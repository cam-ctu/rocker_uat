
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:36:43.121] plan(): Setting new future strategy stack:
[17:36:43.121] List of future strategies:
[17:36:43.121] 1. sequential:
[17:36:43.121]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.121]    - tweaked: FALSE
[17:36:43.121]    - call: future::plan("sequential")
[17:36:43.136] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:36:43.158] plan(): Setting new future strategy stack:
[17:36:43.158] List of future strategies:
[17:36:43.158] 1. sequential:
[17:36:43.158]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.158]    - tweaked: FALSE
[17:36:43.158]    - call: plan(strategy)
[17:36:43.171] plan(): nbrOfWorkers() = 1
[17:36:43.171] future_lapply() ...
[17:36:43.175] Number of chunks: 1
[17:36:43.176] getGlobalsAndPackagesXApply() ...
[17:36:43.176]  - future.globals: TRUE
[17:36:43.177] getGlobalsAndPackages() ...
[17:36:43.177] Searching for globals...
[17:36:43.179] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:43.179] Searching for globals ... DONE
[17:36:43.179] Resolving globals: FALSE
[17:36:43.180] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:43.180] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:43.180] - globals: [1] ‘FUN’
[17:36:43.181] 
[17:36:43.181] getGlobalsAndPackages() ... DONE
[17:36:43.181]  - globals found/used: [n=1] ‘FUN’
[17:36:43.181]  - needed namespaces: [n=0] 
[17:36:43.181] Finding globals ... DONE
[17:36:43.181]  - use_args: TRUE
[17:36:43.181]  - Getting '...' globals ...
[17:36:43.182] resolve() on list ...
[17:36:43.182]  recursive: 0
[17:36:43.182]  length: 1
[17:36:43.182]  elements: ‘...’
[17:36:43.183]  length: 0 (resolved future 1)
[17:36:43.183] resolve() on list ... DONE
[17:36:43.183]    - '...' content: [n=0] 
[17:36:43.183] List of 1
[17:36:43.183]  $ ...: list()
[17:36:43.183]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.183]  - attr(*, "where")=List of 1
[17:36:43.183]   ..$ ...:<environment: 0x565502704d78> 
[17:36:43.183]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.183]  - attr(*, "resolved")= logi TRUE
[17:36:43.183]  - attr(*, "total_size")= num NA
[17:36:43.187]  - Getting '...' globals ... DONE
[17:36:43.188] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:43.188] List of 2
[17:36:43.188]  $ ...future.FUN:function (x, ...)  
[17:36:43.188]  $ ...          : list()
[17:36:43.188]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.188]  - attr(*, "where")=List of 2
[17:36:43.188]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:43.188]   ..$ ...          :<environment: 0x565502704d78> 
[17:36:43.188]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.188]  - attr(*, "resolved")= logi FALSE
[17:36:43.188]  - attr(*, "total_size")= num 1240
[17:36:43.190] Packages to be attached in all futures: [n=0] 
[17:36:43.191] getGlobalsAndPackagesXApply() ... DONE
[17:36:43.191] Number of futures (= number of chunks): 1
[17:36:43.191] Launching 1 futures (chunks) ...
[17:36:43.191] Chunk #1 of 1 ...
[17:36:43.191]  - Finding globals in 'X' for chunk #1 ...
[17:36:43.191] getGlobalsAndPackages() ...
[17:36:43.191] Searching for globals...
[17:36:43.192] 
[17:36:43.192] Searching for globals ... DONE
[17:36:43.192] - globals: [0] <none>
[17:36:43.192] getGlobalsAndPackages() ... DONE
[17:36:43.192]    + additional globals found: [n=0] 
[17:36:43.192]    + additional namespaces needed: [n=0] 
[17:36:43.192]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:43.192]  - seeds: <none>
[17:36:43.192]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.193] getGlobalsAndPackages() ...
[17:36:43.193] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.193] Resolving globals: FALSE
[17:36:43.193] Tweak future expression to call with '...' arguments ...
[17:36:43.193] {
[17:36:43.193]     do.call(function(...) {
[17:36:43.193]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.193]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.193]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.193]             on.exit(options(oopts), add = TRUE)
[17:36:43.193]         }
[17:36:43.193]         {
[17:36:43.193]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.193]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.193]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.193]             })
[17:36:43.193]         }
[17:36:43.193]     }, args = future.call.arguments)
[17:36:43.193] }
[17:36:43.193] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.194] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.194] 
[17:36:43.194] getGlobalsAndPackages() ... DONE
[17:36:43.195] run() for ‘Future’ ...
[17:36:43.195] - state: ‘created’
[17:36:43.195] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:43.195] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:43.195] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:43.195]   - Field: ‘label’
[17:36:43.196]   - Field: ‘local’
[17:36:43.196]   - Field: ‘owner’
[17:36:43.196]   - Field: ‘envir’
[17:36:43.196]   - Field: ‘packages’
[17:36:43.196]   - Field: ‘gc’
[17:36:43.196]   - Field: ‘conditions’
[17:36:43.196]   - Field: ‘expr’
[17:36:43.196]   - Field: ‘uuid’
[17:36:43.196]   - Field: ‘seed’
[17:36:43.196]   - Field: ‘version’
[17:36:43.196]   - Field: ‘result’
[17:36:43.197]   - Field: ‘asynchronous’
[17:36:43.197]   - Field: ‘calls’
[17:36:43.197]   - Field: ‘globals’
[17:36:43.197]   - Field: ‘stdout’
[17:36:43.197]   - Field: ‘earlySignal’
[17:36:43.197]   - Field: ‘lazy’
[17:36:43.197]   - Field: ‘state’
[17:36:43.197] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:43.197] - Launch lazy future ...
[17:36:43.198] Packages needed by the future expression (n = 0): <none>
[17:36:43.198] Packages needed by future strategies (n = 0): <none>
[17:36:43.199] {
[17:36:43.199]     {
[17:36:43.199]         {
[17:36:43.199]             ...future.startTime <- base::Sys.time()
[17:36:43.199]             {
[17:36:43.199]                 {
[17:36:43.199]                   {
[17:36:43.199]                     base::local({
[17:36:43.199]                       has_future <- base::requireNamespace("future", 
[17:36:43.199]                         quietly = TRUE)
[17:36:43.199]                       if (has_future) {
[17:36:43.199]                         ns <- base::getNamespace("future")
[17:36:43.199]                         version <- ns[[".package"]][["version"]]
[17:36:43.199]                         if (is.null(version)) 
[17:36:43.199]                           version <- utils::packageVersion("future")
[17:36:43.199]                       }
[17:36:43.199]                       else {
[17:36:43.199]                         version <- NULL
[17:36:43.199]                       }
[17:36:43.199]                       if (!has_future || version < "1.8.0") {
[17:36:43.199]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.199]                           "", base::R.version$version.string), 
[17:36:43.199]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:43.199]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:43.199]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.199]                             "release", "version")], collapse = " "), 
[17:36:43.199]                           hostname = base::Sys.info()[["nodename"]])
[17:36:43.199]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.199]                           info)
[17:36:43.199]                         info <- base::paste(info, collapse = "; ")
[17:36:43.199]                         if (!has_future) {
[17:36:43.199]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.199]                             info)
[17:36:43.199]                         }
[17:36:43.199]                         else {
[17:36:43.199]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.199]                             info, version)
[17:36:43.199]                         }
[17:36:43.199]                         base::stop(msg)
[17:36:43.199]                       }
[17:36:43.199]                     })
[17:36:43.199]                   }
[17:36:43.199]                   ...future.strategy.old <- future::plan("list")
[17:36:43.199]                   options(future.plan = NULL)
[17:36:43.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.199]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.199]                 }
[17:36:43.199]                 ...future.workdir <- getwd()
[17:36:43.199]             }
[17:36:43.199]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.199]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.199]         }
[17:36:43.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.199]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:43.199]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.199]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.199]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.199]             base::names(...future.oldOptions))
[17:36:43.199]     }
[17:36:43.199]     if (FALSE) {
[17:36:43.199]     }
[17:36:43.199]     else {
[17:36:43.199]         if (TRUE) {
[17:36:43.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.199]                 open = "w")
[17:36:43.199]         }
[17:36:43.199]         else {
[17:36:43.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.199]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.199]         }
[17:36:43.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.199]             base::sink(type = "output", split = FALSE)
[17:36:43.199]             base::close(...future.stdout)
[17:36:43.199]         }, add = TRUE)
[17:36:43.199]     }
[17:36:43.199]     ...future.frame <- base::sys.nframe()
[17:36:43.199]     ...future.conditions <- base::list()
[17:36:43.199]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.199]     if (FALSE) {
[17:36:43.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.199]     }
[17:36:43.199]     ...future.result <- base::tryCatch({
[17:36:43.199]         base::withCallingHandlers({
[17:36:43.199]             ...future.value <- base::withVisible(base::local({
[17:36:43.199]                 do.call(function(...) {
[17:36:43.199]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.199]                   if (!identical(...future.globals.maxSize.org, 
[17:36:43.199]                     ...future.globals.maxSize)) {
[17:36:43.199]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.199]                     on.exit(options(oopts), add = TRUE)
[17:36:43.199]                   }
[17:36:43.199]                   {
[17:36:43.199]                     lapply(seq_along(...future.elements_ii), 
[17:36:43.199]                       FUN = function(jj) {
[17:36:43.199]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.199]                         ...future.FUN(...future.X_jj, ...)
[17:36:43.199]                       })
[17:36:43.199]                   }
[17:36:43.199]                 }, args = future.call.arguments)
[17:36:43.199]             }))
[17:36:43.199]             future::FutureResult(value = ...future.value$value, 
[17:36:43.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.199]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.199]                     ...future.globalenv.names))
[17:36:43.199]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.199]         }, condition = base::local({
[17:36:43.199]             c <- base::c
[17:36:43.199]             inherits <- base::inherits
[17:36:43.199]             invokeRestart <- base::invokeRestart
[17:36:43.199]             length <- base::length
[17:36:43.199]             list <- base::list
[17:36:43.199]             seq.int <- base::seq.int
[17:36:43.199]             signalCondition <- base::signalCondition
[17:36:43.199]             sys.calls <- base::sys.calls
[17:36:43.199]             `[[` <- base::`[[`
[17:36:43.199]             `+` <- base::`+`
[17:36:43.199]             `<<-` <- base::`<<-`
[17:36:43.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.199]                   3L)]
[17:36:43.199]             }
[17:36:43.199]             function(cond) {
[17:36:43.199]                 is_error <- inherits(cond, "error")
[17:36:43.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.199]                   NULL)
[17:36:43.199]                 if (is_error) {
[17:36:43.199]                   sessionInformation <- function() {
[17:36:43.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.199]                       search = base::search(), system = base::Sys.info())
[17:36:43.199]                   }
[17:36:43.199]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.199]                     cond$call), session = sessionInformation(), 
[17:36:43.199]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.199]                   signalCondition(cond)
[17:36:43.199]                 }
[17:36:43.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.199]                 "immediateCondition"))) {
[17:36:43.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.199]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.199]                   if (TRUE && !signal) {
[17:36:43.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.199]                     {
[17:36:43.199]                       inherits <- base::inherits
[17:36:43.199]                       invokeRestart <- base::invokeRestart
[17:36:43.199]                       is.null <- base::is.null
[17:36:43.199]                       muffled <- FALSE
[17:36:43.199]                       if (inherits(cond, "message")) {
[17:36:43.199]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.199]                         if (muffled) 
[17:36:43.199]                           invokeRestart("muffleMessage")
[17:36:43.199]                       }
[17:36:43.199]                       else if (inherits(cond, "warning")) {
[17:36:43.199]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.199]                         if (muffled) 
[17:36:43.199]                           invokeRestart("muffleWarning")
[17:36:43.199]                       }
[17:36:43.199]                       else if (inherits(cond, "condition")) {
[17:36:43.199]                         if (!is.null(pattern)) {
[17:36:43.199]                           computeRestarts <- base::computeRestarts
[17:36:43.199]                           grepl <- base::grepl
[17:36:43.199]                           restarts <- computeRestarts(cond)
[17:36:43.199]                           for (restart in restarts) {
[17:36:43.199]                             name <- restart$name
[17:36:43.199]                             if (is.null(name)) 
[17:36:43.199]                               next
[17:36:43.199]                             if (!grepl(pattern, name)) 
[17:36:43.199]                               next
[17:36:43.199]                             invokeRestart(restart)
[17:36:43.199]                             muffled <- TRUE
[17:36:43.199]                             break
[17:36:43.199]                           }
[17:36:43.199]                         }
[17:36:43.199]                       }
[17:36:43.199]                       invisible(muffled)
[17:36:43.199]                     }
[17:36:43.199]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.199]                   }
[17:36:43.199]                 }
[17:36:43.199]                 else {
[17:36:43.199]                   if (TRUE) {
[17:36:43.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.199]                     {
[17:36:43.199]                       inherits <- base::inherits
[17:36:43.199]                       invokeRestart <- base::invokeRestart
[17:36:43.199]                       is.null <- base::is.null
[17:36:43.199]                       muffled <- FALSE
[17:36:43.199]                       if (inherits(cond, "message")) {
[17:36:43.199]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.199]                         if (muffled) 
[17:36:43.199]                           invokeRestart("muffleMessage")
[17:36:43.199]                       }
[17:36:43.199]                       else if (inherits(cond, "warning")) {
[17:36:43.199]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.199]                         if (muffled) 
[17:36:43.199]                           invokeRestart("muffleWarning")
[17:36:43.199]                       }
[17:36:43.199]                       else if (inherits(cond, "condition")) {
[17:36:43.199]                         if (!is.null(pattern)) {
[17:36:43.199]                           computeRestarts <- base::computeRestarts
[17:36:43.199]                           grepl <- base::grepl
[17:36:43.199]                           restarts <- computeRestarts(cond)
[17:36:43.199]                           for (restart in restarts) {
[17:36:43.199]                             name <- restart$name
[17:36:43.199]                             if (is.null(name)) 
[17:36:43.199]                               next
[17:36:43.199]                             if (!grepl(pattern, name)) 
[17:36:43.199]                               next
[17:36:43.199]                             invokeRestart(restart)
[17:36:43.199]                             muffled <- TRUE
[17:36:43.199]                             break
[17:36:43.199]                           }
[17:36:43.199]                         }
[17:36:43.199]                       }
[17:36:43.199]                       invisible(muffled)
[17:36:43.199]                     }
[17:36:43.199]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.199]                   }
[17:36:43.199]                 }
[17:36:43.199]             }
[17:36:43.199]         }))
[17:36:43.199]     }, error = function(ex) {
[17:36:43.199]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.199]                 ...future.rng), started = ...future.startTime, 
[17:36:43.199]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.199]             version = "1.8"), class = "FutureResult")
[17:36:43.199]     }, finally = {
[17:36:43.199]         if (!identical(...future.workdir, getwd())) 
[17:36:43.199]             setwd(...future.workdir)
[17:36:43.199]         {
[17:36:43.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.199]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.199]             }
[17:36:43.199]             base::options(...future.oldOptions)
[17:36:43.199]             if (.Platform$OS.type == "windows") {
[17:36:43.199]                 old_names <- names(...future.oldEnvVars)
[17:36:43.199]                 envs <- base::Sys.getenv()
[17:36:43.199]                 names <- names(envs)
[17:36:43.199]                 common <- intersect(names, old_names)
[17:36:43.199]                 added <- setdiff(names, old_names)
[17:36:43.199]                 removed <- setdiff(old_names, names)
[17:36:43.199]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.199]                   envs[common]]
[17:36:43.199]                 NAMES <- toupper(changed)
[17:36:43.199]                 args <- list()
[17:36:43.199]                 for (kk in seq_along(NAMES)) {
[17:36:43.199]                   name <- changed[[kk]]
[17:36:43.199]                   NAME <- NAMES[[kk]]
[17:36:43.199]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.199]                     next
[17:36:43.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.199]                 }
[17:36:43.199]                 NAMES <- toupper(added)
[17:36:43.199]                 for (kk in seq_along(NAMES)) {
[17:36:43.199]                   name <- added[[kk]]
[17:36:43.199]                   NAME <- NAMES[[kk]]
[17:36:43.199]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.199]                     next
[17:36:43.199]                   args[[name]] <- ""
[17:36:43.199]                 }
[17:36:43.199]                 NAMES <- toupper(removed)
[17:36:43.199]                 for (kk in seq_along(NAMES)) {
[17:36:43.199]                   name <- removed[[kk]]
[17:36:43.199]                   NAME <- NAMES[[kk]]
[17:36:43.199]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.199]                     next
[17:36:43.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.199]                 }
[17:36:43.199]                 if (length(args) > 0) 
[17:36:43.199]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.199]             }
[17:36:43.199]             else {
[17:36:43.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.199]             }
[17:36:43.199]             {
[17:36:43.199]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.199]                   0L) {
[17:36:43.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.199]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.199]                   base::options(opts)
[17:36:43.199]                 }
[17:36:43.199]                 {
[17:36:43.199]                   {
[17:36:43.199]                     NULL
[17:36:43.199]                     RNGkind("Mersenne-Twister")
[17:36:43.199]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:43.199]                       inherits = FALSE)
[17:36:43.199]                   }
[17:36:43.199]                   options(future.plan = NULL)
[17:36:43.199]                   if (is.na(NA_character_)) 
[17:36:43.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.199]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.199]                     .init = FALSE)
[17:36:43.199]                 }
[17:36:43.199]             }
[17:36:43.199]         }
[17:36:43.199]     })
[17:36:43.199]     if (TRUE) {
[17:36:43.199]         base::sink(type = "output", split = FALSE)
[17:36:43.199]         if (TRUE) {
[17:36:43.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.199]         }
[17:36:43.199]         else {
[17:36:43.199]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.199]         }
[17:36:43.199]         base::close(...future.stdout)
[17:36:43.199]         ...future.stdout <- NULL
[17:36:43.199]     }
[17:36:43.199]     ...future.result$conditions <- ...future.conditions
[17:36:43.199]     ...future.result$finished <- base::Sys.time()
[17:36:43.199]     ...future.result
[17:36:43.199] }
[17:36:43.201] assign_globals() ...
[17:36:43.201] List of 5
[17:36:43.201]  $ ...future.FUN            :function (x, ...)  
[17:36:43.201]  $ future.call.arguments    : list()
[17:36:43.201]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.201]  $ ...future.elements_ii    :List of 3
[17:36:43.201]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[17:36:43.201]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:36:43.201]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:36:43.201]  $ ...future.seeds_ii       : NULL
[17:36:43.201]  $ ...future.globals.maxSize: NULL
[17:36:43.201]  - attr(*, "where")=List of 5
[17:36:43.201]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.201]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.201]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.201]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.201]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.201]  - attr(*, "resolved")= logi FALSE
[17:36:43.201]  - attr(*, "total_size")= num 1240
[17:36:43.201]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.201]  - attr(*, "already-done")= logi TRUE
[17:36:43.209] - copied ‘...future.FUN’ to environment
[17:36:43.209] - copied ‘future.call.arguments’ to environment
[17:36:43.209] - copied ‘...future.elements_ii’ to environment
[17:36:43.209] - copied ‘...future.seeds_ii’ to environment
[17:36:43.210] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.210] assign_globals() ... done
[17:36:43.210] plan(): Setting new future strategy stack:
[17:36:43.210] List of future strategies:
[17:36:43.210] 1. sequential:
[17:36:43.210]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.210]    - tweaked: FALSE
[17:36:43.210]    - call: NULL
[17:36:43.210] plan(): nbrOfWorkers() = 1
[17:36:43.212] plan(): Setting new future strategy stack:
[17:36:43.212] List of future strategies:
[17:36:43.212] 1. sequential:
[17:36:43.212]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.212]    - tweaked: FALSE
[17:36:43.212]    - call: plan(strategy)
[17:36:43.212] plan(): nbrOfWorkers() = 1
[17:36:43.212] SequentialFuture started (and completed)
[17:36:43.213] - Launch lazy future ... done
[17:36:43.213] run() for ‘SequentialFuture’ ... done
[17:36:43.213] Created future:
[17:36:43.213] SequentialFuture:
[17:36:43.213] Label: ‘future_eapply-1’
[17:36:43.213] Expression:
[17:36:43.213] {
[17:36:43.213]     do.call(function(...) {
[17:36:43.213]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.213]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.213]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.213]             on.exit(options(oopts), add = TRUE)
[17:36:43.213]         }
[17:36:43.213]         {
[17:36:43.213]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.213]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.213]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.213]             })
[17:36:43.213]         }
[17:36:43.213]     }, args = future.call.arguments)
[17:36:43.213] }
[17:36:43.213] Lazy evaluation: FALSE
[17:36:43.213] Asynchronous evaluation: FALSE
[17:36:43.213] Local evaluation: TRUE
[17:36:43.213] Environment: R_GlobalEnv
[17:36:43.213] Capture standard output: TRUE
[17:36:43.213] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.213] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.213] Packages: <none>
[17:36:43.213] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.213] Resolved: TRUE
[17:36:43.213] Value: 168 bytes of class ‘list’
[17:36:43.213] Early signaling: FALSE
[17:36:43.213] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.213] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:43.215] Chunk #1 of 1 ... DONE
[17:36:43.215] Launching 1 futures (chunks) ... DONE
[17:36:43.215] Resolving 1 futures (chunks) ...
[17:36:43.215] resolve() on list ...
[17:36:43.215]  recursive: 0
[17:36:43.215]  length: 1
[17:36:43.215] 
[17:36:43.215] resolved() for ‘SequentialFuture’ ...
[17:36:43.216] - state: ‘finished’
[17:36:43.216] - run: TRUE
[17:36:43.216] - result: ‘FutureResult’
[17:36:43.216] resolved() for ‘SequentialFuture’ ... done
[17:36:43.216] Future #1
[17:36:43.216] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:43.216] - nx: 1
[17:36:43.216] - relay: TRUE
[17:36:43.217] - stdout: TRUE
[17:36:43.217] - signal: TRUE
[17:36:43.217] - resignal: FALSE
[17:36:43.217] - force: TRUE
[17:36:43.217] - relayed: [n=1] FALSE
[17:36:43.217] - queued futures: [n=1] FALSE
[17:36:43.217]  - until=1
[17:36:43.217]  - relaying element #1
[17:36:43.217] - relayed: [n=1] TRUE
[17:36:43.217] - queued futures: [n=1] TRUE
[17:36:43.217] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:43.218]  length: 0 (resolved future 1)
[17:36:43.218] Relaying remaining futures
[17:36:43.218] signalConditionsASAP(NULL, pos=0) ...
[17:36:43.218] - nx: 1
[17:36:43.218] - relay: TRUE
[17:36:43.218] - stdout: TRUE
[17:36:43.218] - signal: TRUE
[17:36:43.218] - resignal: FALSE
[17:36:43.218] - force: TRUE
[17:36:43.218] - relayed: [n=1] TRUE
[17:36:43.219] - queued futures: [n=1] TRUE
 - flush all
[17:36:43.219] - relayed: [n=1] TRUE
[17:36:43.219] - queued futures: [n=1] TRUE
[17:36:43.219] signalConditionsASAP(NULL, pos=0) ... done
[17:36:43.219] resolve() on list ... DONE
[17:36:43.219]  - Number of value chunks collected: 1
[17:36:43.219] Resolving 1 futures (chunks) ... DONE
[17:36:43.219] Reducing values from 1 chunks ...
[17:36:43.219]  - Number of values collected after concatenation: 3
[17:36:43.219]  - Number of values expected: 3
[17:36:43.220] Reducing values from 1 chunks ... DONE
[17:36:43.220] future_lapply() ... DONE
[17:36:43.222] future_lapply() ...
[17:36:43.222] Number of chunks: 1
[17:36:43.222] getGlobalsAndPackagesXApply() ...
[17:36:43.222]  - future.globals: TRUE
[17:36:43.222] getGlobalsAndPackages() ...
[17:36:43.222] Searching for globals...
[17:36:43.223] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:43.224] Searching for globals ... DONE
[17:36:43.224] Resolving globals: FALSE
[17:36:43.224] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:43.224] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:43.224] - globals: [1] ‘FUN’
[17:36:43.225] - packages: [1] ‘stats’
[17:36:43.225] getGlobalsAndPackages() ... DONE
[17:36:43.225]  - globals found/used: [n=1] ‘FUN’
[17:36:43.225]  - needed namespaces: [n=1] ‘stats’
[17:36:43.225] Finding globals ... DONE
[17:36:43.225]  - use_args: TRUE
[17:36:43.225]  - Getting '...' globals ...
[17:36:43.225] resolve() on list ...
[17:36:43.225]  recursive: 0
[17:36:43.226]  length: 1
[17:36:43.226]  elements: ‘...’
[17:36:43.226]  length: 0 (resolved future 1)
[17:36:43.226] resolve() on list ... DONE
[17:36:43.226]    - '...' content: [n=1] ‘probs’
[17:36:43.226] List of 1
[17:36:43.226]  $ ...:List of 1
[17:36:43.226]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:36:43.226]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.226]  - attr(*, "where")=List of 1
[17:36:43.226]   ..$ ...:<environment: 0x565504560888> 
[17:36:43.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.226]  - attr(*, "resolved")= logi TRUE
[17:36:43.226]  - attr(*, "total_size")= num NA
[17:36:43.229]  - Getting '...' globals ... DONE
[17:36:43.229] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:43.229] List of 2
[17:36:43.229]  $ ...future.FUN:function (x, ...)  
[17:36:43.229]  $ ...          :List of 1
[17:36:43.229]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:36:43.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.229]  - attr(*, "where")=List of 2
[17:36:43.229]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:43.229]   ..$ ...          :<environment: 0x565504560888> 
[17:36:43.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.229]  - attr(*, "resolved")= logi FALSE
[17:36:43.229]  - attr(*, "total_size")= num 1328
[17:36:43.232] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:43.232] getGlobalsAndPackagesXApply() ... DONE
[17:36:43.232] Number of futures (= number of chunks): 1
[17:36:43.232] Launching 1 futures (chunks) ...
[17:36:43.233] Chunk #1 of 1 ...
[17:36:43.233]  - Finding globals in 'X' for chunk #1 ...
[17:36:43.233] getGlobalsAndPackages() ...
[17:36:43.233] Searching for globals...
[17:36:43.233] 
[17:36:43.233] Searching for globals ... DONE
[17:36:43.233] - globals: [0] <none>
[17:36:43.233] getGlobalsAndPackages() ... DONE
[17:36:43.233]    + additional globals found: [n=0] 
[17:36:43.235]    + additional namespaces needed: [n=0] 
[17:36:43.235]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:43.235]  - seeds: <none>
[17:36:43.235]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.236] getGlobalsAndPackages() ...
[17:36:43.236] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.236] Resolving globals: FALSE
[17:36:43.236] Tweak future expression to call with '...' arguments ...
[17:36:43.236] {
[17:36:43.236]     do.call(function(...) {
[17:36:43.236]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.236]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.236]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.236]             on.exit(options(oopts), add = TRUE)
[17:36:43.236]         }
[17:36:43.236]         {
[17:36:43.236]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.236]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.236]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.236]             })
[17:36:43.236]         }
[17:36:43.236]     }, args = future.call.arguments)
[17:36:43.236] }
[17:36:43.236] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.237] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.237] - packages: [1] ‘stats’
[17:36:43.237] getGlobalsAndPackages() ... DONE
[17:36:43.237] run() for ‘Future’ ...
[17:36:43.237] - state: ‘created’
[17:36:43.237] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:43.238] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:43.238] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:43.238]   - Field: ‘label’
[17:36:43.238]   - Field: ‘local’
[17:36:43.238]   - Field: ‘owner’
[17:36:43.238]   - Field: ‘envir’
[17:36:43.238]   - Field: ‘packages’
[17:36:43.238]   - Field: ‘gc’
[17:36:43.238]   - Field: ‘conditions’
[17:36:43.238]   - Field: ‘expr’
[17:36:43.239]   - Field: ‘uuid’
[17:36:43.239]   - Field: ‘seed’
[17:36:43.239]   - Field: ‘version’
[17:36:43.239]   - Field: ‘result’
[17:36:43.239]   - Field: ‘asynchronous’
[17:36:43.239]   - Field: ‘calls’
[17:36:43.239]   - Field: ‘globals’
[17:36:43.239]   - Field: ‘stdout’
[17:36:43.239]   - Field: ‘earlySignal’
[17:36:43.239]   - Field: ‘lazy’
[17:36:43.239]   - Field: ‘state’
[17:36:43.240] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:43.240] - Launch lazy future ...
[17:36:43.240] Packages needed by the future expression (n = 1): ‘stats’
[17:36:43.240] Packages needed by future strategies (n = 0): <none>
[17:36:43.240] {
[17:36:43.240]     {
[17:36:43.240]         {
[17:36:43.240]             ...future.startTime <- base::Sys.time()
[17:36:43.240]             {
[17:36:43.240]                 {
[17:36:43.240]                   {
[17:36:43.240]                     {
[17:36:43.240]                       base::local({
[17:36:43.240]                         has_future <- base::requireNamespace("future", 
[17:36:43.240]                           quietly = TRUE)
[17:36:43.240]                         if (has_future) {
[17:36:43.240]                           ns <- base::getNamespace("future")
[17:36:43.240]                           version <- ns[[".package"]][["version"]]
[17:36:43.240]                           if (is.null(version)) 
[17:36:43.240]                             version <- utils::packageVersion("future")
[17:36:43.240]                         }
[17:36:43.240]                         else {
[17:36:43.240]                           version <- NULL
[17:36:43.240]                         }
[17:36:43.240]                         if (!has_future || version < "1.8.0") {
[17:36:43.240]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.240]                             "", base::R.version$version.string), 
[17:36:43.240]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:43.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:43.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.240]                               "release", "version")], collapse = " "), 
[17:36:43.240]                             hostname = base::Sys.info()[["nodename"]])
[17:36:43.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.240]                             info)
[17:36:43.240]                           info <- base::paste(info, collapse = "; ")
[17:36:43.240]                           if (!has_future) {
[17:36:43.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.240]                               info)
[17:36:43.240]                           }
[17:36:43.240]                           else {
[17:36:43.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.240]                               info, version)
[17:36:43.240]                           }
[17:36:43.240]                           base::stop(msg)
[17:36:43.240]                         }
[17:36:43.240]                       })
[17:36:43.240]                     }
[17:36:43.240]                     base::local({
[17:36:43.240]                       for (pkg in "stats") {
[17:36:43.240]                         base::loadNamespace(pkg)
[17:36:43.240]                         base::library(pkg, character.only = TRUE)
[17:36:43.240]                       }
[17:36:43.240]                     })
[17:36:43.240]                   }
[17:36:43.240]                   ...future.strategy.old <- future::plan("list")
[17:36:43.240]                   options(future.plan = NULL)
[17:36:43.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.240]                 }
[17:36:43.240]                 ...future.workdir <- getwd()
[17:36:43.240]             }
[17:36:43.240]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.240]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.240]         }
[17:36:43.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:43.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.240]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.240]             base::names(...future.oldOptions))
[17:36:43.240]     }
[17:36:43.240]     if (FALSE) {
[17:36:43.240]     }
[17:36:43.240]     else {
[17:36:43.240]         if (TRUE) {
[17:36:43.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.240]                 open = "w")
[17:36:43.240]         }
[17:36:43.240]         else {
[17:36:43.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.240]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.240]         }
[17:36:43.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.240]             base::sink(type = "output", split = FALSE)
[17:36:43.240]             base::close(...future.stdout)
[17:36:43.240]         }, add = TRUE)
[17:36:43.240]     }
[17:36:43.240]     ...future.frame <- base::sys.nframe()
[17:36:43.240]     ...future.conditions <- base::list()
[17:36:43.240]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.240]     if (FALSE) {
[17:36:43.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.240]     }
[17:36:43.240]     ...future.result <- base::tryCatch({
[17:36:43.240]         base::withCallingHandlers({
[17:36:43.240]             ...future.value <- base::withVisible(base::local({
[17:36:43.240]                 do.call(function(...) {
[17:36:43.240]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.240]                   if (!identical(...future.globals.maxSize.org, 
[17:36:43.240]                     ...future.globals.maxSize)) {
[17:36:43.240]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.240]                     on.exit(options(oopts), add = TRUE)
[17:36:43.240]                   }
[17:36:43.240]                   {
[17:36:43.240]                     lapply(seq_along(...future.elements_ii), 
[17:36:43.240]                       FUN = function(jj) {
[17:36:43.240]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.240]                         ...future.FUN(...future.X_jj, ...)
[17:36:43.240]                       })
[17:36:43.240]                   }
[17:36:43.240]                 }, args = future.call.arguments)
[17:36:43.240]             }))
[17:36:43.240]             future::FutureResult(value = ...future.value$value, 
[17:36:43.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.240]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.240]                     ...future.globalenv.names))
[17:36:43.240]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.240]         }, condition = base::local({
[17:36:43.240]             c <- base::c
[17:36:43.240]             inherits <- base::inherits
[17:36:43.240]             invokeRestart <- base::invokeRestart
[17:36:43.240]             length <- base::length
[17:36:43.240]             list <- base::list
[17:36:43.240]             seq.int <- base::seq.int
[17:36:43.240]             signalCondition <- base::signalCondition
[17:36:43.240]             sys.calls <- base::sys.calls
[17:36:43.240]             `[[` <- base::`[[`
[17:36:43.240]             `+` <- base::`+`
[17:36:43.240]             `<<-` <- base::`<<-`
[17:36:43.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.240]                   3L)]
[17:36:43.240]             }
[17:36:43.240]             function(cond) {
[17:36:43.240]                 is_error <- inherits(cond, "error")
[17:36:43.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.240]                   NULL)
[17:36:43.240]                 if (is_error) {
[17:36:43.240]                   sessionInformation <- function() {
[17:36:43.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.240]                       search = base::search(), system = base::Sys.info())
[17:36:43.240]                   }
[17:36:43.240]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.240]                     cond$call), session = sessionInformation(), 
[17:36:43.240]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.240]                   signalCondition(cond)
[17:36:43.240]                 }
[17:36:43.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.240]                 "immediateCondition"))) {
[17:36:43.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.240]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.240]                   if (TRUE && !signal) {
[17:36:43.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.240]                     {
[17:36:43.240]                       inherits <- base::inherits
[17:36:43.240]                       invokeRestart <- base::invokeRestart
[17:36:43.240]                       is.null <- base::is.null
[17:36:43.240]                       muffled <- FALSE
[17:36:43.240]                       if (inherits(cond, "message")) {
[17:36:43.240]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.240]                         if (muffled) 
[17:36:43.240]                           invokeRestart("muffleMessage")
[17:36:43.240]                       }
[17:36:43.240]                       else if (inherits(cond, "warning")) {
[17:36:43.240]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.240]                         if (muffled) 
[17:36:43.240]                           invokeRestart("muffleWarning")
[17:36:43.240]                       }
[17:36:43.240]                       else if (inherits(cond, "condition")) {
[17:36:43.240]                         if (!is.null(pattern)) {
[17:36:43.240]                           computeRestarts <- base::computeRestarts
[17:36:43.240]                           grepl <- base::grepl
[17:36:43.240]                           restarts <- computeRestarts(cond)
[17:36:43.240]                           for (restart in restarts) {
[17:36:43.240]                             name <- restart$name
[17:36:43.240]                             if (is.null(name)) 
[17:36:43.240]                               next
[17:36:43.240]                             if (!grepl(pattern, name)) 
[17:36:43.240]                               next
[17:36:43.240]                             invokeRestart(restart)
[17:36:43.240]                             muffled <- TRUE
[17:36:43.240]                             break
[17:36:43.240]                           }
[17:36:43.240]                         }
[17:36:43.240]                       }
[17:36:43.240]                       invisible(muffled)
[17:36:43.240]                     }
[17:36:43.240]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.240]                   }
[17:36:43.240]                 }
[17:36:43.240]                 else {
[17:36:43.240]                   if (TRUE) {
[17:36:43.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.240]                     {
[17:36:43.240]                       inherits <- base::inherits
[17:36:43.240]                       invokeRestart <- base::invokeRestart
[17:36:43.240]                       is.null <- base::is.null
[17:36:43.240]                       muffled <- FALSE
[17:36:43.240]                       if (inherits(cond, "message")) {
[17:36:43.240]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.240]                         if (muffled) 
[17:36:43.240]                           invokeRestart("muffleMessage")
[17:36:43.240]                       }
[17:36:43.240]                       else if (inherits(cond, "warning")) {
[17:36:43.240]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.240]                         if (muffled) 
[17:36:43.240]                           invokeRestart("muffleWarning")
[17:36:43.240]                       }
[17:36:43.240]                       else if (inherits(cond, "condition")) {
[17:36:43.240]                         if (!is.null(pattern)) {
[17:36:43.240]                           computeRestarts <- base::computeRestarts
[17:36:43.240]                           grepl <- base::grepl
[17:36:43.240]                           restarts <- computeRestarts(cond)
[17:36:43.240]                           for (restart in restarts) {
[17:36:43.240]                             name <- restart$name
[17:36:43.240]                             if (is.null(name)) 
[17:36:43.240]                               next
[17:36:43.240]                             if (!grepl(pattern, name)) 
[17:36:43.240]                               next
[17:36:43.240]                             invokeRestart(restart)
[17:36:43.240]                             muffled <- TRUE
[17:36:43.240]                             break
[17:36:43.240]                           }
[17:36:43.240]                         }
[17:36:43.240]                       }
[17:36:43.240]                       invisible(muffled)
[17:36:43.240]                     }
[17:36:43.240]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.240]                   }
[17:36:43.240]                 }
[17:36:43.240]             }
[17:36:43.240]         }))
[17:36:43.240]     }, error = function(ex) {
[17:36:43.240]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.240]                 ...future.rng), started = ...future.startTime, 
[17:36:43.240]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.240]             version = "1.8"), class = "FutureResult")
[17:36:43.240]     }, finally = {
[17:36:43.240]         if (!identical(...future.workdir, getwd())) 
[17:36:43.240]             setwd(...future.workdir)
[17:36:43.240]         {
[17:36:43.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.240]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.240]             }
[17:36:43.240]             base::options(...future.oldOptions)
[17:36:43.240]             if (.Platform$OS.type == "windows") {
[17:36:43.240]                 old_names <- names(...future.oldEnvVars)
[17:36:43.240]                 envs <- base::Sys.getenv()
[17:36:43.240]                 names <- names(envs)
[17:36:43.240]                 common <- intersect(names, old_names)
[17:36:43.240]                 added <- setdiff(names, old_names)
[17:36:43.240]                 removed <- setdiff(old_names, names)
[17:36:43.240]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.240]                   envs[common]]
[17:36:43.240]                 NAMES <- toupper(changed)
[17:36:43.240]                 args <- list()
[17:36:43.240]                 for (kk in seq_along(NAMES)) {
[17:36:43.240]                   name <- changed[[kk]]
[17:36:43.240]                   NAME <- NAMES[[kk]]
[17:36:43.240]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.240]                     next
[17:36:43.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.240]                 }
[17:36:43.240]                 NAMES <- toupper(added)
[17:36:43.240]                 for (kk in seq_along(NAMES)) {
[17:36:43.240]                   name <- added[[kk]]
[17:36:43.240]                   NAME <- NAMES[[kk]]
[17:36:43.240]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.240]                     next
[17:36:43.240]                   args[[name]] <- ""
[17:36:43.240]                 }
[17:36:43.240]                 NAMES <- toupper(removed)
[17:36:43.240]                 for (kk in seq_along(NAMES)) {
[17:36:43.240]                   name <- removed[[kk]]
[17:36:43.240]                   NAME <- NAMES[[kk]]
[17:36:43.240]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.240]                     next
[17:36:43.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.240]                 }
[17:36:43.240]                 if (length(args) > 0) 
[17:36:43.240]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.240]             }
[17:36:43.240]             else {
[17:36:43.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.240]             }
[17:36:43.240]             {
[17:36:43.240]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.240]                   0L) {
[17:36:43.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.240]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.240]                   base::options(opts)
[17:36:43.240]                 }
[17:36:43.240]                 {
[17:36:43.240]                   {
[17:36:43.240]                     NULL
[17:36:43.240]                     RNGkind("Mersenne-Twister")
[17:36:43.240]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:43.240]                       inherits = FALSE)
[17:36:43.240]                   }
[17:36:43.240]                   options(future.plan = NULL)
[17:36:43.240]                   if (is.na(NA_character_)) 
[17:36:43.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.240]                     .init = FALSE)
[17:36:43.240]                 }
[17:36:43.240]             }
[17:36:43.240]         }
[17:36:43.240]     })
[17:36:43.240]     if (TRUE) {
[17:36:43.240]         base::sink(type = "output", split = FALSE)
[17:36:43.240]         if (TRUE) {
[17:36:43.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.240]         }
[17:36:43.240]         else {
[17:36:43.240]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.240]         }
[17:36:43.240]         base::close(...future.stdout)
[17:36:43.240]         ...future.stdout <- NULL
[17:36:43.240]     }
[17:36:43.240]     ...future.result$conditions <- ...future.conditions
[17:36:43.240]     ...future.result$finished <- base::Sys.time()
[17:36:43.240]     ...future.result
[17:36:43.240] }
[17:36:43.242] assign_globals() ...
[17:36:43.242] List of 5
[17:36:43.242]  $ ...future.FUN            :function (x, ...)  
[17:36:43.242]  $ future.call.arguments    :List of 1
[17:36:43.242]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:36:43.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.242]  $ ...future.elements_ii    :List of 3
[17:36:43.242]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:36:43.242]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:36:43.242]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:36:43.242]  $ ...future.seeds_ii       : NULL
[17:36:43.242]  $ ...future.globals.maxSize: NULL
[17:36:43.242]  - attr(*, "where")=List of 5
[17:36:43.242]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.242]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.242]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.242]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.242]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.242]  - attr(*, "resolved")= logi FALSE
[17:36:43.242]  - attr(*, "total_size")= num 1328
[17:36:43.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.242]  - attr(*, "already-done")= logi TRUE
[17:36:43.248] - copied ‘...future.FUN’ to environment
[17:36:43.248] - copied ‘future.call.arguments’ to environment
[17:36:43.248] - copied ‘...future.elements_ii’ to environment
[17:36:43.248] - copied ‘...future.seeds_ii’ to environment
[17:36:43.248] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.248] assign_globals() ... done
[17:36:43.248] plan(): Setting new future strategy stack:
[17:36:43.249] List of future strategies:
[17:36:43.249] 1. sequential:
[17:36:43.249]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.249]    - tweaked: FALSE
[17:36:43.249]    - call: NULL
[17:36:43.249] plan(): nbrOfWorkers() = 1
[17:36:43.250] plan(): Setting new future strategy stack:
[17:36:43.250] List of future strategies:
[17:36:43.250] 1. sequential:
[17:36:43.250]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.250]    - tweaked: FALSE
[17:36:43.250]    - call: plan(strategy)
[17:36:43.251] plan(): nbrOfWorkers() = 1
[17:36:43.251] SequentialFuture started (and completed)
[17:36:43.251] - Launch lazy future ... done
[17:36:43.251] run() for ‘SequentialFuture’ ... done
[17:36:43.251] Created future:
[17:36:43.251] SequentialFuture:
[17:36:43.251] Label: ‘future_eapply-1’
[17:36:43.251] Expression:
[17:36:43.251] {
[17:36:43.251]     do.call(function(...) {
[17:36:43.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.251]             on.exit(options(oopts), add = TRUE)
[17:36:43.251]         }
[17:36:43.251]         {
[17:36:43.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.251]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.251]             })
[17:36:43.251]         }
[17:36:43.251]     }, args = future.call.arguments)
[17:36:43.251] }
[17:36:43.251] Lazy evaluation: FALSE
[17:36:43.251] Asynchronous evaluation: FALSE
[17:36:43.251] Local evaluation: TRUE
[17:36:43.251] Environment: R_GlobalEnv
[17:36:43.251] Capture standard output: TRUE
[17:36:43.251] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.251] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.251] Packages: 1 packages (‘stats’)
[17:36:43.251] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.251] Resolved: TRUE
[17:36:43.251] Value: 1.29 KiB of class ‘list’
[17:36:43.251] Early signaling: FALSE
[17:36:43.251] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.251] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:43.252] Chunk #1 of 1 ... DONE
[17:36:43.252] Launching 1 futures (chunks) ... DONE
[17:36:43.252] Resolving 1 futures (chunks) ...
[17:36:43.252] resolve() on list ...
[17:36:43.252]  recursive: 0
[17:36:43.253]  length: 1
[17:36:43.253] 
[17:36:43.253] resolved() for ‘SequentialFuture’ ...
[17:36:43.253] - state: ‘finished’
[17:36:43.253] - run: TRUE
[17:36:43.253] - result: ‘FutureResult’
[17:36:43.253] resolved() for ‘SequentialFuture’ ... done
[17:36:43.253] Future #1
[17:36:43.253] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:43.253] - nx: 1
[17:36:43.254] - relay: TRUE
[17:36:43.254] - stdout: TRUE
[17:36:43.254] - signal: TRUE
[17:36:43.254] - resignal: FALSE
[17:36:43.254] - force: TRUE
[17:36:43.254] - relayed: [n=1] FALSE
[17:36:43.254] - queued futures: [n=1] FALSE
[17:36:43.254]  - until=1
[17:36:43.254]  - relaying element #1
[17:36:43.254] - relayed: [n=1] TRUE
[17:36:43.254] - queued futures: [n=1] TRUE
[17:36:43.255] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:43.255]  length: 0 (resolved future 1)
[17:36:43.255] Relaying remaining futures
[17:36:43.255] signalConditionsASAP(NULL, pos=0) ...
[17:36:43.255] - nx: 1
[17:36:43.255] - relay: TRUE
[17:36:43.255] - stdout: TRUE
[17:36:43.255] - signal: TRUE
[17:36:43.255] - resignal: FALSE
[17:36:43.255] - force: TRUE
[17:36:43.255] - relayed: [n=1] TRUE
[17:36:43.255] - queued futures: [n=1] TRUE
 - flush all
[17:36:43.256] - relayed: [n=1] TRUE
[17:36:43.256] - queued futures: [n=1] TRUE
[17:36:43.256] signalConditionsASAP(NULL, pos=0) ... done
[17:36:43.256] resolve() on list ... DONE
[17:36:43.256]  - Number of value chunks collected: 1
[17:36:43.256] Resolving 1 futures (chunks) ... DONE
[17:36:43.256] Reducing values from 1 chunks ...
[17:36:43.256]  - Number of values collected after concatenation: 3
[17:36:43.256]  - Number of values expected: 3
[17:36:43.256] Reducing values from 1 chunks ... DONE
[17:36:43.256] future_lapply() ... DONE
[17:36:43.258] future_lapply() ...
[17:36:43.258] Number of chunks: 1
[17:36:43.258] getGlobalsAndPackagesXApply() ...
[17:36:43.258]  - future.globals: TRUE
[17:36:43.258] getGlobalsAndPackages() ...
[17:36:43.258] Searching for globals...
[17:36:43.259] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:43.260] Searching for globals ... DONE
[17:36:43.260] Resolving globals: FALSE
[17:36:43.261] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:43.262] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:43.262] - globals: [1] ‘FUN’
[17:36:43.262] - packages: [1] ‘stats’
[17:36:43.262] getGlobalsAndPackages() ... DONE
[17:36:43.262]  - globals found/used: [n=1] ‘FUN’
[17:36:43.262]  - needed namespaces: [n=1] ‘stats’
[17:36:43.262] Finding globals ... DONE
[17:36:43.262]  - use_args: TRUE
[17:36:43.263]  - Getting '...' globals ...
[17:36:43.263] resolve() on list ...
[17:36:43.263]  recursive: 0
[17:36:43.263]  length: 1
[17:36:43.263]  elements: ‘...’
[17:36:43.263]  length: 0 (resolved future 1)
[17:36:43.263] resolve() on list ... DONE
[17:36:43.263]    - '...' content: [n=0] 
[17:36:43.264] List of 1
[17:36:43.264]  $ ...: list()
[17:36:43.264]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.264]  - attr(*, "where")=List of 1
[17:36:43.264]   ..$ ...:<environment: 0x565504bc7298> 
[17:36:43.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.264]  - attr(*, "resolved")= logi TRUE
[17:36:43.264]  - attr(*, "total_size")= num NA
[17:36:43.266]  - Getting '...' globals ... DONE
[17:36:43.266] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:43.266] List of 2
[17:36:43.266]  $ ...future.FUN:function (x, ...)  
[17:36:43.266]  $ ...          : list()
[17:36:43.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.266]  - attr(*, "where")=List of 2
[17:36:43.266]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:43.266]   ..$ ...          :<environment: 0x565504bc7298> 
[17:36:43.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.266]  - attr(*, "resolved")= logi FALSE
[17:36:43.266]  - attr(*, "total_size")= num 1248
[17:36:43.269] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:43.269] getGlobalsAndPackagesXApply() ... DONE
[17:36:43.269] Number of futures (= number of chunks): 1
[17:36:43.269] Launching 1 futures (chunks) ...
[17:36:43.269] Chunk #1 of 1 ...
[17:36:43.269]  - Finding globals in 'X' for chunk #1 ...
[17:36:43.269] getGlobalsAndPackages() ...
[17:36:43.270] Searching for globals...
[17:36:43.270] 
[17:36:43.270] Searching for globals ... DONE
[17:36:43.270] - globals: [0] <none>
[17:36:43.270] getGlobalsAndPackages() ... DONE
[17:36:43.270]    + additional globals found: [n=0] 
[17:36:43.270]    + additional namespaces needed: [n=0] 
[17:36:43.270]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:43.270]  - seeds: <none>
[17:36:43.270]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.271] getGlobalsAndPackages() ...
[17:36:43.271] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.271] Resolving globals: FALSE
[17:36:43.271] Tweak future expression to call with '...' arguments ...
[17:36:43.271] {
[17:36:43.271]     do.call(function(...) {
[17:36:43.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.271]             on.exit(options(oopts), add = TRUE)
[17:36:43.271]         }
[17:36:43.271]         {
[17:36:43.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.271]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.271]             })
[17:36:43.271]         }
[17:36:43.271]     }, args = future.call.arguments)
[17:36:43.271] }
[17:36:43.271] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.272] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.272] - packages: [1] ‘stats’
[17:36:43.272] getGlobalsAndPackages() ... DONE
[17:36:43.272] run() for ‘Future’ ...
[17:36:43.272] - state: ‘created’
[17:36:43.272] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:43.273] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:43.273] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:43.273]   - Field: ‘label’
[17:36:43.273]   - Field: ‘local’
[17:36:43.273]   - Field: ‘owner’
[17:36:43.273]   - Field: ‘envir’
[17:36:43.273]   - Field: ‘packages’
[17:36:43.273]   - Field: ‘gc’
[17:36:43.273]   - Field: ‘conditions’
[17:36:43.273]   - Field: ‘expr’
[17:36:43.273]   - Field: ‘uuid’
[17:36:43.274]   - Field: ‘seed’
[17:36:43.274]   - Field: ‘version’
[17:36:43.274]   - Field: ‘result’
[17:36:43.274]   - Field: ‘asynchronous’
[17:36:43.274]   - Field: ‘calls’
[17:36:43.274]   - Field: ‘globals’
[17:36:43.274]   - Field: ‘stdout’
[17:36:43.274]   - Field: ‘earlySignal’
[17:36:43.274]   - Field: ‘lazy’
[17:36:43.274]   - Field: ‘state’
[17:36:43.274] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:43.274] - Launch lazy future ...
[17:36:43.275] Packages needed by the future expression (n = 1): ‘stats’
[17:36:43.275] Packages needed by future strategies (n = 0): <none>
[17:36:43.275] {
[17:36:43.275]     {
[17:36:43.275]         {
[17:36:43.275]             ...future.startTime <- base::Sys.time()
[17:36:43.275]             {
[17:36:43.275]                 {
[17:36:43.275]                   {
[17:36:43.275]                     {
[17:36:43.275]                       base::local({
[17:36:43.275]                         has_future <- base::requireNamespace("future", 
[17:36:43.275]                           quietly = TRUE)
[17:36:43.275]                         if (has_future) {
[17:36:43.275]                           ns <- base::getNamespace("future")
[17:36:43.275]                           version <- ns[[".package"]][["version"]]
[17:36:43.275]                           if (is.null(version)) 
[17:36:43.275]                             version <- utils::packageVersion("future")
[17:36:43.275]                         }
[17:36:43.275]                         else {
[17:36:43.275]                           version <- NULL
[17:36:43.275]                         }
[17:36:43.275]                         if (!has_future || version < "1.8.0") {
[17:36:43.275]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.275]                             "", base::R.version$version.string), 
[17:36:43.275]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:43.275]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:43.275]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.275]                               "release", "version")], collapse = " "), 
[17:36:43.275]                             hostname = base::Sys.info()[["nodename"]])
[17:36:43.275]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.275]                             info)
[17:36:43.275]                           info <- base::paste(info, collapse = "; ")
[17:36:43.275]                           if (!has_future) {
[17:36:43.275]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.275]                               info)
[17:36:43.275]                           }
[17:36:43.275]                           else {
[17:36:43.275]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.275]                               info, version)
[17:36:43.275]                           }
[17:36:43.275]                           base::stop(msg)
[17:36:43.275]                         }
[17:36:43.275]                       })
[17:36:43.275]                     }
[17:36:43.275]                     base::local({
[17:36:43.275]                       for (pkg in "stats") {
[17:36:43.275]                         base::loadNamespace(pkg)
[17:36:43.275]                         base::library(pkg, character.only = TRUE)
[17:36:43.275]                       }
[17:36:43.275]                     })
[17:36:43.275]                   }
[17:36:43.275]                   ...future.strategy.old <- future::plan("list")
[17:36:43.275]                   options(future.plan = NULL)
[17:36:43.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.275]                 }
[17:36:43.275]                 ...future.workdir <- getwd()
[17:36:43.275]             }
[17:36:43.275]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.275]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.275]         }
[17:36:43.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.275]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:43.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.275]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.275]             base::names(...future.oldOptions))
[17:36:43.275]     }
[17:36:43.275]     if (FALSE) {
[17:36:43.275]     }
[17:36:43.275]     else {
[17:36:43.275]         if (TRUE) {
[17:36:43.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.275]                 open = "w")
[17:36:43.275]         }
[17:36:43.275]         else {
[17:36:43.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.275]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.275]         }
[17:36:43.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.275]             base::sink(type = "output", split = FALSE)
[17:36:43.275]             base::close(...future.stdout)
[17:36:43.275]         }, add = TRUE)
[17:36:43.275]     }
[17:36:43.275]     ...future.frame <- base::sys.nframe()
[17:36:43.275]     ...future.conditions <- base::list()
[17:36:43.275]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.275]     if (FALSE) {
[17:36:43.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.275]     }
[17:36:43.275]     ...future.result <- base::tryCatch({
[17:36:43.275]         base::withCallingHandlers({
[17:36:43.275]             ...future.value <- base::withVisible(base::local({
[17:36:43.275]                 do.call(function(...) {
[17:36:43.275]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.275]                   if (!identical(...future.globals.maxSize.org, 
[17:36:43.275]                     ...future.globals.maxSize)) {
[17:36:43.275]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.275]                     on.exit(options(oopts), add = TRUE)
[17:36:43.275]                   }
[17:36:43.275]                   {
[17:36:43.275]                     lapply(seq_along(...future.elements_ii), 
[17:36:43.275]                       FUN = function(jj) {
[17:36:43.275]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.275]                         ...future.FUN(...future.X_jj, ...)
[17:36:43.275]                       })
[17:36:43.275]                   }
[17:36:43.275]                 }, args = future.call.arguments)
[17:36:43.275]             }))
[17:36:43.275]             future::FutureResult(value = ...future.value$value, 
[17:36:43.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.275]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.275]                     ...future.globalenv.names))
[17:36:43.275]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.275]         }, condition = base::local({
[17:36:43.275]             c <- base::c
[17:36:43.275]             inherits <- base::inherits
[17:36:43.275]             invokeRestart <- base::invokeRestart
[17:36:43.275]             length <- base::length
[17:36:43.275]             list <- base::list
[17:36:43.275]             seq.int <- base::seq.int
[17:36:43.275]             signalCondition <- base::signalCondition
[17:36:43.275]             sys.calls <- base::sys.calls
[17:36:43.275]             `[[` <- base::`[[`
[17:36:43.275]             `+` <- base::`+`
[17:36:43.275]             `<<-` <- base::`<<-`
[17:36:43.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.275]                   3L)]
[17:36:43.275]             }
[17:36:43.275]             function(cond) {
[17:36:43.275]                 is_error <- inherits(cond, "error")
[17:36:43.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.275]                   NULL)
[17:36:43.275]                 if (is_error) {
[17:36:43.275]                   sessionInformation <- function() {
[17:36:43.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.275]                       search = base::search(), system = base::Sys.info())
[17:36:43.275]                   }
[17:36:43.275]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.275]                     cond$call), session = sessionInformation(), 
[17:36:43.275]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.275]                   signalCondition(cond)
[17:36:43.275]                 }
[17:36:43.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.275]                 "immediateCondition"))) {
[17:36:43.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.275]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.275]                   if (TRUE && !signal) {
[17:36:43.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.275]                     {
[17:36:43.275]                       inherits <- base::inherits
[17:36:43.275]                       invokeRestart <- base::invokeRestart
[17:36:43.275]                       is.null <- base::is.null
[17:36:43.275]                       muffled <- FALSE
[17:36:43.275]                       if (inherits(cond, "message")) {
[17:36:43.275]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.275]                         if (muffled) 
[17:36:43.275]                           invokeRestart("muffleMessage")
[17:36:43.275]                       }
[17:36:43.275]                       else if (inherits(cond, "warning")) {
[17:36:43.275]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.275]                         if (muffled) 
[17:36:43.275]                           invokeRestart("muffleWarning")
[17:36:43.275]                       }
[17:36:43.275]                       else if (inherits(cond, "condition")) {
[17:36:43.275]                         if (!is.null(pattern)) {
[17:36:43.275]                           computeRestarts <- base::computeRestarts
[17:36:43.275]                           grepl <- base::grepl
[17:36:43.275]                           restarts <- computeRestarts(cond)
[17:36:43.275]                           for (restart in restarts) {
[17:36:43.275]                             name <- restart$name
[17:36:43.275]                             if (is.null(name)) 
[17:36:43.275]                               next
[17:36:43.275]                             if (!grepl(pattern, name)) 
[17:36:43.275]                               next
[17:36:43.275]                             invokeRestart(restart)
[17:36:43.275]                             muffled <- TRUE
[17:36:43.275]                             break
[17:36:43.275]                           }
[17:36:43.275]                         }
[17:36:43.275]                       }
[17:36:43.275]                       invisible(muffled)
[17:36:43.275]                     }
[17:36:43.275]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.275]                   }
[17:36:43.275]                 }
[17:36:43.275]                 else {
[17:36:43.275]                   if (TRUE) {
[17:36:43.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.275]                     {
[17:36:43.275]                       inherits <- base::inherits
[17:36:43.275]                       invokeRestart <- base::invokeRestart
[17:36:43.275]                       is.null <- base::is.null
[17:36:43.275]                       muffled <- FALSE
[17:36:43.275]                       if (inherits(cond, "message")) {
[17:36:43.275]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.275]                         if (muffled) 
[17:36:43.275]                           invokeRestart("muffleMessage")
[17:36:43.275]                       }
[17:36:43.275]                       else if (inherits(cond, "warning")) {
[17:36:43.275]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.275]                         if (muffled) 
[17:36:43.275]                           invokeRestart("muffleWarning")
[17:36:43.275]                       }
[17:36:43.275]                       else if (inherits(cond, "condition")) {
[17:36:43.275]                         if (!is.null(pattern)) {
[17:36:43.275]                           computeRestarts <- base::computeRestarts
[17:36:43.275]                           grepl <- base::grepl
[17:36:43.275]                           restarts <- computeRestarts(cond)
[17:36:43.275]                           for (restart in restarts) {
[17:36:43.275]                             name <- restart$name
[17:36:43.275]                             if (is.null(name)) 
[17:36:43.275]                               next
[17:36:43.275]                             if (!grepl(pattern, name)) 
[17:36:43.275]                               next
[17:36:43.275]                             invokeRestart(restart)
[17:36:43.275]                             muffled <- TRUE
[17:36:43.275]                             break
[17:36:43.275]                           }
[17:36:43.275]                         }
[17:36:43.275]                       }
[17:36:43.275]                       invisible(muffled)
[17:36:43.275]                     }
[17:36:43.275]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.275]                   }
[17:36:43.275]                 }
[17:36:43.275]             }
[17:36:43.275]         }))
[17:36:43.275]     }, error = function(ex) {
[17:36:43.275]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.275]                 ...future.rng), started = ...future.startTime, 
[17:36:43.275]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.275]             version = "1.8"), class = "FutureResult")
[17:36:43.275]     }, finally = {
[17:36:43.275]         if (!identical(...future.workdir, getwd())) 
[17:36:43.275]             setwd(...future.workdir)
[17:36:43.275]         {
[17:36:43.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.275]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.275]             }
[17:36:43.275]             base::options(...future.oldOptions)
[17:36:43.275]             if (.Platform$OS.type == "windows") {
[17:36:43.275]                 old_names <- names(...future.oldEnvVars)
[17:36:43.275]                 envs <- base::Sys.getenv()
[17:36:43.275]                 names <- names(envs)
[17:36:43.275]                 common <- intersect(names, old_names)
[17:36:43.275]                 added <- setdiff(names, old_names)
[17:36:43.275]                 removed <- setdiff(old_names, names)
[17:36:43.275]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.275]                   envs[common]]
[17:36:43.275]                 NAMES <- toupper(changed)
[17:36:43.275]                 args <- list()
[17:36:43.275]                 for (kk in seq_along(NAMES)) {
[17:36:43.275]                   name <- changed[[kk]]
[17:36:43.275]                   NAME <- NAMES[[kk]]
[17:36:43.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.275]                     next
[17:36:43.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.275]                 }
[17:36:43.275]                 NAMES <- toupper(added)
[17:36:43.275]                 for (kk in seq_along(NAMES)) {
[17:36:43.275]                   name <- added[[kk]]
[17:36:43.275]                   NAME <- NAMES[[kk]]
[17:36:43.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.275]                     next
[17:36:43.275]                   args[[name]] <- ""
[17:36:43.275]                 }
[17:36:43.275]                 NAMES <- toupper(removed)
[17:36:43.275]                 for (kk in seq_along(NAMES)) {
[17:36:43.275]                   name <- removed[[kk]]
[17:36:43.275]                   NAME <- NAMES[[kk]]
[17:36:43.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.275]                     next
[17:36:43.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.275]                 }
[17:36:43.275]                 if (length(args) > 0) 
[17:36:43.275]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.275]             }
[17:36:43.275]             else {
[17:36:43.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.275]             }
[17:36:43.275]             {
[17:36:43.275]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.275]                   0L) {
[17:36:43.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.275]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.275]                   base::options(opts)
[17:36:43.275]                 }
[17:36:43.275]                 {
[17:36:43.275]                   {
[17:36:43.275]                     NULL
[17:36:43.275]                     RNGkind("Mersenne-Twister")
[17:36:43.275]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:43.275]                       inherits = FALSE)
[17:36:43.275]                   }
[17:36:43.275]                   options(future.plan = NULL)
[17:36:43.275]                   if (is.na(NA_character_)) 
[17:36:43.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.275]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.275]                     .init = FALSE)
[17:36:43.275]                 }
[17:36:43.275]             }
[17:36:43.275]         }
[17:36:43.275]     })
[17:36:43.275]     if (TRUE) {
[17:36:43.275]         base::sink(type = "output", split = FALSE)
[17:36:43.275]         if (TRUE) {
[17:36:43.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.275]         }
[17:36:43.275]         else {
[17:36:43.275]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.275]         }
[17:36:43.275]         base::close(...future.stdout)
[17:36:43.275]         ...future.stdout <- NULL
[17:36:43.275]     }
[17:36:43.275]     ...future.result$conditions <- ...future.conditions
[17:36:43.275]     ...future.result$finished <- base::Sys.time()
[17:36:43.275]     ...future.result
[17:36:43.275] }
[17:36:43.277] assign_globals() ...
[17:36:43.277] List of 5
[17:36:43.277]  $ ...future.FUN            :function (x, ...)  
[17:36:43.277]  $ future.call.arguments    : list()
[17:36:43.277]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.277]  $ ...future.elements_ii    :List of 3
[17:36:43.277]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:36:43.277]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:36:43.277]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:36:43.277]  $ ...future.seeds_ii       : NULL
[17:36:43.277]  $ ...future.globals.maxSize: NULL
[17:36:43.277]  - attr(*, "where")=List of 5
[17:36:43.277]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.277]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.277]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.277]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.277]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.277]  - attr(*, "resolved")= logi FALSE
[17:36:43.277]  - attr(*, "total_size")= num 1248
[17:36:43.277]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.277]  - attr(*, "already-done")= logi TRUE
[17:36:43.282] - copied ‘...future.FUN’ to environment
[17:36:43.282] - copied ‘future.call.arguments’ to environment
[17:36:43.282] - copied ‘...future.elements_ii’ to environment
[17:36:43.282] - copied ‘...future.seeds_ii’ to environment
[17:36:43.282] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.282] assign_globals() ... done
[17:36:43.283] plan(): Setting new future strategy stack:
[17:36:43.283] List of future strategies:
[17:36:43.283] 1. sequential:
[17:36:43.283]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.283]    - tweaked: FALSE
[17:36:43.283]    - call: NULL
[17:36:43.283] plan(): nbrOfWorkers() = 1
[17:36:43.284] plan(): Setting new future strategy stack:
[17:36:43.285] List of future strategies:
[17:36:43.285] 1. sequential:
[17:36:43.285]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.285]    - tweaked: FALSE
[17:36:43.285]    - call: plan(strategy)
[17:36:43.285] plan(): nbrOfWorkers() = 1
[17:36:43.287] SequentialFuture started (and completed)
[17:36:43.287] - Launch lazy future ... done
[17:36:43.287] run() for ‘SequentialFuture’ ... done
[17:36:43.287] Created future:
[17:36:43.287] SequentialFuture:
[17:36:43.287] Label: ‘future_eapply-1’
[17:36:43.287] Expression:
[17:36:43.287] {
[17:36:43.287]     do.call(function(...) {
[17:36:43.287]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.287]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.287]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.287]             on.exit(options(oopts), add = TRUE)
[17:36:43.287]         }
[17:36:43.287]         {
[17:36:43.287]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.287]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.287]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.287]             })
[17:36:43.287]         }
[17:36:43.287]     }, args = future.call.arguments)
[17:36:43.287] }
[17:36:43.287] Lazy evaluation: FALSE
[17:36:43.287] Asynchronous evaluation: FALSE
[17:36:43.287] Local evaluation: TRUE
[17:36:43.287] Environment: R_GlobalEnv
[17:36:43.287] Capture standard output: TRUE
[17:36:43.287] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.287] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.287] Packages: 1 packages (‘stats’)
[17:36:43.287] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.287] Resolved: TRUE
[17:36:43.287] Value: 1.71 KiB of class ‘list’
[17:36:43.287] Early signaling: FALSE
[17:36:43.287] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.287] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:43.288] Chunk #1 of 1 ... DONE
[17:36:43.288] Launching 1 futures (chunks) ... DONE
[17:36:43.288] Resolving 1 futures (chunks) ...
[17:36:43.288] resolve() on list ...
[17:36:43.288]  recursive: 0
[17:36:43.288]  length: 1
[17:36:43.289] 
[17:36:43.289] resolved() for ‘SequentialFuture’ ...
[17:36:43.289] - state: ‘finished’
[17:36:43.289] - run: TRUE
[17:36:43.289] - result: ‘FutureResult’
[17:36:43.289] resolved() for ‘SequentialFuture’ ... done
[17:36:43.289] Future #1
[17:36:43.289] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:43.289] - nx: 1
[17:36:43.289] - relay: TRUE
[17:36:43.289] - stdout: TRUE
[17:36:43.290] - signal: TRUE
[17:36:43.290] - resignal: FALSE
[17:36:43.290] - force: TRUE
[17:36:43.290] - relayed: [n=1] FALSE
[17:36:43.290] - queued futures: [n=1] FALSE
[17:36:43.290]  - until=1
[17:36:43.290]  - relaying element #1
[17:36:43.290] - relayed: [n=1] TRUE
[17:36:43.290] - queued futures: [n=1] TRUE
[17:36:43.290] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:43.291]  length: 0 (resolved future 1)
[17:36:43.291] Relaying remaining futures
[17:36:43.291] signalConditionsASAP(NULL, pos=0) ...
[17:36:43.291] - nx: 1
[17:36:43.291] - relay: TRUE
[17:36:43.291] - stdout: TRUE
[17:36:43.291] - signal: TRUE
[17:36:43.291] - resignal: FALSE
[17:36:43.291] - force: TRUE
[17:36:43.291] - relayed: [n=1] TRUE
[17:36:43.291] - queued futures: [n=1] TRUE
 - flush all
[17:36:43.291] - relayed: [n=1] TRUE
[17:36:43.292] - queued futures: [n=1] TRUE
[17:36:43.292] signalConditionsASAP(NULL, pos=0) ... done
[17:36:43.292] resolve() on list ... DONE
[17:36:43.292]  - Number of value chunks collected: 1
[17:36:43.292] Resolving 1 futures (chunks) ... DONE
[17:36:43.292] Reducing values from 1 chunks ...
[17:36:43.292]  - Number of values collected after concatenation: 3
[17:36:43.292]  - Number of values expected: 3
[17:36:43.292] Reducing values from 1 chunks ... DONE
[17:36:43.292] future_lapply() ... DONE
[17:36:43.293] future_lapply() ...
[17:36:43.293] Number of chunks: 1
[17:36:43.293] getGlobalsAndPackagesXApply() ...
[17:36:43.293]  - future.globals: TRUE
[17:36:43.293] getGlobalsAndPackages() ...
[17:36:43.293] Searching for globals...
[17:36:43.294] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:43.294] Searching for globals ... DONE
[17:36:43.295] Resolving globals: FALSE
[17:36:43.295] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:43.295] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:43.295] - globals: [1] ‘FUN’
[17:36:43.296] - packages: [1] ‘stats’
[17:36:43.296] getGlobalsAndPackages() ... DONE
[17:36:43.296]  - globals found/used: [n=1] ‘FUN’
[17:36:43.296]  - needed namespaces: [n=1] ‘stats’
[17:36:43.296] Finding globals ... DONE
[17:36:43.296]  - use_args: TRUE
[17:36:43.296]  - Getting '...' globals ...
[17:36:43.296] resolve() on list ...
[17:36:43.296]  recursive: 0
[17:36:43.297]  length: 1
[17:36:43.297]  elements: ‘...’
[17:36:43.297]  length: 0 (resolved future 1)
[17:36:43.297] resolve() on list ... DONE
[17:36:43.297]    - '...' content: [n=0] 
[17:36:43.297] List of 1
[17:36:43.297]  $ ...: list()
[17:36:43.297]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.297]  - attr(*, "where")=List of 1
[17:36:43.297]   ..$ ...:<environment: 0x5655038f7238> 
[17:36:43.297]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.297]  - attr(*, "resolved")= logi TRUE
[17:36:43.297]  - attr(*, "total_size")= num NA
[17:36:43.299]  - Getting '...' globals ... DONE
[17:36:43.300] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:43.300] List of 2
[17:36:43.300]  $ ...future.FUN:function (x, ...)  
[17:36:43.300]  $ ...          : list()
[17:36:43.300]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.300]  - attr(*, "where")=List of 2
[17:36:43.300]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:43.300]   ..$ ...          :<environment: 0x5655038f7238> 
[17:36:43.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.300]  - attr(*, "resolved")= logi FALSE
[17:36:43.300]  - attr(*, "total_size")= num 1248
[17:36:43.302] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:43.302] getGlobalsAndPackagesXApply() ... DONE
[17:36:43.302] Number of futures (= number of chunks): 1
[17:36:43.303] Launching 1 futures (chunks) ...
[17:36:43.303] Chunk #1 of 1 ...
[17:36:43.303]  - Finding globals in 'X' for chunk #1 ...
[17:36:43.303] getGlobalsAndPackages() ...
[17:36:43.303] Searching for globals...
[17:36:43.303] 
[17:36:43.303] Searching for globals ... DONE
[17:36:43.303] - globals: [0] <none>
[17:36:43.303] getGlobalsAndPackages() ... DONE
[17:36:43.303]    + additional globals found: [n=0] 
[17:36:43.304]    + additional namespaces needed: [n=0] 
[17:36:43.304]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:43.304]  - seeds: <none>
[17:36:43.304]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.304] getGlobalsAndPackages() ...
[17:36:43.304] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.304] Resolving globals: FALSE
[17:36:43.304] Tweak future expression to call with '...' arguments ...
[17:36:43.304] {
[17:36:43.304]     do.call(function(...) {
[17:36:43.304]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.304]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.304]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.304]             on.exit(options(oopts), add = TRUE)
[17:36:43.304]         }
[17:36:43.304]         {
[17:36:43.304]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.304]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.304]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.304]             })
[17:36:43.304]         }
[17:36:43.304]     }, args = future.call.arguments)
[17:36:43.304] }
[17:36:43.305] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.305] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.305] - packages: [1] ‘stats’
[17:36:43.305] getGlobalsAndPackages() ... DONE
[17:36:43.305] run() for ‘Future’ ...
[17:36:43.305] - state: ‘created’
[17:36:43.306] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:43.306] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:43.306] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:43.306]   - Field: ‘label’
[17:36:43.306]   - Field: ‘local’
[17:36:43.306]   - Field: ‘owner’
[17:36:43.306]   - Field: ‘envir’
[17:36:43.306]   - Field: ‘packages’
[17:36:43.307]   - Field: ‘gc’
[17:36:43.307]   - Field: ‘conditions’
[17:36:43.307]   - Field: ‘expr’
[17:36:43.307]   - Field: ‘uuid’
[17:36:43.307]   - Field: ‘seed’
[17:36:43.307]   - Field: ‘version’
[17:36:43.307]   - Field: ‘result’
[17:36:43.307]   - Field: ‘asynchronous’
[17:36:43.307]   - Field: ‘calls’
[17:36:43.307]   - Field: ‘globals’
[17:36:43.307]   - Field: ‘stdout’
[17:36:43.307]   - Field: ‘earlySignal’
[17:36:43.308]   - Field: ‘lazy’
[17:36:43.308]   - Field: ‘state’
[17:36:43.308] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:43.308] - Launch lazy future ...
[17:36:43.308] Packages needed by the future expression (n = 1): ‘stats’
[17:36:43.308] Packages needed by future strategies (n = 0): <none>
[17:36:43.309] {
[17:36:43.309]     {
[17:36:43.309]         {
[17:36:43.309]             ...future.startTime <- base::Sys.time()
[17:36:43.309]             {
[17:36:43.309]                 {
[17:36:43.309]                   {
[17:36:43.309]                     {
[17:36:43.309]                       base::local({
[17:36:43.309]                         has_future <- base::requireNamespace("future", 
[17:36:43.309]                           quietly = TRUE)
[17:36:43.309]                         if (has_future) {
[17:36:43.309]                           ns <- base::getNamespace("future")
[17:36:43.309]                           version <- ns[[".package"]][["version"]]
[17:36:43.309]                           if (is.null(version)) 
[17:36:43.309]                             version <- utils::packageVersion("future")
[17:36:43.309]                         }
[17:36:43.309]                         else {
[17:36:43.309]                           version <- NULL
[17:36:43.309]                         }
[17:36:43.309]                         if (!has_future || version < "1.8.0") {
[17:36:43.309]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.309]                             "", base::R.version$version.string), 
[17:36:43.309]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:43.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:43.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.309]                               "release", "version")], collapse = " "), 
[17:36:43.309]                             hostname = base::Sys.info()[["nodename"]])
[17:36:43.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.309]                             info)
[17:36:43.309]                           info <- base::paste(info, collapse = "; ")
[17:36:43.309]                           if (!has_future) {
[17:36:43.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.309]                               info)
[17:36:43.309]                           }
[17:36:43.309]                           else {
[17:36:43.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.309]                               info, version)
[17:36:43.309]                           }
[17:36:43.309]                           base::stop(msg)
[17:36:43.309]                         }
[17:36:43.309]                       })
[17:36:43.309]                     }
[17:36:43.309]                     base::local({
[17:36:43.309]                       for (pkg in "stats") {
[17:36:43.309]                         base::loadNamespace(pkg)
[17:36:43.309]                         base::library(pkg, character.only = TRUE)
[17:36:43.309]                       }
[17:36:43.309]                     })
[17:36:43.309]                   }
[17:36:43.309]                   ...future.strategy.old <- future::plan("list")
[17:36:43.309]                   options(future.plan = NULL)
[17:36:43.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.309]                 }
[17:36:43.309]                 ...future.workdir <- getwd()
[17:36:43.309]             }
[17:36:43.309]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.309]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.309]         }
[17:36:43.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.309]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:43.309]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.309]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.309]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.309]             base::names(...future.oldOptions))
[17:36:43.309]     }
[17:36:43.309]     if (FALSE) {
[17:36:43.309]     }
[17:36:43.309]     else {
[17:36:43.309]         if (TRUE) {
[17:36:43.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.309]                 open = "w")
[17:36:43.309]         }
[17:36:43.309]         else {
[17:36:43.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.309]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.309]         }
[17:36:43.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.309]             base::sink(type = "output", split = FALSE)
[17:36:43.309]             base::close(...future.stdout)
[17:36:43.309]         }, add = TRUE)
[17:36:43.309]     }
[17:36:43.309]     ...future.frame <- base::sys.nframe()
[17:36:43.309]     ...future.conditions <- base::list()
[17:36:43.309]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.309]     if (FALSE) {
[17:36:43.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.309]     }
[17:36:43.309]     ...future.result <- base::tryCatch({
[17:36:43.309]         base::withCallingHandlers({
[17:36:43.309]             ...future.value <- base::withVisible(base::local({
[17:36:43.309]                 do.call(function(...) {
[17:36:43.309]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.309]                   if (!identical(...future.globals.maxSize.org, 
[17:36:43.309]                     ...future.globals.maxSize)) {
[17:36:43.309]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.309]                     on.exit(options(oopts), add = TRUE)
[17:36:43.309]                   }
[17:36:43.309]                   {
[17:36:43.309]                     lapply(seq_along(...future.elements_ii), 
[17:36:43.309]                       FUN = function(jj) {
[17:36:43.309]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.309]                         ...future.FUN(...future.X_jj, ...)
[17:36:43.309]                       })
[17:36:43.309]                   }
[17:36:43.309]                 }, args = future.call.arguments)
[17:36:43.309]             }))
[17:36:43.309]             future::FutureResult(value = ...future.value$value, 
[17:36:43.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.309]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.309]                     ...future.globalenv.names))
[17:36:43.309]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.309]         }, condition = base::local({
[17:36:43.309]             c <- base::c
[17:36:43.309]             inherits <- base::inherits
[17:36:43.309]             invokeRestart <- base::invokeRestart
[17:36:43.309]             length <- base::length
[17:36:43.309]             list <- base::list
[17:36:43.309]             seq.int <- base::seq.int
[17:36:43.309]             signalCondition <- base::signalCondition
[17:36:43.309]             sys.calls <- base::sys.calls
[17:36:43.309]             `[[` <- base::`[[`
[17:36:43.309]             `+` <- base::`+`
[17:36:43.309]             `<<-` <- base::`<<-`
[17:36:43.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.309]                   3L)]
[17:36:43.309]             }
[17:36:43.309]             function(cond) {
[17:36:43.309]                 is_error <- inherits(cond, "error")
[17:36:43.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.309]                   NULL)
[17:36:43.309]                 if (is_error) {
[17:36:43.309]                   sessionInformation <- function() {
[17:36:43.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.309]                       search = base::search(), system = base::Sys.info())
[17:36:43.309]                   }
[17:36:43.309]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.309]                     cond$call), session = sessionInformation(), 
[17:36:43.309]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.309]                   signalCondition(cond)
[17:36:43.309]                 }
[17:36:43.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.309]                 "immediateCondition"))) {
[17:36:43.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.309]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.309]                   if (TRUE && !signal) {
[17:36:43.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.309]                     {
[17:36:43.309]                       inherits <- base::inherits
[17:36:43.309]                       invokeRestart <- base::invokeRestart
[17:36:43.309]                       is.null <- base::is.null
[17:36:43.309]                       muffled <- FALSE
[17:36:43.309]                       if (inherits(cond, "message")) {
[17:36:43.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.309]                         if (muffled) 
[17:36:43.309]                           invokeRestart("muffleMessage")
[17:36:43.309]                       }
[17:36:43.309]                       else if (inherits(cond, "warning")) {
[17:36:43.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.309]                         if (muffled) 
[17:36:43.309]                           invokeRestart("muffleWarning")
[17:36:43.309]                       }
[17:36:43.309]                       else if (inherits(cond, "condition")) {
[17:36:43.309]                         if (!is.null(pattern)) {
[17:36:43.309]                           computeRestarts <- base::computeRestarts
[17:36:43.309]                           grepl <- base::grepl
[17:36:43.309]                           restarts <- computeRestarts(cond)
[17:36:43.309]                           for (restart in restarts) {
[17:36:43.309]                             name <- restart$name
[17:36:43.309]                             if (is.null(name)) 
[17:36:43.309]                               next
[17:36:43.309]                             if (!grepl(pattern, name)) 
[17:36:43.309]                               next
[17:36:43.309]                             invokeRestart(restart)
[17:36:43.309]                             muffled <- TRUE
[17:36:43.309]                             break
[17:36:43.309]                           }
[17:36:43.309]                         }
[17:36:43.309]                       }
[17:36:43.309]                       invisible(muffled)
[17:36:43.309]                     }
[17:36:43.309]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.309]                   }
[17:36:43.309]                 }
[17:36:43.309]                 else {
[17:36:43.309]                   if (TRUE) {
[17:36:43.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.309]                     {
[17:36:43.309]                       inherits <- base::inherits
[17:36:43.309]                       invokeRestart <- base::invokeRestart
[17:36:43.309]                       is.null <- base::is.null
[17:36:43.309]                       muffled <- FALSE
[17:36:43.309]                       if (inherits(cond, "message")) {
[17:36:43.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.309]                         if (muffled) 
[17:36:43.309]                           invokeRestart("muffleMessage")
[17:36:43.309]                       }
[17:36:43.309]                       else if (inherits(cond, "warning")) {
[17:36:43.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.309]                         if (muffled) 
[17:36:43.309]                           invokeRestart("muffleWarning")
[17:36:43.309]                       }
[17:36:43.309]                       else if (inherits(cond, "condition")) {
[17:36:43.309]                         if (!is.null(pattern)) {
[17:36:43.309]                           computeRestarts <- base::computeRestarts
[17:36:43.309]                           grepl <- base::grepl
[17:36:43.309]                           restarts <- computeRestarts(cond)
[17:36:43.309]                           for (restart in restarts) {
[17:36:43.309]                             name <- restart$name
[17:36:43.309]                             if (is.null(name)) 
[17:36:43.309]                               next
[17:36:43.309]                             if (!grepl(pattern, name)) 
[17:36:43.309]                               next
[17:36:43.309]                             invokeRestart(restart)
[17:36:43.309]                             muffled <- TRUE
[17:36:43.309]                             break
[17:36:43.309]                           }
[17:36:43.309]                         }
[17:36:43.309]                       }
[17:36:43.309]                       invisible(muffled)
[17:36:43.309]                     }
[17:36:43.309]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.309]                   }
[17:36:43.309]                 }
[17:36:43.309]             }
[17:36:43.309]         }))
[17:36:43.309]     }, error = function(ex) {
[17:36:43.309]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.309]                 ...future.rng), started = ...future.startTime, 
[17:36:43.309]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.309]             version = "1.8"), class = "FutureResult")
[17:36:43.309]     }, finally = {
[17:36:43.309]         if (!identical(...future.workdir, getwd())) 
[17:36:43.309]             setwd(...future.workdir)
[17:36:43.309]         {
[17:36:43.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.309]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.309]             }
[17:36:43.309]             base::options(...future.oldOptions)
[17:36:43.309]             if (.Platform$OS.type == "windows") {
[17:36:43.309]                 old_names <- names(...future.oldEnvVars)
[17:36:43.309]                 envs <- base::Sys.getenv()
[17:36:43.309]                 names <- names(envs)
[17:36:43.309]                 common <- intersect(names, old_names)
[17:36:43.309]                 added <- setdiff(names, old_names)
[17:36:43.309]                 removed <- setdiff(old_names, names)
[17:36:43.309]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.309]                   envs[common]]
[17:36:43.309]                 NAMES <- toupper(changed)
[17:36:43.309]                 args <- list()
[17:36:43.309]                 for (kk in seq_along(NAMES)) {
[17:36:43.309]                   name <- changed[[kk]]
[17:36:43.309]                   NAME <- NAMES[[kk]]
[17:36:43.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.309]                     next
[17:36:43.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.309]                 }
[17:36:43.309]                 NAMES <- toupper(added)
[17:36:43.309]                 for (kk in seq_along(NAMES)) {
[17:36:43.309]                   name <- added[[kk]]
[17:36:43.309]                   NAME <- NAMES[[kk]]
[17:36:43.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.309]                     next
[17:36:43.309]                   args[[name]] <- ""
[17:36:43.309]                 }
[17:36:43.309]                 NAMES <- toupper(removed)
[17:36:43.309]                 for (kk in seq_along(NAMES)) {
[17:36:43.309]                   name <- removed[[kk]]
[17:36:43.309]                   NAME <- NAMES[[kk]]
[17:36:43.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.309]                     next
[17:36:43.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.309]                 }
[17:36:43.309]                 if (length(args) > 0) 
[17:36:43.309]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.309]             }
[17:36:43.309]             else {
[17:36:43.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.309]             }
[17:36:43.309]             {
[17:36:43.309]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.309]                   0L) {
[17:36:43.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.309]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.309]                   base::options(opts)
[17:36:43.309]                 }
[17:36:43.309]                 {
[17:36:43.309]                   {
[17:36:43.309]                     NULL
[17:36:43.309]                     RNGkind("Mersenne-Twister")
[17:36:43.309]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:43.309]                       inherits = FALSE)
[17:36:43.309]                   }
[17:36:43.309]                   options(future.plan = NULL)
[17:36:43.309]                   if (is.na(NA_character_)) 
[17:36:43.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.309]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.309]                     .init = FALSE)
[17:36:43.309]                 }
[17:36:43.309]             }
[17:36:43.309]         }
[17:36:43.309]     })
[17:36:43.309]     if (TRUE) {
[17:36:43.309]         base::sink(type = "output", split = FALSE)
[17:36:43.309]         if (TRUE) {
[17:36:43.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.309]         }
[17:36:43.309]         else {
[17:36:43.309]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.309]         }
[17:36:43.309]         base::close(...future.stdout)
[17:36:43.309]         ...future.stdout <- NULL
[17:36:43.309]     }
[17:36:43.309]     ...future.result$conditions <- ...future.conditions
[17:36:43.309]     ...future.result$finished <- base::Sys.time()
[17:36:43.309]     ...future.result
[17:36:43.309] }
[17:36:43.312] assign_globals() ...
[17:36:43.312] List of 5
[17:36:43.312]  $ ...future.FUN            :function (x, ...)  
[17:36:43.312]  $ future.call.arguments    : list()
[17:36:43.312]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.312]  $ ...future.elements_ii    :List of 3
[17:36:43.312]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:36:43.312]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:36:43.312]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:36:43.312]  $ ...future.seeds_ii       : NULL
[17:36:43.312]  $ ...future.globals.maxSize: NULL
[17:36:43.312]  - attr(*, "where")=List of 5
[17:36:43.312]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.312]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.312]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.312]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.312]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.312]  - attr(*, "resolved")= logi FALSE
[17:36:43.312]  - attr(*, "total_size")= num 1248
[17:36:43.312]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.312]  - attr(*, "already-done")= logi TRUE
[17:36:43.317] - copied ‘...future.FUN’ to environment
[17:36:43.317] - copied ‘future.call.arguments’ to environment
[17:36:43.317] - copied ‘...future.elements_ii’ to environment
[17:36:43.317] - copied ‘...future.seeds_ii’ to environment
[17:36:43.317] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.317] assign_globals() ... done
[17:36:43.318] plan(): Setting new future strategy stack:
[17:36:43.318] List of future strategies:
[17:36:43.318] 1. sequential:
[17:36:43.318]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.318]    - tweaked: FALSE
[17:36:43.318]    - call: NULL
[17:36:43.318] plan(): nbrOfWorkers() = 1
[17:36:43.319] plan(): Setting new future strategy stack:
[17:36:43.319] List of future strategies:
[17:36:43.319] 1. sequential:
[17:36:43.319]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.319]    - tweaked: FALSE
[17:36:43.319]    - call: plan(strategy)
[17:36:43.320] plan(): nbrOfWorkers() = 1
[17:36:43.320] SequentialFuture started (and completed)
[17:36:43.320] - Launch lazy future ... done
[17:36:43.320] run() for ‘SequentialFuture’ ... done
[17:36:43.320] Created future:
[17:36:43.321] SequentialFuture:
[17:36:43.321] Label: ‘future_eapply-1’
[17:36:43.321] Expression:
[17:36:43.321] {
[17:36:43.321]     do.call(function(...) {
[17:36:43.321]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.321]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.321]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.321]             on.exit(options(oopts), add = TRUE)
[17:36:43.321]         }
[17:36:43.321]         {
[17:36:43.321]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.321]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.321]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.321]             })
[17:36:43.321]         }
[17:36:43.321]     }, args = future.call.arguments)
[17:36:43.321] }
[17:36:43.321] Lazy evaluation: FALSE
[17:36:43.321] Asynchronous evaluation: FALSE
[17:36:43.321] Local evaluation: TRUE
[17:36:43.321] Environment: R_GlobalEnv
[17:36:43.321] Capture standard output: TRUE
[17:36:43.321] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.321] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.321] Packages: 1 packages (‘stats’)
[17:36:43.321] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.321] Resolved: TRUE
[17:36:43.321] Value: 1.71 KiB of class ‘list’
[17:36:43.321] Early signaling: FALSE
[17:36:43.321] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.321] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:43.321] Chunk #1 of 1 ... DONE
[17:36:43.322] Launching 1 futures (chunks) ... DONE
[17:36:43.322] Resolving 1 futures (chunks) ...
[17:36:43.322] resolve() on list ...
[17:36:43.322]  recursive: 0
[17:36:43.322]  length: 1
[17:36:43.322] 
[17:36:43.322] resolved() for ‘SequentialFuture’ ...
[17:36:43.322] - state: ‘finished’
[17:36:43.322] - run: TRUE
[17:36:43.322] - result: ‘FutureResult’
[17:36:43.323] resolved() for ‘SequentialFuture’ ... done
[17:36:43.323] Future #1
[17:36:43.323] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:43.323] - nx: 1
[17:36:43.323] - relay: TRUE
[17:36:43.323] - stdout: TRUE
[17:36:43.323] - signal: TRUE
[17:36:43.323] - resignal: FALSE
[17:36:43.323] - force: TRUE
[17:36:43.323] - relayed: [n=1] FALSE
[17:36:43.323] - queued futures: [n=1] FALSE
[17:36:43.323]  - until=1
[17:36:43.324]  - relaying element #1
[17:36:43.324] - relayed: [n=1] TRUE
[17:36:43.324] - queued futures: [n=1] TRUE
[17:36:43.324] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:43.324]  length: 0 (resolved future 1)
[17:36:43.324] Relaying remaining futures
[17:36:43.324] signalConditionsASAP(NULL, pos=0) ...
[17:36:43.324] - nx: 1
[17:36:43.324] - relay: TRUE
[17:36:43.324] - stdout: TRUE
[17:36:43.324] - signal: TRUE
[17:36:43.325] - resignal: FALSE
[17:36:43.325] - force: TRUE
[17:36:43.325] - relayed: [n=1] TRUE
[17:36:43.325] - queued futures: [n=1] TRUE
 - flush all
[17:36:43.325] - relayed: [n=1] TRUE
[17:36:43.325] - queued futures: [n=1] TRUE
[17:36:43.325] signalConditionsASAP(NULL, pos=0) ... done
[17:36:43.325] resolve() on list ... DONE
[17:36:43.325]  - Number of value chunks collected: 1
[17:36:43.325] Resolving 1 futures (chunks) ... DONE
[17:36:43.326] Reducing values from 1 chunks ...
[17:36:43.326]  - Number of values collected after concatenation: 3
[17:36:43.326]  - Number of values expected: 3
[17:36:43.326] Reducing values from 1 chunks ... DONE
[17:36:43.326] future_lapply() ... DONE
[17:36:43.326] plan(): Setting new future strategy stack:
[17:36:43.326] List of future strategies:
[17:36:43.326] 1. sequential:
[17:36:43.326]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.326]    - tweaked: FALSE
[17:36:43.326]    - call: plan(sequential)
[17:36:43.327] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:36:43.327] plan(): Setting new future strategy stack:
[17:36:43.327] List of future strategies:
[17:36:43.327] 1. multicore:
[17:36:43.327]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:43.327]    - tweaked: FALSE
[17:36:43.327]    - call: plan(strategy)
[17:36:43.331] plan(): nbrOfWorkers() = 2
[17:36:43.331] future_lapply() ...
[17:36:43.336] Number of chunks: 2
[17:36:43.336] getGlobalsAndPackagesXApply() ...
[17:36:43.336]  - future.globals: TRUE
[17:36:43.336] getGlobalsAndPackages() ...
[17:36:43.336] Searching for globals...
[17:36:43.337] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:43.337] Searching for globals ... DONE
[17:36:43.337] Resolving globals: FALSE
[17:36:43.338] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:43.338] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:43.338] - globals: [1] ‘FUN’
[17:36:43.338] 
[17:36:43.338] getGlobalsAndPackages() ... DONE
[17:36:43.338]  - globals found/used: [n=1] ‘FUN’
[17:36:43.338]  - needed namespaces: [n=0] 
[17:36:43.338] Finding globals ... DONE
[17:36:43.339]  - use_args: TRUE
[17:36:43.339]  - Getting '...' globals ...
[17:36:43.339] resolve() on list ...
[17:36:43.339]  recursive: 0
[17:36:43.339]  length: 1
[17:36:43.339]  elements: ‘...’
[17:36:43.339]  length: 0 (resolved future 1)
[17:36:43.339] resolve() on list ... DONE
[17:36:43.339]    - '...' content: [n=0] 
[17:36:43.341] List of 1
[17:36:43.341]  $ ...: list()
[17:36:43.341]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.341]  - attr(*, "where")=List of 1
[17:36:43.341]   ..$ ...:<environment: 0x565504937778> 
[17:36:43.341]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.341]  - attr(*, "resolved")= logi TRUE
[17:36:43.341]  - attr(*, "total_size")= num NA
[17:36:43.344]  - Getting '...' globals ... DONE
[17:36:43.344] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:43.344] List of 2
[17:36:43.344]  $ ...future.FUN:function (x, ...)  
[17:36:43.344]  $ ...          : list()
[17:36:43.344]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.344]  - attr(*, "where")=List of 2
[17:36:43.344]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:43.344]   ..$ ...          :<environment: 0x565504937778> 
[17:36:43.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.344]  - attr(*, "resolved")= logi FALSE
[17:36:43.344]  - attr(*, "total_size")= num 1240
[17:36:43.347] Packages to be attached in all futures: [n=0] 
[17:36:43.347] getGlobalsAndPackagesXApply() ... DONE
[17:36:43.347] Number of futures (= number of chunks): 2
[17:36:43.347] Launching 2 futures (chunks) ...
[17:36:43.347] Chunk #1 of 2 ...
[17:36:43.347]  - Finding globals in 'X' for chunk #1 ...
[17:36:43.347] getGlobalsAndPackages() ...
[17:36:43.347] Searching for globals...
[17:36:43.348] 
[17:36:43.348] Searching for globals ... DONE
[17:36:43.348] - globals: [0] <none>
[17:36:43.348] getGlobalsAndPackages() ... DONE
[17:36:43.348]    + additional globals found: [n=0] 
[17:36:43.348]    + additional namespaces needed: [n=0] 
[17:36:43.348]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:43.348]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:43.349]  - seeds: <none>
[17:36:43.349]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.349] getGlobalsAndPackages() ...
[17:36:43.349] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.349] Resolving globals: FALSE
[17:36:43.349] Tweak future expression to call with '...' arguments ...
[17:36:43.349] {
[17:36:43.349]     do.call(function(...) {
[17:36:43.349]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.349]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.349]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.349]             on.exit(options(oopts), add = TRUE)
[17:36:43.349]         }
[17:36:43.349]         {
[17:36:43.349]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.349]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.349]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.349]             })
[17:36:43.349]         }
[17:36:43.349]     }, args = future.call.arguments)
[17:36:43.349] }
[17:36:43.349] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.350] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.350] 
[17:36:43.350] getGlobalsAndPackages() ... DONE
[17:36:43.350] run() for ‘Future’ ...
[17:36:43.350] - state: ‘created’
[17:36:43.350] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:43.354] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:43.354]   - Field: ‘label’
[17:36:43.354]   - Field: ‘local’
[17:36:43.354]   - Field: ‘owner’
[17:36:43.355]   - Field: ‘envir’
[17:36:43.355]   - Field: ‘workers’
[17:36:43.355]   - Field: ‘packages’
[17:36:43.355]   - Field: ‘gc’
[17:36:43.355]   - Field: ‘job’
[17:36:43.355]   - Field: ‘conditions’
[17:36:43.355]   - Field: ‘expr’
[17:36:43.355]   - Field: ‘uuid’
[17:36:43.355]   - Field: ‘seed’
[17:36:43.355]   - Field: ‘version’
[17:36:43.355]   - Field: ‘result’
[17:36:43.356]   - Field: ‘asynchronous’
[17:36:43.356]   - Field: ‘calls’
[17:36:43.356]   - Field: ‘globals’
[17:36:43.356]   - Field: ‘stdout’
[17:36:43.356]   - Field: ‘earlySignal’
[17:36:43.356]   - Field: ‘lazy’
[17:36:43.356]   - Field: ‘state’
[17:36:43.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:43.356] - Launch lazy future ...
[17:36:43.357] Packages needed by the future expression (n = 0): <none>
[17:36:43.357] Packages needed by future strategies (n = 0): <none>
[17:36:43.358] {
[17:36:43.358]     {
[17:36:43.358]         {
[17:36:43.358]             ...future.startTime <- base::Sys.time()
[17:36:43.358]             {
[17:36:43.358]                 {
[17:36:43.358]                   {
[17:36:43.358]                     {
[17:36:43.358]                       base::local({
[17:36:43.358]                         has_future <- base::requireNamespace("future", 
[17:36:43.358]                           quietly = TRUE)
[17:36:43.358]                         if (has_future) {
[17:36:43.358]                           ns <- base::getNamespace("future")
[17:36:43.358]                           version <- ns[[".package"]][["version"]]
[17:36:43.358]                           if (is.null(version)) 
[17:36:43.358]                             version <- utils::packageVersion("future")
[17:36:43.358]                         }
[17:36:43.358]                         else {
[17:36:43.358]                           version <- NULL
[17:36:43.358]                         }
[17:36:43.358]                         if (!has_future || version < "1.8.0") {
[17:36:43.358]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.358]                             "", base::R.version$version.string), 
[17:36:43.358]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:43.358]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:43.358]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.358]                               "release", "version")], collapse = " "), 
[17:36:43.358]                             hostname = base::Sys.info()[["nodename"]])
[17:36:43.358]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.358]                             info)
[17:36:43.358]                           info <- base::paste(info, collapse = "; ")
[17:36:43.358]                           if (!has_future) {
[17:36:43.358]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.358]                               info)
[17:36:43.358]                           }
[17:36:43.358]                           else {
[17:36:43.358]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.358]                               info, version)
[17:36:43.358]                           }
[17:36:43.358]                           base::stop(msg)
[17:36:43.358]                         }
[17:36:43.358]                       })
[17:36:43.358]                     }
[17:36:43.358]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:43.358]                     base::options(mc.cores = 1L)
[17:36:43.358]                   }
[17:36:43.358]                   ...future.strategy.old <- future::plan("list")
[17:36:43.358]                   options(future.plan = NULL)
[17:36:43.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.358]                 }
[17:36:43.358]                 ...future.workdir <- getwd()
[17:36:43.358]             }
[17:36:43.358]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.358]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.358]         }
[17:36:43.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.358]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:43.358]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.358]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.358]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.358]             base::names(...future.oldOptions))
[17:36:43.358]     }
[17:36:43.358]     if (FALSE) {
[17:36:43.358]     }
[17:36:43.358]     else {
[17:36:43.358]         if (TRUE) {
[17:36:43.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.358]                 open = "w")
[17:36:43.358]         }
[17:36:43.358]         else {
[17:36:43.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.358]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.358]         }
[17:36:43.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.358]             base::sink(type = "output", split = FALSE)
[17:36:43.358]             base::close(...future.stdout)
[17:36:43.358]         }, add = TRUE)
[17:36:43.358]     }
[17:36:43.358]     ...future.frame <- base::sys.nframe()
[17:36:43.358]     ...future.conditions <- base::list()
[17:36:43.358]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.358]     if (FALSE) {
[17:36:43.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.358]     }
[17:36:43.358]     ...future.result <- base::tryCatch({
[17:36:43.358]         base::withCallingHandlers({
[17:36:43.358]             ...future.value <- base::withVisible(base::local({
[17:36:43.358]                 withCallingHandlers({
[17:36:43.358]                   {
[17:36:43.358]                     do.call(function(...) {
[17:36:43.358]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.358]                       if (!identical(...future.globals.maxSize.org, 
[17:36:43.358]                         ...future.globals.maxSize)) {
[17:36:43.358]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.358]                         on.exit(options(oopts), add = TRUE)
[17:36:43.358]                       }
[17:36:43.358]                       {
[17:36:43.358]                         lapply(seq_along(...future.elements_ii), 
[17:36:43.358]                           FUN = function(jj) {
[17:36:43.358]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.358]                             ...future.FUN(...future.X_jj, ...)
[17:36:43.358]                           })
[17:36:43.358]                       }
[17:36:43.358]                     }, args = future.call.arguments)
[17:36:43.358]                   }
[17:36:43.358]                 }, immediateCondition = function(cond) {
[17:36:43.358]                   save_rds <- function (object, pathname, ...) 
[17:36:43.358]                   {
[17:36:43.358]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:43.358]                     if (file_test("-f", pathname_tmp)) {
[17:36:43.358]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.358]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:43.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.358]                         fi_tmp[["mtime"]])
[17:36:43.358]                     }
[17:36:43.358]                     tryCatch({
[17:36:43.358]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:43.358]                     }, error = function(ex) {
[17:36:43.358]                       msg <- conditionMessage(ex)
[17:36:43.358]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.358]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:43.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.358]                         fi_tmp[["mtime"]], msg)
[17:36:43.358]                       ex$message <- msg
[17:36:43.358]                       stop(ex)
[17:36:43.358]                     })
[17:36:43.358]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:43.358]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:43.358]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:43.358]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.358]                       fi <- file.info(pathname)
[17:36:43.358]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:43.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.358]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:43.358]                         fi[["size"]], fi[["mtime"]])
[17:36:43.358]                       stop(msg)
[17:36:43.358]                     }
[17:36:43.358]                     invisible(pathname)
[17:36:43.358]                   }
[17:36:43.358]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:43.358]                     rootPath = tempdir()) 
[17:36:43.358]                   {
[17:36:43.358]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:43.358]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:43.358]                       tmpdir = path, fileext = ".rds")
[17:36:43.358]                     save_rds(obj, file)
[17:36:43.358]                   }
[17:36:43.358]                   saveImmediateCondition(cond, path = "/tmp/RtmpEOKIKx/.future/immediateConditions")
[17:36:43.358]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.358]                   {
[17:36:43.358]                     inherits <- base::inherits
[17:36:43.358]                     invokeRestart <- base::invokeRestart
[17:36:43.358]                     is.null <- base::is.null
[17:36:43.358]                     muffled <- FALSE
[17:36:43.358]                     if (inherits(cond, "message")) {
[17:36:43.358]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:43.358]                       if (muffled) 
[17:36:43.358]                         invokeRestart("muffleMessage")
[17:36:43.358]                     }
[17:36:43.358]                     else if (inherits(cond, "warning")) {
[17:36:43.358]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:43.358]                       if (muffled) 
[17:36:43.358]                         invokeRestart("muffleWarning")
[17:36:43.358]                     }
[17:36:43.358]                     else if (inherits(cond, "condition")) {
[17:36:43.358]                       if (!is.null(pattern)) {
[17:36:43.358]                         computeRestarts <- base::computeRestarts
[17:36:43.358]                         grepl <- base::grepl
[17:36:43.358]                         restarts <- computeRestarts(cond)
[17:36:43.358]                         for (restart in restarts) {
[17:36:43.358]                           name <- restart$name
[17:36:43.358]                           if (is.null(name)) 
[17:36:43.358]                             next
[17:36:43.358]                           if (!grepl(pattern, name)) 
[17:36:43.358]                             next
[17:36:43.358]                           invokeRestart(restart)
[17:36:43.358]                           muffled <- TRUE
[17:36:43.358]                           break
[17:36:43.358]                         }
[17:36:43.358]                       }
[17:36:43.358]                     }
[17:36:43.358]                     invisible(muffled)
[17:36:43.358]                   }
[17:36:43.358]                   muffleCondition(cond)
[17:36:43.358]                 })
[17:36:43.358]             }))
[17:36:43.358]             future::FutureResult(value = ...future.value$value, 
[17:36:43.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.358]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.358]                     ...future.globalenv.names))
[17:36:43.358]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.358]         }, condition = base::local({
[17:36:43.358]             c <- base::c
[17:36:43.358]             inherits <- base::inherits
[17:36:43.358]             invokeRestart <- base::invokeRestart
[17:36:43.358]             length <- base::length
[17:36:43.358]             list <- base::list
[17:36:43.358]             seq.int <- base::seq.int
[17:36:43.358]             signalCondition <- base::signalCondition
[17:36:43.358]             sys.calls <- base::sys.calls
[17:36:43.358]             `[[` <- base::`[[`
[17:36:43.358]             `+` <- base::`+`
[17:36:43.358]             `<<-` <- base::`<<-`
[17:36:43.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.358]                   3L)]
[17:36:43.358]             }
[17:36:43.358]             function(cond) {
[17:36:43.358]                 is_error <- inherits(cond, "error")
[17:36:43.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.358]                   NULL)
[17:36:43.358]                 if (is_error) {
[17:36:43.358]                   sessionInformation <- function() {
[17:36:43.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.358]                       search = base::search(), system = base::Sys.info())
[17:36:43.358]                   }
[17:36:43.358]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.358]                     cond$call), session = sessionInformation(), 
[17:36:43.358]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.358]                   signalCondition(cond)
[17:36:43.358]                 }
[17:36:43.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.358]                 "immediateCondition"))) {
[17:36:43.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.358]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.358]                   if (TRUE && !signal) {
[17:36:43.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.358]                     {
[17:36:43.358]                       inherits <- base::inherits
[17:36:43.358]                       invokeRestart <- base::invokeRestart
[17:36:43.358]                       is.null <- base::is.null
[17:36:43.358]                       muffled <- FALSE
[17:36:43.358]                       if (inherits(cond, "message")) {
[17:36:43.358]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.358]                         if (muffled) 
[17:36:43.358]                           invokeRestart("muffleMessage")
[17:36:43.358]                       }
[17:36:43.358]                       else if (inherits(cond, "warning")) {
[17:36:43.358]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.358]                         if (muffled) 
[17:36:43.358]                           invokeRestart("muffleWarning")
[17:36:43.358]                       }
[17:36:43.358]                       else if (inherits(cond, "condition")) {
[17:36:43.358]                         if (!is.null(pattern)) {
[17:36:43.358]                           computeRestarts <- base::computeRestarts
[17:36:43.358]                           grepl <- base::grepl
[17:36:43.358]                           restarts <- computeRestarts(cond)
[17:36:43.358]                           for (restart in restarts) {
[17:36:43.358]                             name <- restart$name
[17:36:43.358]                             if (is.null(name)) 
[17:36:43.358]                               next
[17:36:43.358]                             if (!grepl(pattern, name)) 
[17:36:43.358]                               next
[17:36:43.358]                             invokeRestart(restart)
[17:36:43.358]                             muffled <- TRUE
[17:36:43.358]                             break
[17:36:43.358]                           }
[17:36:43.358]                         }
[17:36:43.358]                       }
[17:36:43.358]                       invisible(muffled)
[17:36:43.358]                     }
[17:36:43.358]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.358]                   }
[17:36:43.358]                 }
[17:36:43.358]                 else {
[17:36:43.358]                   if (TRUE) {
[17:36:43.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.358]                     {
[17:36:43.358]                       inherits <- base::inherits
[17:36:43.358]                       invokeRestart <- base::invokeRestart
[17:36:43.358]                       is.null <- base::is.null
[17:36:43.358]                       muffled <- FALSE
[17:36:43.358]                       if (inherits(cond, "message")) {
[17:36:43.358]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.358]                         if (muffled) 
[17:36:43.358]                           invokeRestart("muffleMessage")
[17:36:43.358]                       }
[17:36:43.358]                       else if (inherits(cond, "warning")) {
[17:36:43.358]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.358]                         if (muffled) 
[17:36:43.358]                           invokeRestart("muffleWarning")
[17:36:43.358]                       }
[17:36:43.358]                       else if (inherits(cond, "condition")) {
[17:36:43.358]                         if (!is.null(pattern)) {
[17:36:43.358]                           computeRestarts <- base::computeRestarts
[17:36:43.358]                           grepl <- base::grepl
[17:36:43.358]                           restarts <- computeRestarts(cond)
[17:36:43.358]                           for (restart in restarts) {
[17:36:43.358]                             name <- restart$name
[17:36:43.358]                             if (is.null(name)) 
[17:36:43.358]                               next
[17:36:43.358]                             if (!grepl(pattern, name)) 
[17:36:43.358]                               next
[17:36:43.358]                             invokeRestart(restart)
[17:36:43.358]                             muffled <- TRUE
[17:36:43.358]                             break
[17:36:43.358]                           }
[17:36:43.358]                         }
[17:36:43.358]                       }
[17:36:43.358]                       invisible(muffled)
[17:36:43.358]                     }
[17:36:43.358]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.358]                   }
[17:36:43.358]                 }
[17:36:43.358]             }
[17:36:43.358]         }))
[17:36:43.358]     }, error = function(ex) {
[17:36:43.358]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.358]                 ...future.rng), started = ...future.startTime, 
[17:36:43.358]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.358]             version = "1.8"), class = "FutureResult")
[17:36:43.358]     }, finally = {
[17:36:43.358]         if (!identical(...future.workdir, getwd())) 
[17:36:43.358]             setwd(...future.workdir)
[17:36:43.358]         {
[17:36:43.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.358]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.358]             }
[17:36:43.358]             base::options(...future.oldOptions)
[17:36:43.358]             if (.Platform$OS.type == "windows") {
[17:36:43.358]                 old_names <- names(...future.oldEnvVars)
[17:36:43.358]                 envs <- base::Sys.getenv()
[17:36:43.358]                 names <- names(envs)
[17:36:43.358]                 common <- intersect(names, old_names)
[17:36:43.358]                 added <- setdiff(names, old_names)
[17:36:43.358]                 removed <- setdiff(old_names, names)
[17:36:43.358]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.358]                   envs[common]]
[17:36:43.358]                 NAMES <- toupper(changed)
[17:36:43.358]                 args <- list()
[17:36:43.358]                 for (kk in seq_along(NAMES)) {
[17:36:43.358]                   name <- changed[[kk]]
[17:36:43.358]                   NAME <- NAMES[[kk]]
[17:36:43.358]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.358]                     next
[17:36:43.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.358]                 }
[17:36:43.358]                 NAMES <- toupper(added)
[17:36:43.358]                 for (kk in seq_along(NAMES)) {
[17:36:43.358]                   name <- added[[kk]]
[17:36:43.358]                   NAME <- NAMES[[kk]]
[17:36:43.358]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.358]                     next
[17:36:43.358]                   args[[name]] <- ""
[17:36:43.358]                 }
[17:36:43.358]                 NAMES <- toupper(removed)
[17:36:43.358]                 for (kk in seq_along(NAMES)) {
[17:36:43.358]                   name <- removed[[kk]]
[17:36:43.358]                   NAME <- NAMES[[kk]]
[17:36:43.358]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.358]                     next
[17:36:43.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.358]                 }
[17:36:43.358]                 if (length(args) > 0) 
[17:36:43.358]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.358]             }
[17:36:43.358]             else {
[17:36:43.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.358]             }
[17:36:43.358]             {
[17:36:43.358]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.358]                   0L) {
[17:36:43.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.358]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.358]                   base::options(opts)
[17:36:43.358]                 }
[17:36:43.358]                 {
[17:36:43.358]                   {
[17:36:43.358]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:43.358]                     NULL
[17:36:43.358]                   }
[17:36:43.358]                   options(future.plan = NULL)
[17:36:43.358]                   if (is.na(NA_character_)) 
[17:36:43.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.358]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.358]                     .init = FALSE)
[17:36:43.358]                 }
[17:36:43.358]             }
[17:36:43.358]         }
[17:36:43.358]     })
[17:36:43.358]     if (TRUE) {
[17:36:43.358]         base::sink(type = "output", split = FALSE)
[17:36:43.358]         if (TRUE) {
[17:36:43.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.358]         }
[17:36:43.358]         else {
[17:36:43.358]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.358]         }
[17:36:43.358]         base::close(...future.stdout)
[17:36:43.358]         ...future.stdout <- NULL
[17:36:43.358]     }
[17:36:43.358]     ...future.result$conditions <- ...future.conditions
[17:36:43.358]     ...future.result$finished <- base::Sys.time()
[17:36:43.358]     ...future.result
[17:36:43.358] }
[17:36:43.360] assign_globals() ...
[17:36:43.360] List of 5
[17:36:43.360]  $ ...future.FUN            :function (x, ...)  
[17:36:43.360]  $ future.call.arguments    : list()
[17:36:43.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.360]  $ ...future.elements_ii    :List of 1
[17:36:43.360]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[17:36:43.360]  $ ...future.seeds_ii       : NULL
[17:36:43.360]  $ ...future.globals.maxSize: NULL
[17:36:43.360]  - attr(*, "where")=List of 5
[17:36:43.360]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.360]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.360]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.360]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.360]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.360]  - attr(*, "resolved")= logi FALSE
[17:36:43.360]  - attr(*, "total_size")= num 1240
[17:36:43.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.360]  - attr(*, "already-done")= logi TRUE
[17:36:43.365] - copied ‘...future.FUN’ to environment
[17:36:43.365] - copied ‘future.call.arguments’ to environment
[17:36:43.365] - copied ‘...future.elements_ii’ to environment
[17:36:43.365] - copied ‘...future.seeds_ii’ to environment
[17:36:43.365] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.365] assign_globals() ... done
[17:36:43.365] requestCore(): workers = 2
[17:36:43.368] MulticoreFuture started
[17:36:43.369] - Launch lazy future ... done
[17:36:43.369] plan(): Setting new future strategy stack:
[17:36:43.369] run() for ‘MulticoreFuture’ ... done
[17:36:43.369] Created future:
[17:36:43.369] List of future strategies:
[17:36:43.369] 1. sequential:
[17:36:43.369]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.369]    - tweaked: FALSE
[17:36:43.369]    - call: NULL
[17:36:43.370] plan(): nbrOfWorkers() = 1
[17:36:43.372] plan(): Setting new future strategy stack:
[17:36:43.372] List of future strategies:
[17:36:43.372] 1. multicore:
[17:36:43.372]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:43.372]    - tweaked: FALSE
[17:36:43.372]    - call: plan(strategy)
[17:36:43.381] plan(): nbrOfWorkers() = 2
[17:36:43.370] MulticoreFuture:
[17:36:43.370] Label: ‘future_eapply-1’
[17:36:43.370] Expression:
[17:36:43.370] {
[17:36:43.370]     do.call(function(...) {
[17:36:43.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.370]             on.exit(options(oopts), add = TRUE)
[17:36:43.370]         }
[17:36:43.370]         {
[17:36:43.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.370]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.370]             })
[17:36:43.370]         }
[17:36:43.370]     }, args = future.call.arguments)
[17:36:43.370] }
[17:36:43.370] Lazy evaluation: FALSE
[17:36:43.370] Asynchronous evaluation: TRUE
[17:36:43.370] Local evaluation: TRUE
[17:36:43.370] Environment: R_GlobalEnv
[17:36:43.370] Capture standard output: TRUE
[17:36:43.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.370] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.370] Packages: <none>
[17:36:43.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.370] Resolved: TRUE
[17:36:43.370] Value: <not collected>
[17:36:43.370] Conditions captured: <none>
[17:36:43.370] Early signaling: FALSE
[17:36:43.370] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.370] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.383] Chunk #1 of 2 ... DONE
[17:36:43.383] Chunk #2 of 2 ...
[17:36:43.383]  - Finding globals in 'X' for chunk #2 ...
[17:36:43.383] getGlobalsAndPackages() ...
[17:36:43.383] Searching for globals...
[17:36:43.384] 
[17:36:43.384] Searching for globals ... DONE
[17:36:43.386] - globals: [0] <none>
[17:36:43.387] getGlobalsAndPackages() ... DONE
[17:36:43.387]    + additional globals found: [n=0] 
[17:36:43.387]    + additional namespaces needed: [n=0] 
[17:36:43.387]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:43.387]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:43.387]  - seeds: <none>
[17:36:43.387]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.388] getGlobalsAndPackages() ...
[17:36:43.388] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.388] Resolving globals: FALSE
[17:36:43.388] Tweak future expression to call with '...' arguments ...
[17:36:43.388] {
[17:36:43.388]     do.call(function(...) {
[17:36:43.388]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.388]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.388]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.388]             on.exit(options(oopts), add = TRUE)
[17:36:43.388]         }
[17:36:43.388]         {
[17:36:43.388]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.388]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.388]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.388]             })
[17:36:43.388]         }
[17:36:43.388]     }, args = future.call.arguments)
[17:36:43.388] }
[17:36:43.389] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.390] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.390] 
[17:36:43.390] getGlobalsAndPackages() ... DONE
[17:36:43.391] run() for ‘Future’ ...
[17:36:43.391] - state: ‘created’
[17:36:43.391] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:43.396] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.396] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:43.396]   - Field: ‘label’
[17:36:43.396]   - Field: ‘local’
[17:36:43.397]   - Field: ‘owner’
[17:36:43.397]   - Field: ‘envir’
[17:36:43.397]   - Field: ‘workers’
[17:36:43.397]   - Field: ‘packages’
[17:36:43.397]   - Field: ‘gc’
[17:36:43.397]   - Field: ‘job’
[17:36:43.398]   - Field: ‘conditions’
[17:36:43.398]   - Field: ‘expr’
[17:36:43.398]   - Field: ‘uuid’
[17:36:43.398]   - Field: ‘seed’
[17:36:43.398]   - Field: ‘version’
[17:36:43.398]   - Field: ‘result’
[17:36:43.399]   - Field: ‘asynchronous’
[17:36:43.399]   - Field: ‘calls’
[17:36:43.399]   - Field: ‘globals’
[17:36:43.399]   - Field: ‘stdout’
[17:36:43.399]   - Field: ‘earlySignal’
[17:36:43.399]   - Field: ‘lazy’
[17:36:43.399]   - Field: ‘state’
[17:36:43.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:43.400] - Launch lazy future ...
[17:36:43.400] Packages needed by the future expression (n = 0): <none>
[17:36:43.400] Packages needed by future strategies (n = 0): <none>
[17:36:43.401] {
[17:36:43.401]     {
[17:36:43.401]         {
[17:36:43.401]             ...future.startTime <- base::Sys.time()
[17:36:43.401]             {
[17:36:43.401]                 {
[17:36:43.401]                   {
[17:36:43.401]                     {
[17:36:43.401]                       base::local({
[17:36:43.401]                         has_future <- base::requireNamespace("future", 
[17:36:43.401]                           quietly = TRUE)
[17:36:43.401]                         if (has_future) {
[17:36:43.401]                           ns <- base::getNamespace("future")
[17:36:43.401]                           version <- ns[[".package"]][["version"]]
[17:36:43.401]                           if (is.null(version)) 
[17:36:43.401]                             version <- utils::packageVersion("future")
[17:36:43.401]                         }
[17:36:43.401]                         else {
[17:36:43.401]                           version <- NULL
[17:36:43.401]                         }
[17:36:43.401]                         if (!has_future || version < "1.8.0") {
[17:36:43.401]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.401]                             "", base::R.version$version.string), 
[17:36:43.401]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:43.401]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:43.401]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.401]                               "release", "version")], collapse = " "), 
[17:36:43.401]                             hostname = base::Sys.info()[["nodename"]])
[17:36:43.401]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.401]                             info)
[17:36:43.401]                           info <- base::paste(info, collapse = "; ")
[17:36:43.401]                           if (!has_future) {
[17:36:43.401]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.401]                               info)
[17:36:43.401]                           }
[17:36:43.401]                           else {
[17:36:43.401]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.401]                               info, version)
[17:36:43.401]                           }
[17:36:43.401]                           base::stop(msg)
[17:36:43.401]                         }
[17:36:43.401]                       })
[17:36:43.401]                     }
[17:36:43.401]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:43.401]                     base::options(mc.cores = 1L)
[17:36:43.401]                   }
[17:36:43.401]                   ...future.strategy.old <- future::plan("list")
[17:36:43.401]                   options(future.plan = NULL)
[17:36:43.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.401]                 }
[17:36:43.401]                 ...future.workdir <- getwd()
[17:36:43.401]             }
[17:36:43.401]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.401]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.401]         }
[17:36:43.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.401]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:43.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.401]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.401]             base::names(...future.oldOptions))
[17:36:43.401]     }
[17:36:43.401]     if (FALSE) {
[17:36:43.401]     }
[17:36:43.401]     else {
[17:36:43.401]         if (TRUE) {
[17:36:43.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.401]                 open = "w")
[17:36:43.401]         }
[17:36:43.401]         else {
[17:36:43.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.401]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.401]         }
[17:36:43.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.401]             base::sink(type = "output", split = FALSE)
[17:36:43.401]             base::close(...future.stdout)
[17:36:43.401]         }, add = TRUE)
[17:36:43.401]     }
[17:36:43.401]     ...future.frame <- base::sys.nframe()
[17:36:43.401]     ...future.conditions <- base::list()
[17:36:43.401]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.401]     if (FALSE) {
[17:36:43.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.401]     }
[17:36:43.401]     ...future.result <- base::tryCatch({
[17:36:43.401]         base::withCallingHandlers({
[17:36:43.401]             ...future.value <- base::withVisible(base::local({
[17:36:43.401]                 withCallingHandlers({
[17:36:43.401]                   {
[17:36:43.401]                     do.call(function(...) {
[17:36:43.401]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.401]                       if (!identical(...future.globals.maxSize.org, 
[17:36:43.401]                         ...future.globals.maxSize)) {
[17:36:43.401]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.401]                         on.exit(options(oopts), add = TRUE)
[17:36:43.401]                       }
[17:36:43.401]                       {
[17:36:43.401]                         lapply(seq_along(...future.elements_ii), 
[17:36:43.401]                           FUN = function(jj) {
[17:36:43.401]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.401]                             ...future.FUN(...future.X_jj, ...)
[17:36:43.401]                           })
[17:36:43.401]                       }
[17:36:43.401]                     }, args = future.call.arguments)
[17:36:43.401]                   }
[17:36:43.401]                 }, immediateCondition = function(cond) {
[17:36:43.401]                   save_rds <- function (object, pathname, ...) 
[17:36:43.401]                   {
[17:36:43.401]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:43.401]                     if (file_test("-f", pathname_tmp)) {
[17:36:43.401]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.401]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:43.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.401]                         fi_tmp[["mtime"]])
[17:36:43.401]                     }
[17:36:43.401]                     tryCatch({
[17:36:43.401]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:43.401]                     }, error = function(ex) {
[17:36:43.401]                       msg <- conditionMessage(ex)
[17:36:43.401]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.401]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:43.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.401]                         fi_tmp[["mtime"]], msg)
[17:36:43.401]                       ex$message <- msg
[17:36:43.401]                       stop(ex)
[17:36:43.401]                     })
[17:36:43.401]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:43.401]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:43.401]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:43.401]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.401]                       fi <- file.info(pathname)
[17:36:43.401]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:43.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.401]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:43.401]                         fi[["size"]], fi[["mtime"]])
[17:36:43.401]                       stop(msg)
[17:36:43.401]                     }
[17:36:43.401]                     invisible(pathname)
[17:36:43.401]                   }
[17:36:43.401]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:43.401]                     rootPath = tempdir()) 
[17:36:43.401]                   {
[17:36:43.401]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:43.401]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:43.401]                       tmpdir = path, fileext = ".rds")
[17:36:43.401]                     save_rds(obj, file)
[17:36:43.401]                   }
[17:36:43.401]                   saveImmediateCondition(cond, path = "/tmp/RtmpEOKIKx/.future/immediateConditions")
[17:36:43.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.401]                   {
[17:36:43.401]                     inherits <- base::inherits
[17:36:43.401]                     invokeRestart <- base::invokeRestart
[17:36:43.401]                     is.null <- base::is.null
[17:36:43.401]                     muffled <- FALSE
[17:36:43.401]                     if (inherits(cond, "message")) {
[17:36:43.401]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:43.401]                       if (muffled) 
[17:36:43.401]                         invokeRestart("muffleMessage")
[17:36:43.401]                     }
[17:36:43.401]                     else if (inherits(cond, "warning")) {
[17:36:43.401]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:43.401]                       if (muffled) 
[17:36:43.401]                         invokeRestart("muffleWarning")
[17:36:43.401]                     }
[17:36:43.401]                     else if (inherits(cond, "condition")) {
[17:36:43.401]                       if (!is.null(pattern)) {
[17:36:43.401]                         computeRestarts <- base::computeRestarts
[17:36:43.401]                         grepl <- base::grepl
[17:36:43.401]                         restarts <- computeRestarts(cond)
[17:36:43.401]                         for (restart in restarts) {
[17:36:43.401]                           name <- restart$name
[17:36:43.401]                           if (is.null(name)) 
[17:36:43.401]                             next
[17:36:43.401]                           if (!grepl(pattern, name)) 
[17:36:43.401]                             next
[17:36:43.401]                           invokeRestart(restart)
[17:36:43.401]                           muffled <- TRUE
[17:36:43.401]                           break
[17:36:43.401]                         }
[17:36:43.401]                       }
[17:36:43.401]                     }
[17:36:43.401]                     invisible(muffled)
[17:36:43.401]                   }
[17:36:43.401]                   muffleCondition(cond)
[17:36:43.401]                 })
[17:36:43.401]             }))
[17:36:43.401]             future::FutureResult(value = ...future.value$value, 
[17:36:43.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.401]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.401]                     ...future.globalenv.names))
[17:36:43.401]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.401]         }, condition = base::local({
[17:36:43.401]             c <- base::c
[17:36:43.401]             inherits <- base::inherits
[17:36:43.401]             invokeRestart <- base::invokeRestart
[17:36:43.401]             length <- base::length
[17:36:43.401]             list <- base::list
[17:36:43.401]             seq.int <- base::seq.int
[17:36:43.401]             signalCondition <- base::signalCondition
[17:36:43.401]             sys.calls <- base::sys.calls
[17:36:43.401]             `[[` <- base::`[[`
[17:36:43.401]             `+` <- base::`+`
[17:36:43.401]             `<<-` <- base::`<<-`
[17:36:43.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.401]                   3L)]
[17:36:43.401]             }
[17:36:43.401]             function(cond) {
[17:36:43.401]                 is_error <- inherits(cond, "error")
[17:36:43.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.401]                   NULL)
[17:36:43.401]                 if (is_error) {
[17:36:43.401]                   sessionInformation <- function() {
[17:36:43.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.401]                       search = base::search(), system = base::Sys.info())
[17:36:43.401]                   }
[17:36:43.401]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.401]                     cond$call), session = sessionInformation(), 
[17:36:43.401]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.401]                   signalCondition(cond)
[17:36:43.401]                 }
[17:36:43.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.401]                 "immediateCondition"))) {
[17:36:43.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.401]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.401]                   if (TRUE && !signal) {
[17:36:43.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.401]                     {
[17:36:43.401]                       inherits <- base::inherits
[17:36:43.401]                       invokeRestart <- base::invokeRestart
[17:36:43.401]                       is.null <- base::is.null
[17:36:43.401]                       muffled <- FALSE
[17:36:43.401]                       if (inherits(cond, "message")) {
[17:36:43.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.401]                         if (muffled) 
[17:36:43.401]                           invokeRestart("muffleMessage")
[17:36:43.401]                       }
[17:36:43.401]                       else if (inherits(cond, "warning")) {
[17:36:43.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.401]                         if (muffled) 
[17:36:43.401]                           invokeRestart("muffleWarning")
[17:36:43.401]                       }
[17:36:43.401]                       else if (inherits(cond, "condition")) {
[17:36:43.401]                         if (!is.null(pattern)) {
[17:36:43.401]                           computeRestarts <- base::computeRestarts
[17:36:43.401]                           grepl <- base::grepl
[17:36:43.401]                           restarts <- computeRestarts(cond)
[17:36:43.401]                           for (restart in restarts) {
[17:36:43.401]                             name <- restart$name
[17:36:43.401]                             if (is.null(name)) 
[17:36:43.401]                               next
[17:36:43.401]                             if (!grepl(pattern, name)) 
[17:36:43.401]                               next
[17:36:43.401]                             invokeRestart(restart)
[17:36:43.401]                             muffled <- TRUE
[17:36:43.401]                             break
[17:36:43.401]                           }
[17:36:43.401]                         }
[17:36:43.401]                       }
[17:36:43.401]                       invisible(muffled)
[17:36:43.401]                     }
[17:36:43.401]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.401]                   }
[17:36:43.401]                 }
[17:36:43.401]                 else {
[17:36:43.401]                   if (TRUE) {
[17:36:43.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.401]                     {
[17:36:43.401]                       inherits <- base::inherits
[17:36:43.401]                       invokeRestart <- base::invokeRestart
[17:36:43.401]                       is.null <- base::is.null
[17:36:43.401]                       muffled <- FALSE
[17:36:43.401]                       if (inherits(cond, "message")) {
[17:36:43.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.401]                         if (muffled) 
[17:36:43.401]                           invokeRestart("muffleMessage")
[17:36:43.401]                       }
[17:36:43.401]                       else if (inherits(cond, "warning")) {
[17:36:43.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.401]                         if (muffled) 
[17:36:43.401]                           invokeRestart("muffleWarning")
[17:36:43.401]                       }
[17:36:43.401]                       else if (inherits(cond, "condition")) {
[17:36:43.401]                         if (!is.null(pattern)) {
[17:36:43.401]                           computeRestarts <- base::computeRestarts
[17:36:43.401]                           grepl <- base::grepl
[17:36:43.401]                           restarts <- computeRestarts(cond)
[17:36:43.401]                           for (restart in restarts) {
[17:36:43.401]                             name <- restart$name
[17:36:43.401]                             if (is.null(name)) 
[17:36:43.401]                               next
[17:36:43.401]                             if (!grepl(pattern, name)) 
[17:36:43.401]                               next
[17:36:43.401]                             invokeRestart(restart)
[17:36:43.401]                             muffled <- TRUE
[17:36:43.401]                             break
[17:36:43.401]                           }
[17:36:43.401]                         }
[17:36:43.401]                       }
[17:36:43.401]                       invisible(muffled)
[17:36:43.401]                     }
[17:36:43.401]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.401]                   }
[17:36:43.401]                 }
[17:36:43.401]             }
[17:36:43.401]         }))
[17:36:43.401]     }, error = function(ex) {
[17:36:43.401]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.401]                 ...future.rng), started = ...future.startTime, 
[17:36:43.401]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.401]             version = "1.8"), class = "FutureResult")
[17:36:43.401]     }, finally = {
[17:36:43.401]         if (!identical(...future.workdir, getwd())) 
[17:36:43.401]             setwd(...future.workdir)
[17:36:43.401]         {
[17:36:43.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.401]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.401]             }
[17:36:43.401]             base::options(...future.oldOptions)
[17:36:43.401]             if (.Platform$OS.type == "windows") {
[17:36:43.401]                 old_names <- names(...future.oldEnvVars)
[17:36:43.401]                 envs <- base::Sys.getenv()
[17:36:43.401]                 names <- names(envs)
[17:36:43.401]                 common <- intersect(names, old_names)
[17:36:43.401]                 added <- setdiff(names, old_names)
[17:36:43.401]                 removed <- setdiff(old_names, names)
[17:36:43.401]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.401]                   envs[common]]
[17:36:43.401]                 NAMES <- toupper(changed)
[17:36:43.401]                 args <- list()
[17:36:43.401]                 for (kk in seq_along(NAMES)) {
[17:36:43.401]                   name <- changed[[kk]]
[17:36:43.401]                   NAME <- NAMES[[kk]]
[17:36:43.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.401]                     next
[17:36:43.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.401]                 }
[17:36:43.401]                 NAMES <- toupper(added)
[17:36:43.401]                 for (kk in seq_along(NAMES)) {
[17:36:43.401]                   name <- added[[kk]]
[17:36:43.401]                   NAME <- NAMES[[kk]]
[17:36:43.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.401]                     next
[17:36:43.401]                   args[[name]] <- ""
[17:36:43.401]                 }
[17:36:43.401]                 NAMES <- toupper(removed)
[17:36:43.401]                 for (kk in seq_along(NAMES)) {
[17:36:43.401]                   name <- removed[[kk]]
[17:36:43.401]                   NAME <- NAMES[[kk]]
[17:36:43.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.401]                     next
[17:36:43.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.401]                 }
[17:36:43.401]                 if (length(args) > 0) 
[17:36:43.401]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.401]             }
[17:36:43.401]             else {
[17:36:43.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.401]             }
[17:36:43.401]             {
[17:36:43.401]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.401]                   0L) {
[17:36:43.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.401]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.401]                   base::options(opts)
[17:36:43.401]                 }
[17:36:43.401]                 {
[17:36:43.401]                   {
[17:36:43.401]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:43.401]                     NULL
[17:36:43.401]                   }
[17:36:43.401]                   options(future.plan = NULL)
[17:36:43.401]                   if (is.na(NA_character_)) 
[17:36:43.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.401]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.401]                     .init = FALSE)
[17:36:43.401]                 }
[17:36:43.401]             }
[17:36:43.401]         }
[17:36:43.401]     })
[17:36:43.401]     if (TRUE) {
[17:36:43.401]         base::sink(type = "output", split = FALSE)
[17:36:43.401]         if (TRUE) {
[17:36:43.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.401]         }
[17:36:43.401]         else {
[17:36:43.401]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.401]         }
[17:36:43.401]         base::close(...future.stdout)
[17:36:43.401]         ...future.stdout <- NULL
[17:36:43.401]     }
[17:36:43.401]     ...future.result$conditions <- ...future.conditions
[17:36:43.401]     ...future.result$finished <- base::Sys.time()
[17:36:43.401]     ...future.result
[17:36:43.401] }
[17:36:43.403] assign_globals() ...
[17:36:43.404] List of 5
[17:36:43.404]  $ ...future.FUN            :function (x, ...)  
[17:36:43.404]  $ future.call.arguments    : list()
[17:36:43.404]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.404]  $ ...future.elements_ii    :List of 2
[17:36:43.404]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:36:43.404]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:36:43.404]  $ ...future.seeds_ii       : NULL
[17:36:43.404]  $ ...future.globals.maxSize: NULL
[17:36:43.404]  - attr(*, "where")=List of 5
[17:36:43.404]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.404]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.404]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.404]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.404]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.404]  - attr(*, "resolved")= logi FALSE
[17:36:43.404]  - attr(*, "total_size")= num 1240
[17:36:43.404]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.404]  - attr(*, "already-done")= logi TRUE
[17:36:43.411] - copied ‘...future.FUN’ to environment
[17:36:43.411] - copied ‘future.call.arguments’ to environment
[17:36:43.411] - copied ‘...future.elements_ii’ to environment
[17:36:43.411] - copied ‘...future.seeds_ii’ to environment
[17:36:43.411] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.411] assign_globals() ... done
[17:36:43.412] requestCore(): workers = 2
[17:36:43.417] MulticoreFuture started
[17:36:43.417] - Launch lazy future ... done
[17:36:43.418] run() for ‘MulticoreFuture’ ... done
[17:36:43.418] Created future:
[17:36:43.418] plan(): Setting new future strategy stack:
[17:36:43.418] List of future strategies:
[17:36:43.418] 1. sequential:
[17:36:43.418]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.418]    - tweaked: FALSE
[17:36:43.418]    - call: NULL
[17:36:43.419] plan(): nbrOfWorkers() = 1
[17:36:43.421] plan(): Setting new future strategy stack:
[17:36:43.421] List of future strategies:
[17:36:43.421] 1. multicore:
[17:36:43.421]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:43.421]    - tweaked: FALSE
[17:36:43.421]    - call: plan(strategy)
[17:36:43.426] plan(): nbrOfWorkers() = 2
[17:36:43.418] MulticoreFuture:
[17:36:43.418] Label: ‘future_eapply-2’
[17:36:43.418] Expression:
[17:36:43.418] {
[17:36:43.418]     do.call(function(...) {
[17:36:43.418]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.418]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.418]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.418]             on.exit(options(oopts), add = TRUE)
[17:36:43.418]         }
[17:36:43.418]         {
[17:36:43.418]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.418]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.418]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.418]             })
[17:36:43.418]         }
[17:36:43.418]     }, args = future.call.arguments)
[17:36:43.418] }
[17:36:43.418] Lazy evaluation: FALSE
[17:36:43.418] Asynchronous evaluation: TRUE
[17:36:43.418] Local evaluation: TRUE
[17:36:43.418] Environment: R_GlobalEnv
[17:36:43.418] Capture standard output: TRUE
[17:36:43.418] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.418] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.418] Packages: <none>
[17:36:43.418] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.418] Resolved: TRUE
[17:36:43.418] Value: <not collected>
[17:36:43.418] Conditions captured: <none>
[17:36:43.418] Early signaling: FALSE
[17:36:43.418] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.418] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.427] Chunk #2 of 2 ... DONE
[17:36:43.428] Launching 2 futures (chunks) ... DONE
[17:36:43.428] Resolving 2 futures (chunks) ...
[17:36:43.428] resolve() on list ...
[17:36:43.428]  recursive: 0
[17:36:43.428]  length: 2
[17:36:43.429] 
[17:36:43.429] Future #1
[17:36:43.430] result() for MulticoreFuture ...
[17:36:43.431] result() for MulticoreFuture ...
[17:36:43.431] result() for MulticoreFuture ... done
[17:36:43.432] result() for MulticoreFuture ... done
[17:36:43.432] result() for MulticoreFuture ...
[17:36:43.432] result() for MulticoreFuture ... done
[17:36:43.432] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:43.432] - nx: 2
[17:36:43.432] - relay: TRUE
[17:36:43.432] - stdout: TRUE
[17:36:43.433] - signal: TRUE
[17:36:43.433] - resignal: FALSE
[17:36:43.433] - force: TRUE
[17:36:43.433] - relayed: [n=2] FALSE, FALSE
[17:36:43.433] - queued futures: [n=2] FALSE, FALSE
[17:36:43.433]  - until=1
[17:36:43.433]  - relaying element #1
[17:36:43.434] result() for MulticoreFuture ...
[17:36:43.434] result() for MulticoreFuture ... done
[17:36:43.434] result() for MulticoreFuture ...
[17:36:43.434] result() for MulticoreFuture ... done
[17:36:43.434] result() for MulticoreFuture ...
[17:36:43.434] result() for MulticoreFuture ... done
[17:36:43.434] result() for MulticoreFuture ...
[17:36:43.435] result() for MulticoreFuture ... done
[17:36:43.435] - relayed: [n=2] TRUE, FALSE
[17:36:43.435] - queued futures: [n=2] TRUE, FALSE
[17:36:43.435] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:43.435]  length: 1 (resolved future 1)
[17:36:43.435] Future #2
[17:36:43.436] result() for MulticoreFuture ...
[17:36:43.436] result() for MulticoreFuture ...
[17:36:43.436] result() for MulticoreFuture ... done
[17:36:43.436] result() for MulticoreFuture ... done
[17:36:43.439] result() for MulticoreFuture ...
[17:36:43.439] result() for MulticoreFuture ... done
[17:36:43.439] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:43.439] - nx: 2
[17:36:43.440] - relay: TRUE
[17:36:43.440] - stdout: TRUE
[17:36:43.440] - signal: TRUE
[17:36:43.440] - resignal: FALSE
[17:36:43.440] - force: TRUE
[17:36:43.440] - relayed: [n=2] TRUE, FALSE
[17:36:43.440] - queued futures: [n=2] TRUE, FALSE
[17:36:43.440]  - until=2
[17:36:43.440]  - relaying element #2
[17:36:43.441] result() for MulticoreFuture ...
[17:36:43.441] result() for MulticoreFuture ... done
[17:36:43.441] result() for MulticoreFuture ...
[17:36:43.441] result() for MulticoreFuture ... done
[17:36:43.441] result() for MulticoreFuture ...
[17:36:43.441] result() for MulticoreFuture ... done
[17:36:43.441] result() for MulticoreFuture ...
[17:36:43.442] result() for MulticoreFuture ... done
[17:36:43.442] - relayed: [n=2] TRUE, TRUE
[17:36:43.442] - queued futures: [n=2] TRUE, TRUE
[17:36:43.442] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:43.442]  length: 0 (resolved future 2)
[17:36:43.442] Relaying remaining futures
[17:36:43.442] signalConditionsASAP(NULL, pos=0) ...
[17:36:43.442] - nx: 2
[17:36:43.443] - relay: TRUE
[17:36:43.443] - stdout: TRUE
[17:36:43.443] - signal: TRUE
[17:36:43.443] - resignal: FALSE
[17:36:43.443] - force: TRUE
[17:36:43.443] - relayed: [n=2] TRUE, TRUE
[17:36:43.443] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:43.443] - relayed: [n=2] TRUE, TRUE
[17:36:43.444] - queued futures: [n=2] TRUE, TRUE
[17:36:43.444] signalConditionsASAP(NULL, pos=0) ... done
[17:36:43.444] resolve() on list ... DONE
[17:36:43.444] result() for MulticoreFuture ...
[17:36:43.444] result() for MulticoreFuture ... done
[17:36:43.444] result() for MulticoreFuture ...
[17:36:43.444] result() for MulticoreFuture ... done
[17:36:43.445] result() for MulticoreFuture ...
[17:36:43.445] result() for MulticoreFuture ... done
[17:36:43.445] result() for MulticoreFuture ...
[17:36:43.445] result() for MulticoreFuture ... done
[17:36:43.445]  - Number of value chunks collected: 2
[17:36:43.445] Resolving 2 futures (chunks) ... DONE
[17:36:43.445] Reducing values from 2 chunks ...
[17:36:43.445]  - Number of values collected after concatenation: 3
[17:36:43.445]  - Number of values expected: 3
[17:36:43.446] Reducing values from 2 chunks ... DONE
[17:36:43.446] future_lapply() ... DONE
[17:36:43.446] future_lapply() ...
[17:36:43.451] Number of chunks: 2
[17:36:43.451] getGlobalsAndPackagesXApply() ...
[17:36:43.451]  - future.globals: TRUE
[17:36:43.451] getGlobalsAndPackages() ...
[17:36:43.451] Searching for globals...
[17:36:43.453] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:43.453] Searching for globals ... DONE
[17:36:43.453] Resolving globals: FALSE
[17:36:43.453] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:43.454] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:43.454] - globals: [1] ‘FUN’
[17:36:43.454] - packages: [1] ‘stats’
[17:36:43.454] getGlobalsAndPackages() ... DONE
[17:36:43.454]  - globals found/used: [n=1] ‘FUN’
[17:36:43.455]  - needed namespaces: [n=1] ‘stats’
[17:36:43.455] Finding globals ... DONE
[17:36:43.455]  - use_args: TRUE
[17:36:43.455]  - Getting '...' globals ...
[17:36:43.455] resolve() on list ...
[17:36:43.455]  recursive: 0
[17:36:43.455]  length: 1
[17:36:43.456]  elements: ‘...’
[17:36:43.456]  length: 0 (resolved future 1)
[17:36:43.456] resolve() on list ... DONE
[17:36:43.456]    - '...' content: [n=1] ‘probs’
[17:36:43.456] List of 1
[17:36:43.456]  $ ...:List of 1
[17:36:43.456]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:36:43.456]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.456]  - attr(*, "where")=List of 1
[17:36:43.456]   ..$ ...:<environment: 0x565502fbffe8> 
[17:36:43.456]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.456]  - attr(*, "resolved")= logi TRUE
[17:36:43.456]  - attr(*, "total_size")= num NA
[17:36:43.460]  - Getting '...' globals ... DONE
[17:36:43.460] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:43.460] List of 2
[17:36:43.460]  $ ...future.FUN:function (x, ...)  
[17:36:43.460]  $ ...          :List of 1
[17:36:43.460]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:36:43.460]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.460]  - attr(*, "where")=List of 2
[17:36:43.460]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:43.460]   ..$ ...          :<environment: 0x565502fbffe8> 
[17:36:43.460]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.460]  - attr(*, "resolved")= logi FALSE
[17:36:43.460]  - attr(*, "total_size")= num 1328
[17:36:43.463] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:43.463] getGlobalsAndPackagesXApply() ... DONE
[17:36:43.463] Number of futures (= number of chunks): 2
[17:36:43.464] Launching 2 futures (chunks) ...
[17:36:43.464] Chunk #1 of 2 ...
[17:36:43.464]  - Finding globals in 'X' for chunk #1 ...
[17:36:43.464] getGlobalsAndPackages() ...
[17:36:43.464] Searching for globals...
[17:36:43.464] 
[17:36:43.464] Searching for globals ... DONE
[17:36:43.464] - globals: [0] <none>
[17:36:43.464] getGlobalsAndPackages() ... DONE
[17:36:43.465]    + additional globals found: [n=0] 
[17:36:43.465]    + additional namespaces needed: [n=0] 
[17:36:43.465]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:43.465]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:43.465]  - seeds: <none>
[17:36:43.465]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.465] getGlobalsAndPackages() ...
[17:36:43.465] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.465] Resolving globals: FALSE
[17:36:43.465] Tweak future expression to call with '...' arguments ...
[17:36:43.466] {
[17:36:43.466]     do.call(function(...) {
[17:36:43.466]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.466]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.466]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.466]             on.exit(options(oopts), add = TRUE)
[17:36:43.466]         }
[17:36:43.466]         {
[17:36:43.466]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.466]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.466]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.466]             })
[17:36:43.466]         }
[17:36:43.466]     }, args = future.call.arguments)
[17:36:43.466] }
[17:36:43.466] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.466] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.466] - packages: [1] ‘stats’
[17:36:43.466] getGlobalsAndPackages() ... DONE
[17:36:43.467] run() for ‘Future’ ...
[17:36:43.467] - state: ‘created’
[17:36:43.467] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:43.473] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.473] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:43.473]   - Field: ‘label’
[17:36:43.473]   - Field: ‘local’
[17:36:43.473]   - Field: ‘owner’
[17:36:43.473]   - Field: ‘envir’
[17:36:43.473]   - Field: ‘workers’
[17:36:43.474]   - Field: ‘packages’
[17:36:43.474]   - Field: ‘gc’
[17:36:43.474]   - Field: ‘job’
[17:36:43.474]   - Field: ‘conditions’
[17:36:43.474]   - Field: ‘expr’
[17:36:43.474]   - Field: ‘uuid’
[17:36:43.474]   - Field: ‘seed’
[17:36:43.474]   - Field: ‘version’
[17:36:43.474]   - Field: ‘result’
[17:36:43.474]   - Field: ‘asynchronous’
[17:36:43.475]   - Field: ‘calls’
[17:36:43.475]   - Field: ‘globals’
[17:36:43.475]   - Field: ‘stdout’
[17:36:43.475]   - Field: ‘earlySignal’
[17:36:43.475]   - Field: ‘lazy’
[17:36:43.475]   - Field: ‘state’
[17:36:43.475] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:43.475] - Launch lazy future ...
[17:36:43.476] Packages needed by the future expression (n = 1): ‘stats’
[17:36:43.476] Packages needed by future strategies (n = 0): <none>
[17:36:43.476] {
[17:36:43.476]     {
[17:36:43.476]         {
[17:36:43.476]             ...future.startTime <- base::Sys.time()
[17:36:43.476]             {
[17:36:43.476]                 {
[17:36:43.476]                   {
[17:36:43.476]                     {
[17:36:43.476]                       {
[17:36:43.476]                         base::local({
[17:36:43.476]                           has_future <- base::requireNamespace("future", 
[17:36:43.476]                             quietly = TRUE)
[17:36:43.476]                           if (has_future) {
[17:36:43.476]                             ns <- base::getNamespace("future")
[17:36:43.476]                             version <- ns[[".package"]][["version"]]
[17:36:43.476]                             if (is.null(version)) 
[17:36:43.476]                               version <- utils::packageVersion("future")
[17:36:43.476]                           }
[17:36:43.476]                           else {
[17:36:43.476]                             version <- NULL
[17:36:43.476]                           }
[17:36:43.476]                           if (!has_future || version < "1.8.0") {
[17:36:43.476]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.476]                               "", base::R.version$version.string), 
[17:36:43.476]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:43.476]                                 base::R.version$platform, 8 * 
[17:36:43.476]                                   base::.Machine$sizeof.pointer), 
[17:36:43.476]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.476]                                 "release", "version")], collapse = " "), 
[17:36:43.476]                               hostname = base::Sys.info()[["nodename"]])
[17:36:43.476]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.476]                               info)
[17:36:43.476]                             info <- base::paste(info, collapse = "; ")
[17:36:43.476]                             if (!has_future) {
[17:36:43.476]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.476]                                 info)
[17:36:43.476]                             }
[17:36:43.476]                             else {
[17:36:43.476]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.476]                                 info, version)
[17:36:43.476]                             }
[17:36:43.476]                             base::stop(msg)
[17:36:43.476]                           }
[17:36:43.476]                         })
[17:36:43.476]                       }
[17:36:43.476]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:43.476]                       base::options(mc.cores = 1L)
[17:36:43.476]                     }
[17:36:43.476]                     base::local({
[17:36:43.476]                       for (pkg in "stats") {
[17:36:43.476]                         base::loadNamespace(pkg)
[17:36:43.476]                         base::library(pkg, character.only = TRUE)
[17:36:43.476]                       }
[17:36:43.476]                     })
[17:36:43.476]                   }
[17:36:43.476]                   ...future.strategy.old <- future::plan("list")
[17:36:43.476]                   options(future.plan = NULL)
[17:36:43.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.476]                 }
[17:36:43.476]                 ...future.workdir <- getwd()
[17:36:43.476]             }
[17:36:43.476]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.476]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.476]         }
[17:36:43.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.476]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:43.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.476]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.476]             base::names(...future.oldOptions))
[17:36:43.476]     }
[17:36:43.476]     if (FALSE) {
[17:36:43.476]     }
[17:36:43.476]     else {
[17:36:43.476]         if (TRUE) {
[17:36:43.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.476]                 open = "w")
[17:36:43.476]         }
[17:36:43.476]         else {
[17:36:43.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.476]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.476]         }
[17:36:43.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.476]             base::sink(type = "output", split = FALSE)
[17:36:43.476]             base::close(...future.stdout)
[17:36:43.476]         }, add = TRUE)
[17:36:43.476]     }
[17:36:43.476]     ...future.frame <- base::sys.nframe()
[17:36:43.476]     ...future.conditions <- base::list()
[17:36:43.476]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.476]     if (FALSE) {
[17:36:43.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.476]     }
[17:36:43.476]     ...future.result <- base::tryCatch({
[17:36:43.476]         base::withCallingHandlers({
[17:36:43.476]             ...future.value <- base::withVisible(base::local({
[17:36:43.476]                 withCallingHandlers({
[17:36:43.476]                   {
[17:36:43.476]                     do.call(function(...) {
[17:36:43.476]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.476]                       if (!identical(...future.globals.maxSize.org, 
[17:36:43.476]                         ...future.globals.maxSize)) {
[17:36:43.476]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.476]                         on.exit(options(oopts), add = TRUE)
[17:36:43.476]                       }
[17:36:43.476]                       {
[17:36:43.476]                         lapply(seq_along(...future.elements_ii), 
[17:36:43.476]                           FUN = function(jj) {
[17:36:43.476]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.476]                             ...future.FUN(...future.X_jj, ...)
[17:36:43.476]                           })
[17:36:43.476]                       }
[17:36:43.476]                     }, args = future.call.arguments)
[17:36:43.476]                   }
[17:36:43.476]                 }, immediateCondition = function(cond) {
[17:36:43.476]                   save_rds <- function (object, pathname, ...) 
[17:36:43.476]                   {
[17:36:43.476]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:43.476]                     if (file_test("-f", pathname_tmp)) {
[17:36:43.476]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.476]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:43.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.476]                         fi_tmp[["mtime"]])
[17:36:43.476]                     }
[17:36:43.476]                     tryCatch({
[17:36:43.476]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:43.476]                     }, error = function(ex) {
[17:36:43.476]                       msg <- conditionMessage(ex)
[17:36:43.476]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.476]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:43.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.476]                         fi_tmp[["mtime"]], msg)
[17:36:43.476]                       ex$message <- msg
[17:36:43.476]                       stop(ex)
[17:36:43.476]                     })
[17:36:43.476]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:43.476]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:43.476]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:43.476]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.476]                       fi <- file.info(pathname)
[17:36:43.476]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:43.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.476]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:43.476]                         fi[["size"]], fi[["mtime"]])
[17:36:43.476]                       stop(msg)
[17:36:43.476]                     }
[17:36:43.476]                     invisible(pathname)
[17:36:43.476]                   }
[17:36:43.476]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:43.476]                     rootPath = tempdir()) 
[17:36:43.476]                   {
[17:36:43.476]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:43.476]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:43.476]                       tmpdir = path, fileext = ".rds")
[17:36:43.476]                     save_rds(obj, file)
[17:36:43.476]                   }
[17:36:43.476]                   saveImmediateCondition(cond, path = "/tmp/RtmpEOKIKx/.future/immediateConditions")
[17:36:43.476]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.476]                   {
[17:36:43.476]                     inherits <- base::inherits
[17:36:43.476]                     invokeRestart <- base::invokeRestart
[17:36:43.476]                     is.null <- base::is.null
[17:36:43.476]                     muffled <- FALSE
[17:36:43.476]                     if (inherits(cond, "message")) {
[17:36:43.476]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:43.476]                       if (muffled) 
[17:36:43.476]                         invokeRestart("muffleMessage")
[17:36:43.476]                     }
[17:36:43.476]                     else if (inherits(cond, "warning")) {
[17:36:43.476]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:43.476]                       if (muffled) 
[17:36:43.476]                         invokeRestart("muffleWarning")
[17:36:43.476]                     }
[17:36:43.476]                     else if (inherits(cond, "condition")) {
[17:36:43.476]                       if (!is.null(pattern)) {
[17:36:43.476]                         computeRestarts <- base::computeRestarts
[17:36:43.476]                         grepl <- base::grepl
[17:36:43.476]                         restarts <- computeRestarts(cond)
[17:36:43.476]                         for (restart in restarts) {
[17:36:43.476]                           name <- restart$name
[17:36:43.476]                           if (is.null(name)) 
[17:36:43.476]                             next
[17:36:43.476]                           if (!grepl(pattern, name)) 
[17:36:43.476]                             next
[17:36:43.476]                           invokeRestart(restart)
[17:36:43.476]                           muffled <- TRUE
[17:36:43.476]                           break
[17:36:43.476]                         }
[17:36:43.476]                       }
[17:36:43.476]                     }
[17:36:43.476]                     invisible(muffled)
[17:36:43.476]                   }
[17:36:43.476]                   muffleCondition(cond)
[17:36:43.476]                 })
[17:36:43.476]             }))
[17:36:43.476]             future::FutureResult(value = ...future.value$value, 
[17:36:43.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.476]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.476]                     ...future.globalenv.names))
[17:36:43.476]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.476]         }, condition = base::local({
[17:36:43.476]             c <- base::c
[17:36:43.476]             inherits <- base::inherits
[17:36:43.476]             invokeRestart <- base::invokeRestart
[17:36:43.476]             length <- base::length
[17:36:43.476]             list <- base::list
[17:36:43.476]             seq.int <- base::seq.int
[17:36:43.476]             signalCondition <- base::signalCondition
[17:36:43.476]             sys.calls <- base::sys.calls
[17:36:43.476]             `[[` <- base::`[[`
[17:36:43.476]             `+` <- base::`+`
[17:36:43.476]             `<<-` <- base::`<<-`
[17:36:43.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.476]                   3L)]
[17:36:43.476]             }
[17:36:43.476]             function(cond) {
[17:36:43.476]                 is_error <- inherits(cond, "error")
[17:36:43.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.476]                   NULL)
[17:36:43.476]                 if (is_error) {
[17:36:43.476]                   sessionInformation <- function() {
[17:36:43.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.476]                       search = base::search(), system = base::Sys.info())
[17:36:43.476]                   }
[17:36:43.476]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.476]                     cond$call), session = sessionInformation(), 
[17:36:43.476]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.476]                   signalCondition(cond)
[17:36:43.476]                 }
[17:36:43.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.476]                 "immediateCondition"))) {
[17:36:43.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.476]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.476]                   if (TRUE && !signal) {
[17:36:43.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.476]                     {
[17:36:43.476]                       inherits <- base::inherits
[17:36:43.476]                       invokeRestart <- base::invokeRestart
[17:36:43.476]                       is.null <- base::is.null
[17:36:43.476]                       muffled <- FALSE
[17:36:43.476]                       if (inherits(cond, "message")) {
[17:36:43.476]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.476]                         if (muffled) 
[17:36:43.476]                           invokeRestart("muffleMessage")
[17:36:43.476]                       }
[17:36:43.476]                       else if (inherits(cond, "warning")) {
[17:36:43.476]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.476]                         if (muffled) 
[17:36:43.476]                           invokeRestart("muffleWarning")
[17:36:43.476]                       }
[17:36:43.476]                       else if (inherits(cond, "condition")) {
[17:36:43.476]                         if (!is.null(pattern)) {
[17:36:43.476]                           computeRestarts <- base::computeRestarts
[17:36:43.476]                           grepl <- base::grepl
[17:36:43.476]                           restarts <- computeRestarts(cond)
[17:36:43.476]                           for (restart in restarts) {
[17:36:43.476]                             name <- restart$name
[17:36:43.476]                             if (is.null(name)) 
[17:36:43.476]                               next
[17:36:43.476]                             if (!grepl(pattern, name)) 
[17:36:43.476]                               next
[17:36:43.476]                             invokeRestart(restart)
[17:36:43.476]                             muffled <- TRUE
[17:36:43.476]                             break
[17:36:43.476]                           }
[17:36:43.476]                         }
[17:36:43.476]                       }
[17:36:43.476]                       invisible(muffled)
[17:36:43.476]                     }
[17:36:43.476]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.476]                   }
[17:36:43.476]                 }
[17:36:43.476]                 else {
[17:36:43.476]                   if (TRUE) {
[17:36:43.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.476]                     {
[17:36:43.476]                       inherits <- base::inherits
[17:36:43.476]                       invokeRestart <- base::invokeRestart
[17:36:43.476]                       is.null <- base::is.null
[17:36:43.476]                       muffled <- FALSE
[17:36:43.476]                       if (inherits(cond, "message")) {
[17:36:43.476]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.476]                         if (muffled) 
[17:36:43.476]                           invokeRestart("muffleMessage")
[17:36:43.476]                       }
[17:36:43.476]                       else if (inherits(cond, "warning")) {
[17:36:43.476]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.476]                         if (muffled) 
[17:36:43.476]                           invokeRestart("muffleWarning")
[17:36:43.476]                       }
[17:36:43.476]                       else if (inherits(cond, "condition")) {
[17:36:43.476]                         if (!is.null(pattern)) {
[17:36:43.476]                           computeRestarts <- base::computeRestarts
[17:36:43.476]                           grepl <- base::grepl
[17:36:43.476]                           restarts <- computeRestarts(cond)
[17:36:43.476]                           for (restart in restarts) {
[17:36:43.476]                             name <- restart$name
[17:36:43.476]                             if (is.null(name)) 
[17:36:43.476]                               next
[17:36:43.476]                             if (!grepl(pattern, name)) 
[17:36:43.476]                               next
[17:36:43.476]                             invokeRestart(restart)
[17:36:43.476]                             muffled <- TRUE
[17:36:43.476]                             break
[17:36:43.476]                           }
[17:36:43.476]                         }
[17:36:43.476]                       }
[17:36:43.476]                       invisible(muffled)
[17:36:43.476]                     }
[17:36:43.476]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.476]                   }
[17:36:43.476]                 }
[17:36:43.476]             }
[17:36:43.476]         }))
[17:36:43.476]     }, error = function(ex) {
[17:36:43.476]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.476]                 ...future.rng), started = ...future.startTime, 
[17:36:43.476]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.476]             version = "1.8"), class = "FutureResult")
[17:36:43.476]     }, finally = {
[17:36:43.476]         if (!identical(...future.workdir, getwd())) 
[17:36:43.476]             setwd(...future.workdir)
[17:36:43.476]         {
[17:36:43.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.476]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.476]             }
[17:36:43.476]             base::options(...future.oldOptions)
[17:36:43.476]             if (.Platform$OS.type == "windows") {
[17:36:43.476]                 old_names <- names(...future.oldEnvVars)
[17:36:43.476]                 envs <- base::Sys.getenv()
[17:36:43.476]                 names <- names(envs)
[17:36:43.476]                 common <- intersect(names, old_names)
[17:36:43.476]                 added <- setdiff(names, old_names)
[17:36:43.476]                 removed <- setdiff(old_names, names)
[17:36:43.476]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.476]                   envs[common]]
[17:36:43.476]                 NAMES <- toupper(changed)
[17:36:43.476]                 args <- list()
[17:36:43.476]                 for (kk in seq_along(NAMES)) {
[17:36:43.476]                   name <- changed[[kk]]
[17:36:43.476]                   NAME <- NAMES[[kk]]
[17:36:43.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.476]                     next
[17:36:43.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.476]                 }
[17:36:43.476]                 NAMES <- toupper(added)
[17:36:43.476]                 for (kk in seq_along(NAMES)) {
[17:36:43.476]                   name <- added[[kk]]
[17:36:43.476]                   NAME <- NAMES[[kk]]
[17:36:43.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.476]                     next
[17:36:43.476]                   args[[name]] <- ""
[17:36:43.476]                 }
[17:36:43.476]                 NAMES <- toupper(removed)
[17:36:43.476]                 for (kk in seq_along(NAMES)) {
[17:36:43.476]                   name <- removed[[kk]]
[17:36:43.476]                   NAME <- NAMES[[kk]]
[17:36:43.476]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.476]                     next
[17:36:43.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.476]                 }
[17:36:43.476]                 if (length(args) > 0) 
[17:36:43.476]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.476]             }
[17:36:43.476]             else {
[17:36:43.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.476]             }
[17:36:43.476]             {
[17:36:43.476]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.476]                   0L) {
[17:36:43.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.476]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.476]                   base::options(opts)
[17:36:43.476]                 }
[17:36:43.476]                 {
[17:36:43.476]                   {
[17:36:43.476]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:43.476]                     NULL
[17:36:43.476]                   }
[17:36:43.476]                   options(future.plan = NULL)
[17:36:43.476]                   if (is.na(NA_character_)) 
[17:36:43.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.476]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.476]                     .init = FALSE)
[17:36:43.476]                 }
[17:36:43.476]             }
[17:36:43.476]         }
[17:36:43.476]     })
[17:36:43.476]     if (TRUE) {
[17:36:43.476]         base::sink(type = "output", split = FALSE)
[17:36:43.476]         if (TRUE) {
[17:36:43.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.476]         }
[17:36:43.476]         else {
[17:36:43.476]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.476]         }
[17:36:43.476]         base::close(...future.stdout)
[17:36:43.476]         ...future.stdout <- NULL
[17:36:43.476]     }
[17:36:43.476]     ...future.result$conditions <- ...future.conditions
[17:36:43.476]     ...future.result$finished <- base::Sys.time()
[17:36:43.476]     ...future.result
[17:36:43.476] }
[17:36:43.479] assign_globals() ...
[17:36:43.479] List of 5
[17:36:43.479]  $ ...future.FUN            :function (x, ...)  
[17:36:43.479]  $ future.call.arguments    :List of 1
[17:36:43.479]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:36:43.479]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.479]  $ ...future.elements_ii    :List of 1
[17:36:43.479]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:36:43.479]  $ ...future.seeds_ii       : NULL
[17:36:43.479]  $ ...future.globals.maxSize: NULL
[17:36:43.479]  - attr(*, "where")=List of 5
[17:36:43.479]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.479]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.479]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.479]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.479]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.479]  - attr(*, "resolved")= logi FALSE
[17:36:43.479]  - attr(*, "total_size")= num 1328
[17:36:43.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.479]  - attr(*, "already-done")= logi TRUE
[17:36:43.484] - copied ‘...future.FUN’ to environment
[17:36:43.484] - copied ‘future.call.arguments’ to environment
[17:36:43.484] - copied ‘...future.elements_ii’ to environment
[17:36:43.484] - copied ‘...future.seeds_ii’ to environment
[17:36:43.484] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.484] assign_globals() ... done
[17:36:43.484] requestCore(): workers = 2
[17:36:43.486] MulticoreFuture started
[17:36:43.487] - Launch lazy future ... done
[17:36:43.487] run() for ‘MulticoreFuture’ ... done
[17:36:43.487] Created future:
[17:36:43.488] plan(): Setting new future strategy stack:
[17:36:43.488] List of future strategies:
[17:36:43.488] 1. sequential:
[17:36:43.488]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.488]    - tweaked: FALSE
[17:36:43.488]    - call: NULL
[17:36:43.489] plan(): nbrOfWorkers() = 1
[17:36:43.491] plan(): Setting new future strategy stack:
[17:36:43.492] List of future strategies:
[17:36:43.492] 1. multicore:
[17:36:43.492]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:43.492]    - tweaked: FALSE
[17:36:43.492]    - call: plan(strategy)
[17:36:43.497] plan(): nbrOfWorkers() = 2
[17:36:43.487] MulticoreFuture:
[17:36:43.487] Label: ‘future_eapply-1’
[17:36:43.487] Expression:
[17:36:43.487] {
[17:36:43.487]     do.call(function(...) {
[17:36:43.487]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.487]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.487]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.487]             on.exit(options(oopts), add = TRUE)
[17:36:43.487]         }
[17:36:43.487]         {
[17:36:43.487]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.487]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.487]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.487]             })
[17:36:43.487]         }
[17:36:43.487]     }, args = future.call.arguments)
[17:36:43.487] }
[17:36:43.487] Lazy evaluation: FALSE
[17:36:43.487] Asynchronous evaluation: TRUE
[17:36:43.487] Local evaluation: TRUE
[17:36:43.487] Environment: R_GlobalEnv
[17:36:43.487] Capture standard output: TRUE
[17:36:43.487] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.487] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.487] Packages: 1 packages (‘stats’)
[17:36:43.487] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.487] Resolved: TRUE
[17:36:43.487] Value: <not collected>
[17:36:43.487] Conditions captured: <none>
[17:36:43.487] Early signaling: FALSE
[17:36:43.487] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.487] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.498] Chunk #1 of 2 ... DONE
[17:36:43.498] Chunk #2 of 2 ...
[17:36:43.498]  - Finding globals in 'X' for chunk #2 ...
[17:36:43.498] getGlobalsAndPackages() ...
[17:36:43.498] Searching for globals...
[17:36:43.499] 
[17:36:43.499] Searching for globals ... DONE
[17:36:43.499] - globals: [0] <none>
[17:36:43.499] getGlobalsAndPackages() ... DONE
[17:36:43.499]    + additional globals found: [n=0] 
[17:36:43.499]    + additional namespaces needed: [n=0] 
[17:36:43.499]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:43.499]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:43.500]  - seeds: <none>
[17:36:43.500]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.500] getGlobalsAndPackages() ...
[17:36:43.500] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.500] Resolving globals: FALSE
[17:36:43.500] Tweak future expression to call with '...' arguments ...
[17:36:43.501] {
[17:36:43.501]     do.call(function(...) {
[17:36:43.501]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.501]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.501]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.501]             on.exit(options(oopts), add = TRUE)
[17:36:43.501]         }
[17:36:43.501]         {
[17:36:43.501]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.501]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.501]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.501]             })
[17:36:43.501]         }
[17:36:43.501]     }, args = future.call.arguments)
[17:36:43.501] }
[17:36:43.501] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.502] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.502] - packages: [1] ‘stats’
[17:36:43.502] getGlobalsAndPackages() ... DONE
[17:36:43.502] run() for ‘Future’ ...
[17:36:43.503] - state: ‘created’
[17:36:43.503] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:43.507] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.507] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:43.507]   - Field: ‘label’
[17:36:43.508]   - Field: ‘local’
[17:36:43.508]   - Field: ‘owner’
[17:36:43.508]   - Field: ‘envir’
[17:36:43.508]   - Field: ‘workers’
[17:36:43.508]   - Field: ‘packages’
[17:36:43.508]   - Field: ‘gc’
[17:36:43.508]   - Field: ‘job’
[17:36:43.509]   - Field: ‘conditions’
[17:36:43.509]   - Field: ‘expr’
[17:36:43.509]   - Field: ‘uuid’
[17:36:43.509]   - Field: ‘seed’
[17:36:43.509]   - Field: ‘version’
[17:36:43.509]   - Field: ‘result’
[17:36:43.509]   - Field: ‘asynchronous’
[17:36:43.509]   - Field: ‘calls’
[17:36:43.510]   - Field: ‘globals’
[17:36:43.510]   - Field: ‘stdout’
[17:36:43.510]   - Field: ‘earlySignal’
[17:36:43.510]   - Field: ‘lazy’
[17:36:43.510]   - Field: ‘state’
[17:36:43.510] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:43.510] - Launch lazy future ...
[17:36:43.511] Packages needed by the future expression (n = 1): ‘stats’
[17:36:43.511] Packages needed by future strategies (n = 0): <none>
[17:36:43.512] {
[17:36:43.512]     {
[17:36:43.512]         {
[17:36:43.512]             ...future.startTime <- base::Sys.time()
[17:36:43.512]             {
[17:36:43.512]                 {
[17:36:43.512]                   {
[17:36:43.512]                     {
[17:36:43.512]                       {
[17:36:43.512]                         base::local({
[17:36:43.512]                           has_future <- base::requireNamespace("future", 
[17:36:43.512]                             quietly = TRUE)
[17:36:43.512]                           if (has_future) {
[17:36:43.512]                             ns <- base::getNamespace("future")
[17:36:43.512]                             version <- ns[[".package"]][["version"]]
[17:36:43.512]                             if (is.null(version)) 
[17:36:43.512]                               version <- utils::packageVersion("future")
[17:36:43.512]                           }
[17:36:43.512]                           else {
[17:36:43.512]                             version <- NULL
[17:36:43.512]                           }
[17:36:43.512]                           if (!has_future || version < "1.8.0") {
[17:36:43.512]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.512]                               "", base::R.version$version.string), 
[17:36:43.512]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:43.512]                                 base::R.version$platform, 8 * 
[17:36:43.512]                                   base::.Machine$sizeof.pointer), 
[17:36:43.512]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.512]                                 "release", "version")], collapse = " "), 
[17:36:43.512]                               hostname = base::Sys.info()[["nodename"]])
[17:36:43.512]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.512]                               info)
[17:36:43.512]                             info <- base::paste(info, collapse = "; ")
[17:36:43.512]                             if (!has_future) {
[17:36:43.512]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.512]                                 info)
[17:36:43.512]                             }
[17:36:43.512]                             else {
[17:36:43.512]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.512]                                 info, version)
[17:36:43.512]                             }
[17:36:43.512]                             base::stop(msg)
[17:36:43.512]                           }
[17:36:43.512]                         })
[17:36:43.512]                       }
[17:36:43.512]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:43.512]                       base::options(mc.cores = 1L)
[17:36:43.512]                     }
[17:36:43.512]                     base::local({
[17:36:43.512]                       for (pkg in "stats") {
[17:36:43.512]                         base::loadNamespace(pkg)
[17:36:43.512]                         base::library(pkg, character.only = TRUE)
[17:36:43.512]                       }
[17:36:43.512]                     })
[17:36:43.512]                   }
[17:36:43.512]                   ...future.strategy.old <- future::plan("list")
[17:36:43.512]                   options(future.plan = NULL)
[17:36:43.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.512]                 }
[17:36:43.512]                 ...future.workdir <- getwd()
[17:36:43.512]             }
[17:36:43.512]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.512]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.512]         }
[17:36:43.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.512]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:43.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.512]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.512]             base::names(...future.oldOptions))
[17:36:43.512]     }
[17:36:43.512]     if (FALSE) {
[17:36:43.512]     }
[17:36:43.512]     else {
[17:36:43.512]         if (TRUE) {
[17:36:43.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.512]                 open = "w")
[17:36:43.512]         }
[17:36:43.512]         else {
[17:36:43.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.512]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.512]         }
[17:36:43.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.512]             base::sink(type = "output", split = FALSE)
[17:36:43.512]             base::close(...future.stdout)
[17:36:43.512]         }, add = TRUE)
[17:36:43.512]     }
[17:36:43.512]     ...future.frame <- base::sys.nframe()
[17:36:43.512]     ...future.conditions <- base::list()
[17:36:43.512]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.512]     if (FALSE) {
[17:36:43.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.512]     }
[17:36:43.512]     ...future.result <- base::tryCatch({
[17:36:43.512]         base::withCallingHandlers({
[17:36:43.512]             ...future.value <- base::withVisible(base::local({
[17:36:43.512]                 withCallingHandlers({
[17:36:43.512]                   {
[17:36:43.512]                     do.call(function(...) {
[17:36:43.512]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.512]                       if (!identical(...future.globals.maxSize.org, 
[17:36:43.512]                         ...future.globals.maxSize)) {
[17:36:43.512]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.512]                         on.exit(options(oopts), add = TRUE)
[17:36:43.512]                       }
[17:36:43.512]                       {
[17:36:43.512]                         lapply(seq_along(...future.elements_ii), 
[17:36:43.512]                           FUN = function(jj) {
[17:36:43.512]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.512]                             ...future.FUN(...future.X_jj, ...)
[17:36:43.512]                           })
[17:36:43.512]                       }
[17:36:43.512]                     }, args = future.call.arguments)
[17:36:43.512]                   }
[17:36:43.512]                 }, immediateCondition = function(cond) {
[17:36:43.512]                   save_rds <- function (object, pathname, ...) 
[17:36:43.512]                   {
[17:36:43.512]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:43.512]                     if (file_test("-f", pathname_tmp)) {
[17:36:43.512]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.512]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:43.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.512]                         fi_tmp[["mtime"]])
[17:36:43.512]                     }
[17:36:43.512]                     tryCatch({
[17:36:43.512]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:43.512]                     }, error = function(ex) {
[17:36:43.512]                       msg <- conditionMessage(ex)
[17:36:43.512]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.512]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:43.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.512]                         fi_tmp[["mtime"]], msg)
[17:36:43.512]                       ex$message <- msg
[17:36:43.512]                       stop(ex)
[17:36:43.512]                     })
[17:36:43.512]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:43.512]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:43.512]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:43.512]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.512]                       fi <- file.info(pathname)
[17:36:43.512]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:43.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.512]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:43.512]                         fi[["size"]], fi[["mtime"]])
[17:36:43.512]                       stop(msg)
[17:36:43.512]                     }
[17:36:43.512]                     invisible(pathname)
[17:36:43.512]                   }
[17:36:43.512]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:43.512]                     rootPath = tempdir()) 
[17:36:43.512]                   {
[17:36:43.512]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:43.512]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:43.512]                       tmpdir = path, fileext = ".rds")
[17:36:43.512]                     save_rds(obj, file)
[17:36:43.512]                   }
[17:36:43.512]                   saveImmediateCondition(cond, path = "/tmp/RtmpEOKIKx/.future/immediateConditions")
[17:36:43.512]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.512]                   {
[17:36:43.512]                     inherits <- base::inherits
[17:36:43.512]                     invokeRestart <- base::invokeRestart
[17:36:43.512]                     is.null <- base::is.null
[17:36:43.512]                     muffled <- FALSE
[17:36:43.512]                     if (inherits(cond, "message")) {
[17:36:43.512]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:43.512]                       if (muffled) 
[17:36:43.512]                         invokeRestart("muffleMessage")
[17:36:43.512]                     }
[17:36:43.512]                     else if (inherits(cond, "warning")) {
[17:36:43.512]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:43.512]                       if (muffled) 
[17:36:43.512]                         invokeRestart("muffleWarning")
[17:36:43.512]                     }
[17:36:43.512]                     else if (inherits(cond, "condition")) {
[17:36:43.512]                       if (!is.null(pattern)) {
[17:36:43.512]                         computeRestarts <- base::computeRestarts
[17:36:43.512]                         grepl <- base::grepl
[17:36:43.512]                         restarts <- computeRestarts(cond)
[17:36:43.512]                         for (restart in restarts) {
[17:36:43.512]                           name <- restart$name
[17:36:43.512]                           if (is.null(name)) 
[17:36:43.512]                             next
[17:36:43.512]                           if (!grepl(pattern, name)) 
[17:36:43.512]                             next
[17:36:43.512]                           invokeRestart(restart)
[17:36:43.512]                           muffled <- TRUE
[17:36:43.512]                           break
[17:36:43.512]                         }
[17:36:43.512]                       }
[17:36:43.512]                     }
[17:36:43.512]                     invisible(muffled)
[17:36:43.512]                   }
[17:36:43.512]                   muffleCondition(cond)
[17:36:43.512]                 })
[17:36:43.512]             }))
[17:36:43.512]             future::FutureResult(value = ...future.value$value, 
[17:36:43.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.512]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.512]                     ...future.globalenv.names))
[17:36:43.512]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.512]         }, condition = base::local({
[17:36:43.512]             c <- base::c
[17:36:43.512]             inherits <- base::inherits
[17:36:43.512]             invokeRestart <- base::invokeRestart
[17:36:43.512]             length <- base::length
[17:36:43.512]             list <- base::list
[17:36:43.512]             seq.int <- base::seq.int
[17:36:43.512]             signalCondition <- base::signalCondition
[17:36:43.512]             sys.calls <- base::sys.calls
[17:36:43.512]             `[[` <- base::`[[`
[17:36:43.512]             `+` <- base::`+`
[17:36:43.512]             `<<-` <- base::`<<-`
[17:36:43.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.512]                   3L)]
[17:36:43.512]             }
[17:36:43.512]             function(cond) {
[17:36:43.512]                 is_error <- inherits(cond, "error")
[17:36:43.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.512]                   NULL)
[17:36:43.512]                 if (is_error) {
[17:36:43.512]                   sessionInformation <- function() {
[17:36:43.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.512]                       search = base::search(), system = base::Sys.info())
[17:36:43.512]                   }
[17:36:43.512]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.512]                     cond$call), session = sessionInformation(), 
[17:36:43.512]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.512]                   signalCondition(cond)
[17:36:43.512]                 }
[17:36:43.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.512]                 "immediateCondition"))) {
[17:36:43.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.512]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.512]                   if (TRUE && !signal) {
[17:36:43.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.512]                     {
[17:36:43.512]                       inherits <- base::inherits
[17:36:43.512]                       invokeRestart <- base::invokeRestart
[17:36:43.512]                       is.null <- base::is.null
[17:36:43.512]                       muffled <- FALSE
[17:36:43.512]                       if (inherits(cond, "message")) {
[17:36:43.512]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.512]                         if (muffled) 
[17:36:43.512]                           invokeRestart("muffleMessage")
[17:36:43.512]                       }
[17:36:43.512]                       else if (inherits(cond, "warning")) {
[17:36:43.512]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.512]                         if (muffled) 
[17:36:43.512]                           invokeRestart("muffleWarning")
[17:36:43.512]                       }
[17:36:43.512]                       else if (inherits(cond, "condition")) {
[17:36:43.512]                         if (!is.null(pattern)) {
[17:36:43.512]                           computeRestarts <- base::computeRestarts
[17:36:43.512]                           grepl <- base::grepl
[17:36:43.512]                           restarts <- computeRestarts(cond)
[17:36:43.512]                           for (restart in restarts) {
[17:36:43.512]                             name <- restart$name
[17:36:43.512]                             if (is.null(name)) 
[17:36:43.512]                               next
[17:36:43.512]                             if (!grepl(pattern, name)) 
[17:36:43.512]                               next
[17:36:43.512]                             invokeRestart(restart)
[17:36:43.512]                             muffled <- TRUE
[17:36:43.512]                             break
[17:36:43.512]                           }
[17:36:43.512]                         }
[17:36:43.512]                       }
[17:36:43.512]                       invisible(muffled)
[17:36:43.512]                     }
[17:36:43.512]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.512]                   }
[17:36:43.512]                 }
[17:36:43.512]                 else {
[17:36:43.512]                   if (TRUE) {
[17:36:43.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.512]                     {
[17:36:43.512]                       inherits <- base::inherits
[17:36:43.512]                       invokeRestart <- base::invokeRestart
[17:36:43.512]                       is.null <- base::is.null
[17:36:43.512]                       muffled <- FALSE
[17:36:43.512]                       if (inherits(cond, "message")) {
[17:36:43.512]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.512]                         if (muffled) 
[17:36:43.512]                           invokeRestart("muffleMessage")
[17:36:43.512]                       }
[17:36:43.512]                       else if (inherits(cond, "warning")) {
[17:36:43.512]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.512]                         if (muffled) 
[17:36:43.512]                           invokeRestart("muffleWarning")
[17:36:43.512]                       }
[17:36:43.512]                       else if (inherits(cond, "condition")) {
[17:36:43.512]                         if (!is.null(pattern)) {
[17:36:43.512]                           computeRestarts <- base::computeRestarts
[17:36:43.512]                           grepl <- base::grepl
[17:36:43.512]                           restarts <- computeRestarts(cond)
[17:36:43.512]                           for (restart in restarts) {
[17:36:43.512]                             name <- restart$name
[17:36:43.512]                             if (is.null(name)) 
[17:36:43.512]                               next
[17:36:43.512]                             if (!grepl(pattern, name)) 
[17:36:43.512]                               next
[17:36:43.512]                             invokeRestart(restart)
[17:36:43.512]                             muffled <- TRUE
[17:36:43.512]                             break
[17:36:43.512]                           }
[17:36:43.512]                         }
[17:36:43.512]                       }
[17:36:43.512]                       invisible(muffled)
[17:36:43.512]                     }
[17:36:43.512]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.512]                   }
[17:36:43.512]                 }
[17:36:43.512]             }
[17:36:43.512]         }))
[17:36:43.512]     }, error = function(ex) {
[17:36:43.512]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.512]                 ...future.rng), started = ...future.startTime, 
[17:36:43.512]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.512]             version = "1.8"), class = "FutureResult")
[17:36:43.512]     }, finally = {
[17:36:43.512]         if (!identical(...future.workdir, getwd())) 
[17:36:43.512]             setwd(...future.workdir)
[17:36:43.512]         {
[17:36:43.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.512]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.512]             }
[17:36:43.512]             base::options(...future.oldOptions)
[17:36:43.512]             if (.Platform$OS.type == "windows") {
[17:36:43.512]                 old_names <- names(...future.oldEnvVars)
[17:36:43.512]                 envs <- base::Sys.getenv()
[17:36:43.512]                 names <- names(envs)
[17:36:43.512]                 common <- intersect(names, old_names)
[17:36:43.512]                 added <- setdiff(names, old_names)
[17:36:43.512]                 removed <- setdiff(old_names, names)
[17:36:43.512]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.512]                   envs[common]]
[17:36:43.512]                 NAMES <- toupper(changed)
[17:36:43.512]                 args <- list()
[17:36:43.512]                 for (kk in seq_along(NAMES)) {
[17:36:43.512]                   name <- changed[[kk]]
[17:36:43.512]                   NAME <- NAMES[[kk]]
[17:36:43.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.512]                     next
[17:36:43.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.512]                 }
[17:36:43.512]                 NAMES <- toupper(added)
[17:36:43.512]                 for (kk in seq_along(NAMES)) {
[17:36:43.512]                   name <- added[[kk]]
[17:36:43.512]                   NAME <- NAMES[[kk]]
[17:36:43.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.512]                     next
[17:36:43.512]                   args[[name]] <- ""
[17:36:43.512]                 }
[17:36:43.512]                 NAMES <- toupper(removed)
[17:36:43.512]                 for (kk in seq_along(NAMES)) {
[17:36:43.512]                   name <- removed[[kk]]
[17:36:43.512]                   NAME <- NAMES[[kk]]
[17:36:43.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.512]                     next
[17:36:43.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.512]                 }
[17:36:43.512]                 if (length(args) > 0) 
[17:36:43.512]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.512]             }
[17:36:43.512]             else {
[17:36:43.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.512]             }
[17:36:43.512]             {
[17:36:43.512]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.512]                   0L) {
[17:36:43.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.512]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.512]                   base::options(opts)
[17:36:43.512]                 }
[17:36:43.512]                 {
[17:36:43.512]                   {
[17:36:43.512]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:43.512]                     NULL
[17:36:43.512]                   }
[17:36:43.512]                   options(future.plan = NULL)
[17:36:43.512]                   if (is.na(NA_character_)) 
[17:36:43.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.512]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.512]                     .init = FALSE)
[17:36:43.512]                 }
[17:36:43.512]             }
[17:36:43.512]         }
[17:36:43.512]     })
[17:36:43.512]     if (TRUE) {
[17:36:43.512]         base::sink(type = "output", split = FALSE)
[17:36:43.512]         if (TRUE) {
[17:36:43.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.512]         }
[17:36:43.512]         else {
[17:36:43.512]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.512]         }
[17:36:43.512]         base::close(...future.stdout)
[17:36:43.512]         ...future.stdout <- NULL
[17:36:43.512]     }
[17:36:43.512]     ...future.result$conditions <- ...future.conditions
[17:36:43.512]     ...future.result$finished <- base::Sys.time()
[17:36:43.512]     ...future.result
[17:36:43.512] }
[17:36:43.515] assign_globals() ...
[17:36:43.515] List of 5
[17:36:43.515]  $ ...future.FUN            :function (x, ...)  
[17:36:43.515]  $ future.call.arguments    :List of 1
[17:36:43.515]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:36:43.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.515]  $ ...future.elements_ii    :List of 2
[17:36:43.515]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:36:43.515]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:36:43.515]  $ ...future.seeds_ii       : NULL
[17:36:43.515]  $ ...future.globals.maxSize: NULL
[17:36:43.515]  - attr(*, "where")=List of 5
[17:36:43.515]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.515]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.515]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.515]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.515]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.515]  - attr(*, "resolved")= logi FALSE
[17:36:43.515]  - attr(*, "total_size")= num 1328
[17:36:43.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.515]  - attr(*, "already-done")= logi TRUE
[17:36:43.527] - copied ‘...future.FUN’ to environment
[17:36:43.527] - copied ‘future.call.arguments’ to environment
[17:36:43.527] - copied ‘...future.elements_ii’ to environment
[17:36:43.528] - copied ‘...future.seeds_ii’ to environment
[17:36:43.528] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.528] assign_globals() ... done
[17:36:43.528] requestCore(): workers = 2
[17:36:43.530] MulticoreFuture started
[17:36:43.531] - Launch lazy future ... done
[17:36:43.531] run() for ‘MulticoreFuture’ ... done
[17:36:43.531] Created future:
[17:36:43.532] plan(): Setting new future strategy stack:
[17:36:43.532] List of future strategies:
[17:36:43.532] 1. sequential:
[17:36:43.532]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.532]    - tweaked: FALSE
[17:36:43.532]    - call: NULL
[17:36:43.533] plan(): nbrOfWorkers() = 1
[17:36:43.536] plan(): Setting new future strategy stack:
[17:36:43.536] List of future strategies:
[17:36:43.536] 1. multicore:
[17:36:43.536]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:43.536]    - tweaked: FALSE
[17:36:43.536]    - call: plan(strategy)
[17:36:43.541] plan(): nbrOfWorkers() = 2
[17:36:43.532] MulticoreFuture:
[17:36:43.532] Label: ‘future_eapply-2’
[17:36:43.532] Expression:
[17:36:43.532] {
[17:36:43.532]     do.call(function(...) {
[17:36:43.532]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.532]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.532]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.532]             on.exit(options(oopts), add = TRUE)
[17:36:43.532]         }
[17:36:43.532]         {
[17:36:43.532]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.532]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.532]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.532]             })
[17:36:43.532]         }
[17:36:43.532]     }, args = future.call.arguments)
[17:36:43.532] }
[17:36:43.532] Lazy evaluation: FALSE
[17:36:43.532] Asynchronous evaluation: TRUE
[17:36:43.532] Local evaluation: TRUE
[17:36:43.532] Environment: R_GlobalEnv
[17:36:43.532] Capture standard output: TRUE
[17:36:43.532] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.532] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.532] Packages: 1 packages (‘stats’)
[17:36:43.532] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.532] Resolved: TRUE
[17:36:43.532] Value: <not collected>
[17:36:43.532] Conditions captured: <none>
[17:36:43.532] Early signaling: FALSE
[17:36:43.532] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.532] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.542] Chunk #2 of 2 ... DONE
[17:36:43.543] Launching 2 futures (chunks) ... DONE
[17:36:43.543] Resolving 2 futures (chunks) ...
[17:36:43.543] resolve() on list ...
[17:36:43.543]  recursive: 0
[17:36:43.543]  length: 2
[17:36:43.543] 
[17:36:43.544] Future #1
[17:36:43.544] result() for MulticoreFuture ...
[17:36:43.545] result() for MulticoreFuture ...
[17:36:43.545] result() for MulticoreFuture ... done
[17:36:43.545] result() for MulticoreFuture ... done
[17:36:43.546] result() for MulticoreFuture ...
[17:36:43.546] result() for MulticoreFuture ... done
[17:36:43.546] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:43.546] - nx: 2
[17:36:43.546] - relay: TRUE
[17:36:43.547] - stdout: TRUE
[17:36:43.547] - signal: TRUE
[17:36:43.547] - resignal: FALSE
[17:36:43.547] - force: TRUE
[17:36:43.547] - relayed: [n=2] FALSE, FALSE
[17:36:43.547] - queued futures: [n=2] FALSE, FALSE
[17:36:43.548]  - until=1
[17:36:43.548]  - relaying element #1
[17:36:43.548] result() for MulticoreFuture ...
[17:36:43.548] result() for MulticoreFuture ... done
[17:36:43.548] result() for MulticoreFuture ...
[17:36:43.549] result() for MulticoreFuture ... done
[17:36:43.549] result() for MulticoreFuture ...
[17:36:43.549] result() for MulticoreFuture ... done
[17:36:43.549] result() for MulticoreFuture ...
[17:36:43.549] result() for MulticoreFuture ... done
[17:36:43.549] - relayed: [n=2] TRUE, FALSE
[17:36:43.550] - queued futures: [n=2] TRUE, FALSE
[17:36:43.550] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:43.550]  length: 1 (resolved future 1)
[17:36:43.550] Future #2
[17:36:43.550] result() for MulticoreFuture ...
[17:36:43.551] result() for MulticoreFuture ...
[17:36:43.551] result() for MulticoreFuture ... done
[17:36:43.552] result() for MulticoreFuture ... done
[17:36:43.552] result() for MulticoreFuture ...
[17:36:43.552] result() for MulticoreFuture ... done
[17:36:43.552] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:43.552] - nx: 2
[17:36:43.553] - relay: TRUE
[17:36:43.553] - stdout: TRUE
[17:36:43.553] - signal: TRUE
[17:36:43.553] - resignal: FALSE
[17:36:43.553] - force: TRUE
[17:36:43.553] - relayed: [n=2] TRUE, FALSE
[17:36:43.553] - queued futures: [n=2] TRUE, FALSE
[17:36:43.554]  - until=2
[17:36:43.554]  - relaying element #2
[17:36:43.554] result() for MulticoreFuture ...
[17:36:43.554] result() for MulticoreFuture ... done
[17:36:43.554] result() for MulticoreFuture ...
[17:36:43.554] result() for MulticoreFuture ... done
[17:36:43.555] result() for MulticoreFuture ...
[17:36:43.555] result() for MulticoreFuture ... done
[17:36:43.555] result() for MulticoreFuture ...
[17:36:43.555] result() for MulticoreFuture ... done
[17:36:43.555] - relayed: [n=2] TRUE, TRUE
[17:36:43.555] - queued futures: [n=2] TRUE, TRUE
[17:36:43.555] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:43.555]  length: 0 (resolved future 2)
[17:36:43.555] Relaying remaining futures
[17:36:43.555] signalConditionsASAP(NULL, pos=0) ...
[17:36:43.556] - nx: 2
[17:36:43.556] - relay: TRUE
[17:36:43.556] - stdout: TRUE
[17:36:43.556] - signal: TRUE
[17:36:43.556] - resignal: FALSE
[17:36:43.556] - force: TRUE
[17:36:43.556] - relayed: [n=2] TRUE, TRUE
[17:36:43.556] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:43.557] - relayed: [n=2] TRUE, TRUE
[17:36:43.557] - queued futures: [n=2] TRUE, TRUE
[17:36:43.557] signalConditionsASAP(NULL, pos=0) ... done
[17:36:43.557] resolve() on list ... DONE
[17:36:43.557] result() for MulticoreFuture ...
[17:36:43.557] result() for MulticoreFuture ... done
[17:36:43.557] result() for MulticoreFuture ...
[17:36:43.557] result() for MulticoreFuture ... done
[17:36:43.557] result() for MulticoreFuture ...
[17:36:43.557] result() for MulticoreFuture ... done
[17:36:43.558] result() for MulticoreFuture ...
[17:36:43.558] result() for MulticoreFuture ... done
[17:36:43.558]  - Number of value chunks collected: 2
[17:36:43.558] Resolving 2 futures (chunks) ... DONE
[17:36:43.558] Reducing values from 2 chunks ...
[17:36:43.558]  - Number of values collected after concatenation: 3
[17:36:43.558]  - Number of values expected: 3
[17:36:43.558] Reducing values from 2 chunks ... DONE
[17:36:43.558] future_lapply() ... DONE
[17:36:43.559] future_lapply() ...
[17:36:43.564] Number of chunks: 2
[17:36:43.564] getGlobalsAndPackagesXApply() ...
[17:36:43.564]  - future.globals: TRUE
[17:36:43.564] getGlobalsAndPackages() ...
[17:36:43.565] Searching for globals...
[17:36:43.566] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:43.566] Searching for globals ... DONE
[17:36:43.566] Resolving globals: FALSE
[17:36:43.566] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:43.567] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:43.567] - globals: [1] ‘FUN’
[17:36:43.567] - packages: [1] ‘stats’
[17:36:43.567] getGlobalsAndPackages() ... DONE
[17:36:43.567]  - globals found/used: [n=1] ‘FUN’
[17:36:43.568]  - needed namespaces: [n=1] ‘stats’
[17:36:43.568] Finding globals ... DONE
[17:36:43.568]  - use_args: TRUE
[17:36:43.570]  - Getting '...' globals ...
[17:36:43.570] resolve() on list ...
[17:36:43.570]  recursive: 0
[17:36:43.570]  length: 1
[17:36:43.571]  elements: ‘...’
[17:36:43.571]  length: 0 (resolved future 1)
[17:36:43.571] resolve() on list ... DONE
[17:36:43.571]    - '...' content: [n=0] 
[17:36:43.571] List of 1
[17:36:43.571]  $ ...: list()
[17:36:43.571]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.571]  - attr(*, "where")=List of 1
[17:36:43.571]   ..$ ...:<environment: 0x5655048d6ed8> 
[17:36:43.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.571]  - attr(*, "resolved")= logi TRUE
[17:36:43.571]  - attr(*, "total_size")= num NA
[17:36:43.575]  - Getting '...' globals ... DONE
[17:36:43.575] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:43.575] List of 2
[17:36:43.575]  $ ...future.FUN:function (x, ...)  
[17:36:43.575]  $ ...          : list()
[17:36:43.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.575]  - attr(*, "where")=List of 2
[17:36:43.575]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:43.575]   ..$ ...          :<environment: 0x5655048d6ed8> 
[17:36:43.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.575]  - attr(*, "resolved")= logi FALSE
[17:36:43.575]  - attr(*, "total_size")= num 1248
[17:36:43.578] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:43.578] getGlobalsAndPackagesXApply() ... DONE
[17:36:43.578] Number of futures (= number of chunks): 2
[17:36:43.578] Launching 2 futures (chunks) ...
[17:36:43.578] Chunk #1 of 2 ...
[17:36:43.579]  - Finding globals in 'X' for chunk #1 ...
[17:36:43.579] getGlobalsAndPackages() ...
[17:36:43.579] Searching for globals...
[17:36:43.579] 
[17:36:43.579] Searching for globals ... DONE
[17:36:43.579] - globals: [0] <none>
[17:36:43.579] getGlobalsAndPackages() ... DONE
[17:36:43.579]    + additional globals found: [n=0] 
[17:36:43.579]    + additional namespaces needed: [n=0] 
[17:36:43.580]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:43.580]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:43.580]  - seeds: <none>
[17:36:43.580]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.580] getGlobalsAndPackages() ...
[17:36:43.580] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.580] Resolving globals: FALSE
[17:36:43.580] Tweak future expression to call with '...' arguments ...
[17:36:43.580] {
[17:36:43.580]     do.call(function(...) {
[17:36:43.580]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.580]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.580]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.580]             on.exit(options(oopts), add = TRUE)
[17:36:43.580]         }
[17:36:43.580]         {
[17:36:43.580]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.580]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.580]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.580]             })
[17:36:43.580]         }
[17:36:43.580]     }, args = future.call.arguments)
[17:36:43.580] }
[17:36:43.581] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.581] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.581] - packages: [1] ‘stats’
[17:36:43.581] getGlobalsAndPackages() ... DONE
[17:36:43.582] run() for ‘Future’ ...
[17:36:43.582] - state: ‘created’
[17:36:43.582] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:43.585] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.586] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:43.586]   - Field: ‘label’
[17:36:43.586]   - Field: ‘local’
[17:36:43.586]   - Field: ‘owner’
[17:36:43.586]   - Field: ‘envir’
[17:36:43.586]   - Field: ‘workers’
[17:36:43.586]   - Field: ‘packages’
[17:36:43.586]   - Field: ‘gc’
[17:36:43.586]   - Field: ‘job’
[17:36:43.586]   - Field: ‘conditions’
[17:36:43.587]   - Field: ‘expr’
[17:36:43.587]   - Field: ‘uuid’
[17:36:43.587]   - Field: ‘seed’
[17:36:43.587]   - Field: ‘version’
[17:36:43.587]   - Field: ‘result’
[17:36:43.587]   - Field: ‘asynchronous’
[17:36:43.587]   - Field: ‘calls’
[17:36:43.587]   - Field: ‘globals’
[17:36:43.587]   - Field: ‘stdout’
[17:36:43.587]   - Field: ‘earlySignal’
[17:36:43.587]   - Field: ‘lazy’
[17:36:43.588]   - Field: ‘state’
[17:36:43.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:43.588] - Launch lazy future ...
[17:36:43.588] Packages needed by the future expression (n = 1): ‘stats’
[17:36:43.588] Packages needed by future strategies (n = 0): <none>
[17:36:43.589] {
[17:36:43.589]     {
[17:36:43.589]         {
[17:36:43.589]             ...future.startTime <- base::Sys.time()
[17:36:43.589]             {
[17:36:43.589]                 {
[17:36:43.589]                   {
[17:36:43.589]                     {
[17:36:43.589]                       {
[17:36:43.589]                         base::local({
[17:36:43.589]                           has_future <- base::requireNamespace("future", 
[17:36:43.589]                             quietly = TRUE)
[17:36:43.589]                           if (has_future) {
[17:36:43.589]                             ns <- base::getNamespace("future")
[17:36:43.589]                             version <- ns[[".package"]][["version"]]
[17:36:43.589]                             if (is.null(version)) 
[17:36:43.589]                               version <- utils::packageVersion("future")
[17:36:43.589]                           }
[17:36:43.589]                           else {
[17:36:43.589]                             version <- NULL
[17:36:43.589]                           }
[17:36:43.589]                           if (!has_future || version < "1.8.0") {
[17:36:43.589]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.589]                               "", base::R.version$version.string), 
[17:36:43.589]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:43.589]                                 base::R.version$platform, 8 * 
[17:36:43.589]                                   base::.Machine$sizeof.pointer), 
[17:36:43.589]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.589]                                 "release", "version")], collapse = " "), 
[17:36:43.589]                               hostname = base::Sys.info()[["nodename"]])
[17:36:43.589]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.589]                               info)
[17:36:43.589]                             info <- base::paste(info, collapse = "; ")
[17:36:43.589]                             if (!has_future) {
[17:36:43.589]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.589]                                 info)
[17:36:43.589]                             }
[17:36:43.589]                             else {
[17:36:43.589]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.589]                                 info, version)
[17:36:43.589]                             }
[17:36:43.589]                             base::stop(msg)
[17:36:43.589]                           }
[17:36:43.589]                         })
[17:36:43.589]                       }
[17:36:43.589]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:43.589]                       base::options(mc.cores = 1L)
[17:36:43.589]                     }
[17:36:43.589]                     base::local({
[17:36:43.589]                       for (pkg in "stats") {
[17:36:43.589]                         base::loadNamespace(pkg)
[17:36:43.589]                         base::library(pkg, character.only = TRUE)
[17:36:43.589]                       }
[17:36:43.589]                     })
[17:36:43.589]                   }
[17:36:43.589]                   ...future.strategy.old <- future::plan("list")
[17:36:43.589]                   options(future.plan = NULL)
[17:36:43.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.589]                 }
[17:36:43.589]                 ...future.workdir <- getwd()
[17:36:43.589]             }
[17:36:43.589]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.589]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.589]         }
[17:36:43.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.589]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:43.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.589]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.589]             base::names(...future.oldOptions))
[17:36:43.589]     }
[17:36:43.589]     if (FALSE) {
[17:36:43.589]     }
[17:36:43.589]     else {
[17:36:43.589]         if (TRUE) {
[17:36:43.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.589]                 open = "w")
[17:36:43.589]         }
[17:36:43.589]         else {
[17:36:43.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.589]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.589]         }
[17:36:43.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.589]             base::sink(type = "output", split = FALSE)
[17:36:43.589]             base::close(...future.stdout)
[17:36:43.589]         }, add = TRUE)
[17:36:43.589]     }
[17:36:43.589]     ...future.frame <- base::sys.nframe()
[17:36:43.589]     ...future.conditions <- base::list()
[17:36:43.589]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.589]     if (FALSE) {
[17:36:43.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.589]     }
[17:36:43.589]     ...future.result <- base::tryCatch({
[17:36:43.589]         base::withCallingHandlers({
[17:36:43.589]             ...future.value <- base::withVisible(base::local({
[17:36:43.589]                 withCallingHandlers({
[17:36:43.589]                   {
[17:36:43.589]                     do.call(function(...) {
[17:36:43.589]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.589]                       if (!identical(...future.globals.maxSize.org, 
[17:36:43.589]                         ...future.globals.maxSize)) {
[17:36:43.589]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.589]                         on.exit(options(oopts), add = TRUE)
[17:36:43.589]                       }
[17:36:43.589]                       {
[17:36:43.589]                         lapply(seq_along(...future.elements_ii), 
[17:36:43.589]                           FUN = function(jj) {
[17:36:43.589]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.589]                             ...future.FUN(...future.X_jj, ...)
[17:36:43.589]                           })
[17:36:43.589]                       }
[17:36:43.589]                     }, args = future.call.arguments)
[17:36:43.589]                   }
[17:36:43.589]                 }, immediateCondition = function(cond) {
[17:36:43.589]                   save_rds <- function (object, pathname, ...) 
[17:36:43.589]                   {
[17:36:43.589]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:43.589]                     if (file_test("-f", pathname_tmp)) {
[17:36:43.589]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.589]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:43.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.589]                         fi_tmp[["mtime"]])
[17:36:43.589]                     }
[17:36:43.589]                     tryCatch({
[17:36:43.589]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:43.589]                     }, error = function(ex) {
[17:36:43.589]                       msg <- conditionMessage(ex)
[17:36:43.589]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.589]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:43.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.589]                         fi_tmp[["mtime"]], msg)
[17:36:43.589]                       ex$message <- msg
[17:36:43.589]                       stop(ex)
[17:36:43.589]                     })
[17:36:43.589]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:43.589]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:43.589]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:43.589]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.589]                       fi <- file.info(pathname)
[17:36:43.589]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:43.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.589]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:43.589]                         fi[["size"]], fi[["mtime"]])
[17:36:43.589]                       stop(msg)
[17:36:43.589]                     }
[17:36:43.589]                     invisible(pathname)
[17:36:43.589]                   }
[17:36:43.589]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:43.589]                     rootPath = tempdir()) 
[17:36:43.589]                   {
[17:36:43.589]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:43.589]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:43.589]                       tmpdir = path, fileext = ".rds")
[17:36:43.589]                     save_rds(obj, file)
[17:36:43.589]                   }
[17:36:43.589]                   saveImmediateCondition(cond, path = "/tmp/RtmpEOKIKx/.future/immediateConditions")
[17:36:43.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.589]                   {
[17:36:43.589]                     inherits <- base::inherits
[17:36:43.589]                     invokeRestart <- base::invokeRestart
[17:36:43.589]                     is.null <- base::is.null
[17:36:43.589]                     muffled <- FALSE
[17:36:43.589]                     if (inherits(cond, "message")) {
[17:36:43.589]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:43.589]                       if (muffled) 
[17:36:43.589]                         invokeRestart("muffleMessage")
[17:36:43.589]                     }
[17:36:43.589]                     else if (inherits(cond, "warning")) {
[17:36:43.589]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:43.589]                       if (muffled) 
[17:36:43.589]                         invokeRestart("muffleWarning")
[17:36:43.589]                     }
[17:36:43.589]                     else if (inherits(cond, "condition")) {
[17:36:43.589]                       if (!is.null(pattern)) {
[17:36:43.589]                         computeRestarts <- base::computeRestarts
[17:36:43.589]                         grepl <- base::grepl
[17:36:43.589]                         restarts <- computeRestarts(cond)
[17:36:43.589]                         for (restart in restarts) {
[17:36:43.589]                           name <- restart$name
[17:36:43.589]                           if (is.null(name)) 
[17:36:43.589]                             next
[17:36:43.589]                           if (!grepl(pattern, name)) 
[17:36:43.589]                             next
[17:36:43.589]                           invokeRestart(restart)
[17:36:43.589]                           muffled <- TRUE
[17:36:43.589]                           break
[17:36:43.589]                         }
[17:36:43.589]                       }
[17:36:43.589]                     }
[17:36:43.589]                     invisible(muffled)
[17:36:43.589]                   }
[17:36:43.589]                   muffleCondition(cond)
[17:36:43.589]                 })
[17:36:43.589]             }))
[17:36:43.589]             future::FutureResult(value = ...future.value$value, 
[17:36:43.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.589]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.589]                     ...future.globalenv.names))
[17:36:43.589]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.589]         }, condition = base::local({
[17:36:43.589]             c <- base::c
[17:36:43.589]             inherits <- base::inherits
[17:36:43.589]             invokeRestart <- base::invokeRestart
[17:36:43.589]             length <- base::length
[17:36:43.589]             list <- base::list
[17:36:43.589]             seq.int <- base::seq.int
[17:36:43.589]             signalCondition <- base::signalCondition
[17:36:43.589]             sys.calls <- base::sys.calls
[17:36:43.589]             `[[` <- base::`[[`
[17:36:43.589]             `+` <- base::`+`
[17:36:43.589]             `<<-` <- base::`<<-`
[17:36:43.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.589]                   3L)]
[17:36:43.589]             }
[17:36:43.589]             function(cond) {
[17:36:43.589]                 is_error <- inherits(cond, "error")
[17:36:43.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.589]                   NULL)
[17:36:43.589]                 if (is_error) {
[17:36:43.589]                   sessionInformation <- function() {
[17:36:43.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.589]                       search = base::search(), system = base::Sys.info())
[17:36:43.589]                   }
[17:36:43.589]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.589]                     cond$call), session = sessionInformation(), 
[17:36:43.589]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.589]                   signalCondition(cond)
[17:36:43.589]                 }
[17:36:43.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.589]                 "immediateCondition"))) {
[17:36:43.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.589]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.589]                   if (TRUE && !signal) {
[17:36:43.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.589]                     {
[17:36:43.589]                       inherits <- base::inherits
[17:36:43.589]                       invokeRestart <- base::invokeRestart
[17:36:43.589]                       is.null <- base::is.null
[17:36:43.589]                       muffled <- FALSE
[17:36:43.589]                       if (inherits(cond, "message")) {
[17:36:43.589]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.589]                         if (muffled) 
[17:36:43.589]                           invokeRestart("muffleMessage")
[17:36:43.589]                       }
[17:36:43.589]                       else if (inherits(cond, "warning")) {
[17:36:43.589]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.589]                         if (muffled) 
[17:36:43.589]                           invokeRestart("muffleWarning")
[17:36:43.589]                       }
[17:36:43.589]                       else if (inherits(cond, "condition")) {
[17:36:43.589]                         if (!is.null(pattern)) {
[17:36:43.589]                           computeRestarts <- base::computeRestarts
[17:36:43.589]                           grepl <- base::grepl
[17:36:43.589]                           restarts <- computeRestarts(cond)
[17:36:43.589]                           for (restart in restarts) {
[17:36:43.589]                             name <- restart$name
[17:36:43.589]                             if (is.null(name)) 
[17:36:43.589]                               next
[17:36:43.589]                             if (!grepl(pattern, name)) 
[17:36:43.589]                               next
[17:36:43.589]                             invokeRestart(restart)
[17:36:43.589]                             muffled <- TRUE
[17:36:43.589]                             break
[17:36:43.589]                           }
[17:36:43.589]                         }
[17:36:43.589]                       }
[17:36:43.589]                       invisible(muffled)
[17:36:43.589]                     }
[17:36:43.589]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.589]                   }
[17:36:43.589]                 }
[17:36:43.589]                 else {
[17:36:43.589]                   if (TRUE) {
[17:36:43.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.589]                     {
[17:36:43.589]                       inherits <- base::inherits
[17:36:43.589]                       invokeRestart <- base::invokeRestart
[17:36:43.589]                       is.null <- base::is.null
[17:36:43.589]                       muffled <- FALSE
[17:36:43.589]                       if (inherits(cond, "message")) {
[17:36:43.589]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.589]                         if (muffled) 
[17:36:43.589]                           invokeRestart("muffleMessage")
[17:36:43.589]                       }
[17:36:43.589]                       else if (inherits(cond, "warning")) {
[17:36:43.589]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.589]                         if (muffled) 
[17:36:43.589]                           invokeRestart("muffleWarning")
[17:36:43.589]                       }
[17:36:43.589]                       else if (inherits(cond, "condition")) {
[17:36:43.589]                         if (!is.null(pattern)) {
[17:36:43.589]                           computeRestarts <- base::computeRestarts
[17:36:43.589]                           grepl <- base::grepl
[17:36:43.589]                           restarts <- computeRestarts(cond)
[17:36:43.589]                           for (restart in restarts) {
[17:36:43.589]                             name <- restart$name
[17:36:43.589]                             if (is.null(name)) 
[17:36:43.589]                               next
[17:36:43.589]                             if (!grepl(pattern, name)) 
[17:36:43.589]                               next
[17:36:43.589]                             invokeRestart(restart)
[17:36:43.589]                             muffled <- TRUE
[17:36:43.589]                             break
[17:36:43.589]                           }
[17:36:43.589]                         }
[17:36:43.589]                       }
[17:36:43.589]                       invisible(muffled)
[17:36:43.589]                     }
[17:36:43.589]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.589]                   }
[17:36:43.589]                 }
[17:36:43.589]             }
[17:36:43.589]         }))
[17:36:43.589]     }, error = function(ex) {
[17:36:43.589]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.589]                 ...future.rng), started = ...future.startTime, 
[17:36:43.589]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.589]             version = "1.8"), class = "FutureResult")
[17:36:43.589]     }, finally = {
[17:36:43.589]         if (!identical(...future.workdir, getwd())) 
[17:36:43.589]             setwd(...future.workdir)
[17:36:43.589]         {
[17:36:43.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.589]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.589]             }
[17:36:43.589]             base::options(...future.oldOptions)
[17:36:43.589]             if (.Platform$OS.type == "windows") {
[17:36:43.589]                 old_names <- names(...future.oldEnvVars)
[17:36:43.589]                 envs <- base::Sys.getenv()
[17:36:43.589]                 names <- names(envs)
[17:36:43.589]                 common <- intersect(names, old_names)
[17:36:43.589]                 added <- setdiff(names, old_names)
[17:36:43.589]                 removed <- setdiff(old_names, names)
[17:36:43.589]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.589]                   envs[common]]
[17:36:43.589]                 NAMES <- toupper(changed)
[17:36:43.589]                 args <- list()
[17:36:43.589]                 for (kk in seq_along(NAMES)) {
[17:36:43.589]                   name <- changed[[kk]]
[17:36:43.589]                   NAME <- NAMES[[kk]]
[17:36:43.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.589]                     next
[17:36:43.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.589]                 }
[17:36:43.589]                 NAMES <- toupper(added)
[17:36:43.589]                 for (kk in seq_along(NAMES)) {
[17:36:43.589]                   name <- added[[kk]]
[17:36:43.589]                   NAME <- NAMES[[kk]]
[17:36:43.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.589]                     next
[17:36:43.589]                   args[[name]] <- ""
[17:36:43.589]                 }
[17:36:43.589]                 NAMES <- toupper(removed)
[17:36:43.589]                 for (kk in seq_along(NAMES)) {
[17:36:43.589]                   name <- removed[[kk]]
[17:36:43.589]                   NAME <- NAMES[[kk]]
[17:36:43.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.589]                     next
[17:36:43.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.589]                 }
[17:36:43.589]                 if (length(args) > 0) 
[17:36:43.589]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.589]             }
[17:36:43.589]             else {
[17:36:43.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.589]             }
[17:36:43.589]             {
[17:36:43.589]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.589]                   0L) {
[17:36:43.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.589]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.589]                   base::options(opts)
[17:36:43.589]                 }
[17:36:43.589]                 {
[17:36:43.589]                   {
[17:36:43.589]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:43.589]                     NULL
[17:36:43.589]                   }
[17:36:43.589]                   options(future.plan = NULL)
[17:36:43.589]                   if (is.na(NA_character_)) 
[17:36:43.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.589]                     .init = FALSE)
[17:36:43.589]                 }
[17:36:43.589]             }
[17:36:43.589]         }
[17:36:43.589]     })
[17:36:43.589]     if (TRUE) {
[17:36:43.589]         base::sink(type = "output", split = FALSE)
[17:36:43.589]         if (TRUE) {
[17:36:43.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.589]         }
[17:36:43.589]         else {
[17:36:43.589]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.589]         }
[17:36:43.589]         base::close(...future.stdout)
[17:36:43.589]         ...future.stdout <- NULL
[17:36:43.589]     }
[17:36:43.589]     ...future.result$conditions <- ...future.conditions
[17:36:43.589]     ...future.result$finished <- base::Sys.time()
[17:36:43.589]     ...future.result
[17:36:43.589] }
[17:36:43.591] assign_globals() ...
[17:36:43.591] List of 5
[17:36:43.591]  $ ...future.FUN            :function (x, ...)  
[17:36:43.591]  $ future.call.arguments    : list()
[17:36:43.591]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.591]  $ ...future.elements_ii    :List of 1
[17:36:43.591]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:36:43.591]  $ ...future.seeds_ii       : NULL
[17:36:43.591]  $ ...future.globals.maxSize: NULL
[17:36:43.591]  - attr(*, "where")=List of 5
[17:36:43.591]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.591]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.591]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.591]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.591]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.591]  - attr(*, "resolved")= logi FALSE
[17:36:43.591]  - attr(*, "total_size")= num 1248
[17:36:43.591]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.591]  - attr(*, "already-done")= logi TRUE
[17:36:43.596] - copied ‘...future.FUN’ to environment
[17:36:43.596] - copied ‘future.call.arguments’ to environment
[17:36:43.596] - copied ‘...future.elements_ii’ to environment
[17:36:43.596] - copied ‘...future.seeds_ii’ to environment
[17:36:43.596] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.596] assign_globals() ... done
[17:36:43.596] requestCore(): workers = 2
[17:36:43.598] MulticoreFuture started
[17:36:43.599] - Launch lazy future ... done
[17:36:43.599] run() for ‘MulticoreFuture’ ... done
[17:36:43.599] Created future:
[17:36:43.603] plan(): Setting new future strategy stack:
[17:36:43.603] List of future strategies:
[17:36:43.603] 1. sequential:
[17:36:43.603]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.603]    - tweaked: FALSE
[17:36:43.603]    - call: NULL
[17:36:43.604] plan(): nbrOfWorkers() = 1
[17:36:43.607] plan(): Setting new future strategy stack:
[17:36:43.607] List of future strategies:
[17:36:43.607] 1. multicore:
[17:36:43.607]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:43.607]    - tweaked: FALSE
[17:36:43.607]    - call: plan(strategy)
[17:36:43.612] plan(): nbrOfWorkers() = 2
[17:36:43.603] MulticoreFuture:
[17:36:43.603] Label: ‘future_eapply-1’
[17:36:43.603] Expression:
[17:36:43.603] {
[17:36:43.603]     do.call(function(...) {
[17:36:43.603]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.603]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.603]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.603]             on.exit(options(oopts), add = TRUE)
[17:36:43.603]         }
[17:36:43.603]         {
[17:36:43.603]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.603]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.603]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.603]             })
[17:36:43.603]         }
[17:36:43.603]     }, args = future.call.arguments)
[17:36:43.603] }
[17:36:43.603] Lazy evaluation: FALSE
[17:36:43.603] Asynchronous evaluation: TRUE
[17:36:43.603] Local evaluation: TRUE
[17:36:43.603] Environment: R_GlobalEnv
[17:36:43.603] Capture standard output: TRUE
[17:36:43.603] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.603] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.603] Packages: 1 packages (‘stats’)
[17:36:43.603] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.603] Resolved: TRUE
[17:36:43.603] Value: <not collected>
[17:36:43.603] Conditions captured: <none>
[17:36:43.603] Early signaling: FALSE
[17:36:43.603] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.603] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.613] Chunk #1 of 2 ... DONE
[17:36:43.614] Chunk #2 of 2 ...
[17:36:43.614]  - Finding globals in 'X' for chunk #2 ...
[17:36:43.614] getGlobalsAndPackages() ...
[17:36:43.614] Searching for globals...
[17:36:43.615] 
[17:36:43.615] Searching for globals ... DONE
[17:36:43.615] - globals: [0] <none>
[17:36:43.615] getGlobalsAndPackages() ... DONE
[17:36:43.615]    + additional globals found: [n=0] 
[17:36:43.615]    + additional namespaces needed: [n=0] 
[17:36:43.616]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:43.616]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:43.616]  - seeds: <none>
[17:36:43.616]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.616] getGlobalsAndPackages() ...
[17:36:43.616] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.616] Resolving globals: FALSE
[17:36:43.617] Tweak future expression to call with '...' arguments ...
[17:36:43.617] {
[17:36:43.617]     do.call(function(...) {
[17:36:43.617]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.617]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.617]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.617]             on.exit(options(oopts), add = TRUE)
[17:36:43.617]         }
[17:36:43.617]         {
[17:36:43.617]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.617]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.617]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.617]             })
[17:36:43.617]         }
[17:36:43.617]     }, args = future.call.arguments)
[17:36:43.617] }
[17:36:43.617] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.618] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.618] - packages: [1] ‘stats’
[17:36:43.618] getGlobalsAndPackages() ... DONE
[17:36:43.619] run() for ‘Future’ ...
[17:36:43.619] - state: ‘created’
[17:36:43.619] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:43.624] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.624] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:43.625]   - Field: ‘label’
[17:36:43.625]   - Field: ‘local’
[17:36:43.625]   - Field: ‘owner’
[17:36:43.625]   - Field: ‘envir’
[17:36:43.625]   - Field: ‘workers’
[17:36:43.625]   - Field: ‘packages’
[17:36:43.625]   - Field: ‘gc’
[17:36:43.626]   - Field: ‘job’
[17:36:43.626]   - Field: ‘conditions’
[17:36:43.626]   - Field: ‘expr’
[17:36:43.626]   - Field: ‘uuid’
[17:36:43.626]   - Field: ‘seed’
[17:36:43.626]   - Field: ‘version’
[17:36:43.626]   - Field: ‘result’
[17:36:43.627]   - Field: ‘asynchronous’
[17:36:43.627]   - Field: ‘calls’
[17:36:43.627]   - Field: ‘globals’
[17:36:43.627]   - Field: ‘stdout’
[17:36:43.627]   - Field: ‘earlySignal’
[17:36:43.627]   - Field: ‘lazy’
[17:36:43.627]   - Field: ‘state’
[17:36:43.627] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:43.628] - Launch lazy future ...
[17:36:43.628] Packages needed by the future expression (n = 1): ‘stats’
[17:36:43.628] Packages needed by future strategies (n = 0): <none>
[17:36:43.629] {
[17:36:43.629]     {
[17:36:43.629]         {
[17:36:43.629]             ...future.startTime <- base::Sys.time()
[17:36:43.629]             {
[17:36:43.629]                 {
[17:36:43.629]                   {
[17:36:43.629]                     {
[17:36:43.629]                       {
[17:36:43.629]                         base::local({
[17:36:43.629]                           has_future <- base::requireNamespace("future", 
[17:36:43.629]                             quietly = TRUE)
[17:36:43.629]                           if (has_future) {
[17:36:43.629]                             ns <- base::getNamespace("future")
[17:36:43.629]                             version <- ns[[".package"]][["version"]]
[17:36:43.629]                             if (is.null(version)) 
[17:36:43.629]                               version <- utils::packageVersion("future")
[17:36:43.629]                           }
[17:36:43.629]                           else {
[17:36:43.629]                             version <- NULL
[17:36:43.629]                           }
[17:36:43.629]                           if (!has_future || version < "1.8.0") {
[17:36:43.629]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.629]                               "", base::R.version$version.string), 
[17:36:43.629]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:43.629]                                 base::R.version$platform, 8 * 
[17:36:43.629]                                   base::.Machine$sizeof.pointer), 
[17:36:43.629]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.629]                                 "release", "version")], collapse = " "), 
[17:36:43.629]                               hostname = base::Sys.info()[["nodename"]])
[17:36:43.629]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.629]                               info)
[17:36:43.629]                             info <- base::paste(info, collapse = "; ")
[17:36:43.629]                             if (!has_future) {
[17:36:43.629]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.629]                                 info)
[17:36:43.629]                             }
[17:36:43.629]                             else {
[17:36:43.629]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.629]                                 info, version)
[17:36:43.629]                             }
[17:36:43.629]                             base::stop(msg)
[17:36:43.629]                           }
[17:36:43.629]                         })
[17:36:43.629]                       }
[17:36:43.629]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:43.629]                       base::options(mc.cores = 1L)
[17:36:43.629]                     }
[17:36:43.629]                     base::local({
[17:36:43.629]                       for (pkg in "stats") {
[17:36:43.629]                         base::loadNamespace(pkg)
[17:36:43.629]                         base::library(pkg, character.only = TRUE)
[17:36:43.629]                       }
[17:36:43.629]                     })
[17:36:43.629]                   }
[17:36:43.629]                   ...future.strategy.old <- future::plan("list")
[17:36:43.629]                   options(future.plan = NULL)
[17:36:43.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.629]                 }
[17:36:43.629]                 ...future.workdir <- getwd()
[17:36:43.629]             }
[17:36:43.629]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.629]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.629]         }
[17:36:43.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.629]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:43.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.629]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.629]             base::names(...future.oldOptions))
[17:36:43.629]     }
[17:36:43.629]     if (FALSE) {
[17:36:43.629]     }
[17:36:43.629]     else {
[17:36:43.629]         if (TRUE) {
[17:36:43.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.629]                 open = "w")
[17:36:43.629]         }
[17:36:43.629]         else {
[17:36:43.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.629]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.629]         }
[17:36:43.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.629]             base::sink(type = "output", split = FALSE)
[17:36:43.629]             base::close(...future.stdout)
[17:36:43.629]         }, add = TRUE)
[17:36:43.629]     }
[17:36:43.629]     ...future.frame <- base::sys.nframe()
[17:36:43.629]     ...future.conditions <- base::list()
[17:36:43.629]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.629]     if (FALSE) {
[17:36:43.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.629]     }
[17:36:43.629]     ...future.result <- base::tryCatch({
[17:36:43.629]         base::withCallingHandlers({
[17:36:43.629]             ...future.value <- base::withVisible(base::local({
[17:36:43.629]                 withCallingHandlers({
[17:36:43.629]                   {
[17:36:43.629]                     do.call(function(...) {
[17:36:43.629]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.629]                       if (!identical(...future.globals.maxSize.org, 
[17:36:43.629]                         ...future.globals.maxSize)) {
[17:36:43.629]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.629]                         on.exit(options(oopts), add = TRUE)
[17:36:43.629]                       }
[17:36:43.629]                       {
[17:36:43.629]                         lapply(seq_along(...future.elements_ii), 
[17:36:43.629]                           FUN = function(jj) {
[17:36:43.629]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.629]                             ...future.FUN(...future.X_jj, ...)
[17:36:43.629]                           })
[17:36:43.629]                       }
[17:36:43.629]                     }, args = future.call.arguments)
[17:36:43.629]                   }
[17:36:43.629]                 }, immediateCondition = function(cond) {
[17:36:43.629]                   save_rds <- function (object, pathname, ...) 
[17:36:43.629]                   {
[17:36:43.629]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:43.629]                     if (file_test("-f", pathname_tmp)) {
[17:36:43.629]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.629]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:43.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.629]                         fi_tmp[["mtime"]])
[17:36:43.629]                     }
[17:36:43.629]                     tryCatch({
[17:36:43.629]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:43.629]                     }, error = function(ex) {
[17:36:43.629]                       msg <- conditionMessage(ex)
[17:36:43.629]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.629]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:43.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.629]                         fi_tmp[["mtime"]], msg)
[17:36:43.629]                       ex$message <- msg
[17:36:43.629]                       stop(ex)
[17:36:43.629]                     })
[17:36:43.629]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:43.629]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:43.629]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:43.629]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.629]                       fi <- file.info(pathname)
[17:36:43.629]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:43.629]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.629]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:43.629]                         fi[["size"]], fi[["mtime"]])
[17:36:43.629]                       stop(msg)
[17:36:43.629]                     }
[17:36:43.629]                     invisible(pathname)
[17:36:43.629]                   }
[17:36:43.629]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:43.629]                     rootPath = tempdir()) 
[17:36:43.629]                   {
[17:36:43.629]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:43.629]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:43.629]                       tmpdir = path, fileext = ".rds")
[17:36:43.629]                     save_rds(obj, file)
[17:36:43.629]                   }
[17:36:43.629]                   saveImmediateCondition(cond, path = "/tmp/RtmpEOKIKx/.future/immediateConditions")
[17:36:43.629]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.629]                   {
[17:36:43.629]                     inherits <- base::inherits
[17:36:43.629]                     invokeRestart <- base::invokeRestart
[17:36:43.629]                     is.null <- base::is.null
[17:36:43.629]                     muffled <- FALSE
[17:36:43.629]                     if (inherits(cond, "message")) {
[17:36:43.629]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:43.629]                       if (muffled) 
[17:36:43.629]                         invokeRestart("muffleMessage")
[17:36:43.629]                     }
[17:36:43.629]                     else if (inherits(cond, "warning")) {
[17:36:43.629]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:43.629]                       if (muffled) 
[17:36:43.629]                         invokeRestart("muffleWarning")
[17:36:43.629]                     }
[17:36:43.629]                     else if (inherits(cond, "condition")) {
[17:36:43.629]                       if (!is.null(pattern)) {
[17:36:43.629]                         computeRestarts <- base::computeRestarts
[17:36:43.629]                         grepl <- base::grepl
[17:36:43.629]                         restarts <- computeRestarts(cond)
[17:36:43.629]                         for (restart in restarts) {
[17:36:43.629]                           name <- restart$name
[17:36:43.629]                           if (is.null(name)) 
[17:36:43.629]                             next
[17:36:43.629]                           if (!grepl(pattern, name)) 
[17:36:43.629]                             next
[17:36:43.629]                           invokeRestart(restart)
[17:36:43.629]                           muffled <- TRUE
[17:36:43.629]                           break
[17:36:43.629]                         }
[17:36:43.629]                       }
[17:36:43.629]                     }
[17:36:43.629]                     invisible(muffled)
[17:36:43.629]                   }
[17:36:43.629]                   muffleCondition(cond)
[17:36:43.629]                 })
[17:36:43.629]             }))
[17:36:43.629]             future::FutureResult(value = ...future.value$value, 
[17:36:43.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.629]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.629]                     ...future.globalenv.names))
[17:36:43.629]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.629]         }, condition = base::local({
[17:36:43.629]             c <- base::c
[17:36:43.629]             inherits <- base::inherits
[17:36:43.629]             invokeRestart <- base::invokeRestart
[17:36:43.629]             length <- base::length
[17:36:43.629]             list <- base::list
[17:36:43.629]             seq.int <- base::seq.int
[17:36:43.629]             signalCondition <- base::signalCondition
[17:36:43.629]             sys.calls <- base::sys.calls
[17:36:43.629]             `[[` <- base::`[[`
[17:36:43.629]             `+` <- base::`+`
[17:36:43.629]             `<<-` <- base::`<<-`
[17:36:43.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.629]                   3L)]
[17:36:43.629]             }
[17:36:43.629]             function(cond) {
[17:36:43.629]                 is_error <- inherits(cond, "error")
[17:36:43.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.629]                   NULL)
[17:36:43.629]                 if (is_error) {
[17:36:43.629]                   sessionInformation <- function() {
[17:36:43.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.629]                       search = base::search(), system = base::Sys.info())
[17:36:43.629]                   }
[17:36:43.629]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.629]                     cond$call), session = sessionInformation(), 
[17:36:43.629]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.629]                   signalCondition(cond)
[17:36:43.629]                 }
[17:36:43.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.629]                 "immediateCondition"))) {
[17:36:43.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.629]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.629]                   if (TRUE && !signal) {
[17:36:43.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.629]                     {
[17:36:43.629]                       inherits <- base::inherits
[17:36:43.629]                       invokeRestart <- base::invokeRestart
[17:36:43.629]                       is.null <- base::is.null
[17:36:43.629]                       muffled <- FALSE
[17:36:43.629]                       if (inherits(cond, "message")) {
[17:36:43.629]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.629]                         if (muffled) 
[17:36:43.629]                           invokeRestart("muffleMessage")
[17:36:43.629]                       }
[17:36:43.629]                       else if (inherits(cond, "warning")) {
[17:36:43.629]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.629]                         if (muffled) 
[17:36:43.629]                           invokeRestart("muffleWarning")
[17:36:43.629]                       }
[17:36:43.629]                       else if (inherits(cond, "condition")) {
[17:36:43.629]                         if (!is.null(pattern)) {
[17:36:43.629]                           computeRestarts <- base::computeRestarts
[17:36:43.629]                           grepl <- base::grepl
[17:36:43.629]                           restarts <- computeRestarts(cond)
[17:36:43.629]                           for (restart in restarts) {
[17:36:43.629]                             name <- restart$name
[17:36:43.629]                             if (is.null(name)) 
[17:36:43.629]                               next
[17:36:43.629]                             if (!grepl(pattern, name)) 
[17:36:43.629]                               next
[17:36:43.629]                             invokeRestart(restart)
[17:36:43.629]                             muffled <- TRUE
[17:36:43.629]                             break
[17:36:43.629]                           }
[17:36:43.629]                         }
[17:36:43.629]                       }
[17:36:43.629]                       invisible(muffled)
[17:36:43.629]                     }
[17:36:43.629]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.629]                   }
[17:36:43.629]                 }
[17:36:43.629]                 else {
[17:36:43.629]                   if (TRUE) {
[17:36:43.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.629]                     {
[17:36:43.629]                       inherits <- base::inherits
[17:36:43.629]                       invokeRestart <- base::invokeRestart
[17:36:43.629]                       is.null <- base::is.null
[17:36:43.629]                       muffled <- FALSE
[17:36:43.629]                       if (inherits(cond, "message")) {
[17:36:43.629]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.629]                         if (muffled) 
[17:36:43.629]                           invokeRestart("muffleMessage")
[17:36:43.629]                       }
[17:36:43.629]                       else if (inherits(cond, "warning")) {
[17:36:43.629]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.629]                         if (muffled) 
[17:36:43.629]                           invokeRestart("muffleWarning")
[17:36:43.629]                       }
[17:36:43.629]                       else if (inherits(cond, "condition")) {
[17:36:43.629]                         if (!is.null(pattern)) {
[17:36:43.629]                           computeRestarts <- base::computeRestarts
[17:36:43.629]                           grepl <- base::grepl
[17:36:43.629]                           restarts <- computeRestarts(cond)
[17:36:43.629]                           for (restart in restarts) {
[17:36:43.629]                             name <- restart$name
[17:36:43.629]                             if (is.null(name)) 
[17:36:43.629]                               next
[17:36:43.629]                             if (!grepl(pattern, name)) 
[17:36:43.629]                               next
[17:36:43.629]                             invokeRestart(restart)
[17:36:43.629]                             muffled <- TRUE
[17:36:43.629]                             break
[17:36:43.629]                           }
[17:36:43.629]                         }
[17:36:43.629]                       }
[17:36:43.629]                       invisible(muffled)
[17:36:43.629]                     }
[17:36:43.629]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.629]                   }
[17:36:43.629]                 }
[17:36:43.629]             }
[17:36:43.629]         }))
[17:36:43.629]     }, error = function(ex) {
[17:36:43.629]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.629]                 ...future.rng), started = ...future.startTime, 
[17:36:43.629]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.629]             version = "1.8"), class = "FutureResult")
[17:36:43.629]     }, finally = {
[17:36:43.629]         if (!identical(...future.workdir, getwd())) 
[17:36:43.629]             setwd(...future.workdir)
[17:36:43.629]         {
[17:36:43.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.629]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.629]             }
[17:36:43.629]             base::options(...future.oldOptions)
[17:36:43.629]             if (.Platform$OS.type == "windows") {
[17:36:43.629]                 old_names <- names(...future.oldEnvVars)
[17:36:43.629]                 envs <- base::Sys.getenv()
[17:36:43.629]                 names <- names(envs)
[17:36:43.629]                 common <- intersect(names, old_names)
[17:36:43.629]                 added <- setdiff(names, old_names)
[17:36:43.629]                 removed <- setdiff(old_names, names)
[17:36:43.629]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.629]                   envs[common]]
[17:36:43.629]                 NAMES <- toupper(changed)
[17:36:43.629]                 args <- list()
[17:36:43.629]                 for (kk in seq_along(NAMES)) {
[17:36:43.629]                   name <- changed[[kk]]
[17:36:43.629]                   NAME <- NAMES[[kk]]
[17:36:43.629]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.629]                     next
[17:36:43.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.629]                 }
[17:36:43.629]                 NAMES <- toupper(added)
[17:36:43.629]                 for (kk in seq_along(NAMES)) {
[17:36:43.629]                   name <- added[[kk]]
[17:36:43.629]                   NAME <- NAMES[[kk]]
[17:36:43.629]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.629]                     next
[17:36:43.629]                   args[[name]] <- ""
[17:36:43.629]                 }
[17:36:43.629]                 NAMES <- toupper(removed)
[17:36:43.629]                 for (kk in seq_along(NAMES)) {
[17:36:43.629]                   name <- removed[[kk]]
[17:36:43.629]                   NAME <- NAMES[[kk]]
[17:36:43.629]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.629]                     next
[17:36:43.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.629]                 }
[17:36:43.629]                 if (length(args) > 0) 
[17:36:43.629]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.629]             }
[17:36:43.629]             else {
[17:36:43.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.629]             }
[17:36:43.629]             {
[17:36:43.629]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.629]                   0L) {
[17:36:43.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.629]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.629]                   base::options(opts)
[17:36:43.629]                 }
[17:36:43.629]                 {
[17:36:43.629]                   {
[17:36:43.629]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:43.629]                     NULL
[17:36:43.629]                   }
[17:36:43.629]                   options(future.plan = NULL)
[17:36:43.629]                   if (is.na(NA_character_)) 
[17:36:43.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.629]                     .init = FALSE)
[17:36:43.629]                 }
[17:36:43.629]             }
[17:36:43.629]         }
[17:36:43.629]     })
[17:36:43.629]     if (TRUE) {
[17:36:43.629]         base::sink(type = "output", split = FALSE)
[17:36:43.629]         if (TRUE) {
[17:36:43.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.629]         }
[17:36:43.629]         else {
[17:36:43.629]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.629]         }
[17:36:43.629]         base::close(...future.stdout)
[17:36:43.629]         ...future.stdout <- NULL
[17:36:43.629]     }
[17:36:43.629]     ...future.result$conditions <- ...future.conditions
[17:36:43.629]     ...future.result$finished <- base::Sys.time()
[17:36:43.629]     ...future.result
[17:36:43.629] }
[17:36:43.632] assign_globals() ...
[17:36:43.632] List of 5
[17:36:43.632]  $ ...future.FUN            :function (x, ...)  
[17:36:43.632]  $ future.call.arguments    : list()
[17:36:43.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.632]  $ ...future.elements_ii    :List of 2
[17:36:43.632]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:36:43.632]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:36:43.632]  $ ...future.seeds_ii       : NULL
[17:36:43.632]  $ ...future.globals.maxSize: NULL
[17:36:43.632]  - attr(*, "where")=List of 5
[17:36:43.632]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.632]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.632]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.632]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.632]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.632]  - attr(*, "resolved")= logi FALSE
[17:36:43.632]  - attr(*, "total_size")= num 1248
[17:36:43.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.632]  - attr(*, "already-done")= logi TRUE
[17:36:43.639] - copied ‘...future.FUN’ to environment
[17:36:43.639] - copied ‘future.call.arguments’ to environment
[17:36:43.639] - copied ‘...future.elements_ii’ to environment
[17:36:43.640] - copied ‘...future.seeds_ii’ to environment
[17:36:43.640] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.640] assign_globals() ... done
[17:36:43.640] requestCore(): workers = 2
[17:36:43.642] MulticoreFuture started
[17:36:43.643] - Launch lazy future ... done
[17:36:43.643] run() for ‘MulticoreFuture’ ... done
[17:36:43.643] Created future:
[17:36:43.644] plan(): Setting new future strategy stack:
[17:36:43.644] List of future strategies:
[17:36:43.644] 1. sequential:
[17:36:43.644]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.644]    - tweaked: FALSE
[17:36:43.644]    - call: NULL
[17:36:43.645] plan(): nbrOfWorkers() = 1
[17:36:43.647] plan(): Setting new future strategy stack:
[17:36:43.648] List of future strategies:
[17:36:43.648] 1. multicore:
[17:36:43.648]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:43.648]    - tweaked: FALSE
[17:36:43.648]    - call: plan(strategy)
[17:36:43.652] plan(): nbrOfWorkers() = 2
[17:36:43.643] MulticoreFuture:
[17:36:43.643] Label: ‘future_eapply-2’
[17:36:43.643] Expression:
[17:36:43.643] {
[17:36:43.643]     do.call(function(...) {
[17:36:43.643]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.643]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.643]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.643]             on.exit(options(oopts), add = TRUE)
[17:36:43.643]         }
[17:36:43.643]         {
[17:36:43.643]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.643]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.643]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.643]             })
[17:36:43.643]         }
[17:36:43.643]     }, args = future.call.arguments)
[17:36:43.643] }
[17:36:43.643] Lazy evaluation: FALSE
[17:36:43.643] Asynchronous evaluation: TRUE
[17:36:43.643] Local evaluation: TRUE
[17:36:43.643] Environment: R_GlobalEnv
[17:36:43.643] Capture standard output: TRUE
[17:36:43.643] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.643] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.643] Packages: 1 packages (‘stats’)
[17:36:43.643] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.643] Resolved: TRUE
[17:36:43.643] Value: <not collected>
[17:36:43.643] Conditions captured: <none>
[17:36:43.643] Early signaling: FALSE
[17:36:43.643] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.643] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.653] Chunk #2 of 2 ... DONE
[17:36:43.654] Launching 2 futures (chunks) ... DONE
[17:36:43.654] Resolving 2 futures (chunks) ...
[17:36:43.654] resolve() on list ...
[17:36:43.654]  recursive: 0
[17:36:43.654]  length: 2
[17:36:43.654] 
[17:36:43.655] Future #1
[17:36:43.655] result() for MulticoreFuture ...
[17:36:43.656] result() for MulticoreFuture ...
[17:36:43.656] result() for MulticoreFuture ... done
[17:36:43.656] result() for MulticoreFuture ... done
[17:36:43.656] result() for MulticoreFuture ...
[17:36:43.656] result() for MulticoreFuture ... done
[17:36:43.657] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:43.657] - nx: 2
[17:36:43.657] - relay: TRUE
[17:36:43.657] - stdout: TRUE
[17:36:43.657] - signal: TRUE
[17:36:43.657] - resignal: FALSE
[17:36:43.657] - force: TRUE
[17:36:43.657] - relayed: [n=2] FALSE, FALSE
[17:36:43.658] - queued futures: [n=2] FALSE, FALSE
[17:36:43.658]  - until=1
[17:36:43.658]  - relaying element #1
[17:36:43.658] result() for MulticoreFuture ...
[17:36:43.658] result() for MulticoreFuture ... done
[17:36:43.658] result() for MulticoreFuture ...
[17:36:43.658] result() for MulticoreFuture ... done
[17:36:43.659] result() for MulticoreFuture ...
[17:36:43.659] result() for MulticoreFuture ... done
[17:36:43.659] result() for MulticoreFuture ...
[17:36:43.659] result() for MulticoreFuture ... done
[17:36:43.659] - relayed: [n=2] TRUE, FALSE
[17:36:43.659] - queued futures: [n=2] TRUE, FALSE
[17:36:43.659] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:43.660]  length: 1 (resolved future 1)
[17:36:43.660] Future #2
[17:36:43.660] result() for MulticoreFuture ...
[17:36:43.661] result() for MulticoreFuture ...
[17:36:43.661] result() for MulticoreFuture ... done
[17:36:43.661] result() for MulticoreFuture ... done
[17:36:43.661] result() for MulticoreFuture ...
[17:36:43.661] result() for MulticoreFuture ... done
[17:36:43.664] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:43.664] - nx: 2
[17:36:43.664] - relay: TRUE
[17:36:43.664] - stdout: TRUE
[17:36:43.664] - signal: TRUE
[17:36:43.665] - resignal: FALSE
[17:36:43.665] - force: TRUE
[17:36:43.665] - relayed: [n=2] TRUE, FALSE
[17:36:43.665] - queued futures: [n=2] TRUE, FALSE
[17:36:43.665]  - until=2
[17:36:43.665]  - relaying element #2
[17:36:43.665] result() for MulticoreFuture ...
[17:36:43.665] result() for MulticoreFuture ... done
[17:36:43.665] result() for MulticoreFuture ...
[17:36:43.666] result() for MulticoreFuture ... done
[17:36:43.666] result() for MulticoreFuture ...
[17:36:43.666] result() for MulticoreFuture ... done
[17:36:43.666] result() for MulticoreFuture ...
[17:36:43.666] result() for MulticoreFuture ... done
[17:36:43.666] - relayed: [n=2] TRUE, TRUE
[17:36:43.666] - queued futures: [n=2] TRUE, TRUE
[17:36:43.667] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:43.667]  length: 0 (resolved future 2)
[17:36:43.667] Relaying remaining futures
[17:36:43.667] signalConditionsASAP(NULL, pos=0) ...
[17:36:43.667] - nx: 2
[17:36:43.667] - relay: TRUE
[17:36:43.667] - stdout: TRUE
[17:36:43.667] - signal: TRUE
[17:36:43.668] - resignal: FALSE
[17:36:43.668] - force: TRUE
[17:36:43.668] - relayed: [n=2] TRUE, TRUE
[17:36:43.668] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:43.668] - relayed: [n=2] TRUE, TRUE
[17:36:43.668] - queued futures: [n=2] TRUE, TRUE
[17:36:43.668] signalConditionsASAP(NULL, pos=0) ... done
[17:36:43.668] resolve() on list ... DONE
[17:36:43.669] result() for MulticoreFuture ...
[17:36:43.669] result() for MulticoreFuture ... done
[17:36:43.669] result() for MulticoreFuture ...
[17:36:43.669] result() for MulticoreFuture ... done
[17:36:43.669] result() for MulticoreFuture ...
[17:36:43.669] result() for MulticoreFuture ... done
[17:36:43.669] result() for MulticoreFuture ...
[17:36:43.669] result() for MulticoreFuture ... done
[17:36:43.670]  - Number of value chunks collected: 2
[17:36:43.670] Resolving 2 futures (chunks) ... DONE
[17:36:43.670] Reducing values from 2 chunks ...
[17:36:43.670]  - Number of values collected after concatenation: 3
[17:36:43.670]  - Number of values expected: 3
[17:36:43.670] Reducing values from 2 chunks ... DONE
[17:36:43.670] future_lapply() ... DONE
[17:36:43.671] future_lapply() ...
[17:36:43.675] Number of chunks: 2
[17:36:43.675] getGlobalsAndPackagesXApply() ...
[17:36:43.675]  - future.globals: TRUE
[17:36:43.676] getGlobalsAndPackages() ...
[17:36:43.676] Searching for globals...
[17:36:43.677] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:43.677] Searching for globals ... DONE
[17:36:43.677] Resolving globals: FALSE
[17:36:43.678] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:43.678] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:43.678] - globals: [1] ‘FUN’
[17:36:43.678] - packages: [1] ‘stats’
[17:36:43.678] getGlobalsAndPackages() ... DONE
[17:36:43.679]  - globals found/used: [n=1] ‘FUN’
[17:36:43.679]  - needed namespaces: [n=1] ‘stats’
[17:36:43.679] Finding globals ... DONE
[17:36:43.679]  - use_args: TRUE
[17:36:43.679]  - Getting '...' globals ...
[17:36:43.679] resolve() on list ...
[17:36:43.679]  recursive: 0
[17:36:43.680]  length: 1
[17:36:43.680]  elements: ‘...’
[17:36:43.680]  length: 0 (resolved future 1)
[17:36:43.680] resolve() on list ... DONE
[17:36:43.680]    - '...' content: [n=0] 
[17:36:43.680] List of 1
[17:36:43.680]  $ ...: list()
[17:36:43.680]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.680]  - attr(*, "where")=List of 1
[17:36:43.680]   ..$ ...:<environment: 0x56550231e850> 
[17:36:43.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.680]  - attr(*, "resolved")= logi TRUE
[17:36:43.680]  - attr(*, "total_size")= num NA
[17:36:43.683]  - Getting '...' globals ... DONE
[17:36:43.683] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:43.683] List of 2
[17:36:43.683]  $ ...future.FUN:function (x, ...)  
[17:36:43.683]  $ ...          : list()
[17:36:43.683]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.683]  - attr(*, "where")=List of 2
[17:36:43.683]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:43.683]   ..$ ...          :<environment: 0x56550231e850> 
[17:36:43.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.683]  - attr(*, "resolved")= logi FALSE
[17:36:43.683]  - attr(*, "total_size")= num 1248
[17:36:43.686] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:43.686] getGlobalsAndPackagesXApply() ... DONE
[17:36:43.687] Number of futures (= number of chunks): 2
[17:36:43.687] Launching 2 futures (chunks) ...
[17:36:43.687] Chunk #1 of 2 ...
[17:36:43.687]  - Finding globals in 'X' for chunk #1 ...
[17:36:43.687] getGlobalsAndPackages() ...
[17:36:43.687] Searching for globals...
[17:36:43.687] 
[17:36:43.687] Searching for globals ... DONE
[17:36:43.688] - globals: [0] <none>
[17:36:43.688] getGlobalsAndPackages() ... DONE
[17:36:43.688]    + additional globals found: [n=0] 
[17:36:43.688]    + additional namespaces needed: [n=0] 
[17:36:43.688]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:43.688]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:43.688]  - seeds: <none>
[17:36:43.688]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.688] getGlobalsAndPackages() ...
[17:36:43.688] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.689] Resolving globals: FALSE
[17:36:43.689] Tweak future expression to call with '...' arguments ...
[17:36:43.689] {
[17:36:43.689]     do.call(function(...) {
[17:36:43.689]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.689]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.689]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.689]             on.exit(options(oopts), add = TRUE)
[17:36:43.689]         }
[17:36:43.689]         {
[17:36:43.689]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.689]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.689]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.689]             })
[17:36:43.689]         }
[17:36:43.689]     }, args = future.call.arguments)
[17:36:43.689] }
[17:36:43.689] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.689] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.689] - packages: [1] ‘stats’
[17:36:43.690] getGlobalsAndPackages() ... DONE
[17:36:43.690] run() for ‘Future’ ...
[17:36:43.690] - state: ‘created’
[17:36:43.690] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:43.696] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.696] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:43.696]   - Field: ‘label’
[17:36:43.696]   - Field: ‘local’
[17:36:43.696]   - Field: ‘owner’
[17:36:43.696]   - Field: ‘envir’
[17:36:43.696]   - Field: ‘workers’
[17:36:43.696]   - Field: ‘packages’
[17:36:43.696]   - Field: ‘gc’
[17:36:43.697]   - Field: ‘job’
[17:36:43.697]   - Field: ‘conditions’
[17:36:43.697]   - Field: ‘expr’
[17:36:43.697]   - Field: ‘uuid’
[17:36:43.697]   - Field: ‘seed’
[17:36:43.697]   - Field: ‘version’
[17:36:43.697]   - Field: ‘result’
[17:36:43.697]   - Field: ‘asynchronous’
[17:36:43.697]   - Field: ‘calls’
[17:36:43.697]   - Field: ‘globals’
[17:36:43.697]   - Field: ‘stdout’
[17:36:43.698]   - Field: ‘earlySignal’
[17:36:43.698]   - Field: ‘lazy’
[17:36:43.698]   - Field: ‘state’
[17:36:43.698] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:43.698] - Launch lazy future ...
[17:36:43.698] Packages needed by the future expression (n = 1): ‘stats’
[17:36:43.698] Packages needed by future strategies (n = 0): <none>
[17:36:43.699] {
[17:36:43.699]     {
[17:36:43.699]         {
[17:36:43.699]             ...future.startTime <- base::Sys.time()
[17:36:43.699]             {
[17:36:43.699]                 {
[17:36:43.699]                   {
[17:36:43.699]                     {
[17:36:43.699]                       {
[17:36:43.699]                         base::local({
[17:36:43.699]                           has_future <- base::requireNamespace("future", 
[17:36:43.699]                             quietly = TRUE)
[17:36:43.699]                           if (has_future) {
[17:36:43.699]                             ns <- base::getNamespace("future")
[17:36:43.699]                             version <- ns[[".package"]][["version"]]
[17:36:43.699]                             if (is.null(version)) 
[17:36:43.699]                               version <- utils::packageVersion("future")
[17:36:43.699]                           }
[17:36:43.699]                           else {
[17:36:43.699]                             version <- NULL
[17:36:43.699]                           }
[17:36:43.699]                           if (!has_future || version < "1.8.0") {
[17:36:43.699]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.699]                               "", base::R.version$version.string), 
[17:36:43.699]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:43.699]                                 base::R.version$platform, 8 * 
[17:36:43.699]                                   base::.Machine$sizeof.pointer), 
[17:36:43.699]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.699]                                 "release", "version")], collapse = " "), 
[17:36:43.699]                               hostname = base::Sys.info()[["nodename"]])
[17:36:43.699]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.699]                               info)
[17:36:43.699]                             info <- base::paste(info, collapse = "; ")
[17:36:43.699]                             if (!has_future) {
[17:36:43.699]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.699]                                 info)
[17:36:43.699]                             }
[17:36:43.699]                             else {
[17:36:43.699]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.699]                                 info, version)
[17:36:43.699]                             }
[17:36:43.699]                             base::stop(msg)
[17:36:43.699]                           }
[17:36:43.699]                         })
[17:36:43.699]                       }
[17:36:43.699]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:43.699]                       base::options(mc.cores = 1L)
[17:36:43.699]                     }
[17:36:43.699]                     base::local({
[17:36:43.699]                       for (pkg in "stats") {
[17:36:43.699]                         base::loadNamespace(pkg)
[17:36:43.699]                         base::library(pkg, character.only = TRUE)
[17:36:43.699]                       }
[17:36:43.699]                     })
[17:36:43.699]                   }
[17:36:43.699]                   ...future.strategy.old <- future::plan("list")
[17:36:43.699]                   options(future.plan = NULL)
[17:36:43.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.699]                 }
[17:36:43.699]                 ...future.workdir <- getwd()
[17:36:43.699]             }
[17:36:43.699]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.699]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.699]         }
[17:36:43.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.699]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:43.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.699]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.699]             base::names(...future.oldOptions))
[17:36:43.699]     }
[17:36:43.699]     if (FALSE) {
[17:36:43.699]     }
[17:36:43.699]     else {
[17:36:43.699]         if (TRUE) {
[17:36:43.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.699]                 open = "w")
[17:36:43.699]         }
[17:36:43.699]         else {
[17:36:43.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.699]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.699]         }
[17:36:43.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.699]             base::sink(type = "output", split = FALSE)
[17:36:43.699]             base::close(...future.stdout)
[17:36:43.699]         }, add = TRUE)
[17:36:43.699]     }
[17:36:43.699]     ...future.frame <- base::sys.nframe()
[17:36:43.699]     ...future.conditions <- base::list()
[17:36:43.699]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.699]     if (FALSE) {
[17:36:43.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.699]     }
[17:36:43.699]     ...future.result <- base::tryCatch({
[17:36:43.699]         base::withCallingHandlers({
[17:36:43.699]             ...future.value <- base::withVisible(base::local({
[17:36:43.699]                 withCallingHandlers({
[17:36:43.699]                   {
[17:36:43.699]                     do.call(function(...) {
[17:36:43.699]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.699]                       if (!identical(...future.globals.maxSize.org, 
[17:36:43.699]                         ...future.globals.maxSize)) {
[17:36:43.699]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.699]                         on.exit(options(oopts), add = TRUE)
[17:36:43.699]                       }
[17:36:43.699]                       {
[17:36:43.699]                         lapply(seq_along(...future.elements_ii), 
[17:36:43.699]                           FUN = function(jj) {
[17:36:43.699]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.699]                             ...future.FUN(...future.X_jj, ...)
[17:36:43.699]                           })
[17:36:43.699]                       }
[17:36:43.699]                     }, args = future.call.arguments)
[17:36:43.699]                   }
[17:36:43.699]                 }, immediateCondition = function(cond) {
[17:36:43.699]                   save_rds <- function (object, pathname, ...) 
[17:36:43.699]                   {
[17:36:43.699]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:43.699]                     if (file_test("-f", pathname_tmp)) {
[17:36:43.699]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.699]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:43.699]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.699]                         fi_tmp[["mtime"]])
[17:36:43.699]                     }
[17:36:43.699]                     tryCatch({
[17:36:43.699]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:43.699]                     }, error = function(ex) {
[17:36:43.699]                       msg <- conditionMessage(ex)
[17:36:43.699]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.699]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:43.699]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.699]                         fi_tmp[["mtime"]], msg)
[17:36:43.699]                       ex$message <- msg
[17:36:43.699]                       stop(ex)
[17:36:43.699]                     })
[17:36:43.699]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:43.699]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:43.699]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:43.699]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.699]                       fi <- file.info(pathname)
[17:36:43.699]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:43.699]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.699]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:43.699]                         fi[["size"]], fi[["mtime"]])
[17:36:43.699]                       stop(msg)
[17:36:43.699]                     }
[17:36:43.699]                     invisible(pathname)
[17:36:43.699]                   }
[17:36:43.699]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:43.699]                     rootPath = tempdir()) 
[17:36:43.699]                   {
[17:36:43.699]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:43.699]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:43.699]                       tmpdir = path, fileext = ".rds")
[17:36:43.699]                     save_rds(obj, file)
[17:36:43.699]                   }
[17:36:43.699]                   saveImmediateCondition(cond, path = "/tmp/RtmpEOKIKx/.future/immediateConditions")
[17:36:43.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.699]                   {
[17:36:43.699]                     inherits <- base::inherits
[17:36:43.699]                     invokeRestart <- base::invokeRestart
[17:36:43.699]                     is.null <- base::is.null
[17:36:43.699]                     muffled <- FALSE
[17:36:43.699]                     if (inherits(cond, "message")) {
[17:36:43.699]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:43.699]                       if (muffled) 
[17:36:43.699]                         invokeRestart("muffleMessage")
[17:36:43.699]                     }
[17:36:43.699]                     else if (inherits(cond, "warning")) {
[17:36:43.699]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:43.699]                       if (muffled) 
[17:36:43.699]                         invokeRestart("muffleWarning")
[17:36:43.699]                     }
[17:36:43.699]                     else if (inherits(cond, "condition")) {
[17:36:43.699]                       if (!is.null(pattern)) {
[17:36:43.699]                         computeRestarts <- base::computeRestarts
[17:36:43.699]                         grepl <- base::grepl
[17:36:43.699]                         restarts <- computeRestarts(cond)
[17:36:43.699]                         for (restart in restarts) {
[17:36:43.699]                           name <- restart$name
[17:36:43.699]                           if (is.null(name)) 
[17:36:43.699]                             next
[17:36:43.699]                           if (!grepl(pattern, name)) 
[17:36:43.699]                             next
[17:36:43.699]                           invokeRestart(restart)
[17:36:43.699]                           muffled <- TRUE
[17:36:43.699]                           break
[17:36:43.699]                         }
[17:36:43.699]                       }
[17:36:43.699]                     }
[17:36:43.699]                     invisible(muffled)
[17:36:43.699]                   }
[17:36:43.699]                   muffleCondition(cond)
[17:36:43.699]                 })
[17:36:43.699]             }))
[17:36:43.699]             future::FutureResult(value = ...future.value$value, 
[17:36:43.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.699]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.699]                     ...future.globalenv.names))
[17:36:43.699]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.699]         }, condition = base::local({
[17:36:43.699]             c <- base::c
[17:36:43.699]             inherits <- base::inherits
[17:36:43.699]             invokeRestart <- base::invokeRestart
[17:36:43.699]             length <- base::length
[17:36:43.699]             list <- base::list
[17:36:43.699]             seq.int <- base::seq.int
[17:36:43.699]             signalCondition <- base::signalCondition
[17:36:43.699]             sys.calls <- base::sys.calls
[17:36:43.699]             `[[` <- base::`[[`
[17:36:43.699]             `+` <- base::`+`
[17:36:43.699]             `<<-` <- base::`<<-`
[17:36:43.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.699]                   3L)]
[17:36:43.699]             }
[17:36:43.699]             function(cond) {
[17:36:43.699]                 is_error <- inherits(cond, "error")
[17:36:43.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.699]                   NULL)
[17:36:43.699]                 if (is_error) {
[17:36:43.699]                   sessionInformation <- function() {
[17:36:43.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.699]                       search = base::search(), system = base::Sys.info())
[17:36:43.699]                   }
[17:36:43.699]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.699]                     cond$call), session = sessionInformation(), 
[17:36:43.699]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.699]                   signalCondition(cond)
[17:36:43.699]                 }
[17:36:43.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.699]                 "immediateCondition"))) {
[17:36:43.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.699]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.699]                   if (TRUE && !signal) {
[17:36:43.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.699]                     {
[17:36:43.699]                       inherits <- base::inherits
[17:36:43.699]                       invokeRestart <- base::invokeRestart
[17:36:43.699]                       is.null <- base::is.null
[17:36:43.699]                       muffled <- FALSE
[17:36:43.699]                       if (inherits(cond, "message")) {
[17:36:43.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.699]                         if (muffled) 
[17:36:43.699]                           invokeRestart("muffleMessage")
[17:36:43.699]                       }
[17:36:43.699]                       else if (inherits(cond, "warning")) {
[17:36:43.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.699]                         if (muffled) 
[17:36:43.699]                           invokeRestart("muffleWarning")
[17:36:43.699]                       }
[17:36:43.699]                       else if (inherits(cond, "condition")) {
[17:36:43.699]                         if (!is.null(pattern)) {
[17:36:43.699]                           computeRestarts <- base::computeRestarts
[17:36:43.699]                           grepl <- base::grepl
[17:36:43.699]                           restarts <- computeRestarts(cond)
[17:36:43.699]                           for (restart in restarts) {
[17:36:43.699]                             name <- restart$name
[17:36:43.699]                             if (is.null(name)) 
[17:36:43.699]                               next
[17:36:43.699]                             if (!grepl(pattern, name)) 
[17:36:43.699]                               next
[17:36:43.699]                             invokeRestart(restart)
[17:36:43.699]                             muffled <- TRUE
[17:36:43.699]                             break
[17:36:43.699]                           }
[17:36:43.699]                         }
[17:36:43.699]                       }
[17:36:43.699]                       invisible(muffled)
[17:36:43.699]                     }
[17:36:43.699]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.699]                   }
[17:36:43.699]                 }
[17:36:43.699]                 else {
[17:36:43.699]                   if (TRUE) {
[17:36:43.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.699]                     {
[17:36:43.699]                       inherits <- base::inherits
[17:36:43.699]                       invokeRestart <- base::invokeRestart
[17:36:43.699]                       is.null <- base::is.null
[17:36:43.699]                       muffled <- FALSE
[17:36:43.699]                       if (inherits(cond, "message")) {
[17:36:43.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.699]                         if (muffled) 
[17:36:43.699]                           invokeRestart("muffleMessage")
[17:36:43.699]                       }
[17:36:43.699]                       else if (inherits(cond, "warning")) {
[17:36:43.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.699]                         if (muffled) 
[17:36:43.699]                           invokeRestart("muffleWarning")
[17:36:43.699]                       }
[17:36:43.699]                       else if (inherits(cond, "condition")) {
[17:36:43.699]                         if (!is.null(pattern)) {
[17:36:43.699]                           computeRestarts <- base::computeRestarts
[17:36:43.699]                           grepl <- base::grepl
[17:36:43.699]                           restarts <- computeRestarts(cond)
[17:36:43.699]                           for (restart in restarts) {
[17:36:43.699]                             name <- restart$name
[17:36:43.699]                             if (is.null(name)) 
[17:36:43.699]                               next
[17:36:43.699]                             if (!grepl(pattern, name)) 
[17:36:43.699]                               next
[17:36:43.699]                             invokeRestart(restart)
[17:36:43.699]                             muffled <- TRUE
[17:36:43.699]                             break
[17:36:43.699]                           }
[17:36:43.699]                         }
[17:36:43.699]                       }
[17:36:43.699]                       invisible(muffled)
[17:36:43.699]                     }
[17:36:43.699]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.699]                   }
[17:36:43.699]                 }
[17:36:43.699]             }
[17:36:43.699]         }))
[17:36:43.699]     }, error = function(ex) {
[17:36:43.699]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.699]                 ...future.rng), started = ...future.startTime, 
[17:36:43.699]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.699]             version = "1.8"), class = "FutureResult")
[17:36:43.699]     }, finally = {
[17:36:43.699]         if (!identical(...future.workdir, getwd())) 
[17:36:43.699]             setwd(...future.workdir)
[17:36:43.699]         {
[17:36:43.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.699]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.699]             }
[17:36:43.699]             base::options(...future.oldOptions)
[17:36:43.699]             if (.Platform$OS.type == "windows") {
[17:36:43.699]                 old_names <- names(...future.oldEnvVars)
[17:36:43.699]                 envs <- base::Sys.getenv()
[17:36:43.699]                 names <- names(envs)
[17:36:43.699]                 common <- intersect(names, old_names)
[17:36:43.699]                 added <- setdiff(names, old_names)
[17:36:43.699]                 removed <- setdiff(old_names, names)
[17:36:43.699]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.699]                   envs[common]]
[17:36:43.699]                 NAMES <- toupper(changed)
[17:36:43.699]                 args <- list()
[17:36:43.699]                 for (kk in seq_along(NAMES)) {
[17:36:43.699]                   name <- changed[[kk]]
[17:36:43.699]                   NAME <- NAMES[[kk]]
[17:36:43.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.699]                     next
[17:36:43.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.699]                 }
[17:36:43.699]                 NAMES <- toupper(added)
[17:36:43.699]                 for (kk in seq_along(NAMES)) {
[17:36:43.699]                   name <- added[[kk]]
[17:36:43.699]                   NAME <- NAMES[[kk]]
[17:36:43.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.699]                     next
[17:36:43.699]                   args[[name]] <- ""
[17:36:43.699]                 }
[17:36:43.699]                 NAMES <- toupper(removed)
[17:36:43.699]                 for (kk in seq_along(NAMES)) {
[17:36:43.699]                   name <- removed[[kk]]
[17:36:43.699]                   NAME <- NAMES[[kk]]
[17:36:43.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.699]                     next
[17:36:43.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.699]                 }
[17:36:43.699]                 if (length(args) > 0) 
[17:36:43.699]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.699]             }
[17:36:43.699]             else {
[17:36:43.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.699]             }
[17:36:43.699]             {
[17:36:43.699]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.699]                   0L) {
[17:36:43.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.699]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.699]                   base::options(opts)
[17:36:43.699]                 }
[17:36:43.699]                 {
[17:36:43.699]                   {
[17:36:43.699]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:43.699]                     NULL
[17:36:43.699]                   }
[17:36:43.699]                   options(future.plan = NULL)
[17:36:43.699]                   if (is.na(NA_character_)) 
[17:36:43.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.699]                     .init = FALSE)
[17:36:43.699]                 }
[17:36:43.699]             }
[17:36:43.699]         }
[17:36:43.699]     })
[17:36:43.699]     if (TRUE) {
[17:36:43.699]         base::sink(type = "output", split = FALSE)
[17:36:43.699]         if (TRUE) {
[17:36:43.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.699]         }
[17:36:43.699]         else {
[17:36:43.699]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.699]         }
[17:36:43.699]         base::close(...future.stdout)
[17:36:43.699]         ...future.stdout <- NULL
[17:36:43.699]     }
[17:36:43.699]     ...future.result$conditions <- ...future.conditions
[17:36:43.699]     ...future.result$finished <- base::Sys.time()
[17:36:43.699]     ...future.result
[17:36:43.699] }
[17:36:43.701] assign_globals() ...
[17:36:43.701] List of 5
[17:36:43.701]  $ ...future.FUN            :function (x, ...)  
[17:36:43.701]  $ future.call.arguments    : list()
[17:36:43.701]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.701]  $ ...future.elements_ii    :List of 1
[17:36:43.701]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:36:43.701]  $ ...future.seeds_ii       : NULL
[17:36:43.701]  $ ...future.globals.maxSize: NULL
[17:36:43.701]  - attr(*, "where")=List of 5
[17:36:43.701]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.701]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.701]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.701]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.701]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.701]  - attr(*, "resolved")= logi FALSE
[17:36:43.701]  - attr(*, "total_size")= num 1248
[17:36:43.701]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.701]  - attr(*, "already-done")= logi TRUE
[17:36:43.706] - copied ‘...future.FUN’ to environment
[17:36:43.706] - copied ‘future.call.arguments’ to environment
[17:36:43.706] - copied ‘...future.elements_ii’ to environment
[17:36:43.706] - copied ‘...future.seeds_ii’ to environment
[17:36:43.706] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.707] assign_globals() ... done
[17:36:43.707] requestCore(): workers = 2
[17:36:43.709] MulticoreFuture started
[17:36:43.709] - Launch lazy future ... done
[17:36:43.710] run() for ‘MulticoreFuture’ ... done
[17:36:43.710] Created future:
[17:36:43.710] plan(): Setting new future strategy stack:
[17:36:43.711] List of future strategies:
[17:36:43.711] 1. sequential:
[17:36:43.711]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.711]    - tweaked: FALSE
[17:36:43.711]    - call: NULL
[17:36:43.712] plan(): nbrOfWorkers() = 1
[17:36:43.714] plan(): Setting new future strategy stack:
[17:36:43.714] List of future strategies:
[17:36:43.714] 1. multicore:
[17:36:43.714]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:43.714]    - tweaked: FALSE
[17:36:43.714]    - call: plan(strategy)
[17:36:43.720] plan(): nbrOfWorkers() = 2
[17:36:43.710] MulticoreFuture:
[17:36:43.710] Label: ‘future_eapply-1’
[17:36:43.710] Expression:
[17:36:43.710] {
[17:36:43.710]     do.call(function(...) {
[17:36:43.710]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.710]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.710]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.710]             on.exit(options(oopts), add = TRUE)
[17:36:43.710]         }
[17:36:43.710]         {
[17:36:43.710]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.710]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.710]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.710]             })
[17:36:43.710]         }
[17:36:43.710]     }, args = future.call.arguments)
[17:36:43.710] }
[17:36:43.710] Lazy evaluation: FALSE
[17:36:43.710] Asynchronous evaluation: TRUE
[17:36:43.710] Local evaluation: TRUE
[17:36:43.710] Environment: R_GlobalEnv
[17:36:43.710] Capture standard output: TRUE
[17:36:43.710] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.710] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.710] Packages: 1 packages (‘stats’)
[17:36:43.710] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.710] Resolved: TRUE
[17:36:43.710] Value: <not collected>
[17:36:43.710] Conditions captured: <none>
[17:36:43.710] Early signaling: FALSE
[17:36:43.710] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.710] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.721] Chunk #1 of 2 ... DONE
[17:36:43.721] Chunk #2 of 2 ...
[17:36:43.721]  - Finding globals in 'X' for chunk #2 ...
[17:36:43.721] getGlobalsAndPackages() ...
[17:36:43.721] Searching for globals...
[17:36:43.722] 
[17:36:43.722] Searching for globals ... DONE
[17:36:43.722] - globals: [0] <none>
[17:36:43.722] getGlobalsAndPackages() ... DONE
[17:36:43.722]    + additional globals found: [n=0] 
[17:36:43.722]    + additional namespaces needed: [n=0] 
[17:36:43.722]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:43.723]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:43.723]  - seeds: <none>
[17:36:43.723]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.723] getGlobalsAndPackages() ...
[17:36:43.723] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.723] Resolving globals: FALSE
[17:36:43.723] Tweak future expression to call with '...' arguments ...
[17:36:43.724] {
[17:36:43.724]     do.call(function(...) {
[17:36:43.724]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.724]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.724]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.724]             on.exit(options(oopts), add = TRUE)
[17:36:43.724]         }
[17:36:43.724]         {
[17:36:43.724]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.724]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.724]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.724]             })
[17:36:43.724]         }
[17:36:43.724]     }, args = future.call.arguments)
[17:36:43.724] }
[17:36:43.724] Tweak future expression to call with '...' arguments ... DONE
[17:36:43.725] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:43.725] - packages: [1] ‘stats’
[17:36:43.725] getGlobalsAndPackages() ... DONE
[17:36:43.726] run() for ‘Future’ ...
[17:36:43.726] - state: ‘created’
[17:36:43.726] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:43.731] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.731] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:43.731]   - Field: ‘label’
[17:36:43.732]   - Field: ‘local’
[17:36:43.732]   - Field: ‘owner’
[17:36:43.732]   - Field: ‘envir’
[17:36:43.732]   - Field: ‘workers’
[17:36:43.732]   - Field: ‘packages’
[17:36:43.732]   - Field: ‘gc’
[17:36:43.732]   - Field: ‘job’
[17:36:43.733]   - Field: ‘conditions’
[17:36:43.733]   - Field: ‘expr’
[17:36:43.733]   - Field: ‘uuid’
[17:36:43.733]   - Field: ‘seed’
[17:36:43.733]   - Field: ‘version’
[17:36:43.733]   - Field: ‘result’
[17:36:43.733]   - Field: ‘asynchronous’
[17:36:43.734]   - Field: ‘calls’
[17:36:43.734]   - Field: ‘globals’
[17:36:43.734]   - Field: ‘stdout’
[17:36:43.734]   - Field: ‘earlySignal’
[17:36:43.734]   - Field: ‘lazy’
[17:36:43.734]   - Field: ‘state’
[17:36:43.734] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:43.734] - Launch lazy future ...
[17:36:43.735] Packages needed by the future expression (n = 1): ‘stats’
[17:36:43.735] Packages needed by future strategies (n = 0): <none>
[17:36:43.736] {
[17:36:43.736]     {
[17:36:43.736]         {
[17:36:43.736]             ...future.startTime <- base::Sys.time()
[17:36:43.736]             {
[17:36:43.736]                 {
[17:36:43.736]                   {
[17:36:43.736]                     {
[17:36:43.736]                       {
[17:36:43.736]                         base::local({
[17:36:43.736]                           has_future <- base::requireNamespace("future", 
[17:36:43.736]                             quietly = TRUE)
[17:36:43.736]                           if (has_future) {
[17:36:43.736]                             ns <- base::getNamespace("future")
[17:36:43.736]                             version <- ns[[".package"]][["version"]]
[17:36:43.736]                             if (is.null(version)) 
[17:36:43.736]                               version <- utils::packageVersion("future")
[17:36:43.736]                           }
[17:36:43.736]                           else {
[17:36:43.736]                             version <- NULL
[17:36:43.736]                           }
[17:36:43.736]                           if (!has_future || version < "1.8.0") {
[17:36:43.736]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:43.736]                               "", base::R.version$version.string), 
[17:36:43.736]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:43.736]                                 base::R.version$platform, 8 * 
[17:36:43.736]                                   base::.Machine$sizeof.pointer), 
[17:36:43.736]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:43.736]                                 "release", "version")], collapse = " "), 
[17:36:43.736]                               hostname = base::Sys.info()[["nodename"]])
[17:36:43.736]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:43.736]                               info)
[17:36:43.736]                             info <- base::paste(info, collapse = "; ")
[17:36:43.736]                             if (!has_future) {
[17:36:43.736]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:43.736]                                 info)
[17:36:43.736]                             }
[17:36:43.736]                             else {
[17:36:43.736]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:43.736]                                 info, version)
[17:36:43.736]                             }
[17:36:43.736]                             base::stop(msg)
[17:36:43.736]                           }
[17:36:43.736]                         })
[17:36:43.736]                       }
[17:36:43.736]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:43.736]                       base::options(mc.cores = 1L)
[17:36:43.736]                     }
[17:36:43.736]                     base::local({
[17:36:43.736]                       for (pkg in "stats") {
[17:36:43.736]                         base::loadNamespace(pkg)
[17:36:43.736]                         base::library(pkg, character.only = TRUE)
[17:36:43.736]                       }
[17:36:43.736]                     })
[17:36:43.736]                   }
[17:36:43.736]                   ...future.strategy.old <- future::plan("list")
[17:36:43.736]                   options(future.plan = NULL)
[17:36:43.736]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.736]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:43.736]                 }
[17:36:43.736]                 ...future.workdir <- getwd()
[17:36:43.736]             }
[17:36:43.736]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:43.736]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:43.736]         }
[17:36:43.736]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:43.736]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:43.736]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:43.736]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:43.736]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:43.736]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:43.736]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:43.736]             base::names(...future.oldOptions))
[17:36:43.736]     }
[17:36:43.736]     if (FALSE) {
[17:36:43.736]     }
[17:36:43.736]     else {
[17:36:43.736]         if (TRUE) {
[17:36:43.736]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:43.736]                 open = "w")
[17:36:43.736]         }
[17:36:43.736]         else {
[17:36:43.736]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:43.736]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:43.736]         }
[17:36:43.736]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:43.736]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:43.736]             base::sink(type = "output", split = FALSE)
[17:36:43.736]             base::close(...future.stdout)
[17:36:43.736]         }, add = TRUE)
[17:36:43.736]     }
[17:36:43.736]     ...future.frame <- base::sys.nframe()
[17:36:43.736]     ...future.conditions <- base::list()
[17:36:43.736]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:43.736]     if (FALSE) {
[17:36:43.736]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:43.736]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:43.736]     }
[17:36:43.736]     ...future.result <- base::tryCatch({
[17:36:43.736]         base::withCallingHandlers({
[17:36:43.736]             ...future.value <- base::withVisible(base::local({
[17:36:43.736]                 withCallingHandlers({
[17:36:43.736]                   {
[17:36:43.736]                     do.call(function(...) {
[17:36:43.736]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.736]                       if (!identical(...future.globals.maxSize.org, 
[17:36:43.736]                         ...future.globals.maxSize)) {
[17:36:43.736]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.736]                         on.exit(options(oopts), add = TRUE)
[17:36:43.736]                       }
[17:36:43.736]                       {
[17:36:43.736]                         lapply(seq_along(...future.elements_ii), 
[17:36:43.736]                           FUN = function(jj) {
[17:36:43.736]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.736]                             ...future.FUN(...future.X_jj, ...)
[17:36:43.736]                           })
[17:36:43.736]                       }
[17:36:43.736]                     }, args = future.call.arguments)
[17:36:43.736]                   }
[17:36:43.736]                 }, immediateCondition = function(cond) {
[17:36:43.736]                   save_rds <- function (object, pathname, ...) 
[17:36:43.736]                   {
[17:36:43.736]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:43.736]                     if (file_test("-f", pathname_tmp)) {
[17:36:43.736]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.736]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:43.736]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.736]                         fi_tmp[["mtime"]])
[17:36:43.736]                     }
[17:36:43.736]                     tryCatch({
[17:36:43.736]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:43.736]                     }, error = function(ex) {
[17:36:43.736]                       msg <- conditionMessage(ex)
[17:36:43.736]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.736]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:43.736]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.736]                         fi_tmp[["mtime"]], msg)
[17:36:43.736]                       ex$message <- msg
[17:36:43.736]                       stop(ex)
[17:36:43.736]                     })
[17:36:43.736]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:43.736]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:43.736]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:43.736]                       fi_tmp <- file.info(pathname_tmp)
[17:36:43.736]                       fi <- file.info(pathname)
[17:36:43.736]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:43.736]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:43.736]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:43.736]                         fi[["size"]], fi[["mtime"]])
[17:36:43.736]                       stop(msg)
[17:36:43.736]                     }
[17:36:43.736]                     invisible(pathname)
[17:36:43.736]                   }
[17:36:43.736]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:43.736]                     rootPath = tempdir()) 
[17:36:43.736]                   {
[17:36:43.736]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:43.736]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:43.736]                       tmpdir = path, fileext = ".rds")
[17:36:43.736]                     save_rds(obj, file)
[17:36:43.736]                   }
[17:36:43.736]                   saveImmediateCondition(cond, path = "/tmp/RtmpEOKIKx/.future/immediateConditions")
[17:36:43.736]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.736]                   {
[17:36:43.736]                     inherits <- base::inherits
[17:36:43.736]                     invokeRestart <- base::invokeRestart
[17:36:43.736]                     is.null <- base::is.null
[17:36:43.736]                     muffled <- FALSE
[17:36:43.736]                     if (inherits(cond, "message")) {
[17:36:43.736]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:43.736]                       if (muffled) 
[17:36:43.736]                         invokeRestart("muffleMessage")
[17:36:43.736]                     }
[17:36:43.736]                     else if (inherits(cond, "warning")) {
[17:36:43.736]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:43.736]                       if (muffled) 
[17:36:43.736]                         invokeRestart("muffleWarning")
[17:36:43.736]                     }
[17:36:43.736]                     else if (inherits(cond, "condition")) {
[17:36:43.736]                       if (!is.null(pattern)) {
[17:36:43.736]                         computeRestarts <- base::computeRestarts
[17:36:43.736]                         grepl <- base::grepl
[17:36:43.736]                         restarts <- computeRestarts(cond)
[17:36:43.736]                         for (restart in restarts) {
[17:36:43.736]                           name <- restart$name
[17:36:43.736]                           if (is.null(name)) 
[17:36:43.736]                             next
[17:36:43.736]                           if (!grepl(pattern, name)) 
[17:36:43.736]                             next
[17:36:43.736]                           invokeRestart(restart)
[17:36:43.736]                           muffled <- TRUE
[17:36:43.736]                           break
[17:36:43.736]                         }
[17:36:43.736]                       }
[17:36:43.736]                     }
[17:36:43.736]                     invisible(muffled)
[17:36:43.736]                   }
[17:36:43.736]                   muffleCondition(cond)
[17:36:43.736]                 })
[17:36:43.736]             }))
[17:36:43.736]             future::FutureResult(value = ...future.value$value, 
[17:36:43.736]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.736]                   ...future.rng), globalenv = if (FALSE) 
[17:36:43.736]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:43.736]                     ...future.globalenv.names))
[17:36:43.736]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:43.736]         }, condition = base::local({
[17:36:43.736]             c <- base::c
[17:36:43.736]             inherits <- base::inherits
[17:36:43.736]             invokeRestart <- base::invokeRestart
[17:36:43.736]             length <- base::length
[17:36:43.736]             list <- base::list
[17:36:43.736]             seq.int <- base::seq.int
[17:36:43.736]             signalCondition <- base::signalCondition
[17:36:43.736]             sys.calls <- base::sys.calls
[17:36:43.736]             `[[` <- base::`[[`
[17:36:43.736]             `+` <- base::`+`
[17:36:43.736]             `<<-` <- base::`<<-`
[17:36:43.736]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:43.736]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:43.736]                   3L)]
[17:36:43.736]             }
[17:36:43.736]             function(cond) {
[17:36:43.736]                 is_error <- inherits(cond, "error")
[17:36:43.736]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:43.736]                   NULL)
[17:36:43.736]                 if (is_error) {
[17:36:43.736]                   sessionInformation <- function() {
[17:36:43.736]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:43.736]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:43.736]                       search = base::search(), system = base::Sys.info())
[17:36:43.736]                   }
[17:36:43.736]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.736]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:43.736]                     cond$call), session = sessionInformation(), 
[17:36:43.736]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:43.736]                   signalCondition(cond)
[17:36:43.736]                 }
[17:36:43.736]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:43.736]                 "immediateCondition"))) {
[17:36:43.736]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:43.736]                   ...future.conditions[[length(...future.conditions) + 
[17:36:43.736]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:43.736]                   if (TRUE && !signal) {
[17:36:43.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.736]                     {
[17:36:43.736]                       inherits <- base::inherits
[17:36:43.736]                       invokeRestart <- base::invokeRestart
[17:36:43.736]                       is.null <- base::is.null
[17:36:43.736]                       muffled <- FALSE
[17:36:43.736]                       if (inherits(cond, "message")) {
[17:36:43.736]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.736]                         if (muffled) 
[17:36:43.736]                           invokeRestart("muffleMessage")
[17:36:43.736]                       }
[17:36:43.736]                       else if (inherits(cond, "warning")) {
[17:36:43.736]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.736]                         if (muffled) 
[17:36:43.736]                           invokeRestart("muffleWarning")
[17:36:43.736]                       }
[17:36:43.736]                       else if (inherits(cond, "condition")) {
[17:36:43.736]                         if (!is.null(pattern)) {
[17:36:43.736]                           computeRestarts <- base::computeRestarts
[17:36:43.736]                           grepl <- base::grepl
[17:36:43.736]                           restarts <- computeRestarts(cond)
[17:36:43.736]                           for (restart in restarts) {
[17:36:43.736]                             name <- restart$name
[17:36:43.736]                             if (is.null(name)) 
[17:36:43.736]                               next
[17:36:43.736]                             if (!grepl(pattern, name)) 
[17:36:43.736]                               next
[17:36:43.736]                             invokeRestart(restart)
[17:36:43.736]                             muffled <- TRUE
[17:36:43.736]                             break
[17:36:43.736]                           }
[17:36:43.736]                         }
[17:36:43.736]                       }
[17:36:43.736]                       invisible(muffled)
[17:36:43.736]                     }
[17:36:43.736]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.736]                   }
[17:36:43.736]                 }
[17:36:43.736]                 else {
[17:36:43.736]                   if (TRUE) {
[17:36:43.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:43.736]                     {
[17:36:43.736]                       inherits <- base::inherits
[17:36:43.736]                       invokeRestart <- base::invokeRestart
[17:36:43.736]                       is.null <- base::is.null
[17:36:43.736]                       muffled <- FALSE
[17:36:43.736]                       if (inherits(cond, "message")) {
[17:36:43.736]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:43.736]                         if (muffled) 
[17:36:43.736]                           invokeRestart("muffleMessage")
[17:36:43.736]                       }
[17:36:43.736]                       else if (inherits(cond, "warning")) {
[17:36:43.736]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:43.736]                         if (muffled) 
[17:36:43.736]                           invokeRestart("muffleWarning")
[17:36:43.736]                       }
[17:36:43.736]                       else if (inherits(cond, "condition")) {
[17:36:43.736]                         if (!is.null(pattern)) {
[17:36:43.736]                           computeRestarts <- base::computeRestarts
[17:36:43.736]                           grepl <- base::grepl
[17:36:43.736]                           restarts <- computeRestarts(cond)
[17:36:43.736]                           for (restart in restarts) {
[17:36:43.736]                             name <- restart$name
[17:36:43.736]                             if (is.null(name)) 
[17:36:43.736]                               next
[17:36:43.736]                             if (!grepl(pattern, name)) 
[17:36:43.736]                               next
[17:36:43.736]                             invokeRestart(restart)
[17:36:43.736]                             muffled <- TRUE
[17:36:43.736]                             break
[17:36:43.736]                           }
[17:36:43.736]                         }
[17:36:43.736]                       }
[17:36:43.736]                       invisible(muffled)
[17:36:43.736]                     }
[17:36:43.736]                     muffleCondition(cond, pattern = "^muffle")
[17:36:43.736]                   }
[17:36:43.736]                 }
[17:36:43.736]             }
[17:36:43.736]         }))
[17:36:43.736]     }, error = function(ex) {
[17:36:43.736]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:43.736]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:43.736]                 ...future.rng), started = ...future.startTime, 
[17:36:43.736]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:43.736]             version = "1.8"), class = "FutureResult")
[17:36:43.736]     }, finally = {
[17:36:43.736]         if (!identical(...future.workdir, getwd())) 
[17:36:43.736]             setwd(...future.workdir)
[17:36:43.736]         {
[17:36:43.736]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:43.736]                 ...future.oldOptions$nwarnings <- NULL
[17:36:43.736]             }
[17:36:43.736]             base::options(...future.oldOptions)
[17:36:43.736]             if (.Platform$OS.type == "windows") {
[17:36:43.736]                 old_names <- names(...future.oldEnvVars)
[17:36:43.736]                 envs <- base::Sys.getenv()
[17:36:43.736]                 names <- names(envs)
[17:36:43.736]                 common <- intersect(names, old_names)
[17:36:43.736]                 added <- setdiff(names, old_names)
[17:36:43.736]                 removed <- setdiff(old_names, names)
[17:36:43.736]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:43.736]                   envs[common]]
[17:36:43.736]                 NAMES <- toupper(changed)
[17:36:43.736]                 args <- list()
[17:36:43.736]                 for (kk in seq_along(NAMES)) {
[17:36:43.736]                   name <- changed[[kk]]
[17:36:43.736]                   NAME <- NAMES[[kk]]
[17:36:43.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.736]                     next
[17:36:43.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.736]                 }
[17:36:43.736]                 NAMES <- toupper(added)
[17:36:43.736]                 for (kk in seq_along(NAMES)) {
[17:36:43.736]                   name <- added[[kk]]
[17:36:43.736]                   NAME <- NAMES[[kk]]
[17:36:43.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.736]                     next
[17:36:43.736]                   args[[name]] <- ""
[17:36:43.736]                 }
[17:36:43.736]                 NAMES <- toupper(removed)
[17:36:43.736]                 for (kk in seq_along(NAMES)) {
[17:36:43.736]                   name <- removed[[kk]]
[17:36:43.736]                   NAME <- NAMES[[kk]]
[17:36:43.736]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:43.736]                     next
[17:36:43.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:43.736]                 }
[17:36:43.736]                 if (length(args) > 0) 
[17:36:43.736]                   base::do.call(base::Sys.setenv, args = args)
[17:36:43.736]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:43.736]             }
[17:36:43.736]             else {
[17:36:43.736]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:43.736]             }
[17:36:43.736]             {
[17:36:43.736]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:43.736]                   0L) {
[17:36:43.736]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:43.736]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:43.736]                   base::options(opts)
[17:36:43.736]                 }
[17:36:43.736]                 {
[17:36:43.736]                   {
[17:36:43.736]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:43.736]                     NULL
[17:36:43.736]                   }
[17:36:43.736]                   options(future.plan = NULL)
[17:36:43.736]                   if (is.na(NA_character_)) 
[17:36:43.736]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:43.736]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:43.736]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:43.736]                     .init = FALSE)
[17:36:43.736]                 }
[17:36:43.736]             }
[17:36:43.736]         }
[17:36:43.736]     })
[17:36:43.736]     if (TRUE) {
[17:36:43.736]         base::sink(type = "output", split = FALSE)
[17:36:43.736]         if (TRUE) {
[17:36:43.736]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:43.736]         }
[17:36:43.736]         else {
[17:36:43.736]             ...future.result["stdout"] <- base::list(NULL)
[17:36:43.736]         }
[17:36:43.736]         base::close(...future.stdout)
[17:36:43.736]         ...future.stdout <- NULL
[17:36:43.736]     }
[17:36:43.736]     ...future.result$conditions <- ...future.conditions
[17:36:43.736]     ...future.result$finished <- base::Sys.time()
[17:36:43.736]     ...future.result
[17:36:43.736] }
[17:36:43.739] assign_globals() ...
[17:36:43.739] List of 5
[17:36:43.739]  $ ...future.FUN            :function (x, ...)  
[17:36:43.739]  $ future.call.arguments    : list()
[17:36:43.739]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:43.739]  $ ...future.elements_ii    :List of 2
[17:36:43.739]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:36:43.739]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:36:43.739]  $ ...future.seeds_ii       : NULL
[17:36:43.739]  $ ...future.globals.maxSize: NULL
[17:36:43.739]  - attr(*, "where")=List of 5
[17:36:43.739]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:43.739]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:43.739]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:43.739]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:43.739]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:43.739]  - attr(*, "resolved")= logi FALSE
[17:36:43.739]  - attr(*, "total_size")= num 1248
[17:36:43.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:43.739]  - attr(*, "already-done")= logi TRUE
[17:36:43.751] - copied ‘...future.FUN’ to environment
[17:36:43.751] - copied ‘future.call.arguments’ to environment
[17:36:43.751] - copied ‘...future.elements_ii’ to environment
[17:36:43.752] - copied ‘...future.seeds_ii’ to environment
[17:36:43.752] - copied ‘...future.globals.maxSize’ to environment
[17:36:43.752] assign_globals() ... done
[17:36:43.752] requestCore(): workers = 2
[17:36:43.755] MulticoreFuture started
[17:36:43.755] - Launch lazy future ... done
[17:36:43.755] run() for ‘MulticoreFuture’ ... done
[17:36:43.756] Created future:
[17:36:43.756] plan(): Setting new future strategy stack:
[17:36:43.757] List of future strategies:
[17:36:43.757] 1. sequential:
[17:36:43.757]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.757]    - tweaked: FALSE
[17:36:43.757]    - call: NULL
[17:36:43.758] plan(): nbrOfWorkers() = 1
[17:36:43.761] plan(): Setting new future strategy stack:
[17:36:43.761] List of future strategies:
[17:36:43.761] 1. multicore:
[17:36:43.761]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:43.761]    - tweaked: FALSE
[17:36:43.761]    - call: plan(strategy)
[17:36:43.766] plan(): nbrOfWorkers() = 2
[17:36:43.756] MulticoreFuture:
[17:36:43.756] Label: ‘future_eapply-2’
[17:36:43.756] Expression:
[17:36:43.756] {
[17:36:43.756]     do.call(function(...) {
[17:36:43.756]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:43.756]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:43.756]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:43.756]             on.exit(options(oopts), add = TRUE)
[17:36:43.756]         }
[17:36:43.756]         {
[17:36:43.756]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:43.756]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:43.756]                 ...future.FUN(...future.X_jj, ...)
[17:36:43.756]             })
[17:36:43.756]         }
[17:36:43.756]     }, args = future.call.arguments)
[17:36:43.756] }
[17:36:43.756] Lazy evaluation: FALSE
[17:36:43.756] Asynchronous evaluation: TRUE
[17:36:43.756] Local evaluation: TRUE
[17:36:43.756] Environment: R_GlobalEnv
[17:36:43.756] Capture standard output: TRUE
[17:36:43.756] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:43.756] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:43.756] Packages: 1 packages (‘stats’)
[17:36:43.756] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:43.756] Resolved: TRUE
[17:36:43.756] Value: <not collected>
[17:36:43.756] Conditions captured: <none>
[17:36:43.756] Early signaling: FALSE
[17:36:43.756] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:43.756] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:43.767] Chunk #2 of 2 ... DONE
[17:36:43.768] Launching 2 futures (chunks) ... DONE
[17:36:43.768] Resolving 2 futures (chunks) ...
[17:36:43.768] resolve() on list ...
[17:36:43.768]  recursive: 0
[17:36:43.768]  length: 2
[17:36:43.768] 
[17:36:43.769] Future #1
[17:36:43.769] result() for MulticoreFuture ...
[17:36:43.770] result() for MulticoreFuture ...
[17:36:43.770] result() for MulticoreFuture ... done
[17:36:43.770] result() for MulticoreFuture ... done
[17:36:43.771] result() for MulticoreFuture ...
[17:36:43.771] result() for MulticoreFuture ... done
[17:36:43.771] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:43.771] - nx: 2
[17:36:43.771] - relay: TRUE
[17:36:43.772] - stdout: TRUE
[17:36:43.772] - signal: TRUE
[17:36:43.772] - resignal: FALSE
[17:36:43.772] - force: TRUE
[17:36:43.772] - relayed: [n=2] FALSE, FALSE
[17:36:43.773] - queued futures: [n=2] FALSE, FALSE
[17:36:43.773]  - until=1
[17:36:43.773]  - relaying element #1
[17:36:43.773] result() for MulticoreFuture ...
[17:36:43.773] result() for MulticoreFuture ... done
[17:36:43.774] result() for MulticoreFuture ...
[17:36:43.774] result() for MulticoreFuture ... done
[17:36:43.774] result() for MulticoreFuture ...
[17:36:43.774] result() for MulticoreFuture ... done
[17:36:43.774] result() for MulticoreFuture ...
[17:36:43.775] result() for MulticoreFuture ... done
[17:36:43.775] - relayed: [n=2] TRUE, FALSE
[17:36:43.775] - queued futures: [n=2] TRUE, FALSE
[17:36:43.775] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:43.775]  length: 1 (resolved future 1)
[17:36:43.776] Future #2
[17:36:43.776] result() for MulticoreFuture ...
[17:36:43.776] result() for MulticoreFuture ...
[17:36:43.777] result() for MulticoreFuture ... done
[17:36:43.777] result() for MulticoreFuture ... done
[17:36:43.777] result() for MulticoreFuture ...
[17:36:43.777] result() for MulticoreFuture ... done
[17:36:43.777] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:43.777] - nx: 2
[17:36:43.777] - relay: TRUE
[17:36:43.778] - stdout: TRUE
[17:36:43.778] - signal: TRUE
[17:36:43.778] - resignal: FALSE
[17:36:43.778] - force: TRUE
[17:36:43.778] - relayed: [n=2] TRUE, FALSE
[17:36:43.778] - queued futures: [n=2] TRUE, FALSE
[17:36:43.778]  - until=2
[17:36:43.778]  - relaying element #2
[17:36:43.779] result() for MulticoreFuture ...
[17:36:43.779] result() for MulticoreFuture ... done
[17:36:43.779] result() for MulticoreFuture ...
[17:36:43.779] result() for MulticoreFuture ... done
[17:36:43.779] result() for MulticoreFuture ...
[17:36:43.779] result() for MulticoreFuture ... done
[17:36:43.779] result() for MulticoreFuture ...
[17:36:43.779] result() for MulticoreFuture ... done
[17:36:43.780] - relayed: [n=2] TRUE, TRUE
[17:36:43.780] - queued futures: [n=2] TRUE, TRUE
[17:36:43.780] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:43.780]  length: 0 (resolved future 2)
[17:36:43.780] Relaying remaining futures
[17:36:43.780] signalConditionsASAP(NULL, pos=0) ...
[17:36:43.780] - nx: 2
[17:36:43.780] - relay: TRUE
[17:36:43.780] - stdout: TRUE
[17:36:43.781] - signal: TRUE
[17:36:43.781] - resignal: FALSE
[17:36:43.781] - force: TRUE
[17:36:43.781] - relayed: [n=2] TRUE, TRUE
[17:36:43.781] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:43.781] - relayed: [n=2] TRUE, TRUE
[17:36:43.781] - queued futures: [n=2] TRUE, TRUE
[17:36:43.781] signalConditionsASAP(NULL, pos=0) ... done
[17:36:43.781] resolve() on list ... DONE
[17:36:43.782] result() for MulticoreFuture ...
[17:36:43.782] result() for MulticoreFuture ... done
[17:36:43.782] result() for MulticoreFuture ...
[17:36:43.782] result() for MulticoreFuture ... done
[17:36:43.782] result() for MulticoreFuture ...
[17:36:43.782] result() for MulticoreFuture ... done
[17:36:43.782] result() for MulticoreFuture ...
[17:36:43.782] result() for MulticoreFuture ... done
[17:36:43.783]  - Number of value chunks collected: 2
[17:36:43.783] Resolving 2 futures (chunks) ... DONE
[17:36:43.783] Reducing values from 2 chunks ...
[17:36:43.783]  - Number of values collected after concatenation: 3
[17:36:43.783]  - Number of values expected: 3
[17:36:43.783] Reducing values from 2 chunks ... DONE
[17:36:43.783] future_lapply() ... DONE
[17:36:43.784] plan(): Setting new future strategy stack:
[17:36:43.784] List of future strategies:
[17:36:43.784] 1. sequential:
[17:36:43.784]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:43.784]    - tweaked: FALSE
[17:36:43.784]    - call: plan(sequential)
[17:36:43.784] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:36:43.785] plan(): Setting new future strategy stack:
[17:36:43.785] List of future strategies:
[17:36:43.785] 1. multisession:
[17:36:43.785]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:43.785]    - tweaked: FALSE
[17:36:43.785]    - call: plan(strategy)
[17:36:43.785] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:36:43.785] multisession:
[17:36:43.785] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:43.785] - tweaked: FALSE
[17:36:43.785] - call: plan(strategy)
[17:36:43.792] getGlobalsAndPackages() ...
[17:36:43.792] Not searching for globals
[17:36:43.792] - globals: [0] <none>
[17:36:43.793] getGlobalsAndPackages() ... DONE
[17:36:43.793] [local output] makeClusterPSOCK() ...
[17:36:43.840] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:36:43.842] [local output] Base port: 11552
[17:36:43.842] [local output] Getting setup options for 2 cluster nodes ...
[17:36:43.842] [local output]  - Node 1 of 2 ...
[17:36:43.843] [local output] localMachine=TRUE => revtunnel=FALSE

[17:36:43.843] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEOKIKx/worker.rank=1.parallelly.parent=29084.719c31043f21.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpEOKIKx/worker.rank=1.parallelly.parent=29084.719c31043f21.pid")'’
[17:36:44.033] - Possible to infer worker's PID: TRUE
[17:36:44.033] [local output] Rscript port: 11552

[17:36:44.033] [local output]  - Node 2 of 2 ...
[17:36:44.034] [local output] localMachine=TRUE => revtunnel=FALSE

[17:36:44.034] [local output] Rscript port: 11552

[17:36:44.035] [local output] Getting setup options for 2 cluster nodes ... done
[17:36:44.035] [local output]  - Parallel setup requested for some PSOCK nodes
[17:36:44.035] [local output] Setting up PSOCK nodes in parallel
[17:36:44.035] List of 36
[17:36:44.035]  $ worker          : chr "localhost"
[17:36:44.035]   ..- attr(*, "localhost")= logi TRUE
[17:36:44.035]  $ master          : chr "localhost"
[17:36:44.035]  $ port            : int 11552
[17:36:44.035]  $ connectTimeout  : num 120
[17:36:44.035]  $ timeout         : num 2592000
[17:36:44.035]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:36:44.035]  $ homogeneous     : logi TRUE
[17:36:44.035]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:36:44.035]  $ rscript_envs    : NULL
[17:36:44.035]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:36:44.035]  $ rscript_startup : NULL
[17:36:44.035]  $ rscript_sh      : chr "sh"
[17:36:44.035]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:36:44.035]  $ methods         : logi TRUE
[17:36:44.035]  $ socketOptions   : chr "no-delay"
[17:36:44.035]  $ useXDR          : logi FALSE
[17:36:44.035]  $ outfile         : chr "/dev/null"
[17:36:44.035]  $ renice          : int NA
[17:36:44.035]  $ rshcmd          : NULL
[17:36:44.035]  $ user            : chr(0) 
[17:36:44.035]  $ revtunnel       : logi FALSE
[17:36:44.035]  $ rshlogfile      : NULL
[17:36:44.035]  $ rshopts         : chr(0) 
[17:36:44.035]  $ rank            : int 1
[17:36:44.035]  $ manual          : logi FALSE
[17:36:44.035]  $ dryrun          : logi FALSE
[17:36:44.035]  $ quiet           : logi FALSE
[17:36:44.035]  $ setup_strategy  : chr "parallel"
[17:36:44.035]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:36:44.035]  $ pidfile         : chr "/tmp/RtmpEOKIKx/worker.rank=1.parallelly.parent=29084.719c31043f21.pid"
[17:36:44.035]  $ rshcmd_label    : NULL
[17:36:44.035]  $ rsh_call        : NULL
[17:36:44.035]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:36:44.035]  $ localMachine    : logi TRUE
[17:36:44.035]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:36:44.035]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:36:44.035]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:36:44.035]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:36:44.035]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:36:44.035]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:36:44.035]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:36:44.035]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:36:44.035]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:36:44.035]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:36:44.035]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:36:44.035]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:36:44.035]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:36:44.035]  $ arguments       :List of 28
[17:36:44.035]   ..$ worker          : chr "localhost"
[17:36:44.035]   ..$ master          : NULL
[17:36:44.035]   ..$ port            : int 11552
[17:36:44.035]   ..$ connectTimeout  : num 120
[17:36:44.035]   ..$ timeout         : num 2592000
[17:36:44.035]   ..$ rscript         : NULL
[17:36:44.035]   ..$ homogeneous     : NULL
[17:36:44.035]   ..$ rscript_args    : NULL
[17:36:44.035]   ..$ rscript_envs    : NULL
[17:36:44.035]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:36:44.035]   ..$ rscript_startup : NULL
[17:36:44.035]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:36:44.035]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:36:44.035]   ..$ methods         : logi TRUE
[17:36:44.035]   ..$ socketOptions   : chr "no-delay"
[17:36:44.035]   ..$ useXDR          : logi FALSE
[17:36:44.035]   ..$ outfile         : chr "/dev/null"
[17:36:44.035]   ..$ renice          : int NA
[17:36:44.035]   ..$ rshcmd          : NULL
[17:36:44.035]   ..$ user            : NULL
[17:36:44.035]   ..$ revtunnel       : logi NA
[17:36:44.035]   ..$ rshlogfile      : NULL
[17:36:44.035]   ..$ rshopts         : NULL
[17:36:44.035]   ..$ rank            : int 1
[17:36:44.035]   ..$ manual          : logi FALSE
[17:36:44.035]   ..$ dryrun          : logi FALSE
[17:36:44.035]   ..$ quiet           : logi FALSE
[17:36:44.035]   ..$ setup_strategy  : chr "parallel"
[17:36:44.035]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:36:44.052] [local output] System call to launch all workers:
[17:36:44.052] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEOKIKx/worker.rank=1.parallelly.parent=29084.719c31043f21.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11552 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:36:44.052] [local output] Starting PSOCK main server
[17:36:44.058] [local output] Workers launched
[17:36:44.058] [local output] Waiting for workers to connect back
[17:36:44.058]  - [local output] 0 workers out of 2 ready
[17:36:44.297]  - [local output] 0 workers out of 2 ready
[17:36:44.298]  - [local output] 1 workers out of 2 ready
[17:36:44.298]  - [local output] 2 workers out of 2 ready
[17:36:44.298] [local output] Launching of workers completed
[17:36:44.298] [local output] Collecting session information from workers
[17:36:44.299] [local output]  - Worker #1 of 2
[17:36:44.300] [local output]  - Worker #2 of 2
[17:36:44.300] [local output] makeClusterPSOCK() ... done
[17:36:44.311] Packages needed by the future expression (n = 0): <none>
[17:36:44.311] Packages needed by future strategies (n = 0): <none>
[17:36:44.312] {
[17:36:44.312]     {
[17:36:44.312]         {
[17:36:44.312]             ...future.startTime <- base::Sys.time()
[17:36:44.312]             {
[17:36:44.312]                 {
[17:36:44.312]                   {
[17:36:44.312]                     {
[17:36:44.312]                       base::local({
[17:36:44.312]                         has_future <- base::requireNamespace("future", 
[17:36:44.312]                           quietly = TRUE)
[17:36:44.312]                         if (has_future) {
[17:36:44.312]                           ns <- base::getNamespace("future")
[17:36:44.312]                           version <- ns[[".package"]][["version"]]
[17:36:44.312]                           if (is.null(version)) 
[17:36:44.312]                             version <- utils::packageVersion("future")
[17:36:44.312]                         }
[17:36:44.312]                         else {
[17:36:44.312]                           version <- NULL
[17:36:44.312]                         }
[17:36:44.312]                         if (!has_future || version < "1.8.0") {
[17:36:44.312]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:44.312]                             "", base::R.version$version.string), 
[17:36:44.312]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:44.312]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:44.312]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:44.312]                               "release", "version")], collapse = " "), 
[17:36:44.312]                             hostname = base::Sys.info()[["nodename"]])
[17:36:44.312]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:44.312]                             info)
[17:36:44.312]                           info <- base::paste(info, collapse = "; ")
[17:36:44.312]                           if (!has_future) {
[17:36:44.312]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:44.312]                               info)
[17:36:44.312]                           }
[17:36:44.312]                           else {
[17:36:44.312]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:44.312]                               info, version)
[17:36:44.312]                           }
[17:36:44.312]                           base::stop(msg)
[17:36:44.312]                         }
[17:36:44.312]                       })
[17:36:44.312]                     }
[17:36:44.312]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:44.312]                     base::options(mc.cores = 1L)
[17:36:44.312]                   }
[17:36:44.312]                   ...future.strategy.old <- future::plan("list")
[17:36:44.312]                   options(future.plan = NULL)
[17:36:44.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:44.312]                 }
[17:36:44.312]                 ...future.workdir <- getwd()
[17:36:44.312]             }
[17:36:44.312]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:44.312]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:44.312]         }
[17:36:44.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:44.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:44.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:44.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:44.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:44.312]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:44.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:44.312]             base::names(...future.oldOptions))
[17:36:44.312]     }
[17:36:44.312]     if (FALSE) {
[17:36:44.312]     }
[17:36:44.312]     else {
[17:36:44.312]         if (TRUE) {
[17:36:44.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:44.312]                 open = "w")
[17:36:44.312]         }
[17:36:44.312]         else {
[17:36:44.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:44.312]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:44.312]         }
[17:36:44.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:44.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:44.312]             base::sink(type = "output", split = FALSE)
[17:36:44.312]             base::close(...future.stdout)
[17:36:44.312]         }, add = TRUE)
[17:36:44.312]     }
[17:36:44.312]     ...future.frame <- base::sys.nframe()
[17:36:44.312]     ...future.conditions <- base::list()
[17:36:44.312]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:44.312]     if (FALSE) {
[17:36:44.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:44.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:44.312]     }
[17:36:44.312]     ...future.result <- base::tryCatch({
[17:36:44.312]         base::withCallingHandlers({
[17:36:44.312]             ...future.value <- base::withVisible(base::local({
[17:36:44.312]                 ...future.makeSendCondition <- base::local({
[17:36:44.312]                   sendCondition <- NULL
[17:36:44.312]                   function(frame = 1L) {
[17:36:44.312]                     if (is.function(sendCondition)) 
[17:36:44.312]                       return(sendCondition)
[17:36:44.312]                     ns <- getNamespace("parallel")
[17:36:44.312]                     if (exists("sendData", mode = "function", 
[17:36:44.312]                       envir = ns)) {
[17:36:44.312]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:44.312]                         envir = ns)
[17:36:44.312]                       envir <- sys.frame(frame)
[17:36:44.312]                       master <- NULL
[17:36:44.312]                       while (!identical(envir, .GlobalEnv) && 
[17:36:44.312]                         !identical(envir, emptyenv())) {
[17:36:44.312]                         if (exists("master", mode = "list", envir = envir, 
[17:36:44.312]                           inherits = FALSE)) {
[17:36:44.312]                           master <- get("master", mode = "list", 
[17:36:44.312]                             envir = envir, inherits = FALSE)
[17:36:44.312]                           if (inherits(master, c("SOCKnode", 
[17:36:44.312]                             "SOCK0node"))) {
[17:36:44.312]                             sendCondition <<- function(cond) {
[17:36:44.312]                               data <- list(type = "VALUE", value = cond, 
[17:36:44.312]                                 success = TRUE)
[17:36:44.312]                               parallel_sendData(master, data)
[17:36:44.312]                             }
[17:36:44.312]                             return(sendCondition)
[17:36:44.312]                           }
[17:36:44.312]                         }
[17:36:44.312]                         frame <- frame + 1L
[17:36:44.312]                         envir <- sys.frame(frame)
[17:36:44.312]                       }
[17:36:44.312]                     }
[17:36:44.312]                     sendCondition <<- function(cond) NULL
[17:36:44.312]                   }
[17:36:44.312]                 })
[17:36:44.312]                 withCallingHandlers({
[17:36:44.312]                   NA
[17:36:44.312]                 }, immediateCondition = function(cond) {
[17:36:44.312]                   sendCondition <- ...future.makeSendCondition()
[17:36:44.312]                   sendCondition(cond)
[17:36:44.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.312]                   {
[17:36:44.312]                     inherits <- base::inherits
[17:36:44.312]                     invokeRestart <- base::invokeRestart
[17:36:44.312]                     is.null <- base::is.null
[17:36:44.312]                     muffled <- FALSE
[17:36:44.312]                     if (inherits(cond, "message")) {
[17:36:44.312]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:44.312]                       if (muffled) 
[17:36:44.312]                         invokeRestart("muffleMessage")
[17:36:44.312]                     }
[17:36:44.312]                     else if (inherits(cond, "warning")) {
[17:36:44.312]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:44.312]                       if (muffled) 
[17:36:44.312]                         invokeRestart("muffleWarning")
[17:36:44.312]                     }
[17:36:44.312]                     else if (inherits(cond, "condition")) {
[17:36:44.312]                       if (!is.null(pattern)) {
[17:36:44.312]                         computeRestarts <- base::computeRestarts
[17:36:44.312]                         grepl <- base::grepl
[17:36:44.312]                         restarts <- computeRestarts(cond)
[17:36:44.312]                         for (restart in restarts) {
[17:36:44.312]                           name <- restart$name
[17:36:44.312]                           if (is.null(name)) 
[17:36:44.312]                             next
[17:36:44.312]                           if (!grepl(pattern, name)) 
[17:36:44.312]                             next
[17:36:44.312]                           invokeRestart(restart)
[17:36:44.312]                           muffled <- TRUE
[17:36:44.312]                           break
[17:36:44.312]                         }
[17:36:44.312]                       }
[17:36:44.312]                     }
[17:36:44.312]                     invisible(muffled)
[17:36:44.312]                   }
[17:36:44.312]                   muffleCondition(cond)
[17:36:44.312]                 })
[17:36:44.312]             }))
[17:36:44.312]             future::FutureResult(value = ...future.value$value, 
[17:36:44.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.312]                   ...future.rng), globalenv = if (FALSE) 
[17:36:44.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:44.312]                     ...future.globalenv.names))
[17:36:44.312]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:44.312]         }, condition = base::local({
[17:36:44.312]             c <- base::c
[17:36:44.312]             inherits <- base::inherits
[17:36:44.312]             invokeRestart <- base::invokeRestart
[17:36:44.312]             length <- base::length
[17:36:44.312]             list <- base::list
[17:36:44.312]             seq.int <- base::seq.int
[17:36:44.312]             signalCondition <- base::signalCondition
[17:36:44.312]             sys.calls <- base::sys.calls
[17:36:44.312]             `[[` <- base::`[[`
[17:36:44.312]             `+` <- base::`+`
[17:36:44.312]             `<<-` <- base::`<<-`
[17:36:44.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:44.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:44.312]                   3L)]
[17:36:44.312]             }
[17:36:44.312]             function(cond) {
[17:36:44.312]                 is_error <- inherits(cond, "error")
[17:36:44.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:44.312]                   NULL)
[17:36:44.312]                 if (is_error) {
[17:36:44.312]                   sessionInformation <- function() {
[17:36:44.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:44.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:44.312]                       search = base::search(), system = base::Sys.info())
[17:36:44.312]                   }
[17:36:44.312]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:44.312]                     cond$call), session = sessionInformation(), 
[17:36:44.312]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:44.312]                   signalCondition(cond)
[17:36:44.312]                 }
[17:36:44.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:44.312]                 "immediateCondition"))) {
[17:36:44.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:44.312]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:44.312]                   if (TRUE && !signal) {
[17:36:44.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.312]                     {
[17:36:44.312]                       inherits <- base::inherits
[17:36:44.312]                       invokeRestart <- base::invokeRestart
[17:36:44.312]                       is.null <- base::is.null
[17:36:44.312]                       muffled <- FALSE
[17:36:44.312]                       if (inherits(cond, "message")) {
[17:36:44.312]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.312]                         if (muffled) 
[17:36:44.312]                           invokeRestart("muffleMessage")
[17:36:44.312]                       }
[17:36:44.312]                       else if (inherits(cond, "warning")) {
[17:36:44.312]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.312]                         if (muffled) 
[17:36:44.312]                           invokeRestart("muffleWarning")
[17:36:44.312]                       }
[17:36:44.312]                       else if (inherits(cond, "condition")) {
[17:36:44.312]                         if (!is.null(pattern)) {
[17:36:44.312]                           computeRestarts <- base::computeRestarts
[17:36:44.312]                           grepl <- base::grepl
[17:36:44.312]                           restarts <- computeRestarts(cond)
[17:36:44.312]                           for (restart in restarts) {
[17:36:44.312]                             name <- restart$name
[17:36:44.312]                             if (is.null(name)) 
[17:36:44.312]                               next
[17:36:44.312]                             if (!grepl(pattern, name)) 
[17:36:44.312]                               next
[17:36:44.312]                             invokeRestart(restart)
[17:36:44.312]                             muffled <- TRUE
[17:36:44.312]                             break
[17:36:44.312]                           }
[17:36:44.312]                         }
[17:36:44.312]                       }
[17:36:44.312]                       invisible(muffled)
[17:36:44.312]                     }
[17:36:44.312]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.312]                   }
[17:36:44.312]                 }
[17:36:44.312]                 else {
[17:36:44.312]                   if (TRUE) {
[17:36:44.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.312]                     {
[17:36:44.312]                       inherits <- base::inherits
[17:36:44.312]                       invokeRestart <- base::invokeRestart
[17:36:44.312]                       is.null <- base::is.null
[17:36:44.312]                       muffled <- FALSE
[17:36:44.312]                       if (inherits(cond, "message")) {
[17:36:44.312]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.312]                         if (muffled) 
[17:36:44.312]                           invokeRestart("muffleMessage")
[17:36:44.312]                       }
[17:36:44.312]                       else if (inherits(cond, "warning")) {
[17:36:44.312]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.312]                         if (muffled) 
[17:36:44.312]                           invokeRestart("muffleWarning")
[17:36:44.312]                       }
[17:36:44.312]                       else if (inherits(cond, "condition")) {
[17:36:44.312]                         if (!is.null(pattern)) {
[17:36:44.312]                           computeRestarts <- base::computeRestarts
[17:36:44.312]                           grepl <- base::grepl
[17:36:44.312]                           restarts <- computeRestarts(cond)
[17:36:44.312]                           for (restart in restarts) {
[17:36:44.312]                             name <- restart$name
[17:36:44.312]                             if (is.null(name)) 
[17:36:44.312]                               next
[17:36:44.312]                             if (!grepl(pattern, name)) 
[17:36:44.312]                               next
[17:36:44.312]                             invokeRestart(restart)
[17:36:44.312]                             muffled <- TRUE
[17:36:44.312]                             break
[17:36:44.312]                           }
[17:36:44.312]                         }
[17:36:44.312]                       }
[17:36:44.312]                       invisible(muffled)
[17:36:44.312]                     }
[17:36:44.312]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.312]                   }
[17:36:44.312]                 }
[17:36:44.312]             }
[17:36:44.312]         }))
[17:36:44.312]     }, error = function(ex) {
[17:36:44.312]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:44.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.312]                 ...future.rng), started = ...future.startTime, 
[17:36:44.312]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:44.312]             version = "1.8"), class = "FutureResult")
[17:36:44.312]     }, finally = {
[17:36:44.312]         if (!identical(...future.workdir, getwd())) 
[17:36:44.312]             setwd(...future.workdir)
[17:36:44.312]         {
[17:36:44.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:44.312]                 ...future.oldOptions$nwarnings <- NULL
[17:36:44.312]             }
[17:36:44.312]             base::options(...future.oldOptions)
[17:36:44.312]             if (.Platform$OS.type == "windows") {
[17:36:44.312]                 old_names <- names(...future.oldEnvVars)
[17:36:44.312]                 envs <- base::Sys.getenv()
[17:36:44.312]                 names <- names(envs)
[17:36:44.312]                 common <- intersect(names, old_names)
[17:36:44.312]                 added <- setdiff(names, old_names)
[17:36:44.312]                 removed <- setdiff(old_names, names)
[17:36:44.312]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:44.312]                   envs[common]]
[17:36:44.312]                 NAMES <- toupper(changed)
[17:36:44.312]                 args <- list()
[17:36:44.312]                 for (kk in seq_along(NAMES)) {
[17:36:44.312]                   name <- changed[[kk]]
[17:36:44.312]                   NAME <- NAMES[[kk]]
[17:36:44.312]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.312]                     next
[17:36:44.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.312]                 }
[17:36:44.312]                 NAMES <- toupper(added)
[17:36:44.312]                 for (kk in seq_along(NAMES)) {
[17:36:44.312]                   name <- added[[kk]]
[17:36:44.312]                   NAME <- NAMES[[kk]]
[17:36:44.312]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.312]                     next
[17:36:44.312]                   args[[name]] <- ""
[17:36:44.312]                 }
[17:36:44.312]                 NAMES <- toupper(removed)
[17:36:44.312]                 for (kk in seq_along(NAMES)) {
[17:36:44.312]                   name <- removed[[kk]]
[17:36:44.312]                   NAME <- NAMES[[kk]]
[17:36:44.312]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.312]                     next
[17:36:44.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.312]                 }
[17:36:44.312]                 if (length(args) > 0) 
[17:36:44.312]                   base::do.call(base::Sys.setenv, args = args)
[17:36:44.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:44.312]             }
[17:36:44.312]             else {
[17:36:44.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:44.312]             }
[17:36:44.312]             {
[17:36:44.312]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:44.312]                   0L) {
[17:36:44.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:44.312]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:44.312]                   base::options(opts)
[17:36:44.312]                 }
[17:36:44.312]                 {
[17:36:44.312]                   {
[17:36:44.312]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:44.312]                     NULL
[17:36:44.312]                   }
[17:36:44.312]                   options(future.plan = NULL)
[17:36:44.312]                   if (is.na(NA_character_)) 
[17:36:44.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:44.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:44.312]                     .init = FALSE)
[17:36:44.312]                 }
[17:36:44.312]             }
[17:36:44.312]         }
[17:36:44.312]     })
[17:36:44.312]     if (TRUE) {
[17:36:44.312]         base::sink(type = "output", split = FALSE)
[17:36:44.312]         if (TRUE) {
[17:36:44.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:44.312]         }
[17:36:44.312]         else {
[17:36:44.312]             ...future.result["stdout"] <- base::list(NULL)
[17:36:44.312]         }
[17:36:44.312]         base::close(...future.stdout)
[17:36:44.312]         ...future.stdout <- NULL
[17:36:44.312]     }
[17:36:44.312]     ...future.result$conditions <- ...future.conditions
[17:36:44.312]     ...future.result$finished <- base::Sys.time()
[17:36:44.312]     ...future.result
[17:36:44.312] }
[17:36:44.364] MultisessionFuture started
[17:36:44.364] result() for ClusterFuture ...
[17:36:44.365] receiveMessageFromWorker() for ClusterFuture ...
[17:36:44.365] - Validating connection of MultisessionFuture
[17:36:44.397] - received message: FutureResult
[17:36:44.397] - Received FutureResult
[17:36:44.397] - Erased future from FutureRegistry
[17:36:44.397] result() for ClusterFuture ...
[17:36:44.397] - result already collected: FutureResult
[17:36:44.398] result() for ClusterFuture ... done
[17:36:44.398] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:44.398] result() for ClusterFuture ... done
[17:36:44.398] result() for ClusterFuture ...
[17:36:44.398] - result already collected: FutureResult
[17:36:44.398] result() for ClusterFuture ... done
[17:36:44.398] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:36:44.402] plan(): nbrOfWorkers() = 2
[17:36:44.402] future_lapply() ...
[17:36:44.406] Number of chunks: 2
[17:36:44.407] getGlobalsAndPackagesXApply() ...
[17:36:44.407]  - future.globals: TRUE
[17:36:44.407] getGlobalsAndPackages() ...
[17:36:44.407] Searching for globals...
[17:36:44.408] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:44.408] Searching for globals ... DONE
[17:36:44.409] Resolving globals: FALSE
[17:36:44.409] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:44.409] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:44.409] - globals: [1] ‘FUN’
[17:36:44.410] 
[17:36:44.410] getGlobalsAndPackages() ... DONE
[17:36:44.410]  - globals found/used: [n=1] ‘FUN’
[17:36:44.410]  - needed namespaces: [n=0] 
[17:36:44.410] Finding globals ... DONE
[17:36:44.410]  - use_args: TRUE
[17:36:44.410]  - Getting '...' globals ...
[17:36:44.411] resolve() on list ...
[17:36:44.411]  recursive: 0
[17:36:44.411]  length: 1
[17:36:44.411]  elements: ‘...’
[17:36:44.411]  length: 0 (resolved future 1)
[17:36:44.411] resolve() on list ... DONE
[17:36:44.411]    - '...' content: [n=0] 
[17:36:44.412] List of 1
[17:36:44.412]  $ ...: list()
[17:36:44.412]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:44.412]  - attr(*, "where")=List of 1
[17:36:44.412]   ..$ ...:<environment: 0x5655059eb8c8> 
[17:36:44.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:44.412]  - attr(*, "resolved")= logi TRUE
[17:36:44.412]  - attr(*, "total_size")= num NA
[17:36:44.415]  - Getting '...' globals ... DONE
[17:36:44.415] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:44.415] List of 2
[17:36:44.415]  $ ...future.FUN:function (x, ...)  
[17:36:44.415]  $ ...          : list()
[17:36:44.415]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:44.415]  - attr(*, "where")=List of 2
[17:36:44.415]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:44.415]   ..$ ...          :<environment: 0x5655059eb8c8> 
[17:36:44.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:44.415]  - attr(*, "resolved")= logi FALSE
[17:36:44.415]  - attr(*, "total_size")= num 1240
[17:36:44.418] Packages to be attached in all futures: [n=0] 
[17:36:44.418] getGlobalsAndPackagesXApply() ... DONE
[17:36:44.419] Number of futures (= number of chunks): 2
[17:36:44.419] Launching 2 futures (chunks) ...
[17:36:44.419] Chunk #1 of 2 ...
[17:36:44.419]  - Finding globals in 'X' for chunk #1 ...
[17:36:44.419] getGlobalsAndPackages() ...
[17:36:44.419] Searching for globals...
[17:36:44.420] 
[17:36:44.420] Searching for globals ... DONE
[17:36:44.420] - globals: [0] <none>
[17:36:44.420] getGlobalsAndPackages() ... DONE
[17:36:44.420]    + additional globals found: [n=0] 
[17:36:44.420]    + additional namespaces needed: [n=0] 
[17:36:44.420]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:44.420]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:44.420]  - seeds: <none>
[17:36:44.421]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.421] getGlobalsAndPackages() ...
[17:36:44.421] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.421] Resolving globals: FALSE
[17:36:44.421] Tweak future expression to call with '...' arguments ...
[17:36:44.421] {
[17:36:44.421]     do.call(function(...) {
[17:36:44.421]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.421]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.421]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.421]             on.exit(options(oopts), add = TRUE)
[17:36:44.421]         }
[17:36:44.421]         {
[17:36:44.421]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.421]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.421]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.421]             })
[17:36:44.421]         }
[17:36:44.421]     }, args = future.call.arguments)
[17:36:44.421] }
[17:36:44.422] Tweak future expression to call with '...' arguments ... DONE
[17:36:44.422] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.422] 
[17:36:44.422] getGlobalsAndPackages() ... DONE
[17:36:44.423] run() for ‘Future’ ...
[17:36:44.423] - state: ‘created’
[17:36:44.423] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:44.437] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:44.437]   - Field: ‘node’
[17:36:44.437]   - Field: ‘label’
[17:36:44.438]   - Field: ‘local’
[17:36:44.438]   - Field: ‘owner’
[17:36:44.438]   - Field: ‘envir’
[17:36:44.438]   - Field: ‘workers’
[17:36:44.438]   - Field: ‘packages’
[17:36:44.438]   - Field: ‘gc’
[17:36:44.438]   - Field: ‘conditions’
[17:36:44.438]   - Field: ‘persistent’
[17:36:44.438]   - Field: ‘expr’
[17:36:44.438]   - Field: ‘uuid’
[17:36:44.439]   - Field: ‘seed’
[17:36:44.439]   - Field: ‘version’
[17:36:44.439]   - Field: ‘result’
[17:36:44.439]   - Field: ‘asynchronous’
[17:36:44.439]   - Field: ‘calls’
[17:36:44.439]   - Field: ‘globals’
[17:36:44.439]   - Field: ‘stdout’
[17:36:44.439]   - Field: ‘earlySignal’
[17:36:44.439]   - Field: ‘lazy’
[17:36:44.440]   - Field: ‘state’
[17:36:44.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:44.440] - Launch lazy future ...
[17:36:44.440] Packages needed by the future expression (n = 0): <none>
[17:36:44.440] Packages needed by future strategies (n = 0): <none>
[17:36:44.441] {
[17:36:44.441]     {
[17:36:44.441]         {
[17:36:44.441]             ...future.startTime <- base::Sys.time()
[17:36:44.441]             {
[17:36:44.441]                 {
[17:36:44.441]                   {
[17:36:44.441]                     {
[17:36:44.441]                       base::local({
[17:36:44.441]                         has_future <- base::requireNamespace("future", 
[17:36:44.441]                           quietly = TRUE)
[17:36:44.441]                         if (has_future) {
[17:36:44.441]                           ns <- base::getNamespace("future")
[17:36:44.441]                           version <- ns[[".package"]][["version"]]
[17:36:44.441]                           if (is.null(version)) 
[17:36:44.441]                             version <- utils::packageVersion("future")
[17:36:44.441]                         }
[17:36:44.441]                         else {
[17:36:44.441]                           version <- NULL
[17:36:44.441]                         }
[17:36:44.441]                         if (!has_future || version < "1.8.0") {
[17:36:44.441]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:44.441]                             "", base::R.version$version.string), 
[17:36:44.441]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:44.441]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:44.441]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:44.441]                               "release", "version")], collapse = " "), 
[17:36:44.441]                             hostname = base::Sys.info()[["nodename"]])
[17:36:44.441]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:44.441]                             info)
[17:36:44.441]                           info <- base::paste(info, collapse = "; ")
[17:36:44.441]                           if (!has_future) {
[17:36:44.441]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:44.441]                               info)
[17:36:44.441]                           }
[17:36:44.441]                           else {
[17:36:44.441]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:44.441]                               info, version)
[17:36:44.441]                           }
[17:36:44.441]                           base::stop(msg)
[17:36:44.441]                         }
[17:36:44.441]                       })
[17:36:44.441]                     }
[17:36:44.441]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:44.441]                     base::options(mc.cores = 1L)
[17:36:44.441]                   }
[17:36:44.441]                   ...future.strategy.old <- future::plan("list")
[17:36:44.441]                   options(future.plan = NULL)
[17:36:44.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:44.441]                 }
[17:36:44.441]                 ...future.workdir <- getwd()
[17:36:44.441]             }
[17:36:44.441]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:44.441]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:44.441]         }
[17:36:44.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:44.441]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:44.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:44.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:44.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:44.441]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:44.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:44.441]             base::names(...future.oldOptions))
[17:36:44.441]     }
[17:36:44.441]     if (FALSE) {
[17:36:44.441]     }
[17:36:44.441]     else {
[17:36:44.441]         if (TRUE) {
[17:36:44.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:44.441]                 open = "w")
[17:36:44.441]         }
[17:36:44.441]         else {
[17:36:44.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:44.441]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:44.441]         }
[17:36:44.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:44.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:44.441]             base::sink(type = "output", split = FALSE)
[17:36:44.441]             base::close(...future.stdout)
[17:36:44.441]         }, add = TRUE)
[17:36:44.441]     }
[17:36:44.441]     ...future.frame <- base::sys.nframe()
[17:36:44.441]     ...future.conditions <- base::list()
[17:36:44.441]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:44.441]     if (FALSE) {
[17:36:44.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:44.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:44.441]     }
[17:36:44.441]     ...future.result <- base::tryCatch({
[17:36:44.441]         base::withCallingHandlers({
[17:36:44.441]             ...future.value <- base::withVisible(base::local({
[17:36:44.441]                 ...future.makeSendCondition <- base::local({
[17:36:44.441]                   sendCondition <- NULL
[17:36:44.441]                   function(frame = 1L) {
[17:36:44.441]                     if (is.function(sendCondition)) 
[17:36:44.441]                       return(sendCondition)
[17:36:44.441]                     ns <- getNamespace("parallel")
[17:36:44.441]                     if (exists("sendData", mode = "function", 
[17:36:44.441]                       envir = ns)) {
[17:36:44.441]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:44.441]                         envir = ns)
[17:36:44.441]                       envir <- sys.frame(frame)
[17:36:44.441]                       master <- NULL
[17:36:44.441]                       while (!identical(envir, .GlobalEnv) && 
[17:36:44.441]                         !identical(envir, emptyenv())) {
[17:36:44.441]                         if (exists("master", mode = "list", envir = envir, 
[17:36:44.441]                           inherits = FALSE)) {
[17:36:44.441]                           master <- get("master", mode = "list", 
[17:36:44.441]                             envir = envir, inherits = FALSE)
[17:36:44.441]                           if (inherits(master, c("SOCKnode", 
[17:36:44.441]                             "SOCK0node"))) {
[17:36:44.441]                             sendCondition <<- function(cond) {
[17:36:44.441]                               data <- list(type = "VALUE", value = cond, 
[17:36:44.441]                                 success = TRUE)
[17:36:44.441]                               parallel_sendData(master, data)
[17:36:44.441]                             }
[17:36:44.441]                             return(sendCondition)
[17:36:44.441]                           }
[17:36:44.441]                         }
[17:36:44.441]                         frame <- frame + 1L
[17:36:44.441]                         envir <- sys.frame(frame)
[17:36:44.441]                       }
[17:36:44.441]                     }
[17:36:44.441]                     sendCondition <<- function(cond) NULL
[17:36:44.441]                   }
[17:36:44.441]                 })
[17:36:44.441]                 withCallingHandlers({
[17:36:44.441]                   {
[17:36:44.441]                     do.call(function(...) {
[17:36:44.441]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.441]                       if (!identical(...future.globals.maxSize.org, 
[17:36:44.441]                         ...future.globals.maxSize)) {
[17:36:44.441]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.441]                         on.exit(options(oopts), add = TRUE)
[17:36:44.441]                       }
[17:36:44.441]                       {
[17:36:44.441]                         lapply(seq_along(...future.elements_ii), 
[17:36:44.441]                           FUN = function(jj) {
[17:36:44.441]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.441]                             ...future.FUN(...future.X_jj, ...)
[17:36:44.441]                           })
[17:36:44.441]                       }
[17:36:44.441]                     }, args = future.call.arguments)
[17:36:44.441]                   }
[17:36:44.441]                 }, immediateCondition = function(cond) {
[17:36:44.441]                   sendCondition <- ...future.makeSendCondition()
[17:36:44.441]                   sendCondition(cond)
[17:36:44.441]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.441]                   {
[17:36:44.441]                     inherits <- base::inherits
[17:36:44.441]                     invokeRestart <- base::invokeRestart
[17:36:44.441]                     is.null <- base::is.null
[17:36:44.441]                     muffled <- FALSE
[17:36:44.441]                     if (inherits(cond, "message")) {
[17:36:44.441]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:44.441]                       if (muffled) 
[17:36:44.441]                         invokeRestart("muffleMessage")
[17:36:44.441]                     }
[17:36:44.441]                     else if (inherits(cond, "warning")) {
[17:36:44.441]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:44.441]                       if (muffled) 
[17:36:44.441]                         invokeRestart("muffleWarning")
[17:36:44.441]                     }
[17:36:44.441]                     else if (inherits(cond, "condition")) {
[17:36:44.441]                       if (!is.null(pattern)) {
[17:36:44.441]                         computeRestarts <- base::computeRestarts
[17:36:44.441]                         grepl <- base::grepl
[17:36:44.441]                         restarts <- computeRestarts(cond)
[17:36:44.441]                         for (restart in restarts) {
[17:36:44.441]                           name <- restart$name
[17:36:44.441]                           if (is.null(name)) 
[17:36:44.441]                             next
[17:36:44.441]                           if (!grepl(pattern, name)) 
[17:36:44.441]                             next
[17:36:44.441]                           invokeRestart(restart)
[17:36:44.441]                           muffled <- TRUE
[17:36:44.441]                           break
[17:36:44.441]                         }
[17:36:44.441]                       }
[17:36:44.441]                     }
[17:36:44.441]                     invisible(muffled)
[17:36:44.441]                   }
[17:36:44.441]                   muffleCondition(cond)
[17:36:44.441]                 })
[17:36:44.441]             }))
[17:36:44.441]             future::FutureResult(value = ...future.value$value, 
[17:36:44.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.441]                   ...future.rng), globalenv = if (FALSE) 
[17:36:44.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:44.441]                     ...future.globalenv.names))
[17:36:44.441]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:44.441]         }, condition = base::local({
[17:36:44.441]             c <- base::c
[17:36:44.441]             inherits <- base::inherits
[17:36:44.441]             invokeRestart <- base::invokeRestart
[17:36:44.441]             length <- base::length
[17:36:44.441]             list <- base::list
[17:36:44.441]             seq.int <- base::seq.int
[17:36:44.441]             signalCondition <- base::signalCondition
[17:36:44.441]             sys.calls <- base::sys.calls
[17:36:44.441]             `[[` <- base::`[[`
[17:36:44.441]             `+` <- base::`+`
[17:36:44.441]             `<<-` <- base::`<<-`
[17:36:44.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:44.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:44.441]                   3L)]
[17:36:44.441]             }
[17:36:44.441]             function(cond) {
[17:36:44.441]                 is_error <- inherits(cond, "error")
[17:36:44.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:44.441]                   NULL)
[17:36:44.441]                 if (is_error) {
[17:36:44.441]                   sessionInformation <- function() {
[17:36:44.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:44.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:44.441]                       search = base::search(), system = base::Sys.info())
[17:36:44.441]                   }
[17:36:44.441]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:44.441]                     cond$call), session = sessionInformation(), 
[17:36:44.441]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:44.441]                   signalCondition(cond)
[17:36:44.441]                 }
[17:36:44.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:44.441]                 "immediateCondition"))) {
[17:36:44.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:44.441]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:44.441]                   if (TRUE && !signal) {
[17:36:44.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.441]                     {
[17:36:44.441]                       inherits <- base::inherits
[17:36:44.441]                       invokeRestart <- base::invokeRestart
[17:36:44.441]                       is.null <- base::is.null
[17:36:44.441]                       muffled <- FALSE
[17:36:44.441]                       if (inherits(cond, "message")) {
[17:36:44.441]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.441]                         if (muffled) 
[17:36:44.441]                           invokeRestart("muffleMessage")
[17:36:44.441]                       }
[17:36:44.441]                       else if (inherits(cond, "warning")) {
[17:36:44.441]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.441]                         if (muffled) 
[17:36:44.441]                           invokeRestart("muffleWarning")
[17:36:44.441]                       }
[17:36:44.441]                       else if (inherits(cond, "condition")) {
[17:36:44.441]                         if (!is.null(pattern)) {
[17:36:44.441]                           computeRestarts <- base::computeRestarts
[17:36:44.441]                           grepl <- base::grepl
[17:36:44.441]                           restarts <- computeRestarts(cond)
[17:36:44.441]                           for (restart in restarts) {
[17:36:44.441]                             name <- restart$name
[17:36:44.441]                             if (is.null(name)) 
[17:36:44.441]                               next
[17:36:44.441]                             if (!grepl(pattern, name)) 
[17:36:44.441]                               next
[17:36:44.441]                             invokeRestart(restart)
[17:36:44.441]                             muffled <- TRUE
[17:36:44.441]                             break
[17:36:44.441]                           }
[17:36:44.441]                         }
[17:36:44.441]                       }
[17:36:44.441]                       invisible(muffled)
[17:36:44.441]                     }
[17:36:44.441]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.441]                   }
[17:36:44.441]                 }
[17:36:44.441]                 else {
[17:36:44.441]                   if (TRUE) {
[17:36:44.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.441]                     {
[17:36:44.441]                       inherits <- base::inherits
[17:36:44.441]                       invokeRestart <- base::invokeRestart
[17:36:44.441]                       is.null <- base::is.null
[17:36:44.441]                       muffled <- FALSE
[17:36:44.441]                       if (inherits(cond, "message")) {
[17:36:44.441]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.441]                         if (muffled) 
[17:36:44.441]                           invokeRestart("muffleMessage")
[17:36:44.441]                       }
[17:36:44.441]                       else if (inherits(cond, "warning")) {
[17:36:44.441]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.441]                         if (muffled) 
[17:36:44.441]                           invokeRestart("muffleWarning")
[17:36:44.441]                       }
[17:36:44.441]                       else if (inherits(cond, "condition")) {
[17:36:44.441]                         if (!is.null(pattern)) {
[17:36:44.441]                           computeRestarts <- base::computeRestarts
[17:36:44.441]                           grepl <- base::grepl
[17:36:44.441]                           restarts <- computeRestarts(cond)
[17:36:44.441]                           for (restart in restarts) {
[17:36:44.441]                             name <- restart$name
[17:36:44.441]                             if (is.null(name)) 
[17:36:44.441]                               next
[17:36:44.441]                             if (!grepl(pattern, name)) 
[17:36:44.441]                               next
[17:36:44.441]                             invokeRestart(restart)
[17:36:44.441]                             muffled <- TRUE
[17:36:44.441]                             break
[17:36:44.441]                           }
[17:36:44.441]                         }
[17:36:44.441]                       }
[17:36:44.441]                       invisible(muffled)
[17:36:44.441]                     }
[17:36:44.441]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.441]                   }
[17:36:44.441]                 }
[17:36:44.441]             }
[17:36:44.441]         }))
[17:36:44.441]     }, error = function(ex) {
[17:36:44.441]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:44.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.441]                 ...future.rng), started = ...future.startTime, 
[17:36:44.441]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:44.441]             version = "1.8"), class = "FutureResult")
[17:36:44.441]     }, finally = {
[17:36:44.441]         if (!identical(...future.workdir, getwd())) 
[17:36:44.441]             setwd(...future.workdir)
[17:36:44.441]         {
[17:36:44.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:44.441]                 ...future.oldOptions$nwarnings <- NULL
[17:36:44.441]             }
[17:36:44.441]             base::options(...future.oldOptions)
[17:36:44.441]             if (.Platform$OS.type == "windows") {
[17:36:44.441]                 old_names <- names(...future.oldEnvVars)
[17:36:44.441]                 envs <- base::Sys.getenv()
[17:36:44.441]                 names <- names(envs)
[17:36:44.441]                 common <- intersect(names, old_names)
[17:36:44.441]                 added <- setdiff(names, old_names)
[17:36:44.441]                 removed <- setdiff(old_names, names)
[17:36:44.441]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:44.441]                   envs[common]]
[17:36:44.441]                 NAMES <- toupper(changed)
[17:36:44.441]                 args <- list()
[17:36:44.441]                 for (kk in seq_along(NAMES)) {
[17:36:44.441]                   name <- changed[[kk]]
[17:36:44.441]                   NAME <- NAMES[[kk]]
[17:36:44.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.441]                     next
[17:36:44.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.441]                 }
[17:36:44.441]                 NAMES <- toupper(added)
[17:36:44.441]                 for (kk in seq_along(NAMES)) {
[17:36:44.441]                   name <- added[[kk]]
[17:36:44.441]                   NAME <- NAMES[[kk]]
[17:36:44.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.441]                     next
[17:36:44.441]                   args[[name]] <- ""
[17:36:44.441]                 }
[17:36:44.441]                 NAMES <- toupper(removed)
[17:36:44.441]                 for (kk in seq_along(NAMES)) {
[17:36:44.441]                   name <- removed[[kk]]
[17:36:44.441]                   NAME <- NAMES[[kk]]
[17:36:44.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.441]                     next
[17:36:44.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.441]                 }
[17:36:44.441]                 if (length(args) > 0) 
[17:36:44.441]                   base::do.call(base::Sys.setenv, args = args)
[17:36:44.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:44.441]             }
[17:36:44.441]             else {
[17:36:44.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:44.441]             }
[17:36:44.441]             {
[17:36:44.441]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:44.441]                   0L) {
[17:36:44.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:44.441]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:44.441]                   base::options(opts)
[17:36:44.441]                 }
[17:36:44.441]                 {
[17:36:44.441]                   {
[17:36:44.441]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:44.441]                     NULL
[17:36:44.441]                   }
[17:36:44.441]                   options(future.plan = NULL)
[17:36:44.441]                   if (is.na(NA_character_)) 
[17:36:44.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:44.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:44.441]                     .init = FALSE)
[17:36:44.441]                 }
[17:36:44.441]             }
[17:36:44.441]         }
[17:36:44.441]     })
[17:36:44.441]     if (TRUE) {
[17:36:44.441]         base::sink(type = "output", split = FALSE)
[17:36:44.441]         if (TRUE) {
[17:36:44.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:44.441]         }
[17:36:44.441]         else {
[17:36:44.441]             ...future.result["stdout"] <- base::list(NULL)
[17:36:44.441]         }
[17:36:44.441]         base::close(...future.stdout)
[17:36:44.441]         ...future.stdout <- NULL
[17:36:44.441]     }
[17:36:44.441]     ...future.result$conditions <- ...future.conditions
[17:36:44.441]     ...future.result$finished <- base::Sys.time()
[17:36:44.441]     ...future.result
[17:36:44.441] }
[17:36:44.444] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:36:44.444] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:36:44.445] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:36:44.445] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:44.445] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:44.446] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:36:44.446] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:36:44.446] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:44.447] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:44.447] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:36:44.447] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:36:44.447] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:36:44.448] MultisessionFuture started
[17:36:44.448] - Launch lazy future ... done
[17:36:44.448] run() for ‘MultisessionFuture’ ... done
[17:36:44.448] Created future:
[17:36:44.449] MultisessionFuture:
[17:36:44.449] Label: ‘future_eapply-1’
[17:36:44.449] Expression:
[17:36:44.449] {
[17:36:44.449]     do.call(function(...) {
[17:36:44.449]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.449]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.449]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.449]             on.exit(options(oopts), add = TRUE)
[17:36:44.449]         }
[17:36:44.449]         {
[17:36:44.449]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.449]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.449]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.449]             })
[17:36:44.449]         }
[17:36:44.449]     }, args = future.call.arguments)
[17:36:44.449] }
[17:36:44.449] Lazy evaluation: FALSE
[17:36:44.449] Asynchronous evaluation: TRUE
[17:36:44.449] Local evaluation: TRUE
[17:36:44.449] Environment: R_GlobalEnv
[17:36:44.449] Capture standard output: TRUE
[17:36:44.449] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:44.449] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:44.449] Packages: <none>
[17:36:44.449] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:44.449] Resolved: FALSE
[17:36:44.449] Value: <not collected>
[17:36:44.449] Conditions captured: <none>
[17:36:44.449] Early signaling: FALSE
[17:36:44.449] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:44.449] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.461] Chunk #1 of 2 ... DONE
[17:36:44.461] Chunk #2 of 2 ...
[17:36:44.461]  - Finding globals in 'X' for chunk #2 ...
[17:36:44.461] getGlobalsAndPackages() ...
[17:36:44.461] Searching for globals...
[17:36:44.462] 
[17:36:44.462] Searching for globals ... DONE
[17:36:44.462] - globals: [0] <none>
[17:36:44.462] getGlobalsAndPackages() ... DONE
[17:36:44.462]    + additional globals found: [n=0] 
[17:36:44.462]    + additional namespaces needed: [n=0] 
[17:36:44.462]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:44.462]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:44.462]  - seeds: <none>
[17:36:44.463]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.463] getGlobalsAndPackages() ...
[17:36:44.463] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.463] Resolving globals: FALSE
[17:36:44.463] Tweak future expression to call with '...' arguments ...
[17:36:44.463] {
[17:36:44.463]     do.call(function(...) {
[17:36:44.463]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.463]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.463]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.463]             on.exit(options(oopts), add = TRUE)
[17:36:44.463]         }
[17:36:44.463]         {
[17:36:44.463]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.463]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.463]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.463]             })
[17:36:44.463]         }
[17:36:44.463]     }, args = future.call.arguments)
[17:36:44.463] }
[17:36:44.463] Tweak future expression to call with '...' arguments ... DONE
[17:36:44.464] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.464] 
[17:36:44.464] getGlobalsAndPackages() ... DONE
[17:36:44.465] run() for ‘Future’ ...
[17:36:44.465] - state: ‘created’
[17:36:44.465] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:44.479] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.479] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:44.480]   - Field: ‘node’
[17:36:44.480]   - Field: ‘label’
[17:36:44.480]   - Field: ‘local’
[17:36:44.480]   - Field: ‘owner’
[17:36:44.480]   - Field: ‘envir’
[17:36:44.480]   - Field: ‘workers’
[17:36:44.480]   - Field: ‘packages’
[17:36:44.480]   - Field: ‘gc’
[17:36:44.480]   - Field: ‘conditions’
[17:36:44.481]   - Field: ‘persistent’
[17:36:44.481]   - Field: ‘expr’
[17:36:44.481]   - Field: ‘uuid’
[17:36:44.481]   - Field: ‘seed’
[17:36:44.481]   - Field: ‘version’
[17:36:44.481]   - Field: ‘result’
[17:36:44.481]   - Field: ‘asynchronous’
[17:36:44.481]   - Field: ‘calls’
[17:36:44.481]   - Field: ‘globals’
[17:36:44.482]   - Field: ‘stdout’
[17:36:44.482]   - Field: ‘earlySignal’
[17:36:44.482]   - Field: ‘lazy’
[17:36:44.482]   - Field: ‘state’
[17:36:44.482] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:44.482] - Launch lazy future ...
[17:36:44.482] Packages needed by the future expression (n = 0): <none>
[17:36:44.483] Packages needed by future strategies (n = 0): <none>
[17:36:44.483] {
[17:36:44.483]     {
[17:36:44.483]         {
[17:36:44.483]             ...future.startTime <- base::Sys.time()
[17:36:44.483]             {
[17:36:44.483]                 {
[17:36:44.483]                   {
[17:36:44.483]                     {
[17:36:44.483]                       base::local({
[17:36:44.483]                         has_future <- base::requireNamespace("future", 
[17:36:44.483]                           quietly = TRUE)
[17:36:44.483]                         if (has_future) {
[17:36:44.483]                           ns <- base::getNamespace("future")
[17:36:44.483]                           version <- ns[[".package"]][["version"]]
[17:36:44.483]                           if (is.null(version)) 
[17:36:44.483]                             version <- utils::packageVersion("future")
[17:36:44.483]                         }
[17:36:44.483]                         else {
[17:36:44.483]                           version <- NULL
[17:36:44.483]                         }
[17:36:44.483]                         if (!has_future || version < "1.8.0") {
[17:36:44.483]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:44.483]                             "", base::R.version$version.string), 
[17:36:44.483]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:44.483]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:44.483]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:44.483]                               "release", "version")], collapse = " "), 
[17:36:44.483]                             hostname = base::Sys.info()[["nodename"]])
[17:36:44.483]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:44.483]                             info)
[17:36:44.483]                           info <- base::paste(info, collapse = "; ")
[17:36:44.483]                           if (!has_future) {
[17:36:44.483]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:44.483]                               info)
[17:36:44.483]                           }
[17:36:44.483]                           else {
[17:36:44.483]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:44.483]                               info, version)
[17:36:44.483]                           }
[17:36:44.483]                           base::stop(msg)
[17:36:44.483]                         }
[17:36:44.483]                       })
[17:36:44.483]                     }
[17:36:44.483]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:44.483]                     base::options(mc.cores = 1L)
[17:36:44.483]                   }
[17:36:44.483]                   ...future.strategy.old <- future::plan("list")
[17:36:44.483]                   options(future.plan = NULL)
[17:36:44.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:44.483]                 }
[17:36:44.483]                 ...future.workdir <- getwd()
[17:36:44.483]             }
[17:36:44.483]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:44.483]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:44.483]         }
[17:36:44.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:44.483]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:44.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:44.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:44.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:44.483]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:44.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:44.483]             base::names(...future.oldOptions))
[17:36:44.483]     }
[17:36:44.483]     if (FALSE) {
[17:36:44.483]     }
[17:36:44.483]     else {
[17:36:44.483]         if (TRUE) {
[17:36:44.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:44.483]                 open = "w")
[17:36:44.483]         }
[17:36:44.483]         else {
[17:36:44.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:44.483]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:44.483]         }
[17:36:44.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:44.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:44.483]             base::sink(type = "output", split = FALSE)
[17:36:44.483]             base::close(...future.stdout)
[17:36:44.483]         }, add = TRUE)
[17:36:44.483]     }
[17:36:44.483]     ...future.frame <- base::sys.nframe()
[17:36:44.483]     ...future.conditions <- base::list()
[17:36:44.483]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:44.483]     if (FALSE) {
[17:36:44.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:44.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:44.483]     }
[17:36:44.483]     ...future.result <- base::tryCatch({
[17:36:44.483]         base::withCallingHandlers({
[17:36:44.483]             ...future.value <- base::withVisible(base::local({
[17:36:44.483]                 ...future.makeSendCondition <- base::local({
[17:36:44.483]                   sendCondition <- NULL
[17:36:44.483]                   function(frame = 1L) {
[17:36:44.483]                     if (is.function(sendCondition)) 
[17:36:44.483]                       return(sendCondition)
[17:36:44.483]                     ns <- getNamespace("parallel")
[17:36:44.483]                     if (exists("sendData", mode = "function", 
[17:36:44.483]                       envir = ns)) {
[17:36:44.483]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:44.483]                         envir = ns)
[17:36:44.483]                       envir <- sys.frame(frame)
[17:36:44.483]                       master <- NULL
[17:36:44.483]                       while (!identical(envir, .GlobalEnv) && 
[17:36:44.483]                         !identical(envir, emptyenv())) {
[17:36:44.483]                         if (exists("master", mode = "list", envir = envir, 
[17:36:44.483]                           inherits = FALSE)) {
[17:36:44.483]                           master <- get("master", mode = "list", 
[17:36:44.483]                             envir = envir, inherits = FALSE)
[17:36:44.483]                           if (inherits(master, c("SOCKnode", 
[17:36:44.483]                             "SOCK0node"))) {
[17:36:44.483]                             sendCondition <<- function(cond) {
[17:36:44.483]                               data <- list(type = "VALUE", value = cond, 
[17:36:44.483]                                 success = TRUE)
[17:36:44.483]                               parallel_sendData(master, data)
[17:36:44.483]                             }
[17:36:44.483]                             return(sendCondition)
[17:36:44.483]                           }
[17:36:44.483]                         }
[17:36:44.483]                         frame <- frame + 1L
[17:36:44.483]                         envir <- sys.frame(frame)
[17:36:44.483]                       }
[17:36:44.483]                     }
[17:36:44.483]                     sendCondition <<- function(cond) NULL
[17:36:44.483]                   }
[17:36:44.483]                 })
[17:36:44.483]                 withCallingHandlers({
[17:36:44.483]                   {
[17:36:44.483]                     do.call(function(...) {
[17:36:44.483]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.483]                       if (!identical(...future.globals.maxSize.org, 
[17:36:44.483]                         ...future.globals.maxSize)) {
[17:36:44.483]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.483]                         on.exit(options(oopts), add = TRUE)
[17:36:44.483]                       }
[17:36:44.483]                       {
[17:36:44.483]                         lapply(seq_along(...future.elements_ii), 
[17:36:44.483]                           FUN = function(jj) {
[17:36:44.483]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.483]                             ...future.FUN(...future.X_jj, ...)
[17:36:44.483]                           })
[17:36:44.483]                       }
[17:36:44.483]                     }, args = future.call.arguments)
[17:36:44.483]                   }
[17:36:44.483]                 }, immediateCondition = function(cond) {
[17:36:44.483]                   sendCondition <- ...future.makeSendCondition()
[17:36:44.483]                   sendCondition(cond)
[17:36:44.483]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.483]                   {
[17:36:44.483]                     inherits <- base::inherits
[17:36:44.483]                     invokeRestart <- base::invokeRestart
[17:36:44.483]                     is.null <- base::is.null
[17:36:44.483]                     muffled <- FALSE
[17:36:44.483]                     if (inherits(cond, "message")) {
[17:36:44.483]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:44.483]                       if (muffled) 
[17:36:44.483]                         invokeRestart("muffleMessage")
[17:36:44.483]                     }
[17:36:44.483]                     else if (inherits(cond, "warning")) {
[17:36:44.483]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:44.483]                       if (muffled) 
[17:36:44.483]                         invokeRestart("muffleWarning")
[17:36:44.483]                     }
[17:36:44.483]                     else if (inherits(cond, "condition")) {
[17:36:44.483]                       if (!is.null(pattern)) {
[17:36:44.483]                         computeRestarts <- base::computeRestarts
[17:36:44.483]                         grepl <- base::grepl
[17:36:44.483]                         restarts <- computeRestarts(cond)
[17:36:44.483]                         for (restart in restarts) {
[17:36:44.483]                           name <- restart$name
[17:36:44.483]                           if (is.null(name)) 
[17:36:44.483]                             next
[17:36:44.483]                           if (!grepl(pattern, name)) 
[17:36:44.483]                             next
[17:36:44.483]                           invokeRestart(restart)
[17:36:44.483]                           muffled <- TRUE
[17:36:44.483]                           break
[17:36:44.483]                         }
[17:36:44.483]                       }
[17:36:44.483]                     }
[17:36:44.483]                     invisible(muffled)
[17:36:44.483]                   }
[17:36:44.483]                   muffleCondition(cond)
[17:36:44.483]                 })
[17:36:44.483]             }))
[17:36:44.483]             future::FutureResult(value = ...future.value$value, 
[17:36:44.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.483]                   ...future.rng), globalenv = if (FALSE) 
[17:36:44.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:44.483]                     ...future.globalenv.names))
[17:36:44.483]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:44.483]         }, condition = base::local({
[17:36:44.483]             c <- base::c
[17:36:44.483]             inherits <- base::inherits
[17:36:44.483]             invokeRestart <- base::invokeRestart
[17:36:44.483]             length <- base::length
[17:36:44.483]             list <- base::list
[17:36:44.483]             seq.int <- base::seq.int
[17:36:44.483]             signalCondition <- base::signalCondition
[17:36:44.483]             sys.calls <- base::sys.calls
[17:36:44.483]             `[[` <- base::`[[`
[17:36:44.483]             `+` <- base::`+`
[17:36:44.483]             `<<-` <- base::`<<-`
[17:36:44.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:44.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:44.483]                   3L)]
[17:36:44.483]             }
[17:36:44.483]             function(cond) {
[17:36:44.483]                 is_error <- inherits(cond, "error")
[17:36:44.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:44.483]                   NULL)
[17:36:44.483]                 if (is_error) {
[17:36:44.483]                   sessionInformation <- function() {
[17:36:44.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:44.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:44.483]                       search = base::search(), system = base::Sys.info())
[17:36:44.483]                   }
[17:36:44.483]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:44.483]                     cond$call), session = sessionInformation(), 
[17:36:44.483]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:44.483]                   signalCondition(cond)
[17:36:44.483]                 }
[17:36:44.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:44.483]                 "immediateCondition"))) {
[17:36:44.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:44.483]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:44.483]                   if (TRUE && !signal) {
[17:36:44.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.483]                     {
[17:36:44.483]                       inherits <- base::inherits
[17:36:44.483]                       invokeRestart <- base::invokeRestart
[17:36:44.483]                       is.null <- base::is.null
[17:36:44.483]                       muffled <- FALSE
[17:36:44.483]                       if (inherits(cond, "message")) {
[17:36:44.483]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.483]                         if (muffled) 
[17:36:44.483]                           invokeRestart("muffleMessage")
[17:36:44.483]                       }
[17:36:44.483]                       else if (inherits(cond, "warning")) {
[17:36:44.483]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.483]                         if (muffled) 
[17:36:44.483]                           invokeRestart("muffleWarning")
[17:36:44.483]                       }
[17:36:44.483]                       else if (inherits(cond, "condition")) {
[17:36:44.483]                         if (!is.null(pattern)) {
[17:36:44.483]                           computeRestarts <- base::computeRestarts
[17:36:44.483]                           grepl <- base::grepl
[17:36:44.483]                           restarts <- computeRestarts(cond)
[17:36:44.483]                           for (restart in restarts) {
[17:36:44.483]                             name <- restart$name
[17:36:44.483]                             if (is.null(name)) 
[17:36:44.483]                               next
[17:36:44.483]                             if (!grepl(pattern, name)) 
[17:36:44.483]                               next
[17:36:44.483]                             invokeRestart(restart)
[17:36:44.483]                             muffled <- TRUE
[17:36:44.483]                             break
[17:36:44.483]                           }
[17:36:44.483]                         }
[17:36:44.483]                       }
[17:36:44.483]                       invisible(muffled)
[17:36:44.483]                     }
[17:36:44.483]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.483]                   }
[17:36:44.483]                 }
[17:36:44.483]                 else {
[17:36:44.483]                   if (TRUE) {
[17:36:44.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.483]                     {
[17:36:44.483]                       inherits <- base::inherits
[17:36:44.483]                       invokeRestart <- base::invokeRestart
[17:36:44.483]                       is.null <- base::is.null
[17:36:44.483]                       muffled <- FALSE
[17:36:44.483]                       if (inherits(cond, "message")) {
[17:36:44.483]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.483]                         if (muffled) 
[17:36:44.483]                           invokeRestart("muffleMessage")
[17:36:44.483]                       }
[17:36:44.483]                       else if (inherits(cond, "warning")) {
[17:36:44.483]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.483]                         if (muffled) 
[17:36:44.483]                           invokeRestart("muffleWarning")
[17:36:44.483]                       }
[17:36:44.483]                       else if (inherits(cond, "condition")) {
[17:36:44.483]                         if (!is.null(pattern)) {
[17:36:44.483]                           computeRestarts <- base::computeRestarts
[17:36:44.483]                           grepl <- base::grepl
[17:36:44.483]                           restarts <- computeRestarts(cond)
[17:36:44.483]                           for (restart in restarts) {
[17:36:44.483]                             name <- restart$name
[17:36:44.483]                             if (is.null(name)) 
[17:36:44.483]                               next
[17:36:44.483]                             if (!grepl(pattern, name)) 
[17:36:44.483]                               next
[17:36:44.483]                             invokeRestart(restart)
[17:36:44.483]                             muffled <- TRUE
[17:36:44.483]                             break
[17:36:44.483]                           }
[17:36:44.483]                         }
[17:36:44.483]                       }
[17:36:44.483]                       invisible(muffled)
[17:36:44.483]                     }
[17:36:44.483]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.483]                   }
[17:36:44.483]                 }
[17:36:44.483]             }
[17:36:44.483]         }))
[17:36:44.483]     }, error = function(ex) {
[17:36:44.483]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:44.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.483]                 ...future.rng), started = ...future.startTime, 
[17:36:44.483]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:44.483]             version = "1.8"), class = "FutureResult")
[17:36:44.483]     }, finally = {
[17:36:44.483]         if (!identical(...future.workdir, getwd())) 
[17:36:44.483]             setwd(...future.workdir)
[17:36:44.483]         {
[17:36:44.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:44.483]                 ...future.oldOptions$nwarnings <- NULL
[17:36:44.483]             }
[17:36:44.483]             base::options(...future.oldOptions)
[17:36:44.483]             if (.Platform$OS.type == "windows") {
[17:36:44.483]                 old_names <- names(...future.oldEnvVars)
[17:36:44.483]                 envs <- base::Sys.getenv()
[17:36:44.483]                 names <- names(envs)
[17:36:44.483]                 common <- intersect(names, old_names)
[17:36:44.483]                 added <- setdiff(names, old_names)
[17:36:44.483]                 removed <- setdiff(old_names, names)
[17:36:44.483]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:44.483]                   envs[common]]
[17:36:44.483]                 NAMES <- toupper(changed)
[17:36:44.483]                 args <- list()
[17:36:44.483]                 for (kk in seq_along(NAMES)) {
[17:36:44.483]                   name <- changed[[kk]]
[17:36:44.483]                   NAME <- NAMES[[kk]]
[17:36:44.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.483]                     next
[17:36:44.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.483]                 }
[17:36:44.483]                 NAMES <- toupper(added)
[17:36:44.483]                 for (kk in seq_along(NAMES)) {
[17:36:44.483]                   name <- added[[kk]]
[17:36:44.483]                   NAME <- NAMES[[kk]]
[17:36:44.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.483]                     next
[17:36:44.483]                   args[[name]] <- ""
[17:36:44.483]                 }
[17:36:44.483]                 NAMES <- toupper(removed)
[17:36:44.483]                 for (kk in seq_along(NAMES)) {
[17:36:44.483]                   name <- removed[[kk]]
[17:36:44.483]                   NAME <- NAMES[[kk]]
[17:36:44.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.483]                     next
[17:36:44.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.483]                 }
[17:36:44.483]                 if (length(args) > 0) 
[17:36:44.483]                   base::do.call(base::Sys.setenv, args = args)
[17:36:44.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:44.483]             }
[17:36:44.483]             else {
[17:36:44.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:44.483]             }
[17:36:44.483]             {
[17:36:44.483]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:44.483]                   0L) {
[17:36:44.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:44.483]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:44.483]                   base::options(opts)
[17:36:44.483]                 }
[17:36:44.483]                 {
[17:36:44.483]                   {
[17:36:44.483]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:44.483]                     NULL
[17:36:44.483]                   }
[17:36:44.483]                   options(future.plan = NULL)
[17:36:44.483]                   if (is.na(NA_character_)) 
[17:36:44.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:44.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:44.483]                     .init = FALSE)
[17:36:44.483]                 }
[17:36:44.483]             }
[17:36:44.483]         }
[17:36:44.483]     })
[17:36:44.483]     if (TRUE) {
[17:36:44.483]         base::sink(type = "output", split = FALSE)
[17:36:44.483]         if (TRUE) {
[17:36:44.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:44.483]         }
[17:36:44.483]         else {
[17:36:44.483]             ...future.result["stdout"] <- base::list(NULL)
[17:36:44.483]         }
[17:36:44.483]         base::close(...future.stdout)
[17:36:44.483]         ...future.stdout <- NULL
[17:36:44.483]     }
[17:36:44.483]     ...future.result$conditions <- ...future.conditions
[17:36:44.483]     ...future.result$finished <- base::Sys.time()
[17:36:44.483]     ...future.result
[17:36:44.483] }
[17:36:44.536] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:36:44.537] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:36:44.537] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:36:44.538] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:44.538] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:44.538] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:36:44.538] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:36:44.539] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:44.539] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:44.539] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:36:44.539] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:36:44.540] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:36:44.540] MultisessionFuture started
[17:36:44.540] - Launch lazy future ... done
[17:36:44.540] run() for ‘MultisessionFuture’ ... done
[17:36:44.541] Created future:
[17:36:44.541] MultisessionFuture:
[17:36:44.541] Label: ‘future_eapply-2’
[17:36:44.541] Expression:
[17:36:44.541] {
[17:36:44.541]     do.call(function(...) {
[17:36:44.541]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.541]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.541]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.541]             on.exit(options(oopts), add = TRUE)
[17:36:44.541]         }
[17:36:44.541]         {
[17:36:44.541]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.541]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.541]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.541]             })
[17:36:44.541]         }
[17:36:44.541]     }, args = future.call.arguments)
[17:36:44.541] }
[17:36:44.541] Lazy evaluation: FALSE
[17:36:44.541] Asynchronous evaluation: TRUE
[17:36:44.541] Local evaluation: TRUE
[17:36:44.541] Environment: R_GlobalEnv
[17:36:44.541] Capture standard output: TRUE
[17:36:44.541] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:44.541] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:44.541] Packages: <none>
[17:36:44.541] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:44.541] Resolved: FALSE
[17:36:44.541] Value: <not collected>
[17:36:44.541] Conditions captured: <none>
[17:36:44.541] Early signaling: FALSE
[17:36:44.541] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:44.541] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.553] Chunk #2 of 2 ... DONE
[17:36:44.553] Launching 2 futures (chunks) ... DONE
[17:36:44.553] Resolving 2 futures (chunks) ...
[17:36:44.553] resolve() on list ...
[17:36:44.553]  recursive: 0
[17:36:44.553]  length: 2
[17:36:44.553] 
[17:36:44.554] receiveMessageFromWorker() for ClusterFuture ...
[17:36:44.554] - Validating connection of MultisessionFuture
[17:36:44.554] - received message: FutureResult
[17:36:44.554] - Received FutureResult
[17:36:44.554] - Erased future from FutureRegistry
[17:36:44.555] result() for ClusterFuture ...
[17:36:44.555] - result already collected: FutureResult
[17:36:44.555] result() for ClusterFuture ... done
[17:36:44.555] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:44.555] Future #1
[17:36:44.555] result() for ClusterFuture ...
[17:36:44.555] - result already collected: FutureResult
[17:36:44.555] result() for ClusterFuture ... done
[17:36:44.555] result() for ClusterFuture ...
[17:36:44.556] - result already collected: FutureResult
[17:36:44.556] result() for ClusterFuture ... done
[17:36:44.556] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:44.556] - nx: 2
[17:36:44.556] - relay: TRUE
[17:36:44.556] - stdout: TRUE
[17:36:44.559] - signal: TRUE
[17:36:44.559] - resignal: FALSE
[17:36:44.559] - force: TRUE
[17:36:44.559] - relayed: [n=2] FALSE, FALSE
[17:36:44.559] - queued futures: [n=2] FALSE, FALSE
[17:36:44.559]  - until=1
[17:36:44.559]  - relaying element #1
[17:36:44.559] result() for ClusterFuture ...
[17:36:44.559] - result already collected: FutureResult
[17:36:44.559] result() for ClusterFuture ... done
[17:36:44.559] result() for ClusterFuture ...
[17:36:44.559] - result already collected: FutureResult
[17:36:44.560] result() for ClusterFuture ... done
[17:36:44.560] result() for ClusterFuture ...
[17:36:44.560] - result already collected: FutureResult
[17:36:44.560] result() for ClusterFuture ... done
[17:36:44.560] result() for ClusterFuture ...
[17:36:44.560] - result already collected: FutureResult
[17:36:44.560] result() for ClusterFuture ... done
[17:36:44.560] - relayed: [n=2] TRUE, FALSE
[17:36:44.560] - queued futures: [n=2] TRUE, FALSE
[17:36:44.560] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:44.560]  length: 1 (resolved future 1)
[17:36:44.623] receiveMessageFromWorker() for ClusterFuture ...
[17:36:44.623] - Validating connection of MultisessionFuture
[17:36:44.623] - received message: FutureResult
[17:36:44.623] - Received FutureResult
[17:36:44.623] - Erased future from FutureRegistry
[17:36:44.624] result() for ClusterFuture ...
[17:36:44.624] - result already collected: FutureResult
[17:36:44.624] result() for ClusterFuture ... done
[17:36:44.624] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:44.624] Future #2
[17:36:44.624] result() for ClusterFuture ...
[17:36:44.624] - result already collected: FutureResult
[17:36:44.624] result() for ClusterFuture ... done
[17:36:44.624] result() for ClusterFuture ...
[17:36:44.624] - result already collected: FutureResult
[17:36:44.624] result() for ClusterFuture ... done
[17:36:44.625] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:44.625] - nx: 2
[17:36:44.625] - relay: TRUE
[17:36:44.625] - stdout: TRUE
[17:36:44.625] - signal: TRUE
[17:36:44.625] - resignal: FALSE
[17:36:44.625] - force: TRUE
[17:36:44.625] - relayed: [n=2] TRUE, FALSE
[17:36:44.625] - queued futures: [n=2] TRUE, FALSE
[17:36:44.625]  - until=2
[17:36:44.625]  - relaying element #2
[17:36:44.625] result() for ClusterFuture ...
[17:36:44.626] - result already collected: FutureResult
[17:36:44.626] result() for ClusterFuture ... done
[17:36:44.626] result() for ClusterFuture ...
[17:36:44.626] - result already collected: FutureResult
[17:36:44.626] result() for ClusterFuture ... done
[17:36:44.626] result() for ClusterFuture ...
[17:36:44.626] - result already collected: FutureResult
[17:36:44.626] result() for ClusterFuture ... done
[17:36:44.626] result() for ClusterFuture ...
[17:36:44.626] - result already collected: FutureResult
[17:36:44.626] result() for ClusterFuture ... done
[17:36:44.626] - relayed: [n=2] TRUE, TRUE
[17:36:44.627] - queued futures: [n=2] TRUE, TRUE
[17:36:44.627] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:44.627]  length: 0 (resolved future 2)
[17:36:44.627] Relaying remaining futures
[17:36:44.627] signalConditionsASAP(NULL, pos=0) ...
[17:36:44.627] - nx: 2
[17:36:44.627] - relay: TRUE
[17:36:44.627] - stdout: TRUE
[17:36:44.627] - signal: TRUE
[17:36:44.627] - resignal: FALSE
[17:36:44.627] - force: TRUE
[17:36:44.627] - relayed: [n=2] TRUE, TRUE
[17:36:44.627] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:44.628] - relayed: [n=2] TRUE, TRUE
[17:36:44.628] - queued futures: [n=2] TRUE, TRUE
[17:36:44.628] signalConditionsASAP(NULL, pos=0) ... done
[17:36:44.628] resolve() on list ... DONE
[17:36:44.628] result() for ClusterFuture ...
[17:36:44.628] - result already collected: FutureResult
[17:36:44.628] result() for ClusterFuture ... done
[17:36:44.628] result() for ClusterFuture ...
[17:36:44.628] - result already collected: FutureResult
[17:36:44.628] result() for ClusterFuture ... done
[17:36:44.629] result() for ClusterFuture ...
[17:36:44.629] - result already collected: FutureResult
[17:36:44.629] result() for ClusterFuture ... done
[17:36:44.629] result() for ClusterFuture ...
[17:36:44.629] - result already collected: FutureResult
[17:36:44.629] result() for ClusterFuture ... done
[17:36:44.629]  - Number of value chunks collected: 2
[17:36:44.629] Resolving 2 futures (chunks) ... DONE
[17:36:44.629] Reducing values from 2 chunks ...
[17:36:44.629]  - Number of values collected after concatenation: 3
[17:36:44.629]  - Number of values expected: 3
[17:36:44.629] Reducing values from 2 chunks ... DONE
[17:36:44.630] future_lapply() ... DONE
[17:36:44.630] future_lapply() ...
[17:36:44.634] Number of chunks: 2
[17:36:44.634] getGlobalsAndPackagesXApply() ...
[17:36:44.634]  - future.globals: TRUE
[17:36:44.634] getGlobalsAndPackages() ...
[17:36:44.635] Searching for globals...
[17:36:44.636] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:44.636] Searching for globals ... DONE
[17:36:44.636] Resolving globals: FALSE
[17:36:44.636] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:44.637] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:44.637] - globals: [1] ‘FUN’
[17:36:44.637] - packages: [1] ‘stats’
[17:36:44.637] getGlobalsAndPackages() ... DONE
[17:36:44.637]  - globals found/used: [n=1] ‘FUN’
[17:36:44.637]  - needed namespaces: [n=1] ‘stats’
[17:36:44.637] Finding globals ... DONE
[17:36:44.637]  - use_args: TRUE
[17:36:44.637]  - Getting '...' globals ...
[17:36:44.638] resolve() on list ...
[17:36:44.638]  recursive: 0
[17:36:44.638]  length: 1
[17:36:44.638]  elements: ‘...’
[17:36:44.638]  length: 0 (resolved future 1)
[17:36:44.638] resolve() on list ... DONE
[17:36:44.638]    - '...' content: [n=1] ‘probs’
[17:36:44.638] List of 1
[17:36:44.638]  $ ...:List of 1
[17:36:44.638]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:36:44.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:44.638]  - attr(*, "where")=List of 1
[17:36:44.638]   ..$ ...:<environment: 0x56550482a180> 
[17:36:44.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:44.638]  - attr(*, "resolved")= logi TRUE
[17:36:44.638]  - attr(*, "total_size")= num NA
[17:36:44.641]  - Getting '...' globals ... DONE
[17:36:44.641] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:44.642] List of 2
[17:36:44.642]  $ ...future.FUN:function (x, ...)  
[17:36:44.642]  $ ...          :List of 1
[17:36:44.642]   ..$ probs: num [1:3] 0.25 0.5 0.75
[17:36:44.642]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:44.642]  - attr(*, "where")=List of 2
[17:36:44.642]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:44.642]   ..$ ...          :<environment: 0x56550482a180> 
[17:36:44.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:44.642]  - attr(*, "resolved")= logi FALSE
[17:36:44.642]  - attr(*, "total_size")= num 1328
[17:36:44.645] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:44.645] getGlobalsAndPackagesXApply() ... DONE
[17:36:44.645] Number of futures (= number of chunks): 2
[17:36:44.645] Launching 2 futures (chunks) ...
[17:36:44.645] Chunk #1 of 2 ...
[17:36:44.645]  - Finding globals in 'X' for chunk #1 ...
[17:36:44.645] getGlobalsAndPackages() ...
[17:36:44.645] Searching for globals...
[17:36:44.646] 
[17:36:44.646] Searching for globals ... DONE
[17:36:44.646] - globals: [0] <none>
[17:36:44.646] getGlobalsAndPackages() ... DONE
[17:36:44.646]    + additional globals found: [n=0] 
[17:36:44.646]    + additional namespaces needed: [n=0] 
[17:36:44.646]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:44.646]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:44.646]  - seeds: <none>
[17:36:44.646]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.647] getGlobalsAndPackages() ...
[17:36:44.647] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.647] Resolving globals: FALSE
[17:36:44.647] Tweak future expression to call with '...' arguments ...
[17:36:44.647] {
[17:36:44.647]     do.call(function(...) {
[17:36:44.647]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.647]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.647]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.647]             on.exit(options(oopts), add = TRUE)
[17:36:44.647]         }
[17:36:44.647]         {
[17:36:44.647]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.647]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.647]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.647]             })
[17:36:44.647]         }
[17:36:44.647]     }, args = future.call.arguments)
[17:36:44.647] }
[17:36:44.647] Tweak future expression to call with '...' arguments ... DONE
[17:36:44.648] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.648] - packages: [1] ‘stats’
[17:36:44.648] getGlobalsAndPackages() ... DONE
[17:36:44.648] run() for ‘Future’ ...
[17:36:44.648] - state: ‘created’
[17:36:44.648] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:44.662] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:44.662]   - Field: ‘node’
[17:36:44.662]   - Field: ‘label’
[17:36:44.663]   - Field: ‘local’
[17:36:44.663]   - Field: ‘owner’
[17:36:44.663]   - Field: ‘envir’
[17:36:44.663]   - Field: ‘workers’
[17:36:44.663]   - Field: ‘packages’
[17:36:44.663]   - Field: ‘gc’
[17:36:44.663]   - Field: ‘conditions’
[17:36:44.663]   - Field: ‘persistent’
[17:36:44.663]   - Field: ‘expr’
[17:36:44.663]   - Field: ‘uuid’
[17:36:44.663]   - Field: ‘seed’
[17:36:44.663]   - Field: ‘version’
[17:36:44.664]   - Field: ‘result’
[17:36:44.664]   - Field: ‘asynchronous’
[17:36:44.664]   - Field: ‘calls’
[17:36:44.664]   - Field: ‘globals’
[17:36:44.664]   - Field: ‘stdout’
[17:36:44.664]   - Field: ‘earlySignal’
[17:36:44.664]   - Field: ‘lazy’
[17:36:44.664]   - Field: ‘state’
[17:36:44.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:44.664] - Launch lazy future ...
[17:36:44.665] Packages needed by the future expression (n = 1): ‘stats’
[17:36:44.665] Packages needed by future strategies (n = 0): <none>
[17:36:44.665] {
[17:36:44.665]     {
[17:36:44.665]         {
[17:36:44.665]             ...future.startTime <- base::Sys.time()
[17:36:44.665]             {
[17:36:44.665]                 {
[17:36:44.665]                   {
[17:36:44.665]                     {
[17:36:44.665]                       {
[17:36:44.665]                         base::local({
[17:36:44.665]                           has_future <- base::requireNamespace("future", 
[17:36:44.665]                             quietly = TRUE)
[17:36:44.665]                           if (has_future) {
[17:36:44.665]                             ns <- base::getNamespace("future")
[17:36:44.665]                             version <- ns[[".package"]][["version"]]
[17:36:44.665]                             if (is.null(version)) 
[17:36:44.665]                               version <- utils::packageVersion("future")
[17:36:44.665]                           }
[17:36:44.665]                           else {
[17:36:44.665]                             version <- NULL
[17:36:44.665]                           }
[17:36:44.665]                           if (!has_future || version < "1.8.0") {
[17:36:44.665]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:44.665]                               "", base::R.version$version.string), 
[17:36:44.665]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:44.665]                                 base::R.version$platform, 8 * 
[17:36:44.665]                                   base::.Machine$sizeof.pointer), 
[17:36:44.665]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:44.665]                                 "release", "version")], collapse = " "), 
[17:36:44.665]                               hostname = base::Sys.info()[["nodename"]])
[17:36:44.665]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:44.665]                               info)
[17:36:44.665]                             info <- base::paste(info, collapse = "; ")
[17:36:44.665]                             if (!has_future) {
[17:36:44.665]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:44.665]                                 info)
[17:36:44.665]                             }
[17:36:44.665]                             else {
[17:36:44.665]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:44.665]                                 info, version)
[17:36:44.665]                             }
[17:36:44.665]                             base::stop(msg)
[17:36:44.665]                           }
[17:36:44.665]                         })
[17:36:44.665]                       }
[17:36:44.665]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:44.665]                       base::options(mc.cores = 1L)
[17:36:44.665]                     }
[17:36:44.665]                     base::local({
[17:36:44.665]                       for (pkg in "stats") {
[17:36:44.665]                         base::loadNamespace(pkg)
[17:36:44.665]                         base::library(pkg, character.only = TRUE)
[17:36:44.665]                       }
[17:36:44.665]                     })
[17:36:44.665]                   }
[17:36:44.665]                   ...future.strategy.old <- future::plan("list")
[17:36:44.665]                   options(future.plan = NULL)
[17:36:44.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:44.665]                 }
[17:36:44.665]                 ...future.workdir <- getwd()
[17:36:44.665]             }
[17:36:44.665]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:44.665]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:44.665]         }
[17:36:44.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:44.665]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:44.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:44.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:44.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:44.665]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:44.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:44.665]             base::names(...future.oldOptions))
[17:36:44.665]     }
[17:36:44.665]     if (FALSE) {
[17:36:44.665]     }
[17:36:44.665]     else {
[17:36:44.665]         if (TRUE) {
[17:36:44.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:44.665]                 open = "w")
[17:36:44.665]         }
[17:36:44.665]         else {
[17:36:44.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:44.665]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:44.665]         }
[17:36:44.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:44.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:44.665]             base::sink(type = "output", split = FALSE)
[17:36:44.665]             base::close(...future.stdout)
[17:36:44.665]         }, add = TRUE)
[17:36:44.665]     }
[17:36:44.665]     ...future.frame <- base::sys.nframe()
[17:36:44.665]     ...future.conditions <- base::list()
[17:36:44.665]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:44.665]     if (FALSE) {
[17:36:44.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:44.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:44.665]     }
[17:36:44.665]     ...future.result <- base::tryCatch({
[17:36:44.665]         base::withCallingHandlers({
[17:36:44.665]             ...future.value <- base::withVisible(base::local({
[17:36:44.665]                 ...future.makeSendCondition <- base::local({
[17:36:44.665]                   sendCondition <- NULL
[17:36:44.665]                   function(frame = 1L) {
[17:36:44.665]                     if (is.function(sendCondition)) 
[17:36:44.665]                       return(sendCondition)
[17:36:44.665]                     ns <- getNamespace("parallel")
[17:36:44.665]                     if (exists("sendData", mode = "function", 
[17:36:44.665]                       envir = ns)) {
[17:36:44.665]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:44.665]                         envir = ns)
[17:36:44.665]                       envir <- sys.frame(frame)
[17:36:44.665]                       master <- NULL
[17:36:44.665]                       while (!identical(envir, .GlobalEnv) && 
[17:36:44.665]                         !identical(envir, emptyenv())) {
[17:36:44.665]                         if (exists("master", mode = "list", envir = envir, 
[17:36:44.665]                           inherits = FALSE)) {
[17:36:44.665]                           master <- get("master", mode = "list", 
[17:36:44.665]                             envir = envir, inherits = FALSE)
[17:36:44.665]                           if (inherits(master, c("SOCKnode", 
[17:36:44.665]                             "SOCK0node"))) {
[17:36:44.665]                             sendCondition <<- function(cond) {
[17:36:44.665]                               data <- list(type = "VALUE", value = cond, 
[17:36:44.665]                                 success = TRUE)
[17:36:44.665]                               parallel_sendData(master, data)
[17:36:44.665]                             }
[17:36:44.665]                             return(sendCondition)
[17:36:44.665]                           }
[17:36:44.665]                         }
[17:36:44.665]                         frame <- frame + 1L
[17:36:44.665]                         envir <- sys.frame(frame)
[17:36:44.665]                       }
[17:36:44.665]                     }
[17:36:44.665]                     sendCondition <<- function(cond) NULL
[17:36:44.665]                   }
[17:36:44.665]                 })
[17:36:44.665]                 withCallingHandlers({
[17:36:44.665]                   {
[17:36:44.665]                     do.call(function(...) {
[17:36:44.665]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.665]                       if (!identical(...future.globals.maxSize.org, 
[17:36:44.665]                         ...future.globals.maxSize)) {
[17:36:44.665]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.665]                         on.exit(options(oopts), add = TRUE)
[17:36:44.665]                       }
[17:36:44.665]                       {
[17:36:44.665]                         lapply(seq_along(...future.elements_ii), 
[17:36:44.665]                           FUN = function(jj) {
[17:36:44.665]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.665]                             ...future.FUN(...future.X_jj, ...)
[17:36:44.665]                           })
[17:36:44.665]                       }
[17:36:44.665]                     }, args = future.call.arguments)
[17:36:44.665]                   }
[17:36:44.665]                 }, immediateCondition = function(cond) {
[17:36:44.665]                   sendCondition <- ...future.makeSendCondition()
[17:36:44.665]                   sendCondition(cond)
[17:36:44.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.665]                   {
[17:36:44.665]                     inherits <- base::inherits
[17:36:44.665]                     invokeRestart <- base::invokeRestart
[17:36:44.665]                     is.null <- base::is.null
[17:36:44.665]                     muffled <- FALSE
[17:36:44.665]                     if (inherits(cond, "message")) {
[17:36:44.665]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:44.665]                       if (muffled) 
[17:36:44.665]                         invokeRestart("muffleMessage")
[17:36:44.665]                     }
[17:36:44.665]                     else if (inherits(cond, "warning")) {
[17:36:44.665]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:44.665]                       if (muffled) 
[17:36:44.665]                         invokeRestart("muffleWarning")
[17:36:44.665]                     }
[17:36:44.665]                     else if (inherits(cond, "condition")) {
[17:36:44.665]                       if (!is.null(pattern)) {
[17:36:44.665]                         computeRestarts <- base::computeRestarts
[17:36:44.665]                         grepl <- base::grepl
[17:36:44.665]                         restarts <- computeRestarts(cond)
[17:36:44.665]                         for (restart in restarts) {
[17:36:44.665]                           name <- restart$name
[17:36:44.665]                           if (is.null(name)) 
[17:36:44.665]                             next
[17:36:44.665]                           if (!grepl(pattern, name)) 
[17:36:44.665]                             next
[17:36:44.665]                           invokeRestart(restart)
[17:36:44.665]                           muffled <- TRUE
[17:36:44.665]                           break
[17:36:44.665]                         }
[17:36:44.665]                       }
[17:36:44.665]                     }
[17:36:44.665]                     invisible(muffled)
[17:36:44.665]                   }
[17:36:44.665]                   muffleCondition(cond)
[17:36:44.665]                 })
[17:36:44.665]             }))
[17:36:44.665]             future::FutureResult(value = ...future.value$value, 
[17:36:44.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.665]                   ...future.rng), globalenv = if (FALSE) 
[17:36:44.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:44.665]                     ...future.globalenv.names))
[17:36:44.665]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:44.665]         }, condition = base::local({
[17:36:44.665]             c <- base::c
[17:36:44.665]             inherits <- base::inherits
[17:36:44.665]             invokeRestart <- base::invokeRestart
[17:36:44.665]             length <- base::length
[17:36:44.665]             list <- base::list
[17:36:44.665]             seq.int <- base::seq.int
[17:36:44.665]             signalCondition <- base::signalCondition
[17:36:44.665]             sys.calls <- base::sys.calls
[17:36:44.665]             `[[` <- base::`[[`
[17:36:44.665]             `+` <- base::`+`
[17:36:44.665]             `<<-` <- base::`<<-`
[17:36:44.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:44.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:44.665]                   3L)]
[17:36:44.665]             }
[17:36:44.665]             function(cond) {
[17:36:44.665]                 is_error <- inherits(cond, "error")
[17:36:44.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:44.665]                   NULL)
[17:36:44.665]                 if (is_error) {
[17:36:44.665]                   sessionInformation <- function() {
[17:36:44.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:44.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:44.665]                       search = base::search(), system = base::Sys.info())
[17:36:44.665]                   }
[17:36:44.665]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:44.665]                     cond$call), session = sessionInformation(), 
[17:36:44.665]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:44.665]                   signalCondition(cond)
[17:36:44.665]                 }
[17:36:44.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:44.665]                 "immediateCondition"))) {
[17:36:44.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:44.665]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:44.665]                   if (TRUE && !signal) {
[17:36:44.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.665]                     {
[17:36:44.665]                       inherits <- base::inherits
[17:36:44.665]                       invokeRestart <- base::invokeRestart
[17:36:44.665]                       is.null <- base::is.null
[17:36:44.665]                       muffled <- FALSE
[17:36:44.665]                       if (inherits(cond, "message")) {
[17:36:44.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.665]                         if (muffled) 
[17:36:44.665]                           invokeRestart("muffleMessage")
[17:36:44.665]                       }
[17:36:44.665]                       else if (inherits(cond, "warning")) {
[17:36:44.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.665]                         if (muffled) 
[17:36:44.665]                           invokeRestart("muffleWarning")
[17:36:44.665]                       }
[17:36:44.665]                       else if (inherits(cond, "condition")) {
[17:36:44.665]                         if (!is.null(pattern)) {
[17:36:44.665]                           computeRestarts <- base::computeRestarts
[17:36:44.665]                           grepl <- base::grepl
[17:36:44.665]                           restarts <- computeRestarts(cond)
[17:36:44.665]                           for (restart in restarts) {
[17:36:44.665]                             name <- restart$name
[17:36:44.665]                             if (is.null(name)) 
[17:36:44.665]                               next
[17:36:44.665]                             if (!grepl(pattern, name)) 
[17:36:44.665]                               next
[17:36:44.665]                             invokeRestart(restart)
[17:36:44.665]                             muffled <- TRUE
[17:36:44.665]                             break
[17:36:44.665]                           }
[17:36:44.665]                         }
[17:36:44.665]                       }
[17:36:44.665]                       invisible(muffled)
[17:36:44.665]                     }
[17:36:44.665]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.665]                   }
[17:36:44.665]                 }
[17:36:44.665]                 else {
[17:36:44.665]                   if (TRUE) {
[17:36:44.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.665]                     {
[17:36:44.665]                       inherits <- base::inherits
[17:36:44.665]                       invokeRestart <- base::invokeRestart
[17:36:44.665]                       is.null <- base::is.null
[17:36:44.665]                       muffled <- FALSE
[17:36:44.665]                       if (inherits(cond, "message")) {
[17:36:44.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.665]                         if (muffled) 
[17:36:44.665]                           invokeRestart("muffleMessage")
[17:36:44.665]                       }
[17:36:44.665]                       else if (inherits(cond, "warning")) {
[17:36:44.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.665]                         if (muffled) 
[17:36:44.665]                           invokeRestart("muffleWarning")
[17:36:44.665]                       }
[17:36:44.665]                       else if (inherits(cond, "condition")) {
[17:36:44.665]                         if (!is.null(pattern)) {
[17:36:44.665]                           computeRestarts <- base::computeRestarts
[17:36:44.665]                           grepl <- base::grepl
[17:36:44.665]                           restarts <- computeRestarts(cond)
[17:36:44.665]                           for (restart in restarts) {
[17:36:44.665]                             name <- restart$name
[17:36:44.665]                             if (is.null(name)) 
[17:36:44.665]                               next
[17:36:44.665]                             if (!grepl(pattern, name)) 
[17:36:44.665]                               next
[17:36:44.665]                             invokeRestart(restart)
[17:36:44.665]                             muffled <- TRUE
[17:36:44.665]                             break
[17:36:44.665]                           }
[17:36:44.665]                         }
[17:36:44.665]                       }
[17:36:44.665]                       invisible(muffled)
[17:36:44.665]                     }
[17:36:44.665]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.665]                   }
[17:36:44.665]                 }
[17:36:44.665]             }
[17:36:44.665]         }))
[17:36:44.665]     }, error = function(ex) {
[17:36:44.665]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:44.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.665]                 ...future.rng), started = ...future.startTime, 
[17:36:44.665]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:44.665]             version = "1.8"), class = "FutureResult")
[17:36:44.665]     }, finally = {
[17:36:44.665]         if (!identical(...future.workdir, getwd())) 
[17:36:44.665]             setwd(...future.workdir)
[17:36:44.665]         {
[17:36:44.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:44.665]                 ...future.oldOptions$nwarnings <- NULL
[17:36:44.665]             }
[17:36:44.665]             base::options(...future.oldOptions)
[17:36:44.665]             if (.Platform$OS.type == "windows") {
[17:36:44.665]                 old_names <- names(...future.oldEnvVars)
[17:36:44.665]                 envs <- base::Sys.getenv()
[17:36:44.665]                 names <- names(envs)
[17:36:44.665]                 common <- intersect(names, old_names)
[17:36:44.665]                 added <- setdiff(names, old_names)
[17:36:44.665]                 removed <- setdiff(old_names, names)
[17:36:44.665]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:44.665]                   envs[common]]
[17:36:44.665]                 NAMES <- toupper(changed)
[17:36:44.665]                 args <- list()
[17:36:44.665]                 for (kk in seq_along(NAMES)) {
[17:36:44.665]                   name <- changed[[kk]]
[17:36:44.665]                   NAME <- NAMES[[kk]]
[17:36:44.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.665]                     next
[17:36:44.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.665]                 }
[17:36:44.665]                 NAMES <- toupper(added)
[17:36:44.665]                 for (kk in seq_along(NAMES)) {
[17:36:44.665]                   name <- added[[kk]]
[17:36:44.665]                   NAME <- NAMES[[kk]]
[17:36:44.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.665]                     next
[17:36:44.665]                   args[[name]] <- ""
[17:36:44.665]                 }
[17:36:44.665]                 NAMES <- toupper(removed)
[17:36:44.665]                 for (kk in seq_along(NAMES)) {
[17:36:44.665]                   name <- removed[[kk]]
[17:36:44.665]                   NAME <- NAMES[[kk]]
[17:36:44.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.665]                     next
[17:36:44.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.665]                 }
[17:36:44.665]                 if (length(args) > 0) 
[17:36:44.665]                   base::do.call(base::Sys.setenv, args = args)
[17:36:44.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:44.665]             }
[17:36:44.665]             else {
[17:36:44.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:44.665]             }
[17:36:44.665]             {
[17:36:44.665]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:44.665]                   0L) {
[17:36:44.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:44.665]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:44.665]                   base::options(opts)
[17:36:44.665]                 }
[17:36:44.665]                 {
[17:36:44.665]                   {
[17:36:44.665]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:44.665]                     NULL
[17:36:44.665]                   }
[17:36:44.665]                   options(future.plan = NULL)
[17:36:44.665]                   if (is.na(NA_character_)) 
[17:36:44.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:44.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:44.665]                     .init = FALSE)
[17:36:44.665]                 }
[17:36:44.665]             }
[17:36:44.665]         }
[17:36:44.665]     })
[17:36:44.665]     if (TRUE) {
[17:36:44.665]         base::sink(type = "output", split = FALSE)
[17:36:44.665]         if (TRUE) {
[17:36:44.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:44.665]         }
[17:36:44.665]         else {
[17:36:44.665]             ...future.result["stdout"] <- base::list(NULL)
[17:36:44.665]         }
[17:36:44.665]         base::close(...future.stdout)
[17:36:44.665]         ...future.stdout <- NULL
[17:36:44.665]     }
[17:36:44.665]     ...future.result$conditions <- ...future.conditions
[17:36:44.665]     ...future.result$finished <- base::Sys.time()
[17:36:44.665]     ...future.result
[17:36:44.665] }
[17:36:44.668] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[17:36:44.668] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:36:44.669] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:36:44.669] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[17:36:44.669] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[17:36:44.669] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:36:44.670] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:36:44.670] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:44.670] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:44.670] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:36:44.671] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:36:44.671] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[17:36:44.671] MultisessionFuture started
[17:36:44.672] - Launch lazy future ... done
[17:36:44.672] run() for ‘MultisessionFuture’ ... done
[17:36:44.672] Created future:
[17:36:44.672] MultisessionFuture:
[17:36:44.672] Label: ‘future_eapply-1’
[17:36:44.672] Expression:
[17:36:44.672] {
[17:36:44.672]     do.call(function(...) {
[17:36:44.672]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.672]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.672]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.672]             on.exit(options(oopts), add = TRUE)
[17:36:44.672]         }
[17:36:44.672]         {
[17:36:44.672]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.672]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.672]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.672]             })
[17:36:44.672]         }
[17:36:44.672]     }, args = future.call.arguments)
[17:36:44.672] }
[17:36:44.672] Lazy evaluation: FALSE
[17:36:44.672] Asynchronous evaluation: TRUE
[17:36:44.672] Local evaluation: TRUE
[17:36:44.672] Environment: R_GlobalEnv
[17:36:44.672] Capture standard output: TRUE
[17:36:44.672] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:44.672] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:44.672] Packages: 1 packages (‘stats’)
[17:36:44.672] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:44.672] Resolved: FALSE
[17:36:44.672] Value: <not collected>
[17:36:44.672] Conditions captured: <none>
[17:36:44.672] Early signaling: FALSE
[17:36:44.672] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:44.672] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.684] Chunk #1 of 2 ... DONE
[17:36:44.684] Chunk #2 of 2 ...
[17:36:44.684]  - Finding globals in 'X' for chunk #2 ...
[17:36:44.684] getGlobalsAndPackages() ...
[17:36:44.684] Searching for globals...
[17:36:44.685] 
[17:36:44.685] Searching for globals ... DONE
[17:36:44.685] - globals: [0] <none>
[17:36:44.685] getGlobalsAndPackages() ... DONE
[17:36:44.685]    + additional globals found: [n=0] 
[17:36:44.685]    + additional namespaces needed: [n=0] 
[17:36:44.685]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:44.685]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:44.686]  - seeds: <none>
[17:36:44.686]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.686] getGlobalsAndPackages() ...
[17:36:44.686] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.686] Resolving globals: FALSE
[17:36:44.686] Tweak future expression to call with '...' arguments ...
[17:36:44.686] {
[17:36:44.686]     do.call(function(...) {
[17:36:44.686]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.686]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.686]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.686]             on.exit(options(oopts), add = TRUE)
[17:36:44.686]         }
[17:36:44.686]         {
[17:36:44.686]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.686]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.686]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.686]             })
[17:36:44.686]         }
[17:36:44.686]     }, args = future.call.arguments)
[17:36:44.686] }
[17:36:44.686] Tweak future expression to call with '...' arguments ... DONE
[17:36:44.687] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.687] - packages: [1] ‘stats’
[17:36:44.687] getGlobalsAndPackages() ... DONE
[17:36:44.687] run() for ‘Future’ ...
[17:36:44.687] - state: ‘created’
[17:36:44.687] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:44.701] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:44.701]   - Field: ‘node’
[17:36:44.702]   - Field: ‘label’
[17:36:44.702]   - Field: ‘local’
[17:36:44.702]   - Field: ‘owner’
[17:36:44.702]   - Field: ‘envir’
[17:36:44.702]   - Field: ‘workers’
[17:36:44.702]   - Field: ‘packages’
[17:36:44.702]   - Field: ‘gc’
[17:36:44.702]   - Field: ‘conditions’
[17:36:44.702]   - Field: ‘persistent’
[17:36:44.702]   - Field: ‘expr’
[17:36:44.702]   - Field: ‘uuid’
[17:36:44.703]   - Field: ‘seed’
[17:36:44.703]   - Field: ‘version’
[17:36:44.703]   - Field: ‘result’
[17:36:44.703]   - Field: ‘asynchronous’
[17:36:44.703]   - Field: ‘calls’
[17:36:44.703]   - Field: ‘globals’
[17:36:44.703]   - Field: ‘stdout’
[17:36:44.703]   - Field: ‘earlySignal’
[17:36:44.703]   - Field: ‘lazy’
[17:36:44.703]   - Field: ‘state’
[17:36:44.703] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:44.704] - Launch lazy future ...
[17:36:44.704] Packages needed by the future expression (n = 1): ‘stats’
[17:36:44.704] Packages needed by future strategies (n = 0): <none>
[17:36:44.704] {
[17:36:44.704]     {
[17:36:44.704]         {
[17:36:44.704]             ...future.startTime <- base::Sys.time()
[17:36:44.704]             {
[17:36:44.704]                 {
[17:36:44.704]                   {
[17:36:44.704]                     {
[17:36:44.704]                       {
[17:36:44.704]                         base::local({
[17:36:44.704]                           has_future <- base::requireNamespace("future", 
[17:36:44.704]                             quietly = TRUE)
[17:36:44.704]                           if (has_future) {
[17:36:44.704]                             ns <- base::getNamespace("future")
[17:36:44.704]                             version <- ns[[".package"]][["version"]]
[17:36:44.704]                             if (is.null(version)) 
[17:36:44.704]                               version <- utils::packageVersion("future")
[17:36:44.704]                           }
[17:36:44.704]                           else {
[17:36:44.704]                             version <- NULL
[17:36:44.704]                           }
[17:36:44.704]                           if (!has_future || version < "1.8.0") {
[17:36:44.704]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:44.704]                               "", base::R.version$version.string), 
[17:36:44.704]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:44.704]                                 base::R.version$platform, 8 * 
[17:36:44.704]                                   base::.Machine$sizeof.pointer), 
[17:36:44.704]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:44.704]                                 "release", "version")], collapse = " "), 
[17:36:44.704]                               hostname = base::Sys.info()[["nodename"]])
[17:36:44.704]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:44.704]                               info)
[17:36:44.704]                             info <- base::paste(info, collapse = "; ")
[17:36:44.704]                             if (!has_future) {
[17:36:44.704]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:44.704]                                 info)
[17:36:44.704]                             }
[17:36:44.704]                             else {
[17:36:44.704]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:44.704]                                 info, version)
[17:36:44.704]                             }
[17:36:44.704]                             base::stop(msg)
[17:36:44.704]                           }
[17:36:44.704]                         })
[17:36:44.704]                       }
[17:36:44.704]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:44.704]                       base::options(mc.cores = 1L)
[17:36:44.704]                     }
[17:36:44.704]                     base::local({
[17:36:44.704]                       for (pkg in "stats") {
[17:36:44.704]                         base::loadNamespace(pkg)
[17:36:44.704]                         base::library(pkg, character.only = TRUE)
[17:36:44.704]                       }
[17:36:44.704]                     })
[17:36:44.704]                   }
[17:36:44.704]                   ...future.strategy.old <- future::plan("list")
[17:36:44.704]                   options(future.plan = NULL)
[17:36:44.704]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.704]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:44.704]                 }
[17:36:44.704]                 ...future.workdir <- getwd()
[17:36:44.704]             }
[17:36:44.704]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:44.704]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:44.704]         }
[17:36:44.704]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:44.704]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:44.704]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:44.704]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:44.704]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:44.704]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:44.704]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:44.704]             base::names(...future.oldOptions))
[17:36:44.704]     }
[17:36:44.704]     if (FALSE) {
[17:36:44.704]     }
[17:36:44.704]     else {
[17:36:44.704]         if (TRUE) {
[17:36:44.704]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:44.704]                 open = "w")
[17:36:44.704]         }
[17:36:44.704]         else {
[17:36:44.704]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:44.704]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:44.704]         }
[17:36:44.704]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:44.704]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:44.704]             base::sink(type = "output", split = FALSE)
[17:36:44.704]             base::close(...future.stdout)
[17:36:44.704]         }, add = TRUE)
[17:36:44.704]     }
[17:36:44.704]     ...future.frame <- base::sys.nframe()
[17:36:44.704]     ...future.conditions <- base::list()
[17:36:44.704]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:44.704]     if (FALSE) {
[17:36:44.704]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:44.704]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:44.704]     }
[17:36:44.704]     ...future.result <- base::tryCatch({
[17:36:44.704]         base::withCallingHandlers({
[17:36:44.704]             ...future.value <- base::withVisible(base::local({
[17:36:44.704]                 ...future.makeSendCondition <- base::local({
[17:36:44.704]                   sendCondition <- NULL
[17:36:44.704]                   function(frame = 1L) {
[17:36:44.704]                     if (is.function(sendCondition)) 
[17:36:44.704]                       return(sendCondition)
[17:36:44.704]                     ns <- getNamespace("parallel")
[17:36:44.704]                     if (exists("sendData", mode = "function", 
[17:36:44.704]                       envir = ns)) {
[17:36:44.704]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:44.704]                         envir = ns)
[17:36:44.704]                       envir <- sys.frame(frame)
[17:36:44.704]                       master <- NULL
[17:36:44.704]                       while (!identical(envir, .GlobalEnv) && 
[17:36:44.704]                         !identical(envir, emptyenv())) {
[17:36:44.704]                         if (exists("master", mode = "list", envir = envir, 
[17:36:44.704]                           inherits = FALSE)) {
[17:36:44.704]                           master <- get("master", mode = "list", 
[17:36:44.704]                             envir = envir, inherits = FALSE)
[17:36:44.704]                           if (inherits(master, c("SOCKnode", 
[17:36:44.704]                             "SOCK0node"))) {
[17:36:44.704]                             sendCondition <<- function(cond) {
[17:36:44.704]                               data <- list(type = "VALUE", value = cond, 
[17:36:44.704]                                 success = TRUE)
[17:36:44.704]                               parallel_sendData(master, data)
[17:36:44.704]                             }
[17:36:44.704]                             return(sendCondition)
[17:36:44.704]                           }
[17:36:44.704]                         }
[17:36:44.704]                         frame <- frame + 1L
[17:36:44.704]                         envir <- sys.frame(frame)
[17:36:44.704]                       }
[17:36:44.704]                     }
[17:36:44.704]                     sendCondition <<- function(cond) NULL
[17:36:44.704]                   }
[17:36:44.704]                 })
[17:36:44.704]                 withCallingHandlers({
[17:36:44.704]                   {
[17:36:44.704]                     do.call(function(...) {
[17:36:44.704]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.704]                       if (!identical(...future.globals.maxSize.org, 
[17:36:44.704]                         ...future.globals.maxSize)) {
[17:36:44.704]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.704]                         on.exit(options(oopts), add = TRUE)
[17:36:44.704]                       }
[17:36:44.704]                       {
[17:36:44.704]                         lapply(seq_along(...future.elements_ii), 
[17:36:44.704]                           FUN = function(jj) {
[17:36:44.704]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.704]                             ...future.FUN(...future.X_jj, ...)
[17:36:44.704]                           })
[17:36:44.704]                       }
[17:36:44.704]                     }, args = future.call.arguments)
[17:36:44.704]                   }
[17:36:44.704]                 }, immediateCondition = function(cond) {
[17:36:44.704]                   sendCondition <- ...future.makeSendCondition()
[17:36:44.704]                   sendCondition(cond)
[17:36:44.704]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.704]                   {
[17:36:44.704]                     inherits <- base::inherits
[17:36:44.704]                     invokeRestart <- base::invokeRestart
[17:36:44.704]                     is.null <- base::is.null
[17:36:44.704]                     muffled <- FALSE
[17:36:44.704]                     if (inherits(cond, "message")) {
[17:36:44.704]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:44.704]                       if (muffled) 
[17:36:44.704]                         invokeRestart("muffleMessage")
[17:36:44.704]                     }
[17:36:44.704]                     else if (inherits(cond, "warning")) {
[17:36:44.704]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:44.704]                       if (muffled) 
[17:36:44.704]                         invokeRestart("muffleWarning")
[17:36:44.704]                     }
[17:36:44.704]                     else if (inherits(cond, "condition")) {
[17:36:44.704]                       if (!is.null(pattern)) {
[17:36:44.704]                         computeRestarts <- base::computeRestarts
[17:36:44.704]                         grepl <- base::grepl
[17:36:44.704]                         restarts <- computeRestarts(cond)
[17:36:44.704]                         for (restart in restarts) {
[17:36:44.704]                           name <- restart$name
[17:36:44.704]                           if (is.null(name)) 
[17:36:44.704]                             next
[17:36:44.704]                           if (!grepl(pattern, name)) 
[17:36:44.704]                             next
[17:36:44.704]                           invokeRestart(restart)
[17:36:44.704]                           muffled <- TRUE
[17:36:44.704]                           break
[17:36:44.704]                         }
[17:36:44.704]                       }
[17:36:44.704]                     }
[17:36:44.704]                     invisible(muffled)
[17:36:44.704]                   }
[17:36:44.704]                   muffleCondition(cond)
[17:36:44.704]                 })
[17:36:44.704]             }))
[17:36:44.704]             future::FutureResult(value = ...future.value$value, 
[17:36:44.704]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.704]                   ...future.rng), globalenv = if (FALSE) 
[17:36:44.704]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:44.704]                     ...future.globalenv.names))
[17:36:44.704]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:44.704]         }, condition = base::local({
[17:36:44.704]             c <- base::c
[17:36:44.704]             inherits <- base::inherits
[17:36:44.704]             invokeRestart <- base::invokeRestart
[17:36:44.704]             length <- base::length
[17:36:44.704]             list <- base::list
[17:36:44.704]             seq.int <- base::seq.int
[17:36:44.704]             signalCondition <- base::signalCondition
[17:36:44.704]             sys.calls <- base::sys.calls
[17:36:44.704]             `[[` <- base::`[[`
[17:36:44.704]             `+` <- base::`+`
[17:36:44.704]             `<<-` <- base::`<<-`
[17:36:44.704]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:44.704]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:44.704]                   3L)]
[17:36:44.704]             }
[17:36:44.704]             function(cond) {
[17:36:44.704]                 is_error <- inherits(cond, "error")
[17:36:44.704]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:44.704]                   NULL)
[17:36:44.704]                 if (is_error) {
[17:36:44.704]                   sessionInformation <- function() {
[17:36:44.704]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:44.704]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:44.704]                       search = base::search(), system = base::Sys.info())
[17:36:44.704]                   }
[17:36:44.704]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.704]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:44.704]                     cond$call), session = sessionInformation(), 
[17:36:44.704]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:44.704]                   signalCondition(cond)
[17:36:44.704]                 }
[17:36:44.704]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:44.704]                 "immediateCondition"))) {
[17:36:44.704]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:44.704]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.704]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:44.704]                   if (TRUE && !signal) {
[17:36:44.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.704]                     {
[17:36:44.704]                       inherits <- base::inherits
[17:36:44.704]                       invokeRestart <- base::invokeRestart
[17:36:44.704]                       is.null <- base::is.null
[17:36:44.704]                       muffled <- FALSE
[17:36:44.704]                       if (inherits(cond, "message")) {
[17:36:44.704]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.704]                         if (muffled) 
[17:36:44.704]                           invokeRestart("muffleMessage")
[17:36:44.704]                       }
[17:36:44.704]                       else if (inherits(cond, "warning")) {
[17:36:44.704]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.704]                         if (muffled) 
[17:36:44.704]                           invokeRestart("muffleWarning")
[17:36:44.704]                       }
[17:36:44.704]                       else if (inherits(cond, "condition")) {
[17:36:44.704]                         if (!is.null(pattern)) {
[17:36:44.704]                           computeRestarts <- base::computeRestarts
[17:36:44.704]                           grepl <- base::grepl
[17:36:44.704]                           restarts <- computeRestarts(cond)
[17:36:44.704]                           for (restart in restarts) {
[17:36:44.704]                             name <- restart$name
[17:36:44.704]                             if (is.null(name)) 
[17:36:44.704]                               next
[17:36:44.704]                             if (!grepl(pattern, name)) 
[17:36:44.704]                               next
[17:36:44.704]                             invokeRestart(restart)
[17:36:44.704]                             muffled <- TRUE
[17:36:44.704]                             break
[17:36:44.704]                           }
[17:36:44.704]                         }
[17:36:44.704]                       }
[17:36:44.704]                       invisible(muffled)
[17:36:44.704]                     }
[17:36:44.704]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.704]                   }
[17:36:44.704]                 }
[17:36:44.704]                 else {
[17:36:44.704]                   if (TRUE) {
[17:36:44.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.704]                     {
[17:36:44.704]                       inherits <- base::inherits
[17:36:44.704]                       invokeRestart <- base::invokeRestart
[17:36:44.704]                       is.null <- base::is.null
[17:36:44.704]                       muffled <- FALSE
[17:36:44.704]                       if (inherits(cond, "message")) {
[17:36:44.704]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.704]                         if (muffled) 
[17:36:44.704]                           invokeRestart("muffleMessage")
[17:36:44.704]                       }
[17:36:44.704]                       else if (inherits(cond, "warning")) {
[17:36:44.704]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.704]                         if (muffled) 
[17:36:44.704]                           invokeRestart("muffleWarning")
[17:36:44.704]                       }
[17:36:44.704]                       else if (inherits(cond, "condition")) {
[17:36:44.704]                         if (!is.null(pattern)) {
[17:36:44.704]                           computeRestarts <- base::computeRestarts
[17:36:44.704]                           grepl <- base::grepl
[17:36:44.704]                           restarts <- computeRestarts(cond)
[17:36:44.704]                           for (restart in restarts) {
[17:36:44.704]                             name <- restart$name
[17:36:44.704]                             if (is.null(name)) 
[17:36:44.704]                               next
[17:36:44.704]                             if (!grepl(pattern, name)) 
[17:36:44.704]                               next
[17:36:44.704]                             invokeRestart(restart)
[17:36:44.704]                             muffled <- TRUE
[17:36:44.704]                             break
[17:36:44.704]                           }
[17:36:44.704]                         }
[17:36:44.704]                       }
[17:36:44.704]                       invisible(muffled)
[17:36:44.704]                     }
[17:36:44.704]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.704]                   }
[17:36:44.704]                 }
[17:36:44.704]             }
[17:36:44.704]         }))
[17:36:44.704]     }, error = function(ex) {
[17:36:44.704]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:44.704]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.704]                 ...future.rng), started = ...future.startTime, 
[17:36:44.704]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:44.704]             version = "1.8"), class = "FutureResult")
[17:36:44.704]     }, finally = {
[17:36:44.704]         if (!identical(...future.workdir, getwd())) 
[17:36:44.704]             setwd(...future.workdir)
[17:36:44.704]         {
[17:36:44.704]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:44.704]                 ...future.oldOptions$nwarnings <- NULL
[17:36:44.704]             }
[17:36:44.704]             base::options(...future.oldOptions)
[17:36:44.704]             if (.Platform$OS.type == "windows") {
[17:36:44.704]                 old_names <- names(...future.oldEnvVars)
[17:36:44.704]                 envs <- base::Sys.getenv()
[17:36:44.704]                 names <- names(envs)
[17:36:44.704]                 common <- intersect(names, old_names)
[17:36:44.704]                 added <- setdiff(names, old_names)
[17:36:44.704]                 removed <- setdiff(old_names, names)
[17:36:44.704]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:44.704]                   envs[common]]
[17:36:44.704]                 NAMES <- toupper(changed)
[17:36:44.704]                 args <- list()
[17:36:44.704]                 for (kk in seq_along(NAMES)) {
[17:36:44.704]                   name <- changed[[kk]]
[17:36:44.704]                   NAME <- NAMES[[kk]]
[17:36:44.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.704]                     next
[17:36:44.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.704]                 }
[17:36:44.704]                 NAMES <- toupper(added)
[17:36:44.704]                 for (kk in seq_along(NAMES)) {
[17:36:44.704]                   name <- added[[kk]]
[17:36:44.704]                   NAME <- NAMES[[kk]]
[17:36:44.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.704]                     next
[17:36:44.704]                   args[[name]] <- ""
[17:36:44.704]                 }
[17:36:44.704]                 NAMES <- toupper(removed)
[17:36:44.704]                 for (kk in seq_along(NAMES)) {
[17:36:44.704]                   name <- removed[[kk]]
[17:36:44.704]                   NAME <- NAMES[[kk]]
[17:36:44.704]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.704]                     next
[17:36:44.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.704]                 }
[17:36:44.704]                 if (length(args) > 0) 
[17:36:44.704]                   base::do.call(base::Sys.setenv, args = args)
[17:36:44.704]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:44.704]             }
[17:36:44.704]             else {
[17:36:44.704]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:44.704]             }
[17:36:44.704]             {
[17:36:44.704]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:44.704]                   0L) {
[17:36:44.704]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:44.704]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:44.704]                   base::options(opts)
[17:36:44.704]                 }
[17:36:44.704]                 {
[17:36:44.704]                   {
[17:36:44.704]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:44.704]                     NULL
[17:36:44.704]                   }
[17:36:44.704]                   options(future.plan = NULL)
[17:36:44.704]                   if (is.na(NA_character_)) 
[17:36:44.704]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.704]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:44.704]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:44.704]                     .init = FALSE)
[17:36:44.704]                 }
[17:36:44.704]             }
[17:36:44.704]         }
[17:36:44.704]     })
[17:36:44.704]     if (TRUE) {
[17:36:44.704]         base::sink(type = "output", split = FALSE)
[17:36:44.704]         if (TRUE) {
[17:36:44.704]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:44.704]         }
[17:36:44.704]         else {
[17:36:44.704]             ...future.result["stdout"] <- base::list(NULL)
[17:36:44.704]         }
[17:36:44.704]         base::close(...future.stdout)
[17:36:44.704]         ...future.stdout <- NULL
[17:36:44.704]     }
[17:36:44.704]     ...future.result$conditions <- ...future.conditions
[17:36:44.704]     ...future.result$finished <- base::Sys.time()
[17:36:44.704]     ...future.result
[17:36:44.704] }
[17:36:44.707] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[17:36:44.707] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:36:44.708] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:36:44.708] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[17:36:44.708] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[17:36:44.709] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:36:44.709] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:36:44.709] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:44.709] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:44.709] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:36:44.710] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:36:44.710] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[17:36:44.710] MultisessionFuture started
[17:36:44.710] - Launch lazy future ... done
[17:36:44.710] run() for ‘MultisessionFuture’ ... done
[17:36:44.711] Created future:
[17:36:44.711] MultisessionFuture:
[17:36:44.711] Label: ‘future_eapply-2’
[17:36:44.711] Expression:
[17:36:44.711] {
[17:36:44.711]     do.call(function(...) {
[17:36:44.711]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.711]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.711]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.711]             on.exit(options(oopts), add = TRUE)
[17:36:44.711]         }
[17:36:44.711]         {
[17:36:44.711]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.711]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.711]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.711]             })
[17:36:44.711]         }
[17:36:44.711]     }, args = future.call.arguments)
[17:36:44.711] }
[17:36:44.711] Lazy evaluation: FALSE
[17:36:44.711] Asynchronous evaluation: TRUE
[17:36:44.711] Local evaluation: TRUE
[17:36:44.711] Environment: R_GlobalEnv
[17:36:44.711] Capture standard output: TRUE
[17:36:44.711] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:44.711] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:44.711] Packages: 1 packages (‘stats’)
[17:36:44.711] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:44.711] Resolved: FALSE
[17:36:44.711] Value: <not collected>
[17:36:44.711] Conditions captured: <none>
[17:36:44.711] Early signaling: FALSE
[17:36:44.711] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:44.711] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.722] Chunk #2 of 2 ... DONE
[17:36:44.722] Launching 2 futures (chunks) ... DONE
[17:36:44.722] Resolving 2 futures (chunks) ...
[17:36:44.722] resolve() on list ...
[17:36:44.723]  recursive: 0
[17:36:44.723]  length: 2
[17:36:44.723] 
[17:36:44.723] receiveMessageFromWorker() for ClusterFuture ...
[17:36:44.723] - Validating connection of MultisessionFuture
[17:36:44.723] - received message: FutureResult
[17:36:44.724] - Received FutureResult
[17:36:44.724] - Erased future from FutureRegistry
[17:36:44.724] result() for ClusterFuture ...
[17:36:44.724] - result already collected: FutureResult
[17:36:44.724] result() for ClusterFuture ... done
[17:36:44.724] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:44.724] Future #1
[17:36:44.724] result() for ClusterFuture ...
[17:36:44.724] - result already collected: FutureResult
[17:36:44.724] result() for ClusterFuture ... done
[17:36:44.725] result() for ClusterFuture ...
[17:36:44.725] - result already collected: FutureResult
[17:36:44.725] result() for ClusterFuture ... done
[17:36:44.725] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:44.725] - nx: 2
[17:36:44.725] - relay: TRUE
[17:36:44.725] - stdout: TRUE
[17:36:44.725] - signal: TRUE
[17:36:44.725] - resignal: FALSE
[17:36:44.725] - force: TRUE
[17:36:44.725] - relayed: [n=2] FALSE, FALSE
[17:36:44.725] - queued futures: [n=2] FALSE, FALSE
[17:36:44.726]  - until=1
[17:36:44.726]  - relaying element #1
[17:36:44.726] result() for ClusterFuture ...
[17:36:44.726] - result already collected: FutureResult
[17:36:44.726] result() for ClusterFuture ... done
[17:36:44.726] result() for ClusterFuture ...
[17:36:44.726] - result already collected: FutureResult
[17:36:44.726] result() for ClusterFuture ... done
[17:36:44.726] result() for ClusterFuture ...
[17:36:44.726] - result already collected: FutureResult
[17:36:44.726] result() for ClusterFuture ... done
[17:36:44.726] result() for ClusterFuture ...
[17:36:44.727] - result already collected: FutureResult
[17:36:44.727] result() for ClusterFuture ... done
[17:36:44.727] - relayed: [n=2] TRUE, FALSE
[17:36:44.727] - queued futures: [n=2] TRUE, FALSE
[17:36:44.727] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:44.727]  length: 1 (resolved future 1)
[17:36:44.769] receiveMessageFromWorker() for ClusterFuture ...
[17:36:44.769] - Validating connection of MultisessionFuture
[17:36:44.769] - received message: FutureResult
[17:36:44.769] - Received FutureResult
[17:36:44.769] - Erased future from FutureRegistry
[17:36:44.769] result() for ClusterFuture ...
[17:36:44.769] - result already collected: FutureResult
[17:36:44.770] result() for ClusterFuture ... done
[17:36:44.770] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:44.770] Future #2
[17:36:44.770] result() for ClusterFuture ...
[17:36:44.770] - result already collected: FutureResult
[17:36:44.770] result() for ClusterFuture ... done
[17:36:44.770] result() for ClusterFuture ...
[17:36:44.770] - result already collected: FutureResult
[17:36:44.770] result() for ClusterFuture ... done
[17:36:44.770] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:44.770] - nx: 2
[17:36:44.770] - relay: TRUE
[17:36:44.771] - stdout: TRUE
[17:36:44.771] - signal: TRUE
[17:36:44.771] - resignal: FALSE
[17:36:44.771] - force: TRUE
[17:36:44.771] - relayed: [n=2] TRUE, FALSE
[17:36:44.771] - queued futures: [n=2] TRUE, FALSE
[17:36:44.771]  - until=2
[17:36:44.771]  - relaying element #2
[17:36:44.771] result() for ClusterFuture ...
[17:36:44.771] - result already collected: FutureResult
[17:36:44.771] result() for ClusterFuture ... done
[17:36:44.772] result() for ClusterFuture ...
[17:36:44.772] - result already collected: FutureResult
[17:36:44.772] result() for ClusterFuture ... done
[17:36:44.772] result() for ClusterFuture ...
[17:36:44.772] - result already collected: FutureResult
[17:36:44.772] result() for ClusterFuture ... done
[17:36:44.772] result() for ClusterFuture ...
[17:36:44.772] - result already collected: FutureResult
[17:36:44.772] result() for ClusterFuture ... done
[17:36:44.772] - relayed: [n=2] TRUE, TRUE
[17:36:44.772] - queued futures: [n=2] TRUE, TRUE
[17:36:44.773] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:44.773]  length: 0 (resolved future 2)
[17:36:44.773] Relaying remaining futures
[17:36:44.773] signalConditionsASAP(NULL, pos=0) ...
[17:36:44.773] - nx: 2
[17:36:44.773] - relay: TRUE
[17:36:44.773] - stdout: TRUE
[17:36:44.773] - signal: TRUE
[17:36:44.773] - resignal: FALSE
[17:36:44.773] - force: TRUE
[17:36:44.773] - relayed: [n=2] TRUE, TRUE
[17:36:44.774] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:44.774] - relayed: [n=2] TRUE, TRUE
[17:36:44.774] - queued futures: [n=2] TRUE, TRUE
[17:36:44.774] signalConditionsASAP(NULL, pos=0) ... done
[17:36:44.774] resolve() on list ... DONE
[17:36:44.774] result() for ClusterFuture ...
[17:36:44.774] - result already collected: FutureResult
[17:36:44.774] result() for ClusterFuture ... done
[17:36:44.774] result() for ClusterFuture ...
[17:36:44.774] - result already collected: FutureResult
[17:36:44.774] result() for ClusterFuture ... done
[17:36:44.775] result() for ClusterFuture ...
[17:36:44.775] - result already collected: FutureResult
[17:36:44.775] result() for ClusterFuture ... done
[17:36:44.775] result() for ClusterFuture ...
[17:36:44.775] - result already collected: FutureResult
[17:36:44.775] result() for ClusterFuture ... done
[17:36:44.775]  - Number of value chunks collected: 2
[17:36:44.775] Resolving 2 futures (chunks) ... DONE
[17:36:44.775] Reducing values from 2 chunks ...
[17:36:44.775]  - Number of values collected after concatenation: 3
[17:36:44.775]  - Number of values expected: 3
[17:36:44.775] Reducing values from 2 chunks ... DONE
[17:36:44.776] future_lapply() ... DONE
[17:36:44.776] future_lapply() ...
[17:36:44.781] Number of chunks: 2
[17:36:44.781] getGlobalsAndPackagesXApply() ...
[17:36:44.781]  - future.globals: TRUE
[17:36:44.781] getGlobalsAndPackages() ...
[17:36:44.781] Searching for globals...
[17:36:44.782] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:44.782] Searching for globals ... DONE
[17:36:44.782] Resolving globals: FALSE
[17:36:44.783] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:44.783] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:44.783] - globals: [1] ‘FUN’
[17:36:44.783] - packages: [1] ‘stats’
[17:36:44.784] getGlobalsAndPackages() ... DONE
[17:36:44.784]  - globals found/used: [n=1] ‘FUN’
[17:36:44.784]  - needed namespaces: [n=1] ‘stats’
[17:36:44.784] Finding globals ... DONE
[17:36:44.784]  - use_args: TRUE
[17:36:44.784]  - Getting '...' globals ...
[17:36:44.784] resolve() on list ...
[17:36:44.784]  recursive: 0
[17:36:44.785]  length: 1
[17:36:44.785]  elements: ‘...’
[17:36:44.785]  length: 0 (resolved future 1)
[17:36:44.785] resolve() on list ... DONE
[17:36:44.785]    - '...' content: [n=0] 
[17:36:44.785] List of 1
[17:36:44.785]  $ ...: list()
[17:36:44.785]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:44.785]  - attr(*, "where")=List of 1
[17:36:44.785]   ..$ ...:<environment: 0x5655068e05e8> 
[17:36:44.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:44.785]  - attr(*, "resolved")= logi TRUE
[17:36:44.785]  - attr(*, "total_size")= num NA
[17:36:44.787]  - Getting '...' globals ... DONE
[17:36:44.788] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:44.793] List of 2
[17:36:44.793]  $ ...future.FUN:function (x, ...)  
[17:36:44.793]  $ ...          : list()
[17:36:44.793]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:44.793]  - attr(*, "where")=List of 2
[17:36:44.793]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:44.793]   ..$ ...          :<environment: 0x5655068e05e8> 
[17:36:44.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:44.793]  - attr(*, "resolved")= logi FALSE
[17:36:44.793]  - attr(*, "total_size")= num 1248
[17:36:44.795] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:44.795] getGlobalsAndPackagesXApply() ... DONE
[17:36:44.796] Number of futures (= number of chunks): 2
[17:36:44.796] Launching 2 futures (chunks) ...
[17:36:44.796] Chunk #1 of 2 ...
[17:36:44.796]  - Finding globals in 'X' for chunk #1 ...
[17:36:44.796] getGlobalsAndPackages() ...
[17:36:44.796] Searching for globals...
[17:36:44.796] 
[17:36:44.797] Searching for globals ... DONE
[17:36:44.797] - globals: [0] <none>
[17:36:44.797] getGlobalsAndPackages() ... DONE
[17:36:44.797]    + additional globals found: [n=0] 
[17:36:44.797]    + additional namespaces needed: [n=0] 
[17:36:44.797]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:44.797]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:44.797]  - seeds: <none>
[17:36:44.797]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.797] getGlobalsAndPackages() ...
[17:36:44.797] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.798] Resolving globals: FALSE
[17:36:44.798] Tweak future expression to call with '...' arguments ...
[17:36:44.798] {
[17:36:44.798]     do.call(function(...) {
[17:36:44.798]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.798]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.798]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.798]             on.exit(options(oopts), add = TRUE)
[17:36:44.798]         }
[17:36:44.798]         {
[17:36:44.798]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.798]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.798]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.798]             })
[17:36:44.798]         }
[17:36:44.798]     }, args = future.call.arguments)
[17:36:44.798] }
[17:36:44.798] Tweak future expression to call with '...' arguments ... DONE
[17:36:44.798] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.798] - packages: [1] ‘stats’
[17:36:44.799] getGlobalsAndPackages() ... DONE
[17:36:44.799] run() for ‘Future’ ...
[17:36:44.799] - state: ‘created’
[17:36:44.799] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:44.813] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:44.813]   - Field: ‘node’
[17:36:44.813]   - Field: ‘label’
[17:36:44.813]   - Field: ‘local’
[17:36:44.813]   - Field: ‘owner’
[17:36:44.814]   - Field: ‘envir’
[17:36:44.814]   - Field: ‘workers’
[17:36:44.814]   - Field: ‘packages’
[17:36:44.814]   - Field: ‘gc’
[17:36:44.814]   - Field: ‘conditions’
[17:36:44.814]   - Field: ‘persistent’
[17:36:44.814]   - Field: ‘expr’
[17:36:44.814]   - Field: ‘uuid’
[17:36:44.814]   - Field: ‘seed’
[17:36:44.814]   - Field: ‘version’
[17:36:44.814]   - Field: ‘result’
[17:36:44.814]   - Field: ‘asynchronous’
[17:36:44.815]   - Field: ‘calls’
[17:36:44.815]   - Field: ‘globals’
[17:36:44.815]   - Field: ‘stdout’
[17:36:44.815]   - Field: ‘earlySignal’
[17:36:44.815]   - Field: ‘lazy’
[17:36:44.815]   - Field: ‘state’
[17:36:44.815] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:44.815] - Launch lazy future ...
[17:36:44.815] Packages needed by the future expression (n = 1): ‘stats’
[17:36:44.815] Packages needed by future strategies (n = 0): <none>
[17:36:44.816] {
[17:36:44.816]     {
[17:36:44.816]         {
[17:36:44.816]             ...future.startTime <- base::Sys.time()
[17:36:44.816]             {
[17:36:44.816]                 {
[17:36:44.816]                   {
[17:36:44.816]                     {
[17:36:44.816]                       {
[17:36:44.816]                         base::local({
[17:36:44.816]                           has_future <- base::requireNamespace("future", 
[17:36:44.816]                             quietly = TRUE)
[17:36:44.816]                           if (has_future) {
[17:36:44.816]                             ns <- base::getNamespace("future")
[17:36:44.816]                             version <- ns[[".package"]][["version"]]
[17:36:44.816]                             if (is.null(version)) 
[17:36:44.816]                               version <- utils::packageVersion("future")
[17:36:44.816]                           }
[17:36:44.816]                           else {
[17:36:44.816]                             version <- NULL
[17:36:44.816]                           }
[17:36:44.816]                           if (!has_future || version < "1.8.0") {
[17:36:44.816]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:44.816]                               "", base::R.version$version.string), 
[17:36:44.816]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:44.816]                                 base::R.version$platform, 8 * 
[17:36:44.816]                                   base::.Machine$sizeof.pointer), 
[17:36:44.816]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:44.816]                                 "release", "version")], collapse = " "), 
[17:36:44.816]                               hostname = base::Sys.info()[["nodename"]])
[17:36:44.816]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:44.816]                               info)
[17:36:44.816]                             info <- base::paste(info, collapse = "; ")
[17:36:44.816]                             if (!has_future) {
[17:36:44.816]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:44.816]                                 info)
[17:36:44.816]                             }
[17:36:44.816]                             else {
[17:36:44.816]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:44.816]                                 info, version)
[17:36:44.816]                             }
[17:36:44.816]                             base::stop(msg)
[17:36:44.816]                           }
[17:36:44.816]                         })
[17:36:44.816]                       }
[17:36:44.816]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:44.816]                       base::options(mc.cores = 1L)
[17:36:44.816]                     }
[17:36:44.816]                     base::local({
[17:36:44.816]                       for (pkg in "stats") {
[17:36:44.816]                         base::loadNamespace(pkg)
[17:36:44.816]                         base::library(pkg, character.only = TRUE)
[17:36:44.816]                       }
[17:36:44.816]                     })
[17:36:44.816]                   }
[17:36:44.816]                   ...future.strategy.old <- future::plan("list")
[17:36:44.816]                   options(future.plan = NULL)
[17:36:44.816]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.816]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:44.816]                 }
[17:36:44.816]                 ...future.workdir <- getwd()
[17:36:44.816]             }
[17:36:44.816]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:44.816]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:44.816]         }
[17:36:44.816]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:44.816]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:44.816]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:44.816]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:44.816]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:44.816]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:44.816]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:44.816]             base::names(...future.oldOptions))
[17:36:44.816]     }
[17:36:44.816]     if (FALSE) {
[17:36:44.816]     }
[17:36:44.816]     else {
[17:36:44.816]         if (TRUE) {
[17:36:44.816]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:44.816]                 open = "w")
[17:36:44.816]         }
[17:36:44.816]         else {
[17:36:44.816]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:44.816]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:44.816]         }
[17:36:44.816]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:44.816]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:44.816]             base::sink(type = "output", split = FALSE)
[17:36:44.816]             base::close(...future.stdout)
[17:36:44.816]         }, add = TRUE)
[17:36:44.816]     }
[17:36:44.816]     ...future.frame <- base::sys.nframe()
[17:36:44.816]     ...future.conditions <- base::list()
[17:36:44.816]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:44.816]     if (FALSE) {
[17:36:44.816]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:44.816]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:44.816]     }
[17:36:44.816]     ...future.result <- base::tryCatch({
[17:36:44.816]         base::withCallingHandlers({
[17:36:44.816]             ...future.value <- base::withVisible(base::local({
[17:36:44.816]                 ...future.makeSendCondition <- base::local({
[17:36:44.816]                   sendCondition <- NULL
[17:36:44.816]                   function(frame = 1L) {
[17:36:44.816]                     if (is.function(sendCondition)) 
[17:36:44.816]                       return(sendCondition)
[17:36:44.816]                     ns <- getNamespace("parallel")
[17:36:44.816]                     if (exists("sendData", mode = "function", 
[17:36:44.816]                       envir = ns)) {
[17:36:44.816]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:44.816]                         envir = ns)
[17:36:44.816]                       envir <- sys.frame(frame)
[17:36:44.816]                       master <- NULL
[17:36:44.816]                       while (!identical(envir, .GlobalEnv) && 
[17:36:44.816]                         !identical(envir, emptyenv())) {
[17:36:44.816]                         if (exists("master", mode = "list", envir = envir, 
[17:36:44.816]                           inherits = FALSE)) {
[17:36:44.816]                           master <- get("master", mode = "list", 
[17:36:44.816]                             envir = envir, inherits = FALSE)
[17:36:44.816]                           if (inherits(master, c("SOCKnode", 
[17:36:44.816]                             "SOCK0node"))) {
[17:36:44.816]                             sendCondition <<- function(cond) {
[17:36:44.816]                               data <- list(type = "VALUE", value = cond, 
[17:36:44.816]                                 success = TRUE)
[17:36:44.816]                               parallel_sendData(master, data)
[17:36:44.816]                             }
[17:36:44.816]                             return(sendCondition)
[17:36:44.816]                           }
[17:36:44.816]                         }
[17:36:44.816]                         frame <- frame + 1L
[17:36:44.816]                         envir <- sys.frame(frame)
[17:36:44.816]                       }
[17:36:44.816]                     }
[17:36:44.816]                     sendCondition <<- function(cond) NULL
[17:36:44.816]                   }
[17:36:44.816]                 })
[17:36:44.816]                 withCallingHandlers({
[17:36:44.816]                   {
[17:36:44.816]                     do.call(function(...) {
[17:36:44.816]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.816]                       if (!identical(...future.globals.maxSize.org, 
[17:36:44.816]                         ...future.globals.maxSize)) {
[17:36:44.816]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.816]                         on.exit(options(oopts), add = TRUE)
[17:36:44.816]                       }
[17:36:44.816]                       {
[17:36:44.816]                         lapply(seq_along(...future.elements_ii), 
[17:36:44.816]                           FUN = function(jj) {
[17:36:44.816]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.816]                             ...future.FUN(...future.X_jj, ...)
[17:36:44.816]                           })
[17:36:44.816]                       }
[17:36:44.816]                     }, args = future.call.arguments)
[17:36:44.816]                   }
[17:36:44.816]                 }, immediateCondition = function(cond) {
[17:36:44.816]                   sendCondition <- ...future.makeSendCondition()
[17:36:44.816]                   sendCondition(cond)
[17:36:44.816]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.816]                   {
[17:36:44.816]                     inherits <- base::inherits
[17:36:44.816]                     invokeRestart <- base::invokeRestart
[17:36:44.816]                     is.null <- base::is.null
[17:36:44.816]                     muffled <- FALSE
[17:36:44.816]                     if (inherits(cond, "message")) {
[17:36:44.816]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:44.816]                       if (muffled) 
[17:36:44.816]                         invokeRestart("muffleMessage")
[17:36:44.816]                     }
[17:36:44.816]                     else if (inherits(cond, "warning")) {
[17:36:44.816]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:44.816]                       if (muffled) 
[17:36:44.816]                         invokeRestart("muffleWarning")
[17:36:44.816]                     }
[17:36:44.816]                     else if (inherits(cond, "condition")) {
[17:36:44.816]                       if (!is.null(pattern)) {
[17:36:44.816]                         computeRestarts <- base::computeRestarts
[17:36:44.816]                         grepl <- base::grepl
[17:36:44.816]                         restarts <- computeRestarts(cond)
[17:36:44.816]                         for (restart in restarts) {
[17:36:44.816]                           name <- restart$name
[17:36:44.816]                           if (is.null(name)) 
[17:36:44.816]                             next
[17:36:44.816]                           if (!grepl(pattern, name)) 
[17:36:44.816]                             next
[17:36:44.816]                           invokeRestart(restart)
[17:36:44.816]                           muffled <- TRUE
[17:36:44.816]                           break
[17:36:44.816]                         }
[17:36:44.816]                       }
[17:36:44.816]                     }
[17:36:44.816]                     invisible(muffled)
[17:36:44.816]                   }
[17:36:44.816]                   muffleCondition(cond)
[17:36:44.816]                 })
[17:36:44.816]             }))
[17:36:44.816]             future::FutureResult(value = ...future.value$value, 
[17:36:44.816]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.816]                   ...future.rng), globalenv = if (FALSE) 
[17:36:44.816]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:44.816]                     ...future.globalenv.names))
[17:36:44.816]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:44.816]         }, condition = base::local({
[17:36:44.816]             c <- base::c
[17:36:44.816]             inherits <- base::inherits
[17:36:44.816]             invokeRestart <- base::invokeRestart
[17:36:44.816]             length <- base::length
[17:36:44.816]             list <- base::list
[17:36:44.816]             seq.int <- base::seq.int
[17:36:44.816]             signalCondition <- base::signalCondition
[17:36:44.816]             sys.calls <- base::sys.calls
[17:36:44.816]             `[[` <- base::`[[`
[17:36:44.816]             `+` <- base::`+`
[17:36:44.816]             `<<-` <- base::`<<-`
[17:36:44.816]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:44.816]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:44.816]                   3L)]
[17:36:44.816]             }
[17:36:44.816]             function(cond) {
[17:36:44.816]                 is_error <- inherits(cond, "error")
[17:36:44.816]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:44.816]                   NULL)
[17:36:44.816]                 if (is_error) {
[17:36:44.816]                   sessionInformation <- function() {
[17:36:44.816]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:44.816]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:44.816]                       search = base::search(), system = base::Sys.info())
[17:36:44.816]                   }
[17:36:44.816]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.816]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:44.816]                     cond$call), session = sessionInformation(), 
[17:36:44.816]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:44.816]                   signalCondition(cond)
[17:36:44.816]                 }
[17:36:44.816]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:44.816]                 "immediateCondition"))) {
[17:36:44.816]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:44.816]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.816]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:44.816]                   if (TRUE && !signal) {
[17:36:44.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.816]                     {
[17:36:44.816]                       inherits <- base::inherits
[17:36:44.816]                       invokeRestart <- base::invokeRestart
[17:36:44.816]                       is.null <- base::is.null
[17:36:44.816]                       muffled <- FALSE
[17:36:44.816]                       if (inherits(cond, "message")) {
[17:36:44.816]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.816]                         if (muffled) 
[17:36:44.816]                           invokeRestart("muffleMessage")
[17:36:44.816]                       }
[17:36:44.816]                       else if (inherits(cond, "warning")) {
[17:36:44.816]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.816]                         if (muffled) 
[17:36:44.816]                           invokeRestart("muffleWarning")
[17:36:44.816]                       }
[17:36:44.816]                       else if (inherits(cond, "condition")) {
[17:36:44.816]                         if (!is.null(pattern)) {
[17:36:44.816]                           computeRestarts <- base::computeRestarts
[17:36:44.816]                           grepl <- base::grepl
[17:36:44.816]                           restarts <- computeRestarts(cond)
[17:36:44.816]                           for (restart in restarts) {
[17:36:44.816]                             name <- restart$name
[17:36:44.816]                             if (is.null(name)) 
[17:36:44.816]                               next
[17:36:44.816]                             if (!grepl(pattern, name)) 
[17:36:44.816]                               next
[17:36:44.816]                             invokeRestart(restart)
[17:36:44.816]                             muffled <- TRUE
[17:36:44.816]                             break
[17:36:44.816]                           }
[17:36:44.816]                         }
[17:36:44.816]                       }
[17:36:44.816]                       invisible(muffled)
[17:36:44.816]                     }
[17:36:44.816]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.816]                   }
[17:36:44.816]                 }
[17:36:44.816]                 else {
[17:36:44.816]                   if (TRUE) {
[17:36:44.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.816]                     {
[17:36:44.816]                       inherits <- base::inherits
[17:36:44.816]                       invokeRestart <- base::invokeRestart
[17:36:44.816]                       is.null <- base::is.null
[17:36:44.816]                       muffled <- FALSE
[17:36:44.816]                       if (inherits(cond, "message")) {
[17:36:44.816]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.816]                         if (muffled) 
[17:36:44.816]                           invokeRestart("muffleMessage")
[17:36:44.816]                       }
[17:36:44.816]                       else if (inherits(cond, "warning")) {
[17:36:44.816]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.816]                         if (muffled) 
[17:36:44.816]                           invokeRestart("muffleWarning")
[17:36:44.816]                       }
[17:36:44.816]                       else if (inherits(cond, "condition")) {
[17:36:44.816]                         if (!is.null(pattern)) {
[17:36:44.816]                           computeRestarts <- base::computeRestarts
[17:36:44.816]                           grepl <- base::grepl
[17:36:44.816]                           restarts <- computeRestarts(cond)
[17:36:44.816]                           for (restart in restarts) {
[17:36:44.816]                             name <- restart$name
[17:36:44.816]                             if (is.null(name)) 
[17:36:44.816]                               next
[17:36:44.816]                             if (!grepl(pattern, name)) 
[17:36:44.816]                               next
[17:36:44.816]                             invokeRestart(restart)
[17:36:44.816]                             muffled <- TRUE
[17:36:44.816]                             break
[17:36:44.816]                           }
[17:36:44.816]                         }
[17:36:44.816]                       }
[17:36:44.816]                       invisible(muffled)
[17:36:44.816]                     }
[17:36:44.816]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.816]                   }
[17:36:44.816]                 }
[17:36:44.816]             }
[17:36:44.816]         }))
[17:36:44.816]     }, error = function(ex) {
[17:36:44.816]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:44.816]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.816]                 ...future.rng), started = ...future.startTime, 
[17:36:44.816]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:44.816]             version = "1.8"), class = "FutureResult")
[17:36:44.816]     }, finally = {
[17:36:44.816]         if (!identical(...future.workdir, getwd())) 
[17:36:44.816]             setwd(...future.workdir)
[17:36:44.816]         {
[17:36:44.816]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:44.816]                 ...future.oldOptions$nwarnings <- NULL
[17:36:44.816]             }
[17:36:44.816]             base::options(...future.oldOptions)
[17:36:44.816]             if (.Platform$OS.type == "windows") {
[17:36:44.816]                 old_names <- names(...future.oldEnvVars)
[17:36:44.816]                 envs <- base::Sys.getenv()
[17:36:44.816]                 names <- names(envs)
[17:36:44.816]                 common <- intersect(names, old_names)
[17:36:44.816]                 added <- setdiff(names, old_names)
[17:36:44.816]                 removed <- setdiff(old_names, names)
[17:36:44.816]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:44.816]                   envs[common]]
[17:36:44.816]                 NAMES <- toupper(changed)
[17:36:44.816]                 args <- list()
[17:36:44.816]                 for (kk in seq_along(NAMES)) {
[17:36:44.816]                   name <- changed[[kk]]
[17:36:44.816]                   NAME <- NAMES[[kk]]
[17:36:44.816]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.816]                     next
[17:36:44.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.816]                 }
[17:36:44.816]                 NAMES <- toupper(added)
[17:36:44.816]                 for (kk in seq_along(NAMES)) {
[17:36:44.816]                   name <- added[[kk]]
[17:36:44.816]                   NAME <- NAMES[[kk]]
[17:36:44.816]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.816]                     next
[17:36:44.816]                   args[[name]] <- ""
[17:36:44.816]                 }
[17:36:44.816]                 NAMES <- toupper(removed)
[17:36:44.816]                 for (kk in seq_along(NAMES)) {
[17:36:44.816]                   name <- removed[[kk]]
[17:36:44.816]                   NAME <- NAMES[[kk]]
[17:36:44.816]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.816]                     next
[17:36:44.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.816]                 }
[17:36:44.816]                 if (length(args) > 0) 
[17:36:44.816]                   base::do.call(base::Sys.setenv, args = args)
[17:36:44.816]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:44.816]             }
[17:36:44.816]             else {
[17:36:44.816]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:44.816]             }
[17:36:44.816]             {
[17:36:44.816]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:44.816]                   0L) {
[17:36:44.816]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:44.816]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:44.816]                   base::options(opts)
[17:36:44.816]                 }
[17:36:44.816]                 {
[17:36:44.816]                   {
[17:36:44.816]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:44.816]                     NULL
[17:36:44.816]                   }
[17:36:44.816]                   options(future.plan = NULL)
[17:36:44.816]                   if (is.na(NA_character_)) 
[17:36:44.816]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.816]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:44.816]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:44.816]                     .init = FALSE)
[17:36:44.816]                 }
[17:36:44.816]             }
[17:36:44.816]         }
[17:36:44.816]     })
[17:36:44.816]     if (TRUE) {
[17:36:44.816]         base::sink(type = "output", split = FALSE)
[17:36:44.816]         if (TRUE) {
[17:36:44.816]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:44.816]         }
[17:36:44.816]         else {
[17:36:44.816]             ...future.result["stdout"] <- base::list(NULL)
[17:36:44.816]         }
[17:36:44.816]         base::close(...future.stdout)
[17:36:44.816]         ...future.stdout <- NULL
[17:36:44.816]     }
[17:36:44.816]     ...future.result$conditions <- ...future.conditions
[17:36:44.816]     ...future.result$finished <- base::Sys.time()
[17:36:44.816]     ...future.result
[17:36:44.816] }
[17:36:44.819] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[17:36:44.819] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:36:44.819] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:36:44.820] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:44.820] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:44.820] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:36:44.820] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:36:44.821] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:44.821] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:44.821] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:36:44.821] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:36:44.822] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[17:36:44.822] MultisessionFuture started
[17:36:44.822] - Launch lazy future ... done
[17:36:44.822] run() for ‘MultisessionFuture’ ... done
[17:36:44.823] Created future:
[17:36:44.823] MultisessionFuture:
[17:36:44.823] Label: ‘future_eapply-1’
[17:36:44.823] Expression:
[17:36:44.823] {
[17:36:44.823]     do.call(function(...) {
[17:36:44.823]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.823]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.823]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.823]             on.exit(options(oopts), add = TRUE)
[17:36:44.823]         }
[17:36:44.823]         {
[17:36:44.823]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.823]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.823]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.823]             })
[17:36:44.823]         }
[17:36:44.823]     }, args = future.call.arguments)
[17:36:44.823] }
[17:36:44.823] Lazy evaluation: FALSE
[17:36:44.823] Asynchronous evaluation: TRUE
[17:36:44.823] Local evaluation: TRUE
[17:36:44.823] Environment: R_GlobalEnv
[17:36:44.823] Capture standard output: TRUE
[17:36:44.823] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:44.823] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:44.823] Packages: 1 packages (‘stats’)
[17:36:44.823] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:44.823] Resolved: FALSE
[17:36:44.823] Value: <not collected>
[17:36:44.823] Conditions captured: <none>
[17:36:44.823] Early signaling: FALSE
[17:36:44.823] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:44.823] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.834] Chunk #1 of 2 ... DONE
[17:36:44.834] Chunk #2 of 2 ...
[17:36:44.834]  - Finding globals in 'X' for chunk #2 ...
[17:36:44.834] getGlobalsAndPackages() ...
[17:36:44.834] Searching for globals...
[17:36:44.835] 
[17:36:44.835] Searching for globals ... DONE
[17:36:44.835] - globals: [0] <none>
[17:36:44.835] getGlobalsAndPackages() ... DONE
[17:36:44.835]    + additional globals found: [n=0] 
[17:36:44.835]    + additional namespaces needed: [n=0] 
[17:36:44.835]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:44.835]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:44.835]  - seeds: <none>
[17:36:44.835]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.836] getGlobalsAndPackages() ...
[17:36:44.836] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.836] Resolving globals: FALSE
[17:36:44.836] Tweak future expression to call with '...' arguments ...
[17:36:44.836] {
[17:36:44.836]     do.call(function(...) {
[17:36:44.836]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.836]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.836]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.836]             on.exit(options(oopts), add = TRUE)
[17:36:44.836]         }
[17:36:44.836]         {
[17:36:44.836]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.836]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.836]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.836]             })
[17:36:44.836]         }
[17:36:44.836]     }, args = future.call.arguments)
[17:36:44.836] }
[17:36:44.836] Tweak future expression to call with '...' arguments ... DONE
[17:36:44.837] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.837] - packages: [1] ‘stats’
[17:36:44.837] getGlobalsAndPackages() ... DONE
[17:36:44.837] run() for ‘Future’ ...
[17:36:44.837] - state: ‘created’
[17:36:44.837] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:44.852] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:44.853]   - Field: ‘node’
[17:36:44.853]   - Field: ‘label’
[17:36:44.853]   - Field: ‘local’
[17:36:44.853]   - Field: ‘owner’
[17:36:44.853]   - Field: ‘envir’
[17:36:44.853]   - Field: ‘workers’
[17:36:44.853]   - Field: ‘packages’
[17:36:44.853]   - Field: ‘gc’
[17:36:44.853]   - Field: ‘conditions’
[17:36:44.854]   - Field: ‘persistent’
[17:36:44.854]   - Field: ‘expr’
[17:36:44.854]   - Field: ‘uuid’
[17:36:44.854]   - Field: ‘seed’
[17:36:44.854]   - Field: ‘version’
[17:36:44.854]   - Field: ‘result’
[17:36:44.854]   - Field: ‘asynchronous’
[17:36:44.854]   - Field: ‘calls’
[17:36:44.854]   - Field: ‘globals’
[17:36:44.854]   - Field: ‘stdout’
[17:36:44.854]   - Field: ‘earlySignal’
[17:36:44.855]   - Field: ‘lazy’
[17:36:44.855]   - Field: ‘state’
[17:36:44.855] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:44.855] - Launch lazy future ...
[17:36:44.855] Packages needed by the future expression (n = 1): ‘stats’
[17:36:44.855] Packages needed by future strategies (n = 0): <none>
[17:36:44.856] {
[17:36:44.856]     {
[17:36:44.856]         {
[17:36:44.856]             ...future.startTime <- base::Sys.time()
[17:36:44.856]             {
[17:36:44.856]                 {
[17:36:44.856]                   {
[17:36:44.856]                     {
[17:36:44.856]                       {
[17:36:44.856]                         base::local({
[17:36:44.856]                           has_future <- base::requireNamespace("future", 
[17:36:44.856]                             quietly = TRUE)
[17:36:44.856]                           if (has_future) {
[17:36:44.856]                             ns <- base::getNamespace("future")
[17:36:44.856]                             version <- ns[[".package"]][["version"]]
[17:36:44.856]                             if (is.null(version)) 
[17:36:44.856]                               version <- utils::packageVersion("future")
[17:36:44.856]                           }
[17:36:44.856]                           else {
[17:36:44.856]                             version <- NULL
[17:36:44.856]                           }
[17:36:44.856]                           if (!has_future || version < "1.8.0") {
[17:36:44.856]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:44.856]                               "", base::R.version$version.string), 
[17:36:44.856]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:44.856]                                 base::R.version$platform, 8 * 
[17:36:44.856]                                   base::.Machine$sizeof.pointer), 
[17:36:44.856]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:44.856]                                 "release", "version")], collapse = " "), 
[17:36:44.856]                               hostname = base::Sys.info()[["nodename"]])
[17:36:44.856]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:44.856]                               info)
[17:36:44.856]                             info <- base::paste(info, collapse = "; ")
[17:36:44.856]                             if (!has_future) {
[17:36:44.856]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:44.856]                                 info)
[17:36:44.856]                             }
[17:36:44.856]                             else {
[17:36:44.856]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:44.856]                                 info, version)
[17:36:44.856]                             }
[17:36:44.856]                             base::stop(msg)
[17:36:44.856]                           }
[17:36:44.856]                         })
[17:36:44.856]                       }
[17:36:44.856]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:44.856]                       base::options(mc.cores = 1L)
[17:36:44.856]                     }
[17:36:44.856]                     base::local({
[17:36:44.856]                       for (pkg in "stats") {
[17:36:44.856]                         base::loadNamespace(pkg)
[17:36:44.856]                         base::library(pkg, character.only = TRUE)
[17:36:44.856]                       }
[17:36:44.856]                     })
[17:36:44.856]                   }
[17:36:44.856]                   ...future.strategy.old <- future::plan("list")
[17:36:44.856]                   options(future.plan = NULL)
[17:36:44.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:44.856]                 }
[17:36:44.856]                 ...future.workdir <- getwd()
[17:36:44.856]             }
[17:36:44.856]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:44.856]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:44.856]         }
[17:36:44.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:44.856]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:44.856]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:44.856]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:44.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:44.856]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:44.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:44.856]             base::names(...future.oldOptions))
[17:36:44.856]     }
[17:36:44.856]     if (FALSE) {
[17:36:44.856]     }
[17:36:44.856]     else {
[17:36:44.856]         if (TRUE) {
[17:36:44.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:44.856]                 open = "w")
[17:36:44.856]         }
[17:36:44.856]         else {
[17:36:44.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:44.856]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:44.856]         }
[17:36:44.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:44.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:44.856]             base::sink(type = "output", split = FALSE)
[17:36:44.856]             base::close(...future.stdout)
[17:36:44.856]         }, add = TRUE)
[17:36:44.856]     }
[17:36:44.856]     ...future.frame <- base::sys.nframe()
[17:36:44.856]     ...future.conditions <- base::list()
[17:36:44.856]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:44.856]     if (FALSE) {
[17:36:44.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:44.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:44.856]     }
[17:36:44.856]     ...future.result <- base::tryCatch({
[17:36:44.856]         base::withCallingHandlers({
[17:36:44.856]             ...future.value <- base::withVisible(base::local({
[17:36:44.856]                 ...future.makeSendCondition <- base::local({
[17:36:44.856]                   sendCondition <- NULL
[17:36:44.856]                   function(frame = 1L) {
[17:36:44.856]                     if (is.function(sendCondition)) 
[17:36:44.856]                       return(sendCondition)
[17:36:44.856]                     ns <- getNamespace("parallel")
[17:36:44.856]                     if (exists("sendData", mode = "function", 
[17:36:44.856]                       envir = ns)) {
[17:36:44.856]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:44.856]                         envir = ns)
[17:36:44.856]                       envir <- sys.frame(frame)
[17:36:44.856]                       master <- NULL
[17:36:44.856]                       while (!identical(envir, .GlobalEnv) && 
[17:36:44.856]                         !identical(envir, emptyenv())) {
[17:36:44.856]                         if (exists("master", mode = "list", envir = envir, 
[17:36:44.856]                           inherits = FALSE)) {
[17:36:44.856]                           master <- get("master", mode = "list", 
[17:36:44.856]                             envir = envir, inherits = FALSE)
[17:36:44.856]                           if (inherits(master, c("SOCKnode", 
[17:36:44.856]                             "SOCK0node"))) {
[17:36:44.856]                             sendCondition <<- function(cond) {
[17:36:44.856]                               data <- list(type = "VALUE", value = cond, 
[17:36:44.856]                                 success = TRUE)
[17:36:44.856]                               parallel_sendData(master, data)
[17:36:44.856]                             }
[17:36:44.856]                             return(sendCondition)
[17:36:44.856]                           }
[17:36:44.856]                         }
[17:36:44.856]                         frame <- frame + 1L
[17:36:44.856]                         envir <- sys.frame(frame)
[17:36:44.856]                       }
[17:36:44.856]                     }
[17:36:44.856]                     sendCondition <<- function(cond) NULL
[17:36:44.856]                   }
[17:36:44.856]                 })
[17:36:44.856]                 withCallingHandlers({
[17:36:44.856]                   {
[17:36:44.856]                     do.call(function(...) {
[17:36:44.856]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.856]                       if (!identical(...future.globals.maxSize.org, 
[17:36:44.856]                         ...future.globals.maxSize)) {
[17:36:44.856]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.856]                         on.exit(options(oopts), add = TRUE)
[17:36:44.856]                       }
[17:36:44.856]                       {
[17:36:44.856]                         lapply(seq_along(...future.elements_ii), 
[17:36:44.856]                           FUN = function(jj) {
[17:36:44.856]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.856]                             ...future.FUN(...future.X_jj, ...)
[17:36:44.856]                           })
[17:36:44.856]                       }
[17:36:44.856]                     }, args = future.call.arguments)
[17:36:44.856]                   }
[17:36:44.856]                 }, immediateCondition = function(cond) {
[17:36:44.856]                   sendCondition <- ...future.makeSendCondition()
[17:36:44.856]                   sendCondition(cond)
[17:36:44.856]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.856]                   {
[17:36:44.856]                     inherits <- base::inherits
[17:36:44.856]                     invokeRestart <- base::invokeRestart
[17:36:44.856]                     is.null <- base::is.null
[17:36:44.856]                     muffled <- FALSE
[17:36:44.856]                     if (inherits(cond, "message")) {
[17:36:44.856]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:44.856]                       if (muffled) 
[17:36:44.856]                         invokeRestart("muffleMessage")
[17:36:44.856]                     }
[17:36:44.856]                     else if (inherits(cond, "warning")) {
[17:36:44.856]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:44.856]                       if (muffled) 
[17:36:44.856]                         invokeRestart("muffleWarning")
[17:36:44.856]                     }
[17:36:44.856]                     else if (inherits(cond, "condition")) {
[17:36:44.856]                       if (!is.null(pattern)) {
[17:36:44.856]                         computeRestarts <- base::computeRestarts
[17:36:44.856]                         grepl <- base::grepl
[17:36:44.856]                         restarts <- computeRestarts(cond)
[17:36:44.856]                         for (restart in restarts) {
[17:36:44.856]                           name <- restart$name
[17:36:44.856]                           if (is.null(name)) 
[17:36:44.856]                             next
[17:36:44.856]                           if (!grepl(pattern, name)) 
[17:36:44.856]                             next
[17:36:44.856]                           invokeRestart(restart)
[17:36:44.856]                           muffled <- TRUE
[17:36:44.856]                           break
[17:36:44.856]                         }
[17:36:44.856]                       }
[17:36:44.856]                     }
[17:36:44.856]                     invisible(muffled)
[17:36:44.856]                   }
[17:36:44.856]                   muffleCondition(cond)
[17:36:44.856]                 })
[17:36:44.856]             }))
[17:36:44.856]             future::FutureResult(value = ...future.value$value, 
[17:36:44.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.856]                   ...future.rng), globalenv = if (FALSE) 
[17:36:44.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:44.856]                     ...future.globalenv.names))
[17:36:44.856]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:44.856]         }, condition = base::local({
[17:36:44.856]             c <- base::c
[17:36:44.856]             inherits <- base::inherits
[17:36:44.856]             invokeRestart <- base::invokeRestart
[17:36:44.856]             length <- base::length
[17:36:44.856]             list <- base::list
[17:36:44.856]             seq.int <- base::seq.int
[17:36:44.856]             signalCondition <- base::signalCondition
[17:36:44.856]             sys.calls <- base::sys.calls
[17:36:44.856]             `[[` <- base::`[[`
[17:36:44.856]             `+` <- base::`+`
[17:36:44.856]             `<<-` <- base::`<<-`
[17:36:44.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:44.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:44.856]                   3L)]
[17:36:44.856]             }
[17:36:44.856]             function(cond) {
[17:36:44.856]                 is_error <- inherits(cond, "error")
[17:36:44.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:44.856]                   NULL)
[17:36:44.856]                 if (is_error) {
[17:36:44.856]                   sessionInformation <- function() {
[17:36:44.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:44.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:44.856]                       search = base::search(), system = base::Sys.info())
[17:36:44.856]                   }
[17:36:44.856]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:44.856]                     cond$call), session = sessionInformation(), 
[17:36:44.856]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:44.856]                   signalCondition(cond)
[17:36:44.856]                 }
[17:36:44.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:44.856]                 "immediateCondition"))) {
[17:36:44.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:44.856]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:44.856]                   if (TRUE && !signal) {
[17:36:44.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.856]                     {
[17:36:44.856]                       inherits <- base::inherits
[17:36:44.856]                       invokeRestart <- base::invokeRestart
[17:36:44.856]                       is.null <- base::is.null
[17:36:44.856]                       muffled <- FALSE
[17:36:44.856]                       if (inherits(cond, "message")) {
[17:36:44.856]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.856]                         if (muffled) 
[17:36:44.856]                           invokeRestart("muffleMessage")
[17:36:44.856]                       }
[17:36:44.856]                       else if (inherits(cond, "warning")) {
[17:36:44.856]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.856]                         if (muffled) 
[17:36:44.856]                           invokeRestart("muffleWarning")
[17:36:44.856]                       }
[17:36:44.856]                       else if (inherits(cond, "condition")) {
[17:36:44.856]                         if (!is.null(pattern)) {
[17:36:44.856]                           computeRestarts <- base::computeRestarts
[17:36:44.856]                           grepl <- base::grepl
[17:36:44.856]                           restarts <- computeRestarts(cond)
[17:36:44.856]                           for (restart in restarts) {
[17:36:44.856]                             name <- restart$name
[17:36:44.856]                             if (is.null(name)) 
[17:36:44.856]                               next
[17:36:44.856]                             if (!grepl(pattern, name)) 
[17:36:44.856]                               next
[17:36:44.856]                             invokeRestart(restart)
[17:36:44.856]                             muffled <- TRUE
[17:36:44.856]                             break
[17:36:44.856]                           }
[17:36:44.856]                         }
[17:36:44.856]                       }
[17:36:44.856]                       invisible(muffled)
[17:36:44.856]                     }
[17:36:44.856]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.856]                   }
[17:36:44.856]                 }
[17:36:44.856]                 else {
[17:36:44.856]                   if (TRUE) {
[17:36:44.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.856]                     {
[17:36:44.856]                       inherits <- base::inherits
[17:36:44.856]                       invokeRestart <- base::invokeRestart
[17:36:44.856]                       is.null <- base::is.null
[17:36:44.856]                       muffled <- FALSE
[17:36:44.856]                       if (inherits(cond, "message")) {
[17:36:44.856]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.856]                         if (muffled) 
[17:36:44.856]                           invokeRestart("muffleMessage")
[17:36:44.856]                       }
[17:36:44.856]                       else if (inherits(cond, "warning")) {
[17:36:44.856]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.856]                         if (muffled) 
[17:36:44.856]                           invokeRestart("muffleWarning")
[17:36:44.856]                       }
[17:36:44.856]                       else if (inherits(cond, "condition")) {
[17:36:44.856]                         if (!is.null(pattern)) {
[17:36:44.856]                           computeRestarts <- base::computeRestarts
[17:36:44.856]                           grepl <- base::grepl
[17:36:44.856]                           restarts <- computeRestarts(cond)
[17:36:44.856]                           for (restart in restarts) {
[17:36:44.856]                             name <- restart$name
[17:36:44.856]                             if (is.null(name)) 
[17:36:44.856]                               next
[17:36:44.856]                             if (!grepl(pattern, name)) 
[17:36:44.856]                               next
[17:36:44.856]                             invokeRestart(restart)
[17:36:44.856]                             muffled <- TRUE
[17:36:44.856]                             break
[17:36:44.856]                           }
[17:36:44.856]                         }
[17:36:44.856]                       }
[17:36:44.856]                       invisible(muffled)
[17:36:44.856]                     }
[17:36:44.856]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.856]                   }
[17:36:44.856]                 }
[17:36:44.856]             }
[17:36:44.856]         }))
[17:36:44.856]     }, error = function(ex) {
[17:36:44.856]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:44.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.856]                 ...future.rng), started = ...future.startTime, 
[17:36:44.856]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:44.856]             version = "1.8"), class = "FutureResult")
[17:36:44.856]     }, finally = {
[17:36:44.856]         if (!identical(...future.workdir, getwd())) 
[17:36:44.856]             setwd(...future.workdir)
[17:36:44.856]         {
[17:36:44.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:44.856]                 ...future.oldOptions$nwarnings <- NULL
[17:36:44.856]             }
[17:36:44.856]             base::options(...future.oldOptions)
[17:36:44.856]             if (.Platform$OS.type == "windows") {
[17:36:44.856]                 old_names <- names(...future.oldEnvVars)
[17:36:44.856]                 envs <- base::Sys.getenv()
[17:36:44.856]                 names <- names(envs)
[17:36:44.856]                 common <- intersect(names, old_names)
[17:36:44.856]                 added <- setdiff(names, old_names)
[17:36:44.856]                 removed <- setdiff(old_names, names)
[17:36:44.856]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:44.856]                   envs[common]]
[17:36:44.856]                 NAMES <- toupper(changed)
[17:36:44.856]                 args <- list()
[17:36:44.856]                 for (kk in seq_along(NAMES)) {
[17:36:44.856]                   name <- changed[[kk]]
[17:36:44.856]                   NAME <- NAMES[[kk]]
[17:36:44.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.856]                     next
[17:36:44.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.856]                 }
[17:36:44.856]                 NAMES <- toupper(added)
[17:36:44.856]                 for (kk in seq_along(NAMES)) {
[17:36:44.856]                   name <- added[[kk]]
[17:36:44.856]                   NAME <- NAMES[[kk]]
[17:36:44.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.856]                     next
[17:36:44.856]                   args[[name]] <- ""
[17:36:44.856]                 }
[17:36:44.856]                 NAMES <- toupper(removed)
[17:36:44.856]                 for (kk in seq_along(NAMES)) {
[17:36:44.856]                   name <- removed[[kk]]
[17:36:44.856]                   NAME <- NAMES[[kk]]
[17:36:44.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.856]                     next
[17:36:44.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.856]                 }
[17:36:44.856]                 if (length(args) > 0) 
[17:36:44.856]                   base::do.call(base::Sys.setenv, args = args)
[17:36:44.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:44.856]             }
[17:36:44.856]             else {
[17:36:44.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:44.856]             }
[17:36:44.856]             {
[17:36:44.856]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:44.856]                   0L) {
[17:36:44.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:44.856]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:44.856]                   base::options(opts)
[17:36:44.856]                 }
[17:36:44.856]                 {
[17:36:44.856]                   {
[17:36:44.856]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:44.856]                     NULL
[17:36:44.856]                   }
[17:36:44.856]                   options(future.plan = NULL)
[17:36:44.856]                   if (is.na(NA_character_)) 
[17:36:44.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:44.856]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:44.856]                     .init = FALSE)
[17:36:44.856]                 }
[17:36:44.856]             }
[17:36:44.856]         }
[17:36:44.856]     })
[17:36:44.856]     if (TRUE) {
[17:36:44.856]         base::sink(type = "output", split = FALSE)
[17:36:44.856]         if (TRUE) {
[17:36:44.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:44.856]         }
[17:36:44.856]         else {
[17:36:44.856]             ...future.result["stdout"] <- base::list(NULL)
[17:36:44.856]         }
[17:36:44.856]         base::close(...future.stdout)
[17:36:44.856]         ...future.stdout <- NULL
[17:36:44.856]     }
[17:36:44.856]     ...future.result$conditions <- ...future.conditions
[17:36:44.856]     ...future.result$finished <- base::Sys.time()
[17:36:44.856]     ...future.result
[17:36:44.856] }
[17:36:44.858] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[17:36:44.859] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:36:44.859] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:36:44.859] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:44.859] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:44.860] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:36:44.860] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:36:44.860] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:44.860] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:44.861] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:36:44.861] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:36:44.861] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[17:36:44.861] MultisessionFuture started
[17:36:44.861] - Launch lazy future ... done
[17:36:44.862] run() for ‘MultisessionFuture’ ... done
[17:36:44.862] Created future:
[17:36:44.862] MultisessionFuture:
[17:36:44.862] Label: ‘future_eapply-2’
[17:36:44.862] Expression:
[17:36:44.862] {
[17:36:44.862]     do.call(function(...) {
[17:36:44.862]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.862]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.862]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.862]             on.exit(options(oopts), add = TRUE)
[17:36:44.862]         }
[17:36:44.862]         {
[17:36:44.862]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.862]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.862]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.862]             })
[17:36:44.862]         }
[17:36:44.862]     }, args = future.call.arguments)
[17:36:44.862] }
[17:36:44.862] Lazy evaluation: FALSE
[17:36:44.862] Asynchronous evaluation: TRUE
[17:36:44.862] Local evaluation: TRUE
[17:36:44.862] Environment: R_GlobalEnv
[17:36:44.862] Capture standard output: TRUE
[17:36:44.862] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:44.862] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:44.862] Packages: 1 packages (‘stats’)
[17:36:44.862] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:44.862] Resolved: FALSE
[17:36:44.862] Value: <not collected>
[17:36:44.862] Conditions captured: <none>
[17:36:44.862] Early signaling: FALSE
[17:36:44.862] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:44.862] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.873] Chunk #2 of 2 ... DONE
[17:36:44.873] Launching 2 futures (chunks) ... DONE
[17:36:44.874] Resolving 2 futures (chunks) ...
[17:36:44.874] resolve() on list ...
[17:36:44.874]  recursive: 0
[17:36:44.874]  length: 2
[17:36:44.874] 
[17:36:44.874] receiveMessageFromWorker() for ClusterFuture ...
[17:36:44.875] - Validating connection of MultisessionFuture
[17:36:44.875] - received message: FutureResult
[17:36:44.875] - Received FutureResult
[17:36:44.875] - Erased future from FutureRegistry
[17:36:44.875] result() for ClusterFuture ...
[17:36:44.875] - result already collected: FutureResult
[17:36:44.875] result() for ClusterFuture ... done
[17:36:44.875] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:44.875] Future #1
[17:36:44.876] result() for ClusterFuture ...
[17:36:44.876] - result already collected: FutureResult
[17:36:44.876] result() for ClusterFuture ... done
[17:36:44.876] result() for ClusterFuture ...
[17:36:44.876] - result already collected: FutureResult
[17:36:44.876] result() for ClusterFuture ... done
[17:36:44.876] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:44.876] - nx: 2
[17:36:44.876] - relay: TRUE
[17:36:44.876] - stdout: TRUE
[17:36:44.877] - signal: TRUE
[17:36:44.877] - resignal: FALSE
[17:36:44.877] - force: TRUE
[17:36:44.877] - relayed: [n=2] FALSE, FALSE
[17:36:44.877] - queued futures: [n=2] FALSE, FALSE
[17:36:44.877]  - until=1
[17:36:44.877]  - relaying element #1
[17:36:44.877] result() for ClusterFuture ...
[17:36:44.877] - result already collected: FutureResult
[17:36:44.877] result() for ClusterFuture ... done
[17:36:44.877] result() for ClusterFuture ...
[17:36:44.877] - result already collected: FutureResult
[17:36:44.878] result() for ClusterFuture ... done
[17:36:44.878] result() for ClusterFuture ...
[17:36:44.878] - result already collected: FutureResult
[17:36:44.878] result() for ClusterFuture ... done
[17:36:44.878] result() for ClusterFuture ...
[17:36:44.878] - result already collected: FutureResult
[17:36:44.878] result() for ClusterFuture ... done
[17:36:44.878] - relayed: [n=2] TRUE, FALSE
[17:36:44.878] - queued futures: [n=2] TRUE, FALSE
[17:36:44.878] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:44.878]  length: 1 (resolved future 1)
[17:36:44.907] receiveMessageFromWorker() for ClusterFuture ...
[17:36:44.907] - Validating connection of MultisessionFuture
[17:36:44.907] - received message: FutureResult
[17:36:44.907] - Received FutureResult
[17:36:44.908] - Erased future from FutureRegistry
[17:36:44.908] result() for ClusterFuture ...
[17:36:44.908] - result already collected: FutureResult
[17:36:44.908] result() for ClusterFuture ... done
[17:36:44.908] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:44.908] Future #2
[17:36:44.908] result() for ClusterFuture ...
[17:36:44.908] - result already collected: FutureResult
[17:36:44.908] result() for ClusterFuture ... done
[17:36:44.908] result() for ClusterFuture ...
[17:36:44.908] - result already collected: FutureResult
[17:36:44.909] result() for ClusterFuture ... done
[17:36:44.909] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:44.909] - nx: 2
[17:36:44.909] - relay: TRUE
[17:36:44.909] - stdout: TRUE
[17:36:44.909] - signal: TRUE
[17:36:44.909] - resignal: FALSE
[17:36:44.909] - force: TRUE
[17:36:44.909] - relayed: [n=2] TRUE, FALSE
[17:36:44.909] - queued futures: [n=2] TRUE, FALSE
[17:36:44.909]  - until=2
[17:36:44.910]  - relaying element #2
[17:36:44.910] result() for ClusterFuture ...
[17:36:44.910] - result already collected: FutureResult
[17:36:44.910] result() for ClusterFuture ... done
[17:36:44.910] result() for ClusterFuture ...
[17:36:44.910] - result already collected: FutureResult
[17:36:44.910] result() for ClusterFuture ... done
[17:36:44.910] result() for ClusterFuture ...
[17:36:44.910] - result already collected: FutureResult
[17:36:44.910] result() for ClusterFuture ... done
[17:36:44.910] result() for ClusterFuture ...
[17:36:44.911] - result already collected: FutureResult
[17:36:44.911] result() for ClusterFuture ... done
[17:36:44.911] - relayed: [n=2] TRUE, TRUE
[17:36:44.911] - queued futures: [n=2] TRUE, TRUE
[17:36:44.911] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:44.911]  length: 0 (resolved future 2)
[17:36:44.911] Relaying remaining futures
[17:36:44.911] signalConditionsASAP(NULL, pos=0) ...
[17:36:44.911] - nx: 2
[17:36:44.911] - relay: TRUE
[17:36:44.911] - stdout: TRUE
[17:36:44.912] - signal: TRUE
[17:36:44.912] - resignal: FALSE
[17:36:44.912] - force: TRUE
[17:36:44.912] - relayed: [n=2] TRUE, TRUE
[17:36:44.912] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:44.912] - relayed: [n=2] TRUE, TRUE
[17:36:44.912] - queued futures: [n=2] TRUE, TRUE
[17:36:44.912] signalConditionsASAP(NULL, pos=0) ... done
[17:36:44.912] resolve() on list ... DONE
[17:36:44.912] result() for ClusterFuture ...
[17:36:44.912] - result already collected: FutureResult
[17:36:44.913] result() for ClusterFuture ... done
[17:36:44.913] result() for ClusterFuture ...
[17:36:44.913] - result already collected: FutureResult
[17:36:44.913] result() for ClusterFuture ... done
[17:36:44.913] result() for ClusterFuture ...
[17:36:44.913] - result already collected: FutureResult
[17:36:44.913] result() for ClusterFuture ... done
[17:36:44.913] result() for ClusterFuture ...
[17:36:44.913] - result already collected: FutureResult
[17:36:44.913] result() for ClusterFuture ... done
[17:36:44.913]  - Number of value chunks collected: 2
[17:36:44.914] Resolving 2 futures (chunks) ... DONE
[17:36:44.914] Reducing values from 2 chunks ...
[17:36:44.914]  - Number of values collected after concatenation: 3
[17:36:44.914]  - Number of values expected: 3
[17:36:44.914] Reducing values from 2 chunks ... DONE
[17:36:44.914] future_lapply() ... DONE
[17:36:44.914] future_lapply() ...
[17:36:44.918] Number of chunks: 2
[17:36:44.918] getGlobalsAndPackagesXApply() ...
[17:36:44.919]  - future.globals: TRUE
[17:36:44.919] getGlobalsAndPackages() ...
[17:36:44.919] Searching for globals...
[17:36:44.920] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:44.920] Searching for globals ... DONE
[17:36:44.920] Resolving globals: FALSE
[17:36:44.920] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:36:44.921] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:36:44.921] - globals: [1] ‘FUN’
[17:36:44.921] - packages: [1] ‘stats’
[17:36:44.921] getGlobalsAndPackages() ... DONE
[17:36:44.921]  - globals found/used: [n=1] ‘FUN’
[17:36:44.921]  - needed namespaces: [n=1] ‘stats’
[17:36:44.921] Finding globals ... DONE
[17:36:44.922]  - use_args: TRUE
[17:36:44.922]  - Getting '...' globals ...
[17:36:44.922] resolve() on list ...
[17:36:44.922]  recursive: 0
[17:36:44.922]  length: 1
[17:36:44.922]  elements: ‘...’
[17:36:44.922]  length: 0 (resolved future 1)
[17:36:44.922] resolve() on list ... DONE
[17:36:44.923]    - '...' content: [n=0] 
[17:36:44.923] List of 1
[17:36:44.923]  $ ...: list()
[17:36:44.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:44.923]  - attr(*, "where")=List of 1
[17:36:44.923]   ..$ ...:<environment: 0x565505ad7ef0> 
[17:36:44.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:44.923]  - attr(*, "resolved")= logi TRUE
[17:36:44.923]  - attr(*, "total_size")= num NA
[17:36:44.925]  - Getting '...' globals ... DONE
[17:36:44.925] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:44.926] List of 2
[17:36:44.926]  $ ...future.FUN:function (x, ...)  
[17:36:44.926]  $ ...          : list()
[17:36:44.926]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:44.926]  - attr(*, "where")=List of 2
[17:36:44.926]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:44.926]   ..$ ...          :<environment: 0x565505ad7ef0> 
[17:36:44.926]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:44.926]  - attr(*, "resolved")= logi FALSE
[17:36:44.926]  - attr(*, "total_size")= num 1248
[17:36:44.928] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:44.928] getGlobalsAndPackagesXApply() ... DONE
[17:36:44.928] Number of futures (= number of chunks): 2
[17:36:44.929] Launching 2 futures (chunks) ...
[17:36:44.929] Chunk #1 of 2 ...
[17:36:44.929]  - Finding globals in 'X' for chunk #1 ...
[17:36:44.929] getGlobalsAndPackages() ...
[17:36:44.929] Searching for globals...
[17:36:44.929] 
[17:36:44.929] Searching for globals ... DONE
[17:36:44.929] - globals: [0] <none>
[17:36:44.929] getGlobalsAndPackages() ... DONE
[17:36:44.930]    + additional globals found: [n=0] 
[17:36:44.930]    + additional namespaces needed: [n=0] 
[17:36:44.930]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:44.930]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:44.930]  - seeds: <none>
[17:36:44.930]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.930] getGlobalsAndPackages() ...
[17:36:44.930] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.930] Resolving globals: FALSE
[17:36:44.930] Tweak future expression to call with '...' arguments ...
[17:36:44.931] {
[17:36:44.931]     do.call(function(...) {
[17:36:44.931]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.931]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.931]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.931]             on.exit(options(oopts), add = TRUE)
[17:36:44.931]         }
[17:36:44.931]         {
[17:36:44.931]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.931]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.931]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.931]             })
[17:36:44.931]         }
[17:36:44.931]     }, args = future.call.arguments)
[17:36:44.931] }
[17:36:44.931] Tweak future expression to call with '...' arguments ... DONE
[17:36:44.931] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.931] - packages: [1] ‘stats’
[17:36:44.931] getGlobalsAndPackages() ... DONE
[17:36:44.932] run() for ‘Future’ ...
[17:36:44.932] - state: ‘created’
[17:36:44.932] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:44.945] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.946] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:44.946]   - Field: ‘node’
[17:36:44.946]   - Field: ‘label’
[17:36:44.946]   - Field: ‘local’
[17:36:44.946]   - Field: ‘owner’
[17:36:44.946]   - Field: ‘envir’
[17:36:44.946]   - Field: ‘workers’
[17:36:44.946]   - Field: ‘packages’
[17:36:44.946]   - Field: ‘gc’
[17:36:44.946]   - Field: ‘conditions’
[17:36:44.947]   - Field: ‘persistent’
[17:36:44.947]   - Field: ‘expr’
[17:36:44.947]   - Field: ‘uuid’
[17:36:44.947]   - Field: ‘seed’
[17:36:44.947]   - Field: ‘version’
[17:36:44.947]   - Field: ‘result’
[17:36:44.947]   - Field: ‘asynchronous’
[17:36:44.947]   - Field: ‘calls’
[17:36:44.947]   - Field: ‘globals’
[17:36:44.947]   - Field: ‘stdout’
[17:36:44.947]   - Field: ‘earlySignal’
[17:36:44.948]   - Field: ‘lazy’
[17:36:44.948]   - Field: ‘state’
[17:36:44.948] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:44.948] - Launch lazy future ...
[17:36:44.948] Packages needed by the future expression (n = 1): ‘stats’
[17:36:44.948] Packages needed by future strategies (n = 0): <none>
[17:36:44.949] {
[17:36:44.949]     {
[17:36:44.949]         {
[17:36:44.949]             ...future.startTime <- base::Sys.time()
[17:36:44.949]             {
[17:36:44.949]                 {
[17:36:44.949]                   {
[17:36:44.949]                     {
[17:36:44.949]                       {
[17:36:44.949]                         base::local({
[17:36:44.949]                           has_future <- base::requireNamespace("future", 
[17:36:44.949]                             quietly = TRUE)
[17:36:44.949]                           if (has_future) {
[17:36:44.949]                             ns <- base::getNamespace("future")
[17:36:44.949]                             version <- ns[[".package"]][["version"]]
[17:36:44.949]                             if (is.null(version)) 
[17:36:44.949]                               version <- utils::packageVersion("future")
[17:36:44.949]                           }
[17:36:44.949]                           else {
[17:36:44.949]                             version <- NULL
[17:36:44.949]                           }
[17:36:44.949]                           if (!has_future || version < "1.8.0") {
[17:36:44.949]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:44.949]                               "", base::R.version$version.string), 
[17:36:44.949]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:44.949]                                 base::R.version$platform, 8 * 
[17:36:44.949]                                   base::.Machine$sizeof.pointer), 
[17:36:44.949]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:44.949]                                 "release", "version")], collapse = " "), 
[17:36:44.949]                               hostname = base::Sys.info()[["nodename"]])
[17:36:44.949]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:44.949]                               info)
[17:36:44.949]                             info <- base::paste(info, collapse = "; ")
[17:36:44.949]                             if (!has_future) {
[17:36:44.949]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:44.949]                                 info)
[17:36:44.949]                             }
[17:36:44.949]                             else {
[17:36:44.949]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:44.949]                                 info, version)
[17:36:44.949]                             }
[17:36:44.949]                             base::stop(msg)
[17:36:44.949]                           }
[17:36:44.949]                         })
[17:36:44.949]                       }
[17:36:44.949]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:44.949]                       base::options(mc.cores = 1L)
[17:36:44.949]                     }
[17:36:44.949]                     base::local({
[17:36:44.949]                       for (pkg in "stats") {
[17:36:44.949]                         base::loadNamespace(pkg)
[17:36:44.949]                         base::library(pkg, character.only = TRUE)
[17:36:44.949]                       }
[17:36:44.949]                     })
[17:36:44.949]                   }
[17:36:44.949]                   ...future.strategy.old <- future::plan("list")
[17:36:44.949]                   options(future.plan = NULL)
[17:36:44.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:44.949]                 }
[17:36:44.949]                 ...future.workdir <- getwd()
[17:36:44.949]             }
[17:36:44.949]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:44.949]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:44.949]         }
[17:36:44.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:44.949]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:44.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:44.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:44.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:44.949]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:44.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:44.949]             base::names(...future.oldOptions))
[17:36:44.949]     }
[17:36:44.949]     if (FALSE) {
[17:36:44.949]     }
[17:36:44.949]     else {
[17:36:44.949]         if (TRUE) {
[17:36:44.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:44.949]                 open = "w")
[17:36:44.949]         }
[17:36:44.949]         else {
[17:36:44.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:44.949]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:44.949]         }
[17:36:44.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:44.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:44.949]             base::sink(type = "output", split = FALSE)
[17:36:44.949]             base::close(...future.stdout)
[17:36:44.949]         }, add = TRUE)
[17:36:44.949]     }
[17:36:44.949]     ...future.frame <- base::sys.nframe()
[17:36:44.949]     ...future.conditions <- base::list()
[17:36:44.949]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:44.949]     if (FALSE) {
[17:36:44.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:44.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:44.949]     }
[17:36:44.949]     ...future.result <- base::tryCatch({
[17:36:44.949]         base::withCallingHandlers({
[17:36:44.949]             ...future.value <- base::withVisible(base::local({
[17:36:44.949]                 ...future.makeSendCondition <- base::local({
[17:36:44.949]                   sendCondition <- NULL
[17:36:44.949]                   function(frame = 1L) {
[17:36:44.949]                     if (is.function(sendCondition)) 
[17:36:44.949]                       return(sendCondition)
[17:36:44.949]                     ns <- getNamespace("parallel")
[17:36:44.949]                     if (exists("sendData", mode = "function", 
[17:36:44.949]                       envir = ns)) {
[17:36:44.949]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:44.949]                         envir = ns)
[17:36:44.949]                       envir <- sys.frame(frame)
[17:36:44.949]                       master <- NULL
[17:36:44.949]                       while (!identical(envir, .GlobalEnv) && 
[17:36:44.949]                         !identical(envir, emptyenv())) {
[17:36:44.949]                         if (exists("master", mode = "list", envir = envir, 
[17:36:44.949]                           inherits = FALSE)) {
[17:36:44.949]                           master <- get("master", mode = "list", 
[17:36:44.949]                             envir = envir, inherits = FALSE)
[17:36:44.949]                           if (inherits(master, c("SOCKnode", 
[17:36:44.949]                             "SOCK0node"))) {
[17:36:44.949]                             sendCondition <<- function(cond) {
[17:36:44.949]                               data <- list(type = "VALUE", value = cond, 
[17:36:44.949]                                 success = TRUE)
[17:36:44.949]                               parallel_sendData(master, data)
[17:36:44.949]                             }
[17:36:44.949]                             return(sendCondition)
[17:36:44.949]                           }
[17:36:44.949]                         }
[17:36:44.949]                         frame <- frame + 1L
[17:36:44.949]                         envir <- sys.frame(frame)
[17:36:44.949]                       }
[17:36:44.949]                     }
[17:36:44.949]                     sendCondition <<- function(cond) NULL
[17:36:44.949]                   }
[17:36:44.949]                 })
[17:36:44.949]                 withCallingHandlers({
[17:36:44.949]                   {
[17:36:44.949]                     do.call(function(...) {
[17:36:44.949]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.949]                       if (!identical(...future.globals.maxSize.org, 
[17:36:44.949]                         ...future.globals.maxSize)) {
[17:36:44.949]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.949]                         on.exit(options(oopts), add = TRUE)
[17:36:44.949]                       }
[17:36:44.949]                       {
[17:36:44.949]                         lapply(seq_along(...future.elements_ii), 
[17:36:44.949]                           FUN = function(jj) {
[17:36:44.949]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.949]                             ...future.FUN(...future.X_jj, ...)
[17:36:44.949]                           })
[17:36:44.949]                       }
[17:36:44.949]                     }, args = future.call.arguments)
[17:36:44.949]                   }
[17:36:44.949]                 }, immediateCondition = function(cond) {
[17:36:44.949]                   sendCondition <- ...future.makeSendCondition()
[17:36:44.949]                   sendCondition(cond)
[17:36:44.949]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.949]                   {
[17:36:44.949]                     inherits <- base::inherits
[17:36:44.949]                     invokeRestart <- base::invokeRestart
[17:36:44.949]                     is.null <- base::is.null
[17:36:44.949]                     muffled <- FALSE
[17:36:44.949]                     if (inherits(cond, "message")) {
[17:36:44.949]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:44.949]                       if (muffled) 
[17:36:44.949]                         invokeRestart("muffleMessage")
[17:36:44.949]                     }
[17:36:44.949]                     else if (inherits(cond, "warning")) {
[17:36:44.949]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:44.949]                       if (muffled) 
[17:36:44.949]                         invokeRestart("muffleWarning")
[17:36:44.949]                     }
[17:36:44.949]                     else if (inherits(cond, "condition")) {
[17:36:44.949]                       if (!is.null(pattern)) {
[17:36:44.949]                         computeRestarts <- base::computeRestarts
[17:36:44.949]                         grepl <- base::grepl
[17:36:44.949]                         restarts <- computeRestarts(cond)
[17:36:44.949]                         for (restart in restarts) {
[17:36:44.949]                           name <- restart$name
[17:36:44.949]                           if (is.null(name)) 
[17:36:44.949]                             next
[17:36:44.949]                           if (!grepl(pattern, name)) 
[17:36:44.949]                             next
[17:36:44.949]                           invokeRestart(restart)
[17:36:44.949]                           muffled <- TRUE
[17:36:44.949]                           break
[17:36:44.949]                         }
[17:36:44.949]                       }
[17:36:44.949]                     }
[17:36:44.949]                     invisible(muffled)
[17:36:44.949]                   }
[17:36:44.949]                   muffleCondition(cond)
[17:36:44.949]                 })
[17:36:44.949]             }))
[17:36:44.949]             future::FutureResult(value = ...future.value$value, 
[17:36:44.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.949]                   ...future.rng), globalenv = if (FALSE) 
[17:36:44.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:44.949]                     ...future.globalenv.names))
[17:36:44.949]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:44.949]         }, condition = base::local({
[17:36:44.949]             c <- base::c
[17:36:44.949]             inherits <- base::inherits
[17:36:44.949]             invokeRestart <- base::invokeRestart
[17:36:44.949]             length <- base::length
[17:36:44.949]             list <- base::list
[17:36:44.949]             seq.int <- base::seq.int
[17:36:44.949]             signalCondition <- base::signalCondition
[17:36:44.949]             sys.calls <- base::sys.calls
[17:36:44.949]             `[[` <- base::`[[`
[17:36:44.949]             `+` <- base::`+`
[17:36:44.949]             `<<-` <- base::`<<-`
[17:36:44.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:44.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:44.949]                   3L)]
[17:36:44.949]             }
[17:36:44.949]             function(cond) {
[17:36:44.949]                 is_error <- inherits(cond, "error")
[17:36:44.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:44.949]                   NULL)
[17:36:44.949]                 if (is_error) {
[17:36:44.949]                   sessionInformation <- function() {
[17:36:44.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:44.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:44.949]                       search = base::search(), system = base::Sys.info())
[17:36:44.949]                   }
[17:36:44.949]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:44.949]                     cond$call), session = sessionInformation(), 
[17:36:44.949]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:44.949]                   signalCondition(cond)
[17:36:44.949]                 }
[17:36:44.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:44.949]                 "immediateCondition"))) {
[17:36:44.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:44.949]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:44.949]                   if (TRUE && !signal) {
[17:36:44.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.949]                     {
[17:36:44.949]                       inherits <- base::inherits
[17:36:44.949]                       invokeRestart <- base::invokeRestart
[17:36:44.949]                       is.null <- base::is.null
[17:36:44.949]                       muffled <- FALSE
[17:36:44.949]                       if (inherits(cond, "message")) {
[17:36:44.949]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.949]                         if (muffled) 
[17:36:44.949]                           invokeRestart("muffleMessage")
[17:36:44.949]                       }
[17:36:44.949]                       else if (inherits(cond, "warning")) {
[17:36:44.949]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.949]                         if (muffled) 
[17:36:44.949]                           invokeRestart("muffleWarning")
[17:36:44.949]                       }
[17:36:44.949]                       else if (inherits(cond, "condition")) {
[17:36:44.949]                         if (!is.null(pattern)) {
[17:36:44.949]                           computeRestarts <- base::computeRestarts
[17:36:44.949]                           grepl <- base::grepl
[17:36:44.949]                           restarts <- computeRestarts(cond)
[17:36:44.949]                           for (restart in restarts) {
[17:36:44.949]                             name <- restart$name
[17:36:44.949]                             if (is.null(name)) 
[17:36:44.949]                               next
[17:36:44.949]                             if (!grepl(pattern, name)) 
[17:36:44.949]                               next
[17:36:44.949]                             invokeRestart(restart)
[17:36:44.949]                             muffled <- TRUE
[17:36:44.949]                             break
[17:36:44.949]                           }
[17:36:44.949]                         }
[17:36:44.949]                       }
[17:36:44.949]                       invisible(muffled)
[17:36:44.949]                     }
[17:36:44.949]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.949]                   }
[17:36:44.949]                 }
[17:36:44.949]                 else {
[17:36:44.949]                   if (TRUE) {
[17:36:44.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.949]                     {
[17:36:44.949]                       inherits <- base::inherits
[17:36:44.949]                       invokeRestart <- base::invokeRestart
[17:36:44.949]                       is.null <- base::is.null
[17:36:44.949]                       muffled <- FALSE
[17:36:44.949]                       if (inherits(cond, "message")) {
[17:36:44.949]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.949]                         if (muffled) 
[17:36:44.949]                           invokeRestart("muffleMessage")
[17:36:44.949]                       }
[17:36:44.949]                       else if (inherits(cond, "warning")) {
[17:36:44.949]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.949]                         if (muffled) 
[17:36:44.949]                           invokeRestart("muffleWarning")
[17:36:44.949]                       }
[17:36:44.949]                       else if (inherits(cond, "condition")) {
[17:36:44.949]                         if (!is.null(pattern)) {
[17:36:44.949]                           computeRestarts <- base::computeRestarts
[17:36:44.949]                           grepl <- base::grepl
[17:36:44.949]                           restarts <- computeRestarts(cond)
[17:36:44.949]                           for (restart in restarts) {
[17:36:44.949]                             name <- restart$name
[17:36:44.949]                             if (is.null(name)) 
[17:36:44.949]                               next
[17:36:44.949]                             if (!grepl(pattern, name)) 
[17:36:44.949]                               next
[17:36:44.949]                             invokeRestart(restart)
[17:36:44.949]                             muffled <- TRUE
[17:36:44.949]                             break
[17:36:44.949]                           }
[17:36:44.949]                         }
[17:36:44.949]                       }
[17:36:44.949]                       invisible(muffled)
[17:36:44.949]                     }
[17:36:44.949]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.949]                   }
[17:36:44.949]                 }
[17:36:44.949]             }
[17:36:44.949]         }))
[17:36:44.949]     }, error = function(ex) {
[17:36:44.949]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:44.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.949]                 ...future.rng), started = ...future.startTime, 
[17:36:44.949]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:44.949]             version = "1.8"), class = "FutureResult")
[17:36:44.949]     }, finally = {
[17:36:44.949]         if (!identical(...future.workdir, getwd())) 
[17:36:44.949]             setwd(...future.workdir)
[17:36:44.949]         {
[17:36:44.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:44.949]                 ...future.oldOptions$nwarnings <- NULL
[17:36:44.949]             }
[17:36:44.949]             base::options(...future.oldOptions)
[17:36:44.949]             if (.Platform$OS.type == "windows") {
[17:36:44.949]                 old_names <- names(...future.oldEnvVars)
[17:36:44.949]                 envs <- base::Sys.getenv()
[17:36:44.949]                 names <- names(envs)
[17:36:44.949]                 common <- intersect(names, old_names)
[17:36:44.949]                 added <- setdiff(names, old_names)
[17:36:44.949]                 removed <- setdiff(old_names, names)
[17:36:44.949]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:44.949]                   envs[common]]
[17:36:44.949]                 NAMES <- toupper(changed)
[17:36:44.949]                 args <- list()
[17:36:44.949]                 for (kk in seq_along(NAMES)) {
[17:36:44.949]                   name <- changed[[kk]]
[17:36:44.949]                   NAME <- NAMES[[kk]]
[17:36:44.949]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.949]                     next
[17:36:44.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.949]                 }
[17:36:44.949]                 NAMES <- toupper(added)
[17:36:44.949]                 for (kk in seq_along(NAMES)) {
[17:36:44.949]                   name <- added[[kk]]
[17:36:44.949]                   NAME <- NAMES[[kk]]
[17:36:44.949]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.949]                     next
[17:36:44.949]                   args[[name]] <- ""
[17:36:44.949]                 }
[17:36:44.949]                 NAMES <- toupper(removed)
[17:36:44.949]                 for (kk in seq_along(NAMES)) {
[17:36:44.949]                   name <- removed[[kk]]
[17:36:44.949]                   NAME <- NAMES[[kk]]
[17:36:44.949]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.949]                     next
[17:36:44.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.949]                 }
[17:36:44.949]                 if (length(args) > 0) 
[17:36:44.949]                   base::do.call(base::Sys.setenv, args = args)
[17:36:44.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:44.949]             }
[17:36:44.949]             else {
[17:36:44.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:44.949]             }
[17:36:44.949]             {
[17:36:44.949]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:44.949]                   0L) {
[17:36:44.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:44.949]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:44.949]                   base::options(opts)
[17:36:44.949]                 }
[17:36:44.949]                 {
[17:36:44.949]                   {
[17:36:44.949]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:44.949]                     NULL
[17:36:44.949]                   }
[17:36:44.949]                   options(future.plan = NULL)
[17:36:44.949]                   if (is.na(NA_character_)) 
[17:36:44.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:44.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:44.949]                     .init = FALSE)
[17:36:44.949]                 }
[17:36:44.949]             }
[17:36:44.949]         }
[17:36:44.949]     })
[17:36:44.949]     if (TRUE) {
[17:36:44.949]         base::sink(type = "output", split = FALSE)
[17:36:44.949]         if (TRUE) {
[17:36:44.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:44.949]         }
[17:36:44.949]         else {
[17:36:44.949]             ...future.result["stdout"] <- base::list(NULL)
[17:36:44.949]         }
[17:36:44.949]         base::close(...future.stdout)
[17:36:44.949]         ...future.stdout <- NULL
[17:36:44.949]     }
[17:36:44.949]     ...future.result$conditions <- ...future.conditions
[17:36:44.949]     ...future.result$finished <- base::Sys.time()
[17:36:44.949]     ...future.result
[17:36:44.949] }
[17:36:44.952] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[17:36:44.952] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:36:44.952] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:36:44.953] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:44.953] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:44.953] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[17:36:44.954] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[17:36:44.954] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:44.954] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:44.954] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:36:44.955] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:36:44.955] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[17:36:44.955] MultisessionFuture started
[17:36:44.955] - Launch lazy future ... done
[17:36:44.956] run() for ‘MultisessionFuture’ ... done
[17:36:44.956] Created future:
[17:36:44.956] MultisessionFuture:
[17:36:44.956] Label: ‘future_eapply-1’
[17:36:44.956] Expression:
[17:36:44.956] {
[17:36:44.956]     do.call(function(...) {
[17:36:44.956]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.956]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.956]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.956]             on.exit(options(oopts), add = TRUE)
[17:36:44.956]         }
[17:36:44.956]         {
[17:36:44.956]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.956]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.956]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.956]             })
[17:36:44.956]         }
[17:36:44.956]     }, args = future.call.arguments)
[17:36:44.956] }
[17:36:44.956] Lazy evaluation: FALSE
[17:36:44.956] Asynchronous evaluation: TRUE
[17:36:44.956] Local evaluation: TRUE
[17:36:44.956] Environment: R_GlobalEnv
[17:36:44.956] Capture standard output: TRUE
[17:36:44.956] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:44.956] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:44.956] Packages: 1 packages (‘stats’)
[17:36:44.956] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:44.956] Resolved: FALSE
[17:36:44.956] Value: <not collected>
[17:36:44.956] Conditions captured: <none>
[17:36:44.956] Early signaling: FALSE
[17:36:44.956] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:44.956] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.968] Chunk #1 of 2 ... DONE
[17:36:44.968] Chunk #2 of 2 ...
[17:36:44.968]  - Finding globals in 'X' for chunk #2 ...
[17:36:44.968] getGlobalsAndPackages() ...
[17:36:44.968] Searching for globals...
[17:36:44.968] 
[17:36:44.968] Searching for globals ... DONE
[17:36:44.969] - globals: [0] <none>
[17:36:44.969] getGlobalsAndPackages() ... DONE
[17:36:44.969]    + additional globals found: [n=0] 
[17:36:44.969]    + additional namespaces needed: [n=0] 
[17:36:44.969]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:44.969]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:44.969]  - seeds: <none>
[17:36:44.969]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.969] getGlobalsAndPackages() ...
[17:36:44.969] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.969] Resolving globals: FALSE
[17:36:44.970] Tweak future expression to call with '...' arguments ...
[17:36:44.970] {
[17:36:44.970]     do.call(function(...) {
[17:36:44.970]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.970]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:44.970]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.970]             on.exit(options(oopts), add = TRUE)
[17:36:44.970]         }
[17:36:44.970]         {
[17:36:44.970]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:44.970]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.970]                 ...future.FUN(...future.X_jj, ...)
[17:36:44.970]             })
[17:36:44.970]         }
[17:36:44.970]     }, args = future.call.arguments)
[17:36:44.970] }
[17:36:44.970] Tweak future expression to call with '...' arguments ... DONE
[17:36:44.970] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:44.970] - packages: [1] ‘stats’
[17:36:44.971] getGlobalsAndPackages() ... DONE
[17:36:44.971] run() for ‘Future’ ...
[17:36:44.971] - state: ‘created’
[17:36:44.971] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:44.989] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:44.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:44.990]   - Field: ‘node’
[17:36:44.990]   - Field: ‘label’
[17:36:44.990]   - Field: ‘local’
[17:36:44.990]   - Field: ‘owner’
[17:36:44.990]   - Field: ‘envir’
[17:36:44.990]   - Field: ‘workers’
[17:36:44.990]   - Field: ‘packages’
[17:36:44.990]   - Field: ‘gc’
[17:36:44.990]   - Field: ‘conditions’
[17:36:44.990]   - Field: ‘persistent’
[17:36:44.991]   - Field: ‘expr’
[17:36:44.991]   - Field: ‘uuid’
[17:36:44.991]   - Field: ‘seed’
[17:36:44.991]   - Field: ‘version’
[17:36:44.991]   - Field: ‘result’
[17:36:44.991]   - Field: ‘asynchronous’
[17:36:44.991]   - Field: ‘calls’
[17:36:44.991]   - Field: ‘globals’
[17:36:44.991]   - Field: ‘stdout’
[17:36:44.991]   - Field: ‘earlySignal’
[17:36:44.991]   - Field: ‘lazy’
[17:36:44.991]   - Field: ‘state’
[17:36:44.992] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:44.992] - Launch lazy future ...
[17:36:44.992] Packages needed by the future expression (n = 1): ‘stats’
[17:36:44.992] Packages needed by future strategies (n = 0): <none>
[17:36:44.993] {
[17:36:44.993]     {
[17:36:44.993]         {
[17:36:44.993]             ...future.startTime <- base::Sys.time()
[17:36:44.993]             {
[17:36:44.993]                 {
[17:36:44.993]                   {
[17:36:44.993]                     {
[17:36:44.993]                       {
[17:36:44.993]                         base::local({
[17:36:44.993]                           has_future <- base::requireNamespace("future", 
[17:36:44.993]                             quietly = TRUE)
[17:36:44.993]                           if (has_future) {
[17:36:44.993]                             ns <- base::getNamespace("future")
[17:36:44.993]                             version <- ns[[".package"]][["version"]]
[17:36:44.993]                             if (is.null(version)) 
[17:36:44.993]                               version <- utils::packageVersion("future")
[17:36:44.993]                           }
[17:36:44.993]                           else {
[17:36:44.993]                             version <- NULL
[17:36:44.993]                           }
[17:36:44.993]                           if (!has_future || version < "1.8.0") {
[17:36:44.993]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:44.993]                               "", base::R.version$version.string), 
[17:36:44.993]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:44.993]                                 base::R.version$platform, 8 * 
[17:36:44.993]                                   base::.Machine$sizeof.pointer), 
[17:36:44.993]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:44.993]                                 "release", "version")], collapse = " "), 
[17:36:44.993]                               hostname = base::Sys.info()[["nodename"]])
[17:36:44.993]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:44.993]                               info)
[17:36:44.993]                             info <- base::paste(info, collapse = "; ")
[17:36:44.993]                             if (!has_future) {
[17:36:44.993]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:44.993]                                 info)
[17:36:44.993]                             }
[17:36:44.993]                             else {
[17:36:44.993]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:44.993]                                 info, version)
[17:36:44.993]                             }
[17:36:44.993]                             base::stop(msg)
[17:36:44.993]                           }
[17:36:44.993]                         })
[17:36:44.993]                       }
[17:36:44.993]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:44.993]                       base::options(mc.cores = 1L)
[17:36:44.993]                     }
[17:36:44.993]                     base::local({
[17:36:44.993]                       for (pkg in "stats") {
[17:36:44.993]                         base::loadNamespace(pkg)
[17:36:44.993]                         base::library(pkg, character.only = TRUE)
[17:36:44.993]                       }
[17:36:44.993]                     })
[17:36:44.993]                   }
[17:36:44.993]                   ...future.strategy.old <- future::plan("list")
[17:36:44.993]                   options(future.plan = NULL)
[17:36:44.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:44.993]                 }
[17:36:44.993]                 ...future.workdir <- getwd()
[17:36:44.993]             }
[17:36:44.993]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:44.993]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:44.993]         }
[17:36:44.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:44.993]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:44.993]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:44.993]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:44.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:44.993]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:44.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:44.993]             base::names(...future.oldOptions))
[17:36:44.993]     }
[17:36:44.993]     if (FALSE) {
[17:36:44.993]     }
[17:36:44.993]     else {
[17:36:44.993]         if (TRUE) {
[17:36:44.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:44.993]                 open = "w")
[17:36:44.993]         }
[17:36:44.993]         else {
[17:36:44.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:44.993]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:44.993]         }
[17:36:44.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:44.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:44.993]             base::sink(type = "output", split = FALSE)
[17:36:44.993]             base::close(...future.stdout)
[17:36:44.993]         }, add = TRUE)
[17:36:44.993]     }
[17:36:44.993]     ...future.frame <- base::sys.nframe()
[17:36:44.993]     ...future.conditions <- base::list()
[17:36:44.993]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:44.993]     if (FALSE) {
[17:36:44.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:44.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:44.993]     }
[17:36:44.993]     ...future.result <- base::tryCatch({
[17:36:44.993]         base::withCallingHandlers({
[17:36:44.993]             ...future.value <- base::withVisible(base::local({
[17:36:44.993]                 ...future.makeSendCondition <- base::local({
[17:36:44.993]                   sendCondition <- NULL
[17:36:44.993]                   function(frame = 1L) {
[17:36:44.993]                     if (is.function(sendCondition)) 
[17:36:44.993]                       return(sendCondition)
[17:36:44.993]                     ns <- getNamespace("parallel")
[17:36:44.993]                     if (exists("sendData", mode = "function", 
[17:36:44.993]                       envir = ns)) {
[17:36:44.993]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:44.993]                         envir = ns)
[17:36:44.993]                       envir <- sys.frame(frame)
[17:36:44.993]                       master <- NULL
[17:36:44.993]                       while (!identical(envir, .GlobalEnv) && 
[17:36:44.993]                         !identical(envir, emptyenv())) {
[17:36:44.993]                         if (exists("master", mode = "list", envir = envir, 
[17:36:44.993]                           inherits = FALSE)) {
[17:36:44.993]                           master <- get("master", mode = "list", 
[17:36:44.993]                             envir = envir, inherits = FALSE)
[17:36:44.993]                           if (inherits(master, c("SOCKnode", 
[17:36:44.993]                             "SOCK0node"))) {
[17:36:44.993]                             sendCondition <<- function(cond) {
[17:36:44.993]                               data <- list(type = "VALUE", value = cond, 
[17:36:44.993]                                 success = TRUE)
[17:36:44.993]                               parallel_sendData(master, data)
[17:36:44.993]                             }
[17:36:44.993]                             return(sendCondition)
[17:36:44.993]                           }
[17:36:44.993]                         }
[17:36:44.993]                         frame <- frame + 1L
[17:36:44.993]                         envir <- sys.frame(frame)
[17:36:44.993]                       }
[17:36:44.993]                     }
[17:36:44.993]                     sendCondition <<- function(cond) NULL
[17:36:44.993]                   }
[17:36:44.993]                 })
[17:36:44.993]                 withCallingHandlers({
[17:36:44.993]                   {
[17:36:44.993]                     do.call(function(...) {
[17:36:44.993]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:44.993]                       if (!identical(...future.globals.maxSize.org, 
[17:36:44.993]                         ...future.globals.maxSize)) {
[17:36:44.993]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:44.993]                         on.exit(options(oopts), add = TRUE)
[17:36:44.993]                       }
[17:36:44.993]                       {
[17:36:44.993]                         lapply(seq_along(...future.elements_ii), 
[17:36:44.993]                           FUN = function(jj) {
[17:36:44.993]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:44.993]                             ...future.FUN(...future.X_jj, ...)
[17:36:44.993]                           })
[17:36:44.993]                       }
[17:36:44.993]                     }, args = future.call.arguments)
[17:36:44.993]                   }
[17:36:44.993]                 }, immediateCondition = function(cond) {
[17:36:44.993]                   sendCondition <- ...future.makeSendCondition()
[17:36:44.993]                   sendCondition(cond)
[17:36:44.993]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.993]                   {
[17:36:44.993]                     inherits <- base::inherits
[17:36:44.993]                     invokeRestart <- base::invokeRestart
[17:36:44.993]                     is.null <- base::is.null
[17:36:44.993]                     muffled <- FALSE
[17:36:44.993]                     if (inherits(cond, "message")) {
[17:36:44.993]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:44.993]                       if (muffled) 
[17:36:44.993]                         invokeRestart("muffleMessage")
[17:36:44.993]                     }
[17:36:44.993]                     else if (inherits(cond, "warning")) {
[17:36:44.993]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:44.993]                       if (muffled) 
[17:36:44.993]                         invokeRestart("muffleWarning")
[17:36:44.993]                     }
[17:36:44.993]                     else if (inherits(cond, "condition")) {
[17:36:44.993]                       if (!is.null(pattern)) {
[17:36:44.993]                         computeRestarts <- base::computeRestarts
[17:36:44.993]                         grepl <- base::grepl
[17:36:44.993]                         restarts <- computeRestarts(cond)
[17:36:44.993]                         for (restart in restarts) {
[17:36:44.993]                           name <- restart$name
[17:36:44.993]                           if (is.null(name)) 
[17:36:44.993]                             next
[17:36:44.993]                           if (!grepl(pattern, name)) 
[17:36:44.993]                             next
[17:36:44.993]                           invokeRestart(restart)
[17:36:44.993]                           muffled <- TRUE
[17:36:44.993]                           break
[17:36:44.993]                         }
[17:36:44.993]                       }
[17:36:44.993]                     }
[17:36:44.993]                     invisible(muffled)
[17:36:44.993]                   }
[17:36:44.993]                   muffleCondition(cond)
[17:36:44.993]                 })
[17:36:44.993]             }))
[17:36:44.993]             future::FutureResult(value = ...future.value$value, 
[17:36:44.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.993]                   ...future.rng), globalenv = if (FALSE) 
[17:36:44.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:44.993]                     ...future.globalenv.names))
[17:36:44.993]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:44.993]         }, condition = base::local({
[17:36:44.993]             c <- base::c
[17:36:44.993]             inherits <- base::inherits
[17:36:44.993]             invokeRestart <- base::invokeRestart
[17:36:44.993]             length <- base::length
[17:36:44.993]             list <- base::list
[17:36:44.993]             seq.int <- base::seq.int
[17:36:44.993]             signalCondition <- base::signalCondition
[17:36:44.993]             sys.calls <- base::sys.calls
[17:36:44.993]             `[[` <- base::`[[`
[17:36:44.993]             `+` <- base::`+`
[17:36:44.993]             `<<-` <- base::`<<-`
[17:36:44.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:44.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:44.993]                   3L)]
[17:36:44.993]             }
[17:36:44.993]             function(cond) {
[17:36:44.993]                 is_error <- inherits(cond, "error")
[17:36:44.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:44.993]                   NULL)
[17:36:44.993]                 if (is_error) {
[17:36:44.993]                   sessionInformation <- function() {
[17:36:44.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:44.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:44.993]                       search = base::search(), system = base::Sys.info())
[17:36:44.993]                   }
[17:36:44.993]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:44.993]                     cond$call), session = sessionInformation(), 
[17:36:44.993]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:44.993]                   signalCondition(cond)
[17:36:44.993]                 }
[17:36:44.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:44.993]                 "immediateCondition"))) {
[17:36:44.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:44.993]                   ...future.conditions[[length(...future.conditions) + 
[17:36:44.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:44.993]                   if (TRUE && !signal) {
[17:36:44.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.993]                     {
[17:36:44.993]                       inherits <- base::inherits
[17:36:44.993]                       invokeRestart <- base::invokeRestart
[17:36:44.993]                       is.null <- base::is.null
[17:36:44.993]                       muffled <- FALSE
[17:36:44.993]                       if (inherits(cond, "message")) {
[17:36:44.993]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.993]                         if (muffled) 
[17:36:44.993]                           invokeRestart("muffleMessage")
[17:36:44.993]                       }
[17:36:44.993]                       else if (inherits(cond, "warning")) {
[17:36:44.993]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.993]                         if (muffled) 
[17:36:44.993]                           invokeRestart("muffleWarning")
[17:36:44.993]                       }
[17:36:44.993]                       else if (inherits(cond, "condition")) {
[17:36:44.993]                         if (!is.null(pattern)) {
[17:36:44.993]                           computeRestarts <- base::computeRestarts
[17:36:44.993]                           grepl <- base::grepl
[17:36:44.993]                           restarts <- computeRestarts(cond)
[17:36:44.993]                           for (restart in restarts) {
[17:36:44.993]                             name <- restart$name
[17:36:44.993]                             if (is.null(name)) 
[17:36:44.993]                               next
[17:36:44.993]                             if (!grepl(pattern, name)) 
[17:36:44.993]                               next
[17:36:44.993]                             invokeRestart(restart)
[17:36:44.993]                             muffled <- TRUE
[17:36:44.993]                             break
[17:36:44.993]                           }
[17:36:44.993]                         }
[17:36:44.993]                       }
[17:36:44.993]                       invisible(muffled)
[17:36:44.993]                     }
[17:36:44.993]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.993]                   }
[17:36:44.993]                 }
[17:36:44.993]                 else {
[17:36:44.993]                   if (TRUE) {
[17:36:44.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:44.993]                     {
[17:36:44.993]                       inherits <- base::inherits
[17:36:44.993]                       invokeRestart <- base::invokeRestart
[17:36:44.993]                       is.null <- base::is.null
[17:36:44.993]                       muffled <- FALSE
[17:36:44.993]                       if (inherits(cond, "message")) {
[17:36:44.993]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:44.993]                         if (muffled) 
[17:36:44.993]                           invokeRestart("muffleMessage")
[17:36:44.993]                       }
[17:36:44.993]                       else if (inherits(cond, "warning")) {
[17:36:44.993]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:44.993]                         if (muffled) 
[17:36:44.993]                           invokeRestart("muffleWarning")
[17:36:44.993]                       }
[17:36:44.993]                       else if (inherits(cond, "condition")) {
[17:36:44.993]                         if (!is.null(pattern)) {
[17:36:44.993]                           computeRestarts <- base::computeRestarts
[17:36:44.993]                           grepl <- base::grepl
[17:36:44.993]                           restarts <- computeRestarts(cond)
[17:36:44.993]                           for (restart in restarts) {
[17:36:44.993]                             name <- restart$name
[17:36:44.993]                             if (is.null(name)) 
[17:36:44.993]                               next
[17:36:44.993]                             if (!grepl(pattern, name)) 
[17:36:44.993]                               next
[17:36:44.993]                             invokeRestart(restart)
[17:36:44.993]                             muffled <- TRUE
[17:36:44.993]                             break
[17:36:44.993]                           }
[17:36:44.993]                         }
[17:36:44.993]                       }
[17:36:44.993]                       invisible(muffled)
[17:36:44.993]                     }
[17:36:44.993]                     muffleCondition(cond, pattern = "^muffle")
[17:36:44.993]                   }
[17:36:44.993]                 }
[17:36:44.993]             }
[17:36:44.993]         }))
[17:36:44.993]     }, error = function(ex) {
[17:36:44.993]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:44.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:44.993]                 ...future.rng), started = ...future.startTime, 
[17:36:44.993]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:44.993]             version = "1.8"), class = "FutureResult")
[17:36:44.993]     }, finally = {
[17:36:44.993]         if (!identical(...future.workdir, getwd())) 
[17:36:44.993]             setwd(...future.workdir)
[17:36:44.993]         {
[17:36:44.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:44.993]                 ...future.oldOptions$nwarnings <- NULL
[17:36:44.993]             }
[17:36:44.993]             base::options(...future.oldOptions)
[17:36:44.993]             if (.Platform$OS.type == "windows") {
[17:36:44.993]                 old_names <- names(...future.oldEnvVars)
[17:36:44.993]                 envs <- base::Sys.getenv()
[17:36:44.993]                 names <- names(envs)
[17:36:44.993]                 common <- intersect(names, old_names)
[17:36:44.993]                 added <- setdiff(names, old_names)
[17:36:44.993]                 removed <- setdiff(old_names, names)
[17:36:44.993]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:44.993]                   envs[common]]
[17:36:44.993]                 NAMES <- toupper(changed)
[17:36:44.993]                 args <- list()
[17:36:44.993]                 for (kk in seq_along(NAMES)) {
[17:36:44.993]                   name <- changed[[kk]]
[17:36:44.993]                   NAME <- NAMES[[kk]]
[17:36:44.993]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.993]                     next
[17:36:44.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.993]                 }
[17:36:44.993]                 NAMES <- toupper(added)
[17:36:44.993]                 for (kk in seq_along(NAMES)) {
[17:36:44.993]                   name <- added[[kk]]
[17:36:44.993]                   NAME <- NAMES[[kk]]
[17:36:44.993]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.993]                     next
[17:36:44.993]                   args[[name]] <- ""
[17:36:44.993]                 }
[17:36:44.993]                 NAMES <- toupper(removed)
[17:36:44.993]                 for (kk in seq_along(NAMES)) {
[17:36:44.993]                   name <- removed[[kk]]
[17:36:44.993]                   NAME <- NAMES[[kk]]
[17:36:44.993]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:44.993]                     next
[17:36:44.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:44.993]                 }
[17:36:44.993]                 if (length(args) > 0) 
[17:36:44.993]                   base::do.call(base::Sys.setenv, args = args)
[17:36:44.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:44.993]             }
[17:36:44.993]             else {
[17:36:44.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:44.993]             }
[17:36:44.993]             {
[17:36:44.993]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:44.993]                   0L) {
[17:36:44.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:44.993]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:44.993]                   base::options(opts)
[17:36:44.993]                 }
[17:36:44.993]                 {
[17:36:44.993]                   {
[17:36:44.993]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:44.993]                     NULL
[17:36:44.993]                   }
[17:36:44.993]                   options(future.plan = NULL)
[17:36:44.993]                   if (is.na(NA_character_)) 
[17:36:44.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:44.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:44.993]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:44.993]                     .init = FALSE)
[17:36:44.993]                 }
[17:36:44.993]             }
[17:36:44.993]         }
[17:36:44.993]     })
[17:36:44.993]     if (TRUE) {
[17:36:44.993]         base::sink(type = "output", split = FALSE)
[17:36:44.993]         if (TRUE) {
[17:36:44.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:44.993]         }
[17:36:44.993]         else {
[17:36:44.993]             ...future.result["stdout"] <- base::list(NULL)
[17:36:44.993]         }
[17:36:44.993]         base::close(...future.stdout)
[17:36:44.993]         ...future.stdout <- NULL
[17:36:44.993]     }
[17:36:44.993]     ...future.result$conditions <- ...future.conditions
[17:36:44.993]     ...future.result$finished <- base::Sys.time()
[17:36:44.993]     ...future.result
[17:36:44.993] }
[17:36:44.995] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[17:36:44.995] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:36:44.996] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:36:44.996] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:44.996] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:44.997] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[17:36:44.997] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[17:36:44.997] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:44.998] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:44.998] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:36:44.998] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:36:44.998] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[17:36:44.999] MultisessionFuture started
[17:36:44.999] - Launch lazy future ... done
[17:36:44.999] run() for ‘MultisessionFuture’ ... done
[17:36:45.000] Created future:
[17:36:45.000] MultisessionFuture:
[17:36:45.000] Label: ‘future_eapply-2’
[17:36:45.000] Expression:
[17:36:45.000] {
[17:36:45.000]     do.call(function(...) {
[17:36:45.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:45.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:45.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:45.000]             on.exit(options(oopts), add = TRUE)
[17:36:45.000]         }
[17:36:45.000]         {
[17:36:45.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:45.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:45.000]                 ...future.FUN(...future.X_jj, ...)
[17:36:45.000]             })
[17:36:45.000]         }
[17:36:45.000]     }, args = future.call.arguments)
[17:36:45.000] }
[17:36:45.000] Lazy evaluation: FALSE
[17:36:45.000] Asynchronous evaluation: TRUE
[17:36:45.000] Local evaluation: TRUE
[17:36:45.000] Environment: R_GlobalEnv
[17:36:45.000] Capture standard output: TRUE
[17:36:45.000] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:45.000] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:45.000] Packages: 1 packages (‘stats’)
[17:36:45.000] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:45.000] Resolved: FALSE
[17:36:45.000] Value: <not collected>
[17:36:45.000] Conditions captured: <none>
[17:36:45.000] Early signaling: FALSE
[17:36:45.000] Owner process: 65d65f3b-a923-b2f1-cba7-74d22442a56c
[17:36:45.000] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:45.011] Chunk #2 of 2 ... DONE
[17:36:45.011] Launching 2 futures (chunks) ... DONE
[17:36:45.012] Resolving 2 futures (chunks) ...
[17:36:45.012] resolve() on list ...
[17:36:45.012]  recursive: 0
[17:36:45.012]  length: 2
[17:36:45.012] 
[17:36:45.013] receiveMessageFromWorker() for ClusterFuture ...
[17:36:45.013] - Validating connection of MultisessionFuture
[17:36:45.013] - received message: FutureResult
[17:36:45.013] - Received FutureResult
[17:36:45.013] - Erased future from FutureRegistry
[17:36:45.013] result() for ClusterFuture ...
[17:36:45.013] - result already collected: FutureResult
[17:36:45.013] result() for ClusterFuture ... done
[17:36:45.014] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:45.014] Future #1
[17:36:45.014] result() for ClusterFuture ...
[17:36:45.014] - result already collected: FutureResult
[17:36:45.014] result() for ClusterFuture ... done
[17:36:45.014] result() for ClusterFuture ...
[17:36:45.014] - result already collected: FutureResult
[17:36:45.014] result() for ClusterFuture ... done
[17:36:45.014] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:45.014] - nx: 2
[17:36:45.014] - relay: TRUE
[17:36:45.014] - stdout: TRUE
[17:36:45.015] - signal: TRUE
[17:36:45.015] - resignal: FALSE
[17:36:45.015] - force: TRUE
[17:36:45.015] - relayed: [n=2] FALSE, FALSE
[17:36:45.015] - queued futures: [n=2] FALSE, FALSE
[17:36:45.015]  - until=1
[17:36:45.015]  - relaying element #1
[17:36:45.015] result() for ClusterFuture ...
[17:36:45.015] - result already collected: FutureResult
[17:36:45.015] result() for ClusterFuture ... done
[17:36:45.015] result() for ClusterFuture ...
[17:36:45.015] - result already collected: FutureResult
[17:36:45.016] result() for ClusterFuture ... done
[17:36:45.016] result() for ClusterFuture ...
[17:36:45.016] - result already collected: FutureResult
[17:36:45.016] result() for ClusterFuture ... done
[17:36:45.016] result() for ClusterFuture ...
[17:36:45.016] - result already collected: FutureResult
[17:36:45.016] result() for ClusterFuture ... done
[17:36:45.016] - relayed: [n=2] TRUE, FALSE
[17:36:45.016] - queued futures: [n=2] TRUE, FALSE
[17:36:45.016] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:45.016]  length: 1 (resolved future 1)
[17:36:45.042] receiveMessageFromWorker() for ClusterFuture ...
[17:36:45.043] - Validating connection of MultisessionFuture
[17:36:45.043] - received message: FutureResult
[17:36:45.043] - Received FutureResult
[17:36:45.043] - Erased future from FutureRegistry
[17:36:45.043] result() for ClusterFuture ...
[17:36:45.043] - result already collected: FutureResult
[17:36:45.044] result() for ClusterFuture ... done
[17:36:45.044] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:45.044] Future #2
[17:36:45.044] result() for ClusterFuture ...
[17:36:45.044] - result already collected: FutureResult
[17:36:45.044] result() for ClusterFuture ... done
[17:36:45.044] result() for ClusterFuture ...
[17:36:45.044] - result already collected: FutureResult
[17:36:45.044] result() for ClusterFuture ... done
[17:36:45.044] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:45.044] - nx: 2
[17:36:45.045] - relay: TRUE
[17:36:45.045] - stdout: TRUE
[17:36:45.045] - signal: TRUE
[17:36:45.045] - resignal: FALSE
[17:36:45.045] - force: TRUE
[17:36:45.045] - relayed: [n=2] TRUE, FALSE
[17:36:45.045] - queued futures: [n=2] TRUE, FALSE
[17:36:45.045]  - until=2
[17:36:45.045]  - relaying element #2
[17:36:45.045] result() for ClusterFuture ...
[17:36:45.045] - result already collected: FutureResult
[17:36:45.045] result() for ClusterFuture ... done
[17:36:45.046] result() for ClusterFuture ...
[17:36:45.046] - result already collected: FutureResult
[17:36:45.046] result() for ClusterFuture ... done
[17:36:45.046] result() for ClusterFuture ...
[17:36:45.046] - result already collected: FutureResult
[17:36:45.046] result() for ClusterFuture ... done
[17:36:45.046] result() for ClusterFuture ...
[17:36:45.046] - result already collected: FutureResult
[17:36:45.046] result() for ClusterFuture ... done
[17:36:45.046] - relayed: [n=2] TRUE, TRUE
[17:36:45.046] - queued futures: [n=2] TRUE, TRUE
[17:36:45.046] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:45.047]  length: 0 (resolved future 2)
[17:36:45.047] Relaying remaining futures
[17:36:45.047] signalConditionsASAP(NULL, pos=0) ...
[17:36:45.047] - nx: 2
[17:36:45.047] - relay: TRUE
[17:36:45.047] - stdout: TRUE
[17:36:45.047] - signal: TRUE
[17:36:45.047] - resignal: FALSE
[17:36:45.047] - force: TRUE
[17:36:45.047] - relayed: [n=2] TRUE, TRUE
[17:36:45.047] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:45.048] - relayed: [n=2] TRUE, TRUE
[17:36:45.048] - queued futures: [n=2] TRUE, TRUE
[17:36:45.048] signalConditionsASAP(NULL, pos=0) ... done
[17:36:45.048] resolve() on list ... DONE
[17:36:45.048] result() for ClusterFuture ...
[17:36:45.048] - result already collected: FutureResult
[17:36:45.048] result() for ClusterFuture ... done
[17:36:45.048] result() for ClusterFuture ...
[17:36:45.048] - result already collected: FutureResult
[17:36:45.048] result() for ClusterFuture ... done
[17:36:45.048] result() for ClusterFuture ...
[17:36:45.049] - result already collected: FutureResult
[17:36:45.049] result() for ClusterFuture ... done
[17:36:45.049] result() for ClusterFuture ...
[17:36:45.049] - result already collected: FutureResult
[17:36:45.049] result() for ClusterFuture ... done
[17:36:45.049]  - Number of value chunks collected: 2
[17:36:45.049] Resolving 2 futures (chunks) ... DONE
[17:36:45.049] Reducing values from 2 chunks ...
[17:36:45.049]  - Number of values collected after concatenation: 3
[17:36:45.049]  - Number of values expected: 3
[17:36:45.049] Reducing values from 2 chunks ... DONE
[17:36:45.050] future_lapply() ... DONE
[17:36:45.050] plan(): Setting new future strategy stack:
[17:36:45.050] List of future strategies:
[17:36:45.050] 1. sequential:
[17:36:45.050]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:45.050]    - tweaked: FALSE
[17:36:45.050]    - call: plan(sequential)
[17:36:45.051] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[17:36:45.052] plan(): Setting new future strategy stack:
[17:36:45.052] List of future strategies:
[17:36:45.052] 1. FutureStrategy:
[17:36:45.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:45.052]    - tweaked: FALSE
[17:36:45.052]    - call: future::plan(oplan)
[17:36:45.052] plan(): nbrOfWorkers() = 1
> 
