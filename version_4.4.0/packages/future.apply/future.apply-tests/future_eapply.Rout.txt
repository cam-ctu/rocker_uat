
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[09:28:25.569] plan(): Setting new future strategy stack:
[09:28:25.569] List of future strategies:
[09:28:25.569] 1. sequential:
[09:28:25.569]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.569]    - tweaked: FALSE
[09:28:25.569]    - call: future::plan("sequential")
[09:28:25.583] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[09:28:25.605] plan(): Setting new future strategy stack:
[09:28:25.605] List of future strategies:
[09:28:25.605] 1. sequential:
[09:28:25.605]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.605]    - tweaked: FALSE
[09:28:25.605]    - call: plan(strategy)
[09:28:25.617] plan(): nbrOfWorkers() = 1
[09:28:25.617] future_lapply() ...
[09:28:25.621] Number of chunks: 1
[09:28:25.621] getGlobalsAndPackagesXApply() ...
[09:28:25.621]  - future.globals: TRUE
[09:28:25.622] getGlobalsAndPackages() ...
[09:28:25.622] Searching for globals...
[09:28:25.624] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:25.624] Searching for globals ... DONE
[09:28:25.625] Resolving globals: FALSE
[09:28:25.625] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:25.626] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:25.626] - globals: [1] ‘FUN’
[09:28:25.626] 
[09:28:25.626] getGlobalsAndPackages() ... DONE
[09:28:25.626]  - globals found/used: [n=1] ‘FUN’
[09:28:25.626]  - needed namespaces: [n=0] 
[09:28:25.626] Finding globals ... DONE
[09:28:25.627]  - use_args: TRUE
[09:28:25.627]  - Getting '...' globals ...
[09:28:25.627] resolve() on list ...
[09:28:25.627]  recursive: 0
[09:28:25.628]  length: 1
[09:28:25.628]  elements: ‘...’
[09:28:25.628]  length: 0 (resolved future 1)
[09:28:25.628] resolve() on list ... DONE
[09:28:25.628]    - '...' content: [n=0] 
[09:28:25.628] List of 1
[09:28:25.628]  $ ...: list()
[09:28:25.628]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.628]  - attr(*, "where")=List of 1
[09:28:25.628]   ..$ ...:<environment: 0x55666417cd78> 
[09:28:25.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.628]  - attr(*, "resolved")= logi TRUE
[09:28:25.628]  - attr(*, "total_size")= num NA
[09:28:25.633]  - Getting '...' globals ... DONE
[09:28:25.633] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:25.633] List of 2
[09:28:25.633]  $ ...future.FUN:function (x, ...)  
[09:28:25.633]  $ ...          : list()
[09:28:25.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.633]  - attr(*, "where")=List of 2
[09:28:25.633]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:25.633]   ..$ ...          :<environment: 0x55666417cd78> 
[09:28:25.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.633]  - attr(*, "resolved")= logi FALSE
[09:28:25.633]  - attr(*, "total_size")= num 1240
[09:28:25.636] Packages to be attached in all futures: [n=0] 
[09:28:25.636] getGlobalsAndPackagesXApply() ... DONE
[09:28:25.636] Number of futures (= number of chunks): 1
[09:28:25.636] Launching 1 futures (chunks) ...
[09:28:25.636] Chunk #1 of 1 ...
[09:28:25.636]  - Finding globals in 'X' for chunk #1 ...
[09:28:25.637] getGlobalsAndPackages() ...
[09:28:25.637] Searching for globals...
[09:28:25.637] 
[09:28:25.637] Searching for globals ... DONE
[09:28:25.637] - globals: [0] <none>
[09:28:25.637] getGlobalsAndPackages() ... DONE
[09:28:25.637]    + additional globals found: [n=0] 
[09:28:25.637]    + additional namespaces needed: [n=0] 
[09:28:25.637]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:25.638]  - seeds: <none>
[09:28:25.638]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.638] getGlobalsAndPackages() ...
[09:28:25.638] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.638] Resolving globals: FALSE
[09:28:25.638] Tweak future expression to call with '...' arguments ...
[09:28:25.638] {
[09:28:25.638]     do.call(function(...) {
[09:28:25.638]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.638]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.638]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.638]             on.exit(options(oopts), add = TRUE)
[09:28:25.638]         }
[09:28:25.638]         {
[09:28:25.638]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.638]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.638]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.638]             })
[09:28:25.638]         }
[09:28:25.638]     }, args = future.call.arguments)
[09:28:25.638] }
[09:28:25.639] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.639] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.639] 
[09:28:25.639] getGlobalsAndPackages() ... DONE
[09:28:25.640] run() for ‘Future’ ...
[09:28:25.640] - state: ‘created’
[09:28:25.640] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:25.640] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:25.640] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:25.641]   - Field: ‘label’
[09:28:25.641]   - Field: ‘local’
[09:28:25.641]   - Field: ‘owner’
[09:28:25.641]   - Field: ‘envir’
[09:28:25.641]   - Field: ‘packages’
[09:28:25.641]   - Field: ‘gc’
[09:28:25.641]   - Field: ‘conditions’
[09:28:25.641]   - Field: ‘expr’
[09:28:25.641]   - Field: ‘uuid’
[09:28:25.641]   - Field: ‘seed’
[09:28:25.641]   - Field: ‘version’
[09:28:25.642]   - Field: ‘result’
[09:28:25.642]   - Field: ‘asynchronous’
[09:28:25.642]   - Field: ‘calls’
[09:28:25.642]   - Field: ‘globals’
[09:28:25.642]   - Field: ‘stdout’
[09:28:25.642]   - Field: ‘earlySignal’
[09:28:25.642]   - Field: ‘lazy’
[09:28:25.642]   - Field: ‘state’
[09:28:25.642] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:25.642] - Launch lazy future ...
[09:28:25.643] Packages needed by the future expression (n = 0): <none>
[09:28:25.643] Packages needed by future strategies (n = 0): <none>
[09:28:25.644] {
[09:28:25.644]     {
[09:28:25.644]         {
[09:28:25.644]             ...future.startTime <- base::Sys.time()
[09:28:25.644]             {
[09:28:25.644]                 {
[09:28:25.644]                   {
[09:28:25.644]                     base::local({
[09:28:25.644]                       has_future <- base::requireNamespace("future", 
[09:28:25.644]                         quietly = TRUE)
[09:28:25.644]                       if (has_future) {
[09:28:25.644]                         ns <- base::getNamespace("future")
[09:28:25.644]                         version <- ns[[".package"]][["version"]]
[09:28:25.644]                         if (is.null(version)) 
[09:28:25.644]                           version <- utils::packageVersion("future")
[09:28:25.644]                       }
[09:28:25.644]                       else {
[09:28:25.644]                         version <- NULL
[09:28:25.644]                       }
[09:28:25.644]                       if (!has_future || version < "1.8.0") {
[09:28:25.644]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.644]                           "", base::R.version$version.string), 
[09:28:25.644]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:25.644]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:25.644]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.644]                             "release", "version")], collapse = " "), 
[09:28:25.644]                           hostname = base::Sys.info()[["nodename"]])
[09:28:25.644]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.644]                           info)
[09:28:25.644]                         info <- base::paste(info, collapse = "; ")
[09:28:25.644]                         if (!has_future) {
[09:28:25.644]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.644]                             info)
[09:28:25.644]                         }
[09:28:25.644]                         else {
[09:28:25.644]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.644]                             info, version)
[09:28:25.644]                         }
[09:28:25.644]                         base::stop(msg)
[09:28:25.644]                       }
[09:28:25.644]                     })
[09:28:25.644]                   }
[09:28:25.644]                   ...future.strategy.old <- future::plan("list")
[09:28:25.644]                   options(future.plan = NULL)
[09:28:25.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.644]                 }
[09:28:25.644]                 ...future.workdir <- getwd()
[09:28:25.644]             }
[09:28:25.644]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.644]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.644]         }
[09:28:25.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:25.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.644]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.644]             base::names(...future.oldOptions))
[09:28:25.644]     }
[09:28:25.644]     if (FALSE) {
[09:28:25.644]     }
[09:28:25.644]     else {
[09:28:25.644]         if (TRUE) {
[09:28:25.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.644]                 open = "w")
[09:28:25.644]         }
[09:28:25.644]         else {
[09:28:25.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.644]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.644]         }
[09:28:25.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.644]             base::sink(type = "output", split = FALSE)
[09:28:25.644]             base::close(...future.stdout)
[09:28:25.644]         }, add = TRUE)
[09:28:25.644]     }
[09:28:25.644]     ...future.frame <- base::sys.nframe()
[09:28:25.644]     ...future.conditions <- base::list()
[09:28:25.644]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.644]     if (FALSE) {
[09:28:25.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.644]     }
[09:28:25.644]     ...future.result <- base::tryCatch({
[09:28:25.644]         base::withCallingHandlers({
[09:28:25.644]             ...future.value <- base::withVisible(base::local({
[09:28:25.644]                 do.call(function(...) {
[09:28:25.644]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.644]                   if (!identical(...future.globals.maxSize.org, 
[09:28:25.644]                     ...future.globals.maxSize)) {
[09:28:25.644]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.644]                     on.exit(options(oopts), add = TRUE)
[09:28:25.644]                   }
[09:28:25.644]                   {
[09:28:25.644]                     lapply(seq_along(...future.elements_ii), 
[09:28:25.644]                       FUN = function(jj) {
[09:28:25.644]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.644]                         ...future.FUN(...future.X_jj, ...)
[09:28:25.644]                       })
[09:28:25.644]                   }
[09:28:25.644]                 }, args = future.call.arguments)
[09:28:25.644]             }))
[09:28:25.644]             future::FutureResult(value = ...future.value$value, 
[09:28:25.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.644]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.644]                     ...future.globalenv.names))
[09:28:25.644]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.644]         }, condition = base::local({
[09:28:25.644]             c <- base::c
[09:28:25.644]             inherits <- base::inherits
[09:28:25.644]             invokeRestart <- base::invokeRestart
[09:28:25.644]             length <- base::length
[09:28:25.644]             list <- base::list
[09:28:25.644]             seq.int <- base::seq.int
[09:28:25.644]             signalCondition <- base::signalCondition
[09:28:25.644]             sys.calls <- base::sys.calls
[09:28:25.644]             `[[` <- base::`[[`
[09:28:25.644]             `+` <- base::`+`
[09:28:25.644]             `<<-` <- base::`<<-`
[09:28:25.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.644]                   3L)]
[09:28:25.644]             }
[09:28:25.644]             function(cond) {
[09:28:25.644]                 is_error <- inherits(cond, "error")
[09:28:25.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.644]                   NULL)
[09:28:25.644]                 if (is_error) {
[09:28:25.644]                   sessionInformation <- function() {
[09:28:25.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.644]                       search = base::search(), system = base::Sys.info())
[09:28:25.644]                   }
[09:28:25.644]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.644]                     cond$call), session = sessionInformation(), 
[09:28:25.644]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.644]                   signalCondition(cond)
[09:28:25.644]                 }
[09:28:25.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.644]                 "immediateCondition"))) {
[09:28:25.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.644]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.644]                   if (TRUE && !signal) {
[09:28:25.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.644]                     {
[09:28:25.644]                       inherits <- base::inherits
[09:28:25.644]                       invokeRestart <- base::invokeRestart
[09:28:25.644]                       is.null <- base::is.null
[09:28:25.644]                       muffled <- FALSE
[09:28:25.644]                       if (inherits(cond, "message")) {
[09:28:25.644]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.644]                         if (muffled) 
[09:28:25.644]                           invokeRestart("muffleMessage")
[09:28:25.644]                       }
[09:28:25.644]                       else if (inherits(cond, "warning")) {
[09:28:25.644]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.644]                         if (muffled) 
[09:28:25.644]                           invokeRestart("muffleWarning")
[09:28:25.644]                       }
[09:28:25.644]                       else if (inherits(cond, "condition")) {
[09:28:25.644]                         if (!is.null(pattern)) {
[09:28:25.644]                           computeRestarts <- base::computeRestarts
[09:28:25.644]                           grepl <- base::grepl
[09:28:25.644]                           restarts <- computeRestarts(cond)
[09:28:25.644]                           for (restart in restarts) {
[09:28:25.644]                             name <- restart$name
[09:28:25.644]                             if (is.null(name)) 
[09:28:25.644]                               next
[09:28:25.644]                             if (!grepl(pattern, name)) 
[09:28:25.644]                               next
[09:28:25.644]                             invokeRestart(restart)
[09:28:25.644]                             muffled <- TRUE
[09:28:25.644]                             break
[09:28:25.644]                           }
[09:28:25.644]                         }
[09:28:25.644]                       }
[09:28:25.644]                       invisible(muffled)
[09:28:25.644]                     }
[09:28:25.644]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.644]                   }
[09:28:25.644]                 }
[09:28:25.644]                 else {
[09:28:25.644]                   if (TRUE) {
[09:28:25.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.644]                     {
[09:28:25.644]                       inherits <- base::inherits
[09:28:25.644]                       invokeRestart <- base::invokeRestart
[09:28:25.644]                       is.null <- base::is.null
[09:28:25.644]                       muffled <- FALSE
[09:28:25.644]                       if (inherits(cond, "message")) {
[09:28:25.644]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.644]                         if (muffled) 
[09:28:25.644]                           invokeRestart("muffleMessage")
[09:28:25.644]                       }
[09:28:25.644]                       else if (inherits(cond, "warning")) {
[09:28:25.644]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.644]                         if (muffled) 
[09:28:25.644]                           invokeRestart("muffleWarning")
[09:28:25.644]                       }
[09:28:25.644]                       else if (inherits(cond, "condition")) {
[09:28:25.644]                         if (!is.null(pattern)) {
[09:28:25.644]                           computeRestarts <- base::computeRestarts
[09:28:25.644]                           grepl <- base::grepl
[09:28:25.644]                           restarts <- computeRestarts(cond)
[09:28:25.644]                           for (restart in restarts) {
[09:28:25.644]                             name <- restart$name
[09:28:25.644]                             if (is.null(name)) 
[09:28:25.644]                               next
[09:28:25.644]                             if (!grepl(pattern, name)) 
[09:28:25.644]                               next
[09:28:25.644]                             invokeRestart(restart)
[09:28:25.644]                             muffled <- TRUE
[09:28:25.644]                             break
[09:28:25.644]                           }
[09:28:25.644]                         }
[09:28:25.644]                       }
[09:28:25.644]                       invisible(muffled)
[09:28:25.644]                     }
[09:28:25.644]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.644]                   }
[09:28:25.644]                 }
[09:28:25.644]             }
[09:28:25.644]         }))
[09:28:25.644]     }, error = function(ex) {
[09:28:25.644]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.644]                 ...future.rng), started = ...future.startTime, 
[09:28:25.644]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.644]             version = "1.8"), class = "FutureResult")
[09:28:25.644]     }, finally = {
[09:28:25.644]         if (!identical(...future.workdir, getwd())) 
[09:28:25.644]             setwd(...future.workdir)
[09:28:25.644]         {
[09:28:25.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.644]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.644]             }
[09:28:25.644]             base::options(...future.oldOptions)
[09:28:25.644]             if (.Platform$OS.type == "windows") {
[09:28:25.644]                 old_names <- names(...future.oldEnvVars)
[09:28:25.644]                 envs <- base::Sys.getenv()
[09:28:25.644]                 names <- names(envs)
[09:28:25.644]                 common <- intersect(names, old_names)
[09:28:25.644]                 added <- setdiff(names, old_names)
[09:28:25.644]                 removed <- setdiff(old_names, names)
[09:28:25.644]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.644]                   envs[common]]
[09:28:25.644]                 NAMES <- toupper(changed)
[09:28:25.644]                 args <- list()
[09:28:25.644]                 for (kk in seq_along(NAMES)) {
[09:28:25.644]                   name <- changed[[kk]]
[09:28:25.644]                   NAME <- NAMES[[kk]]
[09:28:25.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.644]                     next
[09:28:25.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.644]                 }
[09:28:25.644]                 NAMES <- toupper(added)
[09:28:25.644]                 for (kk in seq_along(NAMES)) {
[09:28:25.644]                   name <- added[[kk]]
[09:28:25.644]                   NAME <- NAMES[[kk]]
[09:28:25.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.644]                     next
[09:28:25.644]                   args[[name]] <- ""
[09:28:25.644]                 }
[09:28:25.644]                 NAMES <- toupper(removed)
[09:28:25.644]                 for (kk in seq_along(NAMES)) {
[09:28:25.644]                   name <- removed[[kk]]
[09:28:25.644]                   NAME <- NAMES[[kk]]
[09:28:25.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.644]                     next
[09:28:25.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.644]                 }
[09:28:25.644]                 if (length(args) > 0) 
[09:28:25.644]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.644]             }
[09:28:25.644]             else {
[09:28:25.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.644]             }
[09:28:25.644]             {
[09:28:25.644]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.644]                   0L) {
[09:28:25.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.644]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.644]                   base::options(opts)
[09:28:25.644]                 }
[09:28:25.644]                 {
[09:28:25.644]                   {
[09:28:25.644]                     NULL
[09:28:25.644]                     RNGkind("Mersenne-Twister")
[09:28:25.644]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:25.644]                       inherits = FALSE)
[09:28:25.644]                   }
[09:28:25.644]                   options(future.plan = NULL)
[09:28:25.644]                   if (is.na(NA_character_)) 
[09:28:25.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.644]                     .init = FALSE)
[09:28:25.644]                 }
[09:28:25.644]             }
[09:28:25.644]         }
[09:28:25.644]     })
[09:28:25.644]     if (TRUE) {
[09:28:25.644]         base::sink(type = "output", split = FALSE)
[09:28:25.644]         if (TRUE) {
[09:28:25.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.644]         }
[09:28:25.644]         else {
[09:28:25.644]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.644]         }
[09:28:25.644]         base::close(...future.stdout)
[09:28:25.644]         ...future.stdout <- NULL
[09:28:25.644]     }
[09:28:25.644]     ...future.result$conditions <- ...future.conditions
[09:28:25.644]     ...future.result$finished <- base::Sys.time()
[09:28:25.644]     ...future.result
[09:28:25.644] }
[09:28:25.646] assign_globals() ...
[09:28:25.646] List of 5
[09:28:25.646]  $ ...future.FUN            :function (x, ...)  
[09:28:25.646]  $ future.call.arguments    : list()
[09:28:25.646]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.646]  $ ...future.elements_ii    :List of 3
[09:28:25.646]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[09:28:25.646]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[09:28:25.646]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:28:25.646]  $ ...future.seeds_ii       : NULL
[09:28:25.646]  $ ...future.globals.maxSize: NULL
[09:28:25.646]  - attr(*, "where")=List of 5
[09:28:25.646]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:25.646]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:25.646]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:25.646]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:25.646]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:25.646]  - attr(*, "resolved")= logi FALSE
[09:28:25.646]  - attr(*, "total_size")= num 1240
[09:28:25.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.646]  - attr(*, "already-done")= logi TRUE
[09:28:25.653] - copied ‘...future.FUN’ to environment
[09:28:25.654] - copied ‘future.call.arguments’ to environment
[09:28:25.654] - copied ‘...future.elements_ii’ to environment
[09:28:25.654] - copied ‘...future.seeds_ii’ to environment
[09:28:25.654] - copied ‘...future.globals.maxSize’ to environment
[09:28:25.654] assign_globals() ... done
[09:28:25.654] plan(): Setting new future strategy stack:
[09:28:25.654] List of future strategies:
[09:28:25.654] 1. sequential:
[09:28:25.654]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.654]    - tweaked: FALSE
[09:28:25.654]    - call: NULL
[09:28:25.655] plan(): nbrOfWorkers() = 1
[09:28:25.656] plan(): Setting new future strategy stack:
[09:28:25.656] List of future strategies:
[09:28:25.656] 1. sequential:
[09:28:25.656]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.656]    - tweaked: FALSE
[09:28:25.656]    - call: plan(strategy)
[09:28:25.656] plan(): nbrOfWorkers() = 1
[09:28:25.657] SequentialFuture started (and completed)
[09:28:25.657] - Launch lazy future ... done
[09:28:25.657] run() for ‘SequentialFuture’ ... done
[09:28:25.657] Created future:
[09:28:25.657] SequentialFuture:
[09:28:25.657] Label: ‘future_eapply-1’
[09:28:25.657] Expression:
[09:28:25.657] {
[09:28:25.657]     do.call(function(...) {
[09:28:25.657]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.657]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.657]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.657]             on.exit(options(oopts), add = TRUE)
[09:28:25.657]         }
[09:28:25.657]         {
[09:28:25.657]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.657]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.657]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.657]             })
[09:28:25.657]         }
[09:28:25.657]     }, args = future.call.arguments)
[09:28:25.657] }
[09:28:25.657] Lazy evaluation: FALSE
[09:28:25.657] Asynchronous evaluation: FALSE
[09:28:25.657] Local evaluation: TRUE
[09:28:25.657] Environment: R_GlobalEnv
[09:28:25.657] Capture standard output: TRUE
[09:28:25.657] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.657] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.657] Packages: <none>
[09:28:25.657] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.657] Resolved: TRUE
[09:28:25.657] Value: 168 bytes of class ‘list’
[09:28:25.657] Early signaling: FALSE
[09:28:25.657] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:25.657] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:25.659] Chunk #1 of 1 ... DONE
[09:28:25.659] Launching 1 futures (chunks) ... DONE
[09:28:25.659] Resolving 1 futures (chunks) ...
[09:28:25.659] resolve() on list ...
[09:28:25.659]  recursive: 0
[09:28:25.659]  length: 1
[09:28:25.659] 
[09:28:25.659] resolved() for ‘SequentialFuture’ ...
[09:28:25.660] - state: ‘finished’
[09:28:25.660] - run: TRUE
[09:28:25.660] - result: ‘FutureResult’
[09:28:25.660] resolved() for ‘SequentialFuture’ ... done
[09:28:25.660] Future #1
[09:28:25.660] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:25.660] - nx: 1
[09:28:25.661] - relay: TRUE
[09:28:25.661] - stdout: TRUE
[09:28:25.661] - signal: TRUE
[09:28:25.661] - resignal: FALSE
[09:28:25.661] - force: TRUE
[09:28:25.661] - relayed: [n=1] FALSE
[09:28:25.661] - queued futures: [n=1] FALSE
[09:28:25.661]  - until=1
[09:28:25.661]  - relaying element #1
[09:28:25.661] - relayed: [n=1] TRUE
[09:28:25.661] - queued futures: [n=1] TRUE
[09:28:25.662] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:25.662]  length: 0 (resolved future 1)
[09:28:25.662] Relaying remaining futures
[09:28:25.662] signalConditionsASAP(NULL, pos=0) ...
[09:28:25.662] - nx: 1
[09:28:25.662] - relay: TRUE
[09:28:25.662] - stdout: TRUE
[09:28:25.662] - signal: TRUE
[09:28:25.662] - resignal: FALSE
[09:28:25.662] - force: TRUE
[09:28:25.662] - relayed: [n=1] TRUE
[09:28:25.663] - queued futures: [n=1] TRUE
 - flush all
[09:28:25.663] - relayed: [n=1] TRUE
[09:28:25.663] - queued futures: [n=1] TRUE
[09:28:25.663] signalConditionsASAP(NULL, pos=0) ... done
[09:28:25.663] resolve() on list ... DONE
[09:28:25.663]  - Number of value chunks collected: 1
[09:28:25.663] Resolving 1 futures (chunks) ... DONE
[09:28:25.663] Reducing values from 1 chunks ...
[09:28:25.663]  - Number of values collected after concatenation: 3
[09:28:25.663]  - Number of values expected: 3
[09:28:25.664] Reducing values from 1 chunks ... DONE
[09:28:25.664] future_lapply() ... DONE
[09:28:25.665] future_lapply() ...
[09:28:25.666] Number of chunks: 1
[09:28:25.666] getGlobalsAndPackagesXApply() ...
[09:28:25.666]  - future.globals: TRUE
[09:28:25.666] getGlobalsAndPackages() ...
[09:28:25.666] Searching for globals...
[09:28:25.667] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:25.667] Searching for globals ... DONE
[09:28:25.667] Resolving globals: FALSE
[09:28:25.668] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:25.668] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:25.668] - globals: [1] ‘FUN’
[09:28:25.668] - packages: [1] ‘stats’
[09:28:25.668] getGlobalsAndPackages() ... DONE
[09:28:25.669]  - globals found/used: [n=1] ‘FUN’
[09:28:25.669]  - needed namespaces: [n=1] ‘stats’
[09:28:25.669] Finding globals ... DONE
[09:28:25.669]  - use_args: TRUE
[09:28:25.669]  - Getting '...' globals ...
[09:28:25.669] resolve() on list ...
[09:28:25.669]  recursive: 0
[09:28:25.669]  length: 1
[09:28:25.669]  elements: ‘...’
[09:28:25.670]  length: 0 (resolved future 1)
[09:28:25.670] resolve() on list ... DONE
[09:28:25.670]    - '...' content: [n=1] ‘probs’
[09:28:25.670] List of 1
[09:28:25.670]  $ ...:List of 1
[09:28:25.670]   ..$ probs: num [1:3] 0.25 0.5 0.75
[09:28:25.670]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.670]  - attr(*, "where")=List of 1
[09:28:25.670]   ..$ ...:<environment: 0x556665fd8930> 
[09:28:25.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.670]  - attr(*, "resolved")= logi TRUE
[09:28:25.670]  - attr(*, "total_size")= num NA
[09:28:25.673]  - Getting '...' globals ... DONE
[09:28:25.673] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:25.673] List of 2
[09:28:25.673]  $ ...future.FUN:function (x, ...)  
[09:28:25.673]  $ ...          :List of 1
[09:28:25.673]   ..$ probs: num [1:3] 0.25 0.5 0.75
[09:28:25.673]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.673]  - attr(*, "where")=List of 2
[09:28:25.673]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:25.673]   ..$ ...          :<environment: 0x556665fd8930> 
[09:28:25.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.673]  - attr(*, "resolved")= logi FALSE
[09:28:25.673]  - attr(*, "total_size")= num 1328
[09:28:25.676] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:25.676] getGlobalsAndPackagesXApply() ... DONE
[09:28:25.676] Number of futures (= number of chunks): 1
[09:28:25.676] Launching 1 futures (chunks) ...
[09:28:25.676] Chunk #1 of 1 ...
[09:28:25.676]  - Finding globals in 'X' for chunk #1 ...
[09:28:25.676] getGlobalsAndPackages() ...
[09:28:25.676] Searching for globals...
[09:28:25.677] 
[09:28:25.677] Searching for globals ... DONE
[09:28:25.677] - globals: [0] <none>
[09:28:25.677] getGlobalsAndPackages() ... DONE
[09:28:25.677]    + additional globals found: [n=0] 
[09:28:25.678]    + additional namespaces needed: [n=0] 
[09:28:25.679]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:25.679]  - seeds: <none>
[09:28:25.679]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.679] getGlobalsAndPackages() ...
[09:28:25.679] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.679] Resolving globals: FALSE
[09:28:25.679] Tweak future expression to call with '...' arguments ...
[09:28:25.679] {
[09:28:25.679]     do.call(function(...) {
[09:28:25.679]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.679]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.679]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.679]             on.exit(options(oopts), add = TRUE)
[09:28:25.679]         }
[09:28:25.679]         {
[09:28:25.679]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.679]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.679]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.679]             })
[09:28:25.679]         }
[09:28:25.679]     }, args = future.call.arguments)
[09:28:25.679] }
[09:28:25.679] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.680] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.680] - packages: [1] ‘stats’
[09:28:25.680] getGlobalsAndPackages() ... DONE
[09:28:25.680] run() for ‘Future’ ...
[09:28:25.680] - state: ‘created’
[09:28:25.680] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:25.681] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:25.681] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:25.681]   - Field: ‘label’
[09:28:25.681]   - Field: ‘local’
[09:28:25.681]   - Field: ‘owner’
[09:28:25.681]   - Field: ‘envir’
[09:28:25.681]   - Field: ‘packages’
[09:28:25.681]   - Field: ‘gc’
[09:28:25.681]   - Field: ‘conditions’
[09:28:25.682]   - Field: ‘expr’
[09:28:25.682]   - Field: ‘uuid’
[09:28:25.682]   - Field: ‘seed’
[09:28:25.682]   - Field: ‘version’
[09:28:25.682]   - Field: ‘result’
[09:28:25.682]   - Field: ‘asynchronous’
[09:28:25.682]   - Field: ‘calls’
[09:28:25.682]   - Field: ‘globals’
[09:28:25.682]   - Field: ‘stdout’
[09:28:25.682]   - Field: ‘earlySignal’
[09:28:25.682]   - Field: ‘lazy’
[09:28:25.683]   - Field: ‘state’
[09:28:25.683] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:25.683] - Launch lazy future ...
[09:28:25.683] Packages needed by the future expression (n = 1): ‘stats’
[09:28:25.683] Packages needed by future strategies (n = 0): <none>
[09:28:25.683] {
[09:28:25.683]     {
[09:28:25.683]         {
[09:28:25.683]             ...future.startTime <- base::Sys.time()
[09:28:25.683]             {
[09:28:25.683]                 {
[09:28:25.683]                   {
[09:28:25.683]                     {
[09:28:25.683]                       base::local({
[09:28:25.683]                         has_future <- base::requireNamespace("future", 
[09:28:25.683]                           quietly = TRUE)
[09:28:25.683]                         if (has_future) {
[09:28:25.683]                           ns <- base::getNamespace("future")
[09:28:25.683]                           version <- ns[[".package"]][["version"]]
[09:28:25.683]                           if (is.null(version)) 
[09:28:25.683]                             version <- utils::packageVersion("future")
[09:28:25.683]                         }
[09:28:25.683]                         else {
[09:28:25.683]                           version <- NULL
[09:28:25.683]                         }
[09:28:25.683]                         if (!has_future || version < "1.8.0") {
[09:28:25.683]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.683]                             "", base::R.version$version.string), 
[09:28:25.683]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:25.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:25.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.683]                               "release", "version")], collapse = " "), 
[09:28:25.683]                             hostname = base::Sys.info()[["nodename"]])
[09:28:25.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.683]                             info)
[09:28:25.683]                           info <- base::paste(info, collapse = "; ")
[09:28:25.683]                           if (!has_future) {
[09:28:25.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.683]                               info)
[09:28:25.683]                           }
[09:28:25.683]                           else {
[09:28:25.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.683]                               info, version)
[09:28:25.683]                           }
[09:28:25.683]                           base::stop(msg)
[09:28:25.683]                         }
[09:28:25.683]                       })
[09:28:25.683]                     }
[09:28:25.683]                     base::local({
[09:28:25.683]                       for (pkg in "stats") {
[09:28:25.683]                         base::loadNamespace(pkg)
[09:28:25.683]                         base::library(pkg, character.only = TRUE)
[09:28:25.683]                       }
[09:28:25.683]                     })
[09:28:25.683]                   }
[09:28:25.683]                   ...future.strategy.old <- future::plan("list")
[09:28:25.683]                   options(future.plan = NULL)
[09:28:25.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.683]                 }
[09:28:25.683]                 ...future.workdir <- getwd()
[09:28:25.683]             }
[09:28:25.683]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.683]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.683]         }
[09:28:25.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:25.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.683]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.683]             base::names(...future.oldOptions))
[09:28:25.683]     }
[09:28:25.683]     if (FALSE) {
[09:28:25.683]     }
[09:28:25.683]     else {
[09:28:25.683]         if (TRUE) {
[09:28:25.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.683]                 open = "w")
[09:28:25.683]         }
[09:28:25.683]         else {
[09:28:25.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.683]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.683]         }
[09:28:25.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.683]             base::sink(type = "output", split = FALSE)
[09:28:25.683]             base::close(...future.stdout)
[09:28:25.683]         }, add = TRUE)
[09:28:25.683]     }
[09:28:25.683]     ...future.frame <- base::sys.nframe()
[09:28:25.683]     ...future.conditions <- base::list()
[09:28:25.683]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.683]     if (FALSE) {
[09:28:25.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.683]     }
[09:28:25.683]     ...future.result <- base::tryCatch({
[09:28:25.683]         base::withCallingHandlers({
[09:28:25.683]             ...future.value <- base::withVisible(base::local({
[09:28:25.683]                 do.call(function(...) {
[09:28:25.683]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.683]                   if (!identical(...future.globals.maxSize.org, 
[09:28:25.683]                     ...future.globals.maxSize)) {
[09:28:25.683]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.683]                     on.exit(options(oopts), add = TRUE)
[09:28:25.683]                   }
[09:28:25.683]                   {
[09:28:25.683]                     lapply(seq_along(...future.elements_ii), 
[09:28:25.683]                       FUN = function(jj) {
[09:28:25.683]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.683]                         ...future.FUN(...future.X_jj, ...)
[09:28:25.683]                       })
[09:28:25.683]                   }
[09:28:25.683]                 }, args = future.call.arguments)
[09:28:25.683]             }))
[09:28:25.683]             future::FutureResult(value = ...future.value$value, 
[09:28:25.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.683]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.683]                     ...future.globalenv.names))
[09:28:25.683]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.683]         }, condition = base::local({
[09:28:25.683]             c <- base::c
[09:28:25.683]             inherits <- base::inherits
[09:28:25.683]             invokeRestart <- base::invokeRestart
[09:28:25.683]             length <- base::length
[09:28:25.683]             list <- base::list
[09:28:25.683]             seq.int <- base::seq.int
[09:28:25.683]             signalCondition <- base::signalCondition
[09:28:25.683]             sys.calls <- base::sys.calls
[09:28:25.683]             `[[` <- base::`[[`
[09:28:25.683]             `+` <- base::`+`
[09:28:25.683]             `<<-` <- base::`<<-`
[09:28:25.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.683]                   3L)]
[09:28:25.683]             }
[09:28:25.683]             function(cond) {
[09:28:25.683]                 is_error <- inherits(cond, "error")
[09:28:25.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.683]                   NULL)
[09:28:25.683]                 if (is_error) {
[09:28:25.683]                   sessionInformation <- function() {
[09:28:25.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.683]                       search = base::search(), system = base::Sys.info())
[09:28:25.683]                   }
[09:28:25.683]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.683]                     cond$call), session = sessionInformation(), 
[09:28:25.683]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.683]                   signalCondition(cond)
[09:28:25.683]                 }
[09:28:25.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.683]                 "immediateCondition"))) {
[09:28:25.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.683]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.683]                   if (TRUE && !signal) {
[09:28:25.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.683]                     {
[09:28:25.683]                       inherits <- base::inherits
[09:28:25.683]                       invokeRestart <- base::invokeRestart
[09:28:25.683]                       is.null <- base::is.null
[09:28:25.683]                       muffled <- FALSE
[09:28:25.683]                       if (inherits(cond, "message")) {
[09:28:25.683]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.683]                         if (muffled) 
[09:28:25.683]                           invokeRestart("muffleMessage")
[09:28:25.683]                       }
[09:28:25.683]                       else if (inherits(cond, "warning")) {
[09:28:25.683]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.683]                         if (muffled) 
[09:28:25.683]                           invokeRestart("muffleWarning")
[09:28:25.683]                       }
[09:28:25.683]                       else if (inherits(cond, "condition")) {
[09:28:25.683]                         if (!is.null(pattern)) {
[09:28:25.683]                           computeRestarts <- base::computeRestarts
[09:28:25.683]                           grepl <- base::grepl
[09:28:25.683]                           restarts <- computeRestarts(cond)
[09:28:25.683]                           for (restart in restarts) {
[09:28:25.683]                             name <- restart$name
[09:28:25.683]                             if (is.null(name)) 
[09:28:25.683]                               next
[09:28:25.683]                             if (!grepl(pattern, name)) 
[09:28:25.683]                               next
[09:28:25.683]                             invokeRestart(restart)
[09:28:25.683]                             muffled <- TRUE
[09:28:25.683]                             break
[09:28:25.683]                           }
[09:28:25.683]                         }
[09:28:25.683]                       }
[09:28:25.683]                       invisible(muffled)
[09:28:25.683]                     }
[09:28:25.683]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.683]                   }
[09:28:25.683]                 }
[09:28:25.683]                 else {
[09:28:25.683]                   if (TRUE) {
[09:28:25.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.683]                     {
[09:28:25.683]                       inherits <- base::inherits
[09:28:25.683]                       invokeRestart <- base::invokeRestart
[09:28:25.683]                       is.null <- base::is.null
[09:28:25.683]                       muffled <- FALSE
[09:28:25.683]                       if (inherits(cond, "message")) {
[09:28:25.683]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.683]                         if (muffled) 
[09:28:25.683]                           invokeRestart("muffleMessage")
[09:28:25.683]                       }
[09:28:25.683]                       else if (inherits(cond, "warning")) {
[09:28:25.683]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.683]                         if (muffled) 
[09:28:25.683]                           invokeRestart("muffleWarning")
[09:28:25.683]                       }
[09:28:25.683]                       else if (inherits(cond, "condition")) {
[09:28:25.683]                         if (!is.null(pattern)) {
[09:28:25.683]                           computeRestarts <- base::computeRestarts
[09:28:25.683]                           grepl <- base::grepl
[09:28:25.683]                           restarts <- computeRestarts(cond)
[09:28:25.683]                           for (restart in restarts) {
[09:28:25.683]                             name <- restart$name
[09:28:25.683]                             if (is.null(name)) 
[09:28:25.683]                               next
[09:28:25.683]                             if (!grepl(pattern, name)) 
[09:28:25.683]                               next
[09:28:25.683]                             invokeRestart(restart)
[09:28:25.683]                             muffled <- TRUE
[09:28:25.683]                             break
[09:28:25.683]                           }
[09:28:25.683]                         }
[09:28:25.683]                       }
[09:28:25.683]                       invisible(muffled)
[09:28:25.683]                     }
[09:28:25.683]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.683]                   }
[09:28:25.683]                 }
[09:28:25.683]             }
[09:28:25.683]         }))
[09:28:25.683]     }, error = function(ex) {
[09:28:25.683]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.683]                 ...future.rng), started = ...future.startTime, 
[09:28:25.683]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.683]             version = "1.8"), class = "FutureResult")
[09:28:25.683]     }, finally = {
[09:28:25.683]         if (!identical(...future.workdir, getwd())) 
[09:28:25.683]             setwd(...future.workdir)
[09:28:25.683]         {
[09:28:25.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.683]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.683]             }
[09:28:25.683]             base::options(...future.oldOptions)
[09:28:25.683]             if (.Platform$OS.type == "windows") {
[09:28:25.683]                 old_names <- names(...future.oldEnvVars)
[09:28:25.683]                 envs <- base::Sys.getenv()
[09:28:25.683]                 names <- names(envs)
[09:28:25.683]                 common <- intersect(names, old_names)
[09:28:25.683]                 added <- setdiff(names, old_names)
[09:28:25.683]                 removed <- setdiff(old_names, names)
[09:28:25.683]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.683]                   envs[common]]
[09:28:25.683]                 NAMES <- toupper(changed)
[09:28:25.683]                 args <- list()
[09:28:25.683]                 for (kk in seq_along(NAMES)) {
[09:28:25.683]                   name <- changed[[kk]]
[09:28:25.683]                   NAME <- NAMES[[kk]]
[09:28:25.683]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.683]                     next
[09:28:25.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.683]                 }
[09:28:25.683]                 NAMES <- toupper(added)
[09:28:25.683]                 for (kk in seq_along(NAMES)) {
[09:28:25.683]                   name <- added[[kk]]
[09:28:25.683]                   NAME <- NAMES[[kk]]
[09:28:25.683]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.683]                     next
[09:28:25.683]                   args[[name]] <- ""
[09:28:25.683]                 }
[09:28:25.683]                 NAMES <- toupper(removed)
[09:28:25.683]                 for (kk in seq_along(NAMES)) {
[09:28:25.683]                   name <- removed[[kk]]
[09:28:25.683]                   NAME <- NAMES[[kk]]
[09:28:25.683]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.683]                     next
[09:28:25.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.683]                 }
[09:28:25.683]                 if (length(args) > 0) 
[09:28:25.683]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.683]             }
[09:28:25.683]             else {
[09:28:25.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.683]             }
[09:28:25.683]             {
[09:28:25.683]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.683]                   0L) {
[09:28:25.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.683]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.683]                   base::options(opts)
[09:28:25.683]                 }
[09:28:25.683]                 {
[09:28:25.683]                   {
[09:28:25.683]                     NULL
[09:28:25.683]                     RNGkind("Mersenne-Twister")
[09:28:25.683]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:25.683]                       inherits = FALSE)
[09:28:25.683]                   }
[09:28:25.683]                   options(future.plan = NULL)
[09:28:25.683]                   if (is.na(NA_character_)) 
[09:28:25.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.683]                     .init = FALSE)
[09:28:25.683]                 }
[09:28:25.683]             }
[09:28:25.683]         }
[09:28:25.683]     })
[09:28:25.683]     if (TRUE) {
[09:28:25.683]         base::sink(type = "output", split = FALSE)
[09:28:25.683]         if (TRUE) {
[09:28:25.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.683]         }
[09:28:25.683]         else {
[09:28:25.683]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.683]         }
[09:28:25.683]         base::close(...future.stdout)
[09:28:25.683]         ...future.stdout <- NULL
[09:28:25.683]     }
[09:28:25.683]     ...future.result$conditions <- ...future.conditions
[09:28:25.683]     ...future.result$finished <- base::Sys.time()
[09:28:25.683]     ...future.result
[09:28:25.683] }
[09:28:25.685] assign_globals() ...
[09:28:25.685] List of 5
[09:28:25.685]  $ ...future.FUN            :function (x, ...)  
[09:28:25.685]  $ future.call.arguments    :List of 1
[09:28:25.685]   ..$ probs: num [1:3] 0.25 0.5 0.75
[09:28:25.685]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.685]  $ ...future.elements_ii    :List of 3
[09:28:25.685]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[09:28:25.685]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[09:28:25.685]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:28:25.685]  $ ...future.seeds_ii       : NULL
[09:28:25.685]  $ ...future.globals.maxSize: NULL
[09:28:25.685]  - attr(*, "where")=List of 5
[09:28:25.685]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:25.685]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:25.685]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:25.685]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:25.685]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:25.685]  - attr(*, "resolved")= logi FALSE
[09:28:25.685]  - attr(*, "total_size")= num 1328
[09:28:25.685]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.685]  - attr(*, "already-done")= logi TRUE
[09:28:25.690] - copied ‘...future.FUN’ to environment
[09:28:25.691] - copied ‘future.call.arguments’ to environment
[09:28:25.691] - copied ‘...future.elements_ii’ to environment
[09:28:25.691] - copied ‘...future.seeds_ii’ to environment
[09:28:25.691] - copied ‘...future.globals.maxSize’ to environment
[09:28:25.691] assign_globals() ... done
[09:28:25.691] plan(): Setting new future strategy stack:
[09:28:25.691] List of future strategies:
[09:28:25.691] 1. sequential:
[09:28:25.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.691]    - tweaked: FALSE
[09:28:25.691]    - call: NULL
[09:28:25.692] plan(): nbrOfWorkers() = 1
[09:28:25.693] plan(): Setting new future strategy stack:
[09:28:25.693] List of future strategies:
[09:28:25.693] 1. sequential:
[09:28:25.693]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.693]    - tweaked: FALSE
[09:28:25.693]    - call: plan(strategy)
[09:28:25.693] plan(): nbrOfWorkers() = 1
[09:28:25.693] SequentialFuture started (and completed)
[09:28:25.694] - Launch lazy future ... done
[09:28:25.694] run() for ‘SequentialFuture’ ... done
[09:28:25.694] Created future:
[09:28:25.694] SequentialFuture:
[09:28:25.694] Label: ‘future_eapply-1’
[09:28:25.694] Expression:
[09:28:25.694] {
[09:28:25.694]     do.call(function(...) {
[09:28:25.694]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.694]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.694]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.694]             on.exit(options(oopts), add = TRUE)
[09:28:25.694]         }
[09:28:25.694]         {
[09:28:25.694]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.694]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.694]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.694]             })
[09:28:25.694]         }
[09:28:25.694]     }, args = future.call.arguments)
[09:28:25.694] }
[09:28:25.694] Lazy evaluation: FALSE
[09:28:25.694] Asynchronous evaluation: FALSE
[09:28:25.694] Local evaluation: TRUE
[09:28:25.694] Environment: R_GlobalEnv
[09:28:25.694] Capture standard output: TRUE
[09:28:25.694] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.694] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.694] Packages: 1 packages (‘stats’)
[09:28:25.694] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.694] Resolved: TRUE
[09:28:25.694] Value: 1.29 KiB of class ‘list’
[09:28:25.694] Early signaling: FALSE
[09:28:25.694] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:25.694] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:25.695] Chunk #1 of 1 ... DONE
[09:28:25.695] Launching 1 futures (chunks) ... DONE
[09:28:25.695] Resolving 1 futures (chunks) ...
[09:28:25.695] resolve() on list ...
[09:28:25.695]  recursive: 0
[09:28:25.695]  length: 1
[09:28:25.695] 
[09:28:25.695] resolved() for ‘SequentialFuture’ ...
[09:28:25.695] - state: ‘finished’
[09:28:25.696] - run: TRUE
[09:28:25.696] - result: ‘FutureResult’
[09:28:25.696] resolved() for ‘SequentialFuture’ ... done
[09:28:25.696] Future #1
[09:28:25.696] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:25.696] - nx: 1
[09:28:25.696] - relay: TRUE
[09:28:25.696] - stdout: TRUE
[09:28:25.696] - signal: TRUE
[09:28:25.696] - resignal: FALSE
[09:28:25.696] - force: TRUE
[09:28:25.697] - relayed: [n=1] FALSE
[09:28:25.697] - queued futures: [n=1] FALSE
[09:28:25.697]  - until=1
[09:28:25.697]  - relaying element #1
[09:28:25.697] - relayed: [n=1] TRUE
[09:28:25.697] - queued futures: [n=1] TRUE
[09:28:25.697] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:25.697]  length: 0 (resolved future 1)
[09:28:25.697] Relaying remaining futures
[09:28:25.697] signalConditionsASAP(NULL, pos=0) ...
[09:28:25.698] - nx: 1
[09:28:25.698] - relay: TRUE
[09:28:25.698] - stdout: TRUE
[09:28:25.698] - signal: TRUE
[09:28:25.698] - resignal: FALSE
[09:28:25.698] - force: TRUE
[09:28:25.698] - relayed: [n=1] TRUE
[09:28:25.698] - queued futures: [n=1] TRUE
 - flush all
[09:28:25.698] - relayed: [n=1] TRUE
[09:28:25.698] - queued futures: [n=1] TRUE
[09:28:25.698] signalConditionsASAP(NULL, pos=0) ... done
[09:28:25.698] resolve() on list ... DONE
[09:28:25.699]  - Number of value chunks collected: 1
[09:28:25.699] Resolving 1 futures (chunks) ... DONE
[09:28:25.699] Reducing values from 1 chunks ...
[09:28:25.699]  - Number of values collected after concatenation: 3
[09:28:25.699]  - Number of values expected: 3
[09:28:25.699] Reducing values from 1 chunks ... DONE
[09:28:25.699] future_lapply() ... DONE
[09:28:25.700] future_lapply() ...
[09:28:25.701] Number of chunks: 1
[09:28:25.701] getGlobalsAndPackagesXApply() ...
[09:28:25.701]  - future.globals: TRUE
[09:28:25.701] getGlobalsAndPackages() ...
[09:28:25.701] Searching for globals...
[09:28:25.702] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:25.702] Searching for globals ... DONE
[09:28:25.702] Resolving globals: FALSE
[09:28:25.704] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:25.704] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:25.704] - globals: [1] ‘FUN’
[09:28:25.704] - packages: [1] ‘stats’
[09:28:25.704] getGlobalsAndPackages() ... DONE
[09:28:25.704]  - globals found/used: [n=1] ‘FUN’
[09:28:25.704]  - needed namespaces: [n=1] ‘stats’
[09:28:25.705] Finding globals ... DONE
[09:28:25.705]  - use_args: TRUE
[09:28:25.705]  - Getting '...' globals ...
[09:28:25.705] resolve() on list ...
[09:28:25.705]  recursive: 0
[09:28:25.705]  length: 1
[09:28:25.705]  elements: ‘...’
[09:28:25.705]  length: 0 (resolved future 1)
[09:28:25.705] resolve() on list ... DONE
[09:28:25.706]    - '...' content: [n=0] 
[09:28:25.706] List of 1
[09:28:25.706]  $ ...: list()
[09:28:25.706]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.706]  - attr(*, "where")=List of 1
[09:28:25.706]   ..$ ...:<environment: 0x55666663eee0> 
[09:28:25.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.706]  - attr(*, "resolved")= logi TRUE
[09:28:25.706]  - attr(*, "total_size")= num NA
[09:28:25.708]  - Getting '...' globals ... DONE
[09:28:25.708] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:25.708] List of 2
[09:28:25.708]  $ ...future.FUN:function (x, ...)  
[09:28:25.708]  $ ...          : list()
[09:28:25.708]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.708]  - attr(*, "where")=List of 2
[09:28:25.708]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:25.708]   ..$ ...          :<environment: 0x55666663eee0> 
[09:28:25.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.708]  - attr(*, "resolved")= logi FALSE
[09:28:25.708]  - attr(*, "total_size")= num 1248
[09:28:25.711] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:25.711] getGlobalsAndPackagesXApply() ... DONE
[09:28:25.711] Number of futures (= number of chunks): 1
[09:28:25.711] Launching 1 futures (chunks) ...
[09:28:25.711] Chunk #1 of 1 ...
[09:28:25.711]  - Finding globals in 'X' for chunk #1 ...
[09:28:25.711] getGlobalsAndPackages() ...
[09:28:25.711] Searching for globals...
[09:28:25.712] 
[09:28:25.712] Searching for globals ... DONE
[09:28:25.712] - globals: [0] <none>
[09:28:25.712] getGlobalsAndPackages() ... DONE
[09:28:25.712]    + additional globals found: [n=0] 
[09:28:25.712]    + additional namespaces needed: [n=0] 
[09:28:25.712]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:25.712]  - seeds: <none>
[09:28:25.712]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.713] getGlobalsAndPackages() ...
[09:28:25.713] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.713] Resolving globals: FALSE
[09:28:25.713] Tweak future expression to call with '...' arguments ...
[09:28:25.713] {
[09:28:25.713]     do.call(function(...) {
[09:28:25.713]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.713]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.713]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.713]             on.exit(options(oopts), add = TRUE)
[09:28:25.713]         }
[09:28:25.713]         {
[09:28:25.713]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.713]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.713]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.713]             })
[09:28:25.713]         }
[09:28:25.713]     }, args = future.call.arguments)
[09:28:25.713] }
[09:28:25.713] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.714] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.714] - packages: [1] ‘stats’
[09:28:25.714] getGlobalsAndPackages() ... DONE
[09:28:25.714] run() for ‘Future’ ...
[09:28:25.714] - state: ‘created’
[09:28:25.714] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:25.714] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:25.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:25.715]   - Field: ‘label’
[09:28:25.715]   - Field: ‘local’
[09:28:25.715]   - Field: ‘owner’
[09:28:25.715]   - Field: ‘envir’
[09:28:25.715]   - Field: ‘packages’
[09:28:25.715]   - Field: ‘gc’
[09:28:25.715]   - Field: ‘conditions’
[09:28:25.715]   - Field: ‘expr’
[09:28:25.715]   - Field: ‘uuid’
[09:28:25.715]   - Field: ‘seed’
[09:28:25.715]   - Field: ‘version’
[09:28:25.716]   - Field: ‘result’
[09:28:25.716]   - Field: ‘asynchronous’
[09:28:25.716]   - Field: ‘calls’
[09:28:25.716]   - Field: ‘globals’
[09:28:25.716]   - Field: ‘stdout’
[09:28:25.716]   - Field: ‘earlySignal’
[09:28:25.716]   - Field: ‘lazy’
[09:28:25.716]   - Field: ‘state’
[09:28:25.716] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:25.716] - Launch lazy future ...
[09:28:25.716] Packages needed by the future expression (n = 1): ‘stats’
[09:28:25.717] Packages needed by future strategies (n = 0): <none>
[09:28:25.717] {
[09:28:25.717]     {
[09:28:25.717]         {
[09:28:25.717]             ...future.startTime <- base::Sys.time()
[09:28:25.717]             {
[09:28:25.717]                 {
[09:28:25.717]                   {
[09:28:25.717]                     {
[09:28:25.717]                       base::local({
[09:28:25.717]                         has_future <- base::requireNamespace("future", 
[09:28:25.717]                           quietly = TRUE)
[09:28:25.717]                         if (has_future) {
[09:28:25.717]                           ns <- base::getNamespace("future")
[09:28:25.717]                           version <- ns[[".package"]][["version"]]
[09:28:25.717]                           if (is.null(version)) 
[09:28:25.717]                             version <- utils::packageVersion("future")
[09:28:25.717]                         }
[09:28:25.717]                         else {
[09:28:25.717]                           version <- NULL
[09:28:25.717]                         }
[09:28:25.717]                         if (!has_future || version < "1.8.0") {
[09:28:25.717]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.717]                             "", base::R.version$version.string), 
[09:28:25.717]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:25.717]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:25.717]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.717]                               "release", "version")], collapse = " "), 
[09:28:25.717]                             hostname = base::Sys.info()[["nodename"]])
[09:28:25.717]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.717]                             info)
[09:28:25.717]                           info <- base::paste(info, collapse = "; ")
[09:28:25.717]                           if (!has_future) {
[09:28:25.717]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.717]                               info)
[09:28:25.717]                           }
[09:28:25.717]                           else {
[09:28:25.717]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.717]                               info, version)
[09:28:25.717]                           }
[09:28:25.717]                           base::stop(msg)
[09:28:25.717]                         }
[09:28:25.717]                       })
[09:28:25.717]                     }
[09:28:25.717]                     base::local({
[09:28:25.717]                       for (pkg in "stats") {
[09:28:25.717]                         base::loadNamespace(pkg)
[09:28:25.717]                         base::library(pkg, character.only = TRUE)
[09:28:25.717]                       }
[09:28:25.717]                     })
[09:28:25.717]                   }
[09:28:25.717]                   ...future.strategy.old <- future::plan("list")
[09:28:25.717]                   options(future.plan = NULL)
[09:28:25.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.717]                 }
[09:28:25.717]                 ...future.workdir <- getwd()
[09:28:25.717]             }
[09:28:25.717]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.717]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.717]         }
[09:28:25.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.717]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:25.717]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.717]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.717]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.717]             base::names(...future.oldOptions))
[09:28:25.717]     }
[09:28:25.717]     if (FALSE) {
[09:28:25.717]     }
[09:28:25.717]     else {
[09:28:25.717]         if (TRUE) {
[09:28:25.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.717]                 open = "w")
[09:28:25.717]         }
[09:28:25.717]         else {
[09:28:25.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.717]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.717]         }
[09:28:25.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.717]             base::sink(type = "output", split = FALSE)
[09:28:25.717]             base::close(...future.stdout)
[09:28:25.717]         }, add = TRUE)
[09:28:25.717]     }
[09:28:25.717]     ...future.frame <- base::sys.nframe()
[09:28:25.717]     ...future.conditions <- base::list()
[09:28:25.717]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.717]     if (FALSE) {
[09:28:25.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.717]     }
[09:28:25.717]     ...future.result <- base::tryCatch({
[09:28:25.717]         base::withCallingHandlers({
[09:28:25.717]             ...future.value <- base::withVisible(base::local({
[09:28:25.717]                 do.call(function(...) {
[09:28:25.717]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.717]                   if (!identical(...future.globals.maxSize.org, 
[09:28:25.717]                     ...future.globals.maxSize)) {
[09:28:25.717]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.717]                     on.exit(options(oopts), add = TRUE)
[09:28:25.717]                   }
[09:28:25.717]                   {
[09:28:25.717]                     lapply(seq_along(...future.elements_ii), 
[09:28:25.717]                       FUN = function(jj) {
[09:28:25.717]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.717]                         ...future.FUN(...future.X_jj, ...)
[09:28:25.717]                       })
[09:28:25.717]                   }
[09:28:25.717]                 }, args = future.call.arguments)
[09:28:25.717]             }))
[09:28:25.717]             future::FutureResult(value = ...future.value$value, 
[09:28:25.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.717]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.717]                     ...future.globalenv.names))
[09:28:25.717]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.717]         }, condition = base::local({
[09:28:25.717]             c <- base::c
[09:28:25.717]             inherits <- base::inherits
[09:28:25.717]             invokeRestart <- base::invokeRestart
[09:28:25.717]             length <- base::length
[09:28:25.717]             list <- base::list
[09:28:25.717]             seq.int <- base::seq.int
[09:28:25.717]             signalCondition <- base::signalCondition
[09:28:25.717]             sys.calls <- base::sys.calls
[09:28:25.717]             `[[` <- base::`[[`
[09:28:25.717]             `+` <- base::`+`
[09:28:25.717]             `<<-` <- base::`<<-`
[09:28:25.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.717]                   3L)]
[09:28:25.717]             }
[09:28:25.717]             function(cond) {
[09:28:25.717]                 is_error <- inherits(cond, "error")
[09:28:25.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.717]                   NULL)
[09:28:25.717]                 if (is_error) {
[09:28:25.717]                   sessionInformation <- function() {
[09:28:25.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.717]                       search = base::search(), system = base::Sys.info())
[09:28:25.717]                   }
[09:28:25.717]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.717]                     cond$call), session = sessionInformation(), 
[09:28:25.717]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.717]                   signalCondition(cond)
[09:28:25.717]                 }
[09:28:25.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.717]                 "immediateCondition"))) {
[09:28:25.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.717]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.717]                   if (TRUE && !signal) {
[09:28:25.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.717]                     {
[09:28:25.717]                       inherits <- base::inherits
[09:28:25.717]                       invokeRestart <- base::invokeRestart
[09:28:25.717]                       is.null <- base::is.null
[09:28:25.717]                       muffled <- FALSE
[09:28:25.717]                       if (inherits(cond, "message")) {
[09:28:25.717]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.717]                         if (muffled) 
[09:28:25.717]                           invokeRestart("muffleMessage")
[09:28:25.717]                       }
[09:28:25.717]                       else if (inherits(cond, "warning")) {
[09:28:25.717]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.717]                         if (muffled) 
[09:28:25.717]                           invokeRestart("muffleWarning")
[09:28:25.717]                       }
[09:28:25.717]                       else if (inherits(cond, "condition")) {
[09:28:25.717]                         if (!is.null(pattern)) {
[09:28:25.717]                           computeRestarts <- base::computeRestarts
[09:28:25.717]                           grepl <- base::grepl
[09:28:25.717]                           restarts <- computeRestarts(cond)
[09:28:25.717]                           for (restart in restarts) {
[09:28:25.717]                             name <- restart$name
[09:28:25.717]                             if (is.null(name)) 
[09:28:25.717]                               next
[09:28:25.717]                             if (!grepl(pattern, name)) 
[09:28:25.717]                               next
[09:28:25.717]                             invokeRestart(restart)
[09:28:25.717]                             muffled <- TRUE
[09:28:25.717]                             break
[09:28:25.717]                           }
[09:28:25.717]                         }
[09:28:25.717]                       }
[09:28:25.717]                       invisible(muffled)
[09:28:25.717]                     }
[09:28:25.717]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.717]                   }
[09:28:25.717]                 }
[09:28:25.717]                 else {
[09:28:25.717]                   if (TRUE) {
[09:28:25.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.717]                     {
[09:28:25.717]                       inherits <- base::inherits
[09:28:25.717]                       invokeRestart <- base::invokeRestart
[09:28:25.717]                       is.null <- base::is.null
[09:28:25.717]                       muffled <- FALSE
[09:28:25.717]                       if (inherits(cond, "message")) {
[09:28:25.717]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.717]                         if (muffled) 
[09:28:25.717]                           invokeRestart("muffleMessage")
[09:28:25.717]                       }
[09:28:25.717]                       else if (inherits(cond, "warning")) {
[09:28:25.717]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.717]                         if (muffled) 
[09:28:25.717]                           invokeRestart("muffleWarning")
[09:28:25.717]                       }
[09:28:25.717]                       else if (inherits(cond, "condition")) {
[09:28:25.717]                         if (!is.null(pattern)) {
[09:28:25.717]                           computeRestarts <- base::computeRestarts
[09:28:25.717]                           grepl <- base::grepl
[09:28:25.717]                           restarts <- computeRestarts(cond)
[09:28:25.717]                           for (restart in restarts) {
[09:28:25.717]                             name <- restart$name
[09:28:25.717]                             if (is.null(name)) 
[09:28:25.717]                               next
[09:28:25.717]                             if (!grepl(pattern, name)) 
[09:28:25.717]                               next
[09:28:25.717]                             invokeRestart(restart)
[09:28:25.717]                             muffled <- TRUE
[09:28:25.717]                             break
[09:28:25.717]                           }
[09:28:25.717]                         }
[09:28:25.717]                       }
[09:28:25.717]                       invisible(muffled)
[09:28:25.717]                     }
[09:28:25.717]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.717]                   }
[09:28:25.717]                 }
[09:28:25.717]             }
[09:28:25.717]         }))
[09:28:25.717]     }, error = function(ex) {
[09:28:25.717]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.717]                 ...future.rng), started = ...future.startTime, 
[09:28:25.717]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.717]             version = "1.8"), class = "FutureResult")
[09:28:25.717]     }, finally = {
[09:28:25.717]         if (!identical(...future.workdir, getwd())) 
[09:28:25.717]             setwd(...future.workdir)
[09:28:25.717]         {
[09:28:25.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.717]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.717]             }
[09:28:25.717]             base::options(...future.oldOptions)
[09:28:25.717]             if (.Platform$OS.type == "windows") {
[09:28:25.717]                 old_names <- names(...future.oldEnvVars)
[09:28:25.717]                 envs <- base::Sys.getenv()
[09:28:25.717]                 names <- names(envs)
[09:28:25.717]                 common <- intersect(names, old_names)
[09:28:25.717]                 added <- setdiff(names, old_names)
[09:28:25.717]                 removed <- setdiff(old_names, names)
[09:28:25.717]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.717]                   envs[common]]
[09:28:25.717]                 NAMES <- toupper(changed)
[09:28:25.717]                 args <- list()
[09:28:25.717]                 for (kk in seq_along(NAMES)) {
[09:28:25.717]                   name <- changed[[kk]]
[09:28:25.717]                   NAME <- NAMES[[kk]]
[09:28:25.717]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.717]                     next
[09:28:25.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.717]                 }
[09:28:25.717]                 NAMES <- toupper(added)
[09:28:25.717]                 for (kk in seq_along(NAMES)) {
[09:28:25.717]                   name <- added[[kk]]
[09:28:25.717]                   NAME <- NAMES[[kk]]
[09:28:25.717]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.717]                     next
[09:28:25.717]                   args[[name]] <- ""
[09:28:25.717]                 }
[09:28:25.717]                 NAMES <- toupper(removed)
[09:28:25.717]                 for (kk in seq_along(NAMES)) {
[09:28:25.717]                   name <- removed[[kk]]
[09:28:25.717]                   NAME <- NAMES[[kk]]
[09:28:25.717]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.717]                     next
[09:28:25.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.717]                 }
[09:28:25.717]                 if (length(args) > 0) 
[09:28:25.717]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.717]             }
[09:28:25.717]             else {
[09:28:25.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.717]             }
[09:28:25.717]             {
[09:28:25.717]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.717]                   0L) {
[09:28:25.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.717]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.717]                   base::options(opts)
[09:28:25.717]                 }
[09:28:25.717]                 {
[09:28:25.717]                   {
[09:28:25.717]                     NULL
[09:28:25.717]                     RNGkind("Mersenne-Twister")
[09:28:25.717]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:25.717]                       inherits = FALSE)
[09:28:25.717]                   }
[09:28:25.717]                   options(future.plan = NULL)
[09:28:25.717]                   if (is.na(NA_character_)) 
[09:28:25.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.717]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.717]                     .init = FALSE)
[09:28:25.717]                 }
[09:28:25.717]             }
[09:28:25.717]         }
[09:28:25.717]     })
[09:28:25.717]     if (TRUE) {
[09:28:25.717]         base::sink(type = "output", split = FALSE)
[09:28:25.717]         if (TRUE) {
[09:28:25.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.717]         }
[09:28:25.717]         else {
[09:28:25.717]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.717]         }
[09:28:25.717]         base::close(...future.stdout)
[09:28:25.717]         ...future.stdout <- NULL
[09:28:25.717]     }
[09:28:25.717]     ...future.result$conditions <- ...future.conditions
[09:28:25.717]     ...future.result$finished <- base::Sys.time()
[09:28:25.717]     ...future.result
[09:28:25.717] }
[09:28:25.719] assign_globals() ...
[09:28:25.719] List of 5
[09:28:25.719]  $ ...future.FUN            :function (x, ...)  
[09:28:25.719]  $ future.call.arguments    : list()
[09:28:25.719]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.719]  $ ...future.elements_ii    :List of 3
[09:28:25.719]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[09:28:25.719]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[09:28:25.719]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:28:25.719]  $ ...future.seeds_ii       : NULL
[09:28:25.719]  $ ...future.globals.maxSize: NULL
[09:28:25.719]  - attr(*, "where")=List of 5
[09:28:25.719]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:25.719]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:25.719]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:25.719]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:25.719]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:25.719]  - attr(*, "resolved")= logi FALSE
[09:28:25.719]  - attr(*, "total_size")= num 1248
[09:28:25.719]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.719]  - attr(*, "already-done")= logi TRUE
[09:28:25.724] - copied ‘...future.FUN’ to environment
[09:28:25.724] - copied ‘future.call.arguments’ to environment
[09:28:25.724] - copied ‘...future.elements_ii’ to environment
[09:28:25.724] - copied ‘...future.seeds_ii’ to environment
[09:28:25.724] - copied ‘...future.globals.maxSize’ to environment
[09:28:25.724] assign_globals() ... done
[09:28:25.724] plan(): Setting new future strategy stack:
[09:28:25.724] List of future strategies:
[09:28:25.724] 1. sequential:
[09:28:25.724]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.724]    - tweaked: FALSE
[09:28:25.724]    - call: NULL
[09:28:25.725] plan(): nbrOfWorkers() = 1
[09:28:25.726] plan(): Setting new future strategy stack:
[09:28:25.726] List of future strategies:
[09:28:25.726] 1. sequential:
[09:28:25.726]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.726]    - tweaked: FALSE
[09:28:25.726]    - call: plan(strategy)
[09:28:25.726] plan(): nbrOfWorkers() = 1
[09:28:25.728] SequentialFuture started (and completed)
[09:28:25.728] - Launch lazy future ... done
[09:28:25.728] run() for ‘SequentialFuture’ ... done
[09:28:25.728] Created future:
[09:28:25.728] SequentialFuture:
[09:28:25.728] Label: ‘future_eapply-1’
[09:28:25.728] Expression:
[09:28:25.728] {
[09:28:25.728]     do.call(function(...) {
[09:28:25.728]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.728]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.728]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.728]             on.exit(options(oopts), add = TRUE)
[09:28:25.728]         }
[09:28:25.728]         {
[09:28:25.728]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.728]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.728]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.728]             })
[09:28:25.728]         }
[09:28:25.728]     }, args = future.call.arguments)
[09:28:25.728] }
[09:28:25.728] Lazy evaluation: FALSE
[09:28:25.728] Asynchronous evaluation: FALSE
[09:28:25.728] Local evaluation: TRUE
[09:28:25.728] Environment: R_GlobalEnv
[09:28:25.728] Capture standard output: TRUE
[09:28:25.728] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.728] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.728] Packages: 1 packages (‘stats’)
[09:28:25.728] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.728] Resolved: TRUE
[09:28:25.728] Value: 1.71 KiB of class ‘list’
[09:28:25.728] Early signaling: FALSE
[09:28:25.728] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:25.728] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:25.729] Chunk #1 of 1 ... DONE
[09:28:25.729] Launching 1 futures (chunks) ... DONE
[09:28:25.729] Resolving 1 futures (chunks) ...
[09:28:25.729] resolve() on list ...
[09:28:25.729]  recursive: 0
[09:28:25.729]  length: 1
[09:28:25.729] 
[09:28:25.730] resolved() for ‘SequentialFuture’ ...
[09:28:25.730] - state: ‘finished’
[09:28:25.730] - run: TRUE
[09:28:25.730] - result: ‘FutureResult’
[09:28:25.730] resolved() for ‘SequentialFuture’ ... done
[09:28:25.730] Future #1
[09:28:25.730] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:25.730] - nx: 1
[09:28:25.730] - relay: TRUE
[09:28:25.730] - stdout: TRUE
[09:28:25.730] - signal: TRUE
[09:28:25.731] - resignal: FALSE
[09:28:25.731] - force: TRUE
[09:28:25.731] - relayed: [n=1] FALSE
[09:28:25.731] - queued futures: [n=1] FALSE
[09:28:25.731]  - until=1
[09:28:25.731]  - relaying element #1
[09:28:25.731] - relayed: [n=1] TRUE
[09:28:25.731] - queued futures: [n=1] TRUE
[09:28:25.731] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:25.731]  length: 0 (resolved future 1)
[09:28:25.732] Relaying remaining futures
[09:28:25.732] signalConditionsASAP(NULL, pos=0) ...
[09:28:25.732] - nx: 1
[09:28:25.732] - relay: TRUE
[09:28:25.732] - stdout: TRUE
[09:28:25.732] - signal: TRUE
[09:28:25.732] - resignal: FALSE
[09:28:25.732] - force: TRUE
[09:28:25.732] - relayed: [n=1] TRUE
[09:28:25.732] - queued futures: [n=1] TRUE
 - flush all
[09:28:25.732] - relayed: [n=1] TRUE
[09:28:25.732] - queued futures: [n=1] TRUE
[09:28:25.733] signalConditionsASAP(NULL, pos=0) ... done
[09:28:25.733] resolve() on list ... DONE
[09:28:25.733]  - Number of value chunks collected: 1
[09:28:25.733] Resolving 1 futures (chunks) ... DONE
[09:28:25.733] Reducing values from 1 chunks ...
[09:28:25.733]  - Number of values collected after concatenation: 3
[09:28:25.733]  - Number of values expected: 3
[09:28:25.733] Reducing values from 1 chunks ... DONE
[09:28:25.733] future_lapply() ... DONE
[09:28:25.733] future_lapply() ...
[09:28:25.734] Number of chunks: 1
[09:28:25.734] getGlobalsAndPackagesXApply() ...
[09:28:25.734]  - future.globals: TRUE
[09:28:25.734] getGlobalsAndPackages() ...
[09:28:25.734] Searching for globals...
[09:28:25.735] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:25.735] Searching for globals ... DONE
[09:28:25.735] Resolving globals: FALSE
[09:28:25.736] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:25.736] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:25.736] - globals: [1] ‘FUN’
[09:28:25.736] - packages: [1] ‘stats’
[09:28:25.736] getGlobalsAndPackages() ... DONE
[09:28:25.736]  - globals found/used: [n=1] ‘FUN’
[09:28:25.737]  - needed namespaces: [n=1] ‘stats’
[09:28:25.737] Finding globals ... DONE
[09:28:25.737]  - use_args: TRUE
[09:28:25.737]  - Getting '...' globals ...
[09:28:25.737] resolve() on list ...
[09:28:25.737]  recursive: 0
[09:28:25.737]  length: 1
[09:28:25.737]  elements: ‘...’
[09:28:25.737]  length: 0 (resolved future 1)
[09:28:25.738] resolve() on list ... DONE
[09:28:25.738]    - '...' content: [n=0] 
[09:28:25.738] List of 1
[09:28:25.738]  $ ...: list()
[09:28:25.738]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.738]  - attr(*, "where")=List of 1
[09:28:25.738]   ..$ ...:<environment: 0x556665372850> 
[09:28:25.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.738]  - attr(*, "resolved")= logi TRUE
[09:28:25.738]  - attr(*, "total_size")= num NA
[09:28:25.740]  - Getting '...' globals ... DONE
[09:28:25.740] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:25.740] List of 2
[09:28:25.740]  $ ...future.FUN:function (x, ...)  
[09:28:25.740]  $ ...          : list()
[09:28:25.740]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.740]  - attr(*, "where")=List of 2
[09:28:25.740]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:25.740]   ..$ ...          :<environment: 0x556665372850> 
[09:28:25.740]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.740]  - attr(*, "resolved")= logi FALSE
[09:28:25.740]  - attr(*, "total_size")= num 1248
[09:28:25.743] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:25.743] getGlobalsAndPackagesXApply() ... DONE
[09:28:25.743] Number of futures (= number of chunks): 1
[09:28:25.743] Launching 1 futures (chunks) ...
[09:28:25.743] Chunk #1 of 1 ...
[09:28:25.743]  - Finding globals in 'X' for chunk #1 ...
[09:28:25.743] getGlobalsAndPackages() ...
[09:28:25.743] Searching for globals...
[09:28:25.744] 
[09:28:25.744] Searching for globals ... DONE
[09:28:25.744] - globals: [0] <none>
[09:28:25.744] getGlobalsAndPackages() ... DONE
[09:28:25.744]    + additional globals found: [n=0] 
[09:28:25.744]    + additional namespaces needed: [n=0] 
[09:28:25.744]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:25.744]  - seeds: <none>
[09:28:25.744]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.745] getGlobalsAndPackages() ...
[09:28:25.745] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.745] Resolving globals: FALSE
[09:28:25.745] Tweak future expression to call with '...' arguments ...
[09:28:25.745] {
[09:28:25.745]     do.call(function(...) {
[09:28:25.745]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.745]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.745]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.745]             on.exit(options(oopts), add = TRUE)
[09:28:25.745]         }
[09:28:25.745]         {
[09:28:25.745]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.745]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.745]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.745]             })
[09:28:25.745]         }
[09:28:25.745]     }, args = future.call.arguments)
[09:28:25.745] }
[09:28:25.745] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.745] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.746] - packages: [1] ‘stats’
[09:28:25.746] getGlobalsAndPackages() ... DONE
[09:28:25.746] run() for ‘Future’ ...
[09:28:25.746] - state: ‘created’
[09:28:25.746] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:25.746] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:25.746] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:25.747]   - Field: ‘label’
[09:28:25.747]   - Field: ‘local’
[09:28:25.747]   - Field: ‘owner’
[09:28:25.747]   - Field: ‘envir’
[09:28:25.747]   - Field: ‘packages’
[09:28:25.747]   - Field: ‘gc’
[09:28:25.747]   - Field: ‘conditions’
[09:28:25.747]   - Field: ‘expr’
[09:28:25.747]   - Field: ‘uuid’
[09:28:25.747]   - Field: ‘seed’
[09:28:25.747]   - Field: ‘version’
[09:28:25.748]   - Field: ‘result’
[09:28:25.748]   - Field: ‘asynchronous’
[09:28:25.748]   - Field: ‘calls’
[09:28:25.748]   - Field: ‘globals’
[09:28:25.748]   - Field: ‘stdout’
[09:28:25.748]   - Field: ‘earlySignal’
[09:28:25.748]   - Field: ‘lazy’
[09:28:25.748]   - Field: ‘state’
[09:28:25.748] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:25.748] - Launch lazy future ...
[09:28:25.748] Packages needed by the future expression (n = 1): ‘stats’
[09:28:25.749] Packages needed by future strategies (n = 0): <none>
[09:28:25.749] {
[09:28:25.749]     {
[09:28:25.749]         {
[09:28:25.749]             ...future.startTime <- base::Sys.time()
[09:28:25.749]             {
[09:28:25.749]                 {
[09:28:25.749]                   {
[09:28:25.749]                     {
[09:28:25.749]                       base::local({
[09:28:25.749]                         has_future <- base::requireNamespace("future", 
[09:28:25.749]                           quietly = TRUE)
[09:28:25.749]                         if (has_future) {
[09:28:25.749]                           ns <- base::getNamespace("future")
[09:28:25.749]                           version <- ns[[".package"]][["version"]]
[09:28:25.749]                           if (is.null(version)) 
[09:28:25.749]                             version <- utils::packageVersion("future")
[09:28:25.749]                         }
[09:28:25.749]                         else {
[09:28:25.749]                           version <- NULL
[09:28:25.749]                         }
[09:28:25.749]                         if (!has_future || version < "1.8.0") {
[09:28:25.749]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.749]                             "", base::R.version$version.string), 
[09:28:25.749]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:25.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:25.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.749]                               "release", "version")], collapse = " "), 
[09:28:25.749]                             hostname = base::Sys.info()[["nodename"]])
[09:28:25.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.749]                             info)
[09:28:25.749]                           info <- base::paste(info, collapse = "; ")
[09:28:25.749]                           if (!has_future) {
[09:28:25.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.749]                               info)
[09:28:25.749]                           }
[09:28:25.749]                           else {
[09:28:25.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.749]                               info, version)
[09:28:25.749]                           }
[09:28:25.749]                           base::stop(msg)
[09:28:25.749]                         }
[09:28:25.749]                       })
[09:28:25.749]                     }
[09:28:25.749]                     base::local({
[09:28:25.749]                       for (pkg in "stats") {
[09:28:25.749]                         base::loadNamespace(pkg)
[09:28:25.749]                         base::library(pkg, character.only = TRUE)
[09:28:25.749]                       }
[09:28:25.749]                     })
[09:28:25.749]                   }
[09:28:25.749]                   ...future.strategy.old <- future::plan("list")
[09:28:25.749]                   options(future.plan = NULL)
[09:28:25.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.749]                 }
[09:28:25.749]                 ...future.workdir <- getwd()
[09:28:25.749]             }
[09:28:25.749]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.749]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.749]         }
[09:28:25.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:25.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.749]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.749]             base::names(...future.oldOptions))
[09:28:25.749]     }
[09:28:25.749]     if (FALSE) {
[09:28:25.749]     }
[09:28:25.749]     else {
[09:28:25.749]         if (TRUE) {
[09:28:25.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.749]                 open = "w")
[09:28:25.749]         }
[09:28:25.749]         else {
[09:28:25.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.749]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.749]         }
[09:28:25.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.749]             base::sink(type = "output", split = FALSE)
[09:28:25.749]             base::close(...future.stdout)
[09:28:25.749]         }, add = TRUE)
[09:28:25.749]     }
[09:28:25.749]     ...future.frame <- base::sys.nframe()
[09:28:25.749]     ...future.conditions <- base::list()
[09:28:25.749]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.749]     if (FALSE) {
[09:28:25.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.749]     }
[09:28:25.749]     ...future.result <- base::tryCatch({
[09:28:25.749]         base::withCallingHandlers({
[09:28:25.749]             ...future.value <- base::withVisible(base::local({
[09:28:25.749]                 do.call(function(...) {
[09:28:25.749]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.749]                   if (!identical(...future.globals.maxSize.org, 
[09:28:25.749]                     ...future.globals.maxSize)) {
[09:28:25.749]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.749]                     on.exit(options(oopts), add = TRUE)
[09:28:25.749]                   }
[09:28:25.749]                   {
[09:28:25.749]                     lapply(seq_along(...future.elements_ii), 
[09:28:25.749]                       FUN = function(jj) {
[09:28:25.749]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.749]                         ...future.FUN(...future.X_jj, ...)
[09:28:25.749]                       })
[09:28:25.749]                   }
[09:28:25.749]                 }, args = future.call.arguments)
[09:28:25.749]             }))
[09:28:25.749]             future::FutureResult(value = ...future.value$value, 
[09:28:25.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.749]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.749]                     ...future.globalenv.names))
[09:28:25.749]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.749]         }, condition = base::local({
[09:28:25.749]             c <- base::c
[09:28:25.749]             inherits <- base::inherits
[09:28:25.749]             invokeRestart <- base::invokeRestart
[09:28:25.749]             length <- base::length
[09:28:25.749]             list <- base::list
[09:28:25.749]             seq.int <- base::seq.int
[09:28:25.749]             signalCondition <- base::signalCondition
[09:28:25.749]             sys.calls <- base::sys.calls
[09:28:25.749]             `[[` <- base::`[[`
[09:28:25.749]             `+` <- base::`+`
[09:28:25.749]             `<<-` <- base::`<<-`
[09:28:25.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.749]                   3L)]
[09:28:25.749]             }
[09:28:25.749]             function(cond) {
[09:28:25.749]                 is_error <- inherits(cond, "error")
[09:28:25.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.749]                   NULL)
[09:28:25.749]                 if (is_error) {
[09:28:25.749]                   sessionInformation <- function() {
[09:28:25.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.749]                       search = base::search(), system = base::Sys.info())
[09:28:25.749]                   }
[09:28:25.749]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.749]                     cond$call), session = sessionInformation(), 
[09:28:25.749]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.749]                   signalCondition(cond)
[09:28:25.749]                 }
[09:28:25.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.749]                 "immediateCondition"))) {
[09:28:25.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.749]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.749]                   if (TRUE && !signal) {
[09:28:25.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.749]                     {
[09:28:25.749]                       inherits <- base::inherits
[09:28:25.749]                       invokeRestart <- base::invokeRestart
[09:28:25.749]                       is.null <- base::is.null
[09:28:25.749]                       muffled <- FALSE
[09:28:25.749]                       if (inherits(cond, "message")) {
[09:28:25.749]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.749]                         if (muffled) 
[09:28:25.749]                           invokeRestart("muffleMessage")
[09:28:25.749]                       }
[09:28:25.749]                       else if (inherits(cond, "warning")) {
[09:28:25.749]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.749]                         if (muffled) 
[09:28:25.749]                           invokeRestart("muffleWarning")
[09:28:25.749]                       }
[09:28:25.749]                       else if (inherits(cond, "condition")) {
[09:28:25.749]                         if (!is.null(pattern)) {
[09:28:25.749]                           computeRestarts <- base::computeRestarts
[09:28:25.749]                           grepl <- base::grepl
[09:28:25.749]                           restarts <- computeRestarts(cond)
[09:28:25.749]                           for (restart in restarts) {
[09:28:25.749]                             name <- restart$name
[09:28:25.749]                             if (is.null(name)) 
[09:28:25.749]                               next
[09:28:25.749]                             if (!grepl(pattern, name)) 
[09:28:25.749]                               next
[09:28:25.749]                             invokeRestart(restart)
[09:28:25.749]                             muffled <- TRUE
[09:28:25.749]                             break
[09:28:25.749]                           }
[09:28:25.749]                         }
[09:28:25.749]                       }
[09:28:25.749]                       invisible(muffled)
[09:28:25.749]                     }
[09:28:25.749]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.749]                   }
[09:28:25.749]                 }
[09:28:25.749]                 else {
[09:28:25.749]                   if (TRUE) {
[09:28:25.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.749]                     {
[09:28:25.749]                       inherits <- base::inherits
[09:28:25.749]                       invokeRestart <- base::invokeRestart
[09:28:25.749]                       is.null <- base::is.null
[09:28:25.749]                       muffled <- FALSE
[09:28:25.749]                       if (inherits(cond, "message")) {
[09:28:25.749]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.749]                         if (muffled) 
[09:28:25.749]                           invokeRestart("muffleMessage")
[09:28:25.749]                       }
[09:28:25.749]                       else if (inherits(cond, "warning")) {
[09:28:25.749]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.749]                         if (muffled) 
[09:28:25.749]                           invokeRestart("muffleWarning")
[09:28:25.749]                       }
[09:28:25.749]                       else if (inherits(cond, "condition")) {
[09:28:25.749]                         if (!is.null(pattern)) {
[09:28:25.749]                           computeRestarts <- base::computeRestarts
[09:28:25.749]                           grepl <- base::grepl
[09:28:25.749]                           restarts <- computeRestarts(cond)
[09:28:25.749]                           for (restart in restarts) {
[09:28:25.749]                             name <- restart$name
[09:28:25.749]                             if (is.null(name)) 
[09:28:25.749]                               next
[09:28:25.749]                             if (!grepl(pattern, name)) 
[09:28:25.749]                               next
[09:28:25.749]                             invokeRestart(restart)
[09:28:25.749]                             muffled <- TRUE
[09:28:25.749]                             break
[09:28:25.749]                           }
[09:28:25.749]                         }
[09:28:25.749]                       }
[09:28:25.749]                       invisible(muffled)
[09:28:25.749]                     }
[09:28:25.749]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.749]                   }
[09:28:25.749]                 }
[09:28:25.749]             }
[09:28:25.749]         }))
[09:28:25.749]     }, error = function(ex) {
[09:28:25.749]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.749]                 ...future.rng), started = ...future.startTime, 
[09:28:25.749]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.749]             version = "1.8"), class = "FutureResult")
[09:28:25.749]     }, finally = {
[09:28:25.749]         if (!identical(...future.workdir, getwd())) 
[09:28:25.749]             setwd(...future.workdir)
[09:28:25.749]         {
[09:28:25.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.749]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.749]             }
[09:28:25.749]             base::options(...future.oldOptions)
[09:28:25.749]             if (.Platform$OS.type == "windows") {
[09:28:25.749]                 old_names <- names(...future.oldEnvVars)
[09:28:25.749]                 envs <- base::Sys.getenv()
[09:28:25.749]                 names <- names(envs)
[09:28:25.749]                 common <- intersect(names, old_names)
[09:28:25.749]                 added <- setdiff(names, old_names)
[09:28:25.749]                 removed <- setdiff(old_names, names)
[09:28:25.749]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.749]                   envs[common]]
[09:28:25.749]                 NAMES <- toupper(changed)
[09:28:25.749]                 args <- list()
[09:28:25.749]                 for (kk in seq_along(NAMES)) {
[09:28:25.749]                   name <- changed[[kk]]
[09:28:25.749]                   NAME <- NAMES[[kk]]
[09:28:25.749]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.749]                     next
[09:28:25.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.749]                 }
[09:28:25.749]                 NAMES <- toupper(added)
[09:28:25.749]                 for (kk in seq_along(NAMES)) {
[09:28:25.749]                   name <- added[[kk]]
[09:28:25.749]                   NAME <- NAMES[[kk]]
[09:28:25.749]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.749]                     next
[09:28:25.749]                   args[[name]] <- ""
[09:28:25.749]                 }
[09:28:25.749]                 NAMES <- toupper(removed)
[09:28:25.749]                 for (kk in seq_along(NAMES)) {
[09:28:25.749]                   name <- removed[[kk]]
[09:28:25.749]                   NAME <- NAMES[[kk]]
[09:28:25.749]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.749]                     next
[09:28:25.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.749]                 }
[09:28:25.749]                 if (length(args) > 0) 
[09:28:25.749]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.749]             }
[09:28:25.749]             else {
[09:28:25.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.749]             }
[09:28:25.749]             {
[09:28:25.749]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.749]                   0L) {
[09:28:25.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.749]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.749]                   base::options(opts)
[09:28:25.749]                 }
[09:28:25.749]                 {
[09:28:25.749]                   {
[09:28:25.749]                     NULL
[09:28:25.749]                     RNGkind("Mersenne-Twister")
[09:28:25.749]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:25.749]                       inherits = FALSE)
[09:28:25.749]                   }
[09:28:25.749]                   options(future.plan = NULL)
[09:28:25.749]                   if (is.na(NA_character_)) 
[09:28:25.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.749]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.749]                     .init = FALSE)
[09:28:25.749]                 }
[09:28:25.749]             }
[09:28:25.749]         }
[09:28:25.749]     })
[09:28:25.749]     if (TRUE) {
[09:28:25.749]         base::sink(type = "output", split = FALSE)
[09:28:25.749]         if (TRUE) {
[09:28:25.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.749]         }
[09:28:25.749]         else {
[09:28:25.749]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.749]         }
[09:28:25.749]         base::close(...future.stdout)
[09:28:25.749]         ...future.stdout <- NULL
[09:28:25.749]     }
[09:28:25.749]     ...future.result$conditions <- ...future.conditions
[09:28:25.749]     ...future.result$finished <- base::Sys.time()
[09:28:25.749]     ...future.result
[09:28:25.749] }
[09:28:25.752] assign_globals() ...
[09:28:25.752] List of 5
[09:28:25.752]  $ ...future.FUN            :function (x, ...)  
[09:28:25.752]  $ future.call.arguments    : list()
[09:28:25.752]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.752]  $ ...future.elements_ii    :List of 3
[09:28:25.752]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[09:28:25.752]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[09:28:25.752]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:28:25.752]  $ ...future.seeds_ii       : NULL
[09:28:25.752]  $ ...future.globals.maxSize: NULL
[09:28:25.752]  - attr(*, "where")=List of 5
[09:28:25.752]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:25.752]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:25.752]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:25.752]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:25.752]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:25.752]  - attr(*, "resolved")= logi FALSE
[09:28:25.752]  - attr(*, "total_size")= num 1248
[09:28:25.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.752]  - attr(*, "already-done")= logi TRUE
[09:28:25.757] - copied ‘...future.FUN’ to environment
[09:28:25.757] - copied ‘future.call.arguments’ to environment
[09:28:25.757] - copied ‘...future.elements_ii’ to environment
[09:28:25.757] - copied ‘...future.seeds_ii’ to environment
[09:28:25.757] - copied ‘...future.globals.maxSize’ to environment
[09:28:25.757] assign_globals() ... done
[09:28:25.758] plan(): Setting new future strategy stack:
[09:28:25.758] List of future strategies:
[09:28:25.758] 1. sequential:
[09:28:25.758]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.758]    - tweaked: FALSE
[09:28:25.758]    - call: NULL
[09:28:25.758] plan(): nbrOfWorkers() = 1
[09:28:25.759] plan(): Setting new future strategy stack:
[09:28:25.759] List of future strategies:
[09:28:25.759] 1. sequential:
[09:28:25.759]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.759]    - tweaked: FALSE
[09:28:25.759]    - call: plan(strategy)
[09:28:25.760] plan(): nbrOfWorkers() = 1
[09:28:25.760] SequentialFuture started (and completed)
[09:28:25.760] - Launch lazy future ... done
[09:28:25.760] run() for ‘SequentialFuture’ ... done
[09:28:25.760] Created future:
[09:28:25.760] SequentialFuture:
[09:28:25.760] Label: ‘future_eapply-1’
[09:28:25.760] Expression:
[09:28:25.760] {
[09:28:25.760]     do.call(function(...) {
[09:28:25.760]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.760]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.760]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.760]             on.exit(options(oopts), add = TRUE)
[09:28:25.760]         }
[09:28:25.760]         {
[09:28:25.760]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.760]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.760]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.760]             })
[09:28:25.760]         }
[09:28:25.760]     }, args = future.call.arguments)
[09:28:25.760] }
[09:28:25.760] Lazy evaluation: FALSE
[09:28:25.760] Asynchronous evaluation: FALSE
[09:28:25.760] Local evaluation: TRUE
[09:28:25.760] Environment: R_GlobalEnv
[09:28:25.760] Capture standard output: TRUE
[09:28:25.760] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.760] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.760] Packages: 1 packages (‘stats’)
[09:28:25.760] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.760] Resolved: TRUE
[09:28:25.760] Value: 1.71 KiB of class ‘list’
[09:28:25.760] Early signaling: FALSE
[09:28:25.760] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:25.760] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:25.761] Chunk #1 of 1 ... DONE
[09:28:25.761] Launching 1 futures (chunks) ... DONE
[09:28:25.761] Resolving 1 futures (chunks) ...
[09:28:25.761] resolve() on list ...
[09:28:25.761]  recursive: 0
[09:28:25.762]  length: 1
[09:28:25.762] 
[09:28:25.762] resolved() for ‘SequentialFuture’ ...
[09:28:25.762] - state: ‘finished’
[09:28:25.762] - run: TRUE
[09:28:25.762] - result: ‘FutureResult’
[09:28:25.762] resolved() for ‘SequentialFuture’ ... done
[09:28:25.762] Future #1
[09:28:25.762] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:25.762] - nx: 1
[09:28:25.762] - relay: TRUE
[09:28:25.763] - stdout: TRUE
[09:28:25.763] - signal: TRUE
[09:28:25.763] - resignal: FALSE
[09:28:25.763] - force: TRUE
[09:28:25.763] - relayed: [n=1] FALSE
[09:28:25.763] - queued futures: [n=1] FALSE
[09:28:25.763]  - until=1
[09:28:25.763]  - relaying element #1
[09:28:25.763] - relayed: [n=1] TRUE
[09:28:25.763] - queued futures: [n=1] TRUE
[09:28:25.763] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:25.764]  length: 0 (resolved future 1)
[09:28:25.764] Relaying remaining futures
[09:28:25.764] signalConditionsASAP(NULL, pos=0) ...
[09:28:25.764] - nx: 1
[09:28:25.764] - relay: TRUE
[09:28:25.764] - stdout: TRUE
[09:28:25.764] - signal: TRUE
[09:28:25.764] - resignal: FALSE
[09:28:25.764] - force: TRUE
[09:28:25.764] - relayed: [n=1] TRUE
[09:28:25.764] - queued futures: [n=1] TRUE
 - flush all
[09:28:25.765] - relayed: [n=1] TRUE
[09:28:25.765] - queued futures: [n=1] TRUE
[09:28:25.765] signalConditionsASAP(NULL, pos=0) ... done
[09:28:25.765] resolve() on list ... DONE
[09:28:25.765]  - Number of value chunks collected: 1
[09:28:25.765] Resolving 1 futures (chunks) ... DONE
[09:28:25.765] Reducing values from 1 chunks ...
[09:28:25.765]  - Number of values collected after concatenation: 3
[09:28:25.765]  - Number of values expected: 3
[09:28:25.765] Reducing values from 1 chunks ... DONE
[09:28:25.765] future_lapply() ... DONE
[09:28:25.766] plan(): Setting new future strategy stack:
[09:28:25.766] List of future strategies:
[09:28:25.766] 1. sequential:
[09:28:25.766]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.766]    - tweaked: FALSE
[09:28:25.766]    - call: plan(sequential)
[09:28:25.766] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[09:28:25.767] plan(): Setting new future strategy stack:
[09:28:25.767] List of future strategies:
[09:28:25.767] 1. multicore:
[09:28:25.767]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:25.767]    - tweaked: FALSE
[09:28:25.767]    - call: plan(strategy)
[09:28:25.770] plan(): nbrOfWorkers() = 2
[09:28:25.770] future_lapply() ...
[09:28:25.774] Number of chunks: 2
[09:28:25.774] getGlobalsAndPackagesXApply() ...
[09:28:25.775]  - future.globals: TRUE
[09:28:25.775] getGlobalsAndPackages() ...
[09:28:25.775] Searching for globals...
[09:28:25.776] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:25.776] Searching for globals ... DONE
[09:28:25.776] Resolving globals: FALSE
[09:28:25.776] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:25.777] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:25.777] - globals: [1] ‘FUN’
[09:28:25.777] 
[09:28:25.777] getGlobalsAndPackages() ... DONE
[09:28:25.777]  - globals found/used: [n=1] ‘FUN’
[09:28:25.777]  - needed namespaces: [n=0] 
[09:28:25.777] Finding globals ... DONE
[09:28:25.777]  - use_args: TRUE
[09:28:25.777]  - Getting '...' globals ...
[09:28:25.778] resolve() on list ...
[09:28:25.778]  recursive: 0
[09:28:25.778]  length: 1
[09:28:25.778]  elements: ‘...’
[09:28:25.778]  length: 0 (resolved future 1)
[09:28:25.778] resolve() on list ... DONE
[09:28:25.778]    - '...' content: [n=0] 
[09:28:25.779] List of 1
[09:28:25.779]  $ ...: list()
[09:28:25.779]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.779]  - attr(*, "where")=List of 1
[09:28:25.779]   ..$ ...:<environment: 0x5566663aefd0> 
[09:28:25.779]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.779]  - attr(*, "resolved")= logi TRUE
[09:28:25.779]  - attr(*, "total_size")= num NA
[09:28:25.782]  - Getting '...' globals ... DONE
[09:28:25.782] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:25.782] List of 2
[09:28:25.782]  $ ...future.FUN:function (x, ...)  
[09:28:25.782]  $ ...          : list()
[09:28:25.782]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.782]  - attr(*, "where")=List of 2
[09:28:25.782]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:25.782]   ..$ ...          :<environment: 0x5566663aefd0> 
[09:28:25.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.782]  - attr(*, "resolved")= logi FALSE
[09:28:25.782]  - attr(*, "total_size")= num 1240
[09:28:25.785] Packages to be attached in all futures: [n=0] 
[09:28:25.785] getGlobalsAndPackagesXApply() ... DONE
[09:28:25.785] Number of futures (= number of chunks): 2
[09:28:25.785] Launching 2 futures (chunks) ...
[09:28:25.785] Chunk #1 of 2 ...
[09:28:25.785]  - Finding globals in 'X' for chunk #1 ...
[09:28:25.785] getGlobalsAndPackages() ...
[09:28:25.785] Searching for globals...
[09:28:25.786] 
[09:28:25.786] Searching for globals ... DONE
[09:28:25.786] - globals: [0] <none>
[09:28:25.786] getGlobalsAndPackages() ... DONE
[09:28:25.786]    + additional globals found: [n=0] 
[09:28:25.786]    + additional namespaces needed: [n=0] 
[09:28:25.786]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:25.786]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:25.786]  - seeds: <none>
[09:28:25.786]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.786] getGlobalsAndPackages() ...
[09:28:25.787] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.787] Resolving globals: FALSE
[09:28:25.787] Tweak future expression to call with '...' arguments ...
[09:28:25.787] {
[09:28:25.787]     do.call(function(...) {
[09:28:25.787]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.787]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.787]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.787]             on.exit(options(oopts), add = TRUE)
[09:28:25.787]         }
[09:28:25.787]         {
[09:28:25.787]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.787]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.787]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.787]             })
[09:28:25.787]         }
[09:28:25.787]     }, args = future.call.arguments)
[09:28:25.787] }
[09:28:25.787] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.787] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.788] 
[09:28:25.788] getGlobalsAndPackages() ... DONE
[09:28:25.788] run() for ‘Future’ ...
[09:28:25.788] - state: ‘created’
[09:28:25.788] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:25.791] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.792] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:25.792]   - Field: ‘label’
[09:28:25.792]   - Field: ‘local’
[09:28:25.792]   - Field: ‘owner’
[09:28:25.792]   - Field: ‘envir’
[09:28:25.792]   - Field: ‘workers’
[09:28:25.792]   - Field: ‘packages’
[09:28:25.792]   - Field: ‘gc’
[09:28:25.792]   - Field: ‘job’
[09:28:25.792]   - Field: ‘conditions’
[09:28:25.793]   - Field: ‘expr’
[09:28:25.793]   - Field: ‘uuid’
[09:28:25.793]   - Field: ‘seed’
[09:28:25.793]   - Field: ‘version’
[09:28:25.793]   - Field: ‘result’
[09:28:25.793]   - Field: ‘asynchronous’
[09:28:25.793]   - Field: ‘calls’
[09:28:25.793]   - Field: ‘globals’
[09:28:25.793]   - Field: ‘stdout’
[09:28:25.793]   - Field: ‘earlySignal’
[09:28:25.793]   - Field: ‘lazy’
[09:28:25.793]   - Field: ‘state’
[09:28:25.794] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:25.794] - Launch lazy future ...
[09:28:25.795] Packages needed by the future expression (n = 0): <none>
[09:28:25.795] Packages needed by future strategies (n = 0): <none>
[09:28:25.795] {
[09:28:25.795]     {
[09:28:25.795]         {
[09:28:25.795]             ...future.startTime <- base::Sys.time()
[09:28:25.795]             {
[09:28:25.795]                 {
[09:28:25.795]                   {
[09:28:25.795]                     {
[09:28:25.795]                       base::local({
[09:28:25.795]                         has_future <- base::requireNamespace("future", 
[09:28:25.795]                           quietly = TRUE)
[09:28:25.795]                         if (has_future) {
[09:28:25.795]                           ns <- base::getNamespace("future")
[09:28:25.795]                           version <- ns[[".package"]][["version"]]
[09:28:25.795]                           if (is.null(version)) 
[09:28:25.795]                             version <- utils::packageVersion("future")
[09:28:25.795]                         }
[09:28:25.795]                         else {
[09:28:25.795]                           version <- NULL
[09:28:25.795]                         }
[09:28:25.795]                         if (!has_future || version < "1.8.0") {
[09:28:25.795]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.795]                             "", base::R.version$version.string), 
[09:28:25.795]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:25.795]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:25.795]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.795]                               "release", "version")], collapse = " "), 
[09:28:25.795]                             hostname = base::Sys.info()[["nodename"]])
[09:28:25.795]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.795]                             info)
[09:28:25.795]                           info <- base::paste(info, collapse = "; ")
[09:28:25.795]                           if (!has_future) {
[09:28:25.795]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.795]                               info)
[09:28:25.795]                           }
[09:28:25.795]                           else {
[09:28:25.795]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.795]                               info, version)
[09:28:25.795]                           }
[09:28:25.795]                           base::stop(msg)
[09:28:25.795]                         }
[09:28:25.795]                       })
[09:28:25.795]                     }
[09:28:25.795]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:25.795]                     base::options(mc.cores = 1L)
[09:28:25.795]                   }
[09:28:25.795]                   ...future.strategy.old <- future::plan("list")
[09:28:25.795]                   options(future.plan = NULL)
[09:28:25.795]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.795]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.795]                 }
[09:28:25.795]                 ...future.workdir <- getwd()
[09:28:25.795]             }
[09:28:25.795]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.795]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.795]         }
[09:28:25.795]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.795]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:25.795]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.795]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.795]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.795]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.795]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.795]             base::names(...future.oldOptions))
[09:28:25.795]     }
[09:28:25.795]     if (FALSE) {
[09:28:25.795]     }
[09:28:25.795]     else {
[09:28:25.795]         if (TRUE) {
[09:28:25.795]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.795]                 open = "w")
[09:28:25.795]         }
[09:28:25.795]         else {
[09:28:25.795]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.795]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.795]         }
[09:28:25.795]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.795]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.795]             base::sink(type = "output", split = FALSE)
[09:28:25.795]             base::close(...future.stdout)
[09:28:25.795]         }, add = TRUE)
[09:28:25.795]     }
[09:28:25.795]     ...future.frame <- base::sys.nframe()
[09:28:25.795]     ...future.conditions <- base::list()
[09:28:25.795]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.795]     if (FALSE) {
[09:28:25.795]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.795]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.795]     }
[09:28:25.795]     ...future.result <- base::tryCatch({
[09:28:25.795]         base::withCallingHandlers({
[09:28:25.795]             ...future.value <- base::withVisible(base::local({
[09:28:25.795]                 withCallingHandlers({
[09:28:25.795]                   {
[09:28:25.795]                     do.call(function(...) {
[09:28:25.795]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.795]                       if (!identical(...future.globals.maxSize.org, 
[09:28:25.795]                         ...future.globals.maxSize)) {
[09:28:25.795]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.795]                         on.exit(options(oopts), add = TRUE)
[09:28:25.795]                       }
[09:28:25.795]                       {
[09:28:25.795]                         lapply(seq_along(...future.elements_ii), 
[09:28:25.795]                           FUN = function(jj) {
[09:28:25.795]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.795]                             ...future.FUN(...future.X_jj, ...)
[09:28:25.795]                           })
[09:28:25.795]                       }
[09:28:25.795]                     }, args = future.call.arguments)
[09:28:25.795]                   }
[09:28:25.795]                 }, immediateCondition = function(cond) {
[09:28:25.795]                   save_rds <- function (object, pathname, ...) 
[09:28:25.795]                   {
[09:28:25.795]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:25.795]                     if (file_test("-f", pathname_tmp)) {
[09:28:25.795]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.795]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:25.795]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.795]                         fi_tmp[["mtime"]])
[09:28:25.795]                     }
[09:28:25.795]                     tryCatch({
[09:28:25.795]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:25.795]                     }, error = function(ex) {
[09:28:25.795]                       msg <- conditionMessage(ex)
[09:28:25.795]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.795]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:25.795]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.795]                         fi_tmp[["mtime"]], msg)
[09:28:25.795]                       ex$message <- msg
[09:28:25.795]                       stop(ex)
[09:28:25.795]                     })
[09:28:25.795]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:25.795]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:25.795]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:25.795]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.795]                       fi <- file.info(pathname)
[09:28:25.795]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:25.795]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.795]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:25.795]                         fi[["size"]], fi[["mtime"]])
[09:28:25.795]                       stop(msg)
[09:28:25.795]                     }
[09:28:25.795]                     invisible(pathname)
[09:28:25.795]                   }
[09:28:25.795]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:25.795]                     rootPath = tempdir()) 
[09:28:25.795]                   {
[09:28:25.795]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:25.795]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:25.795]                       tmpdir = path, fileext = ".rds")
[09:28:25.795]                     save_rds(obj, file)
[09:28:25.795]                   }
[09:28:25.795]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPXoGS/.future/immediateConditions")
[09:28:25.795]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.795]                   {
[09:28:25.795]                     inherits <- base::inherits
[09:28:25.795]                     invokeRestart <- base::invokeRestart
[09:28:25.795]                     is.null <- base::is.null
[09:28:25.795]                     muffled <- FALSE
[09:28:25.795]                     if (inherits(cond, "message")) {
[09:28:25.795]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:25.795]                       if (muffled) 
[09:28:25.795]                         invokeRestart("muffleMessage")
[09:28:25.795]                     }
[09:28:25.795]                     else if (inherits(cond, "warning")) {
[09:28:25.795]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:25.795]                       if (muffled) 
[09:28:25.795]                         invokeRestart("muffleWarning")
[09:28:25.795]                     }
[09:28:25.795]                     else if (inherits(cond, "condition")) {
[09:28:25.795]                       if (!is.null(pattern)) {
[09:28:25.795]                         computeRestarts <- base::computeRestarts
[09:28:25.795]                         grepl <- base::grepl
[09:28:25.795]                         restarts <- computeRestarts(cond)
[09:28:25.795]                         for (restart in restarts) {
[09:28:25.795]                           name <- restart$name
[09:28:25.795]                           if (is.null(name)) 
[09:28:25.795]                             next
[09:28:25.795]                           if (!grepl(pattern, name)) 
[09:28:25.795]                             next
[09:28:25.795]                           invokeRestart(restart)
[09:28:25.795]                           muffled <- TRUE
[09:28:25.795]                           break
[09:28:25.795]                         }
[09:28:25.795]                       }
[09:28:25.795]                     }
[09:28:25.795]                     invisible(muffled)
[09:28:25.795]                   }
[09:28:25.795]                   muffleCondition(cond)
[09:28:25.795]                 })
[09:28:25.795]             }))
[09:28:25.795]             future::FutureResult(value = ...future.value$value, 
[09:28:25.795]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.795]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.795]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.795]                     ...future.globalenv.names))
[09:28:25.795]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.795]         }, condition = base::local({
[09:28:25.795]             c <- base::c
[09:28:25.795]             inherits <- base::inherits
[09:28:25.795]             invokeRestart <- base::invokeRestart
[09:28:25.795]             length <- base::length
[09:28:25.795]             list <- base::list
[09:28:25.795]             seq.int <- base::seq.int
[09:28:25.795]             signalCondition <- base::signalCondition
[09:28:25.795]             sys.calls <- base::sys.calls
[09:28:25.795]             `[[` <- base::`[[`
[09:28:25.795]             `+` <- base::`+`
[09:28:25.795]             `<<-` <- base::`<<-`
[09:28:25.795]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.795]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.795]                   3L)]
[09:28:25.795]             }
[09:28:25.795]             function(cond) {
[09:28:25.795]                 is_error <- inherits(cond, "error")
[09:28:25.795]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.795]                   NULL)
[09:28:25.795]                 if (is_error) {
[09:28:25.795]                   sessionInformation <- function() {
[09:28:25.795]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.795]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.795]                       search = base::search(), system = base::Sys.info())
[09:28:25.795]                   }
[09:28:25.795]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.795]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.795]                     cond$call), session = sessionInformation(), 
[09:28:25.795]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.795]                   signalCondition(cond)
[09:28:25.795]                 }
[09:28:25.795]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.795]                 "immediateCondition"))) {
[09:28:25.795]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.795]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.795]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.795]                   if (TRUE && !signal) {
[09:28:25.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.795]                     {
[09:28:25.795]                       inherits <- base::inherits
[09:28:25.795]                       invokeRestart <- base::invokeRestart
[09:28:25.795]                       is.null <- base::is.null
[09:28:25.795]                       muffled <- FALSE
[09:28:25.795]                       if (inherits(cond, "message")) {
[09:28:25.795]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.795]                         if (muffled) 
[09:28:25.795]                           invokeRestart("muffleMessage")
[09:28:25.795]                       }
[09:28:25.795]                       else if (inherits(cond, "warning")) {
[09:28:25.795]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.795]                         if (muffled) 
[09:28:25.795]                           invokeRestart("muffleWarning")
[09:28:25.795]                       }
[09:28:25.795]                       else if (inherits(cond, "condition")) {
[09:28:25.795]                         if (!is.null(pattern)) {
[09:28:25.795]                           computeRestarts <- base::computeRestarts
[09:28:25.795]                           grepl <- base::grepl
[09:28:25.795]                           restarts <- computeRestarts(cond)
[09:28:25.795]                           for (restart in restarts) {
[09:28:25.795]                             name <- restart$name
[09:28:25.795]                             if (is.null(name)) 
[09:28:25.795]                               next
[09:28:25.795]                             if (!grepl(pattern, name)) 
[09:28:25.795]                               next
[09:28:25.795]                             invokeRestart(restart)
[09:28:25.795]                             muffled <- TRUE
[09:28:25.795]                             break
[09:28:25.795]                           }
[09:28:25.795]                         }
[09:28:25.795]                       }
[09:28:25.795]                       invisible(muffled)
[09:28:25.795]                     }
[09:28:25.795]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.795]                   }
[09:28:25.795]                 }
[09:28:25.795]                 else {
[09:28:25.795]                   if (TRUE) {
[09:28:25.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.795]                     {
[09:28:25.795]                       inherits <- base::inherits
[09:28:25.795]                       invokeRestart <- base::invokeRestart
[09:28:25.795]                       is.null <- base::is.null
[09:28:25.795]                       muffled <- FALSE
[09:28:25.795]                       if (inherits(cond, "message")) {
[09:28:25.795]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.795]                         if (muffled) 
[09:28:25.795]                           invokeRestart("muffleMessage")
[09:28:25.795]                       }
[09:28:25.795]                       else if (inherits(cond, "warning")) {
[09:28:25.795]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.795]                         if (muffled) 
[09:28:25.795]                           invokeRestart("muffleWarning")
[09:28:25.795]                       }
[09:28:25.795]                       else if (inherits(cond, "condition")) {
[09:28:25.795]                         if (!is.null(pattern)) {
[09:28:25.795]                           computeRestarts <- base::computeRestarts
[09:28:25.795]                           grepl <- base::grepl
[09:28:25.795]                           restarts <- computeRestarts(cond)
[09:28:25.795]                           for (restart in restarts) {
[09:28:25.795]                             name <- restart$name
[09:28:25.795]                             if (is.null(name)) 
[09:28:25.795]                               next
[09:28:25.795]                             if (!grepl(pattern, name)) 
[09:28:25.795]                               next
[09:28:25.795]                             invokeRestart(restart)
[09:28:25.795]                             muffled <- TRUE
[09:28:25.795]                             break
[09:28:25.795]                           }
[09:28:25.795]                         }
[09:28:25.795]                       }
[09:28:25.795]                       invisible(muffled)
[09:28:25.795]                     }
[09:28:25.795]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.795]                   }
[09:28:25.795]                 }
[09:28:25.795]             }
[09:28:25.795]         }))
[09:28:25.795]     }, error = function(ex) {
[09:28:25.795]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.795]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.795]                 ...future.rng), started = ...future.startTime, 
[09:28:25.795]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.795]             version = "1.8"), class = "FutureResult")
[09:28:25.795]     }, finally = {
[09:28:25.795]         if (!identical(...future.workdir, getwd())) 
[09:28:25.795]             setwd(...future.workdir)
[09:28:25.795]         {
[09:28:25.795]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.795]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.795]             }
[09:28:25.795]             base::options(...future.oldOptions)
[09:28:25.795]             if (.Platform$OS.type == "windows") {
[09:28:25.795]                 old_names <- names(...future.oldEnvVars)
[09:28:25.795]                 envs <- base::Sys.getenv()
[09:28:25.795]                 names <- names(envs)
[09:28:25.795]                 common <- intersect(names, old_names)
[09:28:25.795]                 added <- setdiff(names, old_names)
[09:28:25.795]                 removed <- setdiff(old_names, names)
[09:28:25.795]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.795]                   envs[common]]
[09:28:25.795]                 NAMES <- toupper(changed)
[09:28:25.795]                 args <- list()
[09:28:25.795]                 for (kk in seq_along(NAMES)) {
[09:28:25.795]                   name <- changed[[kk]]
[09:28:25.795]                   NAME <- NAMES[[kk]]
[09:28:25.795]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.795]                     next
[09:28:25.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.795]                 }
[09:28:25.795]                 NAMES <- toupper(added)
[09:28:25.795]                 for (kk in seq_along(NAMES)) {
[09:28:25.795]                   name <- added[[kk]]
[09:28:25.795]                   NAME <- NAMES[[kk]]
[09:28:25.795]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.795]                     next
[09:28:25.795]                   args[[name]] <- ""
[09:28:25.795]                 }
[09:28:25.795]                 NAMES <- toupper(removed)
[09:28:25.795]                 for (kk in seq_along(NAMES)) {
[09:28:25.795]                   name <- removed[[kk]]
[09:28:25.795]                   NAME <- NAMES[[kk]]
[09:28:25.795]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.795]                     next
[09:28:25.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.795]                 }
[09:28:25.795]                 if (length(args) > 0) 
[09:28:25.795]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.795]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.795]             }
[09:28:25.795]             else {
[09:28:25.795]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.795]             }
[09:28:25.795]             {
[09:28:25.795]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.795]                   0L) {
[09:28:25.795]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.795]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.795]                   base::options(opts)
[09:28:25.795]                 }
[09:28:25.795]                 {
[09:28:25.795]                   {
[09:28:25.795]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:25.795]                     NULL
[09:28:25.795]                   }
[09:28:25.795]                   options(future.plan = NULL)
[09:28:25.795]                   if (is.na(NA_character_)) 
[09:28:25.795]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.795]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.795]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.795]                     .init = FALSE)
[09:28:25.795]                 }
[09:28:25.795]             }
[09:28:25.795]         }
[09:28:25.795]     })
[09:28:25.795]     if (TRUE) {
[09:28:25.795]         base::sink(type = "output", split = FALSE)
[09:28:25.795]         if (TRUE) {
[09:28:25.795]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.795]         }
[09:28:25.795]         else {
[09:28:25.795]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.795]         }
[09:28:25.795]         base::close(...future.stdout)
[09:28:25.795]         ...future.stdout <- NULL
[09:28:25.795]     }
[09:28:25.795]     ...future.result$conditions <- ...future.conditions
[09:28:25.795]     ...future.result$finished <- base::Sys.time()
[09:28:25.795]     ...future.result
[09:28:25.795] }
[09:28:25.797] assign_globals() ...
[09:28:25.797] List of 5
[09:28:25.797]  $ ...future.FUN            :function (x, ...)  
[09:28:25.797]  $ future.call.arguments    : list()
[09:28:25.797]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.797]  $ ...future.elements_ii    :List of 1
[09:28:25.797]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[09:28:25.797]  $ ...future.seeds_ii       : NULL
[09:28:25.797]  $ ...future.globals.maxSize: NULL
[09:28:25.797]  - attr(*, "where")=List of 5
[09:28:25.797]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:25.797]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:25.797]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:25.797]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:25.797]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:25.797]  - attr(*, "resolved")= logi FALSE
[09:28:25.797]  - attr(*, "total_size")= num 1240
[09:28:25.797]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.797]  - attr(*, "already-done")= logi TRUE
[09:28:25.802] - copied ‘...future.FUN’ to environment
[09:28:25.802] - copied ‘future.call.arguments’ to environment
[09:28:25.802] - copied ‘...future.elements_ii’ to environment
[09:28:25.802] - copied ‘...future.seeds_ii’ to environment
[09:28:25.802] - copied ‘...future.globals.maxSize’ to environment
[09:28:25.802] assign_globals() ... done
[09:28:25.802] requestCore(): workers = 2
[09:28:25.805] MulticoreFuture started
[09:28:25.806] - Launch lazy future ... done
[09:28:25.806] run() for ‘MulticoreFuture’ ... done
[09:28:25.806] plan(): Setting new future strategy stack:
[09:28:25.806] Created future:
[09:28:25.806] List of future strategies:
[09:28:25.806] 1. sequential:
[09:28:25.806]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.806]    - tweaked: FALSE
[09:28:25.806]    - call: NULL
[09:28:25.807] plan(): nbrOfWorkers() = 1
[09:28:25.809] plan(): Setting new future strategy stack:
[09:28:25.809] List of future strategies:
[09:28:25.809] 1. multicore:
[09:28:25.809]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:25.809]    - tweaked: FALSE
[09:28:25.809]    - call: plan(strategy)
[09:28:25.818] plan(): nbrOfWorkers() = 2
[09:28:25.806] MulticoreFuture:
[09:28:25.806] Label: ‘future_eapply-1’
[09:28:25.806] Expression:
[09:28:25.806] {
[09:28:25.806]     do.call(function(...) {
[09:28:25.806]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.806]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.806]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.806]             on.exit(options(oopts), add = TRUE)
[09:28:25.806]         }
[09:28:25.806]         {
[09:28:25.806]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.806]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.806]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.806]             })
[09:28:25.806]         }
[09:28:25.806]     }, args = future.call.arguments)
[09:28:25.806] }
[09:28:25.806] Lazy evaluation: FALSE
[09:28:25.806] Asynchronous evaluation: TRUE
[09:28:25.806] Local evaluation: TRUE
[09:28:25.806] Environment: R_GlobalEnv
[09:28:25.806] Capture standard output: TRUE
[09:28:25.806] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.806] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.806] Packages: <none>
[09:28:25.806] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.806] Resolved: TRUE
[09:28:25.806] Value: <not collected>
[09:28:25.806] Conditions captured: <none>
[09:28:25.806] Early signaling: FALSE
[09:28:25.806] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:25.806] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.819] Chunk #1 of 2 ... DONE
[09:28:25.819] Chunk #2 of 2 ...
[09:28:25.819]  - Finding globals in 'X' for chunk #2 ...
[09:28:25.819] getGlobalsAndPackages() ...
[09:28:25.819] Searching for globals...
[09:28:25.820] 
[09:28:25.820] Searching for globals ... DONE
[09:28:25.822] - globals: [0] <none>
[09:28:25.822] getGlobalsAndPackages() ... DONE
[09:28:25.822]    + additional globals found: [n=0] 
[09:28:25.822]    + additional namespaces needed: [n=0] 
[09:28:25.823]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:25.823]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:25.823]  - seeds: <none>
[09:28:25.823]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.823] getGlobalsAndPackages() ...
[09:28:25.823] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.824] Resolving globals: FALSE
[09:28:25.824] Tweak future expression to call with '...' arguments ...
[09:28:25.824] {
[09:28:25.824]     do.call(function(...) {
[09:28:25.824]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.824]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.824]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.824]             on.exit(options(oopts), add = TRUE)
[09:28:25.824]         }
[09:28:25.824]         {
[09:28:25.824]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.824]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.824]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.824]             })
[09:28:25.824]         }
[09:28:25.824]     }, args = future.call.arguments)
[09:28:25.824] }
[09:28:25.824] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.825] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.826] 
[09:28:25.826] getGlobalsAndPackages() ... DONE
[09:28:25.826] run() for ‘Future’ ...
[09:28:25.826] - state: ‘created’
[09:28:25.827] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:25.831] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.831] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:25.832]   - Field: ‘label’
[09:28:25.832]   - Field: ‘local’
[09:28:25.832]   - Field: ‘owner’
[09:28:25.832]   - Field: ‘envir’
[09:28:25.832]   - Field: ‘workers’
[09:28:25.833]   - Field: ‘packages’
[09:28:25.833]   - Field: ‘gc’
[09:28:25.833]   - Field: ‘job’
[09:28:25.833]   - Field: ‘conditions’
[09:28:25.833]   - Field: ‘expr’
[09:28:25.833]   - Field: ‘uuid’
[09:28:25.833]   - Field: ‘seed’
[09:28:25.834]   - Field: ‘version’
[09:28:25.834]   - Field: ‘result’
[09:28:25.834]   - Field: ‘asynchronous’
[09:28:25.834]   - Field: ‘calls’
[09:28:25.834]   - Field: ‘globals’
[09:28:25.834]   - Field: ‘stdout’
[09:28:25.834]   - Field: ‘earlySignal’
[09:28:25.835]   - Field: ‘lazy’
[09:28:25.835]   - Field: ‘state’
[09:28:25.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:25.835] - Launch lazy future ...
[09:28:25.835] Packages needed by the future expression (n = 0): <none>
[09:28:25.836] Packages needed by future strategies (n = 0): <none>
[09:28:25.836] {
[09:28:25.836]     {
[09:28:25.836]         {
[09:28:25.836]             ...future.startTime <- base::Sys.time()
[09:28:25.836]             {
[09:28:25.836]                 {
[09:28:25.836]                   {
[09:28:25.836]                     {
[09:28:25.836]                       base::local({
[09:28:25.836]                         has_future <- base::requireNamespace("future", 
[09:28:25.836]                           quietly = TRUE)
[09:28:25.836]                         if (has_future) {
[09:28:25.836]                           ns <- base::getNamespace("future")
[09:28:25.836]                           version <- ns[[".package"]][["version"]]
[09:28:25.836]                           if (is.null(version)) 
[09:28:25.836]                             version <- utils::packageVersion("future")
[09:28:25.836]                         }
[09:28:25.836]                         else {
[09:28:25.836]                           version <- NULL
[09:28:25.836]                         }
[09:28:25.836]                         if (!has_future || version < "1.8.0") {
[09:28:25.836]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.836]                             "", base::R.version$version.string), 
[09:28:25.836]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:25.836]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:25.836]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.836]                               "release", "version")], collapse = " "), 
[09:28:25.836]                             hostname = base::Sys.info()[["nodename"]])
[09:28:25.836]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.836]                             info)
[09:28:25.836]                           info <- base::paste(info, collapse = "; ")
[09:28:25.836]                           if (!has_future) {
[09:28:25.836]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.836]                               info)
[09:28:25.836]                           }
[09:28:25.836]                           else {
[09:28:25.836]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.836]                               info, version)
[09:28:25.836]                           }
[09:28:25.836]                           base::stop(msg)
[09:28:25.836]                         }
[09:28:25.836]                       })
[09:28:25.836]                     }
[09:28:25.836]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:25.836]                     base::options(mc.cores = 1L)
[09:28:25.836]                   }
[09:28:25.836]                   ...future.strategy.old <- future::plan("list")
[09:28:25.836]                   options(future.plan = NULL)
[09:28:25.836]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.836]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.836]                 }
[09:28:25.836]                 ...future.workdir <- getwd()
[09:28:25.836]             }
[09:28:25.836]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.836]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.836]         }
[09:28:25.836]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.836]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:25.836]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.836]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.836]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.836]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.836]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.836]             base::names(...future.oldOptions))
[09:28:25.836]     }
[09:28:25.836]     if (FALSE) {
[09:28:25.836]     }
[09:28:25.836]     else {
[09:28:25.836]         if (TRUE) {
[09:28:25.836]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.836]                 open = "w")
[09:28:25.836]         }
[09:28:25.836]         else {
[09:28:25.836]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.836]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.836]         }
[09:28:25.836]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.836]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.836]             base::sink(type = "output", split = FALSE)
[09:28:25.836]             base::close(...future.stdout)
[09:28:25.836]         }, add = TRUE)
[09:28:25.836]     }
[09:28:25.836]     ...future.frame <- base::sys.nframe()
[09:28:25.836]     ...future.conditions <- base::list()
[09:28:25.836]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.836]     if (FALSE) {
[09:28:25.836]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.836]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.836]     }
[09:28:25.836]     ...future.result <- base::tryCatch({
[09:28:25.836]         base::withCallingHandlers({
[09:28:25.836]             ...future.value <- base::withVisible(base::local({
[09:28:25.836]                 withCallingHandlers({
[09:28:25.836]                   {
[09:28:25.836]                     do.call(function(...) {
[09:28:25.836]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.836]                       if (!identical(...future.globals.maxSize.org, 
[09:28:25.836]                         ...future.globals.maxSize)) {
[09:28:25.836]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.836]                         on.exit(options(oopts), add = TRUE)
[09:28:25.836]                       }
[09:28:25.836]                       {
[09:28:25.836]                         lapply(seq_along(...future.elements_ii), 
[09:28:25.836]                           FUN = function(jj) {
[09:28:25.836]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.836]                             ...future.FUN(...future.X_jj, ...)
[09:28:25.836]                           })
[09:28:25.836]                       }
[09:28:25.836]                     }, args = future.call.arguments)
[09:28:25.836]                   }
[09:28:25.836]                 }, immediateCondition = function(cond) {
[09:28:25.836]                   save_rds <- function (object, pathname, ...) 
[09:28:25.836]                   {
[09:28:25.836]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:25.836]                     if (file_test("-f", pathname_tmp)) {
[09:28:25.836]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.836]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:25.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.836]                         fi_tmp[["mtime"]])
[09:28:25.836]                     }
[09:28:25.836]                     tryCatch({
[09:28:25.836]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:25.836]                     }, error = function(ex) {
[09:28:25.836]                       msg <- conditionMessage(ex)
[09:28:25.836]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.836]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:25.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.836]                         fi_tmp[["mtime"]], msg)
[09:28:25.836]                       ex$message <- msg
[09:28:25.836]                       stop(ex)
[09:28:25.836]                     })
[09:28:25.836]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:25.836]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:25.836]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:25.836]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.836]                       fi <- file.info(pathname)
[09:28:25.836]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:25.836]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.836]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:25.836]                         fi[["size"]], fi[["mtime"]])
[09:28:25.836]                       stop(msg)
[09:28:25.836]                     }
[09:28:25.836]                     invisible(pathname)
[09:28:25.836]                   }
[09:28:25.836]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:25.836]                     rootPath = tempdir()) 
[09:28:25.836]                   {
[09:28:25.836]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:25.836]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:25.836]                       tmpdir = path, fileext = ".rds")
[09:28:25.836]                     save_rds(obj, file)
[09:28:25.836]                   }
[09:28:25.836]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPXoGS/.future/immediateConditions")
[09:28:25.836]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.836]                   {
[09:28:25.836]                     inherits <- base::inherits
[09:28:25.836]                     invokeRestart <- base::invokeRestart
[09:28:25.836]                     is.null <- base::is.null
[09:28:25.836]                     muffled <- FALSE
[09:28:25.836]                     if (inherits(cond, "message")) {
[09:28:25.836]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:25.836]                       if (muffled) 
[09:28:25.836]                         invokeRestart("muffleMessage")
[09:28:25.836]                     }
[09:28:25.836]                     else if (inherits(cond, "warning")) {
[09:28:25.836]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:25.836]                       if (muffled) 
[09:28:25.836]                         invokeRestart("muffleWarning")
[09:28:25.836]                     }
[09:28:25.836]                     else if (inherits(cond, "condition")) {
[09:28:25.836]                       if (!is.null(pattern)) {
[09:28:25.836]                         computeRestarts <- base::computeRestarts
[09:28:25.836]                         grepl <- base::grepl
[09:28:25.836]                         restarts <- computeRestarts(cond)
[09:28:25.836]                         for (restart in restarts) {
[09:28:25.836]                           name <- restart$name
[09:28:25.836]                           if (is.null(name)) 
[09:28:25.836]                             next
[09:28:25.836]                           if (!grepl(pattern, name)) 
[09:28:25.836]                             next
[09:28:25.836]                           invokeRestart(restart)
[09:28:25.836]                           muffled <- TRUE
[09:28:25.836]                           break
[09:28:25.836]                         }
[09:28:25.836]                       }
[09:28:25.836]                     }
[09:28:25.836]                     invisible(muffled)
[09:28:25.836]                   }
[09:28:25.836]                   muffleCondition(cond)
[09:28:25.836]                 })
[09:28:25.836]             }))
[09:28:25.836]             future::FutureResult(value = ...future.value$value, 
[09:28:25.836]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.836]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.836]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.836]                     ...future.globalenv.names))
[09:28:25.836]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.836]         }, condition = base::local({
[09:28:25.836]             c <- base::c
[09:28:25.836]             inherits <- base::inherits
[09:28:25.836]             invokeRestart <- base::invokeRestart
[09:28:25.836]             length <- base::length
[09:28:25.836]             list <- base::list
[09:28:25.836]             seq.int <- base::seq.int
[09:28:25.836]             signalCondition <- base::signalCondition
[09:28:25.836]             sys.calls <- base::sys.calls
[09:28:25.836]             `[[` <- base::`[[`
[09:28:25.836]             `+` <- base::`+`
[09:28:25.836]             `<<-` <- base::`<<-`
[09:28:25.836]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.836]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.836]                   3L)]
[09:28:25.836]             }
[09:28:25.836]             function(cond) {
[09:28:25.836]                 is_error <- inherits(cond, "error")
[09:28:25.836]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.836]                   NULL)
[09:28:25.836]                 if (is_error) {
[09:28:25.836]                   sessionInformation <- function() {
[09:28:25.836]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.836]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.836]                       search = base::search(), system = base::Sys.info())
[09:28:25.836]                   }
[09:28:25.836]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.836]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.836]                     cond$call), session = sessionInformation(), 
[09:28:25.836]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.836]                   signalCondition(cond)
[09:28:25.836]                 }
[09:28:25.836]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.836]                 "immediateCondition"))) {
[09:28:25.836]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.836]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.836]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.836]                   if (TRUE && !signal) {
[09:28:25.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.836]                     {
[09:28:25.836]                       inherits <- base::inherits
[09:28:25.836]                       invokeRestart <- base::invokeRestart
[09:28:25.836]                       is.null <- base::is.null
[09:28:25.836]                       muffled <- FALSE
[09:28:25.836]                       if (inherits(cond, "message")) {
[09:28:25.836]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.836]                         if (muffled) 
[09:28:25.836]                           invokeRestart("muffleMessage")
[09:28:25.836]                       }
[09:28:25.836]                       else if (inherits(cond, "warning")) {
[09:28:25.836]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.836]                         if (muffled) 
[09:28:25.836]                           invokeRestart("muffleWarning")
[09:28:25.836]                       }
[09:28:25.836]                       else if (inherits(cond, "condition")) {
[09:28:25.836]                         if (!is.null(pattern)) {
[09:28:25.836]                           computeRestarts <- base::computeRestarts
[09:28:25.836]                           grepl <- base::grepl
[09:28:25.836]                           restarts <- computeRestarts(cond)
[09:28:25.836]                           for (restart in restarts) {
[09:28:25.836]                             name <- restart$name
[09:28:25.836]                             if (is.null(name)) 
[09:28:25.836]                               next
[09:28:25.836]                             if (!grepl(pattern, name)) 
[09:28:25.836]                               next
[09:28:25.836]                             invokeRestart(restart)
[09:28:25.836]                             muffled <- TRUE
[09:28:25.836]                             break
[09:28:25.836]                           }
[09:28:25.836]                         }
[09:28:25.836]                       }
[09:28:25.836]                       invisible(muffled)
[09:28:25.836]                     }
[09:28:25.836]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.836]                   }
[09:28:25.836]                 }
[09:28:25.836]                 else {
[09:28:25.836]                   if (TRUE) {
[09:28:25.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.836]                     {
[09:28:25.836]                       inherits <- base::inherits
[09:28:25.836]                       invokeRestart <- base::invokeRestart
[09:28:25.836]                       is.null <- base::is.null
[09:28:25.836]                       muffled <- FALSE
[09:28:25.836]                       if (inherits(cond, "message")) {
[09:28:25.836]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.836]                         if (muffled) 
[09:28:25.836]                           invokeRestart("muffleMessage")
[09:28:25.836]                       }
[09:28:25.836]                       else if (inherits(cond, "warning")) {
[09:28:25.836]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.836]                         if (muffled) 
[09:28:25.836]                           invokeRestart("muffleWarning")
[09:28:25.836]                       }
[09:28:25.836]                       else if (inherits(cond, "condition")) {
[09:28:25.836]                         if (!is.null(pattern)) {
[09:28:25.836]                           computeRestarts <- base::computeRestarts
[09:28:25.836]                           grepl <- base::grepl
[09:28:25.836]                           restarts <- computeRestarts(cond)
[09:28:25.836]                           for (restart in restarts) {
[09:28:25.836]                             name <- restart$name
[09:28:25.836]                             if (is.null(name)) 
[09:28:25.836]                               next
[09:28:25.836]                             if (!grepl(pattern, name)) 
[09:28:25.836]                               next
[09:28:25.836]                             invokeRestart(restart)
[09:28:25.836]                             muffled <- TRUE
[09:28:25.836]                             break
[09:28:25.836]                           }
[09:28:25.836]                         }
[09:28:25.836]                       }
[09:28:25.836]                       invisible(muffled)
[09:28:25.836]                     }
[09:28:25.836]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.836]                   }
[09:28:25.836]                 }
[09:28:25.836]             }
[09:28:25.836]         }))
[09:28:25.836]     }, error = function(ex) {
[09:28:25.836]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.836]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.836]                 ...future.rng), started = ...future.startTime, 
[09:28:25.836]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.836]             version = "1.8"), class = "FutureResult")
[09:28:25.836]     }, finally = {
[09:28:25.836]         if (!identical(...future.workdir, getwd())) 
[09:28:25.836]             setwd(...future.workdir)
[09:28:25.836]         {
[09:28:25.836]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.836]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.836]             }
[09:28:25.836]             base::options(...future.oldOptions)
[09:28:25.836]             if (.Platform$OS.type == "windows") {
[09:28:25.836]                 old_names <- names(...future.oldEnvVars)
[09:28:25.836]                 envs <- base::Sys.getenv()
[09:28:25.836]                 names <- names(envs)
[09:28:25.836]                 common <- intersect(names, old_names)
[09:28:25.836]                 added <- setdiff(names, old_names)
[09:28:25.836]                 removed <- setdiff(old_names, names)
[09:28:25.836]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.836]                   envs[common]]
[09:28:25.836]                 NAMES <- toupper(changed)
[09:28:25.836]                 args <- list()
[09:28:25.836]                 for (kk in seq_along(NAMES)) {
[09:28:25.836]                   name <- changed[[kk]]
[09:28:25.836]                   NAME <- NAMES[[kk]]
[09:28:25.836]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.836]                     next
[09:28:25.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.836]                 }
[09:28:25.836]                 NAMES <- toupper(added)
[09:28:25.836]                 for (kk in seq_along(NAMES)) {
[09:28:25.836]                   name <- added[[kk]]
[09:28:25.836]                   NAME <- NAMES[[kk]]
[09:28:25.836]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.836]                     next
[09:28:25.836]                   args[[name]] <- ""
[09:28:25.836]                 }
[09:28:25.836]                 NAMES <- toupper(removed)
[09:28:25.836]                 for (kk in seq_along(NAMES)) {
[09:28:25.836]                   name <- removed[[kk]]
[09:28:25.836]                   NAME <- NAMES[[kk]]
[09:28:25.836]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.836]                     next
[09:28:25.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.836]                 }
[09:28:25.836]                 if (length(args) > 0) 
[09:28:25.836]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.836]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.836]             }
[09:28:25.836]             else {
[09:28:25.836]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.836]             }
[09:28:25.836]             {
[09:28:25.836]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.836]                   0L) {
[09:28:25.836]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.836]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.836]                   base::options(opts)
[09:28:25.836]                 }
[09:28:25.836]                 {
[09:28:25.836]                   {
[09:28:25.836]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:25.836]                     NULL
[09:28:25.836]                   }
[09:28:25.836]                   options(future.plan = NULL)
[09:28:25.836]                   if (is.na(NA_character_)) 
[09:28:25.836]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.836]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.836]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.836]                     .init = FALSE)
[09:28:25.836]                 }
[09:28:25.836]             }
[09:28:25.836]         }
[09:28:25.836]     })
[09:28:25.836]     if (TRUE) {
[09:28:25.836]         base::sink(type = "output", split = FALSE)
[09:28:25.836]         if (TRUE) {
[09:28:25.836]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.836]         }
[09:28:25.836]         else {
[09:28:25.836]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.836]         }
[09:28:25.836]         base::close(...future.stdout)
[09:28:25.836]         ...future.stdout <- NULL
[09:28:25.836]     }
[09:28:25.836]     ...future.result$conditions <- ...future.conditions
[09:28:25.836]     ...future.result$finished <- base::Sys.time()
[09:28:25.836]     ...future.result
[09:28:25.836] }
[09:28:25.838] assign_globals() ...
[09:28:25.839] List of 5
[09:28:25.839]  $ ...future.FUN            :function (x, ...)  
[09:28:25.839]  $ future.call.arguments    : list()
[09:28:25.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.839]  $ ...future.elements_ii    :List of 2
[09:28:25.839]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[09:28:25.839]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:28:25.839]  $ ...future.seeds_ii       : NULL
[09:28:25.839]  $ ...future.globals.maxSize: NULL
[09:28:25.839]  - attr(*, "where")=List of 5
[09:28:25.839]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:25.839]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:25.839]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:25.839]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:25.839]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:25.839]  - attr(*, "resolved")= logi FALSE
[09:28:25.839]  - attr(*, "total_size")= num 1240
[09:28:25.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.839]  - attr(*, "already-done")= logi TRUE
[09:28:25.846] - copied ‘...future.FUN’ to environment
[09:28:25.846] - copied ‘future.call.arguments’ to environment
[09:28:25.846] - copied ‘...future.elements_ii’ to environment
[09:28:25.846] - copied ‘...future.seeds_ii’ to environment
[09:28:25.846] - copied ‘...future.globals.maxSize’ to environment
[09:28:25.846] assign_globals() ... done
[09:28:25.847] requestCore(): workers = 2
[09:28:25.852] MulticoreFuture started
[09:28:25.852] - Launch lazy future ... done
[09:28:25.852] run() for ‘MulticoreFuture’ ... done
[09:28:25.853] Created future:
[09:28:25.853] plan(): Setting new future strategy stack:
[09:28:25.853] List of future strategies:
[09:28:25.853] 1. sequential:
[09:28:25.853]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.853]    - tweaked: FALSE
[09:28:25.853]    - call: NULL
[09:28:25.854] plan(): nbrOfWorkers() = 1
[09:28:25.856] plan(): Setting new future strategy stack:
[09:28:25.856] List of future strategies:
[09:28:25.856] 1. multicore:
[09:28:25.856]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:25.856]    - tweaked: FALSE
[09:28:25.856]    - call: plan(strategy)
[09:28:25.862] plan(): nbrOfWorkers() = 2
[09:28:25.853] MulticoreFuture:
[09:28:25.853] Label: ‘future_eapply-2’
[09:28:25.853] Expression:
[09:28:25.853] {
[09:28:25.853]     do.call(function(...) {
[09:28:25.853]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.853]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.853]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.853]             on.exit(options(oopts), add = TRUE)
[09:28:25.853]         }
[09:28:25.853]         {
[09:28:25.853]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.853]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.853]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.853]             })
[09:28:25.853]         }
[09:28:25.853]     }, args = future.call.arguments)
[09:28:25.853] }
[09:28:25.853] Lazy evaluation: FALSE
[09:28:25.853] Asynchronous evaluation: TRUE
[09:28:25.853] Local evaluation: TRUE
[09:28:25.853] Environment: R_GlobalEnv
[09:28:25.853] Capture standard output: TRUE
[09:28:25.853] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.853] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.853] Packages: <none>
[09:28:25.853] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.853] Resolved: TRUE
[09:28:25.853] Value: <not collected>
[09:28:25.853] Conditions captured: <none>
[09:28:25.853] Early signaling: FALSE
[09:28:25.853] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:25.853] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.863] Chunk #2 of 2 ... DONE
[09:28:25.863] Launching 2 futures (chunks) ... DONE
[09:28:25.863] Resolving 2 futures (chunks) ...
[09:28:25.863] resolve() on list ...
[09:28:25.863]  recursive: 0
[09:28:25.863]  length: 2
[09:28:25.864] 
[09:28:25.864] Future #1
[09:28:25.865] result() for MulticoreFuture ...
[09:28:25.866] result() for MulticoreFuture ...
[09:28:25.867] result() for MulticoreFuture ... done
[09:28:25.867] result() for MulticoreFuture ... done
[09:28:25.867] result() for MulticoreFuture ...
[09:28:25.867] result() for MulticoreFuture ... done
[09:28:25.867] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:25.868] - nx: 2
[09:28:25.868] - relay: TRUE
[09:28:25.868] - stdout: TRUE
[09:28:25.868] - signal: TRUE
[09:28:25.868] - resignal: FALSE
[09:28:25.869] - force: TRUE
[09:28:25.869] - relayed: [n=2] FALSE, FALSE
[09:28:25.869] - queued futures: [n=2] FALSE, FALSE
[09:28:25.869]  - until=1
[09:28:25.869]  - relaying element #1
[09:28:25.869] result() for MulticoreFuture ...
[09:28:25.870] result() for MulticoreFuture ... done
[09:28:25.870] result() for MulticoreFuture ...
[09:28:25.870] result() for MulticoreFuture ... done
[09:28:25.870] result() for MulticoreFuture ...
[09:28:25.870] result() for MulticoreFuture ... done
[09:28:25.871] result() for MulticoreFuture ...
[09:28:25.871] result() for MulticoreFuture ... done
[09:28:25.871] - relayed: [n=2] TRUE, FALSE
[09:28:25.871] - queued futures: [n=2] TRUE, FALSE
[09:28:25.871] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:25.871]  length: 1 (resolved future 1)
[09:28:25.872] Future #2
[09:28:25.872] result() for MulticoreFuture ...
[09:28:25.872] result() for MulticoreFuture ...
[09:28:25.873] result() for MulticoreFuture ... done
[09:28:25.873] result() for MulticoreFuture ... done
[09:28:25.876] result() for MulticoreFuture ...
[09:28:25.876] result() for MulticoreFuture ... done
[09:28:25.876] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:25.876] - nx: 2
[09:28:25.876] - relay: TRUE
[09:28:25.876] - stdout: TRUE
[09:28:25.876] - signal: TRUE
[09:28:25.876] - resignal: FALSE
[09:28:25.877] - force: TRUE
[09:28:25.877] - relayed: [n=2] TRUE, FALSE
[09:28:25.877] - queued futures: [n=2] TRUE, FALSE
[09:28:25.877]  - until=2
[09:28:25.877]  - relaying element #2
[09:28:25.877] result() for MulticoreFuture ...
[09:28:25.877] result() for MulticoreFuture ... done
[09:28:25.877] result() for MulticoreFuture ...
[09:28:25.878] result() for MulticoreFuture ... done
[09:28:25.878] result() for MulticoreFuture ...
[09:28:25.878] result() for MulticoreFuture ... done
[09:28:25.878] result() for MulticoreFuture ...
[09:28:25.878] result() for MulticoreFuture ... done
[09:28:25.878] - relayed: [n=2] TRUE, TRUE
[09:28:25.878] - queued futures: [n=2] TRUE, TRUE
[09:28:25.879] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:25.879]  length: 0 (resolved future 2)
[09:28:25.879] Relaying remaining futures
[09:28:25.879] signalConditionsASAP(NULL, pos=0) ...
[09:28:25.879] - nx: 2
[09:28:25.879] - relay: TRUE
[09:28:25.879] - stdout: TRUE
[09:28:25.879] - signal: TRUE
[09:28:25.880] - resignal: FALSE
[09:28:25.880] - force: TRUE
[09:28:25.880] - relayed: [n=2] TRUE, TRUE
[09:28:25.880] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:25.880] - relayed: [n=2] TRUE, TRUE
[09:28:25.880] - queued futures: [n=2] TRUE, TRUE
[09:28:25.880] signalConditionsASAP(NULL, pos=0) ... done
[09:28:25.880] resolve() on list ... DONE
[09:28:25.881] result() for MulticoreFuture ...
[09:28:25.881] result() for MulticoreFuture ... done
[09:28:25.881] result() for MulticoreFuture ...
[09:28:25.881] result() for MulticoreFuture ... done
[09:28:25.881] result() for MulticoreFuture ...
[09:28:25.881] result() for MulticoreFuture ... done
[09:28:25.881] result() for MulticoreFuture ...
[09:28:25.881] result() for MulticoreFuture ... done
[09:28:25.882]  - Number of value chunks collected: 2
[09:28:25.882] Resolving 2 futures (chunks) ... DONE
[09:28:25.882] Reducing values from 2 chunks ...
[09:28:25.882]  - Number of values collected after concatenation: 3
[09:28:25.882]  - Number of values expected: 3
[09:28:25.882] Reducing values from 2 chunks ... DONE
[09:28:25.882] future_lapply() ... DONE
[09:28:25.883] future_lapply() ...
[09:28:25.887] Number of chunks: 2
[09:28:25.888] getGlobalsAndPackagesXApply() ...
[09:28:25.888]  - future.globals: TRUE
[09:28:25.888] getGlobalsAndPackages() ...
[09:28:25.888] Searching for globals...
[09:28:25.889] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:25.889] Searching for globals ... DONE
[09:28:25.890] Resolving globals: FALSE
[09:28:25.890] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:25.890] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:25.890] - globals: [1] ‘FUN’
[09:28:25.891] - packages: [1] ‘stats’
[09:28:25.891] getGlobalsAndPackages() ... DONE
[09:28:25.891]  - globals found/used: [n=1] ‘FUN’
[09:28:25.891]  - needed namespaces: [n=1] ‘stats’
[09:28:25.891] Finding globals ... DONE
[09:28:25.891]  - use_args: TRUE
[09:28:25.891]  - Getting '...' globals ...
[09:28:25.892] resolve() on list ...
[09:28:25.892]  recursive: 0
[09:28:25.892]  length: 1
[09:28:25.892]  elements: ‘...’
[09:28:25.892]  length: 0 (resolved future 1)
[09:28:25.892] resolve() on list ... DONE
[09:28:25.892]    - '...' content: [n=1] ‘probs’
[09:28:25.893] List of 1
[09:28:25.893]  $ ...:List of 1
[09:28:25.893]   ..$ probs: num [1:3] 0.25 0.5 0.75
[09:28:25.893]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.893]  - attr(*, "where")=List of 1
[09:28:25.893]   ..$ ...:<environment: 0x556664a37920> 
[09:28:25.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.893]  - attr(*, "resolved")= logi TRUE
[09:28:25.893]  - attr(*, "total_size")= num NA
[09:28:25.896]  - Getting '...' globals ... DONE
[09:28:25.896] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:25.896] List of 2
[09:28:25.896]  $ ...future.FUN:function (x, ...)  
[09:28:25.896]  $ ...          :List of 1
[09:28:25.896]   ..$ probs: num [1:3] 0.25 0.5 0.75
[09:28:25.896]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.896]  - attr(*, "where")=List of 2
[09:28:25.896]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:25.896]   ..$ ...          :<environment: 0x556664a37920> 
[09:28:25.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.896]  - attr(*, "resolved")= logi FALSE
[09:28:25.896]  - attr(*, "total_size")= num 1328
[09:28:25.899] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:25.900] getGlobalsAndPackagesXApply() ... DONE
[09:28:25.900] Number of futures (= number of chunks): 2
[09:28:25.900] Launching 2 futures (chunks) ...
[09:28:25.900] Chunk #1 of 2 ...
[09:28:25.900]  - Finding globals in 'X' for chunk #1 ...
[09:28:25.900] getGlobalsAndPackages() ...
[09:28:25.900] Searching for globals...
[09:28:25.901] 
[09:28:25.901] Searching for globals ... DONE
[09:28:25.901] - globals: [0] <none>
[09:28:25.901] getGlobalsAndPackages() ... DONE
[09:28:25.901]    + additional globals found: [n=0] 
[09:28:25.901]    + additional namespaces needed: [n=0] 
[09:28:25.901]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:25.901]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:25.901]  - seeds: <none>
[09:28:25.901]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.902] getGlobalsAndPackages() ...
[09:28:25.902] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.902] Resolving globals: FALSE
[09:28:25.902] Tweak future expression to call with '...' arguments ...
[09:28:25.902] {
[09:28:25.902]     do.call(function(...) {
[09:28:25.902]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.902]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.902]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.902]             on.exit(options(oopts), add = TRUE)
[09:28:25.902]         }
[09:28:25.902]         {
[09:28:25.902]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.902]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.902]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.902]             })
[09:28:25.902]         }
[09:28:25.902]     }, args = future.call.arguments)
[09:28:25.902] }
[09:28:25.902] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.903] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.903] - packages: [1] ‘stats’
[09:28:25.903] getGlobalsAndPackages() ... DONE
[09:28:25.903] run() for ‘Future’ ...
[09:28:25.903] - state: ‘created’
[09:28:25.903] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:25.909] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.909] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:25.909]   - Field: ‘label’
[09:28:25.909]   - Field: ‘local’
[09:28:25.909]   - Field: ‘owner’
[09:28:25.909]   - Field: ‘envir’
[09:28:25.910]   - Field: ‘workers’
[09:28:25.910]   - Field: ‘packages’
[09:28:25.910]   - Field: ‘gc’
[09:28:25.910]   - Field: ‘job’
[09:28:25.910]   - Field: ‘conditions’
[09:28:25.910]   - Field: ‘expr’
[09:28:25.910]   - Field: ‘uuid’
[09:28:25.910]   - Field: ‘seed’
[09:28:25.910]   - Field: ‘version’
[09:28:25.911]   - Field: ‘result’
[09:28:25.911]   - Field: ‘asynchronous’
[09:28:25.911]   - Field: ‘calls’
[09:28:25.911]   - Field: ‘globals’
[09:28:25.911]   - Field: ‘stdout’
[09:28:25.911]   - Field: ‘earlySignal’
[09:28:25.911]   - Field: ‘lazy’
[09:28:25.911]   - Field: ‘state’
[09:28:25.911] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:25.911] - Launch lazy future ...
[09:28:25.912] Packages needed by the future expression (n = 1): ‘stats’
[09:28:25.912] Packages needed by future strategies (n = 0): <none>
[09:28:25.912] {
[09:28:25.912]     {
[09:28:25.912]         {
[09:28:25.912]             ...future.startTime <- base::Sys.time()
[09:28:25.912]             {
[09:28:25.912]                 {
[09:28:25.912]                   {
[09:28:25.912]                     {
[09:28:25.912]                       {
[09:28:25.912]                         base::local({
[09:28:25.912]                           has_future <- base::requireNamespace("future", 
[09:28:25.912]                             quietly = TRUE)
[09:28:25.912]                           if (has_future) {
[09:28:25.912]                             ns <- base::getNamespace("future")
[09:28:25.912]                             version <- ns[[".package"]][["version"]]
[09:28:25.912]                             if (is.null(version)) 
[09:28:25.912]                               version <- utils::packageVersion("future")
[09:28:25.912]                           }
[09:28:25.912]                           else {
[09:28:25.912]                             version <- NULL
[09:28:25.912]                           }
[09:28:25.912]                           if (!has_future || version < "1.8.0") {
[09:28:25.912]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.912]                               "", base::R.version$version.string), 
[09:28:25.912]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:25.912]                                 base::R.version$platform, 8 * 
[09:28:25.912]                                   base::.Machine$sizeof.pointer), 
[09:28:25.912]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.912]                                 "release", "version")], collapse = " "), 
[09:28:25.912]                               hostname = base::Sys.info()[["nodename"]])
[09:28:25.912]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.912]                               info)
[09:28:25.912]                             info <- base::paste(info, collapse = "; ")
[09:28:25.912]                             if (!has_future) {
[09:28:25.912]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.912]                                 info)
[09:28:25.912]                             }
[09:28:25.912]                             else {
[09:28:25.912]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.912]                                 info, version)
[09:28:25.912]                             }
[09:28:25.912]                             base::stop(msg)
[09:28:25.912]                           }
[09:28:25.912]                         })
[09:28:25.912]                       }
[09:28:25.912]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:25.912]                       base::options(mc.cores = 1L)
[09:28:25.912]                     }
[09:28:25.912]                     base::local({
[09:28:25.912]                       for (pkg in "stats") {
[09:28:25.912]                         base::loadNamespace(pkg)
[09:28:25.912]                         base::library(pkg, character.only = TRUE)
[09:28:25.912]                       }
[09:28:25.912]                     })
[09:28:25.912]                   }
[09:28:25.912]                   ...future.strategy.old <- future::plan("list")
[09:28:25.912]                   options(future.plan = NULL)
[09:28:25.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.912]                 }
[09:28:25.912]                 ...future.workdir <- getwd()
[09:28:25.912]             }
[09:28:25.912]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.912]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.912]         }
[09:28:25.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.912]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:25.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.912]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.912]             base::names(...future.oldOptions))
[09:28:25.912]     }
[09:28:25.912]     if (FALSE) {
[09:28:25.912]     }
[09:28:25.912]     else {
[09:28:25.912]         if (TRUE) {
[09:28:25.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.912]                 open = "w")
[09:28:25.912]         }
[09:28:25.912]         else {
[09:28:25.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.912]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.912]         }
[09:28:25.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.912]             base::sink(type = "output", split = FALSE)
[09:28:25.912]             base::close(...future.stdout)
[09:28:25.912]         }, add = TRUE)
[09:28:25.912]     }
[09:28:25.912]     ...future.frame <- base::sys.nframe()
[09:28:25.912]     ...future.conditions <- base::list()
[09:28:25.912]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.912]     if (FALSE) {
[09:28:25.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.912]     }
[09:28:25.912]     ...future.result <- base::tryCatch({
[09:28:25.912]         base::withCallingHandlers({
[09:28:25.912]             ...future.value <- base::withVisible(base::local({
[09:28:25.912]                 withCallingHandlers({
[09:28:25.912]                   {
[09:28:25.912]                     do.call(function(...) {
[09:28:25.912]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.912]                       if (!identical(...future.globals.maxSize.org, 
[09:28:25.912]                         ...future.globals.maxSize)) {
[09:28:25.912]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.912]                         on.exit(options(oopts), add = TRUE)
[09:28:25.912]                       }
[09:28:25.912]                       {
[09:28:25.912]                         lapply(seq_along(...future.elements_ii), 
[09:28:25.912]                           FUN = function(jj) {
[09:28:25.912]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.912]                             ...future.FUN(...future.X_jj, ...)
[09:28:25.912]                           })
[09:28:25.912]                       }
[09:28:25.912]                     }, args = future.call.arguments)
[09:28:25.912]                   }
[09:28:25.912]                 }, immediateCondition = function(cond) {
[09:28:25.912]                   save_rds <- function (object, pathname, ...) 
[09:28:25.912]                   {
[09:28:25.912]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:25.912]                     if (file_test("-f", pathname_tmp)) {
[09:28:25.912]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.912]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:25.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.912]                         fi_tmp[["mtime"]])
[09:28:25.912]                     }
[09:28:25.912]                     tryCatch({
[09:28:25.912]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:25.912]                     }, error = function(ex) {
[09:28:25.912]                       msg <- conditionMessage(ex)
[09:28:25.912]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.912]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:25.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.912]                         fi_tmp[["mtime"]], msg)
[09:28:25.912]                       ex$message <- msg
[09:28:25.912]                       stop(ex)
[09:28:25.912]                     })
[09:28:25.912]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:25.912]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:25.912]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:25.912]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.912]                       fi <- file.info(pathname)
[09:28:25.912]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:25.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.912]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:25.912]                         fi[["size"]], fi[["mtime"]])
[09:28:25.912]                       stop(msg)
[09:28:25.912]                     }
[09:28:25.912]                     invisible(pathname)
[09:28:25.912]                   }
[09:28:25.912]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:25.912]                     rootPath = tempdir()) 
[09:28:25.912]                   {
[09:28:25.912]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:25.912]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:25.912]                       tmpdir = path, fileext = ".rds")
[09:28:25.912]                     save_rds(obj, file)
[09:28:25.912]                   }
[09:28:25.912]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPXoGS/.future/immediateConditions")
[09:28:25.912]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.912]                   {
[09:28:25.912]                     inherits <- base::inherits
[09:28:25.912]                     invokeRestart <- base::invokeRestart
[09:28:25.912]                     is.null <- base::is.null
[09:28:25.912]                     muffled <- FALSE
[09:28:25.912]                     if (inherits(cond, "message")) {
[09:28:25.912]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:25.912]                       if (muffled) 
[09:28:25.912]                         invokeRestart("muffleMessage")
[09:28:25.912]                     }
[09:28:25.912]                     else if (inherits(cond, "warning")) {
[09:28:25.912]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:25.912]                       if (muffled) 
[09:28:25.912]                         invokeRestart("muffleWarning")
[09:28:25.912]                     }
[09:28:25.912]                     else if (inherits(cond, "condition")) {
[09:28:25.912]                       if (!is.null(pattern)) {
[09:28:25.912]                         computeRestarts <- base::computeRestarts
[09:28:25.912]                         grepl <- base::grepl
[09:28:25.912]                         restarts <- computeRestarts(cond)
[09:28:25.912]                         for (restart in restarts) {
[09:28:25.912]                           name <- restart$name
[09:28:25.912]                           if (is.null(name)) 
[09:28:25.912]                             next
[09:28:25.912]                           if (!grepl(pattern, name)) 
[09:28:25.912]                             next
[09:28:25.912]                           invokeRestart(restart)
[09:28:25.912]                           muffled <- TRUE
[09:28:25.912]                           break
[09:28:25.912]                         }
[09:28:25.912]                       }
[09:28:25.912]                     }
[09:28:25.912]                     invisible(muffled)
[09:28:25.912]                   }
[09:28:25.912]                   muffleCondition(cond)
[09:28:25.912]                 })
[09:28:25.912]             }))
[09:28:25.912]             future::FutureResult(value = ...future.value$value, 
[09:28:25.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.912]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.912]                     ...future.globalenv.names))
[09:28:25.912]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.912]         }, condition = base::local({
[09:28:25.912]             c <- base::c
[09:28:25.912]             inherits <- base::inherits
[09:28:25.912]             invokeRestart <- base::invokeRestart
[09:28:25.912]             length <- base::length
[09:28:25.912]             list <- base::list
[09:28:25.912]             seq.int <- base::seq.int
[09:28:25.912]             signalCondition <- base::signalCondition
[09:28:25.912]             sys.calls <- base::sys.calls
[09:28:25.912]             `[[` <- base::`[[`
[09:28:25.912]             `+` <- base::`+`
[09:28:25.912]             `<<-` <- base::`<<-`
[09:28:25.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.912]                   3L)]
[09:28:25.912]             }
[09:28:25.912]             function(cond) {
[09:28:25.912]                 is_error <- inherits(cond, "error")
[09:28:25.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.912]                   NULL)
[09:28:25.912]                 if (is_error) {
[09:28:25.912]                   sessionInformation <- function() {
[09:28:25.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.912]                       search = base::search(), system = base::Sys.info())
[09:28:25.912]                   }
[09:28:25.912]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.912]                     cond$call), session = sessionInformation(), 
[09:28:25.912]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.912]                   signalCondition(cond)
[09:28:25.912]                 }
[09:28:25.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.912]                 "immediateCondition"))) {
[09:28:25.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.912]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.912]                   if (TRUE && !signal) {
[09:28:25.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.912]                     {
[09:28:25.912]                       inherits <- base::inherits
[09:28:25.912]                       invokeRestart <- base::invokeRestart
[09:28:25.912]                       is.null <- base::is.null
[09:28:25.912]                       muffled <- FALSE
[09:28:25.912]                       if (inherits(cond, "message")) {
[09:28:25.912]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.912]                         if (muffled) 
[09:28:25.912]                           invokeRestart("muffleMessage")
[09:28:25.912]                       }
[09:28:25.912]                       else if (inherits(cond, "warning")) {
[09:28:25.912]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.912]                         if (muffled) 
[09:28:25.912]                           invokeRestart("muffleWarning")
[09:28:25.912]                       }
[09:28:25.912]                       else if (inherits(cond, "condition")) {
[09:28:25.912]                         if (!is.null(pattern)) {
[09:28:25.912]                           computeRestarts <- base::computeRestarts
[09:28:25.912]                           grepl <- base::grepl
[09:28:25.912]                           restarts <- computeRestarts(cond)
[09:28:25.912]                           for (restart in restarts) {
[09:28:25.912]                             name <- restart$name
[09:28:25.912]                             if (is.null(name)) 
[09:28:25.912]                               next
[09:28:25.912]                             if (!grepl(pattern, name)) 
[09:28:25.912]                               next
[09:28:25.912]                             invokeRestart(restart)
[09:28:25.912]                             muffled <- TRUE
[09:28:25.912]                             break
[09:28:25.912]                           }
[09:28:25.912]                         }
[09:28:25.912]                       }
[09:28:25.912]                       invisible(muffled)
[09:28:25.912]                     }
[09:28:25.912]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.912]                   }
[09:28:25.912]                 }
[09:28:25.912]                 else {
[09:28:25.912]                   if (TRUE) {
[09:28:25.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.912]                     {
[09:28:25.912]                       inherits <- base::inherits
[09:28:25.912]                       invokeRestart <- base::invokeRestart
[09:28:25.912]                       is.null <- base::is.null
[09:28:25.912]                       muffled <- FALSE
[09:28:25.912]                       if (inherits(cond, "message")) {
[09:28:25.912]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.912]                         if (muffled) 
[09:28:25.912]                           invokeRestart("muffleMessage")
[09:28:25.912]                       }
[09:28:25.912]                       else if (inherits(cond, "warning")) {
[09:28:25.912]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.912]                         if (muffled) 
[09:28:25.912]                           invokeRestart("muffleWarning")
[09:28:25.912]                       }
[09:28:25.912]                       else if (inherits(cond, "condition")) {
[09:28:25.912]                         if (!is.null(pattern)) {
[09:28:25.912]                           computeRestarts <- base::computeRestarts
[09:28:25.912]                           grepl <- base::grepl
[09:28:25.912]                           restarts <- computeRestarts(cond)
[09:28:25.912]                           for (restart in restarts) {
[09:28:25.912]                             name <- restart$name
[09:28:25.912]                             if (is.null(name)) 
[09:28:25.912]                               next
[09:28:25.912]                             if (!grepl(pattern, name)) 
[09:28:25.912]                               next
[09:28:25.912]                             invokeRestart(restart)
[09:28:25.912]                             muffled <- TRUE
[09:28:25.912]                             break
[09:28:25.912]                           }
[09:28:25.912]                         }
[09:28:25.912]                       }
[09:28:25.912]                       invisible(muffled)
[09:28:25.912]                     }
[09:28:25.912]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.912]                   }
[09:28:25.912]                 }
[09:28:25.912]             }
[09:28:25.912]         }))
[09:28:25.912]     }, error = function(ex) {
[09:28:25.912]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.912]                 ...future.rng), started = ...future.startTime, 
[09:28:25.912]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.912]             version = "1.8"), class = "FutureResult")
[09:28:25.912]     }, finally = {
[09:28:25.912]         if (!identical(...future.workdir, getwd())) 
[09:28:25.912]             setwd(...future.workdir)
[09:28:25.912]         {
[09:28:25.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.912]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.912]             }
[09:28:25.912]             base::options(...future.oldOptions)
[09:28:25.912]             if (.Platform$OS.type == "windows") {
[09:28:25.912]                 old_names <- names(...future.oldEnvVars)
[09:28:25.912]                 envs <- base::Sys.getenv()
[09:28:25.912]                 names <- names(envs)
[09:28:25.912]                 common <- intersect(names, old_names)
[09:28:25.912]                 added <- setdiff(names, old_names)
[09:28:25.912]                 removed <- setdiff(old_names, names)
[09:28:25.912]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.912]                   envs[common]]
[09:28:25.912]                 NAMES <- toupper(changed)
[09:28:25.912]                 args <- list()
[09:28:25.912]                 for (kk in seq_along(NAMES)) {
[09:28:25.912]                   name <- changed[[kk]]
[09:28:25.912]                   NAME <- NAMES[[kk]]
[09:28:25.912]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.912]                     next
[09:28:25.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.912]                 }
[09:28:25.912]                 NAMES <- toupper(added)
[09:28:25.912]                 for (kk in seq_along(NAMES)) {
[09:28:25.912]                   name <- added[[kk]]
[09:28:25.912]                   NAME <- NAMES[[kk]]
[09:28:25.912]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.912]                     next
[09:28:25.912]                   args[[name]] <- ""
[09:28:25.912]                 }
[09:28:25.912]                 NAMES <- toupper(removed)
[09:28:25.912]                 for (kk in seq_along(NAMES)) {
[09:28:25.912]                   name <- removed[[kk]]
[09:28:25.912]                   NAME <- NAMES[[kk]]
[09:28:25.912]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.912]                     next
[09:28:25.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.912]                 }
[09:28:25.912]                 if (length(args) > 0) 
[09:28:25.912]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.912]             }
[09:28:25.912]             else {
[09:28:25.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.912]             }
[09:28:25.912]             {
[09:28:25.912]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.912]                   0L) {
[09:28:25.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.912]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.912]                   base::options(opts)
[09:28:25.912]                 }
[09:28:25.912]                 {
[09:28:25.912]                   {
[09:28:25.912]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:25.912]                     NULL
[09:28:25.912]                   }
[09:28:25.912]                   options(future.plan = NULL)
[09:28:25.912]                   if (is.na(NA_character_)) 
[09:28:25.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.912]                     .init = FALSE)
[09:28:25.912]                 }
[09:28:25.912]             }
[09:28:25.912]         }
[09:28:25.912]     })
[09:28:25.912]     if (TRUE) {
[09:28:25.912]         base::sink(type = "output", split = FALSE)
[09:28:25.912]         if (TRUE) {
[09:28:25.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.912]         }
[09:28:25.912]         else {
[09:28:25.912]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.912]         }
[09:28:25.912]         base::close(...future.stdout)
[09:28:25.912]         ...future.stdout <- NULL
[09:28:25.912]     }
[09:28:25.912]     ...future.result$conditions <- ...future.conditions
[09:28:25.912]     ...future.result$finished <- base::Sys.time()
[09:28:25.912]     ...future.result
[09:28:25.912] }
[09:28:25.915] assign_globals() ...
[09:28:25.915] List of 5
[09:28:25.915]  $ ...future.FUN            :function (x, ...)  
[09:28:25.915]  $ future.call.arguments    :List of 1
[09:28:25.915]   ..$ probs: num [1:3] 0.25 0.5 0.75
[09:28:25.915]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.915]  $ ...future.elements_ii    :List of 1
[09:28:25.915]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[09:28:25.915]  $ ...future.seeds_ii       : NULL
[09:28:25.915]  $ ...future.globals.maxSize: NULL
[09:28:25.915]  - attr(*, "where")=List of 5
[09:28:25.915]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:25.915]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:25.915]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:25.915]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:25.915]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:25.915]  - attr(*, "resolved")= logi FALSE
[09:28:25.915]  - attr(*, "total_size")= num 1328
[09:28:25.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.915]  - attr(*, "already-done")= logi TRUE
[09:28:25.920] - copied ‘...future.FUN’ to environment
[09:28:25.920] - copied ‘future.call.arguments’ to environment
[09:28:25.920] - copied ‘...future.elements_ii’ to environment
[09:28:25.920] - copied ‘...future.seeds_ii’ to environment
[09:28:25.920] - copied ‘...future.globals.maxSize’ to environment
[09:28:25.920] assign_globals() ... done
[09:28:25.920] requestCore(): workers = 2
[09:28:25.922] MulticoreFuture started
[09:28:25.923] - Launch lazy future ... done
[09:28:25.923] run() for ‘MulticoreFuture’ ... done
[09:28:25.923] Created future:
[09:28:25.924] plan(): Setting new future strategy stack:
[09:28:25.924] List of future strategies:
[09:28:25.924] 1. sequential:
[09:28:25.924]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.924]    - tweaked: FALSE
[09:28:25.924]    - call: NULL
[09:28:25.925] plan(): nbrOfWorkers() = 1
[09:28:25.927] plan(): Setting new future strategy stack:
[09:28:25.927] List of future strategies:
[09:28:25.927] 1. multicore:
[09:28:25.927]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:25.927]    - tweaked: FALSE
[09:28:25.927]    - call: plan(strategy)
[09:28:25.932] plan(): nbrOfWorkers() = 2
[09:28:25.923] MulticoreFuture:
[09:28:25.923] Label: ‘future_eapply-1’
[09:28:25.923] Expression:
[09:28:25.923] {
[09:28:25.923]     do.call(function(...) {
[09:28:25.923]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.923]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.923]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.923]             on.exit(options(oopts), add = TRUE)
[09:28:25.923]         }
[09:28:25.923]         {
[09:28:25.923]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.923]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.923]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.923]             })
[09:28:25.923]         }
[09:28:25.923]     }, args = future.call.arguments)
[09:28:25.923] }
[09:28:25.923] Lazy evaluation: FALSE
[09:28:25.923] Asynchronous evaluation: TRUE
[09:28:25.923] Local evaluation: TRUE
[09:28:25.923] Environment: R_GlobalEnv
[09:28:25.923] Capture standard output: TRUE
[09:28:25.923] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.923] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.923] Packages: 1 packages (‘stats’)
[09:28:25.923] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.923] Resolved: TRUE
[09:28:25.923] Value: <not collected>
[09:28:25.923] Conditions captured: <none>
[09:28:25.923] Early signaling: FALSE
[09:28:25.923] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:25.923] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.933] Chunk #1 of 2 ... DONE
[09:28:25.933] Chunk #2 of 2 ...
[09:28:25.933]  - Finding globals in 'X' for chunk #2 ...
[09:28:25.933] getGlobalsAndPackages() ...
[09:28:25.933] Searching for globals...
[09:28:25.934] 
[09:28:25.934] Searching for globals ... DONE
[09:28:25.934] - globals: [0] <none>
[09:28:25.934] getGlobalsAndPackages() ... DONE
[09:28:25.934]    + additional globals found: [n=0] 
[09:28:25.934]    + additional namespaces needed: [n=0] 
[09:28:25.935]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:25.935]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:25.935]  - seeds: <none>
[09:28:25.935]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.935] getGlobalsAndPackages() ...
[09:28:25.935] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.935] Resolving globals: FALSE
[09:28:25.936] Tweak future expression to call with '...' arguments ...
[09:28:25.936] {
[09:28:25.936]     do.call(function(...) {
[09:28:25.936]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.936]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.936]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.936]             on.exit(options(oopts), add = TRUE)
[09:28:25.936]         }
[09:28:25.936]         {
[09:28:25.936]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.936]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.936]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.936]             })
[09:28:25.936]         }
[09:28:25.936]     }, args = future.call.arguments)
[09:28:25.936] }
[09:28:25.936] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.937] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.937] - packages: [1] ‘stats’
[09:28:25.937] getGlobalsAndPackages() ... DONE
[09:28:25.938] run() for ‘Future’ ...
[09:28:25.938] - state: ‘created’
[09:28:25.938] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:25.942] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.942] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:25.943]   - Field: ‘label’
[09:28:25.943]   - Field: ‘local’
[09:28:25.943]   - Field: ‘owner’
[09:28:25.943]   - Field: ‘envir’
[09:28:25.943]   - Field: ‘workers’
[09:28:25.943]   - Field: ‘packages’
[09:28:25.943]   - Field: ‘gc’
[09:28:25.944]   - Field: ‘job’
[09:28:25.944]   - Field: ‘conditions’
[09:28:25.944]   - Field: ‘expr’
[09:28:25.944]   - Field: ‘uuid’
[09:28:25.944]   - Field: ‘seed’
[09:28:25.944]   - Field: ‘version’
[09:28:25.944]   - Field: ‘result’
[09:28:25.944]   - Field: ‘asynchronous’
[09:28:25.945]   - Field: ‘calls’
[09:28:25.945]   - Field: ‘globals’
[09:28:25.945]   - Field: ‘stdout’
[09:28:25.945]   - Field: ‘earlySignal’
[09:28:25.945]   - Field: ‘lazy’
[09:28:25.945]   - Field: ‘state’
[09:28:25.945] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:25.946] - Launch lazy future ...
[09:28:25.946] Packages needed by the future expression (n = 1): ‘stats’
[09:28:25.946] Packages needed by future strategies (n = 0): <none>
[09:28:25.947] {
[09:28:25.947]     {
[09:28:25.947]         {
[09:28:25.947]             ...future.startTime <- base::Sys.time()
[09:28:25.947]             {
[09:28:25.947]                 {
[09:28:25.947]                   {
[09:28:25.947]                     {
[09:28:25.947]                       {
[09:28:25.947]                         base::local({
[09:28:25.947]                           has_future <- base::requireNamespace("future", 
[09:28:25.947]                             quietly = TRUE)
[09:28:25.947]                           if (has_future) {
[09:28:25.947]                             ns <- base::getNamespace("future")
[09:28:25.947]                             version <- ns[[".package"]][["version"]]
[09:28:25.947]                             if (is.null(version)) 
[09:28:25.947]                               version <- utils::packageVersion("future")
[09:28:25.947]                           }
[09:28:25.947]                           else {
[09:28:25.947]                             version <- NULL
[09:28:25.947]                           }
[09:28:25.947]                           if (!has_future || version < "1.8.0") {
[09:28:25.947]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.947]                               "", base::R.version$version.string), 
[09:28:25.947]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:25.947]                                 base::R.version$platform, 8 * 
[09:28:25.947]                                   base::.Machine$sizeof.pointer), 
[09:28:25.947]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.947]                                 "release", "version")], collapse = " "), 
[09:28:25.947]                               hostname = base::Sys.info()[["nodename"]])
[09:28:25.947]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.947]                               info)
[09:28:25.947]                             info <- base::paste(info, collapse = "; ")
[09:28:25.947]                             if (!has_future) {
[09:28:25.947]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.947]                                 info)
[09:28:25.947]                             }
[09:28:25.947]                             else {
[09:28:25.947]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.947]                                 info, version)
[09:28:25.947]                             }
[09:28:25.947]                             base::stop(msg)
[09:28:25.947]                           }
[09:28:25.947]                         })
[09:28:25.947]                       }
[09:28:25.947]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:25.947]                       base::options(mc.cores = 1L)
[09:28:25.947]                     }
[09:28:25.947]                     base::local({
[09:28:25.947]                       for (pkg in "stats") {
[09:28:25.947]                         base::loadNamespace(pkg)
[09:28:25.947]                         base::library(pkg, character.only = TRUE)
[09:28:25.947]                       }
[09:28:25.947]                     })
[09:28:25.947]                   }
[09:28:25.947]                   ...future.strategy.old <- future::plan("list")
[09:28:25.947]                   options(future.plan = NULL)
[09:28:25.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.947]                 }
[09:28:25.947]                 ...future.workdir <- getwd()
[09:28:25.947]             }
[09:28:25.947]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.947]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.947]         }
[09:28:25.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.947]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:25.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.947]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.947]             base::names(...future.oldOptions))
[09:28:25.947]     }
[09:28:25.947]     if (FALSE) {
[09:28:25.947]     }
[09:28:25.947]     else {
[09:28:25.947]         if (TRUE) {
[09:28:25.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.947]                 open = "w")
[09:28:25.947]         }
[09:28:25.947]         else {
[09:28:25.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.947]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.947]         }
[09:28:25.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.947]             base::sink(type = "output", split = FALSE)
[09:28:25.947]             base::close(...future.stdout)
[09:28:25.947]         }, add = TRUE)
[09:28:25.947]     }
[09:28:25.947]     ...future.frame <- base::sys.nframe()
[09:28:25.947]     ...future.conditions <- base::list()
[09:28:25.947]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.947]     if (FALSE) {
[09:28:25.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.947]     }
[09:28:25.947]     ...future.result <- base::tryCatch({
[09:28:25.947]         base::withCallingHandlers({
[09:28:25.947]             ...future.value <- base::withVisible(base::local({
[09:28:25.947]                 withCallingHandlers({
[09:28:25.947]                   {
[09:28:25.947]                     do.call(function(...) {
[09:28:25.947]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.947]                       if (!identical(...future.globals.maxSize.org, 
[09:28:25.947]                         ...future.globals.maxSize)) {
[09:28:25.947]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.947]                         on.exit(options(oopts), add = TRUE)
[09:28:25.947]                       }
[09:28:25.947]                       {
[09:28:25.947]                         lapply(seq_along(...future.elements_ii), 
[09:28:25.947]                           FUN = function(jj) {
[09:28:25.947]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.947]                             ...future.FUN(...future.X_jj, ...)
[09:28:25.947]                           })
[09:28:25.947]                       }
[09:28:25.947]                     }, args = future.call.arguments)
[09:28:25.947]                   }
[09:28:25.947]                 }, immediateCondition = function(cond) {
[09:28:25.947]                   save_rds <- function (object, pathname, ...) 
[09:28:25.947]                   {
[09:28:25.947]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:25.947]                     if (file_test("-f", pathname_tmp)) {
[09:28:25.947]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.947]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:25.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.947]                         fi_tmp[["mtime"]])
[09:28:25.947]                     }
[09:28:25.947]                     tryCatch({
[09:28:25.947]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:25.947]                     }, error = function(ex) {
[09:28:25.947]                       msg <- conditionMessage(ex)
[09:28:25.947]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.947]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:25.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.947]                         fi_tmp[["mtime"]], msg)
[09:28:25.947]                       ex$message <- msg
[09:28:25.947]                       stop(ex)
[09:28:25.947]                     })
[09:28:25.947]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:25.947]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:25.947]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:25.947]                       fi_tmp <- file.info(pathname_tmp)
[09:28:25.947]                       fi <- file.info(pathname)
[09:28:25.947]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:25.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:25.947]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:25.947]                         fi[["size"]], fi[["mtime"]])
[09:28:25.947]                       stop(msg)
[09:28:25.947]                     }
[09:28:25.947]                     invisible(pathname)
[09:28:25.947]                   }
[09:28:25.947]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:25.947]                     rootPath = tempdir()) 
[09:28:25.947]                   {
[09:28:25.947]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:25.947]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:25.947]                       tmpdir = path, fileext = ".rds")
[09:28:25.947]                     save_rds(obj, file)
[09:28:25.947]                   }
[09:28:25.947]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPXoGS/.future/immediateConditions")
[09:28:25.947]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.947]                   {
[09:28:25.947]                     inherits <- base::inherits
[09:28:25.947]                     invokeRestart <- base::invokeRestart
[09:28:25.947]                     is.null <- base::is.null
[09:28:25.947]                     muffled <- FALSE
[09:28:25.947]                     if (inherits(cond, "message")) {
[09:28:25.947]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:25.947]                       if (muffled) 
[09:28:25.947]                         invokeRestart("muffleMessage")
[09:28:25.947]                     }
[09:28:25.947]                     else if (inherits(cond, "warning")) {
[09:28:25.947]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:25.947]                       if (muffled) 
[09:28:25.947]                         invokeRestart("muffleWarning")
[09:28:25.947]                     }
[09:28:25.947]                     else if (inherits(cond, "condition")) {
[09:28:25.947]                       if (!is.null(pattern)) {
[09:28:25.947]                         computeRestarts <- base::computeRestarts
[09:28:25.947]                         grepl <- base::grepl
[09:28:25.947]                         restarts <- computeRestarts(cond)
[09:28:25.947]                         for (restart in restarts) {
[09:28:25.947]                           name <- restart$name
[09:28:25.947]                           if (is.null(name)) 
[09:28:25.947]                             next
[09:28:25.947]                           if (!grepl(pattern, name)) 
[09:28:25.947]                             next
[09:28:25.947]                           invokeRestart(restart)
[09:28:25.947]                           muffled <- TRUE
[09:28:25.947]                           break
[09:28:25.947]                         }
[09:28:25.947]                       }
[09:28:25.947]                     }
[09:28:25.947]                     invisible(muffled)
[09:28:25.947]                   }
[09:28:25.947]                   muffleCondition(cond)
[09:28:25.947]                 })
[09:28:25.947]             }))
[09:28:25.947]             future::FutureResult(value = ...future.value$value, 
[09:28:25.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.947]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.947]                     ...future.globalenv.names))
[09:28:25.947]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.947]         }, condition = base::local({
[09:28:25.947]             c <- base::c
[09:28:25.947]             inherits <- base::inherits
[09:28:25.947]             invokeRestart <- base::invokeRestart
[09:28:25.947]             length <- base::length
[09:28:25.947]             list <- base::list
[09:28:25.947]             seq.int <- base::seq.int
[09:28:25.947]             signalCondition <- base::signalCondition
[09:28:25.947]             sys.calls <- base::sys.calls
[09:28:25.947]             `[[` <- base::`[[`
[09:28:25.947]             `+` <- base::`+`
[09:28:25.947]             `<<-` <- base::`<<-`
[09:28:25.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.947]                   3L)]
[09:28:25.947]             }
[09:28:25.947]             function(cond) {
[09:28:25.947]                 is_error <- inherits(cond, "error")
[09:28:25.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.947]                   NULL)
[09:28:25.947]                 if (is_error) {
[09:28:25.947]                   sessionInformation <- function() {
[09:28:25.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.947]                       search = base::search(), system = base::Sys.info())
[09:28:25.947]                   }
[09:28:25.947]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.947]                     cond$call), session = sessionInformation(), 
[09:28:25.947]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.947]                   signalCondition(cond)
[09:28:25.947]                 }
[09:28:25.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.947]                 "immediateCondition"))) {
[09:28:25.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.947]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.947]                   if (TRUE && !signal) {
[09:28:25.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.947]                     {
[09:28:25.947]                       inherits <- base::inherits
[09:28:25.947]                       invokeRestart <- base::invokeRestart
[09:28:25.947]                       is.null <- base::is.null
[09:28:25.947]                       muffled <- FALSE
[09:28:25.947]                       if (inherits(cond, "message")) {
[09:28:25.947]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.947]                         if (muffled) 
[09:28:25.947]                           invokeRestart("muffleMessage")
[09:28:25.947]                       }
[09:28:25.947]                       else if (inherits(cond, "warning")) {
[09:28:25.947]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.947]                         if (muffled) 
[09:28:25.947]                           invokeRestart("muffleWarning")
[09:28:25.947]                       }
[09:28:25.947]                       else if (inherits(cond, "condition")) {
[09:28:25.947]                         if (!is.null(pattern)) {
[09:28:25.947]                           computeRestarts <- base::computeRestarts
[09:28:25.947]                           grepl <- base::grepl
[09:28:25.947]                           restarts <- computeRestarts(cond)
[09:28:25.947]                           for (restart in restarts) {
[09:28:25.947]                             name <- restart$name
[09:28:25.947]                             if (is.null(name)) 
[09:28:25.947]                               next
[09:28:25.947]                             if (!grepl(pattern, name)) 
[09:28:25.947]                               next
[09:28:25.947]                             invokeRestart(restart)
[09:28:25.947]                             muffled <- TRUE
[09:28:25.947]                             break
[09:28:25.947]                           }
[09:28:25.947]                         }
[09:28:25.947]                       }
[09:28:25.947]                       invisible(muffled)
[09:28:25.947]                     }
[09:28:25.947]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.947]                   }
[09:28:25.947]                 }
[09:28:25.947]                 else {
[09:28:25.947]                   if (TRUE) {
[09:28:25.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.947]                     {
[09:28:25.947]                       inherits <- base::inherits
[09:28:25.947]                       invokeRestart <- base::invokeRestart
[09:28:25.947]                       is.null <- base::is.null
[09:28:25.947]                       muffled <- FALSE
[09:28:25.947]                       if (inherits(cond, "message")) {
[09:28:25.947]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.947]                         if (muffled) 
[09:28:25.947]                           invokeRestart("muffleMessage")
[09:28:25.947]                       }
[09:28:25.947]                       else if (inherits(cond, "warning")) {
[09:28:25.947]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.947]                         if (muffled) 
[09:28:25.947]                           invokeRestart("muffleWarning")
[09:28:25.947]                       }
[09:28:25.947]                       else if (inherits(cond, "condition")) {
[09:28:25.947]                         if (!is.null(pattern)) {
[09:28:25.947]                           computeRestarts <- base::computeRestarts
[09:28:25.947]                           grepl <- base::grepl
[09:28:25.947]                           restarts <- computeRestarts(cond)
[09:28:25.947]                           for (restart in restarts) {
[09:28:25.947]                             name <- restart$name
[09:28:25.947]                             if (is.null(name)) 
[09:28:25.947]                               next
[09:28:25.947]                             if (!grepl(pattern, name)) 
[09:28:25.947]                               next
[09:28:25.947]                             invokeRestart(restart)
[09:28:25.947]                             muffled <- TRUE
[09:28:25.947]                             break
[09:28:25.947]                           }
[09:28:25.947]                         }
[09:28:25.947]                       }
[09:28:25.947]                       invisible(muffled)
[09:28:25.947]                     }
[09:28:25.947]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.947]                   }
[09:28:25.947]                 }
[09:28:25.947]             }
[09:28:25.947]         }))
[09:28:25.947]     }, error = function(ex) {
[09:28:25.947]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.947]                 ...future.rng), started = ...future.startTime, 
[09:28:25.947]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.947]             version = "1.8"), class = "FutureResult")
[09:28:25.947]     }, finally = {
[09:28:25.947]         if (!identical(...future.workdir, getwd())) 
[09:28:25.947]             setwd(...future.workdir)
[09:28:25.947]         {
[09:28:25.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.947]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.947]             }
[09:28:25.947]             base::options(...future.oldOptions)
[09:28:25.947]             if (.Platform$OS.type == "windows") {
[09:28:25.947]                 old_names <- names(...future.oldEnvVars)
[09:28:25.947]                 envs <- base::Sys.getenv()
[09:28:25.947]                 names <- names(envs)
[09:28:25.947]                 common <- intersect(names, old_names)
[09:28:25.947]                 added <- setdiff(names, old_names)
[09:28:25.947]                 removed <- setdiff(old_names, names)
[09:28:25.947]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.947]                   envs[common]]
[09:28:25.947]                 NAMES <- toupper(changed)
[09:28:25.947]                 args <- list()
[09:28:25.947]                 for (kk in seq_along(NAMES)) {
[09:28:25.947]                   name <- changed[[kk]]
[09:28:25.947]                   NAME <- NAMES[[kk]]
[09:28:25.947]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.947]                     next
[09:28:25.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.947]                 }
[09:28:25.947]                 NAMES <- toupper(added)
[09:28:25.947]                 for (kk in seq_along(NAMES)) {
[09:28:25.947]                   name <- added[[kk]]
[09:28:25.947]                   NAME <- NAMES[[kk]]
[09:28:25.947]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.947]                     next
[09:28:25.947]                   args[[name]] <- ""
[09:28:25.947]                 }
[09:28:25.947]                 NAMES <- toupper(removed)
[09:28:25.947]                 for (kk in seq_along(NAMES)) {
[09:28:25.947]                   name <- removed[[kk]]
[09:28:25.947]                   NAME <- NAMES[[kk]]
[09:28:25.947]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.947]                     next
[09:28:25.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.947]                 }
[09:28:25.947]                 if (length(args) > 0) 
[09:28:25.947]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.947]             }
[09:28:25.947]             else {
[09:28:25.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.947]             }
[09:28:25.947]             {
[09:28:25.947]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.947]                   0L) {
[09:28:25.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.947]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.947]                   base::options(opts)
[09:28:25.947]                 }
[09:28:25.947]                 {
[09:28:25.947]                   {
[09:28:25.947]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:25.947]                     NULL
[09:28:25.947]                   }
[09:28:25.947]                   options(future.plan = NULL)
[09:28:25.947]                   if (is.na(NA_character_)) 
[09:28:25.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.947]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.947]                     .init = FALSE)
[09:28:25.947]                 }
[09:28:25.947]             }
[09:28:25.947]         }
[09:28:25.947]     })
[09:28:25.947]     if (TRUE) {
[09:28:25.947]         base::sink(type = "output", split = FALSE)
[09:28:25.947]         if (TRUE) {
[09:28:25.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.947]         }
[09:28:25.947]         else {
[09:28:25.947]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.947]         }
[09:28:25.947]         base::close(...future.stdout)
[09:28:25.947]         ...future.stdout <- NULL
[09:28:25.947]     }
[09:28:25.947]     ...future.result$conditions <- ...future.conditions
[09:28:25.947]     ...future.result$finished <- base::Sys.time()
[09:28:25.947]     ...future.result
[09:28:25.947] }
[09:28:25.950] assign_globals() ...
[09:28:25.950] List of 5
[09:28:25.950]  $ ...future.FUN            :function (x, ...)  
[09:28:25.950]  $ future.call.arguments    :List of 1
[09:28:25.950]   ..$ probs: num [1:3] 0.25 0.5 0.75
[09:28:25.950]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.950]  $ ...future.elements_ii    :List of 2
[09:28:25.950]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[09:28:25.950]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:28:25.950]  $ ...future.seeds_ii       : NULL
[09:28:25.950]  $ ...future.globals.maxSize: NULL
[09:28:25.950]  - attr(*, "where")=List of 5
[09:28:25.950]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:25.950]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:25.950]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:25.950]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:25.950]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:25.950]  - attr(*, "resolved")= logi FALSE
[09:28:25.950]  - attr(*, "total_size")= num 1328
[09:28:25.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.950]  - attr(*, "already-done")= logi TRUE
[09:28:25.962] - copied ‘...future.FUN’ to environment
[09:28:25.962] - copied ‘future.call.arguments’ to environment
[09:28:25.962] - copied ‘...future.elements_ii’ to environment
[09:28:25.962] - copied ‘...future.seeds_ii’ to environment
[09:28:25.963] - copied ‘...future.globals.maxSize’ to environment
[09:28:25.963] assign_globals() ... done
[09:28:25.963] requestCore(): workers = 2
[09:28:25.965] MulticoreFuture started
[09:28:25.965] - Launch lazy future ... done
[09:28:25.966] run() for ‘MulticoreFuture’ ... done
[09:28:25.966] Created future:
[09:28:25.966] plan(): Setting new future strategy stack:
[09:28:25.967] List of future strategies:
[09:28:25.967] 1. sequential:
[09:28:25.967]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.967]    - tweaked: FALSE
[09:28:25.967]    - call: NULL
[09:28:25.968] plan(): nbrOfWorkers() = 1
[09:28:25.970] plan(): Setting new future strategy stack:
[09:28:25.971] List of future strategies:
[09:28:25.971] 1. multicore:
[09:28:25.971]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:25.971]    - tweaked: FALSE
[09:28:25.971]    - call: plan(strategy)
[09:28:25.975] plan(): nbrOfWorkers() = 2
[09:28:25.966] MulticoreFuture:
[09:28:25.966] Label: ‘future_eapply-2’
[09:28:25.966] Expression:
[09:28:25.966] {
[09:28:25.966]     do.call(function(...) {
[09:28:25.966]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.966]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.966]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.966]             on.exit(options(oopts), add = TRUE)
[09:28:25.966]         }
[09:28:25.966]         {
[09:28:25.966]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.966]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.966]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.966]             })
[09:28:25.966]         }
[09:28:25.966]     }, args = future.call.arguments)
[09:28:25.966] }
[09:28:25.966] Lazy evaluation: FALSE
[09:28:25.966] Asynchronous evaluation: TRUE
[09:28:25.966] Local evaluation: TRUE
[09:28:25.966] Environment: R_GlobalEnv
[09:28:25.966] Capture standard output: TRUE
[09:28:25.966] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.966] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.966] Packages: 1 packages (‘stats’)
[09:28:25.966] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.966] Resolved: TRUE
[09:28:25.966] Value: <not collected>
[09:28:25.966] Conditions captured: <none>
[09:28:25.966] Early signaling: FALSE
[09:28:25.966] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:25.966] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.977] Chunk #2 of 2 ... DONE
[09:28:25.977] Launching 2 futures (chunks) ... DONE
[09:28:25.977] Resolving 2 futures (chunks) ...
[09:28:25.977] resolve() on list ...
[09:28:25.977]  recursive: 0
[09:28:25.977]  length: 2
[09:28:25.977] 
[09:28:25.978] Future #1
[09:28:25.978] result() for MulticoreFuture ...
[09:28:25.979] result() for MulticoreFuture ...
[09:28:25.979] result() for MulticoreFuture ... done
[09:28:25.979] result() for MulticoreFuture ... done
[09:28:25.979] result() for MulticoreFuture ...
[09:28:25.979] result() for MulticoreFuture ... done
[09:28:25.980] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:25.980] - nx: 2
[09:28:25.980] - relay: TRUE
[09:28:25.980] - stdout: TRUE
[09:28:25.980] - signal: TRUE
[09:28:25.980] - resignal: FALSE
[09:28:25.980] - force: TRUE
[09:28:25.980] - relayed: [n=2] FALSE, FALSE
[09:28:25.981] - queued futures: [n=2] FALSE, FALSE
[09:28:25.981]  - until=1
[09:28:25.981]  - relaying element #1
[09:28:25.981] result() for MulticoreFuture ...
[09:28:25.981] result() for MulticoreFuture ... done
[09:28:25.981] result() for MulticoreFuture ...
[09:28:25.981] result() for MulticoreFuture ... done
[09:28:25.982] result() for MulticoreFuture ...
[09:28:25.982] result() for MulticoreFuture ... done
[09:28:25.982] result() for MulticoreFuture ...
[09:28:25.982] result() for MulticoreFuture ... done
[09:28:25.982] - relayed: [n=2] TRUE, FALSE
[09:28:25.982] - queued futures: [n=2] TRUE, FALSE
[09:28:25.982] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:25.983]  length: 1 (resolved future 1)
[09:28:25.983] Future #2
[09:28:25.983] result() for MulticoreFuture ...
[09:28:25.984] result() for MulticoreFuture ...
[09:28:25.984] result() for MulticoreFuture ... done
[09:28:25.984] result() for MulticoreFuture ... done
[09:28:25.984] result() for MulticoreFuture ...
[09:28:25.984] result() for MulticoreFuture ... done
[09:28:25.985] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:25.985] - nx: 2
[09:28:25.985] - relay: TRUE
[09:28:25.985] - stdout: TRUE
[09:28:25.985] - signal: TRUE
[09:28:25.985] - resignal: FALSE
[09:28:25.985] - force: TRUE
[09:28:25.985] - relayed: [n=2] TRUE, FALSE
[09:28:25.986] - queued futures: [n=2] TRUE, FALSE
[09:28:25.986]  - until=2
[09:28:25.986]  - relaying element #2
[09:28:25.986] result() for MulticoreFuture ...
[09:28:25.986] result() for MulticoreFuture ... done
[09:28:25.986] result() for MulticoreFuture ...
[09:28:25.986] result() for MulticoreFuture ... done
[09:28:25.986] result() for MulticoreFuture ...
[09:28:25.987] result() for MulticoreFuture ... done
[09:28:25.987] result() for MulticoreFuture ...
[09:28:25.987] result() for MulticoreFuture ... done
[09:28:25.987] - relayed: [n=2] TRUE, TRUE
[09:28:25.987] - queued futures: [n=2] TRUE, TRUE
[09:28:25.987] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:25.987]  length: 0 (resolved future 2)
[09:28:25.987] Relaying remaining futures
[09:28:25.987] signalConditionsASAP(NULL, pos=0) ...
[09:28:25.988] - nx: 2
[09:28:25.988] - relay: TRUE
[09:28:25.988] - stdout: TRUE
[09:28:25.988] - signal: TRUE
[09:28:25.988] - resignal: FALSE
[09:28:25.988] - force: TRUE
[09:28:25.988] - relayed: [n=2] TRUE, TRUE
[09:28:25.988] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:25.988] - relayed: [n=2] TRUE, TRUE
[09:28:25.989] - queued futures: [n=2] TRUE, TRUE
[09:28:25.989] signalConditionsASAP(NULL, pos=0) ... done
[09:28:25.989] resolve() on list ... DONE
[09:28:25.989] result() for MulticoreFuture ...
[09:28:25.989] result() for MulticoreFuture ... done
[09:28:25.989] result() for MulticoreFuture ...
[09:28:25.989] result() for MulticoreFuture ... done
[09:28:25.989] result() for MulticoreFuture ...
[09:28:25.989] result() for MulticoreFuture ... done
[09:28:25.990] result() for MulticoreFuture ...
[09:28:25.990] result() for MulticoreFuture ... done
[09:28:25.990]  - Number of value chunks collected: 2
[09:28:25.990] Resolving 2 futures (chunks) ... DONE
[09:28:25.990] Reducing values from 2 chunks ...
[09:28:25.990]  - Number of values collected after concatenation: 3
[09:28:25.990]  - Number of values expected: 3
[09:28:25.990] Reducing values from 2 chunks ... DONE
[09:28:25.990] future_lapply() ... DONE
[09:28:25.991] future_lapply() ...
[09:28:25.996] Number of chunks: 2
[09:28:25.996] getGlobalsAndPackagesXApply() ...
[09:28:25.996]  - future.globals: TRUE
[09:28:25.996] getGlobalsAndPackages() ...
[09:28:25.996] Searching for globals...
[09:28:25.997] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:25.998] Searching for globals ... DONE
[09:28:25.998] Resolving globals: FALSE
[09:28:25.998] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:25.998] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:25.999] - globals: [1] ‘FUN’
[09:28:25.999] - packages: [1] ‘stats’
[09:28:25.999] getGlobalsAndPackages() ... DONE
[09:28:25.999]  - globals found/used: [n=1] ‘FUN’
[09:28:25.999]  - needed namespaces: [n=1] ‘stats’
[09:28:25.999] Finding globals ... DONE
[09:28:25.999]  - use_args: TRUE
[09:28:26.001]  - Getting '...' globals ...
[09:28:26.002] resolve() on list ...
[09:28:26.002]  recursive: 0
[09:28:26.002]  length: 1
[09:28:26.002]  elements: ‘...’
[09:28:26.002]  length: 0 (resolved future 1)
[09:28:26.002] resolve() on list ... DONE
[09:28:26.002]    - '...' content: [n=0] 
[09:28:26.002] List of 1
[09:28:26.002]  $ ...: list()
[09:28:26.002]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:26.002]  - attr(*, "where")=List of 1
[09:28:26.002]   ..$ ...:<environment: 0x55666635c308> 
[09:28:26.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:26.002]  - attr(*, "resolved")= logi TRUE
[09:28:26.002]  - attr(*, "total_size")= num NA
[09:28:26.006]  - Getting '...' globals ... DONE
[09:28:26.006] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:26.006] List of 2
[09:28:26.006]  $ ...future.FUN:function (x, ...)  
[09:28:26.006]  $ ...          : list()
[09:28:26.006]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:26.006]  - attr(*, "where")=List of 2
[09:28:26.006]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:26.006]   ..$ ...          :<environment: 0x55666635c308> 
[09:28:26.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:26.006]  - attr(*, "resolved")= logi FALSE
[09:28:26.006]  - attr(*, "total_size")= num 1248
[09:28:26.009] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:26.009] getGlobalsAndPackagesXApply() ... DONE
[09:28:26.009] Number of futures (= number of chunks): 2
[09:28:26.009] Launching 2 futures (chunks) ...
[09:28:26.010] Chunk #1 of 2 ...
[09:28:26.010]  - Finding globals in 'X' for chunk #1 ...
[09:28:26.010] getGlobalsAndPackages() ...
[09:28:26.010] Searching for globals...
[09:28:26.010] 
[09:28:26.010] Searching for globals ... DONE
[09:28:26.010] - globals: [0] <none>
[09:28:26.010] getGlobalsAndPackages() ... DONE
[09:28:26.010]    + additional globals found: [n=0] 
[09:28:26.011]    + additional namespaces needed: [n=0] 
[09:28:26.011]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:26.011]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:26.011]  - seeds: <none>
[09:28:26.011]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.011] getGlobalsAndPackages() ...
[09:28:26.011] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.011] Resolving globals: FALSE
[09:28:26.011] Tweak future expression to call with '...' arguments ...
[09:28:26.011] {
[09:28:26.011]     do.call(function(...) {
[09:28:26.011]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.011]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.011]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.011]             on.exit(options(oopts), add = TRUE)
[09:28:26.011]         }
[09:28:26.011]         {
[09:28:26.011]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.011]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.011]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.011]             })
[09:28:26.011]         }
[09:28:26.011]     }, args = future.call.arguments)
[09:28:26.011] }
[09:28:26.012] Tweak future expression to call with '...' arguments ... DONE
[09:28:26.012] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.012] - packages: [1] ‘stats’
[09:28:26.012] getGlobalsAndPackages() ... DONE
[09:28:26.013] run() for ‘Future’ ...
[09:28:26.013] - state: ‘created’
[09:28:26.013] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:26.016] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:26.017]   - Field: ‘label’
[09:28:26.017]   - Field: ‘local’
[09:28:26.017]   - Field: ‘owner’
[09:28:26.017]   - Field: ‘envir’
[09:28:26.017]   - Field: ‘workers’
[09:28:26.017]   - Field: ‘packages’
[09:28:26.017]   - Field: ‘gc’
[09:28:26.017]   - Field: ‘job’
[09:28:26.017]   - Field: ‘conditions’
[09:28:26.017]   - Field: ‘expr’
[09:28:26.018]   - Field: ‘uuid’
[09:28:26.018]   - Field: ‘seed’
[09:28:26.018]   - Field: ‘version’
[09:28:26.018]   - Field: ‘result’
[09:28:26.018]   - Field: ‘asynchronous’
[09:28:26.018]   - Field: ‘calls’
[09:28:26.018]   - Field: ‘globals’
[09:28:26.018]   - Field: ‘stdout’
[09:28:26.018]   - Field: ‘earlySignal’
[09:28:26.018]   - Field: ‘lazy’
[09:28:26.018]   - Field: ‘state’
[09:28:26.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:26.019] - Launch lazy future ...
[09:28:26.019] Packages needed by the future expression (n = 1): ‘stats’
[09:28:26.019] Packages needed by future strategies (n = 0): <none>
[09:28:26.019] {
[09:28:26.019]     {
[09:28:26.019]         {
[09:28:26.019]             ...future.startTime <- base::Sys.time()
[09:28:26.019]             {
[09:28:26.019]                 {
[09:28:26.019]                   {
[09:28:26.019]                     {
[09:28:26.019]                       {
[09:28:26.019]                         base::local({
[09:28:26.019]                           has_future <- base::requireNamespace("future", 
[09:28:26.019]                             quietly = TRUE)
[09:28:26.019]                           if (has_future) {
[09:28:26.019]                             ns <- base::getNamespace("future")
[09:28:26.019]                             version <- ns[[".package"]][["version"]]
[09:28:26.019]                             if (is.null(version)) 
[09:28:26.019]                               version <- utils::packageVersion("future")
[09:28:26.019]                           }
[09:28:26.019]                           else {
[09:28:26.019]                             version <- NULL
[09:28:26.019]                           }
[09:28:26.019]                           if (!has_future || version < "1.8.0") {
[09:28:26.019]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:26.019]                               "", base::R.version$version.string), 
[09:28:26.019]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:26.019]                                 base::R.version$platform, 8 * 
[09:28:26.019]                                   base::.Machine$sizeof.pointer), 
[09:28:26.019]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:26.019]                                 "release", "version")], collapse = " "), 
[09:28:26.019]                               hostname = base::Sys.info()[["nodename"]])
[09:28:26.019]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:26.019]                               info)
[09:28:26.019]                             info <- base::paste(info, collapse = "; ")
[09:28:26.019]                             if (!has_future) {
[09:28:26.019]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:26.019]                                 info)
[09:28:26.019]                             }
[09:28:26.019]                             else {
[09:28:26.019]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:26.019]                                 info, version)
[09:28:26.019]                             }
[09:28:26.019]                             base::stop(msg)
[09:28:26.019]                           }
[09:28:26.019]                         })
[09:28:26.019]                       }
[09:28:26.019]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:26.019]                       base::options(mc.cores = 1L)
[09:28:26.019]                     }
[09:28:26.019]                     base::local({
[09:28:26.019]                       for (pkg in "stats") {
[09:28:26.019]                         base::loadNamespace(pkg)
[09:28:26.019]                         base::library(pkg, character.only = TRUE)
[09:28:26.019]                       }
[09:28:26.019]                     })
[09:28:26.019]                   }
[09:28:26.019]                   ...future.strategy.old <- future::plan("list")
[09:28:26.019]                   options(future.plan = NULL)
[09:28:26.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:26.019]                 }
[09:28:26.019]                 ...future.workdir <- getwd()
[09:28:26.019]             }
[09:28:26.019]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:26.019]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:26.019]         }
[09:28:26.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:26.019]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:26.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:26.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:26.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:26.019]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:26.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:26.019]             base::names(...future.oldOptions))
[09:28:26.019]     }
[09:28:26.019]     if (FALSE) {
[09:28:26.019]     }
[09:28:26.019]     else {
[09:28:26.019]         if (TRUE) {
[09:28:26.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:26.019]                 open = "w")
[09:28:26.019]         }
[09:28:26.019]         else {
[09:28:26.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:26.019]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:26.019]         }
[09:28:26.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:26.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:26.019]             base::sink(type = "output", split = FALSE)
[09:28:26.019]             base::close(...future.stdout)
[09:28:26.019]         }, add = TRUE)
[09:28:26.019]     }
[09:28:26.019]     ...future.frame <- base::sys.nframe()
[09:28:26.019]     ...future.conditions <- base::list()
[09:28:26.019]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:26.019]     if (FALSE) {
[09:28:26.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:26.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:26.019]     }
[09:28:26.019]     ...future.result <- base::tryCatch({
[09:28:26.019]         base::withCallingHandlers({
[09:28:26.019]             ...future.value <- base::withVisible(base::local({
[09:28:26.019]                 withCallingHandlers({
[09:28:26.019]                   {
[09:28:26.019]                     do.call(function(...) {
[09:28:26.019]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.019]                       if (!identical(...future.globals.maxSize.org, 
[09:28:26.019]                         ...future.globals.maxSize)) {
[09:28:26.019]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.019]                         on.exit(options(oopts), add = TRUE)
[09:28:26.019]                       }
[09:28:26.019]                       {
[09:28:26.019]                         lapply(seq_along(...future.elements_ii), 
[09:28:26.019]                           FUN = function(jj) {
[09:28:26.019]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.019]                             ...future.FUN(...future.X_jj, ...)
[09:28:26.019]                           })
[09:28:26.019]                       }
[09:28:26.019]                     }, args = future.call.arguments)
[09:28:26.019]                   }
[09:28:26.019]                 }, immediateCondition = function(cond) {
[09:28:26.019]                   save_rds <- function (object, pathname, ...) 
[09:28:26.019]                   {
[09:28:26.019]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:26.019]                     if (file_test("-f", pathname_tmp)) {
[09:28:26.019]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.019]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:26.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.019]                         fi_tmp[["mtime"]])
[09:28:26.019]                     }
[09:28:26.019]                     tryCatch({
[09:28:26.019]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:26.019]                     }, error = function(ex) {
[09:28:26.019]                       msg <- conditionMessage(ex)
[09:28:26.019]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.019]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:26.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.019]                         fi_tmp[["mtime"]], msg)
[09:28:26.019]                       ex$message <- msg
[09:28:26.019]                       stop(ex)
[09:28:26.019]                     })
[09:28:26.019]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:26.019]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:26.019]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:26.019]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.019]                       fi <- file.info(pathname)
[09:28:26.019]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:26.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.019]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:26.019]                         fi[["size"]], fi[["mtime"]])
[09:28:26.019]                       stop(msg)
[09:28:26.019]                     }
[09:28:26.019]                     invisible(pathname)
[09:28:26.019]                   }
[09:28:26.019]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:26.019]                     rootPath = tempdir()) 
[09:28:26.019]                   {
[09:28:26.019]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:26.019]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:26.019]                       tmpdir = path, fileext = ".rds")
[09:28:26.019]                     save_rds(obj, file)
[09:28:26.019]                   }
[09:28:26.019]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPXoGS/.future/immediateConditions")
[09:28:26.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.019]                   {
[09:28:26.019]                     inherits <- base::inherits
[09:28:26.019]                     invokeRestart <- base::invokeRestart
[09:28:26.019]                     is.null <- base::is.null
[09:28:26.019]                     muffled <- FALSE
[09:28:26.019]                     if (inherits(cond, "message")) {
[09:28:26.019]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:26.019]                       if (muffled) 
[09:28:26.019]                         invokeRestart("muffleMessage")
[09:28:26.019]                     }
[09:28:26.019]                     else if (inherits(cond, "warning")) {
[09:28:26.019]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:26.019]                       if (muffled) 
[09:28:26.019]                         invokeRestart("muffleWarning")
[09:28:26.019]                     }
[09:28:26.019]                     else if (inherits(cond, "condition")) {
[09:28:26.019]                       if (!is.null(pattern)) {
[09:28:26.019]                         computeRestarts <- base::computeRestarts
[09:28:26.019]                         grepl <- base::grepl
[09:28:26.019]                         restarts <- computeRestarts(cond)
[09:28:26.019]                         for (restart in restarts) {
[09:28:26.019]                           name <- restart$name
[09:28:26.019]                           if (is.null(name)) 
[09:28:26.019]                             next
[09:28:26.019]                           if (!grepl(pattern, name)) 
[09:28:26.019]                             next
[09:28:26.019]                           invokeRestart(restart)
[09:28:26.019]                           muffled <- TRUE
[09:28:26.019]                           break
[09:28:26.019]                         }
[09:28:26.019]                       }
[09:28:26.019]                     }
[09:28:26.019]                     invisible(muffled)
[09:28:26.019]                   }
[09:28:26.019]                   muffleCondition(cond)
[09:28:26.019]                 })
[09:28:26.019]             }))
[09:28:26.019]             future::FutureResult(value = ...future.value$value, 
[09:28:26.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.019]                   ...future.rng), globalenv = if (FALSE) 
[09:28:26.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:26.019]                     ...future.globalenv.names))
[09:28:26.019]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:26.019]         }, condition = base::local({
[09:28:26.019]             c <- base::c
[09:28:26.019]             inherits <- base::inherits
[09:28:26.019]             invokeRestart <- base::invokeRestart
[09:28:26.019]             length <- base::length
[09:28:26.019]             list <- base::list
[09:28:26.019]             seq.int <- base::seq.int
[09:28:26.019]             signalCondition <- base::signalCondition
[09:28:26.019]             sys.calls <- base::sys.calls
[09:28:26.019]             `[[` <- base::`[[`
[09:28:26.019]             `+` <- base::`+`
[09:28:26.019]             `<<-` <- base::`<<-`
[09:28:26.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:26.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:26.019]                   3L)]
[09:28:26.019]             }
[09:28:26.019]             function(cond) {
[09:28:26.019]                 is_error <- inherits(cond, "error")
[09:28:26.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:26.019]                   NULL)
[09:28:26.019]                 if (is_error) {
[09:28:26.019]                   sessionInformation <- function() {
[09:28:26.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:26.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:26.019]                       search = base::search(), system = base::Sys.info())
[09:28:26.019]                   }
[09:28:26.019]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:26.019]                     cond$call), session = sessionInformation(), 
[09:28:26.019]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:26.019]                   signalCondition(cond)
[09:28:26.019]                 }
[09:28:26.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:26.019]                 "immediateCondition"))) {
[09:28:26.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:26.019]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:26.019]                   if (TRUE && !signal) {
[09:28:26.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.019]                     {
[09:28:26.019]                       inherits <- base::inherits
[09:28:26.019]                       invokeRestart <- base::invokeRestart
[09:28:26.019]                       is.null <- base::is.null
[09:28:26.019]                       muffled <- FALSE
[09:28:26.019]                       if (inherits(cond, "message")) {
[09:28:26.019]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.019]                         if (muffled) 
[09:28:26.019]                           invokeRestart("muffleMessage")
[09:28:26.019]                       }
[09:28:26.019]                       else if (inherits(cond, "warning")) {
[09:28:26.019]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.019]                         if (muffled) 
[09:28:26.019]                           invokeRestart("muffleWarning")
[09:28:26.019]                       }
[09:28:26.019]                       else if (inherits(cond, "condition")) {
[09:28:26.019]                         if (!is.null(pattern)) {
[09:28:26.019]                           computeRestarts <- base::computeRestarts
[09:28:26.019]                           grepl <- base::grepl
[09:28:26.019]                           restarts <- computeRestarts(cond)
[09:28:26.019]                           for (restart in restarts) {
[09:28:26.019]                             name <- restart$name
[09:28:26.019]                             if (is.null(name)) 
[09:28:26.019]                               next
[09:28:26.019]                             if (!grepl(pattern, name)) 
[09:28:26.019]                               next
[09:28:26.019]                             invokeRestart(restart)
[09:28:26.019]                             muffled <- TRUE
[09:28:26.019]                             break
[09:28:26.019]                           }
[09:28:26.019]                         }
[09:28:26.019]                       }
[09:28:26.019]                       invisible(muffled)
[09:28:26.019]                     }
[09:28:26.019]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.019]                   }
[09:28:26.019]                 }
[09:28:26.019]                 else {
[09:28:26.019]                   if (TRUE) {
[09:28:26.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.019]                     {
[09:28:26.019]                       inherits <- base::inherits
[09:28:26.019]                       invokeRestart <- base::invokeRestart
[09:28:26.019]                       is.null <- base::is.null
[09:28:26.019]                       muffled <- FALSE
[09:28:26.019]                       if (inherits(cond, "message")) {
[09:28:26.019]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.019]                         if (muffled) 
[09:28:26.019]                           invokeRestart("muffleMessage")
[09:28:26.019]                       }
[09:28:26.019]                       else if (inherits(cond, "warning")) {
[09:28:26.019]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.019]                         if (muffled) 
[09:28:26.019]                           invokeRestart("muffleWarning")
[09:28:26.019]                       }
[09:28:26.019]                       else if (inherits(cond, "condition")) {
[09:28:26.019]                         if (!is.null(pattern)) {
[09:28:26.019]                           computeRestarts <- base::computeRestarts
[09:28:26.019]                           grepl <- base::grepl
[09:28:26.019]                           restarts <- computeRestarts(cond)
[09:28:26.019]                           for (restart in restarts) {
[09:28:26.019]                             name <- restart$name
[09:28:26.019]                             if (is.null(name)) 
[09:28:26.019]                               next
[09:28:26.019]                             if (!grepl(pattern, name)) 
[09:28:26.019]                               next
[09:28:26.019]                             invokeRestart(restart)
[09:28:26.019]                             muffled <- TRUE
[09:28:26.019]                             break
[09:28:26.019]                           }
[09:28:26.019]                         }
[09:28:26.019]                       }
[09:28:26.019]                       invisible(muffled)
[09:28:26.019]                     }
[09:28:26.019]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.019]                   }
[09:28:26.019]                 }
[09:28:26.019]             }
[09:28:26.019]         }))
[09:28:26.019]     }, error = function(ex) {
[09:28:26.019]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:26.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.019]                 ...future.rng), started = ...future.startTime, 
[09:28:26.019]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:26.019]             version = "1.8"), class = "FutureResult")
[09:28:26.019]     }, finally = {
[09:28:26.019]         if (!identical(...future.workdir, getwd())) 
[09:28:26.019]             setwd(...future.workdir)
[09:28:26.019]         {
[09:28:26.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:26.019]                 ...future.oldOptions$nwarnings <- NULL
[09:28:26.019]             }
[09:28:26.019]             base::options(...future.oldOptions)
[09:28:26.019]             if (.Platform$OS.type == "windows") {
[09:28:26.019]                 old_names <- names(...future.oldEnvVars)
[09:28:26.019]                 envs <- base::Sys.getenv()
[09:28:26.019]                 names <- names(envs)
[09:28:26.019]                 common <- intersect(names, old_names)
[09:28:26.019]                 added <- setdiff(names, old_names)
[09:28:26.019]                 removed <- setdiff(old_names, names)
[09:28:26.019]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:26.019]                   envs[common]]
[09:28:26.019]                 NAMES <- toupper(changed)
[09:28:26.019]                 args <- list()
[09:28:26.019]                 for (kk in seq_along(NAMES)) {
[09:28:26.019]                   name <- changed[[kk]]
[09:28:26.019]                   NAME <- NAMES[[kk]]
[09:28:26.019]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.019]                     next
[09:28:26.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.019]                 }
[09:28:26.019]                 NAMES <- toupper(added)
[09:28:26.019]                 for (kk in seq_along(NAMES)) {
[09:28:26.019]                   name <- added[[kk]]
[09:28:26.019]                   NAME <- NAMES[[kk]]
[09:28:26.019]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.019]                     next
[09:28:26.019]                   args[[name]] <- ""
[09:28:26.019]                 }
[09:28:26.019]                 NAMES <- toupper(removed)
[09:28:26.019]                 for (kk in seq_along(NAMES)) {
[09:28:26.019]                   name <- removed[[kk]]
[09:28:26.019]                   NAME <- NAMES[[kk]]
[09:28:26.019]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.019]                     next
[09:28:26.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.019]                 }
[09:28:26.019]                 if (length(args) > 0) 
[09:28:26.019]                   base::do.call(base::Sys.setenv, args = args)
[09:28:26.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:26.019]             }
[09:28:26.019]             else {
[09:28:26.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:26.019]             }
[09:28:26.019]             {
[09:28:26.019]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:26.019]                   0L) {
[09:28:26.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:26.019]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:26.019]                   base::options(opts)
[09:28:26.019]                 }
[09:28:26.019]                 {
[09:28:26.019]                   {
[09:28:26.019]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:26.019]                     NULL
[09:28:26.019]                   }
[09:28:26.019]                   options(future.plan = NULL)
[09:28:26.019]                   if (is.na(NA_character_)) 
[09:28:26.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:26.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:26.019]                     .init = FALSE)
[09:28:26.019]                 }
[09:28:26.019]             }
[09:28:26.019]         }
[09:28:26.019]     })
[09:28:26.019]     if (TRUE) {
[09:28:26.019]         base::sink(type = "output", split = FALSE)
[09:28:26.019]         if (TRUE) {
[09:28:26.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:26.019]         }
[09:28:26.019]         else {
[09:28:26.019]             ...future.result["stdout"] <- base::list(NULL)
[09:28:26.019]         }
[09:28:26.019]         base::close(...future.stdout)
[09:28:26.019]         ...future.stdout <- NULL
[09:28:26.019]     }
[09:28:26.019]     ...future.result$conditions <- ...future.conditions
[09:28:26.019]     ...future.result$finished <- base::Sys.time()
[09:28:26.019]     ...future.result
[09:28:26.019] }
[09:28:26.022] assign_globals() ...
[09:28:26.022] List of 5
[09:28:26.022]  $ ...future.FUN            :function (x, ...)  
[09:28:26.022]  $ future.call.arguments    : list()
[09:28:26.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:26.022]  $ ...future.elements_ii    :List of 1
[09:28:26.022]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[09:28:26.022]  $ ...future.seeds_ii       : NULL
[09:28:26.022]  $ ...future.globals.maxSize: NULL
[09:28:26.022]  - attr(*, "where")=List of 5
[09:28:26.022]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:26.022]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:26.022]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:26.022]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:26.022]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:26.022]  - attr(*, "resolved")= logi FALSE
[09:28:26.022]  - attr(*, "total_size")= num 1248
[09:28:26.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:26.022]  - attr(*, "already-done")= logi TRUE
[09:28:26.026] - copied ‘...future.FUN’ to environment
[09:28:26.027] - copied ‘future.call.arguments’ to environment
[09:28:26.027] - copied ‘...future.elements_ii’ to environment
[09:28:26.027] - copied ‘...future.seeds_ii’ to environment
[09:28:26.027] - copied ‘...future.globals.maxSize’ to environment
[09:28:26.027] assign_globals() ... done
[09:28:26.027] requestCore(): workers = 2
[09:28:26.029] MulticoreFuture started
[09:28:26.029] - Launch lazy future ... done
[09:28:26.029] run() for ‘MulticoreFuture’ ... done
[09:28:26.030] Created future:
[09:28:26.030] plan(): Setting new future strategy stack:
[09:28:26.033] List of future strategies:
[09:28:26.033] 1. sequential:
[09:28:26.033]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:26.033]    - tweaked: FALSE
[09:28:26.033]    - call: NULL
[09:28:26.034] plan(): nbrOfWorkers() = 1
[09:28:26.036] plan(): Setting new future strategy stack:
[09:28:26.037] List of future strategies:
[09:28:26.037] 1. multicore:
[09:28:26.037]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:26.037]    - tweaked: FALSE
[09:28:26.037]    - call: plan(strategy)
[09:28:26.042] plan(): nbrOfWorkers() = 2
[09:28:26.033] MulticoreFuture:
[09:28:26.033] Label: ‘future_eapply-1’
[09:28:26.033] Expression:
[09:28:26.033] {
[09:28:26.033]     do.call(function(...) {
[09:28:26.033]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.033]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.033]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.033]             on.exit(options(oopts), add = TRUE)
[09:28:26.033]         }
[09:28:26.033]         {
[09:28:26.033]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.033]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.033]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.033]             })
[09:28:26.033]         }
[09:28:26.033]     }, args = future.call.arguments)
[09:28:26.033] }
[09:28:26.033] Lazy evaluation: FALSE
[09:28:26.033] Asynchronous evaluation: TRUE
[09:28:26.033] Local evaluation: TRUE
[09:28:26.033] Environment: R_GlobalEnv
[09:28:26.033] Capture standard output: TRUE
[09:28:26.033] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:26.033] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:26.033] Packages: 1 packages (‘stats’)
[09:28:26.033] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:26.033] Resolved: TRUE
[09:28:26.033] Value: <not collected>
[09:28:26.033] Conditions captured: <none>
[09:28:26.033] Early signaling: FALSE
[09:28:26.033] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:26.033] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.043] Chunk #1 of 2 ... DONE
[09:28:26.043] Chunk #2 of 2 ...
[09:28:26.043]  - Finding globals in 'X' for chunk #2 ...
[09:28:26.044] getGlobalsAndPackages() ...
[09:28:26.044] Searching for globals...
[09:28:26.044] 
[09:28:26.044] Searching for globals ... DONE
[09:28:26.045] - globals: [0] <none>
[09:28:26.045] getGlobalsAndPackages() ... DONE
[09:28:26.045]    + additional globals found: [n=0] 
[09:28:26.045]    + additional namespaces needed: [n=0] 
[09:28:26.045]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:26.045]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:26.045]  - seeds: <none>
[09:28:26.045]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.046] getGlobalsAndPackages() ...
[09:28:26.046] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.046] Resolving globals: FALSE
[09:28:26.046] Tweak future expression to call with '...' arguments ...
[09:28:26.046] {
[09:28:26.046]     do.call(function(...) {
[09:28:26.046]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.046]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.046]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.046]             on.exit(options(oopts), add = TRUE)
[09:28:26.046]         }
[09:28:26.046]         {
[09:28:26.046]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.046]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.046]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.046]             })
[09:28:26.046]         }
[09:28:26.046]     }, args = future.call.arguments)
[09:28:26.046] }
[09:28:26.047] Tweak future expression to call with '...' arguments ... DONE
[09:28:26.048] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.048] - packages: [1] ‘stats’
[09:28:26.048] getGlobalsAndPackages() ... DONE
[09:28:26.048] run() for ‘Future’ ...
[09:28:26.049] - state: ‘created’
[09:28:26.049] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:26.053] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.054] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:26.054]   - Field: ‘label’
[09:28:26.054]   - Field: ‘local’
[09:28:26.054]   - Field: ‘owner’
[09:28:26.054]   - Field: ‘envir’
[09:28:26.054]   - Field: ‘workers’
[09:28:26.054]   - Field: ‘packages’
[09:28:26.055]   - Field: ‘gc’
[09:28:26.055]   - Field: ‘job’
[09:28:26.055]   - Field: ‘conditions’
[09:28:26.055]   - Field: ‘expr’
[09:28:26.055]   - Field: ‘uuid’
[09:28:26.055]   - Field: ‘seed’
[09:28:26.055]   - Field: ‘version’
[09:28:26.056]   - Field: ‘result’
[09:28:26.056]   - Field: ‘asynchronous’
[09:28:26.056]   - Field: ‘calls’
[09:28:26.056]   - Field: ‘globals’
[09:28:26.056]   - Field: ‘stdout’
[09:28:26.056]   - Field: ‘earlySignal’
[09:28:26.056]   - Field: ‘lazy’
[09:28:26.057]   - Field: ‘state’
[09:28:26.057] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:26.057] - Launch lazy future ...
[09:28:26.057] Packages needed by the future expression (n = 1): ‘stats’
[09:28:26.057] Packages needed by future strategies (n = 0): <none>
[09:28:26.058] {
[09:28:26.058]     {
[09:28:26.058]         {
[09:28:26.058]             ...future.startTime <- base::Sys.time()
[09:28:26.058]             {
[09:28:26.058]                 {
[09:28:26.058]                   {
[09:28:26.058]                     {
[09:28:26.058]                       {
[09:28:26.058]                         base::local({
[09:28:26.058]                           has_future <- base::requireNamespace("future", 
[09:28:26.058]                             quietly = TRUE)
[09:28:26.058]                           if (has_future) {
[09:28:26.058]                             ns <- base::getNamespace("future")
[09:28:26.058]                             version <- ns[[".package"]][["version"]]
[09:28:26.058]                             if (is.null(version)) 
[09:28:26.058]                               version <- utils::packageVersion("future")
[09:28:26.058]                           }
[09:28:26.058]                           else {
[09:28:26.058]                             version <- NULL
[09:28:26.058]                           }
[09:28:26.058]                           if (!has_future || version < "1.8.0") {
[09:28:26.058]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:26.058]                               "", base::R.version$version.string), 
[09:28:26.058]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:26.058]                                 base::R.version$platform, 8 * 
[09:28:26.058]                                   base::.Machine$sizeof.pointer), 
[09:28:26.058]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:26.058]                                 "release", "version")], collapse = " "), 
[09:28:26.058]                               hostname = base::Sys.info()[["nodename"]])
[09:28:26.058]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:26.058]                               info)
[09:28:26.058]                             info <- base::paste(info, collapse = "; ")
[09:28:26.058]                             if (!has_future) {
[09:28:26.058]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:26.058]                                 info)
[09:28:26.058]                             }
[09:28:26.058]                             else {
[09:28:26.058]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:26.058]                                 info, version)
[09:28:26.058]                             }
[09:28:26.058]                             base::stop(msg)
[09:28:26.058]                           }
[09:28:26.058]                         })
[09:28:26.058]                       }
[09:28:26.058]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:26.058]                       base::options(mc.cores = 1L)
[09:28:26.058]                     }
[09:28:26.058]                     base::local({
[09:28:26.058]                       for (pkg in "stats") {
[09:28:26.058]                         base::loadNamespace(pkg)
[09:28:26.058]                         base::library(pkg, character.only = TRUE)
[09:28:26.058]                       }
[09:28:26.058]                     })
[09:28:26.058]                   }
[09:28:26.058]                   ...future.strategy.old <- future::plan("list")
[09:28:26.058]                   options(future.plan = NULL)
[09:28:26.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:26.058]                 }
[09:28:26.058]                 ...future.workdir <- getwd()
[09:28:26.058]             }
[09:28:26.058]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:26.058]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:26.058]         }
[09:28:26.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:26.058]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:26.058]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:26.058]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:26.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:26.058]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:26.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:26.058]             base::names(...future.oldOptions))
[09:28:26.058]     }
[09:28:26.058]     if (FALSE) {
[09:28:26.058]     }
[09:28:26.058]     else {
[09:28:26.058]         if (TRUE) {
[09:28:26.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:26.058]                 open = "w")
[09:28:26.058]         }
[09:28:26.058]         else {
[09:28:26.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:26.058]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:26.058]         }
[09:28:26.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:26.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:26.058]             base::sink(type = "output", split = FALSE)
[09:28:26.058]             base::close(...future.stdout)
[09:28:26.058]         }, add = TRUE)
[09:28:26.058]     }
[09:28:26.058]     ...future.frame <- base::sys.nframe()
[09:28:26.058]     ...future.conditions <- base::list()
[09:28:26.058]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:26.058]     if (FALSE) {
[09:28:26.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:26.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:26.058]     }
[09:28:26.058]     ...future.result <- base::tryCatch({
[09:28:26.058]         base::withCallingHandlers({
[09:28:26.058]             ...future.value <- base::withVisible(base::local({
[09:28:26.058]                 withCallingHandlers({
[09:28:26.058]                   {
[09:28:26.058]                     do.call(function(...) {
[09:28:26.058]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.058]                       if (!identical(...future.globals.maxSize.org, 
[09:28:26.058]                         ...future.globals.maxSize)) {
[09:28:26.058]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.058]                         on.exit(options(oopts), add = TRUE)
[09:28:26.058]                       }
[09:28:26.058]                       {
[09:28:26.058]                         lapply(seq_along(...future.elements_ii), 
[09:28:26.058]                           FUN = function(jj) {
[09:28:26.058]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.058]                             ...future.FUN(...future.X_jj, ...)
[09:28:26.058]                           })
[09:28:26.058]                       }
[09:28:26.058]                     }, args = future.call.arguments)
[09:28:26.058]                   }
[09:28:26.058]                 }, immediateCondition = function(cond) {
[09:28:26.058]                   save_rds <- function (object, pathname, ...) 
[09:28:26.058]                   {
[09:28:26.058]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:26.058]                     if (file_test("-f", pathname_tmp)) {
[09:28:26.058]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.058]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:26.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.058]                         fi_tmp[["mtime"]])
[09:28:26.058]                     }
[09:28:26.058]                     tryCatch({
[09:28:26.058]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:26.058]                     }, error = function(ex) {
[09:28:26.058]                       msg <- conditionMessage(ex)
[09:28:26.058]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.058]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:26.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.058]                         fi_tmp[["mtime"]], msg)
[09:28:26.058]                       ex$message <- msg
[09:28:26.058]                       stop(ex)
[09:28:26.058]                     })
[09:28:26.058]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:26.058]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:26.058]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:26.058]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.058]                       fi <- file.info(pathname)
[09:28:26.058]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:26.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.058]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:26.058]                         fi[["size"]], fi[["mtime"]])
[09:28:26.058]                       stop(msg)
[09:28:26.058]                     }
[09:28:26.058]                     invisible(pathname)
[09:28:26.058]                   }
[09:28:26.058]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:26.058]                     rootPath = tempdir()) 
[09:28:26.058]                   {
[09:28:26.058]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:26.058]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:26.058]                       tmpdir = path, fileext = ".rds")
[09:28:26.058]                     save_rds(obj, file)
[09:28:26.058]                   }
[09:28:26.058]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPXoGS/.future/immediateConditions")
[09:28:26.058]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.058]                   {
[09:28:26.058]                     inherits <- base::inherits
[09:28:26.058]                     invokeRestart <- base::invokeRestart
[09:28:26.058]                     is.null <- base::is.null
[09:28:26.058]                     muffled <- FALSE
[09:28:26.058]                     if (inherits(cond, "message")) {
[09:28:26.058]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:26.058]                       if (muffled) 
[09:28:26.058]                         invokeRestart("muffleMessage")
[09:28:26.058]                     }
[09:28:26.058]                     else if (inherits(cond, "warning")) {
[09:28:26.058]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:26.058]                       if (muffled) 
[09:28:26.058]                         invokeRestart("muffleWarning")
[09:28:26.058]                     }
[09:28:26.058]                     else if (inherits(cond, "condition")) {
[09:28:26.058]                       if (!is.null(pattern)) {
[09:28:26.058]                         computeRestarts <- base::computeRestarts
[09:28:26.058]                         grepl <- base::grepl
[09:28:26.058]                         restarts <- computeRestarts(cond)
[09:28:26.058]                         for (restart in restarts) {
[09:28:26.058]                           name <- restart$name
[09:28:26.058]                           if (is.null(name)) 
[09:28:26.058]                             next
[09:28:26.058]                           if (!grepl(pattern, name)) 
[09:28:26.058]                             next
[09:28:26.058]                           invokeRestart(restart)
[09:28:26.058]                           muffled <- TRUE
[09:28:26.058]                           break
[09:28:26.058]                         }
[09:28:26.058]                       }
[09:28:26.058]                     }
[09:28:26.058]                     invisible(muffled)
[09:28:26.058]                   }
[09:28:26.058]                   muffleCondition(cond)
[09:28:26.058]                 })
[09:28:26.058]             }))
[09:28:26.058]             future::FutureResult(value = ...future.value$value, 
[09:28:26.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.058]                   ...future.rng), globalenv = if (FALSE) 
[09:28:26.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:26.058]                     ...future.globalenv.names))
[09:28:26.058]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:26.058]         }, condition = base::local({
[09:28:26.058]             c <- base::c
[09:28:26.058]             inherits <- base::inherits
[09:28:26.058]             invokeRestart <- base::invokeRestart
[09:28:26.058]             length <- base::length
[09:28:26.058]             list <- base::list
[09:28:26.058]             seq.int <- base::seq.int
[09:28:26.058]             signalCondition <- base::signalCondition
[09:28:26.058]             sys.calls <- base::sys.calls
[09:28:26.058]             `[[` <- base::`[[`
[09:28:26.058]             `+` <- base::`+`
[09:28:26.058]             `<<-` <- base::`<<-`
[09:28:26.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:26.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:26.058]                   3L)]
[09:28:26.058]             }
[09:28:26.058]             function(cond) {
[09:28:26.058]                 is_error <- inherits(cond, "error")
[09:28:26.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:26.058]                   NULL)
[09:28:26.058]                 if (is_error) {
[09:28:26.058]                   sessionInformation <- function() {
[09:28:26.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:26.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:26.058]                       search = base::search(), system = base::Sys.info())
[09:28:26.058]                   }
[09:28:26.058]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:26.058]                     cond$call), session = sessionInformation(), 
[09:28:26.058]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:26.058]                   signalCondition(cond)
[09:28:26.058]                 }
[09:28:26.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:26.058]                 "immediateCondition"))) {
[09:28:26.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:26.058]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:26.058]                   if (TRUE && !signal) {
[09:28:26.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.058]                     {
[09:28:26.058]                       inherits <- base::inherits
[09:28:26.058]                       invokeRestart <- base::invokeRestart
[09:28:26.058]                       is.null <- base::is.null
[09:28:26.058]                       muffled <- FALSE
[09:28:26.058]                       if (inherits(cond, "message")) {
[09:28:26.058]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.058]                         if (muffled) 
[09:28:26.058]                           invokeRestart("muffleMessage")
[09:28:26.058]                       }
[09:28:26.058]                       else if (inherits(cond, "warning")) {
[09:28:26.058]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.058]                         if (muffled) 
[09:28:26.058]                           invokeRestart("muffleWarning")
[09:28:26.058]                       }
[09:28:26.058]                       else if (inherits(cond, "condition")) {
[09:28:26.058]                         if (!is.null(pattern)) {
[09:28:26.058]                           computeRestarts <- base::computeRestarts
[09:28:26.058]                           grepl <- base::grepl
[09:28:26.058]                           restarts <- computeRestarts(cond)
[09:28:26.058]                           for (restart in restarts) {
[09:28:26.058]                             name <- restart$name
[09:28:26.058]                             if (is.null(name)) 
[09:28:26.058]                               next
[09:28:26.058]                             if (!grepl(pattern, name)) 
[09:28:26.058]                               next
[09:28:26.058]                             invokeRestart(restart)
[09:28:26.058]                             muffled <- TRUE
[09:28:26.058]                             break
[09:28:26.058]                           }
[09:28:26.058]                         }
[09:28:26.058]                       }
[09:28:26.058]                       invisible(muffled)
[09:28:26.058]                     }
[09:28:26.058]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.058]                   }
[09:28:26.058]                 }
[09:28:26.058]                 else {
[09:28:26.058]                   if (TRUE) {
[09:28:26.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.058]                     {
[09:28:26.058]                       inherits <- base::inherits
[09:28:26.058]                       invokeRestart <- base::invokeRestart
[09:28:26.058]                       is.null <- base::is.null
[09:28:26.058]                       muffled <- FALSE
[09:28:26.058]                       if (inherits(cond, "message")) {
[09:28:26.058]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.058]                         if (muffled) 
[09:28:26.058]                           invokeRestart("muffleMessage")
[09:28:26.058]                       }
[09:28:26.058]                       else if (inherits(cond, "warning")) {
[09:28:26.058]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.058]                         if (muffled) 
[09:28:26.058]                           invokeRestart("muffleWarning")
[09:28:26.058]                       }
[09:28:26.058]                       else if (inherits(cond, "condition")) {
[09:28:26.058]                         if (!is.null(pattern)) {
[09:28:26.058]                           computeRestarts <- base::computeRestarts
[09:28:26.058]                           grepl <- base::grepl
[09:28:26.058]                           restarts <- computeRestarts(cond)
[09:28:26.058]                           for (restart in restarts) {
[09:28:26.058]                             name <- restart$name
[09:28:26.058]                             if (is.null(name)) 
[09:28:26.058]                               next
[09:28:26.058]                             if (!grepl(pattern, name)) 
[09:28:26.058]                               next
[09:28:26.058]                             invokeRestart(restart)
[09:28:26.058]                             muffled <- TRUE
[09:28:26.058]                             break
[09:28:26.058]                           }
[09:28:26.058]                         }
[09:28:26.058]                       }
[09:28:26.058]                       invisible(muffled)
[09:28:26.058]                     }
[09:28:26.058]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.058]                   }
[09:28:26.058]                 }
[09:28:26.058]             }
[09:28:26.058]         }))
[09:28:26.058]     }, error = function(ex) {
[09:28:26.058]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:26.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.058]                 ...future.rng), started = ...future.startTime, 
[09:28:26.058]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:26.058]             version = "1.8"), class = "FutureResult")
[09:28:26.058]     }, finally = {
[09:28:26.058]         if (!identical(...future.workdir, getwd())) 
[09:28:26.058]             setwd(...future.workdir)
[09:28:26.058]         {
[09:28:26.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:26.058]                 ...future.oldOptions$nwarnings <- NULL
[09:28:26.058]             }
[09:28:26.058]             base::options(...future.oldOptions)
[09:28:26.058]             if (.Platform$OS.type == "windows") {
[09:28:26.058]                 old_names <- names(...future.oldEnvVars)
[09:28:26.058]                 envs <- base::Sys.getenv()
[09:28:26.058]                 names <- names(envs)
[09:28:26.058]                 common <- intersect(names, old_names)
[09:28:26.058]                 added <- setdiff(names, old_names)
[09:28:26.058]                 removed <- setdiff(old_names, names)
[09:28:26.058]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:26.058]                   envs[common]]
[09:28:26.058]                 NAMES <- toupper(changed)
[09:28:26.058]                 args <- list()
[09:28:26.058]                 for (kk in seq_along(NAMES)) {
[09:28:26.058]                   name <- changed[[kk]]
[09:28:26.058]                   NAME <- NAMES[[kk]]
[09:28:26.058]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.058]                     next
[09:28:26.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.058]                 }
[09:28:26.058]                 NAMES <- toupper(added)
[09:28:26.058]                 for (kk in seq_along(NAMES)) {
[09:28:26.058]                   name <- added[[kk]]
[09:28:26.058]                   NAME <- NAMES[[kk]]
[09:28:26.058]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.058]                     next
[09:28:26.058]                   args[[name]] <- ""
[09:28:26.058]                 }
[09:28:26.058]                 NAMES <- toupper(removed)
[09:28:26.058]                 for (kk in seq_along(NAMES)) {
[09:28:26.058]                   name <- removed[[kk]]
[09:28:26.058]                   NAME <- NAMES[[kk]]
[09:28:26.058]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.058]                     next
[09:28:26.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.058]                 }
[09:28:26.058]                 if (length(args) > 0) 
[09:28:26.058]                   base::do.call(base::Sys.setenv, args = args)
[09:28:26.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:26.058]             }
[09:28:26.058]             else {
[09:28:26.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:26.058]             }
[09:28:26.058]             {
[09:28:26.058]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:26.058]                   0L) {
[09:28:26.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:26.058]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:26.058]                   base::options(opts)
[09:28:26.058]                 }
[09:28:26.058]                 {
[09:28:26.058]                   {
[09:28:26.058]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:26.058]                     NULL
[09:28:26.058]                   }
[09:28:26.058]                   options(future.plan = NULL)
[09:28:26.058]                   if (is.na(NA_character_)) 
[09:28:26.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:26.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:26.058]                     .init = FALSE)
[09:28:26.058]                 }
[09:28:26.058]             }
[09:28:26.058]         }
[09:28:26.058]     })
[09:28:26.058]     if (TRUE) {
[09:28:26.058]         base::sink(type = "output", split = FALSE)
[09:28:26.058]         if (TRUE) {
[09:28:26.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:26.058]         }
[09:28:26.058]         else {
[09:28:26.058]             ...future.result["stdout"] <- base::list(NULL)
[09:28:26.058]         }
[09:28:26.058]         base::close(...future.stdout)
[09:28:26.058]         ...future.stdout <- NULL
[09:28:26.058]     }
[09:28:26.058]     ...future.result$conditions <- ...future.conditions
[09:28:26.058]     ...future.result$finished <- base::Sys.time()
[09:28:26.058]     ...future.result
[09:28:26.058] }
[09:28:26.061] assign_globals() ...
[09:28:26.061] List of 5
[09:28:26.061]  $ ...future.FUN            :function (x, ...)  
[09:28:26.061]  $ future.call.arguments    : list()
[09:28:26.061]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:26.061]  $ ...future.elements_ii    :List of 2
[09:28:26.061]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[09:28:26.061]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:28:26.061]  $ ...future.seeds_ii       : NULL
[09:28:26.061]  $ ...future.globals.maxSize: NULL
[09:28:26.061]  - attr(*, "where")=List of 5
[09:28:26.061]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:26.061]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:26.061]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:26.061]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:26.061]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:26.061]  - attr(*, "resolved")= logi FALSE
[09:28:26.061]  - attr(*, "total_size")= num 1248
[09:28:26.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:26.061]  - attr(*, "already-done")= logi TRUE
[09:28:26.068] - copied ‘...future.FUN’ to environment
[09:28:26.068] - copied ‘future.call.arguments’ to environment
[09:28:26.068] - copied ‘...future.elements_ii’ to environment
[09:28:26.068] - copied ‘...future.seeds_ii’ to environment
[09:28:26.068] - copied ‘...future.globals.maxSize’ to environment
[09:28:26.069] assign_globals() ... done
[09:28:26.069] requestCore(): workers = 2
[09:28:26.071] MulticoreFuture started
[09:28:26.071] - Launch lazy future ... done
[09:28:26.071] run() for ‘MulticoreFuture’ ... done
[09:28:26.071] Created future:
[09:28:26.072] plan(): Setting new future strategy stack:
[09:28:26.072] List of future strategies:
[09:28:26.072] 1. sequential:
[09:28:26.072]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:26.072]    - tweaked: FALSE
[09:28:26.072]    - call: NULL
[09:28:26.073] plan(): nbrOfWorkers() = 1
[09:28:26.076] plan(): Setting new future strategy stack:
[09:28:26.076] List of future strategies:
[09:28:26.076] 1. multicore:
[09:28:26.076]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:26.076]    - tweaked: FALSE
[09:28:26.076]    - call: plan(strategy)
[09:28:26.081] plan(): nbrOfWorkers() = 2
[09:28:26.072] MulticoreFuture:
[09:28:26.072] Label: ‘future_eapply-2’
[09:28:26.072] Expression:
[09:28:26.072] {
[09:28:26.072]     do.call(function(...) {
[09:28:26.072]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.072]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.072]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.072]             on.exit(options(oopts), add = TRUE)
[09:28:26.072]         }
[09:28:26.072]         {
[09:28:26.072]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.072]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.072]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.072]             })
[09:28:26.072]         }
[09:28:26.072]     }, args = future.call.arguments)
[09:28:26.072] }
[09:28:26.072] Lazy evaluation: FALSE
[09:28:26.072] Asynchronous evaluation: TRUE
[09:28:26.072] Local evaluation: TRUE
[09:28:26.072] Environment: R_GlobalEnv
[09:28:26.072] Capture standard output: TRUE
[09:28:26.072] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:26.072] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:26.072] Packages: 1 packages (‘stats’)
[09:28:26.072] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:26.072] Resolved: TRUE
[09:28:26.072] Value: <not collected>
[09:28:26.072] Conditions captured: <none>
[09:28:26.072] Early signaling: FALSE
[09:28:26.072] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:26.072] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.082] Chunk #2 of 2 ... DONE
[09:28:26.082] Launching 2 futures (chunks) ... DONE
[09:28:26.082] Resolving 2 futures (chunks) ...
[09:28:26.082] resolve() on list ...
[09:28:26.082]  recursive: 0
[09:28:26.083]  length: 2
[09:28:26.083] 
[09:28:26.083] Future #1
[09:28:26.083] result() for MulticoreFuture ...
[09:28:26.084] result() for MulticoreFuture ...
[09:28:26.084] result() for MulticoreFuture ... done
[09:28:26.084] result() for MulticoreFuture ... done
[09:28:26.085] result() for MulticoreFuture ...
[09:28:26.085] result() for MulticoreFuture ... done
[09:28:26.085] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:26.085] - nx: 2
[09:28:26.085] - relay: TRUE
[09:28:26.085] - stdout: TRUE
[09:28:26.086] - signal: TRUE
[09:28:26.086] - resignal: FALSE
[09:28:26.086] - force: TRUE
[09:28:26.086] - relayed: [n=2] FALSE, FALSE
[09:28:26.086] - queued futures: [n=2] FALSE, FALSE
[09:28:26.086]  - until=1
[09:28:26.086]  - relaying element #1
[09:28:26.086] result() for MulticoreFuture ...
[09:28:26.087] result() for MulticoreFuture ... done
[09:28:26.087] result() for MulticoreFuture ...
[09:28:26.087] result() for MulticoreFuture ... done
[09:28:26.087] result() for MulticoreFuture ...
[09:28:26.087] result() for MulticoreFuture ... done
[09:28:26.087] result() for MulticoreFuture ...
[09:28:26.088] result() for MulticoreFuture ... done
[09:28:26.088] - relayed: [n=2] TRUE, FALSE
[09:28:26.088] - queued futures: [n=2] TRUE, FALSE
[09:28:26.088] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:26.088]  length: 1 (resolved future 1)
[09:28:26.088] Future #2
[09:28:26.089] result() for MulticoreFuture ...
[09:28:26.089] result() for MulticoreFuture ...
[09:28:26.089] result() for MulticoreFuture ... done
[09:28:26.089] result() for MulticoreFuture ... done
[09:28:26.090] result() for MulticoreFuture ...
[09:28:26.090] result() for MulticoreFuture ... done
[09:28:26.092] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:26.092] - nx: 2
[09:28:26.093] - relay: TRUE
[09:28:26.093] - stdout: TRUE
[09:28:26.093] - signal: TRUE
[09:28:26.093] - resignal: FALSE
[09:28:26.093] - force: TRUE
[09:28:26.093] - relayed: [n=2] TRUE, FALSE
[09:28:26.093] - queued futures: [n=2] TRUE, FALSE
[09:28:26.093]  - until=2
[09:28:26.093]  - relaying element #2
[09:28:26.094] result() for MulticoreFuture ...
[09:28:26.094] result() for MulticoreFuture ... done
[09:28:26.094] result() for MulticoreFuture ...
[09:28:26.094] result() for MulticoreFuture ... done
[09:28:26.094] result() for MulticoreFuture ...
[09:28:26.094] result() for MulticoreFuture ... done
[09:28:26.094] result() for MulticoreFuture ...
[09:28:26.094] result() for MulticoreFuture ... done
[09:28:26.095] - relayed: [n=2] TRUE, TRUE
[09:28:26.095] - queued futures: [n=2] TRUE, TRUE
[09:28:26.095] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:26.095]  length: 0 (resolved future 2)
[09:28:26.095] Relaying remaining futures
[09:28:26.095] signalConditionsASAP(NULL, pos=0) ...
[09:28:26.095] - nx: 2
[09:28:26.095] - relay: TRUE
[09:28:26.096] - stdout: TRUE
[09:28:26.096] - signal: TRUE
[09:28:26.096] - resignal: FALSE
[09:28:26.096] - force: TRUE
[09:28:26.096] - relayed: [n=2] TRUE, TRUE
[09:28:26.096] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:26.096] - relayed: [n=2] TRUE, TRUE
[09:28:26.096] - queued futures: [n=2] TRUE, TRUE
[09:28:26.097] signalConditionsASAP(NULL, pos=0) ... done
[09:28:26.097] resolve() on list ... DONE
[09:28:26.097] result() for MulticoreFuture ...
[09:28:26.097] result() for MulticoreFuture ... done
[09:28:26.097] result() for MulticoreFuture ...
[09:28:26.097] result() for MulticoreFuture ... done
[09:28:26.097] result() for MulticoreFuture ...
[09:28:26.097] result() for MulticoreFuture ... done
[09:28:26.098] result() for MulticoreFuture ...
[09:28:26.098] result() for MulticoreFuture ... done
[09:28:26.098]  - Number of value chunks collected: 2
[09:28:26.098] Resolving 2 futures (chunks) ... DONE
[09:28:26.098] Reducing values from 2 chunks ...
[09:28:26.098]  - Number of values collected after concatenation: 3
[09:28:26.098]  - Number of values expected: 3
[09:28:26.098] Reducing values from 2 chunks ... DONE
[09:28:26.099] future_lapply() ... DONE
[09:28:26.099] future_lapply() ...
[09:28:26.103] Number of chunks: 2
[09:28:26.103] getGlobalsAndPackagesXApply() ...
[09:28:26.103]  - future.globals: TRUE
[09:28:26.104] getGlobalsAndPackages() ...
[09:28:26.104] Searching for globals...
[09:28:26.105] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:26.105] Searching for globals ... DONE
[09:28:26.105] Resolving globals: FALSE
[09:28:26.106] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:26.106] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:26.106] - globals: [1] ‘FUN’
[09:28:26.106] - packages: [1] ‘stats’
[09:28:26.106] getGlobalsAndPackages() ... DONE
[09:28:26.107]  - globals found/used: [n=1] ‘FUN’
[09:28:26.107]  - needed namespaces: [n=1] ‘stats’
[09:28:26.107] Finding globals ... DONE
[09:28:26.107]  - use_args: TRUE
[09:28:26.107]  - Getting '...' globals ...
[09:28:26.107] resolve() on list ...
[09:28:26.107]  recursive: 0
[09:28:26.108]  length: 1
[09:28:26.108]  elements: ‘...’
[09:28:26.108]  length: 0 (resolved future 1)
[09:28:26.108] resolve() on list ... DONE
[09:28:26.108]    - '...' content: [n=0] 
[09:28:26.108] List of 1
[09:28:26.108]  $ ...: list()
[09:28:26.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:26.108]  - attr(*, "where")=List of 1
[09:28:26.108]   ..$ ...:<environment: 0x556663d9f6f8> 
[09:28:26.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:26.108]  - attr(*, "resolved")= logi TRUE
[09:28:26.108]  - attr(*, "total_size")= num NA
[09:28:26.111]  - Getting '...' globals ... DONE
[09:28:26.111] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:26.111] List of 2
[09:28:26.111]  $ ...future.FUN:function (x, ...)  
[09:28:26.111]  $ ...          : list()
[09:28:26.111]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:26.111]  - attr(*, "where")=List of 2
[09:28:26.111]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:26.111]   ..$ ...          :<environment: 0x556663d9f6f8> 
[09:28:26.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:26.111]  - attr(*, "resolved")= logi FALSE
[09:28:26.111]  - attr(*, "total_size")= num 1248
[09:28:26.114] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:26.114] getGlobalsAndPackagesXApply() ... DONE
[09:28:26.115] Number of futures (= number of chunks): 2
[09:28:26.115] Launching 2 futures (chunks) ...
[09:28:26.115] Chunk #1 of 2 ...
[09:28:26.115]  - Finding globals in 'X' for chunk #1 ...
[09:28:26.115] getGlobalsAndPackages() ...
[09:28:26.115] Searching for globals...
[09:28:26.115] 
[09:28:26.115] Searching for globals ... DONE
[09:28:26.115] - globals: [0] <none>
[09:28:26.116] getGlobalsAndPackages() ... DONE
[09:28:26.116]    + additional globals found: [n=0] 
[09:28:26.116]    + additional namespaces needed: [n=0] 
[09:28:26.116]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:26.116]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:26.116]  - seeds: <none>
[09:28:26.116]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.116] getGlobalsAndPackages() ...
[09:28:26.116] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.116] Resolving globals: FALSE
[09:28:26.117] Tweak future expression to call with '...' arguments ...
[09:28:26.117] {
[09:28:26.117]     do.call(function(...) {
[09:28:26.117]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.117]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.117]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.117]             on.exit(options(oopts), add = TRUE)
[09:28:26.117]         }
[09:28:26.117]         {
[09:28:26.117]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.117]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.117]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.117]             })
[09:28:26.117]         }
[09:28:26.117]     }, args = future.call.arguments)
[09:28:26.117] }
[09:28:26.117] Tweak future expression to call with '...' arguments ... DONE
[09:28:26.117] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.117] - packages: [1] ‘stats’
[09:28:26.118] getGlobalsAndPackages() ... DONE
[09:28:26.118] run() for ‘Future’ ...
[09:28:26.118] - state: ‘created’
[09:28:26.118] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:26.123] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.123] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:26.123]   - Field: ‘label’
[09:28:26.123]   - Field: ‘local’
[09:28:26.124]   - Field: ‘owner’
[09:28:26.124]   - Field: ‘envir’
[09:28:26.124]   - Field: ‘workers’
[09:28:26.124]   - Field: ‘packages’
[09:28:26.124]   - Field: ‘gc’
[09:28:26.124]   - Field: ‘job’
[09:28:26.124]   - Field: ‘conditions’
[09:28:26.124]   - Field: ‘expr’
[09:28:26.124]   - Field: ‘uuid’
[09:28:26.124]   - Field: ‘seed’
[09:28:26.124]   - Field: ‘version’
[09:28:26.125]   - Field: ‘result’
[09:28:26.125]   - Field: ‘asynchronous’
[09:28:26.125]   - Field: ‘calls’
[09:28:26.125]   - Field: ‘globals’
[09:28:26.125]   - Field: ‘stdout’
[09:28:26.125]   - Field: ‘earlySignal’
[09:28:26.125]   - Field: ‘lazy’
[09:28:26.125]   - Field: ‘state’
[09:28:26.125] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:26.125] - Launch lazy future ...
[09:28:26.126] Packages needed by the future expression (n = 1): ‘stats’
[09:28:26.126] Packages needed by future strategies (n = 0): <none>
[09:28:26.126] {
[09:28:26.126]     {
[09:28:26.126]         {
[09:28:26.126]             ...future.startTime <- base::Sys.time()
[09:28:26.126]             {
[09:28:26.126]                 {
[09:28:26.126]                   {
[09:28:26.126]                     {
[09:28:26.126]                       {
[09:28:26.126]                         base::local({
[09:28:26.126]                           has_future <- base::requireNamespace("future", 
[09:28:26.126]                             quietly = TRUE)
[09:28:26.126]                           if (has_future) {
[09:28:26.126]                             ns <- base::getNamespace("future")
[09:28:26.126]                             version <- ns[[".package"]][["version"]]
[09:28:26.126]                             if (is.null(version)) 
[09:28:26.126]                               version <- utils::packageVersion("future")
[09:28:26.126]                           }
[09:28:26.126]                           else {
[09:28:26.126]                             version <- NULL
[09:28:26.126]                           }
[09:28:26.126]                           if (!has_future || version < "1.8.0") {
[09:28:26.126]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:26.126]                               "", base::R.version$version.string), 
[09:28:26.126]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:26.126]                                 base::R.version$platform, 8 * 
[09:28:26.126]                                   base::.Machine$sizeof.pointer), 
[09:28:26.126]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:26.126]                                 "release", "version")], collapse = " "), 
[09:28:26.126]                               hostname = base::Sys.info()[["nodename"]])
[09:28:26.126]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:26.126]                               info)
[09:28:26.126]                             info <- base::paste(info, collapse = "; ")
[09:28:26.126]                             if (!has_future) {
[09:28:26.126]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:26.126]                                 info)
[09:28:26.126]                             }
[09:28:26.126]                             else {
[09:28:26.126]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:26.126]                                 info, version)
[09:28:26.126]                             }
[09:28:26.126]                             base::stop(msg)
[09:28:26.126]                           }
[09:28:26.126]                         })
[09:28:26.126]                       }
[09:28:26.126]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:26.126]                       base::options(mc.cores = 1L)
[09:28:26.126]                     }
[09:28:26.126]                     base::local({
[09:28:26.126]                       for (pkg in "stats") {
[09:28:26.126]                         base::loadNamespace(pkg)
[09:28:26.126]                         base::library(pkg, character.only = TRUE)
[09:28:26.126]                       }
[09:28:26.126]                     })
[09:28:26.126]                   }
[09:28:26.126]                   ...future.strategy.old <- future::plan("list")
[09:28:26.126]                   options(future.plan = NULL)
[09:28:26.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:26.126]                 }
[09:28:26.126]                 ...future.workdir <- getwd()
[09:28:26.126]             }
[09:28:26.126]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:26.126]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:26.126]         }
[09:28:26.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:26.126]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:26.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:26.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:26.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:26.126]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:26.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:26.126]             base::names(...future.oldOptions))
[09:28:26.126]     }
[09:28:26.126]     if (FALSE) {
[09:28:26.126]     }
[09:28:26.126]     else {
[09:28:26.126]         if (TRUE) {
[09:28:26.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:26.126]                 open = "w")
[09:28:26.126]         }
[09:28:26.126]         else {
[09:28:26.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:26.126]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:26.126]         }
[09:28:26.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:26.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:26.126]             base::sink(type = "output", split = FALSE)
[09:28:26.126]             base::close(...future.stdout)
[09:28:26.126]         }, add = TRUE)
[09:28:26.126]     }
[09:28:26.126]     ...future.frame <- base::sys.nframe()
[09:28:26.126]     ...future.conditions <- base::list()
[09:28:26.126]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:26.126]     if (FALSE) {
[09:28:26.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:26.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:26.126]     }
[09:28:26.126]     ...future.result <- base::tryCatch({
[09:28:26.126]         base::withCallingHandlers({
[09:28:26.126]             ...future.value <- base::withVisible(base::local({
[09:28:26.126]                 withCallingHandlers({
[09:28:26.126]                   {
[09:28:26.126]                     do.call(function(...) {
[09:28:26.126]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.126]                       if (!identical(...future.globals.maxSize.org, 
[09:28:26.126]                         ...future.globals.maxSize)) {
[09:28:26.126]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.126]                         on.exit(options(oopts), add = TRUE)
[09:28:26.126]                       }
[09:28:26.126]                       {
[09:28:26.126]                         lapply(seq_along(...future.elements_ii), 
[09:28:26.126]                           FUN = function(jj) {
[09:28:26.126]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.126]                             ...future.FUN(...future.X_jj, ...)
[09:28:26.126]                           })
[09:28:26.126]                       }
[09:28:26.126]                     }, args = future.call.arguments)
[09:28:26.126]                   }
[09:28:26.126]                 }, immediateCondition = function(cond) {
[09:28:26.126]                   save_rds <- function (object, pathname, ...) 
[09:28:26.126]                   {
[09:28:26.126]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:26.126]                     if (file_test("-f", pathname_tmp)) {
[09:28:26.126]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.126]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:26.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.126]                         fi_tmp[["mtime"]])
[09:28:26.126]                     }
[09:28:26.126]                     tryCatch({
[09:28:26.126]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:26.126]                     }, error = function(ex) {
[09:28:26.126]                       msg <- conditionMessage(ex)
[09:28:26.126]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.126]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:26.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.126]                         fi_tmp[["mtime"]], msg)
[09:28:26.126]                       ex$message <- msg
[09:28:26.126]                       stop(ex)
[09:28:26.126]                     })
[09:28:26.126]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:26.126]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:26.126]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:26.126]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.126]                       fi <- file.info(pathname)
[09:28:26.126]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:26.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.126]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:26.126]                         fi[["size"]], fi[["mtime"]])
[09:28:26.126]                       stop(msg)
[09:28:26.126]                     }
[09:28:26.126]                     invisible(pathname)
[09:28:26.126]                   }
[09:28:26.126]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:26.126]                     rootPath = tempdir()) 
[09:28:26.126]                   {
[09:28:26.126]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:26.126]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:26.126]                       tmpdir = path, fileext = ".rds")
[09:28:26.126]                     save_rds(obj, file)
[09:28:26.126]                   }
[09:28:26.126]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPXoGS/.future/immediateConditions")
[09:28:26.126]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.126]                   {
[09:28:26.126]                     inherits <- base::inherits
[09:28:26.126]                     invokeRestart <- base::invokeRestart
[09:28:26.126]                     is.null <- base::is.null
[09:28:26.126]                     muffled <- FALSE
[09:28:26.126]                     if (inherits(cond, "message")) {
[09:28:26.126]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:26.126]                       if (muffled) 
[09:28:26.126]                         invokeRestart("muffleMessage")
[09:28:26.126]                     }
[09:28:26.126]                     else if (inherits(cond, "warning")) {
[09:28:26.126]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:26.126]                       if (muffled) 
[09:28:26.126]                         invokeRestart("muffleWarning")
[09:28:26.126]                     }
[09:28:26.126]                     else if (inherits(cond, "condition")) {
[09:28:26.126]                       if (!is.null(pattern)) {
[09:28:26.126]                         computeRestarts <- base::computeRestarts
[09:28:26.126]                         grepl <- base::grepl
[09:28:26.126]                         restarts <- computeRestarts(cond)
[09:28:26.126]                         for (restart in restarts) {
[09:28:26.126]                           name <- restart$name
[09:28:26.126]                           if (is.null(name)) 
[09:28:26.126]                             next
[09:28:26.126]                           if (!grepl(pattern, name)) 
[09:28:26.126]                             next
[09:28:26.126]                           invokeRestart(restart)
[09:28:26.126]                           muffled <- TRUE
[09:28:26.126]                           break
[09:28:26.126]                         }
[09:28:26.126]                       }
[09:28:26.126]                     }
[09:28:26.126]                     invisible(muffled)
[09:28:26.126]                   }
[09:28:26.126]                   muffleCondition(cond)
[09:28:26.126]                 })
[09:28:26.126]             }))
[09:28:26.126]             future::FutureResult(value = ...future.value$value, 
[09:28:26.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.126]                   ...future.rng), globalenv = if (FALSE) 
[09:28:26.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:26.126]                     ...future.globalenv.names))
[09:28:26.126]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:26.126]         }, condition = base::local({
[09:28:26.126]             c <- base::c
[09:28:26.126]             inherits <- base::inherits
[09:28:26.126]             invokeRestart <- base::invokeRestart
[09:28:26.126]             length <- base::length
[09:28:26.126]             list <- base::list
[09:28:26.126]             seq.int <- base::seq.int
[09:28:26.126]             signalCondition <- base::signalCondition
[09:28:26.126]             sys.calls <- base::sys.calls
[09:28:26.126]             `[[` <- base::`[[`
[09:28:26.126]             `+` <- base::`+`
[09:28:26.126]             `<<-` <- base::`<<-`
[09:28:26.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:26.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:26.126]                   3L)]
[09:28:26.126]             }
[09:28:26.126]             function(cond) {
[09:28:26.126]                 is_error <- inherits(cond, "error")
[09:28:26.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:26.126]                   NULL)
[09:28:26.126]                 if (is_error) {
[09:28:26.126]                   sessionInformation <- function() {
[09:28:26.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:26.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:26.126]                       search = base::search(), system = base::Sys.info())
[09:28:26.126]                   }
[09:28:26.126]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:26.126]                     cond$call), session = sessionInformation(), 
[09:28:26.126]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:26.126]                   signalCondition(cond)
[09:28:26.126]                 }
[09:28:26.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:26.126]                 "immediateCondition"))) {
[09:28:26.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:26.126]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:26.126]                   if (TRUE && !signal) {
[09:28:26.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.126]                     {
[09:28:26.126]                       inherits <- base::inherits
[09:28:26.126]                       invokeRestart <- base::invokeRestart
[09:28:26.126]                       is.null <- base::is.null
[09:28:26.126]                       muffled <- FALSE
[09:28:26.126]                       if (inherits(cond, "message")) {
[09:28:26.126]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.126]                         if (muffled) 
[09:28:26.126]                           invokeRestart("muffleMessage")
[09:28:26.126]                       }
[09:28:26.126]                       else if (inherits(cond, "warning")) {
[09:28:26.126]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.126]                         if (muffled) 
[09:28:26.126]                           invokeRestart("muffleWarning")
[09:28:26.126]                       }
[09:28:26.126]                       else if (inherits(cond, "condition")) {
[09:28:26.126]                         if (!is.null(pattern)) {
[09:28:26.126]                           computeRestarts <- base::computeRestarts
[09:28:26.126]                           grepl <- base::grepl
[09:28:26.126]                           restarts <- computeRestarts(cond)
[09:28:26.126]                           for (restart in restarts) {
[09:28:26.126]                             name <- restart$name
[09:28:26.126]                             if (is.null(name)) 
[09:28:26.126]                               next
[09:28:26.126]                             if (!grepl(pattern, name)) 
[09:28:26.126]                               next
[09:28:26.126]                             invokeRestart(restart)
[09:28:26.126]                             muffled <- TRUE
[09:28:26.126]                             break
[09:28:26.126]                           }
[09:28:26.126]                         }
[09:28:26.126]                       }
[09:28:26.126]                       invisible(muffled)
[09:28:26.126]                     }
[09:28:26.126]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.126]                   }
[09:28:26.126]                 }
[09:28:26.126]                 else {
[09:28:26.126]                   if (TRUE) {
[09:28:26.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.126]                     {
[09:28:26.126]                       inherits <- base::inherits
[09:28:26.126]                       invokeRestart <- base::invokeRestart
[09:28:26.126]                       is.null <- base::is.null
[09:28:26.126]                       muffled <- FALSE
[09:28:26.126]                       if (inherits(cond, "message")) {
[09:28:26.126]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.126]                         if (muffled) 
[09:28:26.126]                           invokeRestart("muffleMessage")
[09:28:26.126]                       }
[09:28:26.126]                       else if (inherits(cond, "warning")) {
[09:28:26.126]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.126]                         if (muffled) 
[09:28:26.126]                           invokeRestart("muffleWarning")
[09:28:26.126]                       }
[09:28:26.126]                       else if (inherits(cond, "condition")) {
[09:28:26.126]                         if (!is.null(pattern)) {
[09:28:26.126]                           computeRestarts <- base::computeRestarts
[09:28:26.126]                           grepl <- base::grepl
[09:28:26.126]                           restarts <- computeRestarts(cond)
[09:28:26.126]                           for (restart in restarts) {
[09:28:26.126]                             name <- restart$name
[09:28:26.126]                             if (is.null(name)) 
[09:28:26.126]                               next
[09:28:26.126]                             if (!grepl(pattern, name)) 
[09:28:26.126]                               next
[09:28:26.126]                             invokeRestart(restart)
[09:28:26.126]                             muffled <- TRUE
[09:28:26.126]                             break
[09:28:26.126]                           }
[09:28:26.126]                         }
[09:28:26.126]                       }
[09:28:26.126]                       invisible(muffled)
[09:28:26.126]                     }
[09:28:26.126]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.126]                   }
[09:28:26.126]                 }
[09:28:26.126]             }
[09:28:26.126]         }))
[09:28:26.126]     }, error = function(ex) {
[09:28:26.126]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:26.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.126]                 ...future.rng), started = ...future.startTime, 
[09:28:26.126]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:26.126]             version = "1.8"), class = "FutureResult")
[09:28:26.126]     }, finally = {
[09:28:26.126]         if (!identical(...future.workdir, getwd())) 
[09:28:26.126]             setwd(...future.workdir)
[09:28:26.126]         {
[09:28:26.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:26.126]                 ...future.oldOptions$nwarnings <- NULL
[09:28:26.126]             }
[09:28:26.126]             base::options(...future.oldOptions)
[09:28:26.126]             if (.Platform$OS.type == "windows") {
[09:28:26.126]                 old_names <- names(...future.oldEnvVars)
[09:28:26.126]                 envs <- base::Sys.getenv()
[09:28:26.126]                 names <- names(envs)
[09:28:26.126]                 common <- intersect(names, old_names)
[09:28:26.126]                 added <- setdiff(names, old_names)
[09:28:26.126]                 removed <- setdiff(old_names, names)
[09:28:26.126]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:26.126]                   envs[common]]
[09:28:26.126]                 NAMES <- toupper(changed)
[09:28:26.126]                 args <- list()
[09:28:26.126]                 for (kk in seq_along(NAMES)) {
[09:28:26.126]                   name <- changed[[kk]]
[09:28:26.126]                   NAME <- NAMES[[kk]]
[09:28:26.126]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.126]                     next
[09:28:26.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.126]                 }
[09:28:26.126]                 NAMES <- toupper(added)
[09:28:26.126]                 for (kk in seq_along(NAMES)) {
[09:28:26.126]                   name <- added[[kk]]
[09:28:26.126]                   NAME <- NAMES[[kk]]
[09:28:26.126]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.126]                     next
[09:28:26.126]                   args[[name]] <- ""
[09:28:26.126]                 }
[09:28:26.126]                 NAMES <- toupper(removed)
[09:28:26.126]                 for (kk in seq_along(NAMES)) {
[09:28:26.126]                   name <- removed[[kk]]
[09:28:26.126]                   NAME <- NAMES[[kk]]
[09:28:26.126]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.126]                     next
[09:28:26.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.126]                 }
[09:28:26.126]                 if (length(args) > 0) 
[09:28:26.126]                   base::do.call(base::Sys.setenv, args = args)
[09:28:26.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:26.126]             }
[09:28:26.126]             else {
[09:28:26.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:26.126]             }
[09:28:26.126]             {
[09:28:26.126]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:26.126]                   0L) {
[09:28:26.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:26.126]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:26.126]                   base::options(opts)
[09:28:26.126]                 }
[09:28:26.126]                 {
[09:28:26.126]                   {
[09:28:26.126]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:26.126]                     NULL
[09:28:26.126]                   }
[09:28:26.126]                   options(future.plan = NULL)
[09:28:26.126]                   if (is.na(NA_character_)) 
[09:28:26.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:26.126]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:26.126]                     .init = FALSE)
[09:28:26.126]                 }
[09:28:26.126]             }
[09:28:26.126]         }
[09:28:26.126]     })
[09:28:26.126]     if (TRUE) {
[09:28:26.126]         base::sink(type = "output", split = FALSE)
[09:28:26.126]         if (TRUE) {
[09:28:26.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:26.126]         }
[09:28:26.126]         else {
[09:28:26.126]             ...future.result["stdout"] <- base::list(NULL)
[09:28:26.126]         }
[09:28:26.126]         base::close(...future.stdout)
[09:28:26.126]         ...future.stdout <- NULL
[09:28:26.126]     }
[09:28:26.126]     ...future.result$conditions <- ...future.conditions
[09:28:26.126]     ...future.result$finished <- base::Sys.time()
[09:28:26.126]     ...future.result
[09:28:26.126] }
[09:28:26.129] assign_globals() ...
[09:28:26.129] List of 5
[09:28:26.129]  $ ...future.FUN            :function (x, ...)  
[09:28:26.129]  $ future.call.arguments    : list()
[09:28:26.129]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:26.129]  $ ...future.elements_ii    :List of 1
[09:28:26.129]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[09:28:26.129]  $ ...future.seeds_ii       : NULL
[09:28:26.129]  $ ...future.globals.maxSize: NULL
[09:28:26.129]  - attr(*, "where")=List of 5
[09:28:26.129]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:26.129]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:26.129]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:26.129]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:26.129]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:26.129]  - attr(*, "resolved")= logi FALSE
[09:28:26.129]  - attr(*, "total_size")= num 1248
[09:28:26.129]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:26.129]  - attr(*, "already-done")= logi TRUE
[09:28:26.133] - copied ‘...future.FUN’ to environment
[09:28:26.133] - copied ‘future.call.arguments’ to environment
[09:28:26.133] - copied ‘...future.elements_ii’ to environment
[09:28:26.133] - copied ‘...future.seeds_ii’ to environment
[09:28:26.133] - copied ‘...future.globals.maxSize’ to environment
[09:28:26.134] assign_globals() ... done
[09:28:26.134] requestCore(): workers = 2
[09:28:26.135] MulticoreFuture started
[09:28:26.136] - Launch lazy future ... done
[09:28:26.136] run() for ‘MulticoreFuture’ ... done
[09:28:26.136] Created future:
[09:28:26.137] plan(): Setting new future strategy stack:
[09:28:26.137] List of future strategies:
[09:28:26.137] 1. sequential:
[09:28:26.137]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:26.137]    - tweaked: FALSE
[09:28:26.137]    - call: NULL
[09:28:26.138] plan(): nbrOfWorkers() = 1
[09:28:26.140] plan(): Setting new future strategy stack:
[09:28:26.141] List of future strategies:
[09:28:26.141] 1. multicore:
[09:28:26.141]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:26.141]    - tweaked: FALSE
[09:28:26.141]    - call: plan(strategy)
[09:28:26.145] plan(): nbrOfWorkers() = 2
[09:28:26.136] MulticoreFuture:
[09:28:26.136] Label: ‘future_eapply-1’
[09:28:26.136] Expression:
[09:28:26.136] {
[09:28:26.136]     do.call(function(...) {
[09:28:26.136]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.136]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.136]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.136]             on.exit(options(oopts), add = TRUE)
[09:28:26.136]         }
[09:28:26.136]         {
[09:28:26.136]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.136]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.136]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.136]             })
[09:28:26.136]         }
[09:28:26.136]     }, args = future.call.arguments)
[09:28:26.136] }
[09:28:26.136] Lazy evaluation: FALSE
[09:28:26.136] Asynchronous evaluation: TRUE
[09:28:26.136] Local evaluation: TRUE
[09:28:26.136] Environment: R_GlobalEnv
[09:28:26.136] Capture standard output: TRUE
[09:28:26.136] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:26.136] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:26.136] Packages: 1 packages (‘stats’)
[09:28:26.136] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:26.136] Resolved: TRUE
[09:28:26.136] Value: <not collected>
[09:28:26.136] Conditions captured: <none>
[09:28:26.136] Early signaling: FALSE
[09:28:26.136] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:26.136] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.146] Chunk #1 of 2 ... DONE
[09:28:26.147] Chunk #2 of 2 ...
[09:28:26.147]  - Finding globals in 'X' for chunk #2 ...
[09:28:26.147] getGlobalsAndPackages() ...
[09:28:26.147] Searching for globals...
[09:28:26.148] 
[09:28:26.148] Searching for globals ... DONE
[09:28:26.148] - globals: [0] <none>
[09:28:26.148] getGlobalsAndPackages() ... DONE
[09:28:26.148]    + additional globals found: [n=0] 
[09:28:26.148]    + additional namespaces needed: [n=0] 
[09:28:26.148]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:26.149]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:26.149]  - seeds: <none>
[09:28:26.149]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.149] getGlobalsAndPackages() ...
[09:28:26.149] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.149] Resolving globals: FALSE
[09:28:26.149] Tweak future expression to call with '...' arguments ...
[09:28:26.150] {
[09:28:26.150]     do.call(function(...) {
[09:28:26.150]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.150]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.150]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.150]             on.exit(options(oopts), add = TRUE)
[09:28:26.150]         }
[09:28:26.150]         {
[09:28:26.150]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.150]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.150]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.150]             })
[09:28:26.150]         }
[09:28:26.150]     }, args = future.call.arguments)
[09:28:26.150] }
[09:28:26.150] Tweak future expression to call with '...' arguments ... DONE
[09:28:26.151] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.151] - packages: [1] ‘stats’
[09:28:26.151] getGlobalsAndPackages() ... DONE
[09:28:26.151] run() for ‘Future’ ...
[09:28:26.152] - state: ‘created’
[09:28:26.152] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:26.156] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.156] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:26.156]   - Field: ‘label’
[09:28:26.157]   - Field: ‘local’
[09:28:26.157]   - Field: ‘owner’
[09:28:26.157]   - Field: ‘envir’
[09:28:26.157]   - Field: ‘workers’
[09:28:26.157]   - Field: ‘packages’
[09:28:26.157]   - Field: ‘gc’
[09:28:26.157]   - Field: ‘job’
[09:28:26.157]   - Field: ‘conditions’
[09:28:26.158]   - Field: ‘expr’
[09:28:26.158]   - Field: ‘uuid’
[09:28:26.158]   - Field: ‘seed’
[09:28:26.158]   - Field: ‘version’
[09:28:26.158]   - Field: ‘result’
[09:28:26.158]   - Field: ‘asynchronous’
[09:28:26.158]   - Field: ‘calls’
[09:28:26.159]   - Field: ‘globals’
[09:28:26.159]   - Field: ‘stdout’
[09:28:26.159]   - Field: ‘earlySignal’
[09:28:26.159]   - Field: ‘lazy’
[09:28:26.159]   - Field: ‘state’
[09:28:26.159] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:26.159] - Launch lazy future ...
[09:28:26.160] Packages needed by the future expression (n = 1): ‘stats’
[09:28:26.160] Packages needed by future strategies (n = 0): <none>
[09:28:26.161] {
[09:28:26.161]     {
[09:28:26.161]         {
[09:28:26.161]             ...future.startTime <- base::Sys.time()
[09:28:26.161]             {
[09:28:26.161]                 {
[09:28:26.161]                   {
[09:28:26.161]                     {
[09:28:26.161]                       {
[09:28:26.161]                         base::local({
[09:28:26.161]                           has_future <- base::requireNamespace("future", 
[09:28:26.161]                             quietly = TRUE)
[09:28:26.161]                           if (has_future) {
[09:28:26.161]                             ns <- base::getNamespace("future")
[09:28:26.161]                             version <- ns[[".package"]][["version"]]
[09:28:26.161]                             if (is.null(version)) 
[09:28:26.161]                               version <- utils::packageVersion("future")
[09:28:26.161]                           }
[09:28:26.161]                           else {
[09:28:26.161]                             version <- NULL
[09:28:26.161]                           }
[09:28:26.161]                           if (!has_future || version < "1.8.0") {
[09:28:26.161]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:26.161]                               "", base::R.version$version.string), 
[09:28:26.161]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:26.161]                                 base::R.version$platform, 8 * 
[09:28:26.161]                                   base::.Machine$sizeof.pointer), 
[09:28:26.161]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:26.161]                                 "release", "version")], collapse = " "), 
[09:28:26.161]                               hostname = base::Sys.info()[["nodename"]])
[09:28:26.161]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:26.161]                               info)
[09:28:26.161]                             info <- base::paste(info, collapse = "; ")
[09:28:26.161]                             if (!has_future) {
[09:28:26.161]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:26.161]                                 info)
[09:28:26.161]                             }
[09:28:26.161]                             else {
[09:28:26.161]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:26.161]                                 info, version)
[09:28:26.161]                             }
[09:28:26.161]                             base::stop(msg)
[09:28:26.161]                           }
[09:28:26.161]                         })
[09:28:26.161]                       }
[09:28:26.161]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:26.161]                       base::options(mc.cores = 1L)
[09:28:26.161]                     }
[09:28:26.161]                     base::local({
[09:28:26.161]                       for (pkg in "stats") {
[09:28:26.161]                         base::loadNamespace(pkg)
[09:28:26.161]                         base::library(pkg, character.only = TRUE)
[09:28:26.161]                       }
[09:28:26.161]                     })
[09:28:26.161]                   }
[09:28:26.161]                   ...future.strategy.old <- future::plan("list")
[09:28:26.161]                   options(future.plan = NULL)
[09:28:26.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:26.161]                 }
[09:28:26.161]                 ...future.workdir <- getwd()
[09:28:26.161]             }
[09:28:26.161]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:26.161]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:26.161]         }
[09:28:26.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:26.161]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:26.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:26.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:26.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:26.161]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:26.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:26.161]             base::names(...future.oldOptions))
[09:28:26.161]     }
[09:28:26.161]     if (FALSE) {
[09:28:26.161]     }
[09:28:26.161]     else {
[09:28:26.161]         if (TRUE) {
[09:28:26.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:26.161]                 open = "w")
[09:28:26.161]         }
[09:28:26.161]         else {
[09:28:26.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:26.161]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:26.161]         }
[09:28:26.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:26.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:26.161]             base::sink(type = "output", split = FALSE)
[09:28:26.161]             base::close(...future.stdout)
[09:28:26.161]         }, add = TRUE)
[09:28:26.161]     }
[09:28:26.161]     ...future.frame <- base::sys.nframe()
[09:28:26.161]     ...future.conditions <- base::list()
[09:28:26.161]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:26.161]     if (FALSE) {
[09:28:26.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:26.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:26.161]     }
[09:28:26.161]     ...future.result <- base::tryCatch({
[09:28:26.161]         base::withCallingHandlers({
[09:28:26.161]             ...future.value <- base::withVisible(base::local({
[09:28:26.161]                 withCallingHandlers({
[09:28:26.161]                   {
[09:28:26.161]                     do.call(function(...) {
[09:28:26.161]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.161]                       if (!identical(...future.globals.maxSize.org, 
[09:28:26.161]                         ...future.globals.maxSize)) {
[09:28:26.161]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.161]                         on.exit(options(oopts), add = TRUE)
[09:28:26.161]                       }
[09:28:26.161]                       {
[09:28:26.161]                         lapply(seq_along(...future.elements_ii), 
[09:28:26.161]                           FUN = function(jj) {
[09:28:26.161]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.161]                             ...future.FUN(...future.X_jj, ...)
[09:28:26.161]                           })
[09:28:26.161]                       }
[09:28:26.161]                     }, args = future.call.arguments)
[09:28:26.161]                   }
[09:28:26.161]                 }, immediateCondition = function(cond) {
[09:28:26.161]                   save_rds <- function (object, pathname, ...) 
[09:28:26.161]                   {
[09:28:26.161]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:26.161]                     if (file_test("-f", pathname_tmp)) {
[09:28:26.161]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.161]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:26.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.161]                         fi_tmp[["mtime"]])
[09:28:26.161]                     }
[09:28:26.161]                     tryCatch({
[09:28:26.161]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:26.161]                     }, error = function(ex) {
[09:28:26.161]                       msg <- conditionMessage(ex)
[09:28:26.161]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.161]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:26.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.161]                         fi_tmp[["mtime"]], msg)
[09:28:26.161]                       ex$message <- msg
[09:28:26.161]                       stop(ex)
[09:28:26.161]                     })
[09:28:26.161]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:26.161]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:26.161]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:26.161]                       fi_tmp <- file.info(pathname_tmp)
[09:28:26.161]                       fi <- file.info(pathname)
[09:28:26.161]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:26.161]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:26.161]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:26.161]                         fi[["size"]], fi[["mtime"]])
[09:28:26.161]                       stop(msg)
[09:28:26.161]                     }
[09:28:26.161]                     invisible(pathname)
[09:28:26.161]                   }
[09:28:26.161]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:26.161]                     rootPath = tempdir()) 
[09:28:26.161]                   {
[09:28:26.161]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:26.161]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:26.161]                       tmpdir = path, fileext = ".rds")
[09:28:26.161]                     save_rds(obj, file)
[09:28:26.161]                   }
[09:28:26.161]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPXoGS/.future/immediateConditions")
[09:28:26.161]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.161]                   {
[09:28:26.161]                     inherits <- base::inherits
[09:28:26.161]                     invokeRestart <- base::invokeRestart
[09:28:26.161]                     is.null <- base::is.null
[09:28:26.161]                     muffled <- FALSE
[09:28:26.161]                     if (inherits(cond, "message")) {
[09:28:26.161]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:26.161]                       if (muffled) 
[09:28:26.161]                         invokeRestart("muffleMessage")
[09:28:26.161]                     }
[09:28:26.161]                     else if (inherits(cond, "warning")) {
[09:28:26.161]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:26.161]                       if (muffled) 
[09:28:26.161]                         invokeRestart("muffleWarning")
[09:28:26.161]                     }
[09:28:26.161]                     else if (inherits(cond, "condition")) {
[09:28:26.161]                       if (!is.null(pattern)) {
[09:28:26.161]                         computeRestarts <- base::computeRestarts
[09:28:26.161]                         grepl <- base::grepl
[09:28:26.161]                         restarts <- computeRestarts(cond)
[09:28:26.161]                         for (restart in restarts) {
[09:28:26.161]                           name <- restart$name
[09:28:26.161]                           if (is.null(name)) 
[09:28:26.161]                             next
[09:28:26.161]                           if (!grepl(pattern, name)) 
[09:28:26.161]                             next
[09:28:26.161]                           invokeRestart(restart)
[09:28:26.161]                           muffled <- TRUE
[09:28:26.161]                           break
[09:28:26.161]                         }
[09:28:26.161]                       }
[09:28:26.161]                     }
[09:28:26.161]                     invisible(muffled)
[09:28:26.161]                   }
[09:28:26.161]                   muffleCondition(cond)
[09:28:26.161]                 })
[09:28:26.161]             }))
[09:28:26.161]             future::FutureResult(value = ...future.value$value, 
[09:28:26.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.161]                   ...future.rng), globalenv = if (FALSE) 
[09:28:26.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:26.161]                     ...future.globalenv.names))
[09:28:26.161]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:26.161]         }, condition = base::local({
[09:28:26.161]             c <- base::c
[09:28:26.161]             inherits <- base::inherits
[09:28:26.161]             invokeRestart <- base::invokeRestart
[09:28:26.161]             length <- base::length
[09:28:26.161]             list <- base::list
[09:28:26.161]             seq.int <- base::seq.int
[09:28:26.161]             signalCondition <- base::signalCondition
[09:28:26.161]             sys.calls <- base::sys.calls
[09:28:26.161]             `[[` <- base::`[[`
[09:28:26.161]             `+` <- base::`+`
[09:28:26.161]             `<<-` <- base::`<<-`
[09:28:26.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:26.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:26.161]                   3L)]
[09:28:26.161]             }
[09:28:26.161]             function(cond) {
[09:28:26.161]                 is_error <- inherits(cond, "error")
[09:28:26.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:26.161]                   NULL)
[09:28:26.161]                 if (is_error) {
[09:28:26.161]                   sessionInformation <- function() {
[09:28:26.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:26.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:26.161]                       search = base::search(), system = base::Sys.info())
[09:28:26.161]                   }
[09:28:26.161]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:26.161]                     cond$call), session = sessionInformation(), 
[09:28:26.161]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:26.161]                   signalCondition(cond)
[09:28:26.161]                 }
[09:28:26.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:26.161]                 "immediateCondition"))) {
[09:28:26.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:26.161]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:26.161]                   if (TRUE && !signal) {
[09:28:26.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.161]                     {
[09:28:26.161]                       inherits <- base::inherits
[09:28:26.161]                       invokeRestart <- base::invokeRestart
[09:28:26.161]                       is.null <- base::is.null
[09:28:26.161]                       muffled <- FALSE
[09:28:26.161]                       if (inherits(cond, "message")) {
[09:28:26.161]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.161]                         if (muffled) 
[09:28:26.161]                           invokeRestart("muffleMessage")
[09:28:26.161]                       }
[09:28:26.161]                       else if (inherits(cond, "warning")) {
[09:28:26.161]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.161]                         if (muffled) 
[09:28:26.161]                           invokeRestart("muffleWarning")
[09:28:26.161]                       }
[09:28:26.161]                       else if (inherits(cond, "condition")) {
[09:28:26.161]                         if (!is.null(pattern)) {
[09:28:26.161]                           computeRestarts <- base::computeRestarts
[09:28:26.161]                           grepl <- base::grepl
[09:28:26.161]                           restarts <- computeRestarts(cond)
[09:28:26.161]                           for (restart in restarts) {
[09:28:26.161]                             name <- restart$name
[09:28:26.161]                             if (is.null(name)) 
[09:28:26.161]                               next
[09:28:26.161]                             if (!grepl(pattern, name)) 
[09:28:26.161]                               next
[09:28:26.161]                             invokeRestart(restart)
[09:28:26.161]                             muffled <- TRUE
[09:28:26.161]                             break
[09:28:26.161]                           }
[09:28:26.161]                         }
[09:28:26.161]                       }
[09:28:26.161]                       invisible(muffled)
[09:28:26.161]                     }
[09:28:26.161]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.161]                   }
[09:28:26.161]                 }
[09:28:26.161]                 else {
[09:28:26.161]                   if (TRUE) {
[09:28:26.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.161]                     {
[09:28:26.161]                       inherits <- base::inherits
[09:28:26.161]                       invokeRestart <- base::invokeRestart
[09:28:26.161]                       is.null <- base::is.null
[09:28:26.161]                       muffled <- FALSE
[09:28:26.161]                       if (inherits(cond, "message")) {
[09:28:26.161]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.161]                         if (muffled) 
[09:28:26.161]                           invokeRestart("muffleMessage")
[09:28:26.161]                       }
[09:28:26.161]                       else if (inherits(cond, "warning")) {
[09:28:26.161]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.161]                         if (muffled) 
[09:28:26.161]                           invokeRestart("muffleWarning")
[09:28:26.161]                       }
[09:28:26.161]                       else if (inherits(cond, "condition")) {
[09:28:26.161]                         if (!is.null(pattern)) {
[09:28:26.161]                           computeRestarts <- base::computeRestarts
[09:28:26.161]                           grepl <- base::grepl
[09:28:26.161]                           restarts <- computeRestarts(cond)
[09:28:26.161]                           for (restart in restarts) {
[09:28:26.161]                             name <- restart$name
[09:28:26.161]                             if (is.null(name)) 
[09:28:26.161]                               next
[09:28:26.161]                             if (!grepl(pattern, name)) 
[09:28:26.161]                               next
[09:28:26.161]                             invokeRestart(restart)
[09:28:26.161]                             muffled <- TRUE
[09:28:26.161]                             break
[09:28:26.161]                           }
[09:28:26.161]                         }
[09:28:26.161]                       }
[09:28:26.161]                       invisible(muffled)
[09:28:26.161]                     }
[09:28:26.161]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.161]                   }
[09:28:26.161]                 }
[09:28:26.161]             }
[09:28:26.161]         }))
[09:28:26.161]     }, error = function(ex) {
[09:28:26.161]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:26.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.161]                 ...future.rng), started = ...future.startTime, 
[09:28:26.161]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:26.161]             version = "1.8"), class = "FutureResult")
[09:28:26.161]     }, finally = {
[09:28:26.161]         if (!identical(...future.workdir, getwd())) 
[09:28:26.161]             setwd(...future.workdir)
[09:28:26.161]         {
[09:28:26.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:26.161]                 ...future.oldOptions$nwarnings <- NULL
[09:28:26.161]             }
[09:28:26.161]             base::options(...future.oldOptions)
[09:28:26.161]             if (.Platform$OS.type == "windows") {
[09:28:26.161]                 old_names <- names(...future.oldEnvVars)
[09:28:26.161]                 envs <- base::Sys.getenv()
[09:28:26.161]                 names <- names(envs)
[09:28:26.161]                 common <- intersect(names, old_names)
[09:28:26.161]                 added <- setdiff(names, old_names)
[09:28:26.161]                 removed <- setdiff(old_names, names)
[09:28:26.161]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:26.161]                   envs[common]]
[09:28:26.161]                 NAMES <- toupper(changed)
[09:28:26.161]                 args <- list()
[09:28:26.161]                 for (kk in seq_along(NAMES)) {
[09:28:26.161]                   name <- changed[[kk]]
[09:28:26.161]                   NAME <- NAMES[[kk]]
[09:28:26.161]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.161]                     next
[09:28:26.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.161]                 }
[09:28:26.161]                 NAMES <- toupper(added)
[09:28:26.161]                 for (kk in seq_along(NAMES)) {
[09:28:26.161]                   name <- added[[kk]]
[09:28:26.161]                   NAME <- NAMES[[kk]]
[09:28:26.161]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.161]                     next
[09:28:26.161]                   args[[name]] <- ""
[09:28:26.161]                 }
[09:28:26.161]                 NAMES <- toupper(removed)
[09:28:26.161]                 for (kk in seq_along(NAMES)) {
[09:28:26.161]                   name <- removed[[kk]]
[09:28:26.161]                   NAME <- NAMES[[kk]]
[09:28:26.161]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.161]                     next
[09:28:26.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.161]                 }
[09:28:26.161]                 if (length(args) > 0) 
[09:28:26.161]                   base::do.call(base::Sys.setenv, args = args)
[09:28:26.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:26.161]             }
[09:28:26.161]             else {
[09:28:26.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:26.161]             }
[09:28:26.161]             {
[09:28:26.161]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:26.161]                   0L) {
[09:28:26.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:26.161]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:26.161]                   base::options(opts)
[09:28:26.161]                 }
[09:28:26.161]                 {
[09:28:26.161]                   {
[09:28:26.161]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:26.161]                     NULL
[09:28:26.161]                   }
[09:28:26.161]                   options(future.plan = NULL)
[09:28:26.161]                   if (is.na(NA_character_)) 
[09:28:26.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:26.161]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:26.161]                     .init = FALSE)
[09:28:26.161]                 }
[09:28:26.161]             }
[09:28:26.161]         }
[09:28:26.161]     })
[09:28:26.161]     if (TRUE) {
[09:28:26.161]         base::sink(type = "output", split = FALSE)
[09:28:26.161]         if (TRUE) {
[09:28:26.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:26.161]         }
[09:28:26.161]         else {
[09:28:26.161]             ...future.result["stdout"] <- base::list(NULL)
[09:28:26.161]         }
[09:28:26.161]         base::close(...future.stdout)
[09:28:26.161]         ...future.stdout <- NULL
[09:28:26.161]     }
[09:28:26.161]     ...future.result$conditions <- ...future.conditions
[09:28:26.161]     ...future.result$finished <- base::Sys.time()
[09:28:26.161]     ...future.result
[09:28:26.161] }
[09:28:26.164] assign_globals() ...
[09:28:26.164] List of 5
[09:28:26.164]  $ ...future.FUN            :function (x, ...)  
[09:28:26.164]  $ future.call.arguments    : list()
[09:28:26.164]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:26.164]  $ ...future.elements_ii    :List of 2
[09:28:26.164]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[09:28:26.164]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:28:26.164]  $ ...future.seeds_ii       : NULL
[09:28:26.164]  $ ...future.globals.maxSize: NULL
[09:28:26.164]  - attr(*, "where")=List of 5
[09:28:26.164]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:26.164]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:26.164]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:26.164]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:26.164]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:26.164]  - attr(*, "resolved")= logi FALSE
[09:28:26.164]  - attr(*, "total_size")= num 1248
[09:28:26.164]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:26.164]  - attr(*, "already-done")= logi TRUE
[09:28:26.175] - copied ‘...future.FUN’ to environment
[09:28:26.175] - copied ‘future.call.arguments’ to environment
[09:28:26.175] - copied ‘...future.elements_ii’ to environment
[09:28:26.175] - copied ‘...future.seeds_ii’ to environment
[09:28:26.176] - copied ‘...future.globals.maxSize’ to environment
[09:28:26.176] assign_globals() ... done
[09:28:26.176] requestCore(): workers = 2
[09:28:26.178] MulticoreFuture started
[09:28:26.179] - Launch lazy future ... done
[09:28:26.179] run() for ‘MulticoreFuture’ ... done
[09:28:26.179] Created future:
[09:28:26.180] plan(): Setting new future strategy stack:
[09:28:26.180] List of future strategies:
[09:28:26.180] 1. sequential:
[09:28:26.180]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:26.180]    - tweaked: FALSE
[09:28:26.180]    - call: NULL
[09:28:26.181] plan(): nbrOfWorkers() = 1
[09:28:26.184] plan(): Setting new future strategy stack:
[09:28:26.184] List of future strategies:
[09:28:26.184] 1. multicore:
[09:28:26.184]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:26.184]    - tweaked: FALSE
[09:28:26.184]    - call: plan(strategy)
[09:28:26.189] plan(): nbrOfWorkers() = 2
[09:28:26.179] MulticoreFuture:
[09:28:26.179] Label: ‘future_eapply-2’
[09:28:26.179] Expression:
[09:28:26.179] {
[09:28:26.179]     do.call(function(...) {
[09:28:26.179]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.179]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.179]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.179]             on.exit(options(oopts), add = TRUE)
[09:28:26.179]         }
[09:28:26.179]         {
[09:28:26.179]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.179]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.179]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.179]             })
[09:28:26.179]         }
[09:28:26.179]     }, args = future.call.arguments)
[09:28:26.179] }
[09:28:26.179] Lazy evaluation: FALSE
[09:28:26.179] Asynchronous evaluation: TRUE
[09:28:26.179] Local evaluation: TRUE
[09:28:26.179] Environment: R_GlobalEnv
[09:28:26.179] Capture standard output: TRUE
[09:28:26.179] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:26.179] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:26.179] Packages: 1 packages (‘stats’)
[09:28:26.179] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:26.179] Resolved: TRUE
[09:28:26.179] Value: <not collected>
[09:28:26.179] Conditions captured: <none>
[09:28:26.179] Early signaling: FALSE
[09:28:26.179] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:26.179] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.190] Chunk #2 of 2 ... DONE
[09:28:26.190] Launching 2 futures (chunks) ... DONE
[09:28:26.190] Resolving 2 futures (chunks) ...
[09:28:26.191] resolve() on list ...
[09:28:26.191]  recursive: 0
[09:28:26.191]  length: 2
[09:28:26.191] 
[09:28:26.191] Future #1
[09:28:26.192] result() for MulticoreFuture ...
[09:28:26.192] result() for MulticoreFuture ...
[09:28:26.193] result() for MulticoreFuture ... done
[09:28:26.193] result() for MulticoreFuture ... done
[09:28:26.193] result() for MulticoreFuture ...
[09:28:26.193] result() for MulticoreFuture ... done
[09:28:26.193] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:26.193] - nx: 2
[09:28:26.193] - relay: TRUE
[09:28:26.194] - stdout: TRUE
[09:28:26.194] - signal: TRUE
[09:28:26.194] - resignal: FALSE
[09:28:26.194] - force: TRUE
[09:28:26.194] - relayed: [n=2] FALSE, FALSE
[09:28:26.194] - queued futures: [n=2] FALSE, FALSE
[09:28:26.194]  - until=1
[09:28:26.195]  - relaying element #1
[09:28:26.195] result() for MulticoreFuture ...
[09:28:26.195] result() for MulticoreFuture ... done
[09:28:26.195] result() for MulticoreFuture ...
[09:28:26.195] result() for MulticoreFuture ... done
[09:28:26.195] result() for MulticoreFuture ...
[09:28:26.195] result() for MulticoreFuture ... done
[09:28:26.196] result() for MulticoreFuture ...
[09:28:26.196] result() for MulticoreFuture ... done
[09:28:26.196] - relayed: [n=2] TRUE, FALSE
[09:28:26.196] - queued futures: [n=2] TRUE, FALSE
[09:28:26.196] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:26.196]  length: 1 (resolved future 1)
[09:28:26.197] Future #2
[09:28:26.197] result() for MulticoreFuture ...
[09:28:26.197] result() for MulticoreFuture ...
[09:28:26.198] result() for MulticoreFuture ... done
[09:28:26.198] result() for MulticoreFuture ... done
[09:28:26.198] result() for MulticoreFuture ...
[09:28:26.198] result() for MulticoreFuture ... done
[09:28:26.198] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:26.198] - nx: 2
[09:28:26.198] - relay: TRUE
[09:28:26.199] - stdout: TRUE
[09:28:26.199] - signal: TRUE
[09:28:26.199] - resignal: FALSE
[09:28:26.199] - force: TRUE
[09:28:26.199] - relayed: [n=2] TRUE, FALSE
[09:28:26.199] - queued futures: [n=2] TRUE, FALSE
[09:28:26.199]  - until=2
[09:28:26.199]  - relaying element #2
[09:28:26.200] result() for MulticoreFuture ...
[09:28:26.200] result() for MulticoreFuture ... done
[09:28:26.200] result() for MulticoreFuture ...
[09:28:26.200] result() for MulticoreFuture ... done
[09:28:26.200] result() for MulticoreFuture ...
[09:28:26.200] result() for MulticoreFuture ... done
[09:28:26.200] result() for MulticoreFuture ...
[09:28:26.200] result() for MulticoreFuture ... done
[09:28:26.201] - relayed: [n=2] TRUE, TRUE
[09:28:26.201] - queued futures: [n=2] TRUE, TRUE
[09:28:26.201] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:26.201]  length: 0 (resolved future 2)
[09:28:26.201] Relaying remaining futures
[09:28:26.201] signalConditionsASAP(NULL, pos=0) ...
[09:28:26.201] - nx: 2
[09:28:26.201] - relay: TRUE
[09:28:26.201] - stdout: TRUE
[09:28:26.201] - signal: TRUE
[09:28:26.202] - resignal: FALSE
[09:28:26.202] - force: TRUE
[09:28:26.202] - relayed: [n=2] TRUE, TRUE
[09:28:26.202] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:26.202] - relayed: [n=2] TRUE, TRUE
[09:28:26.202] - queued futures: [n=2] TRUE, TRUE
[09:28:26.202] signalConditionsASAP(NULL, pos=0) ... done
[09:28:26.202] resolve() on list ... DONE
[09:28:26.202] result() for MulticoreFuture ...
[09:28:26.203] result() for MulticoreFuture ... done
[09:28:26.203] result() for MulticoreFuture ...
[09:28:26.203] result() for MulticoreFuture ... done
[09:28:26.203] result() for MulticoreFuture ...
[09:28:26.203] result() for MulticoreFuture ... done
[09:28:26.203] result() for MulticoreFuture ...
[09:28:26.203] result() for MulticoreFuture ... done
[09:28:26.203]  - Number of value chunks collected: 2
[09:28:26.203] Resolving 2 futures (chunks) ... DONE
[09:28:26.204] Reducing values from 2 chunks ...
[09:28:26.204]  - Number of values collected after concatenation: 3
[09:28:26.204]  - Number of values expected: 3
[09:28:26.204] Reducing values from 2 chunks ... DONE
[09:28:26.204] future_lapply() ... DONE
[09:28:26.204] plan(): Setting new future strategy stack:
[09:28:26.205] List of future strategies:
[09:28:26.205] 1. sequential:
[09:28:26.205]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:26.205]    - tweaked: FALSE
[09:28:26.205]    - call: plan(sequential)
[09:28:26.205] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[09:28:26.206] plan(): Setting new future strategy stack:
[09:28:26.206] List of future strategies:
[09:28:26.206] 1. multisession:
[09:28:26.206]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:26.206]    - tweaked: FALSE
[09:28:26.206]    - call: plan(strategy)
[09:28:26.206] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:28:26.206] multisession:
[09:28:26.206] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:26.206] - tweaked: FALSE
[09:28:26.206] - call: plan(strategy)
[09:28:26.212] getGlobalsAndPackages() ...
[09:28:26.212] Not searching for globals
[09:28:26.213] - globals: [0] <none>
[09:28:26.213] getGlobalsAndPackages() ... DONE
[09:28:26.213] [local output] makeClusterPSOCK() ...
[09:28:26.258] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:28:26.260] [local output] Base port: 11222
[09:28:26.260] [local output] Getting setup options for 2 cluster nodes ...
[09:28:26.260] [local output]  - Node 1 of 2 ...
[09:28:26.260] [local output] localMachine=TRUE => revtunnel=FALSE

[09:28:26.261] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpmPXoGS/worker.rank=1.parallelly.parent=29080.71981f7c194c.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpmPXoGS/worker.rank=1.parallelly.parent=29080.71981f7c194c.pid")'’
[09:28:26.446] - Possible to infer worker's PID: TRUE
[09:28:26.446] [local output] Rscript port: 11222

[09:28:26.447] [local output]  - Node 2 of 2 ...
[09:28:26.447] [local output] localMachine=TRUE => revtunnel=FALSE

[09:28:26.448] [local output] Rscript port: 11222

[09:28:26.448] [local output] Getting setup options for 2 cluster nodes ... done
[09:28:26.448] [local output]  - Parallel setup requested for some PSOCK nodes
[09:28:26.449] [local output] Setting up PSOCK nodes in parallel
[09:28:26.449] List of 36
[09:28:26.449]  $ worker          : chr "localhost"
[09:28:26.449]   ..- attr(*, "localhost")= logi TRUE
[09:28:26.449]  $ master          : chr "localhost"
[09:28:26.449]  $ port            : int 11222
[09:28:26.449]  $ connectTimeout  : num 120
[09:28:26.449]  $ timeout         : num 2592000
[09:28:26.449]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:28:26.449]  $ homogeneous     : logi TRUE
[09:28:26.449]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:28:26.449]  $ rscript_envs    : NULL
[09:28:26.449]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:28:26.449]  $ rscript_startup : NULL
[09:28:26.449]  $ rscript_sh      : chr "sh"
[09:28:26.449]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:28:26.449]  $ methods         : logi TRUE
[09:28:26.449]  $ socketOptions   : chr "no-delay"
[09:28:26.449]  $ useXDR          : logi FALSE
[09:28:26.449]  $ outfile         : chr "/dev/null"
[09:28:26.449]  $ renice          : int NA
[09:28:26.449]  $ rshcmd          : NULL
[09:28:26.449]  $ user            : chr(0) 
[09:28:26.449]  $ revtunnel       : logi FALSE
[09:28:26.449]  $ rshlogfile      : NULL
[09:28:26.449]  $ rshopts         : chr(0) 
[09:28:26.449]  $ rank            : int 1
[09:28:26.449]  $ manual          : logi FALSE
[09:28:26.449]  $ dryrun          : logi FALSE
[09:28:26.449]  $ quiet           : logi FALSE
[09:28:26.449]  $ setup_strategy  : chr "parallel"
[09:28:26.449]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:28:26.449]  $ pidfile         : chr "/tmp/RtmpmPXoGS/worker.rank=1.parallelly.parent=29080.71981f7c194c.pid"
[09:28:26.449]  $ rshcmd_label    : NULL
[09:28:26.449]  $ rsh_call        : NULL
[09:28:26.449]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:28:26.449]  $ localMachine    : logi TRUE
[09:28:26.449]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:28:26.449]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:28:26.449]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:28:26.449]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:28:26.449]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:28:26.449]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:28:26.449]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:28:26.449]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:28:26.449]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:28:26.449]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:28:26.449]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:28:26.449]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:28:26.449]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:28:26.449]  $ arguments       :List of 28
[09:28:26.449]   ..$ worker          : chr "localhost"
[09:28:26.449]   ..$ master          : NULL
[09:28:26.449]   ..$ port            : int 11222
[09:28:26.449]   ..$ connectTimeout  : num 120
[09:28:26.449]   ..$ timeout         : num 2592000
[09:28:26.449]   ..$ rscript         : NULL
[09:28:26.449]   ..$ homogeneous     : NULL
[09:28:26.449]   ..$ rscript_args    : NULL
[09:28:26.449]   ..$ rscript_envs    : NULL
[09:28:26.449]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:28:26.449]   ..$ rscript_startup : NULL
[09:28:26.449]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:28:26.449]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:28:26.449]   ..$ methods         : logi TRUE
[09:28:26.449]   ..$ socketOptions   : chr "no-delay"
[09:28:26.449]   ..$ useXDR          : logi FALSE
[09:28:26.449]   ..$ outfile         : chr "/dev/null"
[09:28:26.449]   ..$ renice          : int NA
[09:28:26.449]   ..$ rshcmd          : NULL
[09:28:26.449]   ..$ user            : NULL
[09:28:26.449]   ..$ revtunnel       : logi NA
[09:28:26.449]   ..$ rshlogfile      : NULL
[09:28:26.449]   ..$ rshopts         : NULL
[09:28:26.449]   ..$ rank            : int 1
[09:28:26.449]   ..$ manual          : logi FALSE
[09:28:26.449]   ..$ dryrun          : logi FALSE
[09:28:26.449]   ..$ quiet           : logi FALSE
[09:28:26.449]   ..$ setup_strategy  : chr "parallel"
[09:28:26.449]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:28:26.465] [local output] System call to launch all workers:
[09:28:26.465] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpmPXoGS/worker.rank=1.parallelly.parent=29080.71981f7c194c.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11222 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:28:26.466] [local output] Starting PSOCK main server
[09:28:26.471] [local output] Workers launched
[09:28:26.472] [local output] Waiting for workers to connect back
[09:28:26.472]  - [local output] 0 workers out of 2 ready
[09:28:26.712]  - [local output] 0 workers out of 2 ready
[09:28:26.712]  - [local output] 1 workers out of 2 ready
[09:28:26.716]  - [local output] 1 workers out of 2 ready
[09:28:26.716]  - [local output] 2 workers out of 2 ready
[09:28:26.716] [local output] Launching of workers completed
[09:28:26.717] [local output] Collecting session information from workers
[09:28:26.717] [local output]  - Worker #1 of 2
[09:28:26.718] [local output]  - Worker #2 of 2
[09:28:26.718] [local output] makeClusterPSOCK() ... done
[09:28:26.729] Packages needed by the future expression (n = 0): <none>
[09:28:26.729] Packages needed by future strategies (n = 0): <none>
[09:28:26.730] {
[09:28:26.730]     {
[09:28:26.730]         {
[09:28:26.730]             ...future.startTime <- base::Sys.time()
[09:28:26.730]             {
[09:28:26.730]                 {
[09:28:26.730]                   {
[09:28:26.730]                     {
[09:28:26.730]                       base::local({
[09:28:26.730]                         has_future <- base::requireNamespace("future", 
[09:28:26.730]                           quietly = TRUE)
[09:28:26.730]                         if (has_future) {
[09:28:26.730]                           ns <- base::getNamespace("future")
[09:28:26.730]                           version <- ns[[".package"]][["version"]]
[09:28:26.730]                           if (is.null(version)) 
[09:28:26.730]                             version <- utils::packageVersion("future")
[09:28:26.730]                         }
[09:28:26.730]                         else {
[09:28:26.730]                           version <- NULL
[09:28:26.730]                         }
[09:28:26.730]                         if (!has_future || version < "1.8.0") {
[09:28:26.730]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:26.730]                             "", base::R.version$version.string), 
[09:28:26.730]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:26.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:26.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:26.730]                               "release", "version")], collapse = " "), 
[09:28:26.730]                             hostname = base::Sys.info()[["nodename"]])
[09:28:26.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:26.730]                             info)
[09:28:26.730]                           info <- base::paste(info, collapse = "; ")
[09:28:26.730]                           if (!has_future) {
[09:28:26.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:26.730]                               info)
[09:28:26.730]                           }
[09:28:26.730]                           else {
[09:28:26.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:26.730]                               info, version)
[09:28:26.730]                           }
[09:28:26.730]                           base::stop(msg)
[09:28:26.730]                         }
[09:28:26.730]                       })
[09:28:26.730]                     }
[09:28:26.730]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:26.730]                     base::options(mc.cores = 1L)
[09:28:26.730]                   }
[09:28:26.730]                   ...future.strategy.old <- future::plan("list")
[09:28:26.730]                   options(future.plan = NULL)
[09:28:26.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:26.730]                 }
[09:28:26.730]                 ...future.workdir <- getwd()
[09:28:26.730]             }
[09:28:26.730]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:26.730]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:26.730]         }
[09:28:26.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:26.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:26.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:26.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:26.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:26.730]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:26.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:26.730]             base::names(...future.oldOptions))
[09:28:26.730]     }
[09:28:26.730]     if (FALSE) {
[09:28:26.730]     }
[09:28:26.730]     else {
[09:28:26.730]         if (TRUE) {
[09:28:26.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:26.730]                 open = "w")
[09:28:26.730]         }
[09:28:26.730]         else {
[09:28:26.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:26.730]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:26.730]         }
[09:28:26.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:26.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:26.730]             base::sink(type = "output", split = FALSE)
[09:28:26.730]             base::close(...future.stdout)
[09:28:26.730]         }, add = TRUE)
[09:28:26.730]     }
[09:28:26.730]     ...future.frame <- base::sys.nframe()
[09:28:26.730]     ...future.conditions <- base::list()
[09:28:26.730]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:26.730]     if (FALSE) {
[09:28:26.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:26.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:26.730]     }
[09:28:26.730]     ...future.result <- base::tryCatch({
[09:28:26.730]         base::withCallingHandlers({
[09:28:26.730]             ...future.value <- base::withVisible(base::local({
[09:28:26.730]                 ...future.makeSendCondition <- base::local({
[09:28:26.730]                   sendCondition <- NULL
[09:28:26.730]                   function(frame = 1L) {
[09:28:26.730]                     if (is.function(sendCondition)) 
[09:28:26.730]                       return(sendCondition)
[09:28:26.730]                     ns <- getNamespace("parallel")
[09:28:26.730]                     if (exists("sendData", mode = "function", 
[09:28:26.730]                       envir = ns)) {
[09:28:26.730]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:26.730]                         envir = ns)
[09:28:26.730]                       envir <- sys.frame(frame)
[09:28:26.730]                       master <- NULL
[09:28:26.730]                       while (!identical(envir, .GlobalEnv) && 
[09:28:26.730]                         !identical(envir, emptyenv())) {
[09:28:26.730]                         if (exists("master", mode = "list", envir = envir, 
[09:28:26.730]                           inherits = FALSE)) {
[09:28:26.730]                           master <- get("master", mode = "list", 
[09:28:26.730]                             envir = envir, inherits = FALSE)
[09:28:26.730]                           if (inherits(master, c("SOCKnode", 
[09:28:26.730]                             "SOCK0node"))) {
[09:28:26.730]                             sendCondition <<- function(cond) {
[09:28:26.730]                               data <- list(type = "VALUE", value = cond, 
[09:28:26.730]                                 success = TRUE)
[09:28:26.730]                               parallel_sendData(master, data)
[09:28:26.730]                             }
[09:28:26.730]                             return(sendCondition)
[09:28:26.730]                           }
[09:28:26.730]                         }
[09:28:26.730]                         frame <- frame + 1L
[09:28:26.730]                         envir <- sys.frame(frame)
[09:28:26.730]                       }
[09:28:26.730]                     }
[09:28:26.730]                     sendCondition <<- function(cond) NULL
[09:28:26.730]                   }
[09:28:26.730]                 })
[09:28:26.730]                 withCallingHandlers({
[09:28:26.730]                   NA
[09:28:26.730]                 }, immediateCondition = function(cond) {
[09:28:26.730]                   sendCondition <- ...future.makeSendCondition()
[09:28:26.730]                   sendCondition(cond)
[09:28:26.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.730]                   {
[09:28:26.730]                     inherits <- base::inherits
[09:28:26.730]                     invokeRestart <- base::invokeRestart
[09:28:26.730]                     is.null <- base::is.null
[09:28:26.730]                     muffled <- FALSE
[09:28:26.730]                     if (inherits(cond, "message")) {
[09:28:26.730]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:26.730]                       if (muffled) 
[09:28:26.730]                         invokeRestart("muffleMessage")
[09:28:26.730]                     }
[09:28:26.730]                     else if (inherits(cond, "warning")) {
[09:28:26.730]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:26.730]                       if (muffled) 
[09:28:26.730]                         invokeRestart("muffleWarning")
[09:28:26.730]                     }
[09:28:26.730]                     else if (inherits(cond, "condition")) {
[09:28:26.730]                       if (!is.null(pattern)) {
[09:28:26.730]                         computeRestarts <- base::computeRestarts
[09:28:26.730]                         grepl <- base::grepl
[09:28:26.730]                         restarts <- computeRestarts(cond)
[09:28:26.730]                         for (restart in restarts) {
[09:28:26.730]                           name <- restart$name
[09:28:26.730]                           if (is.null(name)) 
[09:28:26.730]                             next
[09:28:26.730]                           if (!grepl(pattern, name)) 
[09:28:26.730]                             next
[09:28:26.730]                           invokeRestart(restart)
[09:28:26.730]                           muffled <- TRUE
[09:28:26.730]                           break
[09:28:26.730]                         }
[09:28:26.730]                       }
[09:28:26.730]                     }
[09:28:26.730]                     invisible(muffled)
[09:28:26.730]                   }
[09:28:26.730]                   muffleCondition(cond)
[09:28:26.730]                 })
[09:28:26.730]             }))
[09:28:26.730]             future::FutureResult(value = ...future.value$value, 
[09:28:26.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.730]                   ...future.rng), globalenv = if (FALSE) 
[09:28:26.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:26.730]                     ...future.globalenv.names))
[09:28:26.730]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:26.730]         }, condition = base::local({
[09:28:26.730]             c <- base::c
[09:28:26.730]             inherits <- base::inherits
[09:28:26.730]             invokeRestart <- base::invokeRestart
[09:28:26.730]             length <- base::length
[09:28:26.730]             list <- base::list
[09:28:26.730]             seq.int <- base::seq.int
[09:28:26.730]             signalCondition <- base::signalCondition
[09:28:26.730]             sys.calls <- base::sys.calls
[09:28:26.730]             `[[` <- base::`[[`
[09:28:26.730]             `+` <- base::`+`
[09:28:26.730]             `<<-` <- base::`<<-`
[09:28:26.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:26.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:26.730]                   3L)]
[09:28:26.730]             }
[09:28:26.730]             function(cond) {
[09:28:26.730]                 is_error <- inherits(cond, "error")
[09:28:26.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:26.730]                   NULL)
[09:28:26.730]                 if (is_error) {
[09:28:26.730]                   sessionInformation <- function() {
[09:28:26.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:26.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:26.730]                       search = base::search(), system = base::Sys.info())
[09:28:26.730]                   }
[09:28:26.730]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:26.730]                     cond$call), session = sessionInformation(), 
[09:28:26.730]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:26.730]                   signalCondition(cond)
[09:28:26.730]                 }
[09:28:26.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:26.730]                 "immediateCondition"))) {
[09:28:26.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:26.730]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:26.730]                   if (TRUE && !signal) {
[09:28:26.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.730]                     {
[09:28:26.730]                       inherits <- base::inherits
[09:28:26.730]                       invokeRestart <- base::invokeRestart
[09:28:26.730]                       is.null <- base::is.null
[09:28:26.730]                       muffled <- FALSE
[09:28:26.730]                       if (inherits(cond, "message")) {
[09:28:26.730]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.730]                         if (muffled) 
[09:28:26.730]                           invokeRestart("muffleMessage")
[09:28:26.730]                       }
[09:28:26.730]                       else if (inherits(cond, "warning")) {
[09:28:26.730]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.730]                         if (muffled) 
[09:28:26.730]                           invokeRestart("muffleWarning")
[09:28:26.730]                       }
[09:28:26.730]                       else if (inherits(cond, "condition")) {
[09:28:26.730]                         if (!is.null(pattern)) {
[09:28:26.730]                           computeRestarts <- base::computeRestarts
[09:28:26.730]                           grepl <- base::grepl
[09:28:26.730]                           restarts <- computeRestarts(cond)
[09:28:26.730]                           for (restart in restarts) {
[09:28:26.730]                             name <- restart$name
[09:28:26.730]                             if (is.null(name)) 
[09:28:26.730]                               next
[09:28:26.730]                             if (!grepl(pattern, name)) 
[09:28:26.730]                               next
[09:28:26.730]                             invokeRestart(restart)
[09:28:26.730]                             muffled <- TRUE
[09:28:26.730]                             break
[09:28:26.730]                           }
[09:28:26.730]                         }
[09:28:26.730]                       }
[09:28:26.730]                       invisible(muffled)
[09:28:26.730]                     }
[09:28:26.730]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.730]                   }
[09:28:26.730]                 }
[09:28:26.730]                 else {
[09:28:26.730]                   if (TRUE) {
[09:28:26.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.730]                     {
[09:28:26.730]                       inherits <- base::inherits
[09:28:26.730]                       invokeRestart <- base::invokeRestart
[09:28:26.730]                       is.null <- base::is.null
[09:28:26.730]                       muffled <- FALSE
[09:28:26.730]                       if (inherits(cond, "message")) {
[09:28:26.730]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.730]                         if (muffled) 
[09:28:26.730]                           invokeRestart("muffleMessage")
[09:28:26.730]                       }
[09:28:26.730]                       else if (inherits(cond, "warning")) {
[09:28:26.730]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.730]                         if (muffled) 
[09:28:26.730]                           invokeRestart("muffleWarning")
[09:28:26.730]                       }
[09:28:26.730]                       else if (inherits(cond, "condition")) {
[09:28:26.730]                         if (!is.null(pattern)) {
[09:28:26.730]                           computeRestarts <- base::computeRestarts
[09:28:26.730]                           grepl <- base::grepl
[09:28:26.730]                           restarts <- computeRestarts(cond)
[09:28:26.730]                           for (restart in restarts) {
[09:28:26.730]                             name <- restart$name
[09:28:26.730]                             if (is.null(name)) 
[09:28:26.730]                               next
[09:28:26.730]                             if (!grepl(pattern, name)) 
[09:28:26.730]                               next
[09:28:26.730]                             invokeRestart(restart)
[09:28:26.730]                             muffled <- TRUE
[09:28:26.730]                             break
[09:28:26.730]                           }
[09:28:26.730]                         }
[09:28:26.730]                       }
[09:28:26.730]                       invisible(muffled)
[09:28:26.730]                     }
[09:28:26.730]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.730]                   }
[09:28:26.730]                 }
[09:28:26.730]             }
[09:28:26.730]         }))
[09:28:26.730]     }, error = function(ex) {
[09:28:26.730]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:26.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.730]                 ...future.rng), started = ...future.startTime, 
[09:28:26.730]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:26.730]             version = "1.8"), class = "FutureResult")
[09:28:26.730]     }, finally = {
[09:28:26.730]         if (!identical(...future.workdir, getwd())) 
[09:28:26.730]             setwd(...future.workdir)
[09:28:26.730]         {
[09:28:26.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:26.730]                 ...future.oldOptions$nwarnings <- NULL
[09:28:26.730]             }
[09:28:26.730]             base::options(...future.oldOptions)
[09:28:26.730]             if (.Platform$OS.type == "windows") {
[09:28:26.730]                 old_names <- names(...future.oldEnvVars)
[09:28:26.730]                 envs <- base::Sys.getenv()
[09:28:26.730]                 names <- names(envs)
[09:28:26.730]                 common <- intersect(names, old_names)
[09:28:26.730]                 added <- setdiff(names, old_names)
[09:28:26.730]                 removed <- setdiff(old_names, names)
[09:28:26.730]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:26.730]                   envs[common]]
[09:28:26.730]                 NAMES <- toupper(changed)
[09:28:26.730]                 args <- list()
[09:28:26.730]                 for (kk in seq_along(NAMES)) {
[09:28:26.730]                   name <- changed[[kk]]
[09:28:26.730]                   NAME <- NAMES[[kk]]
[09:28:26.730]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.730]                     next
[09:28:26.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.730]                 }
[09:28:26.730]                 NAMES <- toupper(added)
[09:28:26.730]                 for (kk in seq_along(NAMES)) {
[09:28:26.730]                   name <- added[[kk]]
[09:28:26.730]                   NAME <- NAMES[[kk]]
[09:28:26.730]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.730]                     next
[09:28:26.730]                   args[[name]] <- ""
[09:28:26.730]                 }
[09:28:26.730]                 NAMES <- toupper(removed)
[09:28:26.730]                 for (kk in seq_along(NAMES)) {
[09:28:26.730]                   name <- removed[[kk]]
[09:28:26.730]                   NAME <- NAMES[[kk]]
[09:28:26.730]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.730]                     next
[09:28:26.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.730]                 }
[09:28:26.730]                 if (length(args) > 0) 
[09:28:26.730]                   base::do.call(base::Sys.setenv, args = args)
[09:28:26.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:26.730]             }
[09:28:26.730]             else {
[09:28:26.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:26.730]             }
[09:28:26.730]             {
[09:28:26.730]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:26.730]                   0L) {
[09:28:26.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:26.730]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:26.730]                   base::options(opts)
[09:28:26.730]                 }
[09:28:26.730]                 {
[09:28:26.730]                   {
[09:28:26.730]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:26.730]                     NULL
[09:28:26.730]                   }
[09:28:26.730]                   options(future.plan = NULL)
[09:28:26.730]                   if (is.na(NA_character_)) 
[09:28:26.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:26.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:26.730]                     .init = FALSE)
[09:28:26.730]                 }
[09:28:26.730]             }
[09:28:26.730]         }
[09:28:26.730]     })
[09:28:26.730]     if (TRUE) {
[09:28:26.730]         base::sink(type = "output", split = FALSE)
[09:28:26.730]         if (TRUE) {
[09:28:26.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:26.730]         }
[09:28:26.730]         else {
[09:28:26.730]             ...future.result["stdout"] <- base::list(NULL)
[09:28:26.730]         }
[09:28:26.730]         base::close(...future.stdout)
[09:28:26.730]         ...future.stdout <- NULL
[09:28:26.730]     }
[09:28:26.730]     ...future.result$conditions <- ...future.conditions
[09:28:26.730]     ...future.result$finished <- base::Sys.time()
[09:28:26.730]     ...future.result
[09:28:26.730] }
[09:28:26.781] MultisessionFuture started
[09:28:26.781] result() for ClusterFuture ...
[09:28:26.782] receiveMessageFromWorker() for ClusterFuture ...
[09:28:26.782] - Validating connection of MultisessionFuture
[09:28:26.812] - received message: FutureResult
[09:28:26.813] - Received FutureResult
[09:28:26.813] - Erased future from FutureRegistry
[09:28:26.813] result() for ClusterFuture ...
[09:28:26.813] - result already collected: FutureResult
[09:28:26.813] result() for ClusterFuture ... done
[09:28:26.813] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:26.813] result() for ClusterFuture ... done
[09:28:26.814] result() for ClusterFuture ...
[09:28:26.814] - result already collected: FutureResult
[09:28:26.814] result() for ClusterFuture ... done
[09:28:26.814] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:28:26.818] plan(): nbrOfWorkers() = 2
[09:28:26.818] future_lapply() ...
[09:28:26.822] Number of chunks: 2
[09:28:26.822] getGlobalsAndPackagesXApply() ...
[09:28:26.822]  - future.globals: TRUE
[09:28:26.822] getGlobalsAndPackages() ...
[09:28:26.823] Searching for globals...
[09:28:26.824] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:26.824] Searching for globals ... DONE
[09:28:26.824] Resolving globals: FALSE
[09:28:26.825] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:26.825] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:26.825] - globals: [1] ‘FUN’
[09:28:26.825] 
[09:28:26.825] getGlobalsAndPackages() ... DONE
[09:28:26.825]  - globals found/used: [n=1] ‘FUN’
[09:28:26.826]  - needed namespaces: [n=0] 
[09:28:26.826] Finding globals ... DONE
[09:28:26.826]  - use_args: TRUE
[09:28:26.826]  - Getting '...' globals ...
[09:28:26.826] resolve() on list ...
[09:28:26.826]  recursive: 0
[09:28:26.827]  length: 1
[09:28:26.827]  elements: ‘...’
[09:28:26.827]  length: 0 (resolved future 1)
[09:28:26.827] resolve() on list ... DONE
[09:28:26.827]    - '...' content: [n=0] 
[09:28:26.827] List of 1
[09:28:26.827]  $ ...: list()
[09:28:26.827]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:26.827]  - attr(*, "where")=List of 1
[09:28:26.827]   ..$ ...:<environment: 0x5566674772c0> 
[09:28:26.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:26.827]  - attr(*, "resolved")= logi TRUE
[09:28:26.827]  - attr(*, "total_size")= num NA
[09:28:26.830]  - Getting '...' globals ... DONE
[09:28:26.831] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:26.831] List of 2
[09:28:26.831]  $ ...future.FUN:function (x, ...)  
[09:28:26.831]  $ ...          : list()
[09:28:26.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:26.831]  - attr(*, "where")=List of 2
[09:28:26.831]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:26.831]   ..$ ...          :<environment: 0x5566674772c0> 
[09:28:26.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:26.831]  - attr(*, "resolved")= logi FALSE
[09:28:26.831]  - attr(*, "total_size")= num 1240
[09:28:26.834] Packages to be attached in all futures: [n=0] 
[09:28:26.834] getGlobalsAndPackagesXApply() ... DONE
[09:28:26.834] Number of futures (= number of chunks): 2
[09:28:26.834] Launching 2 futures (chunks) ...
[09:28:26.835] Chunk #1 of 2 ...
[09:28:26.835]  - Finding globals in 'X' for chunk #1 ...
[09:28:26.835] getGlobalsAndPackages() ...
[09:28:26.835] Searching for globals...
[09:28:26.835] 
[09:28:26.835] Searching for globals ... DONE
[09:28:26.835] - globals: [0] <none>
[09:28:26.835] getGlobalsAndPackages() ... DONE
[09:28:26.836]    + additional globals found: [n=0] 
[09:28:26.836]    + additional namespaces needed: [n=0] 
[09:28:26.836]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:26.836]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:26.836]  - seeds: <none>
[09:28:26.836]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.836] getGlobalsAndPackages() ...
[09:28:26.836] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.837] Resolving globals: FALSE
[09:28:26.837] Tweak future expression to call with '...' arguments ...
[09:28:26.837] {
[09:28:26.837]     do.call(function(...) {
[09:28:26.837]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.837]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.837]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.837]             on.exit(options(oopts), add = TRUE)
[09:28:26.837]         }
[09:28:26.837]         {
[09:28:26.837]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.837]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.837]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.837]             })
[09:28:26.837]         }
[09:28:26.837]     }, args = future.call.arguments)
[09:28:26.837] }
[09:28:26.837] Tweak future expression to call with '...' arguments ... DONE
[09:28:26.838] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.838] 
[09:28:26.838] getGlobalsAndPackages() ... DONE
[09:28:26.838] run() for ‘Future’ ...
[09:28:26.838] - state: ‘created’
[09:28:26.838] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:26.853] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:26.853]   - Field: ‘node’
[09:28:26.853]   - Field: ‘label’
[09:28:26.853]   - Field: ‘local’
[09:28:26.853]   - Field: ‘owner’
[09:28:26.853]   - Field: ‘envir’
[09:28:26.853]   - Field: ‘workers’
[09:28:26.853]   - Field: ‘packages’
[09:28:26.854]   - Field: ‘gc’
[09:28:26.854]   - Field: ‘conditions’
[09:28:26.854]   - Field: ‘persistent’
[09:28:26.854]   - Field: ‘expr’
[09:28:26.854]   - Field: ‘uuid’
[09:28:26.854]   - Field: ‘seed’
[09:28:26.854]   - Field: ‘version’
[09:28:26.854]   - Field: ‘result’
[09:28:26.854]   - Field: ‘asynchronous’
[09:28:26.855]   - Field: ‘calls’
[09:28:26.855]   - Field: ‘globals’
[09:28:26.855]   - Field: ‘stdout’
[09:28:26.855]   - Field: ‘earlySignal’
[09:28:26.855]   - Field: ‘lazy’
[09:28:26.855]   - Field: ‘state’
[09:28:26.855] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:26.855] - Launch lazy future ...
[09:28:26.856] Packages needed by the future expression (n = 0): <none>
[09:28:26.856] Packages needed by future strategies (n = 0): <none>
[09:28:26.856] {
[09:28:26.856]     {
[09:28:26.856]         {
[09:28:26.856]             ...future.startTime <- base::Sys.time()
[09:28:26.856]             {
[09:28:26.856]                 {
[09:28:26.856]                   {
[09:28:26.856]                     {
[09:28:26.856]                       base::local({
[09:28:26.856]                         has_future <- base::requireNamespace("future", 
[09:28:26.856]                           quietly = TRUE)
[09:28:26.856]                         if (has_future) {
[09:28:26.856]                           ns <- base::getNamespace("future")
[09:28:26.856]                           version <- ns[[".package"]][["version"]]
[09:28:26.856]                           if (is.null(version)) 
[09:28:26.856]                             version <- utils::packageVersion("future")
[09:28:26.856]                         }
[09:28:26.856]                         else {
[09:28:26.856]                           version <- NULL
[09:28:26.856]                         }
[09:28:26.856]                         if (!has_future || version < "1.8.0") {
[09:28:26.856]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:26.856]                             "", base::R.version$version.string), 
[09:28:26.856]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:26.856]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:26.856]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:26.856]                               "release", "version")], collapse = " "), 
[09:28:26.856]                             hostname = base::Sys.info()[["nodename"]])
[09:28:26.856]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:26.856]                             info)
[09:28:26.856]                           info <- base::paste(info, collapse = "; ")
[09:28:26.856]                           if (!has_future) {
[09:28:26.856]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:26.856]                               info)
[09:28:26.856]                           }
[09:28:26.856]                           else {
[09:28:26.856]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:26.856]                               info, version)
[09:28:26.856]                           }
[09:28:26.856]                           base::stop(msg)
[09:28:26.856]                         }
[09:28:26.856]                       })
[09:28:26.856]                     }
[09:28:26.856]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:26.856]                     base::options(mc.cores = 1L)
[09:28:26.856]                   }
[09:28:26.856]                   ...future.strategy.old <- future::plan("list")
[09:28:26.856]                   options(future.plan = NULL)
[09:28:26.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:26.856]                 }
[09:28:26.856]                 ...future.workdir <- getwd()
[09:28:26.856]             }
[09:28:26.856]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:26.856]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:26.856]         }
[09:28:26.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:26.856]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:26.856]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:26.856]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:26.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:26.856]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:26.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:26.856]             base::names(...future.oldOptions))
[09:28:26.856]     }
[09:28:26.856]     if (FALSE) {
[09:28:26.856]     }
[09:28:26.856]     else {
[09:28:26.856]         if (TRUE) {
[09:28:26.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:26.856]                 open = "w")
[09:28:26.856]         }
[09:28:26.856]         else {
[09:28:26.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:26.856]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:26.856]         }
[09:28:26.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:26.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:26.856]             base::sink(type = "output", split = FALSE)
[09:28:26.856]             base::close(...future.stdout)
[09:28:26.856]         }, add = TRUE)
[09:28:26.856]     }
[09:28:26.856]     ...future.frame <- base::sys.nframe()
[09:28:26.856]     ...future.conditions <- base::list()
[09:28:26.856]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:26.856]     if (FALSE) {
[09:28:26.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:26.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:26.856]     }
[09:28:26.856]     ...future.result <- base::tryCatch({
[09:28:26.856]         base::withCallingHandlers({
[09:28:26.856]             ...future.value <- base::withVisible(base::local({
[09:28:26.856]                 ...future.makeSendCondition <- base::local({
[09:28:26.856]                   sendCondition <- NULL
[09:28:26.856]                   function(frame = 1L) {
[09:28:26.856]                     if (is.function(sendCondition)) 
[09:28:26.856]                       return(sendCondition)
[09:28:26.856]                     ns <- getNamespace("parallel")
[09:28:26.856]                     if (exists("sendData", mode = "function", 
[09:28:26.856]                       envir = ns)) {
[09:28:26.856]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:26.856]                         envir = ns)
[09:28:26.856]                       envir <- sys.frame(frame)
[09:28:26.856]                       master <- NULL
[09:28:26.856]                       while (!identical(envir, .GlobalEnv) && 
[09:28:26.856]                         !identical(envir, emptyenv())) {
[09:28:26.856]                         if (exists("master", mode = "list", envir = envir, 
[09:28:26.856]                           inherits = FALSE)) {
[09:28:26.856]                           master <- get("master", mode = "list", 
[09:28:26.856]                             envir = envir, inherits = FALSE)
[09:28:26.856]                           if (inherits(master, c("SOCKnode", 
[09:28:26.856]                             "SOCK0node"))) {
[09:28:26.856]                             sendCondition <<- function(cond) {
[09:28:26.856]                               data <- list(type = "VALUE", value = cond, 
[09:28:26.856]                                 success = TRUE)
[09:28:26.856]                               parallel_sendData(master, data)
[09:28:26.856]                             }
[09:28:26.856]                             return(sendCondition)
[09:28:26.856]                           }
[09:28:26.856]                         }
[09:28:26.856]                         frame <- frame + 1L
[09:28:26.856]                         envir <- sys.frame(frame)
[09:28:26.856]                       }
[09:28:26.856]                     }
[09:28:26.856]                     sendCondition <<- function(cond) NULL
[09:28:26.856]                   }
[09:28:26.856]                 })
[09:28:26.856]                 withCallingHandlers({
[09:28:26.856]                   {
[09:28:26.856]                     do.call(function(...) {
[09:28:26.856]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.856]                       if (!identical(...future.globals.maxSize.org, 
[09:28:26.856]                         ...future.globals.maxSize)) {
[09:28:26.856]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.856]                         on.exit(options(oopts), add = TRUE)
[09:28:26.856]                       }
[09:28:26.856]                       {
[09:28:26.856]                         lapply(seq_along(...future.elements_ii), 
[09:28:26.856]                           FUN = function(jj) {
[09:28:26.856]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.856]                             ...future.FUN(...future.X_jj, ...)
[09:28:26.856]                           })
[09:28:26.856]                       }
[09:28:26.856]                     }, args = future.call.arguments)
[09:28:26.856]                   }
[09:28:26.856]                 }, immediateCondition = function(cond) {
[09:28:26.856]                   sendCondition <- ...future.makeSendCondition()
[09:28:26.856]                   sendCondition(cond)
[09:28:26.856]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.856]                   {
[09:28:26.856]                     inherits <- base::inherits
[09:28:26.856]                     invokeRestart <- base::invokeRestart
[09:28:26.856]                     is.null <- base::is.null
[09:28:26.856]                     muffled <- FALSE
[09:28:26.856]                     if (inherits(cond, "message")) {
[09:28:26.856]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:26.856]                       if (muffled) 
[09:28:26.856]                         invokeRestart("muffleMessage")
[09:28:26.856]                     }
[09:28:26.856]                     else if (inherits(cond, "warning")) {
[09:28:26.856]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:26.856]                       if (muffled) 
[09:28:26.856]                         invokeRestart("muffleWarning")
[09:28:26.856]                     }
[09:28:26.856]                     else if (inherits(cond, "condition")) {
[09:28:26.856]                       if (!is.null(pattern)) {
[09:28:26.856]                         computeRestarts <- base::computeRestarts
[09:28:26.856]                         grepl <- base::grepl
[09:28:26.856]                         restarts <- computeRestarts(cond)
[09:28:26.856]                         for (restart in restarts) {
[09:28:26.856]                           name <- restart$name
[09:28:26.856]                           if (is.null(name)) 
[09:28:26.856]                             next
[09:28:26.856]                           if (!grepl(pattern, name)) 
[09:28:26.856]                             next
[09:28:26.856]                           invokeRestart(restart)
[09:28:26.856]                           muffled <- TRUE
[09:28:26.856]                           break
[09:28:26.856]                         }
[09:28:26.856]                       }
[09:28:26.856]                     }
[09:28:26.856]                     invisible(muffled)
[09:28:26.856]                   }
[09:28:26.856]                   muffleCondition(cond)
[09:28:26.856]                 })
[09:28:26.856]             }))
[09:28:26.856]             future::FutureResult(value = ...future.value$value, 
[09:28:26.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.856]                   ...future.rng), globalenv = if (FALSE) 
[09:28:26.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:26.856]                     ...future.globalenv.names))
[09:28:26.856]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:26.856]         }, condition = base::local({
[09:28:26.856]             c <- base::c
[09:28:26.856]             inherits <- base::inherits
[09:28:26.856]             invokeRestart <- base::invokeRestart
[09:28:26.856]             length <- base::length
[09:28:26.856]             list <- base::list
[09:28:26.856]             seq.int <- base::seq.int
[09:28:26.856]             signalCondition <- base::signalCondition
[09:28:26.856]             sys.calls <- base::sys.calls
[09:28:26.856]             `[[` <- base::`[[`
[09:28:26.856]             `+` <- base::`+`
[09:28:26.856]             `<<-` <- base::`<<-`
[09:28:26.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:26.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:26.856]                   3L)]
[09:28:26.856]             }
[09:28:26.856]             function(cond) {
[09:28:26.856]                 is_error <- inherits(cond, "error")
[09:28:26.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:26.856]                   NULL)
[09:28:26.856]                 if (is_error) {
[09:28:26.856]                   sessionInformation <- function() {
[09:28:26.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:26.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:26.856]                       search = base::search(), system = base::Sys.info())
[09:28:26.856]                   }
[09:28:26.856]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:26.856]                     cond$call), session = sessionInformation(), 
[09:28:26.856]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:26.856]                   signalCondition(cond)
[09:28:26.856]                 }
[09:28:26.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:26.856]                 "immediateCondition"))) {
[09:28:26.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:26.856]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:26.856]                   if (TRUE && !signal) {
[09:28:26.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.856]                     {
[09:28:26.856]                       inherits <- base::inherits
[09:28:26.856]                       invokeRestart <- base::invokeRestart
[09:28:26.856]                       is.null <- base::is.null
[09:28:26.856]                       muffled <- FALSE
[09:28:26.856]                       if (inherits(cond, "message")) {
[09:28:26.856]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.856]                         if (muffled) 
[09:28:26.856]                           invokeRestart("muffleMessage")
[09:28:26.856]                       }
[09:28:26.856]                       else if (inherits(cond, "warning")) {
[09:28:26.856]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.856]                         if (muffled) 
[09:28:26.856]                           invokeRestart("muffleWarning")
[09:28:26.856]                       }
[09:28:26.856]                       else if (inherits(cond, "condition")) {
[09:28:26.856]                         if (!is.null(pattern)) {
[09:28:26.856]                           computeRestarts <- base::computeRestarts
[09:28:26.856]                           grepl <- base::grepl
[09:28:26.856]                           restarts <- computeRestarts(cond)
[09:28:26.856]                           for (restart in restarts) {
[09:28:26.856]                             name <- restart$name
[09:28:26.856]                             if (is.null(name)) 
[09:28:26.856]                               next
[09:28:26.856]                             if (!grepl(pattern, name)) 
[09:28:26.856]                               next
[09:28:26.856]                             invokeRestart(restart)
[09:28:26.856]                             muffled <- TRUE
[09:28:26.856]                             break
[09:28:26.856]                           }
[09:28:26.856]                         }
[09:28:26.856]                       }
[09:28:26.856]                       invisible(muffled)
[09:28:26.856]                     }
[09:28:26.856]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.856]                   }
[09:28:26.856]                 }
[09:28:26.856]                 else {
[09:28:26.856]                   if (TRUE) {
[09:28:26.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.856]                     {
[09:28:26.856]                       inherits <- base::inherits
[09:28:26.856]                       invokeRestart <- base::invokeRestart
[09:28:26.856]                       is.null <- base::is.null
[09:28:26.856]                       muffled <- FALSE
[09:28:26.856]                       if (inherits(cond, "message")) {
[09:28:26.856]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.856]                         if (muffled) 
[09:28:26.856]                           invokeRestart("muffleMessage")
[09:28:26.856]                       }
[09:28:26.856]                       else if (inherits(cond, "warning")) {
[09:28:26.856]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.856]                         if (muffled) 
[09:28:26.856]                           invokeRestart("muffleWarning")
[09:28:26.856]                       }
[09:28:26.856]                       else if (inherits(cond, "condition")) {
[09:28:26.856]                         if (!is.null(pattern)) {
[09:28:26.856]                           computeRestarts <- base::computeRestarts
[09:28:26.856]                           grepl <- base::grepl
[09:28:26.856]                           restarts <- computeRestarts(cond)
[09:28:26.856]                           for (restart in restarts) {
[09:28:26.856]                             name <- restart$name
[09:28:26.856]                             if (is.null(name)) 
[09:28:26.856]                               next
[09:28:26.856]                             if (!grepl(pattern, name)) 
[09:28:26.856]                               next
[09:28:26.856]                             invokeRestart(restart)
[09:28:26.856]                             muffled <- TRUE
[09:28:26.856]                             break
[09:28:26.856]                           }
[09:28:26.856]                         }
[09:28:26.856]                       }
[09:28:26.856]                       invisible(muffled)
[09:28:26.856]                     }
[09:28:26.856]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.856]                   }
[09:28:26.856]                 }
[09:28:26.856]             }
[09:28:26.856]         }))
[09:28:26.856]     }, error = function(ex) {
[09:28:26.856]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:26.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.856]                 ...future.rng), started = ...future.startTime, 
[09:28:26.856]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:26.856]             version = "1.8"), class = "FutureResult")
[09:28:26.856]     }, finally = {
[09:28:26.856]         if (!identical(...future.workdir, getwd())) 
[09:28:26.856]             setwd(...future.workdir)
[09:28:26.856]         {
[09:28:26.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:26.856]                 ...future.oldOptions$nwarnings <- NULL
[09:28:26.856]             }
[09:28:26.856]             base::options(...future.oldOptions)
[09:28:26.856]             if (.Platform$OS.type == "windows") {
[09:28:26.856]                 old_names <- names(...future.oldEnvVars)
[09:28:26.856]                 envs <- base::Sys.getenv()
[09:28:26.856]                 names <- names(envs)
[09:28:26.856]                 common <- intersect(names, old_names)
[09:28:26.856]                 added <- setdiff(names, old_names)
[09:28:26.856]                 removed <- setdiff(old_names, names)
[09:28:26.856]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:26.856]                   envs[common]]
[09:28:26.856]                 NAMES <- toupper(changed)
[09:28:26.856]                 args <- list()
[09:28:26.856]                 for (kk in seq_along(NAMES)) {
[09:28:26.856]                   name <- changed[[kk]]
[09:28:26.856]                   NAME <- NAMES[[kk]]
[09:28:26.856]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.856]                     next
[09:28:26.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.856]                 }
[09:28:26.856]                 NAMES <- toupper(added)
[09:28:26.856]                 for (kk in seq_along(NAMES)) {
[09:28:26.856]                   name <- added[[kk]]
[09:28:26.856]                   NAME <- NAMES[[kk]]
[09:28:26.856]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.856]                     next
[09:28:26.856]                   args[[name]] <- ""
[09:28:26.856]                 }
[09:28:26.856]                 NAMES <- toupper(removed)
[09:28:26.856]                 for (kk in seq_along(NAMES)) {
[09:28:26.856]                   name <- removed[[kk]]
[09:28:26.856]                   NAME <- NAMES[[kk]]
[09:28:26.856]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.856]                     next
[09:28:26.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.856]                 }
[09:28:26.856]                 if (length(args) > 0) 
[09:28:26.856]                   base::do.call(base::Sys.setenv, args = args)
[09:28:26.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:26.856]             }
[09:28:26.856]             else {
[09:28:26.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:26.856]             }
[09:28:26.856]             {
[09:28:26.856]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:26.856]                   0L) {
[09:28:26.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:26.856]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:26.856]                   base::options(opts)
[09:28:26.856]                 }
[09:28:26.856]                 {
[09:28:26.856]                   {
[09:28:26.856]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:26.856]                     NULL
[09:28:26.856]                   }
[09:28:26.856]                   options(future.plan = NULL)
[09:28:26.856]                   if (is.na(NA_character_)) 
[09:28:26.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:26.856]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:26.856]                     .init = FALSE)
[09:28:26.856]                 }
[09:28:26.856]             }
[09:28:26.856]         }
[09:28:26.856]     })
[09:28:26.856]     if (TRUE) {
[09:28:26.856]         base::sink(type = "output", split = FALSE)
[09:28:26.856]         if (TRUE) {
[09:28:26.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:26.856]         }
[09:28:26.856]         else {
[09:28:26.856]             ...future.result["stdout"] <- base::list(NULL)
[09:28:26.856]         }
[09:28:26.856]         base::close(...future.stdout)
[09:28:26.856]         ...future.stdout <- NULL
[09:28:26.856]     }
[09:28:26.856]     ...future.result$conditions <- ...future.conditions
[09:28:26.856]     ...future.result$finished <- base::Sys.time()
[09:28:26.856]     ...future.result
[09:28:26.856] }
[09:28:26.859] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[09:28:26.859] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[09:28:26.860] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[09:28:26.860] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:26.861] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:26.861] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[09:28:26.861] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[09:28:26.861] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:26.862] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:26.862] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:28:26.862] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:28:26.863] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[09:28:26.863] MultisessionFuture started
[09:28:26.863] - Launch lazy future ... done
[09:28:26.863] run() for ‘MultisessionFuture’ ... done
[09:28:26.864] Created future:
[09:28:26.864] MultisessionFuture:
[09:28:26.864] Label: ‘future_eapply-1’
[09:28:26.864] Expression:
[09:28:26.864] {
[09:28:26.864]     do.call(function(...) {
[09:28:26.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.864]             on.exit(options(oopts), add = TRUE)
[09:28:26.864]         }
[09:28:26.864]         {
[09:28:26.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.864]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.864]             })
[09:28:26.864]         }
[09:28:26.864]     }, args = future.call.arguments)
[09:28:26.864] }
[09:28:26.864] Lazy evaluation: FALSE
[09:28:26.864] Asynchronous evaluation: TRUE
[09:28:26.864] Local evaluation: TRUE
[09:28:26.864] Environment: R_GlobalEnv
[09:28:26.864] Capture standard output: TRUE
[09:28:26.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:26.864] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:26.864] Packages: <none>
[09:28:26.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:26.864] Resolved: FALSE
[09:28:26.864] Value: <not collected>
[09:28:26.864] Conditions captured: <none>
[09:28:26.864] Early signaling: FALSE
[09:28:26.864] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:26.864] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.876] Chunk #1 of 2 ... DONE
[09:28:26.876] Chunk #2 of 2 ...
[09:28:26.876]  - Finding globals in 'X' for chunk #2 ...
[09:28:26.876] getGlobalsAndPackages() ...
[09:28:26.876] Searching for globals...
[09:28:26.877] 
[09:28:26.877] Searching for globals ... DONE
[09:28:26.877] - globals: [0] <none>
[09:28:26.877] getGlobalsAndPackages() ... DONE
[09:28:26.877]    + additional globals found: [n=0] 
[09:28:26.877]    + additional namespaces needed: [n=0] 
[09:28:26.877]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:26.877]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:26.877]  - seeds: <none>
[09:28:26.878]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.878] getGlobalsAndPackages() ...
[09:28:26.878] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.878] Resolving globals: FALSE
[09:28:26.878] Tweak future expression to call with '...' arguments ...
[09:28:26.878] {
[09:28:26.878]     do.call(function(...) {
[09:28:26.878]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.878]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.878]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.878]             on.exit(options(oopts), add = TRUE)
[09:28:26.878]         }
[09:28:26.878]         {
[09:28:26.878]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.878]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.878]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.878]             })
[09:28:26.878]         }
[09:28:26.878]     }, args = future.call.arguments)
[09:28:26.878] }
[09:28:26.879] Tweak future expression to call with '...' arguments ... DONE
[09:28:26.879] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:26.879] 
[09:28:26.879] getGlobalsAndPackages() ... DONE
[09:28:26.879] run() for ‘Future’ ...
[09:28:26.880] - state: ‘created’
[09:28:26.880] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:26.894] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:26.894]   - Field: ‘node’
[09:28:26.894]   - Field: ‘label’
[09:28:26.894]   - Field: ‘local’
[09:28:26.894]   - Field: ‘owner’
[09:28:26.894]   - Field: ‘envir’
[09:28:26.894]   - Field: ‘workers’
[09:28:26.894]   - Field: ‘packages’
[09:28:26.895]   - Field: ‘gc’
[09:28:26.895]   - Field: ‘conditions’
[09:28:26.895]   - Field: ‘persistent’
[09:28:26.895]   - Field: ‘expr’
[09:28:26.895]   - Field: ‘uuid’
[09:28:26.895]   - Field: ‘seed’
[09:28:26.895]   - Field: ‘version’
[09:28:26.895]   - Field: ‘result’
[09:28:26.895]   - Field: ‘asynchronous’
[09:28:26.896]   - Field: ‘calls’
[09:28:26.896]   - Field: ‘globals’
[09:28:26.896]   - Field: ‘stdout’
[09:28:26.896]   - Field: ‘earlySignal’
[09:28:26.896]   - Field: ‘lazy’
[09:28:26.896]   - Field: ‘state’
[09:28:26.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:26.896] - Launch lazy future ...
[09:28:26.897] Packages needed by the future expression (n = 0): <none>
[09:28:26.897] Packages needed by future strategies (n = 0): <none>
[09:28:26.897] {
[09:28:26.897]     {
[09:28:26.897]         {
[09:28:26.897]             ...future.startTime <- base::Sys.time()
[09:28:26.897]             {
[09:28:26.897]                 {
[09:28:26.897]                   {
[09:28:26.897]                     {
[09:28:26.897]                       base::local({
[09:28:26.897]                         has_future <- base::requireNamespace("future", 
[09:28:26.897]                           quietly = TRUE)
[09:28:26.897]                         if (has_future) {
[09:28:26.897]                           ns <- base::getNamespace("future")
[09:28:26.897]                           version <- ns[[".package"]][["version"]]
[09:28:26.897]                           if (is.null(version)) 
[09:28:26.897]                             version <- utils::packageVersion("future")
[09:28:26.897]                         }
[09:28:26.897]                         else {
[09:28:26.897]                           version <- NULL
[09:28:26.897]                         }
[09:28:26.897]                         if (!has_future || version < "1.8.0") {
[09:28:26.897]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:26.897]                             "", base::R.version$version.string), 
[09:28:26.897]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:26.897]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:26.897]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:26.897]                               "release", "version")], collapse = " "), 
[09:28:26.897]                             hostname = base::Sys.info()[["nodename"]])
[09:28:26.897]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:26.897]                             info)
[09:28:26.897]                           info <- base::paste(info, collapse = "; ")
[09:28:26.897]                           if (!has_future) {
[09:28:26.897]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:26.897]                               info)
[09:28:26.897]                           }
[09:28:26.897]                           else {
[09:28:26.897]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:26.897]                               info, version)
[09:28:26.897]                           }
[09:28:26.897]                           base::stop(msg)
[09:28:26.897]                         }
[09:28:26.897]                       })
[09:28:26.897]                     }
[09:28:26.897]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:26.897]                     base::options(mc.cores = 1L)
[09:28:26.897]                   }
[09:28:26.897]                   ...future.strategy.old <- future::plan("list")
[09:28:26.897]                   options(future.plan = NULL)
[09:28:26.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.897]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:26.897]                 }
[09:28:26.897]                 ...future.workdir <- getwd()
[09:28:26.897]             }
[09:28:26.897]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:26.897]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:26.897]         }
[09:28:26.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:26.897]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:26.897]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:26.897]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:26.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:26.897]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:26.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:26.897]             base::names(...future.oldOptions))
[09:28:26.897]     }
[09:28:26.897]     if (FALSE) {
[09:28:26.897]     }
[09:28:26.897]     else {
[09:28:26.897]         if (TRUE) {
[09:28:26.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:26.897]                 open = "w")
[09:28:26.897]         }
[09:28:26.897]         else {
[09:28:26.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:26.897]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:26.897]         }
[09:28:26.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:26.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:26.897]             base::sink(type = "output", split = FALSE)
[09:28:26.897]             base::close(...future.stdout)
[09:28:26.897]         }, add = TRUE)
[09:28:26.897]     }
[09:28:26.897]     ...future.frame <- base::sys.nframe()
[09:28:26.897]     ...future.conditions <- base::list()
[09:28:26.897]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:26.897]     if (FALSE) {
[09:28:26.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:26.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:26.897]     }
[09:28:26.897]     ...future.result <- base::tryCatch({
[09:28:26.897]         base::withCallingHandlers({
[09:28:26.897]             ...future.value <- base::withVisible(base::local({
[09:28:26.897]                 ...future.makeSendCondition <- base::local({
[09:28:26.897]                   sendCondition <- NULL
[09:28:26.897]                   function(frame = 1L) {
[09:28:26.897]                     if (is.function(sendCondition)) 
[09:28:26.897]                       return(sendCondition)
[09:28:26.897]                     ns <- getNamespace("parallel")
[09:28:26.897]                     if (exists("sendData", mode = "function", 
[09:28:26.897]                       envir = ns)) {
[09:28:26.897]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:26.897]                         envir = ns)
[09:28:26.897]                       envir <- sys.frame(frame)
[09:28:26.897]                       master <- NULL
[09:28:26.897]                       while (!identical(envir, .GlobalEnv) && 
[09:28:26.897]                         !identical(envir, emptyenv())) {
[09:28:26.897]                         if (exists("master", mode = "list", envir = envir, 
[09:28:26.897]                           inherits = FALSE)) {
[09:28:26.897]                           master <- get("master", mode = "list", 
[09:28:26.897]                             envir = envir, inherits = FALSE)
[09:28:26.897]                           if (inherits(master, c("SOCKnode", 
[09:28:26.897]                             "SOCK0node"))) {
[09:28:26.897]                             sendCondition <<- function(cond) {
[09:28:26.897]                               data <- list(type = "VALUE", value = cond, 
[09:28:26.897]                                 success = TRUE)
[09:28:26.897]                               parallel_sendData(master, data)
[09:28:26.897]                             }
[09:28:26.897]                             return(sendCondition)
[09:28:26.897]                           }
[09:28:26.897]                         }
[09:28:26.897]                         frame <- frame + 1L
[09:28:26.897]                         envir <- sys.frame(frame)
[09:28:26.897]                       }
[09:28:26.897]                     }
[09:28:26.897]                     sendCondition <<- function(cond) NULL
[09:28:26.897]                   }
[09:28:26.897]                 })
[09:28:26.897]                 withCallingHandlers({
[09:28:26.897]                   {
[09:28:26.897]                     do.call(function(...) {
[09:28:26.897]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.897]                       if (!identical(...future.globals.maxSize.org, 
[09:28:26.897]                         ...future.globals.maxSize)) {
[09:28:26.897]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.897]                         on.exit(options(oopts), add = TRUE)
[09:28:26.897]                       }
[09:28:26.897]                       {
[09:28:26.897]                         lapply(seq_along(...future.elements_ii), 
[09:28:26.897]                           FUN = function(jj) {
[09:28:26.897]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.897]                             ...future.FUN(...future.X_jj, ...)
[09:28:26.897]                           })
[09:28:26.897]                       }
[09:28:26.897]                     }, args = future.call.arguments)
[09:28:26.897]                   }
[09:28:26.897]                 }, immediateCondition = function(cond) {
[09:28:26.897]                   sendCondition <- ...future.makeSendCondition()
[09:28:26.897]                   sendCondition(cond)
[09:28:26.897]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.897]                   {
[09:28:26.897]                     inherits <- base::inherits
[09:28:26.897]                     invokeRestart <- base::invokeRestart
[09:28:26.897]                     is.null <- base::is.null
[09:28:26.897]                     muffled <- FALSE
[09:28:26.897]                     if (inherits(cond, "message")) {
[09:28:26.897]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:26.897]                       if (muffled) 
[09:28:26.897]                         invokeRestart("muffleMessage")
[09:28:26.897]                     }
[09:28:26.897]                     else if (inherits(cond, "warning")) {
[09:28:26.897]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:26.897]                       if (muffled) 
[09:28:26.897]                         invokeRestart("muffleWarning")
[09:28:26.897]                     }
[09:28:26.897]                     else if (inherits(cond, "condition")) {
[09:28:26.897]                       if (!is.null(pattern)) {
[09:28:26.897]                         computeRestarts <- base::computeRestarts
[09:28:26.897]                         grepl <- base::grepl
[09:28:26.897]                         restarts <- computeRestarts(cond)
[09:28:26.897]                         for (restart in restarts) {
[09:28:26.897]                           name <- restart$name
[09:28:26.897]                           if (is.null(name)) 
[09:28:26.897]                             next
[09:28:26.897]                           if (!grepl(pattern, name)) 
[09:28:26.897]                             next
[09:28:26.897]                           invokeRestart(restart)
[09:28:26.897]                           muffled <- TRUE
[09:28:26.897]                           break
[09:28:26.897]                         }
[09:28:26.897]                       }
[09:28:26.897]                     }
[09:28:26.897]                     invisible(muffled)
[09:28:26.897]                   }
[09:28:26.897]                   muffleCondition(cond)
[09:28:26.897]                 })
[09:28:26.897]             }))
[09:28:26.897]             future::FutureResult(value = ...future.value$value, 
[09:28:26.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.897]                   ...future.rng), globalenv = if (FALSE) 
[09:28:26.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:26.897]                     ...future.globalenv.names))
[09:28:26.897]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:26.897]         }, condition = base::local({
[09:28:26.897]             c <- base::c
[09:28:26.897]             inherits <- base::inherits
[09:28:26.897]             invokeRestart <- base::invokeRestart
[09:28:26.897]             length <- base::length
[09:28:26.897]             list <- base::list
[09:28:26.897]             seq.int <- base::seq.int
[09:28:26.897]             signalCondition <- base::signalCondition
[09:28:26.897]             sys.calls <- base::sys.calls
[09:28:26.897]             `[[` <- base::`[[`
[09:28:26.897]             `+` <- base::`+`
[09:28:26.897]             `<<-` <- base::`<<-`
[09:28:26.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:26.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:26.897]                   3L)]
[09:28:26.897]             }
[09:28:26.897]             function(cond) {
[09:28:26.897]                 is_error <- inherits(cond, "error")
[09:28:26.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:26.897]                   NULL)
[09:28:26.897]                 if (is_error) {
[09:28:26.897]                   sessionInformation <- function() {
[09:28:26.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:26.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:26.897]                       search = base::search(), system = base::Sys.info())
[09:28:26.897]                   }
[09:28:26.897]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:26.897]                     cond$call), session = sessionInformation(), 
[09:28:26.897]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:26.897]                   signalCondition(cond)
[09:28:26.897]                 }
[09:28:26.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:26.897]                 "immediateCondition"))) {
[09:28:26.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:26.897]                   ...future.conditions[[length(...future.conditions) + 
[09:28:26.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:26.897]                   if (TRUE && !signal) {
[09:28:26.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.897]                     {
[09:28:26.897]                       inherits <- base::inherits
[09:28:26.897]                       invokeRestart <- base::invokeRestart
[09:28:26.897]                       is.null <- base::is.null
[09:28:26.897]                       muffled <- FALSE
[09:28:26.897]                       if (inherits(cond, "message")) {
[09:28:26.897]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.897]                         if (muffled) 
[09:28:26.897]                           invokeRestart("muffleMessage")
[09:28:26.897]                       }
[09:28:26.897]                       else if (inherits(cond, "warning")) {
[09:28:26.897]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.897]                         if (muffled) 
[09:28:26.897]                           invokeRestart("muffleWarning")
[09:28:26.897]                       }
[09:28:26.897]                       else if (inherits(cond, "condition")) {
[09:28:26.897]                         if (!is.null(pattern)) {
[09:28:26.897]                           computeRestarts <- base::computeRestarts
[09:28:26.897]                           grepl <- base::grepl
[09:28:26.897]                           restarts <- computeRestarts(cond)
[09:28:26.897]                           for (restart in restarts) {
[09:28:26.897]                             name <- restart$name
[09:28:26.897]                             if (is.null(name)) 
[09:28:26.897]                               next
[09:28:26.897]                             if (!grepl(pattern, name)) 
[09:28:26.897]                               next
[09:28:26.897]                             invokeRestart(restart)
[09:28:26.897]                             muffled <- TRUE
[09:28:26.897]                             break
[09:28:26.897]                           }
[09:28:26.897]                         }
[09:28:26.897]                       }
[09:28:26.897]                       invisible(muffled)
[09:28:26.897]                     }
[09:28:26.897]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.897]                   }
[09:28:26.897]                 }
[09:28:26.897]                 else {
[09:28:26.897]                   if (TRUE) {
[09:28:26.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:26.897]                     {
[09:28:26.897]                       inherits <- base::inherits
[09:28:26.897]                       invokeRestart <- base::invokeRestart
[09:28:26.897]                       is.null <- base::is.null
[09:28:26.897]                       muffled <- FALSE
[09:28:26.897]                       if (inherits(cond, "message")) {
[09:28:26.897]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:26.897]                         if (muffled) 
[09:28:26.897]                           invokeRestart("muffleMessage")
[09:28:26.897]                       }
[09:28:26.897]                       else if (inherits(cond, "warning")) {
[09:28:26.897]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:26.897]                         if (muffled) 
[09:28:26.897]                           invokeRestart("muffleWarning")
[09:28:26.897]                       }
[09:28:26.897]                       else if (inherits(cond, "condition")) {
[09:28:26.897]                         if (!is.null(pattern)) {
[09:28:26.897]                           computeRestarts <- base::computeRestarts
[09:28:26.897]                           grepl <- base::grepl
[09:28:26.897]                           restarts <- computeRestarts(cond)
[09:28:26.897]                           for (restart in restarts) {
[09:28:26.897]                             name <- restart$name
[09:28:26.897]                             if (is.null(name)) 
[09:28:26.897]                               next
[09:28:26.897]                             if (!grepl(pattern, name)) 
[09:28:26.897]                               next
[09:28:26.897]                             invokeRestart(restart)
[09:28:26.897]                             muffled <- TRUE
[09:28:26.897]                             break
[09:28:26.897]                           }
[09:28:26.897]                         }
[09:28:26.897]                       }
[09:28:26.897]                       invisible(muffled)
[09:28:26.897]                     }
[09:28:26.897]                     muffleCondition(cond, pattern = "^muffle")
[09:28:26.897]                   }
[09:28:26.897]                 }
[09:28:26.897]             }
[09:28:26.897]         }))
[09:28:26.897]     }, error = function(ex) {
[09:28:26.897]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:26.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:26.897]                 ...future.rng), started = ...future.startTime, 
[09:28:26.897]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:26.897]             version = "1.8"), class = "FutureResult")
[09:28:26.897]     }, finally = {
[09:28:26.897]         if (!identical(...future.workdir, getwd())) 
[09:28:26.897]             setwd(...future.workdir)
[09:28:26.897]         {
[09:28:26.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:26.897]                 ...future.oldOptions$nwarnings <- NULL
[09:28:26.897]             }
[09:28:26.897]             base::options(...future.oldOptions)
[09:28:26.897]             if (.Platform$OS.type == "windows") {
[09:28:26.897]                 old_names <- names(...future.oldEnvVars)
[09:28:26.897]                 envs <- base::Sys.getenv()
[09:28:26.897]                 names <- names(envs)
[09:28:26.897]                 common <- intersect(names, old_names)
[09:28:26.897]                 added <- setdiff(names, old_names)
[09:28:26.897]                 removed <- setdiff(old_names, names)
[09:28:26.897]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:26.897]                   envs[common]]
[09:28:26.897]                 NAMES <- toupper(changed)
[09:28:26.897]                 args <- list()
[09:28:26.897]                 for (kk in seq_along(NAMES)) {
[09:28:26.897]                   name <- changed[[kk]]
[09:28:26.897]                   NAME <- NAMES[[kk]]
[09:28:26.897]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.897]                     next
[09:28:26.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.897]                 }
[09:28:26.897]                 NAMES <- toupper(added)
[09:28:26.897]                 for (kk in seq_along(NAMES)) {
[09:28:26.897]                   name <- added[[kk]]
[09:28:26.897]                   NAME <- NAMES[[kk]]
[09:28:26.897]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.897]                     next
[09:28:26.897]                   args[[name]] <- ""
[09:28:26.897]                 }
[09:28:26.897]                 NAMES <- toupper(removed)
[09:28:26.897]                 for (kk in seq_along(NAMES)) {
[09:28:26.897]                   name <- removed[[kk]]
[09:28:26.897]                   NAME <- NAMES[[kk]]
[09:28:26.897]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:26.897]                     next
[09:28:26.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:26.897]                 }
[09:28:26.897]                 if (length(args) > 0) 
[09:28:26.897]                   base::do.call(base::Sys.setenv, args = args)
[09:28:26.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:26.897]             }
[09:28:26.897]             else {
[09:28:26.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:26.897]             }
[09:28:26.897]             {
[09:28:26.897]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:26.897]                   0L) {
[09:28:26.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:26.897]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:26.897]                   base::options(opts)
[09:28:26.897]                 }
[09:28:26.897]                 {
[09:28:26.897]                   {
[09:28:26.897]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:26.897]                     NULL
[09:28:26.897]                   }
[09:28:26.897]                   options(future.plan = NULL)
[09:28:26.897]                   if (is.na(NA_character_)) 
[09:28:26.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:26.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:26.897]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:26.897]                     .init = FALSE)
[09:28:26.897]                 }
[09:28:26.897]             }
[09:28:26.897]         }
[09:28:26.897]     })
[09:28:26.897]     if (TRUE) {
[09:28:26.897]         base::sink(type = "output", split = FALSE)
[09:28:26.897]         if (TRUE) {
[09:28:26.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:26.897]         }
[09:28:26.897]         else {
[09:28:26.897]             ...future.result["stdout"] <- base::list(NULL)
[09:28:26.897]         }
[09:28:26.897]         base::close(...future.stdout)
[09:28:26.897]         ...future.stdout <- NULL
[09:28:26.897]     }
[09:28:26.897]     ...future.result$conditions <- ...future.conditions
[09:28:26.897]     ...future.result$finished <- base::Sys.time()
[09:28:26.897]     ...future.result
[09:28:26.897] }
[09:28:26.949] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[09:28:26.949] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[09:28:26.950] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[09:28:26.950] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:26.950] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:26.951] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[09:28:26.951] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[09:28:26.951] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:26.952] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:26.952] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:28:26.952] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:28:26.952] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[09:28:26.953] MultisessionFuture started
[09:28:26.953] - Launch lazy future ... done
[09:28:26.953] run() for ‘MultisessionFuture’ ... done
[09:28:26.954] Created future:
[09:28:26.954] MultisessionFuture:
[09:28:26.954] Label: ‘future_eapply-2’
[09:28:26.954] Expression:
[09:28:26.954] {
[09:28:26.954]     do.call(function(...) {
[09:28:26.954]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:26.954]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:26.954]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:26.954]             on.exit(options(oopts), add = TRUE)
[09:28:26.954]         }
[09:28:26.954]         {
[09:28:26.954]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:26.954]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:26.954]                 ...future.FUN(...future.X_jj, ...)
[09:28:26.954]             })
[09:28:26.954]         }
[09:28:26.954]     }, args = future.call.arguments)
[09:28:26.954] }
[09:28:26.954] Lazy evaluation: FALSE
[09:28:26.954] Asynchronous evaluation: TRUE
[09:28:26.954] Local evaluation: TRUE
[09:28:26.954] Environment: R_GlobalEnv
[09:28:26.954] Capture standard output: TRUE
[09:28:26.954] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:26.954] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:26.954] Packages: <none>
[09:28:26.954] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:26.954] Resolved: FALSE
[09:28:26.954] Value: <not collected>
[09:28:26.954] Conditions captured: <none>
[09:28:26.954] Early signaling: FALSE
[09:28:26.954] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:26.954] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:26.966] Chunk #2 of 2 ... DONE
[09:28:26.966] Launching 2 futures (chunks) ... DONE
[09:28:26.966] Resolving 2 futures (chunks) ...
[09:28:26.966] resolve() on list ...
[09:28:26.966]  recursive: 0
[09:28:26.966]  length: 2
[09:28:26.966] 
[09:28:26.967] receiveMessageFromWorker() for ClusterFuture ...
[09:28:26.967] - Validating connection of MultisessionFuture
[09:28:26.967] - received message: FutureResult
[09:28:26.967] - Received FutureResult
[09:28:26.968] - Erased future from FutureRegistry
[09:28:26.968] result() for ClusterFuture ...
[09:28:26.968] - result already collected: FutureResult
[09:28:26.968] result() for ClusterFuture ... done
[09:28:26.968] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:26.968] Future #1
[09:28:26.968] result() for ClusterFuture ...
[09:28:26.969] - result already collected: FutureResult
[09:28:26.969] result() for ClusterFuture ... done
[09:28:26.969] result() for ClusterFuture ...
[09:28:26.969] - result already collected: FutureResult
[09:28:26.969] result() for ClusterFuture ... done
[09:28:26.969] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:26.969] - nx: 2
[09:28:26.972] - relay: TRUE
[09:28:26.972] - stdout: TRUE
[09:28:26.972] - signal: TRUE
[09:28:26.972] - resignal: FALSE
[09:28:26.972] - force: TRUE
[09:28:26.972] - relayed: [n=2] FALSE, FALSE
[09:28:26.972] - queued futures: [n=2] FALSE, FALSE
[09:28:26.973]  - until=1
[09:28:26.973]  - relaying element #1
[09:28:26.973] result() for ClusterFuture ...
[09:28:26.973] - result already collected: FutureResult
[09:28:26.973] result() for ClusterFuture ... done
[09:28:26.973] result() for ClusterFuture ...
[09:28:26.973] - result already collected: FutureResult
[09:28:26.973] result() for ClusterFuture ... done
[09:28:26.973] result() for ClusterFuture ...
[09:28:26.973] - result already collected: FutureResult
[09:28:26.973] result() for ClusterFuture ... done
[09:28:26.974] result() for ClusterFuture ...
[09:28:26.974] - result already collected: FutureResult
[09:28:26.974] result() for ClusterFuture ... done
[09:28:26.974] - relayed: [n=2] TRUE, FALSE
[09:28:26.974] - queued futures: [n=2] TRUE, FALSE
[09:28:26.974] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:26.974]  length: 1 (resolved future 1)
[09:28:27.037] receiveMessageFromWorker() for ClusterFuture ...
[09:28:27.037] - Validating connection of MultisessionFuture
[09:28:27.037] - received message: FutureResult
[09:28:27.037] - Received FutureResult
[09:28:27.037] - Erased future from FutureRegistry
[09:28:27.037] result() for ClusterFuture ...
[09:28:27.037] - result already collected: FutureResult
[09:28:27.037] result() for ClusterFuture ... done
[09:28:27.037] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:27.038] Future #2
[09:28:27.038] result() for ClusterFuture ...
[09:28:27.038] - result already collected: FutureResult
[09:28:27.038] result() for ClusterFuture ... done
[09:28:27.038] result() for ClusterFuture ...
[09:28:27.038] - result already collected: FutureResult
[09:28:27.038] result() for ClusterFuture ... done
[09:28:27.038] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:27.038] - nx: 2
[09:28:27.038] - relay: TRUE
[09:28:27.038] - stdout: TRUE
[09:28:27.038] - signal: TRUE
[09:28:27.039] - resignal: FALSE
[09:28:27.039] - force: TRUE
[09:28:27.039] - relayed: [n=2] TRUE, FALSE
[09:28:27.039] - queued futures: [n=2] TRUE, FALSE
[09:28:27.039]  - until=2
[09:28:27.039]  - relaying element #2
[09:28:27.039] result() for ClusterFuture ...
[09:28:27.039] - result already collected: FutureResult
[09:28:27.039] result() for ClusterFuture ... done
[09:28:27.039] result() for ClusterFuture ...
[09:28:27.039] - result already collected: FutureResult
[09:28:27.039] result() for ClusterFuture ... done
[09:28:27.040] result() for ClusterFuture ...
[09:28:27.040] - result already collected: FutureResult
[09:28:27.040] result() for ClusterFuture ... done
[09:28:27.040] result() for ClusterFuture ...
[09:28:27.040] - result already collected: FutureResult
[09:28:27.040] result() for ClusterFuture ... done
[09:28:27.040] - relayed: [n=2] TRUE, TRUE
[09:28:27.040] - queued futures: [n=2] TRUE, TRUE
[09:28:27.040] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:27.040]  length: 0 (resolved future 2)
[09:28:27.041] Relaying remaining futures
[09:28:27.041] signalConditionsASAP(NULL, pos=0) ...
[09:28:27.041] - nx: 2
[09:28:27.041] - relay: TRUE
[09:28:27.041] - stdout: TRUE
[09:28:27.041] - signal: TRUE
[09:28:27.041] - resignal: FALSE
[09:28:27.041] - force: TRUE
[09:28:27.041] - relayed: [n=2] TRUE, TRUE
[09:28:27.041] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:27.041] - relayed: [n=2] TRUE, TRUE
[09:28:27.041] - queued futures: [n=2] TRUE, TRUE
[09:28:27.042] signalConditionsASAP(NULL, pos=0) ... done
[09:28:27.042] resolve() on list ... DONE
[09:28:27.042] result() for ClusterFuture ...
[09:28:27.042] - result already collected: FutureResult
[09:28:27.042] result() for ClusterFuture ... done
[09:28:27.042] result() for ClusterFuture ...
[09:28:27.042] - result already collected: FutureResult
[09:28:27.042] result() for ClusterFuture ... done
[09:28:27.042] result() for ClusterFuture ...
[09:28:27.042] - result already collected: FutureResult
[09:28:27.042] result() for ClusterFuture ... done
[09:28:27.042] result() for ClusterFuture ...
[09:28:27.043] - result already collected: FutureResult
[09:28:27.043] result() for ClusterFuture ... done
[09:28:27.043]  - Number of value chunks collected: 2
[09:28:27.043] Resolving 2 futures (chunks) ... DONE
[09:28:27.043] Reducing values from 2 chunks ...
[09:28:27.043]  - Number of values collected after concatenation: 3
[09:28:27.043]  - Number of values expected: 3
[09:28:27.043] Reducing values from 2 chunks ... DONE
[09:28:27.043] future_lapply() ... DONE
[09:28:27.044] future_lapply() ...
[09:28:27.048] Number of chunks: 2
[09:28:27.048] getGlobalsAndPackagesXApply() ...
[09:28:27.048]  - future.globals: TRUE
[09:28:27.048] getGlobalsAndPackages() ...
[09:28:27.048] Searching for globals...
[09:28:27.050] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:27.050] Searching for globals ... DONE
[09:28:27.050] Resolving globals: FALSE
[09:28:27.050] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:27.051] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:27.051] - globals: [1] ‘FUN’
[09:28:27.051] - packages: [1] ‘stats’
[09:28:27.051] getGlobalsAndPackages() ... DONE
[09:28:27.051]  - globals found/used: [n=1] ‘FUN’
[09:28:27.051]  - needed namespaces: [n=1] ‘stats’
[09:28:27.051] Finding globals ... DONE
[09:28:27.051]  - use_args: TRUE
[09:28:27.051]  - Getting '...' globals ...
[09:28:27.052] resolve() on list ...
[09:28:27.052]  recursive: 0
[09:28:27.052]  length: 1
[09:28:27.052]  elements: ‘...’
[09:28:27.052]  length: 0 (resolved future 1)
[09:28:27.052] resolve() on list ... DONE
[09:28:27.052]    - '...' content: [n=1] ‘probs’
[09:28:27.053] List of 1
[09:28:27.053]  $ ...:List of 1
[09:28:27.053]   ..$ probs: num [1:3] 0.25 0.5 0.75
[09:28:27.053]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:27.053]  - attr(*, "where")=List of 1
[09:28:27.053]   ..$ ...:<environment: 0x556666291ed0> 
[09:28:27.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:27.053]  - attr(*, "resolved")= logi TRUE
[09:28:27.053]  - attr(*, "total_size")= num NA
[09:28:27.055]  - Getting '...' globals ... DONE
[09:28:27.056] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:27.056] List of 2
[09:28:27.056]  $ ...future.FUN:function (x, ...)  
[09:28:27.056]  $ ...          :List of 1
[09:28:27.056]   ..$ probs: num [1:3] 0.25 0.5 0.75
[09:28:27.056]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:27.056]  - attr(*, "where")=List of 2
[09:28:27.056]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:27.056]   ..$ ...          :<environment: 0x556666291ed0> 
[09:28:27.056]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:27.056]  - attr(*, "resolved")= logi FALSE
[09:28:27.056]  - attr(*, "total_size")= num 1328
[09:28:27.059] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:27.059] getGlobalsAndPackagesXApply() ... DONE
[09:28:27.059] Number of futures (= number of chunks): 2
[09:28:27.059] Launching 2 futures (chunks) ...
[09:28:27.059] Chunk #1 of 2 ...
[09:28:27.059]  - Finding globals in 'X' for chunk #1 ...
[09:28:27.059] getGlobalsAndPackages() ...
[09:28:27.060] Searching for globals...
[09:28:27.060] 
[09:28:27.060] Searching for globals ... DONE
[09:28:27.060] - globals: [0] <none>
[09:28:27.060] getGlobalsAndPackages() ... DONE
[09:28:27.060]    + additional globals found: [n=0] 
[09:28:27.060]    + additional namespaces needed: [n=0] 
[09:28:27.060]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:27.060]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:27.061]  - seeds: <none>
[09:28:27.061]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.061] getGlobalsAndPackages() ...
[09:28:27.061] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.061] Resolving globals: FALSE
[09:28:27.061] Tweak future expression to call with '...' arguments ...
[09:28:27.061] {
[09:28:27.061]     do.call(function(...) {
[09:28:27.061]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.061]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.061]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.061]             on.exit(options(oopts), add = TRUE)
[09:28:27.061]         }
[09:28:27.061]         {
[09:28:27.061]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.061]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.061]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.061]             })
[09:28:27.061]         }
[09:28:27.061]     }, args = future.call.arguments)
[09:28:27.061] }
[09:28:27.061] Tweak future expression to call with '...' arguments ... DONE
[09:28:27.062] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.062] - packages: [1] ‘stats’
[09:28:27.062] getGlobalsAndPackages() ... DONE
[09:28:27.062] run() for ‘Future’ ...
[09:28:27.062] - state: ‘created’
[09:28:27.063] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:27.076] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.076] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:27.076]   - Field: ‘node’
[09:28:27.077]   - Field: ‘label’
[09:28:27.077]   - Field: ‘local’
[09:28:27.077]   - Field: ‘owner’
[09:28:27.077]   - Field: ‘envir’
[09:28:27.077]   - Field: ‘workers’
[09:28:27.077]   - Field: ‘packages’
[09:28:27.077]   - Field: ‘gc’
[09:28:27.077]   - Field: ‘conditions’
[09:28:27.077]   - Field: ‘persistent’
[09:28:27.077]   - Field: ‘expr’
[09:28:27.078]   - Field: ‘uuid’
[09:28:27.078]   - Field: ‘seed’
[09:28:27.078]   - Field: ‘version’
[09:28:27.078]   - Field: ‘result’
[09:28:27.078]   - Field: ‘asynchronous’
[09:28:27.078]   - Field: ‘calls’
[09:28:27.078]   - Field: ‘globals’
[09:28:27.078]   - Field: ‘stdout’
[09:28:27.078]   - Field: ‘earlySignal’
[09:28:27.078]   - Field: ‘lazy’
[09:28:27.078]   - Field: ‘state’
[09:28:27.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:27.079] - Launch lazy future ...
[09:28:27.079] Packages needed by the future expression (n = 1): ‘stats’
[09:28:27.079] Packages needed by future strategies (n = 0): <none>
[09:28:27.079] {
[09:28:27.079]     {
[09:28:27.079]         {
[09:28:27.079]             ...future.startTime <- base::Sys.time()
[09:28:27.079]             {
[09:28:27.079]                 {
[09:28:27.079]                   {
[09:28:27.079]                     {
[09:28:27.079]                       {
[09:28:27.079]                         base::local({
[09:28:27.079]                           has_future <- base::requireNamespace("future", 
[09:28:27.079]                             quietly = TRUE)
[09:28:27.079]                           if (has_future) {
[09:28:27.079]                             ns <- base::getNamespace("future")
[09:28:27.079]                             version <- ns[[".package"]][["version"]]
[09:28:27.079]                             if (is.null(version)) 
[09:28:27.079]                               version <- utils::packageVersion("future")
[09:28:27.079]                           }
[09:28:27.079]                           else {
[09:28:27.079]                             version <- NULL
[09:28:27.079]                           }
[09:28:27.079]                           if (!has_future || version < "1.8.0") {
[09:28:27.079]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:27.079]                               "", base::R.version$version.string), 
[09:28:27.079]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:27.079]                                 base::R.version$platform, 8 * 
[09:28:27.079]                                   base::.Machine$sizeof.pointer), 
[09:28:27.079]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:27.079]                                 "release", "version")], collapse = " "), 
[09:28:27.079]                               hostname = base::Sys.info()[["nodename"]])
[09:28:27.079]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:27.079]                               info)
[09:28:27.079]                             info <- base::paste(info, collapse = "; ")
[09:28:27.079]                             if (!has_future) {
[09:28:27.079]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:27.079]                                 info)
[09:28:27.079]                             }
[09:28:27.079]                             else {
[09:28:27.079]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:27.079]                                 info, version)
[09:28:27.079]                             }
[09:28:27.079]                             base::stop(msg)
[09:28:27.079]                           }
[09:28:27.079]                         })
[09:28:27.079]                       }
[09:28:27.079]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:27.079]                       base::options(mc.cores = 1L)
[09:28:27.079]                     }
[09:28:27.079]                     base::local({
[09:28:27.079]                       for (pkg in "stats") {
[09:28:27.079]                         base::loadNamespace(pkg)
[09:28:27.079]                         base::library(pkg, character.only = TRUE)
[09:28:27.079]                       }
[09:28:27.079]                     })
[09:28:27.079]                   }
[09:28:27.079]                   ...future.strategy.old <- future::plan("list")
[09:28:27.079]                   options(future.plan = NULL)
[09:28:27.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:27.079]                 }
[09:28:27.079]                 ...future.workdir <- getwd()
[09:28:27.079]             }
[09:28:27.079]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:27.079]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:27.079]         }
[09:28:27.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:27.079]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:27.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:27.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:27.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:27.079]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:27.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:27.079]             base::names(...future.oldOptions))
[09:28:27.079]     }
[09:28:27.079]     if (FALSE) {
[09:28:27.079]     }
[09:28:27.079]     else {
[09:28:27.079]         if (TRUE) {
[09:28:27.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:27.079]                 open = "w")
[09:28:27.079]         }
[09:28:27.079]         else {
[09:28:27.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:27.079]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:27.079]         }
[09:28:27.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:27.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:27.079]             base::sink(type = "output", split = FALSE)
[09:28:27.079]             base::close(...future.stdout)
[09:28:27.079]         }, add = TRUE)
[09:28:27.079]     }
[09:28:27.079]     ...future.frame <- base::sys.nframe()
[09:28:27.079]     ...future.conditions <- base::list()
[09:28:27.079]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:27.079]     if (FALSE) {
[09:28:27.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:27.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:27.079]     }
[09:28:27.079]     ...future.result <- base::tryCatch({
[09:28:27.079]         base::withCallingHandlers({
[09:28:27.079]             ...future.value <- base::withVisible(base::local({
[09:28:27.079]                 ...future.makeSendCondition <- base::local({
[09:28:27.079]                   sendCondition <- NULL
[09:28:27.079]                   function(frame = 1L) {
[09:28:27.079]                     if (is.function(sendCondition)) 
[09:28:27.079]                       return(sendCondition)
[09:28:27.079]                     ns <- getNamespace("parallel")
[09:28:27.079]                     if (exists("sendData", mode = "function", 
[09:28:27.079]                       envir = ns)) {
[09:28:27.079]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:27.079]                         envir = ns)
[09:28:27.079]                       envir <- sys.frame(frame)
[09:28:27.079]                       master <- NULL
[09:28:27.079]                       while (!identical(envir, .GlobalEnv) && 
[09:28:27.079]                         !identical(envir, emptyenv())) {
[09:28:27.079]                         if (exists("master", mode = "list", envir = envir, 
[09:28:27.079]                           inherits = FALSE)) {
[09:28:27.079]                           master <- get("master", mode = "list", 
[09:28:27.079]                             envir = envir, inherits = FALSE)
[09:28:27.079]                           if (inherits(master, c("SOCKnode", 
[09:28:27.079]                             "SOCK0node"))) {
[09:28:27.079]                             sendCondition <<- function(cond) {
[09:28:27.079]                               data <- list(type = "VALUE", value = cond, 
[09:28:27.079]                                 success = TRUE)
[09:28:27.079]                               parallel_sendData(master, data)
[09:28:27.079]                             }
[09:28:27.079]                             return(sendCondition)
[09:28:27.079]                           }
[09:28:27.079]                         }
[09:28:27.079]                         frame <- frame + 1L
[09:28:27.079]                         envir <- sys.frame(frame)
[09:28:27.079]                       }
[09:28:27.079]                     }
[09:28:27.079]                     sendCondition <<- function(cond) NULL
[09:28:27.079]                   }
[09:28:27.079]                 })
[09:28:27.079]                 withCallingHandlers({
[09:28:27.079]                   {
[09:28:27.079]                     do.call(function(...) {
[09:28:27.079]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.079]                       if (!identical(...future.globals.maxSize.org, 
[09:28:27.079]                         ...future.globals.maxSize)) {
[09:28:27.079]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.079]                         on.exit(options(oopts), add = TRUE)
[09:28:27.079]                       }
[09:28:27.079]                       {
[09:28:27.079]                         lapply(seq_along(...future.elements_ii), 
[09:28:27.079]                           FUN = function(jj) {
[09:28:27.079]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.079]                             ...future.FUN(...future.X_jj, ...)
[09:28:27.079]                           })
[09:28:27.079]                       }
[09:28:27.079]                     }, args = future.call.arguments)
[09:28:27.079]                   }
[09:28:27.079]                 }, immediateCondition = function(cond) {
[09:28:27.079]                   sendCondition <- ...future.makeSendCondition()
[09:28:27.079]                   sendCondition(cond)
[09:28:27.079]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.079]                   {
[09:28:27.079]                     inherits <- base::inherits
[09:28:27.079]                     invokeRestart <- base::invokeRestart
[09:28:27.079]                     is.null <- base::is.null
[09:28:27.079]                     muffled <- FALSE
[09:28:27.079]                     if (inherits(cond, "message")) {
[09:28:27.079]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:27.079]                       if (muffled) 
[09:28:27.079]                         invokeRestart("muffleMessage")
[09:28:27.079]                     }
[09:28:27.079]                     else if (inherits(cond, "warning")) {
[09:28:27.079]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:27.079]                       if (muffled) 
[09:28:27.079]                         invokeRestart("muffleWarning")
[09:28:27.079]                     }
[09:28:27.079]                     else if (inherits(cond, "condition")) {
[09:28:27.079]                       if (!is.null(pattern)) {
[09:28:27.079]                         computeRestarts <- base::computeRestarts
[09:28:27.079]                         grepl <- base::grepl
[09:28:27.079]                         restarts <- computeRestarts(cond)
[09:28:27.079]                         for (restart in restarts) {
[09:28:27.079]                           name <- restart$name
[09:28:27.079]                           if (is.null(name)) 
[09:28:27.079]                             next
[09:28:27.079]                           if (!grepl(pattern, name)) 
[09:28:27.079]                             next
[09:28:27.079]                           invokeRestart(restart)
[09:28:27.079]                           muffled <- TRUE
[09:28:27.079]                           break
[09:28:27.079]                         }
[09:28:27.079]                       }
[09:28:27.079]                     }
[09:28:27.079]                     invisible(muffled)
[09:28:27.079]                   }
[09:28:27.079]                   muffleCondition(cond)
[09:28:27.079]                 })
[09:28:27.079]             }))
[09:28:27.079]             future::FutureResult(value = ...future.value$value, 
[09:28:27.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.079]                   ...future.rng), globalenv = if (FALSE) 
[09:28:27.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:27.079]                     ...future.globalenv.names))
[09:28:27.079]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:27.079]         }, condition = base::local({
[09:28:27.079]             c <- base::c
[09:28:27.079]             inherits <- base::inherits
[09:28:27.079]             invokeRestart <- base::invokeRestart
[09:28:27.079]             length <- base::length
[09:28:27.079]             list <- base::list
[09:28:27.079]             seq.int <- base::seq.int
[09:28:27.079]             signalCondition <- base::signalCondition
[09:28:27.079]             sys.calls <- base::sys.calls
[09:28:27.079]             `[[` <- base::`[[`
[09:28:27.079]             `+` <- base::`+`
[09:28:27.079]             `<<-` <- base::`<<-`
[09:28:27.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:27.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:27.079]                   3L)]
[09:28:27.079]             }
[09:28:27.079]             function(cond) {
[09:28:27.079]                 is_error <- inherits(cond, "error")
[09:28:27.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:27.079]                   NULL)
[09:28:27.079]                 if (is_error) {
[09:28:27.079]                   sessionInformation <- function() {
[09:28:27.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:27.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:27.079]                       search = base::search(), system = base::Sys.info())
[09:28:27.079]                   }
[09:28:27.079]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:27.079]                     cond$call), session = sessionInformation(), 
[09:28:27.079]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:27.079]                   signalCondition(cond)
[09:28:27.079]                 }
[09:28:27.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:27.079]                 "immediateCondition"))) {
[09:28:27.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:27.079]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:27.079]                   if (TRUE && !signal) {
[09:28:27.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.079]                     {
[09:28:27.079]                       inherits <- base::inherits
[09:28:27.079]                       invokeRestart <- base::invokeRestart
[09:28:27.079]                       is.null <- base::is.null
[09:28:27.079]                       muffled <- FALSE
[09:28:27.079]                       if (inherits(cond, "message")) {
[09:28:27.079]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.079]                         if (muffled) 
[09:28:27.079]                           invokeRestart("muffleMessage")
[09:28:27.079]                       }
[09:28:27.079]                       else if (inherits(cond, "warning")) {
[09:28:27.079]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.079]                         if (muffled) 
[09:28:27.079]                           invokeRestart("muffleWarning")
[09:28:27.079]                       }
[09:28:27.079]                       else if (inherits(cond, "condition")) {
[09:28:27.079]                         if (!is.null(pattern)) {
[09:28:27.079]                           computeRestarts <- base::computeRestarts
[09:28:27.079]                           grepl <- base::grepl
[09:28:27.079]                           restarts <- computeRestarts(cond)
[09:28:27.079]                           for (restart in restarts) {
[09:28:27.079]                             name <- restart$name
[09:28:27.079]                             if (is.null(name)) 
[09:28:27.079]                               next
[09:28:27.079]                             if (!grepl(pattern, name)) 
[09:28:27.079]                               next
[09:28:27.079]                             invokeRestart(restart)
[09:28:27.079]                             muffled <- TRUE
[09:28:27.079]                             break
[09:28:27.079]                           }
[09:28:27.079]                         }
[09:28:27.079]                       }
[09:28:27.079]                       invisible(muffled)
[09:28:27.079]                     }
[09:28:27.079]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.079]                   }
[09:28:27.079]                 }
[09:28:27.079]                 else {
[09:28:27.079]                   if (TRUE) {
[09:28:27.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.079]                     {
[09:28:27.079]                       inherits <- base::inherits
[09:28:27.079]                       invokeRestart <- base::invokeRestart
[09:28:27.079]                       is.null <- base::is.null
[09:28:27.079]                       muffled <- FALSE
[09:28:27.079]                       if (inherits(cond, "message")) {
[09:28:27.079]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.079]                         if (muffled) 
[09:28:27.079]                           invokeRestart("muffleMessage")
[09:28:27.079]                       }
[09:28:27.079]                       else if (inherits(cond, "warning")) {
[09:28:27.079]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.079]                         if (muffled) 
[09:28:27.079]                           invokeRestart("muffleWarning")
[09:28:27.079]                       }
[09:28:27.079]                       else if (inherits(cond, "condition")) {
[09:28:27.079]                         if (!is.null(pattern)) {
[09:28:27.079]                           computeRestarts <- base::computeRestarts
[09:28:27.079]                           grepl <- base::grepl
[09:28:27.079]                           restarts <- computeRestarts(cond)
[09:28:27.079]                           for (restart in restarts) {
[09:28:27.079]                             name <- restart$name
[09:28:27.079]                             if (is.null(name)) 
[09:28:27.079]                               next
[09:28:27.079]                             if (!grepl(pattern, name)) 
[09:28:27.079]                               next
[09:28:27.079]                             invokeRestart(restart)
[09:28:27.079]                             muffled <- TRUE
[09:28:27.079]                             break
[09:28:27.079]                           }
[09:28:27.079]                         }
[09:28:27.079]                       }
[09:28:27.079]                       invisible(muffled)
[09:28:27.079]                     }
[09:28:27.079]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.079]                   }
[09:28:27.079]                 }
[09:28:27.079]             }
[09:28:27.079]         }))
[09:28:27.079]     }, error = function(ex) {
[09:28:27.079]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:27.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.079]                 ...future.rng), started = ...future.startTime, 
[09:28:27.079]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:27.079]             version = "1.8"), class = "FutureResult")
[09:28:27.079]     }, finally = {
[09:28:27.079]         if (!identical(...future.workdir, getwd())) 
[09:28:27.079]             setwd(...future.workdir)
[09:28:27.079]         {
[09:28:27.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:27.079]                 ...future.oldOptions$nwarnings <- NULL
[09:28:27.079]             }
[09:28:27.079]             base::options(...future.oldOptions)
[09:28:27.079]             if (.Platform$OS.type == "windows") {
[09:28:27.079]                 old_names <- names(...future.oldEnvVars)
[09:28:27.079]                 envs <- base::Sys.getenv()
[09:28:27.079]                 names <- names(envs)
[09:28:27.079]                 common <- intersect(names, old_names)
[09:28:27.079]                 added <- setdiff(names, old_names)
[09:28:27.079]                 removed <- setdiff(old_names, names)
[09:28:27.079]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:27.079]                   envs[common]]
[09:28:27.079]                 NAMES <- toupper(changed)
[09:28:27.079]                 args <- list()
[09:28:27.079]                 for (kk in seq_along(NAMES)) {
[09:28:27.079]                   name <- changed[[kk]]
[09:28:27.079]                   NAME <- NAMES[[kk]]
[09:28:27.079]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.079]                     next
[09:28:27.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.079]                 }
[09:28:27.079]                 NAMES <- toupper(added)
[09:28:27.079]                 for (kk in seq_along(NAMES)) {
[09:28:27.079]                   name <- added[[kk]]
[09:28:27.079]                   NAME <- NAMES[[kk]]
[09:28:27.079]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.079]                     next
[09:28:27.079]                   args[[name]] <- ""
[09:28:27.079]                 }
[09:28:27.079]                 NAMES <- toupper(removed)
[09:28:27.079]                 for (kk in seq_along(NAMES)) {
[09:28:27.079]                   name <- removed[[kk]]
[09:28:27.079]                   NAME <- NAMES[[kk]]
[09:28:27.079]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.079]                     next
[09:28:27.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.079]                 }
[09:28:27.079]                 if (length(args) > 0) 
[09:28:27.079]                   base::do.call(base::Sys.setenv, args = args)
[09:28:27.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:27.079]             }
[09:28:27.079]             else {
[09:28:27.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:27.079]             }
[09:28:27.079]             {
[09:28:27.079]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:27.079]                   0L) {
[09:28:27.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:27.079]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:27.079]                   base::options(opts)
[09:28:27.079]                 }
[09:28:27.079]                 {
[09:28:27.079]                   {
[09:28:27.079]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:27.079]                     NULL
[09:28:27.079]                   }
[09:28:27.079]                   options(future.plan = NULL)
[09:28:27.079]                   if (is.na(NA_character_)) 
[09:28:27.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:27.079]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:27.079]                     .init = FALSE)
[09:28:27.079]                 }
[09:28:27.079]             }
[09:28:27.079]         }
[09:28:27.079]     })
[09:28:27.079]     if (TRUE) {
[09:28:27.079]         base::sink(type = "output", split = FALSE)
[09:28:27.079]         if (TRUE) {
[09:28:27.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:27.079]         }
[09:28:27.079]         else {
[09:28:27.079]             ...future.result["stdout"] <- base::list(NULL)
[09:28:27.079]         }
[09:28:27.079]         base::close(...future.stdout)
[09:28:27.079]         ...future.stdout <- NULL
[09:28:27.079]     }
[09:28:27.079]     ...future.result$conditions <- ...future.conditions
[09:28:27.079]     ...future.result$finished <- base::Sys.time()
[09:28:27.079]     ...future.result
[09:28:27.079] }
[09:28:27.082] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[09:28:27.082] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[09:28:27.083] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[09:28:27.083] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[09:28:27.083] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[09:28:27.083] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[09:28:27.084] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[09:28:27.084] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:27.084] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:27.084] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:28:27.085] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:28:27.085] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[09:28:27.085] MultisessionFuture started
[09:28:27.085] - Launch lazy future ... done
[09:28:27.085] run() for ‘MultisessionFuture’ ... done
[09:28:27.085] Created future:
[09:28:27.086] MultisessionFuture:
[09:28:27.086] Label: ‘future_eapply-1’
[09:28:27.086] Expression:
[09:28:27.086] {
[09:28:27.086]     do.call(function(...) {
[09:28:27.086]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.086]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.086]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.086]             on.exit(options(oopts), add = TRUE)
[09:28:27.086]         }
[09:28:27.086]         {
[09:28:27.086]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.086]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.086]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.086]             })
[09:28:27.086]         }
[09:28:27.086]     }, args = future.call.arguments)
[09:28:27.086] }
[09:28:27.086] Lazy evaluation: FALSE
[09:28:27.086] Asynchronous evaluation: TRUE
[09:28:27.086] Local evaluation: TRUE
[09:28:27.086] Environment: R_GlobalEnv
[09:28:27.086] Capture standard output: TRUE
[09:28:27.086] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:27.086] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:27.086] Packages: 1 packages (‘stats’)
[09:28:27.086] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:27.086] Resolved: FALSE
[09:28:27.086] Value: <not collected>
[09:28:27.086] Conditions captured: <none>
[09:28:27.086] Early signaling: FALSE
[09:28:27.086] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:27.086] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.097] Chunk #1 of 2 ... DONE
[09:28:27.097] Chunk #2 of 2 ...
[09:28:27.097]  - Finding globals in 'X' for chunk #2 ...
[09:28:27.097] getGlobalsAndPackages() ...
[09:28:27.097] Searching for globals...
[09:28:27.098] 
[09:28:27.098] Searching for globals ... DONE
[09:28:27.098] - globals: [0] <none>
[09:28:27.098] getGlobalsAndPackages() ... DONE
[09:28:27.098]    + additional globals found: [n=0] 
[09:28:27.098]    + additional namespaces needed: [n=0] 
[09:28:27.098]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:27.098]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:27.098]  - seeds: <none>
[09:28:27.098]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.099] getGlobalsAndPackages() ...
[09:28:27.099] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.099] Resolving globals: FALSE
[09:28:27.099] Tweak future expression to call with '...' arguments ...
[09:28:27.099] {
[09:28:27.099]     do.call(function(...) {
[09:28:27.099]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.099]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.099]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.099]             on.exit(options(oopts), add = TRUE)
[09:28:27.099]         }
[09:28:27.099]         {
[09:28:27.099]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.099]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.099]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.099]             })
[09:28:27.099]         }
[09:28:27.099]     }, args = future.call.arguments)
[09:28:27.099] }
[09:28:27.099] Tweak future expression to call with '...' arguments ... DONE
[09:28:27.100] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.100] - packages: [1] ‘stats’
[09:28:27.100] getGlobalsAndPackages() ... DONE
[09:28:27.100] run() for ‘Future’ ...
[09:28:27.100] - state: ‘created’
[09:28:27.100] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:27.113] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:27.114]   - Field: ‘node’
[09:28:27.114]   - Field: ‘label’
[09:28:27.114]   - Field: ‘local’
[09:28:27.114]   - Field: ‘owner’
[09:28:27.114]   - Field: ‘envir’
[09:28:27.114]   - Field: ‘workers’
[09:28:27.114]   - Field: ‘packages’
[09:28:27.114]   - Field: ‘gc’
[09:28:27.114]   - Field: ‘conditions’
[09:28:27.114]   - Field: ‘persistent’
[09:28:27.115]   - Field: ‘expr’
[09:28:27.115]   - Field: ‘uuid’
[09:28:27.115]   - Field: ‘seed’
[09:28:27.115]   - Field: ‘version’
[09:28:27.115]   - Field: ‘result’
[09:28:27.115]   - Field: ‘asynchronous’
[09:28:27.115]   - Field: ‘calls’
[09:28:27.115]   - Field: ‘globals’
[09:28:27.115]   - Field: ‘stdout’
[09:28:27.115]   - Field: ‘earlySignal’
[09:28:27.115]   - Field: ‘lazy’
[09:28:27.116]   - Field: ‘state’
[09:28:27.116] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:27.116] - Launch lazy future ...
[09:28:27.116] Packages needed by the future expression (n = 1): ‘stats’
[09:28:27.116] Packages needed by future strategies (n = 0): <none>
[09:28:27.117] {
[09:28:27.117]     {
[09:28:27.117]         {
[09:28:27.117]             ...future.startTime <- base::Sys.time()
[09:28:27.117]             {
[09:28:27.117]                 {
[09:28:27.117]                   {
[09:28:27.117]                     {
[09:28:27.117]                       {
[09:28:27.117]                         base::local({
[09:28:27.117]                           has_future <- base::requireNamespace("future", 
[09:28:27.117]                             quietly = TRUE)
[09:28:27.117]                           if (has_future) {
[09:28:27.117]                             ns <- base::getNamespace("future")
[09:28:27.117]                             version <- ns[[".package"]][["version"]]
[09:28:27.117]                             if (is.null(version)) 
[09:28:27.117]                               version <- utils::packageVersion("future")
[09:28:27.117]                           }
[09:28:27.117]                           else {
[09:28:27.117]                             version <- NULL
[09:28:27.117]                           }
[09:28:27.117]                           if (!has_future || version < "1.8.0") {
[09:28:27.117]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:27.117]                               "", base::R.version$version.string), 
[09:28:27.117]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:27.117]                                 base::R.version$platform, 8 * 
[09:28:27.117]                                   base::.Machine$sizeof.pointer), 
[09:28:27.117]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:27.117]                                 "release", "version")], collapse = " "), 
[09:28:27.117]                               hostname = base::Sys.info()[["nodename"]])
[09:28:27.117]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:27.117]                               info)
[09:28:27.117]                             info <- base::paste(info, collapse = "; ")
[09:28:27.117]                             if (!has_future) {
[09:28:27.117]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:27.117]                                 info)
[09:28:27.117]                             }
[09:28:27.117]                             else {
[09:28:27.117]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:27.117]                                 info, version)
[09:28:27.117]                             }
[09:28:27.117]                             base::stop(msg)
[09:28:27.117]                           }
[09:28:27.117]                         })
[09:28:27.117]                       }
[09:28:27.117]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:27.117]                       base::options(mc.cores = 1L)
[09:28:27.117]                     }
[09:28:27.117]                     base::local({
[09:28:27.117]                       for (pkg in "stats") {
[09:28:27.117]                         base::loadNamespace(pkg)
[09:28:27.117]                         base::library(pkg, character.only = TRUE)
[09:28:27.117]                       }
[09:28:27.117]                     })
[09:28:27.117]                   }
[09:28:27.117]                   ...future.strategy.old <- future::plan("list")
[09:28:27.117]                   options(future.plan = NULL)
[09:28:27.117]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.117]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:27.117]                 }
[09:28:27.117]                 ...future.workdir <- getwd()
[09:28:27.117]             }
[09:28:27.117]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:27.117]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:27.117]         }
[09:28:27.117]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:27.117]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:27.117]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:27.117]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:27.117]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:27.117]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:27.117]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:27.117]             base::names(...future.oldOptions))
[09:28:27.117]     }
[09:28:27.117]     if (FALSE) {
[09:28:27.117]     }
[09:28:27.117]     else {
[09:28:27.117]         if (TRUE) {
[09:28:27.117]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:27.117]                 open = "w")
[09:28:27.117]         }
[09:28:27.117]         else {
[09:28:27.117]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:27.117]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:27.117]         }
[09:28:27.117]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:27.117]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:27.117]             base::sink(type = "output", split = FALSE)
[09:28:27.117]             base::close(...future.stdout)
[09:28:27.117]         }, add = TRUE)
[09:28:27.117]     }
[09:28:27.117]     ...future.frame <- base::sys.nframe()
[09:28:27.117]     ...future.conditions <- base::list()
[09:28:27.117]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:27.117]     if (FALSE) {
[09:28:27.117]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:27.117]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:27.117]     }
[09:28:27.117]     ...future.result <- base::tryCatch({
[09:28:27.117]         base::withCallingHandlers({
[09:28:27.117]             ...future.value <- base::withVisible(base::local({
[09:28:27.117]                 ...future.makeSendCondition <- base::local({
[09:28:27.117]                   sendCondition <- NULL
[09:28:27.117]                   function(frame = 1L) {
[09:28:27.117]                     if (is.function(sendCondition)) 
[09:28:27.117]                       return(sendCondition)
[09:28:27.117]                     ns <- getNamespace("parallel")
[09:28:27.117]                     if (exists("sendData", mode = "function", 
[09:28:27.117]                       envir = ns)) {
[09:28:27.117]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:27.117]                         envir = ns)
[09:28:27.117]                       envir <- sys.frame(frame)
[09:28:27.117]                       master <- NULL
[09:28:27.117]                       while (!identical(envir, .GlobalEnv) && 
[09:28:27.117]                         !identical(envir, emptyenv())) {
[09:28:27.117]                         if (exists("master", mode = "list", envir = envir, 
[09:28:27.117]                           inherits = FALSE)) {
[09:28:27.117]                           master <- get("master", mode = "list", 
[09:28:27.117]                             envir = envir, inherits = FALSE)
[09:28:27.117]                           if (inherits(master, c("SOCKnode", 
[09:28:27.117]                             "SOCK0node"))) {
[09:28:27.117]                             sendCondition <<- function(cond) {
[09:28:27.117]                               data <- list(type = "VALUE", value = cond, 
[09:28:27.117]                                 success = TRUE)
[09:28:27.117]                               parallel_sendData(master, data)
[09:28:27.117]                             }
[09:28:27.117]                             return(sendCondition)
[09:28:27.117]                           }
[09:28:27.117]                         }
[09:28:27.117]                         frame <- frame + 1L
[09:28:27.117]                         envir <- sys.frame(frame)
[09:28:27.117]                       }
[09:28:27.117]                     }
[09:28:27.117]                     sendCondition <<- function(cond) NULL
[09:28:27.117]                   }
[09:28:27.117]                 })
[09:28:27.117]                 withCallingHandlers({
[09:28:27.117]                   {
[09:28:27.117]                     do.call(function(...) {
[09:28:27.117]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.117]                       if (!identical(...future.globals.maxSize.org, 
[09:28:27.117]                         ...future.globals.maxSize)) {
[09:28:27.117]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.117]                         on.exit(options(oopts), add = TRUE)
[09:28:27.117]                       }
[09:28:27.117]                       {
[09:28:27.117]                         lapply(seq_along(...future.elements_ii), 
[09:28:27.117]                           FUN = function(jj) {
[09:28:27.117]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.117]                             ...future.FUN(...future.X_jj, ...)
[09:28:27.117]                           })
[09:28:27.117]                       }
[09:28:27.117]                     }, args = future.call.arguments)
[09:28:27.117]                   }
[09:28:27.117]                 }, immediateCondition = function(cond) {
[09:28:27.117]                   sendCondition <- ...future.makeSendCondition()
[09:28:27.117]                   sendCondition(cond)
[09:28:27.117]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.117]                   {
[09:28:27.117]                     inherits <- base::inherits
[09:28:27.117]                     invokeRestart <- base::invokeRestart
[09:28:27.117]                     is.null <- base::is.null
[09:28:27.117]                     muffled <- FALSE
[09:28:27.117]                     if (inherits(cond, "message")) {
[09:28:27.117]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:27.117]                       if (muffled) 
[09:28:27.117]                         invokeRestart("muffleMessage")
[09:28:27.117]                     }
[09:28:27.117]                     else if (inherits(cond, "warning")) {
[09:28:27.117]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:27.117]                       if (muffled) 
[09:28:27.117]                         invokeRestart("muffleWarning")
[09:28:27.117]                     }
[09:28:27.117]                     else if (inherits(cond, "condition")) {
[09:28:27.117]                       if (!is.null(pattern)) {
[09:28:27.117]                         computeRestarts <- base::computeRestarts
[09:28:27.117]                         grepl <- base::grepl
[09:28:27.117]                         restarts <- computeRestarts(cond)
[09:28:27.117]                         for (restart in restarts) {
[09:28:27.117]                           name <- restart$name
[09:28:27.117]                           if (is.null(name)) 
[09:28:27.117]                             next
[09:28:27.117]                           if (!grepl(pattern, name)) 
[09:28:27.117]                             next
[09:28:27.117]                           invokeRestart(restart)
[09:28:27.117]                           muffled <- TRUE
[09:28:27.117]                           break
[09:28:27.117]                         }
[09:28:27.117]                       }
[09:28:27.117]                     }
[09:28:27.117]                     invisible(muffled)
[09:28:27.117]                   }
[09:28:27.117]                   muffleCondition(cond)
[09:28:27.117]                 })
[09:28:27.117]             }))
[09:28:27.117]             future::FutureResult(value = ...future.value$value, 
[09:28:27.117]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.117]                   ...future.rng), globalenv = if (FALSE) 
[09:28:27.117]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:27.117]                     ...future.globalenv.names))
[09:28:27.117]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:27.117]         }, condition = base::local({
[09:28:27.117]             c <- base::c
[09:28:27.117]             inherits <- base::inherits
[09:28:27.117]             invokeRestart <- base::invokeRestart
[09:28:27.117]             length <- base::length
[09:28:27.117]             list <- base::list
[09:28:27.117]             seq.int <- base::seq.int
[09:28:27.117]             signalCondition <- base::signalCondition
[09:28:27.117]             sys.calls <- base::sys.calls
[09:28:27.117]             `[[` <- base::`[[`
[09:28:27.117]             `+` <- base::`+`
[09:28:27.117]             `<<-` <- base::`<<-`
[09:28:27.117]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:27.117]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:27.117]                   3L)]
[09:28:27.117]             }
[09:28:27.117]             function(cond) {
[09:28:27.117]                 is_error <- inherits(cond, "error")
[09:28:27.117]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:27.117]                   NULL)
[09:28:27.117]                 if (is_error) {
[09:28:27.117]                   sessionInformation <- function() {
[09:28:27.117]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:27.117]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:27.117]                       search = base::search(), system = base::Sys.info())
[09:28:27.117]                   }
[09:28:27.117]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.117]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:27.117]                     cond$call), session = sessionInformation(), 
[09:28:27.117]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:27.117]                   signalCondition(cond)
[09:28:27.117]                 }
[09:28:27.117]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:27.117]                 "immediateCondition"))) {
[09:28:27.117]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:27.117]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.117]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:27.117]                   if (TRUE && !signal) {
[09:28:27.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.117]                     {
[09:28:27.117]                       inherits <- base::inherits
[09:28:27.117]                       invokeRestart <- base::invokeRestart
[09:28:27.117]                       is.null <- base::is.null
[09:28:27.117]                       muffled <- FALSE
[09:28:27.117]                       if (inherits(cond, "message")) {
[09:28:27.117]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.117]                         if (muffled) 
[09:28:27.117]                           invokeRestart("muffleMessage")
[09:28:27.117]                       }
[09:28:27.117]                       else if (inherits(cond, "warning")) {
[09:28:27.117]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.117]                         if (muffled) 
[09:28:27.117]                           invokeRestart("muffleWarning")
[09:28:27.117]                       }
[09:28:27.117]                       else if (inherits(cond, "condition")) {
[09:28:27.117]                         if (!is.null(pattern)) {
[09:28:27.117]                           computeRestarts <- base::computeRestarts
[09:28:27.117]                           grepl <- base::grepl
[09:28:27.117]                           restarts <- computeRestarts(cond)
[09:28:27.117]                           for (restart in restarts) {
[09:28:27.117]                             name <- restart$name
[09:28:27.117]                             if (is.null(name)) 
[09:28:27.117]                               next
[09:28:27.117]                             if (!grepl(pattern, name)) 
[09:28:27.117]                               next
[09:28:27.117]                             invokeRestart(restart)
[09:28:27.117]                             muffled <- TRUE
[09:28:27.117]                             break
[09:28:27.117]                           }
[09:28:27.117]                         }
[09:28:27.117]                       }
[09:28:27.117]                       invisible(muffled)
[09:28:27.117]                     }
[09:28:27.117]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.117]                   }
[09:28:27.117]                 }
[09:28:27.117]                 else {
[09:28:27.117]                   if (TRUE) {
[09:28:27.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.117]                     {
[09:28:27.117]                       inherits <- base::inherits
[09:28:27.117]                       invokeRestart <- base::invokeRestart
[09:28:27.117]                       is.null <- base::is.null
[09:28:27.117]                       muffled <- FALSE
[09:28:27.117]                       if (inherits(cond, "message")) {
[09:28:27.117]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.117]                         if (muffled) 
[09:28:27.117]                           invokeRestart("muffleMessage")
[09:28:27.117]                       }
[09:28:27.117]                       else if (inherits(cond, "warning")) {
[09:28:27.117]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.117]                         if (muffled) 
[09:28:27.117]                           invokeRestart("muffleWarning")
[09:28:27.117]                       }
[09:28:27.117]                       else if (inherits(cond, "condition")) {
[09:28:27.117]                         if (!is.null(pattern)) {
[09:28:27.117]                           computeRestarts <- base::computeRestarts
[09:28:27.117]                           grepl <- base::grepl
[09:28:27.117]                           restarts <- computeRestarts(cond)
[09:28:27.117]                           for (restart in restarts) {
[09:28:27.117]                             name <- restart$name
[09:28:27.117]                             if (is.null(name)) 
[09:28:27.117]                               next
[09:28:27.117]                             if (!grepl(pattern, name)) 
[09:28:27.117]                               next
[09:28:27.117]                             invokeRestart(restart)
[09:28:27.117]                             muffled <- TRUE
[09:28:27.117]                             break
[09:28:27.117]                           }
[09:28:27.117]                         }
[09:28:27.117]                       }
[09:28:27.117]                       invisible(muffled)
[09:28:27.117]                     }
[09:28:27.117]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.117]                   }
[09:28:27.117]                 }
[09:28:27.117]             }
[09:28:27.117]         }))
[09:28:27.117]     }, error = function(ex) {
[09:28:27.117]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:27.117]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.117]                 ...future.rng), started = ...future.startTime, 
[09:28:27.117]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:27.117]             version = "1.8"), class = "FutureResult")
[09:28:27.117]     }, finally = {
[09:28:27.117]         if (!identical(...future.workdir, getwd())) 
[09:28:27.117]             setwd(...future.workdir)
[09:28:27.117]         {
[09:28:27.117]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:27.117]                 ...future.oldOptions$nwarnings <- NULL
[09:28:27.117]             }
[09:28:27.117]             base::options(...future.oldOptions)
[09:28:27.117]             if (.Platform$OS.type == "windows") {
[09:28:27.117]                 old_names <- names(...future.oldEnvVars)
[09:28:27.117]                 envs <- base::Sys.getenv()
[09:28:27.117]                 names <- names(envs)
[09:28:27.117]                 common <- intersect(names, old_names)
[09:28:27.117]                 added <- setdiff(names, old_names)
[09:28:27.117]                 removed <- setdiff(old_names, names)
[09:28:27.117]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:27.117]                   envs[common]]
[09:28:27.117]                 NAMES <- toupper(changed)
[09:28:27.117]                 args <- list()
[09:28:27.117]                 for (kk in seq_along(NAMES)) {
[09:28:27.117]                   name <- changed[[kk]]
[09:28:27.117]                   NAME <- NAMES[[kk]]
[09:28:27.117]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.117]                     next
[09:28:27.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.117]                 }
[09:28:27.117]                 NAMES <- toupper(added)
[09:28:27.117]                 for (kk in seq_along(NAMES)) {
[09:28:27.117]                   name <- added[[kk]]
[09:28:27.117]                   NAME <- NAMES[[kk]]
[09:28:27.117]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.117]                     next
[09:28:27.117]                   args[[name]] <- ""
[09:28:27.117]                 }
[09:28:27.117]                 NAMES <- toupper(removed)
[09:28:27.117]                 for (kk in seq_along(NAMES)) {
[09:28:27.117]                   name <- removed[[kk]]
[09:28:27.117]                   NAME <- NAMES[[kk]]
[09:28:27.117]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.117]                     next
[09:28:27.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.117]                 }
[09:28:27.117]                 if (length(args) > 0) 
[09:28:27.117]                   base::do.call(base::Sys.setenv, args = args)
[09:28:27.117]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:27.117]             }
[09:28:27.117]             else {
[09:28:27.117]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:27.117]             }
[09:28:27.117]             {
[09:28:27.117]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:27.117]                   0L) {
[09:28:27.117]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:27.117]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:27.117]                   base::options(opts)
[09:28:27.117]                 }
[09:28:27.117]                 {
[09:28:27.117]                   {
[09:28:27.117]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:27.117]                     NULL
[09:28:27.117]                   }
[09:28:27.117]                   options(future.plan = NULL)
[09:28:27.117]                   if (is.na(NA_character_)) 
[09:28:27.117]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.117]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:27.117]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:27.117]                     .init = FALSE)
[09:28:27.117]                 }
[09:28:27.117]             }
[09:28:27.117]         }
[09:28:27.117]     })
[09:28:27.117]     if (TRUE) {
[09:28:27.117]         base::sink(type = "output", split = FALSE)
[09:28:27.117]         if (TRUE) {
[09:28:27.117]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:27.117]         }
[09:28:27.117]         else {
[09:28:27.117]             ...future.result["stdout"] <- base::list(NULL)
[09:28:27.117]         }
[09:28:27.117]         base::close(...future.stdout)
[09:28:27.117]         ...future.stdout <- NULL
[09:28:27.117]     }
[09:28:27.117]     ...future.result$conditions <- ...future.conditions
[09:28:27.117]     ...future.result$finished <- base::Sys.time()
[09:28:27.117]     ...future.result
[09:28:27.117] }
[09:28:27.119] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[09:28:27.119] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[09:28:27.120] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[09:28:27.120] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[09:28:27.120] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[09:28:27.121] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[09:28:27.121] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[09:28:27.121] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:27.121] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:27.122] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:28:27.122] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:28:27.122] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[09:28:27.123] MultisessionFuture started
[09:28:27.123] - Launch lazy future ... done
[09:28:27.123] run() for ‘MultisessionFuture’ ... done
[09:28:27.123] Created future:
[09:28:27.123] MultisessionFuture:
[09:28:27.123] Label: ‘future_eapply-2’
[09:28:27.123] Expression:
[09:28:27.123] {
[09:28:27.123]     do.call(function(...) {
[09:28:27.123]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.123]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.123]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.123]             on.exit(options(oopts), add = TRUE)
[09:28:27.123]         }
[09:28:27.123]         {
[09:28:27.123]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.123]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.123]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.123]             })
[09:28:27.123]         }
[09:28:27.123]     }, args = future.call.arguments)
[09:28:27.123] }
[09:28:27.123] Lazy evaluation: FALSE
[09:28:27.123] Asynchronous evaluation: TRUE
[09:28:27.123] Local evaluation: TRUE
[09:28:27.123] Environment: R_GlobalEnv
[09:28:27.123] Capture standard output: TRUE
[09:28:27.123] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:27.123] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:27.123] Packages: 1 packages (‘stats’)
[09:28:27.123] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:27.123] Resolved: FALSE
[09:28:27.123] Value: <not collected>
[09:28:27.123] Conditions captured: <none>
[09:28:27.123] Early signaling: FALSE
[09:28:27.123] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:27.123] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.135] Chunk #2 of 2 ... DONE
[09:28:27.135] Launching 2 futures (chunks) ... DONE
[09:28:27.135] Resolving 2 futures (chunks) ...
[09:28:27.135] resolve() on list ...
[09:28:27.135]  recursive: 0
[09:28:27.135]  length: 2
[09:28:27.135] 
[09:28:27.136] receiveMessageFromWorker() for ClusterFuture ...
[09:28:27.136] - Validating connection of MultisessionFuture
[09:28:27.136] - received message: FutureResult
[09:28:27.136] - Received FutureResult
[09:28:27.136] - Erased future from FutureRegistry
[09:28:27.136] result() for ClusterFuture ...
[09:28:27.136] - result already collected: FutureResult
[09:28:27.136] result() for ClusterFuture ... done
[09:28:27.137] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:27.137] Future #1
[09:28:27.137] result() for ClusterFuture ...
[09:28:27.137] - result already collected: FutureResult
[09:28:27.137] result() for ClusterFuture ... done
[09:28:27.137] result() for ClusterFuture ...
[09:28:27.137] - result already collected: FutureResult
[09:28:27.137] result() for ClusterFuture ... done
[09:28:27.137] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:27.137] - nx: 2
[09:28:27.137] - relay: TRUE
[09:28:27.137] - stdout: TRUE
[09:28:27.138] - signal: TRUE
[09:28:27.138] - resignal: FALSE
[09:28:27.138] - force: TRUE
[09:28:27.138] - relayed: [n=2] FALSE, FALSE
[09:28:27.138] - queued futures: [n=2] FALSE, FALSE
[09:28:27.138]  - until=1
[09:28:27.138]  - relaying element #1
[09:28:27.138] result() for ClusterFuture ...
[09:28:27.138] - result already collected: FutureResult
[09:28:27.138] result() for ClusterFuture ... done
[09:28:27.138] result() for ClusterFuture ...
[09:28:27.138] - result already collected: FutureResult
[09:28:27.139] result() for ClusterFuture ... done
[09:28:27.139] result() for ClusterFuture ...
[09:28:27.139] - result already collected: FutureResult
[09:28:27.139] result() for ClusterFuture ... done
[09:28:27.139] result() for ClusterFuture ...
[09:28:27.139] - result already collected: FutureResult
[09:28:27.139] result() for ClusterFuture ... done
[09:28:27.139] - relayed: [n=2] TRUE, FALSE
[09:28:27.139] - queued futures: [n=2] TRUE, FALSE
[09:28:27.139] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:27.139]  length: 1 (resolved future 1)
[09:28:27.181] receiveMessageFromWorker() for ClusterFuture ...
[09:28:27.181] - Validating connection of MultisessionFuture
[09:28:27.181] - received message: FutureResult
[09:28:27.182] - Received FutureResult
[09:28:27.182] - Erased future from FutureRegistry
[09:28:27.182] result() for ClusterFuture ...
[09:28:27.182] - result already collected: FutureResult
[09:28:27.182] result() for ClusterFuture ... done
[09:28:27.182] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:27.182] Future #2
[09:28:27.182] result() for ClusterFuture ...
[09:28:27.182] - result already collected: FutureResult
[09:28:27.182] result() for ClusterFuture ... done
[09:28:27.183] result() for ClusterFuture ...
[09:28:27.183] - result already collected: FutureResult
[09:28:27.183] result() for ClusterFuture ... done
[09:28:27.183] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:27.183] - nx: 2
[09:28:27.183] - relay: TRUE
[09:28:27.183] - stdout: TRUE
[09:28:27.183] - signal: TRUE
[09:28:27.183] - resignal: FALSE
[09:28:27.183] - force: TRUE
[09:28:27.183] - relayed: [n=2] TRUE, FALSE
[09:28:27.184] - queued futures: [n=2] TRUE, FALSE
[09:28:27.184]  - until=2
[09:28:27.184]  - relaying element #2
[09:28:27.184] result() for ClusterFuture ...
[09:28:27.184] - result already collected: FutureResult
[09:28:27.184] result() for ClusterFuture ... done
[09:28:27.184] result() for ClusterFuture ...
[09:28:27.184] - result already collected: FutureResult
[09:28:27.184] result() for ClusterFuture ... done
[09:28:27.184] result() for ClusterFuture ...
[09:28:27.184] - result already collected: FutureResult
[09:28:27.185] result() for ClusterFuture ... done
[09:28:27.185] result() for ClusterFuture ...
[09:28:27.185] - result already collected: FutureResult
[09:28:27.185] result() for ClusterFuture ... done
[09:28:27.185] - relayed: [n=2] TRUE, TRUE
[09:28:27.185] - queued futures: [n=2] TRUE, TRUE
[09:28:27.185] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:27.185]  length: 0 (resolved future 2)
[09:28:27.185] Relaying remaining futures
[09:28:27.185] signalConditionsASAP(NULL, pos=0) ...
[09:28:27.185] - nx: 2
[09:28:27.185] - relay: TRUE
[09:28:27.186] - stdout: TRUE
[09:28:27.186] - signal: TRUE
[09:28:27.186] - resignal: FALSE
[09:28:27.186] - force: TRUE
[09:28:27.186] - relayed: [n=2] TRUE, TRUE
[09:28:27.186] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:27.186] - relayed: [n=2] TRUE, TRUE
[09:28:27.186] - queued futures: [n=2] TRUE, TRUE
[09:28:27.186] signalConditionsASAP(NULL, pos=0) ... done
[09:28:27.186] resolve() on list ... DONE
[09:28:27.186] result() for ClusterFuture ...
[09:28:27.187] - result already collected: FutureResult
[09:28:27.187] result() for ClusterFuture ... done
[09:28:27.187] result() for ClusterFuture ...
[09:28:27.187] - result already collected: FutureResult
[09:28:27.187] result() for ClusterFuture ... done
[09:28:27.187] result() for ClusterFuture ...
[09:28:27.187] - result already collected: FutureResult
[09:28:27.187] result() for ClusterFuture ... done
[09:28:27.187] result() for ClusterFuture ...
[09:28:27.187] - result already collected: FutureResult
[09:28:27.187] result() for ClusterFuture ... done
[09:28:27.187]  - Number of value chunks collected: 2
[09:28:27.188] Resolving 2 futures (chunks) ... DONE
[09:28:27.188] Reducing values from 2 chunks ...
[09:28:27.188]  - Number of values collected after concatenation: 3
[09:28:27.188]  - Number of values expected: 3
[09:28:27.188] Reducing values from 2 chunks ... DONE
[09:28:27.188] future_lapply() ... DONE
[09:28:27.189] future_lapply() ...
[09:28:27.193] Number of chunks: 2
[09:28:27.193] getGlobalsAndPackagesXApply() ...
[09:28:27.193]  - future.globals: TRUE
[09:28:27.193] getGlobalsAndPackages() ...
[09:28:27.193] Searching for globals...
[09:28:27.194] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:27.194] Searching for globals ... DONE
[09:28:27.194] Resolving globals: FALSE
[09:28:27.194] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:27.195] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:27.195] - globals: [1] ‘FUN’
[09:28:27.195] - packages: [1] ‘stats’
[09:28:27.195] getGlobalsAndPackages() ... DONE
[09:28:27.195]  - globals found/used: [n=1] ‘FUN’
[09:28:27.195]  - needed namespaces: [n=1] ‘stats’
[09:28:27.195] Finding globals ... DONE
[09:28:27.196]  - use_args: TRUE
[09:28:27.196]  - Getting '...' globals ...
[09:28:27.196] resolve() on list ...
[09:28:27.196]  recursive: 0
[09:28:27.196]  length: 1
[09:28:27.196]  elements: ‘...’
[09:28:27.196]  length: 0 (resolved future 1)
[09:28:27.196] resolve() on list ... DONE
[09:28:27.197]    - '...' content: [n=0] 
[09:28:27.197] List of 1
[09:28:27.197]  $ ...: list()
[09:28:27.197]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:27.197]  - attr(*, "where")=List of 1
[09:28:27.197]   ..$ ...:<environment: 0x556668364f60> 
[09:28:27.197]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:27.197]  - attr(*, "resolved")= logi TRUE
[09:28:27.197]  - attr(*, "total_size")= num NA
[09:28:27.199]  - Getting '...' globals ... DONE
[09:28:27.204] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:27.205] List of 2
[09:28:27.205]  $ ...future.FUN:function (x, ...)  
[09:28:27.205]  $ ...          : list()
[09:28:27.205]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:27.205]  - attr(*, "where")=List of 2
[09:28:27.205]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:27.205]   ..$ ...          :<environment: 0x556668364f60> 
[09:28:27.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:27.205]  - attr(*, "resolved")= logi FALSE
[09:28:27.205]  - attr(*, "total_size")= num 1248
[09:28:27.207] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:27.207] getGlobalsAndPackagesXApply() ... DONE
[09:28:27.208] Number of futures (= number of chunks): 2
[09:28:27.208] Launching 2 futures (chunks) ...
[09:28:27.208] Chunk #1 of 2 ...
[09:28:27.208]  - Finding globals in 'X' for chunk #1 ...
[09:28:27.208] getGlobalsAndPackages() ...
[09:28:27.208] Searching for globals...
[09:28:27.208] 
[09:28:27.208] Searching for globals ... DONE
[09:28:27.209] - globals: [0] <none>
[09:28:27.209] getGlobalsAndPackages() ... DONE
[09:28:27.209]    + additional globals found: [n=0] 
[09:28:27.209]    + additional namespaces needed: [n=0] 
[09:28:27.209]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:27.209]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:27.209]  - seeds: <none>
[09:28:27.209]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.209] getGlobalsAndPackages() ...
[09:28:27.209] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.209] Resolving globals: FALSE
[09:28:27.210] Tweak future expression to call with '...' arguments ...
[09:28:27.210] {
[09:28:27.210]     do.call(function(...) {
[09:28:27.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.210]             on.exit(options(oopts), add = TRUE)
[09:28:27.210]         }
[09:28:27.210]         {
[09:28:27.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.210]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.210]             })
[09:28:27.210]         }
[09:28:27.210]     }, args = future.call.arguments)
[09:28:27.210] }
[09:28:27.210] Tweak future expression to call with '...' arguments ... DONE
[09:28:27.210] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.210] - packages: [1] ‘stats’
[09:28:27.210] getGlobalsAndPackages() ... DONE
[09:28:27.211] run() for ‘Future’ ...
[09:28:27.211] - state: ‘created’
[09:28:27.211] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:27.225] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:27.225]   - Field: ‘node’
[09:28:27.225]   - Field: ‘label’
[09:28:27.225]   - Field: ‘local’
[09:28:27.225]   - Field: ‘owner’
[09:28:27.225]   - Field: ‘envir’
[09:28:27.225]   - Field: ‘workers’
[09:28:27.226]   - Field: ‘packages’
[09:28:27.226]   - Field: ‘gc’
[09:28:27.226]   - Field: ‘conditions’
[09:28:27.226]   - Field: ‘persistent’
[09:28:27.226]   - Field: ‘expr’
[09:28:27.226]   - Field: ‘uuid’
[09:28:27.226]   - Field: ‘seed’
[09:28:27.226]   - Field: ‘version’
[09:28:27.226]   - Field: ‘result’
[09:28:27.226]   - Field: ‘asynchronous’
[09:28:27.226]   - Field: ‘calls’
[09:28:27.226]   - Field: ‘globals’
[09:28:27.227]   - Field: ‘stdout’
[09:28:27.227]   - Field: ‘earlySignal’
[09:28:27.227]   - Field: ‘lazy’
[09:28:27.227]   - Field: ‘state’
[09:28:27.227] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:27.227] - Launch lazy future ...
[09:28:27.227] Packages needed by the future expression (n = 1): ‘stats’
[09:28:27.227] Packages needed by future strategies (n = 0): <none>
[09:28:27.228] {
[09:28:27.228]     {
[09:28:27.228]         {
[09:28:27.228]             ...future.startTime <- base::Sys.time()
[09:28:27.228]             {
[09:28:27.228]                 {
[09:28:27.228]                   {
[09:28:27.228]                     {
[09:28:27.228]                       {
[09:28:27.228]                         base::local({
[09:28:27.228]                           has_future <- base::requireNamespace("future", 
[09:28:27.228]                             quietly = TRUE)
[09:28:27.228]                           if (has_future) {
[09:28:27.228]                             ns <- base::getNamespace("future")
[09:28:27.228]                             version <- ns[[".package"]][["version"]]
[09:28:27.228]                             if (is.null(version)) 
[09:28:27.228]                               version <- utils::packageVersion("future")
[09:28:27.228]                           }
[09:28:27.228]                           else {
[09:28:27.228]                             version <- NULL
[09:28:27.228]                           }
[09:28:27.228]                           if (!has_future || version < "1.8.0") {
[09:28:27.228]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:27.228]                               "", base::R.version$version.string), 
[09:28:27.228]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:27.228]                                 base::R.version$platform, 8 * 
[09:28:27.228]                                   base::.Machine$sizeof.pointer), 
[09:28:27.228]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:27.228]                                 "release", "version")], collapse = " "), 
[09:28:27.228]                               hostname = base::Sys.info()[["nodename"]])
[09:28:27.228]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:27.228]                               info)
[09:28:27.228]                             info <- base::paste(info, collapse = "; ")
[09:28:27.228]                             if (!has_future) {
[09:28:27.228]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:27.228]                                 info)
[09:28:27.228]                             }
[09:28:27.228]                             else {
[09:28:27.228]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:27.228]                                 info, version)
[09:28:27.228]                             }
[09:28:27.228]                             base::stop(msg)
[09:28:27.228]                           }
[09:28:27.228]                         })
[09:28:27.228]                       }
[09:28:27.228]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:27.228]                       base::options(mc.cores = 1L)
[09:28:27.228]                     }
[09:28:27.228]                     base::local({
[09:28:27.228]                       for (pkg in "stats") {
[09:28:27.228]                         base::loadNamespace(pkg)
[09:28:27.228]                         base::library(pkg, character.only = TRUE)
[09:28:27.228]                       }
[09:28:27.228]                     })
[09:28:27.228]                   }
[09:28:27.228]                   ...future.strategy.old <- future::plan("list")
[09:28:27.228]                   options(future.plan = NULL)
[09:28:27.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:27.228]                 }
[09:28:27.228]                 ...future.workdir <- getwd()
[09:28:27.228]             }
[09:28:27.228]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:27.228]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:27.228]         }
[09:28:27.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:27.228]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:27.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:27.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:27.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:27.228]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:27.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:27.228]             base::names(...future.oldOptions))
[09:28:27.228]     }
[09:28:27.228]     if (FALSE) {
[09:28:27.228]     }
[09:28:27.228]     else {
[09:28:27.228]         if (TRUE) {
[09:28:27.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:27.228]                 open = "w")
[09:28:27.228]         }
[09:28:27.228]         else {
[09:28:27.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:27.228]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:27.228]         }
[09:28:27.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:27.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:27.228]             base::sink(type = "output", split = FALSE)
[09:28:27.228]             base::close(...future.stdout)
[09:28:27.228]         }, add = TRUE)
[09:28:27.228]     }
[09:28:27.228]     ...future.frame <- base::sys.nframe()
[09:28:27.228]     ...future.conditions <- base::list()
[09:28:27.228]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:27.228]     if (FALSE) {
[09:28:27.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:27.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:27.228]     }
[09:28:27.228]     ...future.result <- base::tryCatch({
[09:28:27.228]         base::withCallingHandlers({
[09:28:27.228]             ...future.value <- base::withVisible(base::local({
[09:28:27.228]                 ...future.makeSendCondition <- base::local({
[09:28:27.228]                   sendCondition <- NULL
[09:28:27.228]                   function(frame = 1L) {
[09:28:27.228]                     if (is.function(sendCondition)) 
[09:28:27.228]                       return(sendCondition)
[09:28:27.228]                     ns <- getNamespace("parallel")
[09:28:27.228]                     if (exists("sendData", mode = "function", 
[09:28:27.228]                       envir = ns)) {
[09:28:27.228]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:27.228]                         envir = ns)
[09:28:27.228]                       envir <- sys.frame(frame)
[09:28:27.228]                       master <- NULL
[09:28:27.228]                       while (!identical(envir, .GlobalEnv) && 
[09:28:27.228]                         !identical(envir, emptyenv())) {
[09:28:27.228]                         if (exists("master", mode = "list", envir = envir, 
[09:28:27.228]                           inherits = FALSE)) {
[09:28:27.228]                           master <- get("master", mode = "list", 
[09:28:27.228]                             envir = envir, inherits = FALSE)
[09:28:27.228]                           if (inherits(master, c("SOCKnode", 
[09:28:27.228]                             "SOCK0node"))) {
[09:28:27.228]                             sendCondition <<- function(cond) {
[09:28:27.228]                               data <- list(type = "VALUE", value = cond, 
[09:28:27.228]                                 success = TRUE)
[09:28:27.228]                               parallel_sendData(master, data)
[09:28:27.228]                             }
[09:28:27.228]                             return(sendCondition)
[09:28:27.228]                           }
[09:28:27.228]                         }
[09:28:27.228]                         frame <- frame + 1L
[09:28:27.228]                         envir <- sys.frame(frame)
[09:28:27.228]                       }
[09:28:27.228]                     }
[09:28:27.228]                     sendCondition <<- function(cond) NULL
[09:28:27.228]                   }
[09:28:27.228]                 })
[09:28:27.228]                 withCallingHandlers({
[09:28:27.228]                   {
[09:28:27.228]                     do.call(function(...) {
[09:28:27.228]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.228]                       if (!identical(...future.globals.maxSize.org, 
[09:28:27.228]                         ...future.globals.maxSize)) {
[09:28:27.228]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.228]                         on.exit(options(oopts), add = TRUE)
[09:28:27.228]                       }
[09:28:27.228]                       {
[09:28:27.228]                         lapply(seq_along(...future.elements_ii), 
[09:28:27.228]                           FUN = function(jj) {
[09:28:27.228]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.228]                             ...future.FUN(...future.X_jj, ...)
[09:28:27.228]                           })
[09:28:27.228]                       }
[09:28:27.228]                     }, args = future.call.arguments)
[09:28:27.228]                   }
[09:28:27.228]                 }, immediateCondition = function(cond) {
[09:28:27.228]                   sendCondition <- ...future.makeSendCondition()
[09:28:27.228]                   sendCondition(cond)
[09:28:27.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.228]                   {
[09:28:27.228]                     inherits <- base::inherits
[09:28:27.228]                     invokeRestart <- base::invokeRestart
[09:28:27.228]                     is.null <- base::is.null
[09:28:27.228]                     muffled <- FALSE
[09:28:27.228]                     if (inherits(cond, "message")) {
[09:28:27.228]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:27.228]                       if (muffled) 
[09:28:27.228]                         invokeRestart("muffleMessage")
[09:28:27.228]                     }
[09:28:27.228]                     else if (inherits(cond, "warning")) {
[09:28:27.228]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:27.228]                       if (muffled) 
[09:28:27.228]                         invokeRestart("muffleWarning")
[09:28:27.228]                     }
[09:28:27.228]                     else if (inherits(cond, "condition")) {
[09:28:27.228]                       if (!is.null(pattern)) {
[09:28:27.228]                         computeRestarts <- base::computeRestarts
[09:28:27.228]                         grepl <- base::grepl
[09:28:27.228]                         restarts <- computeRestarts(cond)
[09:28:27.228]                         for (restart in restarts) {
[09:28:27.228]                           name <- restart$name
[09:28:27.228]                           if (is.null(name)) 
[09:28:27.228]                             next
[09:28:27.228]                           if (!grepl(pattern, name)) 
[09:28:27.228]                             next
[09:28:27.228]                           invokeRestart(restart)
[09:28:27.228]                           muffled <- TRUE
[09:28:27.228]                           break
[09:28:27.228]                         }
[09:28:27.228]                       }
[09:28:27.228]                     }
[09:28:27.228]                     invisible(muffled)
[09:28:27.228]                   }
[09:28:27.228]                   muffleCondition(cond)
[09:28:27.228]                 })
[09:28:27.228]             }))
[09:28:27.228]             future::FutureResult(value = ...future.value$value, 
[09:28:27.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.228]                   ...future.rng), globalenv = if (FALSE) 
[09:28:27.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:27.228]                     ...future.globalenv.names))
[09:28:27.228]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:27.228]         }, condition = base::local({
[09:28:27.228]             c <- base::c
[09:28:27.228]             inherits <- base::inherits
[09:28:27.228]             invokeRestart <- base::invokeRestart
[09:28:27.228]             length <- base::length
[09:28:27.228]             list <- base::list
[09:28:27.228]             seq.int <- base::seq.int
[09:28:27.228]             signalCondition <- base::signalCondition
[09:28:27.228]             sys.calls <- base::sys.calls
[09:28:27.228]             `[[` <- base::`[[`
[09:28:27.228]             `+` <- base::`+`
[09:28:27.228]             `<<-` <- base::`<<-`
[09:28:27.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:27.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:27.228]                   3L)]
[09:28:27.228]             }
[09:28:27.228]             function(cond) {
[09:28:27.228]                 is_error <- inherits(cond, "error")
[09:28:27.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:27.228]                   NULL)
[09:28:27.228]                 if (is_error) {
[09:28:27.228]                   sessionInformation <- function() {
[09:28:27.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:27.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:27.228]                       search = base::search(), system = base::Sys.info())
[09:28:27.228]                   }
[09:28:27.228]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:27.228]                     cond$call), session = sessionInformation(), 
[09:28:27.228]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:27.228]                   signalCondition(cond)
[09:28:27.228]                 }
[09:28:27.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:27.228]                 "immediateCondition"))) {
[09:28:27.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:27.228]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:27.228]                   if (TRUE && !signal) {
[09:28:27.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.228]                     {
[09:28:27.228]                       inherits <- base::inherits
[09:28:27.228]                       invokeRestart <- base::invokeRestart
[09:28:27.228]                       is.null <- base::is.null
[09:28:27.228]                       muffled <- FALSE
[09:28:27.228]                       if (inherits(cond, "message")) {
[09:28:27.228]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.228]                         if (muffled) 
[09:28:27.228]                           invokeRestart("muffleMessage")
[09:28:27.228]                       }
[09:28:27.228]                       else if (inherits(cond, "warning")) {
[09:28:27.228]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.228]                         if (muffled) 
[09:28:27.228]                           invokeRestart("muffleWarning")
[09:28:27.228]                       }
[09:28:27.228]                       else if (inherits(cond, "condition")) {
[09:28:27.228]                         if (!is.null(pattern)) {
[09:28:27.228]                           computeRestarts <- base::computeRestarts
[09:28:27.228]                           grepl <- base::grepl
[09:28:27.228]                           restarts <- computeRestarts(cond)
[09:28:27.228]                           for (restart in restarts) {
[09:28:27.228]                             name <- restart$name
[09:28:27.228]                             if (is.null(name)) 
[09:28:27.228]                               next
[09:28:27.228]                             if (!grepl(pattern, name)) 
[09:28:27.228]                               next
[09:28:27.228]                             invokeRestart(restart)
[09:28:27.228]                             muffled <- TRUE
[09:28:27.228]                             break
[09:28:27.228]                           }
[09:28:27.228]                         }
[09:28:27.228]                       }
[09:28:27.228]                       invisible(muffled)
[09:28:27.228]                     }
[09:28:27.228]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.228]                   }
[09:28:27.228]                 }
[09:28:27.228]                 else {
[09:28:27.228]                   if (TRUE) {
[09:28:27.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.228]                     {
[09:28:27.228]                       inherits <- base::inherits
[09:28:27.228]                       invokeRestart <- base::invokeRestart
[09:28:27.228]                       is.null <- base::is.null
[09:28:27.228]                       muffled <- FALSE
[09:28:27.228]                       if (inherits(cond, "message")) {
[09:28:27.228]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.228]                         if (muffled) 
[09:28:27.228]                           invokeRestart("muffleMessage")
[09:28:27.228]                       }
[09:28:27.228]                       else if (inherits(cond, "warning")) {
[09:28:27.228]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.228]                         if (muffled) 
[09:28:27.228]                           invokeRestart("muffleWarning")
[09:28:27.228]                       }
[09:28:27.228]                       else if (inherits(cond, "condition")) {
[09:28:27.228]                         if (!is.null(pattern)) {
[09:28:27.228]                           computeRestarts <- base::computeRestarts
[09:28:27.228]                           grepl <- base::grepl
[09:28:27.228]                           restarts <- computeRestarts(cond)
[09:28:27.228]                           for (restart in restarts) {
[09:28:27.228]                             name <- restart$name
[09:28:27.228]                             if (is.null(name)) 
[09:28:27.228]                               next
[09:28:27.228]                             if (!grepl(pattern, name)) 
[09:28:27.228]                               next
[09:28:27.228]                             invokeRestart(restart)
[09:28:27.228]                             muffled <- TRUE
[09:28:27.228]                             break
[09:28:27.228]                           }
[09:28:27.228]                         }
[09:28:27.228]                       }
[09:28:27.228]                       invisible(muffled)
[09:28:27.228]                     }
[09:28:27.228]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.228]                   }
[09:28:27.228]                 }
[09:28:27.228]             }
[09:28:27.228]         }))
[09:28:27.228]     }, error = function(ex) {
[09:28:27.228]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:27.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.228]                 ...future.rng), started = ...future.startTime, 
[09:28:27.228]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:27.228]             version = "1.8"), class = "FutureResult")
[09:28:27.228]     }, finally = {
[09:28:27.228]         if (!identical(...future.workdir, getwd())) 
[09:28:27.228]             setwd(...future.workdir)
[09:28:27.228]         {
[09:28:27.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:27.228]                 ...future.oldOptions$nwarnings <- NULL
[09:28:27.228]             }
[09:28:27.228]             base::options(...future.oldOptions)
[09:28:27.228]             if (.Platform$OS.type == "windows") {
[09:28:27.228]                 old_names <- names(...future.oldEnvVars)
[09:28:27.228]                 envs <- base::Sys.getenv()
[09:28:27.228]                 names <- names(envs)
[09:28:27.228]                 common <- intersect(names, old_names)
[09:28:27.228]                 added <- setdiff(names, old_names)
[09:28:27.228]                 removed <- setdiff(old_names, names)
[09:28:27.228]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:27.228]                   envs[common]]
[09:28:27.228]                 NAMES <- toupper(changed)
[09:28:27.228]                 args <- list()
[09:28:27.228]                 for (kk in seq_along(NAMES)) {
[09:28:27.228]                   name <- changed[[kk]]
[09:28:27.228]                   NAME <- NAMES[[kk]]
[09:28:27.228]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.228]                     next
[09:28:27.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.228]                 }
[09:28:27.228]                 NAMES <- toupper(added)
[09:28:27.228]                 for (kk in seq_along(NAMES)) {
[09:28:27.228]                   name <- added[[kk]]
[09:28:27.228]                   NAME <- NAMES[[kk]]
[09:28:27.228]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.228]                     next
[09:28:27.228]                   args[[name]] <- ""
[09:28:27.228]                 }
[09:28:27.228]                 NAMES <- toupper(removed)
[09:28:27.228]                 for (kk in seq_along(NAMES)) {
[09:28:27.228]                   name <- removed[[kk]]
[09:28:27.228]                   NAME <- NAMES[[kk]]
[09:28:27.228]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.228]                     next
[09:28:27.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.228]                 }
[09:28:27.228]                 if (length(args) > 0) 
[09:28:27.228]                   base::do.call(base::Sys.setenv, args = args)
[09:28:27.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:27.228]             }
[09:28:27.228]             else {
[09:28:27.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:27.228]             }
[09:28:27.228]             {
[09:28:27.228]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:27.228]                   0L) {
[09:28:27.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:27.228]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:27.228]                   base::options(opts)
[09:28:27.228]                 }
[09:28:27.228]                 {
[09:28:27.228]                   {
[09:28:27.228]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:27.228]                     NULL
[09:28:27.228]                   }
[09:28:27.228]                   options(future.plan = NULL)
[09:28:27.228]                   if (is.na(NA_character_)) 
[09:28:27.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:27.228]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:27.228]                     .init = FALSE)
[09:28:27.228]                 }
[09:28:27.228]             }
[09:28:27.228]         }
[09:28:27.228]     })
[09:28:27.228]     if (TRUE) {
[09:28:27.228]         base::sink(type = "output", split = FALSE)
[09:28:27.228]         if (TRUE) {
[09:28:27.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:27.228]         }
[09:28:27.228]         else {
[09:28:27.228]             ...future.result["stdout"] <- base::list(NULL)
[09:28:27.228]         }
[09:28:27.228]         base::close(...future.stdout)
[09:28:27.228]         ...future.stdout <- NULL
[09:28:27.228]     }
[09:28:27.228]     ...future.result$conditions <- ...future.conditions
[09:28:27.228]     ...future.result$finished <- base::Sys.time()
[09:28:27.228]     ...future.result
[09:28:27.228] }
[09:28:27.231] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[09:28:27.231] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[09:28:27.231] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[09:28:27.231] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:27.232] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:27.232] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[09:28:27.232] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[09:28:27.232] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:27.233] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:27.233] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:28:27.233] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:28:27.233] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[09:28:27.234] MultisessionFuture started
[09:28:27.234] - Launch lazy future ... done
[09:28:27.234] run() for ‘MultisessionFuture’ ... done
[09:28:27.234] Created future:
[09:28:27.234] MultisessionFuture:
[09:28:27.234] Label: ‘future_eapply-1’
[09:28:27.234] Expression:
[09:28:27.234] {
[09:28:27.234]     do.call(function(...) {
[09:28:27.234]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.234]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.234]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.234]             on.exit(options(oopts), add = TRUE)
[09:28:27.234]         }
[09:28:27.234]         {
[09:28:27.234]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.234]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.234]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.234]             })
[09:28:27.234]         }
[09:28:27.234]     }, args = future.call.arguments)
[09:28:27.234] }
[09:28:27.234] Lazy evaluation: FALSE
[09:28:27.234] Asynchronous evaluation: TRUE
[09:28:27.234] Local evaluation: TRUE
[09:28:27.234] Environment: R_GlobalEnv
[09:28:27.234] Capture standard output: TRUE
[09:28:27.234] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:27.234] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:27.234] Packages: 1 packages (‘stats’)
[09:28:27.234] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:27.234] Resolved: FALSE
[09:28:27.234] Value: <not collected>
[09:28:27.234] Conditions captured: <none>
[09:28:27.234] Early signaling: FALSE
[09:28:27.234] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:27.234] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.246] Chunk #1 of 2 ... DONE
[09:28:27.246] Chunk #2 of 2 ...
[09:28:27.246]  - Finding globals in 'X' for chunk #2 ...
[09:28:27.246] getGlobalsAndPackages() ...
[09:28:27.246] Searching for globals...
[09:28:27.247] 
[09:28:27.247] Searching for globals ... DONE
[09:28:27.247] - globals: [0] <none>
[09:28:27.247] getGlobalsAndPackages() ... DONE
[09:28:27.247]    + additional globals found: [n=0] 
[09:28:27.247]    + additional namespaces needed: [n=0] 
[09:28:27.247]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:27.247]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:27.247]  - seeds: <none>
[09:28:27.247]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.248] getGlobalsAndPackages() ...
[09:28:27.248] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.248] Resolving globals: FALSE
[09:28:27.248] Tweak future expression to call with '...' arguments ...
[09:28:27.248] {
[09:28:27.248]     do.call(function(...) {
[09:28:27.248]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.248]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.248]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.248]             on.exit(options(oopts), add = TRUE)
[09:28:27.248]         }
[09:28:27.248]         {
[09:28:27.248]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.248]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.248]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.248]             })
[09:28:27.248]         }
[09:28:27.248]     }, args = future.call.arguments)
[09:28:27.248] }
[09:28:27.248] Tweak future expression to call with '...' arguments ... DONE
[09:28:27.249] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.249] - packages: [1] ‘stats’
[09:28:27.249] getGlobalsAndPackages() ... DONE
[09:28:27.249] run() for ‘Future’ ...
[09:28:27.249] - state: ‘created’
[09:28:27.249] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:27.265] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:27.265]   - Field: ‘node’
[09:28:27.265]   - Field: ‘label’
[09:28:27.265]   - Field: ‘local’
[09:28:27.265]   - Field: ‘owner’
[09:28:27.266]   - Field: ‘envir’
[09:28:27.266]   - Field: ‘workers’
[09:28:27.266]   - Field: ‘packages’
[09:28:27.266]   - Field: ‘gc’
[09:28:27.266]   - Field: ‘conditions’
[09:28:27.266]   - Field: ‘persistent’
[09:28:27.266]   - Field: ‘expr’
[09:28:27.266]   - Field: ‘uuid’
[09:28:27.266]   - Field: ‘seed’
[09:28:27.266]   - Field: ‘version’
[09:28:27.266]   - Field: ‘result’
[09:28:27.267]   - Field: ‘asynchronous’
[09:28:27.267]   - Field: ‘calls’
[09:28:27.267]   - Field: ‘globals’
[09:28:27.267]   - Field: ‘stdout’
[09:28:27.267]   - Field: ‘earlySignal’
[09:28:27.267]   - Field: ‘lazy’
[09:28:27.267]   - Field: ‘state’
[09:28:27.267] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:27.267] - Launch lazy future ...
[09:28:27.268] Packages needed by the future expression (n = 1): ‘stats’
[09:28:27.268] Packages needed by future strategies (n = 0): <none>
[09:28:27.268] {
[09:28:27.268]     {
[09:28:27.268]         {
[09:28:27.268]             ...future.startTime <- base::Sys.time()
[09:28:27.268]             {
[09:28:27.268]                 {
[09:28:27.268]                   {
[09:28:27.268]                     {
[09:28:27.268]                       {
[09:28:27.268]                         base::local({
[09:28:27.268]                           has_future <- base::requireNamespace("future", 
[09:28:27.268]                             quietly = TRUE)
[09:28:27.268]                           if (has_future) {
[09:28:27.268]                             ns <- base::getNamespace("future")
[09:28:27.268]                             version <- ns[[".package"]][["version"]]
[09:28:27.268]                             if (is.null(version)) 
[09:28:27.268]                               version <- utils::packageVersion("future")
[09:28:27.268]                           }
[09:28:27.268]                           else {
[09:28:27.268]                             version <- NULL
[09:28:27.268]                           }
[09:28:27.268]                           if (!has_future || version < "1.8.0") {
[09:28:27.268]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:27.268]                               "", base::R.version$version.string), 
[09:28:27.268]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:27.268]                                 base::R.version$platform, 8 * 
[09:28:27.268]                                   base::.Machine$sizeof.pointer), 
[09:28:27.268]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:27.268]                                 "release", "version")], collapse = " "), 
[09:28:27.268]                               hostname = base::Sys.info()[["nodename"]])
[09:28:27.268]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:27.268]                               info)
[09:28:27.268]                             info <- base::paste(info, collapse = "; ")
[09:28:27.268]                             if (!has_future) {
[09:28:27.268]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:27.268]                                 info)
[09:28:27.268]                             }
[09:28:27.268]                             else {
[09:28:27.268]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:27.268]                                 info, version)
[09:28:27.268]                             }
[09:28:27.268]                             base::stop(msg)
[09:28:27.268]                           }
[09:28:27.268]                         })
[09:28:27.268]                       }
[09:28:27.268]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:27.268]                       base::options(mc.cores = 1L)
[09:28:27.268]                     }
[09:28:27.268]                     base::local({
[09:28:27.268]                       for (pkg in "stats") {
[09:28:27.268]                         base::loadNamespace(pkg)
[09:28:27.268]                         base::library(pkg, character.only = TRUE)
[09:28:27.268]                       }
[09:28:27.268]                     })
[09:28:27.268]                   }
[09:28:27.268]                   ...future.strategy.old <- future::plan("list")
[09:28:27.268]                   options(future.plan = NULL)
[09:28:27.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:27.268]                 }
[09:28:27.268]                 ...future.workdir <- getwd()
[09:28:27.268]             }
[09:28:27.268]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:27.268]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:27.268]         }
[09:28:27.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:27.268]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:27.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:27.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:27.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:27.268]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:27.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:27.268]             base::names(...future.oldOptions))
[09:28:27.268]     }
[09:28:27.268]     if (FALSE) {
[09:28:27.268]     }
[09:28:27.268]     else {
[09:28:27.268]         if (TRUE) {
[09:28:27.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:27.268]                 open = "w")
[09:28:27.268]         }
[09:28:27.268]         else {
[09:28:27.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:27.268]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:27.268]         }
[09:28:27.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:27.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:27.268]             base::sink(type = "output", split = FALSE)
[09:28:27.268]             base::close(...future.stdout)
[09:28:27.268]         }, add = TRUE)
[09:28:27.268]     }
[09:28:27.268]     ...future.frame <- base::sys.nframe()
[09:28:27.268]     ...future.conditions <- base::list()
[09:28:27.268]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:27.268]     if (FALSE) {
[09:28:27.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:27.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:27.268]     }
[09:28:27.268]     ...future.result <- base::tryCatch({
[09:28:27.268]         base::withCallingHandlers({
[09:28:27.268]             ...future.value <- base::withVisible(base::local({
[09:28:27.268]                 ...future.makeSendCondition <- base::local({
[09:28:27.268]                   sendCondition <- NULL
[09:28:27.268]                   function(frame = 1L) {
[09:28:27.268]                     if (is.function(sendCondition)) 
[09:28:27.268]                       return(sendCondition)
[09:28:27.268]                     ns <- getNamespace("parallel")
[09:28:27.268]                     if (exists("sendData", mode = "function", 
[09:28:27.268]                       envir = ns)) {
[09:28:27.268]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:27.268]                         envir = ns)
[09:28:27.268]                       envir <- sys.frame(frame)
[09:28:27.268]                       master <- NULL
[09:28:27.268]                       while (!identical(envir, .GlobalEnv) && 
[09:28:27.268]                         !identical(envir, emptyenv())) {
[09:28:27.268]                         if (exists("master", mode = "list", envir = envir, 
[09:28:27.268]                           inherits = FALSE)) {
[09:28:27.268]                           master <- get("master", mode = "list", 
[09:28:27.268]                             envir = envir, inherits = FALSE)
[09:28:27.268]                           if (inherits(master, c("SOCKnode", 
[09:28:27.268]                             "SOCK0node"))) {
[09:28:27.268]                             sendCondition <<- function(cond) {
[09:28:27.268]                               data <- list(type = "VALUE", value = cond, 
[09:28:27.268]                                 success = TRUE)
[09:28:27.268]                               parallel_sendData(master, data)
[09:28:27.268]                             }
[09:28:27.268]                             return(sendCondition)
[09:28:27.268]                           }
[09:28:27.268]                         }
[09:28:27.268]                         frame <- frame + 1L
[09:28:27.268]                         envir <- sys.frame(frame)
[09:28:27.268]                       }
[09:28:27.268]                     }
[09:28:27.268]                     sendCondition <<- function(cond) NULL
[09:28:27.268]                   }
[09:28:27.268]                 })
[09:28:27.268]                 withCallingHandlers({
[09:28:27.268]                   {
[09:28:27.268]                     do.call(function(...) {
[09:28:27.268]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.268]                       if (!identical(...future.globals.maxSize.org, 
[09:28:27.268]                         ...future.globals.maxSize)) {
[09:28:27.268]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.268]                         on.exit(options(oopts), add = TRUE)
[09:28:27.268]                       }
[09:28:27.268]                       {
[09:28:27.268]                         lapply(seq_along(...future.elements_ii), 
[09:28:27.268]                           FUN = function(jj) {
[09:28:27.268]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.268]                             ...future.FUN(...future.X_jj, ...)
[09:28:27.268]                           })
[09:28:27.268]                       }
[09:28:27.268]                     }, args = future.call.arguments)
[09:28:27.268]                   }
[09:28:27.268]                 }, immediateCondition = function(cond) {
[09:28:27.268]                   sendCondition <- ...future.makeSendCondition()
[09:28:27.268]                   sendCondition(cond)
[09:28:27.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.268]                   {
[09:28:27.268]                     inherits <- base::inherits
[09:28:27.268]                     invokeRestart <- base::invokeRestart
[09:28:27.268]                     is.null <- base::is.null
[09:28:27.268]                     muffled <- FALSE
[09:28:27.268]                     if (inherits(cond, "message")) {
[09:28:27.268]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:27.268]                       if (muffled) 
[09:28:27.268]                         invokeRestart("muffleMessage")
[09:28:27.268]                     }
[09:28:27.268]                     else if (inherits(cond, "warning")) {
[09:28:27.268]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:27.268]                       if (muffled) 
[09:28:27.268]                         invokeRestart("muffleWarning")
[09:28:27.268]                     }
[09:28:27.268]                     else if (inherits(cond, "condition")) {
[09:28:27.268]                       if (!is.null(pattern)) {
[09:28:27.268]                         computeRestarts <- base::computeRestarts
[09:28:27.268]                         grepl <- base::grepl
[09:28:27.268]                         restarts <- computeRestarts(cond)
[09:28:27.268]                         for (restart in restarts) {
[09:28:27.268]                           name <- restart$name
[09:28:27.268]                           if (is.null(name)) 
[09:28:27.268]                             next
[09:28:27.268]                           if (!grepl(pattern, name)) 
[09:28:27.268]                             next
[09:28:27.268]                           invokeRestart(restart)
[09:28:27.268]                           muffled <- TRUE
[09:28:27.268]                           break
[09:28:27.268]                         }
[09:28:27.268]                       }
[09:28:27.268]                     }
[09:28:27.268]                     invisible(muffled)
[09:28:27.268]                   }
[09:28:27.268]                   muffleCondition(cond)
[09:28:27.268]                 })
[09:28:27.268]             }))
[09:28:27.268]             future::FutureResult(value = ...future.value$value, 
[09:28:27.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.268]                   ...future.rng), globalenv = if (FALSE) 
[09:28:27.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:27.268]                     ...future.globalenv.names))
[09:28:27.268]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:27.268]         }, condition = base::local({
[09:28:27.268]             c <- base::c
[09:28:27.268]             inherits <- base::inherits
[09:28:27.268]             invokeRestart <- base::invokeRestart
[09:28:27.268]             length <- base::length
[09:28:27.268]             list <- base::list
[09:28:27.268]             seq.int <- base::seq.int
[09:28:27.268]             signalCondition <- base::signalCondition
[09:28:27.268]             sys.calls <- base::sys.calls
[09:28:27.268]             `[[` <- base::`[[`
[09:28:27.268]             `+` <- base::`+`
[09:28:27.268]             `<<-` <- base::`<<-`
[09:28:27.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:27.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:27.268]                   3L)]
[09:28:27.268]             }
[09:28:27.268]             function(cond) {
[09:28:27.268]                 is_error <- inherits(cond, "error")
[09:28:27.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:27.268]                   NULL)
[09:28:27.268]                 if (is_error) {
[09:28:27.268]                   sessionInformation <- function() {
[09:28:27.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:27.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:27.268]                       search = base::search(), system = base::Sys.info())
[09:28:27.268]                   }
[09:28:27.268]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:27.268]                     cond$call), session = sessionInformation(), 
[09:28:27.268]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:27.268]                   signalCondition(cond)
[09:28:27.268]                 }
[09:28:27.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:27.268]                 "immediateCondition"))) {
[09:28:27.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:27.268]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:27.268]                   if (TRUE && !signal) {
[09:28:27.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.268]                     {
[09:28:27.268]                       inherits <- base::inherits
[09:28:27.268]                       invokeRestart <- base::invokeRestart
[09:28:27.268]                       is.null <- base::is.null
[09:28:27.268]                       muffled <- FALSE
[09:28:27.268]                       if (inherits(cond, "message")) {
[09:28:27.268]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.268]                         if (muffled) 
[09:28:27.268]                           invokeRestart("muffleMessage")
[09:28:27.268]                       }
[09:28:27.268]                       else if (inherits(cond, "warning")) {
[09:28:27.268]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.268]                         if (muffled) 
[09:28:27.268]                           invokeRestart("muffleWarning")
[09:28:27.268]                       }
[09:28:27.268]                       else if (inherits(cond, "condition")) {
[09:28:27.268]                         if (!is.null(pattern)) {
[09:28:27.268]                           computeRestarts <- base::computeRestarts
[09:28:27.268]                           grepl <- base::grepl
[09:28:27.268]                           restarts <- computeRestarts(cond)
[09:28:27.268]                           for (restart in restarts) {
[09:28:27.268]                             name <- restart$name
[09:28:27.268]                             if (is.null(name)) 
[09:28:27.268]                               next
[09:28:27.268]                             if (!grepl(pattern, name)) 
[09:28:27.268]                               next
[09:28:27.268]                             invokeRestart(restart)
[09:28:27.268]                             muffled <- TRUE
[09:28:27.268]                             break
[09:28:27.268]                           }
[09:28:27.268]                         }
[09:28:27.268]                       }
[09:28:27.268]                       invisible(muffled)
[09:28:27.268]                     }
[09:28:27.268]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.268]                   }
[09:28:27.268]                 }
[09:28:27.268]                 else {
[09:28:27.268]                   if (TRUE) {
[09:28:27.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.268]                     {
[09:28:27.268]                       inherits <- base::inherits
[09:28:27.268]                       invokeRestart <- base::invokeRestart
[09:28:27.268]                       is.null <- base::is.null
[09:28:27.268]                       muffled <- FALSE
[09:28:27.268]                       if (inherits(cond, "message")) {
[09:28:27.268]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.268]                         if (muffled) 
[09:28:27.268]                           invokeRestart("muffleMessage")
[09:28:27.268]                       }
[09:28:27.268]                       else if (inherits(cond, "warning")) {
[09:28:27.268]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.268]                         if (muffled) 
[09:28:27.268]                           invokeRestart("muffleWarning")
[09:28:27.268]                       }
[09:28:27.268]                       else if (inherits(cond, "condition")) {
[09:28:27.268]                         if (!is.null(pattern)) {
[09:28:27.268]                           computeRestarts <- base::computeRestarts
[09:28:27.268]                           grepl <- base::grepl
[09:28:27.268]                           restarts <- computeRestarts(cond)
[09:28:27.268]                           for (restart in restarts) {
[09:28:27.268]                             name <- restart$name
[09:28:27.268]                             if (is.null(name)) 
[09:28:27.268]                               next
[09:28:27.268]                             if (!grepl(pattern, name)) 
[09:28:27.268]                               next
[09:28:27.268]                             invokeRestart(restart)
[09:28:27.268]                             muffled <- TRUE
[09:28:27.268]                             break
[09:28:27.268]                           }
[09:28:27.268]                         }
[09:28:27.268]                       }
[09:28:27.268]                       invisible(muffled)
[09:28:27.268]                     }
[09:28:27.268]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.268]                   }
[09:28:27.268]                 }
[09:28:27.268]             }
[09:28:27.268]         }))
[09:28:27.268]     }, error = function(ex) {
[09:28:27.268]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:27.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.268]                 ...future.rng), started = ...future.startTime, 
[09:28:27.268]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:27.268]             version = "1.8"), class = "FutureResult")
[09:28:27.268]     }, finally = {
[09:28:27.268]         if (!identical(...future.workdir, getwd())) 
[09:28:27.268]             setwd(...future.workdir)
[09:28:27.268]         {
[09:28:27.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:27.268]                 ...future.oldOptions$nwarnings <- NULL
[09:28:27.268]             }
[09:28:27.268]             base::options(...future.oldOptions)
[09:28:27.268]             if (.Platform$OS.type == "windows") {
[09:28:27.268]                 old_names <- names(...future.oldEnvVars)
[09:28:27.268]                 envs <- base::Sys.getenv()
[09:28:27.268]                 names <- names(envs)
[09:28:27.268]                 common <- intersect(names, old_names)
[09:28:27.268]                 added <- setdiff(names, old_names)
[09:28:27.268]                 removed <- setdiff(old_names, names)
[09:28:27.268]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:27.268]                   envs[common]]
[09:28:27.268]                 NAMES <- toupper(changed)
[09:28:27.268]                 args <- list()
[09:28:27.268]                 for (kk in seq_along(NAMES)) {
[09:28:27.268]                   name <- changed[[kk]]
[09:28:27.268]                   NAME <- NAMES[[kk]]
[09:28:27.268]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.268]                     next
[09:28:27.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.268]                 }
[09:28:27.268]                 NAMES <- toupper(added)
[09:28:27.268]                 for (kk in seq_along(NAMES)) {
[09:28:27.268]                   name <- added[[kk]]
[09:28:27.268]                   NAME <- NAMES[[kk]]
[09:28:27.268]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.268]                     next
[09:28:27.268]                   args[[name]] <- ""
[09:28:27.268]                 }
[09:28:27.268]                 NAMES <- toupper(removed)
[09:28:27.268]                 for (kk in seq_along(NAMES)) {
[09:28:27.268]                   name <- removed[[kk]]
[09:28:27.268]                   NAME <- NAMES[[kk]]
[09:28:27.268]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.268]                     next
[09:28:27.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.268]                 }
[09:28:27.268]                 if (length(args) > 0) 
[09:28:27.268]                   base::do.call(base::Sys.setenv, args = args)
[09:28:27.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:27.268]             }
[09:28:27.268]             else {
[09:28:27.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:27.268]             }
[09:28:27.268]             {
[09:28:27.268]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:27.268]                   0L) {
[09:28:27.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:27.268]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:27.268]                   base::options(opts)
[09:28:27.268]                 }
[09:28:27.268]                 {
[09:28:27.268]                   {
[09:28:27.268]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:27.268]                     NULL
[09:28:27.268]                   }
[09:28:27.268]                   options(future.plan = NULL)
[09:28:27.268]                   if (is.na(NA_character_)) 
[09:28:27.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:27.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:27.268]                     .init = FALSE)
[09:28:27.268]                 }
[09:28:27.268]             }
[09:28:27.268]         }
[09:28:27.268]     })
[09:28:27.268]     if (TRUE) {
[09:28:27.268]         base::sink(type = "output", split = FALSE)
[09:28:27.268]         if (TRUE) {
[09:28:27.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:27.268]         }
[09:28:27.268]         else {
[09:28:27.268]             ...future.result["stdout"] <- base::list(NULL)
[09:28:27.268]         }
[09:28:27.268]         base::close(...future.stdout)
[09:28:27.268]         ...future.stdout <- NULL
[09:28:27.268]     }
[09:28:27.268]     ...future.result$conditions <- ...future.conditions
[09:28:27.268]     ...future.result$finished <- base::Sys.time()
[09:28:27.268]     ...future.result
[09:28:27.268] }
[09:28:27.271] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[09:28:27.271] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[09:28:27.272] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[09:28:27.272] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:27.272] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:27.272] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[09:28:27.273] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[09:28:27.273] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:27.273] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:27.273] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:28:27.274] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:28:27.274] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[09:28:27.274] MultisessionFuture started
[09:28:27.274] - Launch lazy future ... done
[09:28:27.274] run() for ‘MultisessionFuture’ ... done
[09:28:27.275] Created future:
[09:28:27.275] MultisessionFuture:
[09:28:27.275] Label: ‘future_eapply-2’
[09:28:27.275] Expression:
[09:28:27.275] {
[09:28:27.275]     do.call(function(...) {
[09:28:27.275]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.275]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.275]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.275]             on.exit(options(oopts), add = TRUE)
[09:28:27.275]         }
[09:28:27.275]         {
[09:28:27.275]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.275]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.275]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.275]             })
[09:28:27.275]         }
[09:28:27.275]     }, args = future.call.arguments)
[09:28:27.275] }
[09:28:27.275] Lazy evaluation: FALSE
[09:28:27.275] Asynchronous evaluation: TRUE
[09:28:27.275] Local evaluation: TRUE
[09:28:27.275] Environment: R_GlobalEnv
[09:28:27.275] Capture standard output: TRUE
[09:28:27.275] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:27.275] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:27.275] Packages: 1 packages (‘stats’)
[09:28:27.275] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:27.275] Resolved: FALSE
[09:28:27.275] Value: <not collected>
[09:28:27.275] Conditions captured: <none>
[09:28:27.275] Early signaling: FALSE
[09:28:27.275] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:27.275] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.286] Chunk #2 of 2 ... DONE
[09:28:27.286] Launching 2 futures (chunks) ... DONE
[09:28:27.287] Resolving 2 futures (chunks) ...
[09:28:27.287] resolve() on list ...
[09:28:27.287]  recursive: 0
[09:28:27.287]  length: 2
[09:28:27.287] 
[09:28:27.287] receiveMessageFromWorker() for ClusterFuture ...
[09:28:27.288] - Validating connection of MultisessionFuture
[09:28:27.288] - received message: FutureResult
[09:28:27.288] - Received FutureResult
[09:28:27.288] - Erased future from FutureRegistry
[09:28:27.288] result() for ClusterFuture ...
[09:28:27.288] - result already collected: FutureResult
[09:28:27.288] result() for ClusterFuture ... done
[09:28:27.288] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:27.288] Future #1
[09:28:27.289] result() for ClusterFuture ...
[09:28:27.289] - result already collected: FutureResult
[09:28:27.289] result() for ClusterFuture ... done
[09:28:27.289] result() for ClusterFuture ...
[09:28:27.289] - result already collected: FutureResult
[09:28:27.289] result() for ClusterFuture ... done
[09:28:27.289] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:27.289] - nx: 2
[09:28:27.289] - relay: TRUE
[09:28:27.289] - stdout: TRUE
[09:28:27.289] - signal: TRUE
[09:28:27.290] - resignal: FALSE
[09:28:27.290] - force: TRUE
[09:28:27.290] - relayed: [n=2] FALSE, FALSE
[09:28:27.290] - queued futures: [n=2] FALSE, FALSE
[09:28:27.290]  - until=1
[09:28:27.290]  - relaying element #1
[09:28:27.290] result() for ClusterFuture ...
[09:28:27.290] - result already collected: FutureResult
[09:28:27.290] result() for ClusterFuture ... done
[09:28:27.290] result() for ClusterFuture ...
[09:28:27.290] - result already collected: FutureResult
[09:28:27.291] result() for ClusterFuture ... done
[09:28:27.291] result() for ClusterFuture ...
[09:28:27.291] - result already collected: FutureResult
[09:28:27.291] result() for ClusterFuture ... done
[09:28:27.291] result() for ClusterFuture ...
[09:28:27.291] - result already collected: FutureResult
[09:28:27.291] result() for ClusterFuture ... done
[09:28:27.291] - relayed: [n=2] TRUE, FALSE
[09:28:27.291] - queued futures: [n=2] TRUE, FALSE
[09:28:27.291] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:27.291]  length: 1 (resolved future 1)
[09:28:27.318] receiveMessageFromWorker() for ClusterFuture ...
[09:28:27.318] - Validating connection of MultisessionFuture
[09:28:27.319] - received message: FutureResult
[09:28:27.319] - Received FutureResult
[09:28:27.319] - Erased future from FutureRegistry
[09:28:27.319] result() for ClusterFuture ...
[09:28:27.319] - result already collected: FutureResult
[09:28:27.319] result() for ClusterFuture ... done
[09:28:27.319] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:27.319] Future #2
[09:28:27.320] result() for ClusterFuture ...
[09:28:27.320] - result already collected: FutureResult
[09:28:27.320] result() for ClusterFuture ... done
[09:28:27.320] result() for ClusterFuture ...
[09:28:27.320] - result already collected: FutureResult
[09:28:27.320] result() for ClusterFuture ... done
[09:28:27.320] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:27.320] - nx: 2
[09:28:27.320] - relay: TRUE
[09:28:27.320] - stdout: TRUE
[09:28:27.320] - signal: TRUE
[09:28:27.321] - resignal: FALSE
[09:28:27.321] - force: TRUE
[09:28:27.321] - relayed: [n=2] TRUE, FALSE
[09:28:27.321] - queued futures: [n=2] TRUE, FALSE
[09:28:27.321]  - until=2
[09:28:27.321]  - relaying element #2
[09:28:27.321] result() for ClusterFuture ...
[09:28:27.321] - result already collected: FutureResult
[09:28:27.321] result() for ClusterFuture ... done
[09:28:27.321] result() for ClusterFuture ...
[09:28:27.321] - result already collected: FutureResult
[09:28:27.321] result() for ClusterFuture ... done
[09:28:27.322] result() for ClusterFuture ...
[09:28:27.322] - result already collected: FutureResult
[09:28:27.322] result() for ClusterFuture ... done
[09:28:27.322] result() for ClusterFuture ...
[09:28:27.322] - result already collected: FutureResult
[09:28:27.322] result() for ClusterFuture ... done
[09:28:27.322] - relayed: [n=2] TRUE, TRUE
[09:28:27.322] - queued futures: [n=2] TRUE, TRUE
[09:28:27.322] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:27.322]  length: 0 (resolved future 2)
[09:28:27.322] Relaying remaining futures
[09:28:27.323] signalConditionsASAP(NULL, pos=0) ...
[09:28:27.323] - nx: 2
[09:28:27.323] - relay: TRUE
[09:28:27.323] - stdout: TRUE
[09:28:27.323] - signal: TRUE
[09:28:27.323] - resignal: FALSE
[09:28:27.323] - force: TRUE
[09:28:27.323] - relayed: [n=2] TRUE, TRUE
[09:28:27.323] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:27.323] - relayed: [n=2] TRUE, TRUE
[09:28:27.323] - queued futures: [n=2] TRUE, TRUE
[09:28:27.324] signalConditionsASAP(NULL, pos=0) ... done
[09:28:27.324] resolve() on list ... DONE
[09:28:27.324] result() for ClusterFuture ...
[09:28:27.324] - result already collected: FutureResult
[09:28:27.324] result() for ClusterFuture ... done
[09:28:27.324] result() for ClusterFuture ...
[09:28:27.324] - result already collected: FutureResult
[09:28:27.324] result() for ClusterFuture ... done
[09:28:27.324] result() for ClusterFuture ...
[09:28:27.324] - result already collected: FutureResult
[09:28:27.324] result() for ClusterFuture ... done
[09:28:27.325] result() for ClusterFuture ...
[09:28:27.325] - result already collected: FutureResult
[09:28:27.325] result() for ClusterFuture ... done
[09:28:27.325]  - Number of value chunks collected: 2
[09:28:27.325] Resolving 2 futures (chunks) ... DONE
[09:28:27.325] Reducing values from 2 chunks ...
[09:28:27.325]  - Number of values collected after concatenation: 3
[09:28:27.325]  - Number of values expected: 3
[09:28:27.325] Reducing values from 2 chunks ... DONE
[09:28:27.325] future_lapply() ... DONE
[09:28:27.326] future_lapply() ...
[09:28:27.330] Number of chunks: 2
[09:28:27.330] getGlobalsAndPackagesXApply() ...
[09:28:27.330]  - future.globals: TRUE
[09:28:27.330] getGlobalsAndPackages() ...
[09:28:27.331] Searching for globals...
[09:28:27.332] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:27.332] Searching for globals ... DONE
[09:28:27.332] Resolving globals: FALSE
[09:28:27.332] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[09:28:27.333] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[09:28:27.333] - globals: [1] ‘FUN’
[09:28:27.333] - packages: [1] ‘stats’
[09:28:27.333] getGlobalsAndPackages() ... DONE
[09:28:27.333]  - globals found/used: [n=1] ‘FUN’
[09:28:27.333]  - needed namespaces: [n=1] ‘stats’
[09:28:27.333] Finding globals ... DONE
[09:28:27.334]  - use_args: TRUE
[09:28:27.334]  - Getting '...' globals ...
[09:28:27.334] resolve() on list ...
[09:28:27.334]  recursive: 0
[09:28:27.334]  length: 1
[09:28:27.334]  elements: ‘...’
[09:28:27.334]  length: 0 (resolved future 1)
[09:28:27.334] resolve() on list ... DONE
[09:28:27.335]    - '...' content: [n=0] 
[09:28:27.335] List of 1
[09:28:27.335]  $ ...: list()
[09:28:27.335]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:27.335]  - attr(*, "where")=List of 1
[09:28:27.335]   ..$ ...:<environment: 0x55666756fb18> 
[09:28:27.335]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:27.335]  - attr(*, "resolved")= logi TRUE
[09:28:27.335]  - attr(*, "total_size")= num NA
[09:28:27.337]  - Getting '...' globals ... DONE
[09:28:27.337] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:27.337] List of 2
[09:28:27.337]  $ ...future.FUN:function (x, ...)  
[09:28:27.337]  $ ...          : list()
[09:28:27.337]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:27.337]  - attr(*, "where")=List of 2
[09:28:27.337]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:27.337]   ..$ ...          :<environment: 0x55666756fb18> 
[09:28:27.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:27.337]  - attr(*, "resolved")= logi FALSE
[09:28:27.337]  - attr(*, "total_size")= num 1248
[09:28:27.340] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:27.340] getGlobalsAndPackagesXApply() ... DONE
[09:28:27.340] Number of futures (= number of chunks): 2
[09:28:27.341] Launching 2 futures (chunks) ...
[09:28:27.341] Chunk #1 of 2 ...
[09:28:27.341]  - Finding globals in 'X' for chunk #1 ...
[09:28:27.341] getGlobalsAndPackages() ...
[09:28:27.341] Searching for globals...
[09:28:27.341] 
[09:28:27.341] Searching for globals ... DONE
[09:28:27.341] - globals: [0] <none>
[09:28:27.341] getGlobalsAndPackages() ... DONE
[09:28:27.342]    + additional globals found: [n=0] 
[09:28:27.342]    + additional namespaces needed: [n=0] 
[09:28:27.342]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:27.342]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:27.342]  - seeds: <none>
[09:28:27.342]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.342] getGlobalsAndPackages() ...
[09:28:27.342] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.342] Resolving globals: FALSE
[09:28:27.342] Tweak future expression to call with '...' arguments ...
[09:28:27.343] {
[09:28:27.343]     do.call(function(...) {
[09:28:27.343]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.343]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.343]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.343]             on.exit(options(oopts), add = TRUE)
[09:28:27.343]         }
[09:28:27.343]         {
[09:28:27.343]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.343]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.343]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.343]             })
[09:28:27.343]         }
[09:28:27.343]     }, args = future.call.arguments)
[09:28:27.343] }
[09:28:27.343] Tweak future expression to call with '...' arguments ... DONE
[09:28:27.343] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.343] - packages: [1] ‘stats’
[09:28:27.343] getGlobalsAndPackages() ... DONE
[09:28:27.344] run() for ‘Future’ ...
[09:28:27.344] - state: ‘created’
[09:28:27.344] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:27.357] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:27.358]   - Field: ‘node’
[09:28:27.358]   - Field: ‘label’
[09:28:27.358]   - Field: ‘local’
[09:28:27.358]   - Field: ‘owner’
[09:28:27.358]   - Field: ‘envir’
[09:28:27.358]   - Field: ‘workers’
[09:28:27.358]   - Field: ‘packages’
[09:28:27.358]   - Field: ‘gc’
[09:28:27.358]   - Field: ‘conditions’
[09:28:27.359]   - Field: ‘persistent’
[09:28:27.359]   - Field: ‘expr’
[09:28:27.359]   - Field: ‘uuid’
[09:28:27.359]   - Field: ‘seed’
[09:28:27.359]   - Field: ‘version’
[09:28:27.359]   - Field: ‘result’
[09:28:27.359]   - Field: ‘asynchronous’
[09:28:27.359]   - Field: ‘calls’
[09:28:27.359]   - Field: ‘globals’
[09:28:27.359]   - Field: ‘stdout’
[09:28:27.359]   - Field: ‘earlySignal’
[09:28:27.360]   - Field: ‘lazy’
[09:28:27.360]   - Field: ‘state’
[09:28:27.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:27.360] - Launch lazy future ...
[09:28:27.360] Packages needed by the future expression (n = 1): ‘stats’
[09:28:27.360] Packages needed by future strategies (n = 0): <none>
[09:28:27.361] {
[09:28:27.361]     {
[09:28:27.361]         {
[09:28:27.361]             ...future.startTime <- base::Sys.time()
[09:28:27.361]             {
[09:28:27.361]                 {
[09:28:27.361]                   {
[09:28:27.361]                     {
[09:28:27.361]                       {
[09:28:27.361]                         base::local({
[09:28:27.361]                           has_future <- base::requireNamespace("future", 
[09:28:27.361]                             quietly = TRUE)
[09:28:27.361]                           if (has_future) {
[09:28:27.361]                             ns <- base::getNamespace("future")
[09:28:27.361]                             version <- ns[[".package"]][["version"]]
[09:28:27.361]                             if (is.null(version)) 
[09:28:27.361]                               version <- utils::packageVersion("future")
[09:28:27.361]                           }
[09:28:27.361]                           else {
[09:28:27.361]                             version <- NULL
[09:28:27.361]                           }
[09:28:27.361]                           if (!has_future || version < "1.8.0") {
[09:28:27.361]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:27.361]                               "", base::R.version$version.string), 
[09:28:27.361]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:27.361]                                 base::R.version$platform, 8 * 
[09:28:27.361]                                   base::.Machine$sizeof.pointer), 
[09:28:27.361]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:27.361]                                 "release", "version")], collapse = " "), 
[09:28:27.361]                               hostname = base::Sys.info()[["nodename"]])
[09:28:27.361]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:27.361]                               info)
[09:28:27.361]                             info <- base::paste(info, collapse = "; ")
[09:28:27.361]                             if (!has_future) {
[09:28:27.361]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:27.361]                                 info)
[09:28:27.361]                             }
[09:28:27.361]                             else {
[09:28:27.361]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:27.361]                                 info, version)
[09:28:27.361]                             }
[09:28:27.361]                             base::stop(msg)
[09:28:27.361]                           }
[09:28:27.361]                         })
[09:28:27.361]                       }
[09:28:27.361]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:27.361]                       base::options(mc.cores = 1L)
[09:28:27.361]                     }
[09:28:27.361]                     base::local({
[09:28:27.361]                       for (pkg in "stats") {
[09:28:27.361]                         base::loadNamespace(pkg)
[09:28:27.361]                         base::library(pkg, character.only = TRUE)
[09:28:27.361]                       }
[09:28:27.361]                     })
[09:28:27.361]                   }
[09:28:27.361]                   ...future.strategy.old <- future::plan("list")
[09:28:27.361]                   options(future.plan = NULL)
[09:28:27.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:27.361]                 }
[09:28:27.361]                 ...future.workdir <- getwd()
[09:28:27.361]             }
[09:28:27.361]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:27.361]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:27.361]         }
[09:28:27.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:27.361]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:27.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:27.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:27.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:27.361]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:27.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:27.361]             base::names(...future.oldOptions))
[09:28:27.361]     }
[09:28:27.361]     if (FALSE) {
[09:28:27.361]     }
[09:28:27.361]     else {
[09:28:27.361]         if (TRUE) {
[09:28:27.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:27.361]                 open = "w")
[09:28:27.361]         }
[09:28:27.361]         else {
[09:28:27.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:27.361]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:27.361]         }
[09:28:27.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:27.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:27.361]             base::sink(type = "output", split = FALSE)
[09:28:27.361]             base::close(...future.stdout)
[09:28:27.361]         }, add = TRUE)
[09:28:27.361]     }
[09:28:27.361]     ...future.frame <- base::sys.nframe()
[09:28:27.361]     ...future.conditions <- base::list()
[09:28:27.361]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:27.361]     if (FALSE) {
[09:28:27.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:27.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:27.361]     }
[09:28:27.361]     ...future.result <- base::tryCatch({
[09:28:27.361]         base::withCallingHandlers({
[09:28:27.361]             ...future.value <- base::withVisible(base::local({
[09:28:27.361]                 ...future.makeSendCondition <- base::local({
[09:28:27.361]                   sendCondition <- NULL
[09:28:27.361]                   function(frame = 1L) {
[09:28:27.361]                     if (is.function(sendCondition)) 
[09:28:27.361]                       return(sendCondition)
[09:28:27.361]                     ns <- getNamespace("parallel")
[09:28:27.361]                     if (exists("sendData", mode = "function", 
[09:28:27.361]                       envir = ns)) {
[09:28:27.361]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:27.361]                         envir = ns)
[09:28:27.361]                       envir <- sys.frame(frame)
[09:28:27.361]                       master <- NULL
[09:28:27.361]                       while (!identical(envir, .GlobalEnv) && 
[09:28:27.361]                         !identical(envir, emptyenv())) {
[09:28:27.361]                         if (exists("master", mode = "list", envir = envir, 
[09:28:27.361]                           inherits = FALSE)) {
[09:28:27.361]                           master <- get("master", mode = "list", 
[09:28:27.361]                             envir = envir, inherits = FALSE)
[09:28:27.361]                           if (inherits(master, c("SOCKnode", 
[09:28:27.361]                             "SOCK0node"))) {
[09:28:27.361]                             sendCondition <<- function(cond) {
[09:28:27.361]                               data <- list(type = "VALUE", value = cond, 
[09:28:27.361]                                 success = TRUE)
[09:28:27.361]                               parallel_sendData(master, data)
[09:28:27.361]                             }
[09:28:27.361]                             return(sendCondition)
[09:28:27.361]                           }
[09:28:27.361]                         }
[09:28:27.361]                         frame <- frame + 1L
[09:28:27.361]                         envir <- sys.frame(frame)
[09:28:27.361]                       }
[09:28:27.361]                     }
[09:28:27.361]                     sendCondition <<- function(cond) NULL
[09:28:27.361]                   }
[09:28:27.361]                 })
[09:28:27.361]                 withCallingHandlers({
[09:28:27.361]                   {
[09:28:27.361]                     do.call(function(...) {
[09:28:27.361]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.361]                       if (!identical(...future.globals.maxSize.org, 
[09:28:27.361]                         ...future.globals.maxSize)) {
[09:28:27.361]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.361]                         on.exit(options(oopts), add = TRUE)
[09:28:27.361]                       }
[09:28:27.361]                       {
[09:28:27.361]                         lapply(seq_along(...future.elements_ii), 
[09:28:27.361]                           FUN = function(jj) {
[09:28:27.361]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.361]                             ...future.FUN(...future.X_jj, ...)
[09:28:27.361]                           })
[09:28:27.361]                       }
[09:28:27.361]                     }, args = future.call.arguments)
[09:28:27.361]                   }
[09:28:27.361]                 }, immediateCondition = function(cond) {
[09:28:27.361]                   sendCondition <- ...future.makeSendCondition()
[09:28:27.361]                   sendCondition(cond)
[09:28:27.361]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.361]                   {
[09:28:27.361]                     inherits <- base::inherits
[09:28:27.361]                     invokeRestart <- base::invokeRestart
[09:28:27.361]                     is.null <- base::is.null
[09:28:27.361]                     muffled <- FALSE
[09:28:27.361]                     if (inherits(cond, "message")) {
[09:28:27.361]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:27.361]                       if (muffled) 
[09:28:27.361]                         invokeRestart("muffleMessage")
[09:28:27.361]                     }
[09:28:27.361]                     else if (inherits(cond, "warning")) {
[09:28:27.361]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:27.361]                       if (muffled) 
[09:28:27.361]                         invokeRestart("muffleWarning")
[09:28:27.361]                     }
[09:28:27.361]                     else if (inherits(cond, "condition")) {
[09:28:27.361]                       if (!is.null(pattern)) {
[09:28:27.361]                         computeRestarts <- base::computeRestarts
[09:28:27.361]                         grepl <- base::grepl
[09:28:27.361]                         restarts <- computeRestarts(cond)
[09:28:27.361]                         for (restart in restarts) {
[09:28:27.361]                           name <- restart$name
[09:28:27.361]                           if (is.null(name)) 
[09:28:27.361]                             next
[09:28:27.361]                           if (!grepl(pattern, name)) 
[09:28:27.361]                             next
[09:28:27.361]                           invokeRestart(restart)
[09:28:27.361]                           muffled <- TRUE
[09:28:27.361]                           break
[09:28:27.361]                         }
[09:28:27.361]                       }
[09:28:27.361]                     }
[09:28:27.361]                     invisible(muffled)
[09:28:27.361]                   }
[09:28:27.361]                   muffleCondition(cond)
[09:28:27.361]                 })
[09:28:27.361]             }))
[09:28:27.361]             future::FutureResult(value = ...future.value$value, 
[09:28:27.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.361]                   ...future.rng), globalenv = if (FALSE) 
[09:28:27.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:27.361]                     ...future.globalenv.names))
[09:28:27.361]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:27.361]         }, condition = base::local({
[09:28:27.361]             c <- base::c
[09:28:27.361]             inherits <- base::inherits
[09:28:27.361]             invokeRestart <- base::invokeRestart
[09:28:27.361]             length <- base::length
[09:28:27.361]             list <- base::list
[09:28:27.361]             seq.int <- base::seq.int
[09:28:27.361]             signalCondition <- base::signalCondition
[09:28:27.361]             sys.calls <- base::sys.calls
[09:28:27.361]             `[[` <- base::`[[`
[09:28:27.361]             `+` <- base::`+`
[09:28:27.361]             `<<-` <- base::`<<-`
[09:28:27.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:27.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:27.361]                   3L)]
[09:28:27.361]             }
[09:28:27.361]             function(cond) {
[09:28:27.361]                 is_error <- inherits(cond, "error")
[09:28:27.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:27.361]                   NULL)
[09:28:27.361]                 if (is_error) {
[09:28:27.361]                   sessionInformation <- function() {
[09:28:27.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:27.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:27.361]                       search = base::search(), system = base::Sys.info())
[09:28:27.361]                   }
[09:28:27.361]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:27.361]                     cond$call), session = sessionInformation(), 
[09:28:27.361]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:27.361]                   signalCondition(cond)
[09:28:27.361]                 }
[09:28:27.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:27.361]                 "immediateCondition"))) {
[09:28:27.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:27.361]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:27.361]                   if (TRUE && !signal) {
[09:28:27.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.361]                     {
[09:28:27.361]                       inherits <- base::inherits
[09:28:27.361]                       invokeRestart <- base::invokeRestart
[09:28:27.361]                       is.null <- base::is.null
[09:28:27.361]                       muffled <- FALSE
[09:28:27.361]                       if (inherits(cond, "message")) {
[09:28:27.361]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.361]                         if (muffled) 
[09:28:27.361]                           invokeRestart("muffleMessage")
[09:28:27.361]                       }
[09:28:27.361]                       else if (inherits(cond, "warning")) {
[09:28:27.361]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.361]                         if (muffled) 
[09:28:27.361]                           invokeRestart("muffleWarning")
[09:28:27.361]                       }
[09:28:27.361]                       else if (inherits(cond, "condition")) {
[09:28:27.361]                         if (!is.null(pattern)) {
[09:28:27.361]                           computeRestarts <- base::computeRestarts
[09:28:27.361]                           grepl <- base::grepl
[09:28:27.361]                           restarts <- computeRestarts(cond)
[09:28:27.361]                           for (restart in restarts) {
[09:28:27.361]                             name <- restart$name
[09:28:27.361]                             if (is.null(name)) 
[09:28:27.361]                               next
[09:28:27.361]                             if (!grepl(pattern, name)) 
[09:28:27.361]                               next
[09:28:27.361]                             invokeRestart(restart)
[09:28:27.361]                             muffled <- TRUE
[09:28:27.361]                             break
[09:28:27.361]                           }
[09:28:27.361]                         }
[09:28:27.361]                       }
[09:28:27.361]                       invisible(muffled)
[09:28:27.361]                     }
[09:28:27.361]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.361]                   }
[09:28:27.361]                 }
[09:28:27.361]                 else {
[09:28:27.361]                   if (TRUE) {
[09:28:27.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.361]                     {
[09:28:27.361]                       inherits <- base::inherits
[09:28:27.361]                       invokeRestart <- base::invokeRestart
[09:28:27.361]                       is.null <- base::is.null
[09:28:27.361]                       muffled <- FALSE
[09:28:27.361]                       if (inherits(cond, "message")) {
[09:28:27.361]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.361]                         if (muffled) 
[09:28:27.361]                           invokeRestart("muffleMessage")
[09:28:27.361]                       }
[09:28:27.361]                       else if (inherits(cond, "warning")) {
[09:28:27.361]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.361]                         if (muffled) 
[09:28:27.361]                           invokeRestart("muffleWarning")
[09:28:27.361]                       }
[09:28:27.361]                       else if (inherits(cond, "condition")) {
[09:28:27.361]                         if (!is.null(pattern)) {
[09:28:27.361]                           computeRestarts <- base::computeRestarts
[09:28:27.361]                           grepl <- base::grepl
[09:28:27.361]                           restarts <- computeRestarts(cond)
[09:28:27.361]                           for (restart in restarts) {
[09:28:27.361]                             name <- restart$name
[09:28:27.361]                             if (is.null(name)) 
[09:28:27.361]                               next
[09:28:27.361]                             if (!grepl(pattern, name)) 
[09:28:27.361]                               next
[09:28:27.361]                             invokeRestart(restart)
[09:28:27.361]                             muffled <- TRUE
[09:28:27.361]                             break
[09:28:27.361]                           }
[09:28:27.361]                         }
[09:28:27.361]                       }
[09:28:27.361]                       invisible(muffled)
[09:28:27.361]                     }
[09:28:27.361]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.361]                   }
[09:28:27.361]                 }
[09:28:27.361]             }
[09:28:27.361]         }))
[09:28:27.361]     }, error = function(ex) {
[09:28:27.361]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:27.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.361]                 ...future.rng), started = ...future.startTime, 
[09:28:27.361]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:27.361]             version = "1.8"), class = "FutureResult")
[09:28:27.361]     }, finally = {
[09:28:27.361]         if (!identical(...future.workdir, getwd())) 
[09:28:27.361]             setwd(...future.workdir)
[09:28:27.361]         {
[09:28:27.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:27.361]                 ...future.oldOptions$nwarnings <- NULL
[09:28:27.361]             }
[09:28:27.361]             base::options(...future.oldOptions)
[09:28:27.361]             if (.Platform$OS.type == "windows") {
[09:28:27.361]                 old_names <- names(...future.oldEnvVars)
[09:28:27.361]                 envs <- base::Sys.getenv()
[09:28:27.361]                 names <- names(envs)
[09:28:27.361]                 common <- intersect(names, old_names)
[09:28:27.361]                 added <- setdiff(names, old_names)
[09:28:27.361]                 removed <- setdiff(old_names, names)
[09:28:27.361]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:27.361]                   envs[common]]
[09:28:27.361]                 NAMES <- toupper(changed)
[09:28:27.361]                 args <- list()
[09:28:27.361]                 for (kk in seq_along(NAMES)) {
[09:28:27.361]                   name <- changed[[kk]]
[09:28:27.361]                   NAME <- NAMES[[kk]]
[09:28:27.361]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.361]                     next
[09:28:27.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.361]                 }
[09:28:27.361]                 NAMES <- toupper(added)
[09:28:27.361]                 for (kk in seq_along(NAMES)) {
[09:28:27.361]                   name <- added[[kk]]
[09:28:27.361]                   NAME <- NAMES[[kk]]
[09:28:27.361]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.361]                     next
[09:28:27.361]                   args[[name]] <- ""
[09:28:27.361]                 }
[09:28:27.361]                 NAMES <- toupper(removed)
[09:28:27.361]                 for (kk in seq_along(NAMES)) {
[09:28:27.361]                   name <- removed[[kk]]
[09:28:27.361]                   NAME <- NAMES[[kk]]
[09:28:27.361]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.361]                     next
[09:28:27.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.361]                 }
[09:28:27.361]                 if (length(args) > 0) 
[09:28:27.361]                   base::do.call(base::Sys.setenv, args = args)
[09:28:27.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:27.361]             }
[09:28:27.361]             else {
[09:28:27.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:27.361]             }
[09:28:27.361]             {
[09:28:27.361]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:27.361]                   0L) {
[09:28:27.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:27.361]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:27.361]                   base::options(opts)
[09:28:27.361]                 }
[09:28:27.361]                 {
[09:28:27.361]                   {
[09:28:27.361]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:27.361]                     NULL
[09:28:27.361]                   }
[09:28:27.361]                   options(future.plan = NULL)
[09:28:27.361]                   if (is.na(NA_character_)) 
[09:28:27.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:27.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:27.361]                     .init = FALSE)
[09:28:27.361]                 }
[09:28:27.361]             }
[09:28:27.361]         }
[09:28:27.361]     })
[09:28:27.361]     if (TRUE) {
[09:28:27.361]         base::sink(type = "output", split = FALSE)
[09:28:27.361]         if (TRUE) {
[09:28:27.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:27.361]         }
[09:28:27.361]         else {
[09:28:27.361]             ...future.result["stdout"] <- base::list(NULL)
[09:28:27.361]         }
[09:28:27.361]         base::close(...future.stdout)
[09:28:27.361]         ...future.stdout <- NULL
[09:28:27.361]     }
[09:28:27.361]     ...future.result$conditions <- ...future.conditions
[09:28:27.361]     ...future.result$finished <- base::Sys.time()
[09:28:27.361]     ...future.result
[09:28:27.361] }
[09:28:27.363] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[09:28:27.364] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[09:28:27.364] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[09:28:27.364] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:27.365] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:27.365] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[09:28:27.365] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[09:28:27.365] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:27.366] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:27.366] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:28:27.366] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:28:27.366] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[09:28:27.367] MultisessionFuture started
[09:28:27.367] - Launch lazy future ... done
[09:28:27.367] run() for ‘MultisessionFuture’ ... done
[09:28:27.367] Created future:
[09:28:27.367] MultisessionFuture:
[09:28:27.367] Label: ‘future_eapply-1’
[09:28:27.367] Expression:
[09:28:27.367] {
[09:28:27.367]     do.call(function(...) {
[09:28:27.367]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.367]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.367]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.367]             on.exit(options(oopts), add = TRUE)
[09:28:27.367]         }
[09:28:27.367]         {
[09:28:27.367]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.367]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.367]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.367]             })
[09:28:27.367]         }
[09:28:27.367]     }, args = future.call.arguments)
[09:28:27.367] }
[09:28:27.367] Lazy evaluation: FALSE
[09:28:27.367] Asynchronous evaluation: TRUE
[09:28:27.367] Local evaluation: TRUE
[09:28:27.367] Environment: R_GlobalEnv
[09:28:27.367] Capture standard output: TRUE
[09:28:27.367] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:27.367] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:27.367] Packages: 1 packages (‘stats’)
[09:28:27.367] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:27.367] Resolved: FALSE
[09:28:27.367] Value: <not collected>
[09:28:27.367] Conditions captured: <none>
[09:28:27.367] Early signaling: FALSE
[09:28:27.367] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:27.367] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.379] Chunk #1 of 2 ... DONE
[09:28:27.379] Chunk #2 of 2 ...
[09:28:27.379]  - Finding globals in 'X' for chunk #2 ...
[09:28:27.379] getGlobalsAndPackages() ...
[09:28:27.379] Searching for globals...
[09:28:27.379] 
[09:28:27.380] Searching for globals ... DONE
[09:28:27.380] - globals: [0] <none>
[09:28:27.380] getGlobalsAndPackages() ... DONE
[09:28:27.380]    + additional globals found: [n=0] 
[09:28:27.380]    + additional namespaces needed: [n=0] 
[09:28:27.380]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:27.380]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:27.380]  - seeds: <none>
[09:28:27.380]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.380] getGlobalsAndPackages() ...
[09:28:27.380] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.381] Resolving globals: FALSE
[09:28:27.381] Tweak future expression to call with '...' arguments ...
[09:28:27.381] {
[09:28:27.381]     do.call(function(...) {
[09:28:27.381]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.381]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.381]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.381]             on.exit(options(oopts), add = TRUE)
[09:28:27.381]         }
[09:28:27.381]         {
[09:28:27.381]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.381]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.381]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.381]             })
[09:28:27.381]         }
[09:28:27.381]     }, args = future.call.arguments)
[09:28:27.381] }
[09:28:27.381] Tweak future expression to call with '...' arguments ... DONE
[09:28:27.381] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:27.382] - packages: [1] ‘stats’
[09:28:27.382] getGlobalsAndPackages() ... DONE
[09:28:27.382] run() for ‘Future’ ...
[09:28:27.382] - state: ‘created’
[09:28:27.382] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:27.398] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.398] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:27.398]   - Field: ‘node’
[09:28:27.398]   - Field: ‘label’
[09:28:27.399]   - Field: ‘local’
[09:28:27.399]   - Field: ‘owner’
[09:28:27.399]   - Field: ‘envir’
[09:28:27.399]   - Field: ‘workers’
[09:28:27.399]   - Field: ‘packages’
[09:28:27.399]   - Field: ‘gc’
[09:28:27.399]   - Field: ‘conditions’
[09:28:27.399]   - Field: ‘persistent’
[09:28:27.399]   - Field: ‘expr’
[09:28:27.399]   - Field: ‘uuid’
[09:28:27.399]   - Field: ‘seed’
[09:28:27.400]   - Field: ‘version’
[09:28:27.400]   - Field: ‘result’
[09:28:27.400]   - Field: ‘asynchronous’
[09:28:27.400]   - Field: ‘calls’
[09:28:27.400]   - Field: ‘globals’
[09:28:27.400]   - Field: ‘stdout’
[09:28:27.400]   - Field: ‘earlySignal’
[09:28:27.400]   - Field: ‘lazy’
[09:28:27.400]   - Field: ‘state’
[09:28:27.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:27.400] - Launch lazy future ...
[09:28:27.401] Packages needed by the future expression (n = 1): ‘stats’
[09:28:27.401] Packages needed by future strategies (n = 0): <none>
[09:28:27.401] {
[09:28:27.401]     {
[09:28:27.401]         {
[09:28:27.401]             ...future.startTime <- base::Sys.time()
[09:28:27.401]             {
[09:28:27.401]                 {
[09:28:27.401]                   {
[09:28:27.401]                     {
[09:28:27.401]                       {
[09:28:27.401]                         base::local({
[09:28:27.401]                           has_future <- base::requireNamespace("future", 
[09:28:27.401]                             quietly = TRUE)
[09:28:27.401]                           if (has_future) {
[09:28:27.401]                             ns <- base::getNamespace("future")
[09:28:27.401]                             version <- ns[[".package"]][["version"]]
[09:28:27.401]                             if (is.null(version)) 
[09:28:27.401]                               version <- utils::packageVersion("future")
[09:28:27.401]                           }
[09:28:27.401]                           else {
[09:28:27.401]                             version <- NULL
[09:28:27.401]                           }
[09:28:27.401]                           if (!has_future || version < "1.8.0") {
[09:28:27.401]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:27.401]                               "", base::R.version$version.string), 
[09:28:27.401]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:27.401]                                 base::R.version$platform, 8 * 
[09:28:27.401]                                   base::.Machine$sizeof.pointer), 
[09:28:27.401]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:27.401]                                 "release", "version")], collapse = " "), 
[09:28:27.401]                               hostname = base::Sys.info()[["nodename"]])
[09:28:27.401]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:27.401]                               info)
[09:28:27.401]                             info <- base::paste(info, collapse = "; ")
[09:28:27.401]                             if (!has_future) {
[09:28:27.401]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:27.401]                                 info)
[09:28:27.401]                             }
[09:28:27.401]                             else {
[09:28:27.401]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:27.401]                                 info, version)
[09:28:27.401]                             }
[09:28:27.401]                             base::stop(msg)
[09:28:27.401]                           }
[09:28:27.401]                         })
[09:28:27.401]                       }
[09:28:27.401]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:27.401]                       base::options(mc.cores = 1L)
[09:28:27.401]                     }
[09:28:27.401]                     base::local({
[09:28:27.401]                       for (pkg in "stats") {
[09:28:27.401]                         base::loadNamespace(pkg)
[09:28:27.401]                         base::library(pkg, character.only = TRUE)
[09:28:27.401]                       }
[09:28:27.401]                     })
[09:28:27.401]                   }
[09:28:27.401]                   ...future.strategy.old <- future::plan("list")
[09:28:27.401]                   options(future.plan = NULL)
[09:28:27.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:27.401]                 }
[09:28:27.401]                 ...future.workdir <- getwd()
[09:28:27.401]             }
[09:28:27.401]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:27.401]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:27.401]         }
[09:28:27.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:27.401]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:27.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:27.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:27.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:27.401]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:27.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:27.401]             base::names(...future.oldOptions))
[09:28:27.401]     }
[09:28:27.401]     if (FALSE) {
[09:28:27.401]     }
[09:28:27.401]     else {
[09:28:27.401]         if (TRUE) {
[09:28:27.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:27.401]                 open = "w")
[09:28:27.401]         }
[09:28:27.401]         else {
[09:28:27.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:27.401]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:27.401]         }
[09:28:27.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:27.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:27.401]             base::sink(type = "output", split = FALSE)
[09:28:27.401]             base::close(...future.stdout)
[09:28:27.401]         }, add = TRUE)
[09:28:27.401]     }
[09:28:27.401]     ...future.frame <- base::sys.nframe()
[09:28:27.401]     ...future.conditions <- base::list()
[09:28:27.401]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:27.401]     if (FALSE) {
[09:28:27.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:27.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:27.401]     }
[09:28:27.401]     ...future.result <- base::tryCatch({
[09:28:27.401]         base::withCallingHandlers({
[09:28:27.401]             ...future.value <- base::withVisible(base::local({
[09:28:27.401]                 ...future.makeSendCondition <- base::local({
[09:28:27.401]                   sendCondition <- NULL
[09:28:27.401]                   function(frame = 1L) {
[09:28:27.401]                     if (is.function(sendCondition)) 
[09:28:27.401]                       return(sendCondition)
[09:28:27.401]                     ns <- getNamespace("parallel")
[09:28:27.401]                     if (exists("sendData", mode = "function", 
[09:28:27.401]                       envir = ns)) {
[09:28:27.401]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:27.401]                         envir = ns)
[09:28:27.401]                       envir <- sys.frame(frame)
[09:28:27.401]                       master <- NULL
[09:28:27.401]                       while (!identical(envir, .GlobalEnv) && 
[09:28:27.401]                         !identical(envir, emptyenv())) {
[09:28:27.401]                         if (exists("master", mode = "list", envir = envir, 
[09:28:27.401]                           inherits = FALSE)) {
[09:28:27.401]                           master <- get("master", mode = "list", 
[09:28:27.401]                             envir = envir, inherits = FALSE)
[09:28:27.401]                           if (inherits(master, c("SOCKnode", 
[09:28:27.401]                             "SOCK0node"))) {
[09:28:27.401]                             sendCondition <<- function(cond) {
[09:28:27.401]                               data <- list(type = "VALUE", value = cond, 
[09:28:27.401]                                 success = TRUE)
[09:28:27.401]                               parallel_sendData(master, data)
[09:28:27.401]                             }
[09:28:27.401]                             return(sendCondition)
[09:28:27.401]                           }
[09:28:27.401]                         }
[09:28:27.401]                         frame <- frame + 1L
[09:28:27.401]                         envir <- sys.frame(frame)
[09:28:27.401]                       }
[09:28:27.401]                     }
[09:28:27.401]                     sendCondition <<- function(cond) NULL
[09:28:27.401]                   }
[09:28:27.401]                 })
[09:28:27.401]                 withCallingHandlers({
[09:28:27.401]                   {
[09:28:27.401]                     do.call(function(...) {
[09:28:27.401]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.401]                       if (!identical(...future.globals.maxSize.org, 
[09:28:27.401]                         ...future.globals.maxSize)) {
[09:28:27.401]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.401]                         on.exit(options(oopts), add = TRUE)
[09:28:27.401]                       }
[09:28:27.401]                       {
[09:28:27.401]                         lapply(seq_along(...future.elements_ii), 
[09:28:27.401]                           FUN = function(jj) {
[09:28:27.401]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.401]                             ...future.FUN(...future.X_jj, ...)
[09:28:27.401]                           })
[09:28:27.401]                       }
[09:28:27.401]                     }, args = future.call.arguments)
[09:28:27.401]                   }
[09:28:27.401]                 }, immediateCondition = function(cond) {
[09:28:27.401]                   sendCondition <- ...future.makeSendCondition()
[09:28:27.401]                   sendCondition(cond)
[09:28:27.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.401]                   {
[09:28:27.401]                     inherits <- base::inherits
[09:28:27.401]                     invokeRestart <- base::invokeRestart
[09:28:27.401]                     is.null <- base::is.null
[09:28:27.401]                     muffled <- FALSE
[09:28:27.401]                     if (inherits(cond, "message")) {
[09:28:27.401]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:27.401]                       if (muffled) 
[09:28:27.401]                         invokeRestart("muffleMessage")
[09:28:27.401]                     }
[09:28:27.401]                     else if (inherits(cond, "warning")) {
[09:28:27.401]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:27.401]                       if (muffled) 
[09:28:27.401]                         invokeRestart("muffleWarning")
[09:28:27.401]                     }
[09:28:27.401]                     else if (inherits(cond, "condition")) {
[09:28:27.401]                       if (!is.null(pattern)) {
[09:28:27.401]                         computeRestarts <- base::computeRestarts
[09:28:27.401]                         grepl <- base::grepl
[09:28:27.401]                         restarts <- computeRestarts(cond)
[09:28:27.401]                         for (restart in restarts) {
[09:28:27.401]                           name <- restart$name
[09:28:27.401]                           if (is.null(name)) 
[09:28:27.401]                             next
[09:28:27.401]                           if (!grepl(pattern, name)) 
[09:28:27.401]                             next
[09:28:27.401]                           invokeRestart(restart)
[09:28:27.401]                           muffled <- TRUE
[09:28:27.401]                           break
[09:28:27.401]                         }
[09:28:27.401]                       }
[09:28:27.401]                     }
[09:28:27.401]                     invisible(muffled)
[09:28:27.401]                   }
[09:28:27.401]                   muffleCondition(cond)
[09:28:27.401]                 })
[09:28:27.401]             }))
[09:28:27.401]             future::FutureResult(value = ...future.value$value, 
[09:28:27.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.401]                   ...future.rng), globalenv = if (FALSE) 
[09:28:27.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:27.401]                     ...future.globalenv.names))
[09:28:27.401]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:27.401]         }, condition = base::local({
[09:28:27.401]             c <- base::c
[09:28:27.401]             inherits <- base::inherits
[09:28:27.401]             invokeRestart <- base::invokeRestart
[09:28:27.401]             length <- base::length
[09:28:27.401]             list <- base::list
[09:28:27.401]             seq.int <- base::seq.int
[09:28:27.401]             signalCondition <- base::signalCondition
[09:28:27.401]             sys.calls <- base::sys.calls
[09:28:27.401]             `[[` <- base::`[[`
[09:28:27.401]             `+` <- base::`+`
[09:28:27.401]             `<<-` <- base::`<<-`
[09:28:27.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:27.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:27.401]                   3L)]
[09:28:27.401]             }
[09:28:27.401]             function(cond) {
[09:28:27.401]                 is_error <- inherits(cond, "error")
[09:28:27.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:27.401]                   NULL)
[09:28:27.401]                 if (is_error) {
[09:28:27.401]                   sessionInformation <- function() {
[09:28:27.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:27.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:27.401]                       search = base::search(), system = base::Sys.info())
[09:28:27.401]                   }
[09:28:27.401]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:27.401]                     cond$call), session = sessionInformation(), 
[09:28:27.401]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:27.401]                   signalCondition(cond)
[09:28:27.401]                 }
[09:28:27.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:27.401]                 "immediateCondition"))) {
[09:28:27.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:27.401]                   ...future.conditions[[length(...future.conditions) + 
[09:28:27.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:27.401]                   if (TRUE && !signal) {
[09:28:27.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.401]                     {
[09:28:27.401]                       inherits <- base::inherits
[09:28:27.401]                       invokeRestart <- base::invokeRestart
[09:28:27.401]                       is.null <- base::is.null
[09:28:27.401]                       muffled <- FALSE
[09:28:27.401]                       if (inherits(cond, "message")) {
[09:28:27.401]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.401]                         if (muffled) 
[09:28:27.401]                           invokeRestart("muffleMessage")
[09:28:27.401]                       }
[09:28:27.401]                       else if (inherits(cond, "warning")) {
[09:28:27.401]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.401]                         if (muffled) 
[09:28:27.401]                           invokeRestart("muffleWarning")
[09:28:27.401]                       }
[09:28:27.401]                       else if (inherits(cond, "condition")) {
[09:28:27.401]                         if (!is.null(pattern)) {
[09:28:27.401]                           computeRestarts <- base::computeRestarts
[09:28:27.401]                           grepl <- base::grepl
[09:28:27.401]                           restarts <- computeRestarts(cond)
[09:28:27.401]                           for (restart in restarts) {
[09:28:27.401]                             name <- restart$name
[09:28:27.401]                             if (is.null(name)) 
[09:28:27.401]                               next
[09:28:27.401]                             if (!grepl(pattern, name)) 
[09:28:27.401]                               next
[09:28:27.401]                             invokeRestart(restart)
[09:28:27.401]                             muffled <- TRUE
[09:28:27.401]                             break
[09:28:27.401]                           }
[09:28:27.401]                         }
[09:28:27.401]                       }
[09:28:27.401]                       invisible(muffled)
[09:28:27.401]                     }
[09:28:27.401]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.401]                   }
[09:28:27.401]                 }
[09:28:27.401]                 else {
[09:28:27.401]                   if (TRUE) {
[09:28:27.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:27.401]                     {
[09:28:27.401]                       inherits <- base::inherits
[09:28:27.401]                       invokeRestart <- base::invokeRestart
[09:28:27.401]                       is.null <- base::is.null
[09:28:27.401]                       muffled <- FALSE
[09:28:27.401]                       if (inherits(cond, "message")) {
[09:28:27.401]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:27.401]                         if (muffled) 
[09:28:27.401]                           invokeRestart("muffleMessage")
[09:28:27.401]                       }
[09:28:27.401]                       else if (inherits(cond, "warning")) {
[09:28:27.401]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:27.401]                         if (muffled) 
[09:28:27.401]                           invokeRestart("muffleWarning")
[09:28:27.401]                       }
[09:28:27.401]                       else if (inherits(cond, "condition")) {
[09:28:27.401]                         if (!is.null(pattern)) {
[09:28:27.401]                           computeRestarts <- base::computeRestarts
[09:28:27.401]                           grepl <- base::grepl
[09:28:27.401]                           restarts <- computeRestarts(cond)
[09:28:27.401]                           for (restart in restarts) {
[09:28:27.401]                             name <- restart$name
[09:28:27.401]                             if (is.null(name)) 
[09:28:27.401]                               next
[09:28:27.401]                             if (!grepl(pattern, name)) 
[09:28:27.401]                               next
[09:28:27.401]                             invokeRestart(restart)
[09:28:27.401]                             muffled <- TRUE
[09:28:27.401]                             break
[09:28:27.401]                           }
[09:28:27.401]                         }
[09:28:27.401]                       }
[09:28:27.401]                       invisible(muffled)
[09:28:27.401]                     }
[09:28:27.401]                     muffleCondition(cond, pattern = "^muffle")
[09:28:27.401]                   }
[09:28:27.401]                 }
[09:28:27.401]             }
[09:28:27.401]         }))
[09:28:27.401]     }, error = function(ex) {
[09:28:27.401]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:27.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:27.401]                 ...future.rng), started = ...future.startTime, 
[09:28:27.401]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:27.401]             version = "1.8"), class = "FutureResult")
[09:28:27.401]     }, finally = {
[09:28:27.401]         if (!identical(...future.workdir, getwd())) 
[09:28:27.401]             setwd(...future.workdir)
[09:28:27.401]         {
[09:28:27.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:27.401]                 ...future.oldOptions$nwarnings <- NULL
[09:28:27.401]             }
[09:28:27.401]             base::options(...future.oldOptions)
[09:28:27.401]             if (.Platform$OS.type == "windows") {
[09:28:27.401]                 old_names <- names(...future.oldEnvVars)
[09:28:27.401]                 envs <- base::Sys.getenv()
[09:28:27.401]                 names <- names(envs)
[09:28:27.401]                 common <- intersect(names, old_names)
[09:28:27.401]                 added <- setdiff(names, old_names)
[09:28:27.401]                 removed <- setdiff(old_names, names)
[09:28:27.401]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:27.401]                   envs[common]]
[09:28:27.401]                 NAMES <- toupper(changed)
[09:28:27.401]                 args <- list()
[09:28:27.401]                 for (kk in seq_along(NAMES)) {
[09:28:27.401]                   name <- changed[[kk]]
[09:28:27.401]                   NAME <- NAMES[[kk]]
[09:28:27.401]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.401]                     next
[09:28:27.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.401]                 }
[09:28:27.401]                 NAMES <- toupper(added)
[09:28:27.401]                 for (kk in seq_along(NAMES)) {
[09:28:27.401]                   name <- added[[kk]]
[09:28:27.401]                   NAME <- NAMES[[kk]]
[09:28:27.401]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.401]                     next
[09:28:27.401]                   args[[name]] <- ""
[09:28:27.401]                 }
[09:28:27.401]                 NAMES <- toupper(removed)
[09:28:27.401]                 for (kk in seq_along(NAMES)) {
[09:28:27.401]                   name <- removed[[kk]]
[09:28:27.401]                   NAME <- NAMES[[kk]]
[09:28:27.401]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:27.401]                     next
[09:28:27.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:27.401]                 }
[09:28:27.401]                 if (length(args) > 0) 
[09:28:27.401]                   base::do.call(base::Sys.setenv, args = args)
[09:28:27.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:27.401]             }
[09:28:27.401]             else {
[09:28:27.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:27.401]             }
[09:28:27.401]             {
[09:28:27.401]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:27.401]                   0L) {
[09:28:27.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:27.401]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:27.401]                   base::options(opts)
[09:28:27.401]                 }
[09:28:27.401]                 {
[09:28:27.401]                   {
[09:28:27.401]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:27.401]                     NULL
[09:28:27.401]                   }
[09:28:27.401]                   options(future.plan = NULL)
[09:28:27.401]                   if (is.na(NA_character_)) 
[09:28:27.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:27.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:27.401]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:27.401]                     .init = FALSE)
[09:28:27.401]                 }
[09:28:27.401]             }
[09:28:27.401]         }
[09:28:27.401]     })
[09:28:27.401]     if (TRUE) {
[09:28:27.401]         base::sink(type = "output", split = FALSE)
[09:28:27.401]         if (TRUE) {
[09:28:27.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:27.401]         }
[09:28:27.401]         else {
[09:28:27.401]             ...future.result["stdout"] <- base::list(NULL)
[09:28:27.401]         }
[09:28:27.401]         base::close(...future.stdout)
[09:28:27.401]         ...future.stdout <- NULL
[09:28:27.401]     }
[09:28:27.401]     ...future.result$conditions <- ...future.conditions
[09:28:27.401]     ...future.result$finished <- base::Sys.time()
[09:28:27.401]     ...future.result
[09:28:27.401] }
[09:28:27.404] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[09:28:27.404] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[09:28:27.404] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[09:28:27.405] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:27.405] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:27.405] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[09:28:27.406] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[09:28:27.406] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:27.406] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:27.406] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:28:27.406] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:28:27.407] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[09:28:27.407] MultisessionFuture started
[09:28:27.407] - Launch lazy future ... done
[09:28:27.407] run() for ‘MultisessionFuture’ ... done
[09:28:27.408] Created future:
[09:28:27.408] MultisessionFuture:
[09:28:27.408] Label: ‘future_eapply-2’
[09:28:27.408] Expression:
[09:28:27.408] {
[09:28:27.408]     do.call(function(...) {
[09:28:27.408]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:27.408]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:27.408]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:27.408]             on.exit(options(oopts), add = TRUE)
[09:28:27.408]         }
[09:28:27.408]         {
[09:28:27.408]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:27.408]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:27.408]                 ...future.FUN(...future.X_jj, ...)
[09:28:27.408]             })
[09:28:27.408]         }
[09:28:27.408]     }, args = future.call.arguments)
[09:28:27.408] }
[09:28:27.408] Lazy evaluation: FALSE
[09:28:27.408] Asynchronous evaluation: TRUE
[09:28:27.408] Local evaluation: TRUE
[09:28:27.408] Environment: R_GlobalEnv
[09:28:27.408] Capture standard output: TRUE
[09:28:27.408] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:27.408] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:27.408] Packages: 1 packages (‘stats’)
[09:28:27.408] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:27.408] Resolved: FALSE
[09:28:27.408] Value: <not collected>
[09:28:27.408] Conditions captured: <none>
[09:28:27.408] Early signaling: FALSE
[09:28:27.408] Owner process: 3a7e3cc6-88cf-aa50-0c8b-f18161e5fc07
[09:28:27.408] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:27.419] Chunk #2 of 2 ... DONE
[09:28:27.419] Launching 2 futures (chunks) ... DONE
[09:28:27.419] Resolving 2 futures (chunks) ...
[09:28:27.419] resolve() on list ...
[09:28:27.420]  recursive: 0
[09:28:27.420]  length: 2
[09:28:27.420] 
[09:28:27.420] receiveMessageFromWorker() for ClusterFuture ...
[09:28:27.420] - Validating connection of MultisessionFuture
[09:28:27.420] - received message: FutureResult
[09:28:27.421] - Received FutureResult
[09:28:27.421] - Erased future from FutureRegistry
[09:28:27.421] result() for ClusterFuture ...
[09:28:27.421] - result already collected: FutureResult
[09:28:27.421] result() for ClusterFuture ... done
[09:28:27.421] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:27.421] Future #1
[09:28:27.421] result() for ClusterFuture ...
[09:28:27.421] - result already collected: FutureResult
[09:28:27.421] result() for ClusterFuture ... done
[09:28:27.421] result() for ClusterFuture ...
[09:28:27.421] - result already collected: FutureResult
[09:28:27.422] result() for ClusterFuture ... done
[09:28:27.422] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:27.422] - nx: 2
[09:28:27.422] - relay: TRUE
[09:28:27.422] - stdout: TRUE
[09:28:27.422] - signal: TRUE
[09:28:27.422] - resignal: FALSE
[09:28:27.422] - force: TRUE
[09:28:27.422] - relayed: [n=2] FALSE, FALSE
[09:28:27.422] - queued futures: [n=2] FALSE, FALSE
[09:28:27.422]  - until=1
[09:28:27.422]  - relaying element #1
[09:28:27.423] result() for ClusterFuture ...
[09:28:27.423] - result already collected: FutureResult
[09:28:27.423] result() for ClusterFuture ... done
[09:28:27.423] result() for ClusterFuture ...
[09:28:27.423] - result already collected: FutureResult
[09:28:27.423] result() for ClusterFuture ... done
[09:28:27.423] result() for ClusterFuture ...
[09:28:27.423] - result already collected: FutureResult
[09:28:27.423] result() for ClusterFuture ... done
[09:28:27.423] result() for ClusterFuture ...
[09:28:27.423] - result already collected: FutureResult
[09:28:27.424] result() for ClusterFuture ... done
[09:28:27.424] - relayed: [n=2] TRUE, FALSE
[09:28:27.424] - queued futures: [n=2] TRUE, FALSE
[09:28:27.424] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:27.424]  length: 1 (resolved future 1)
[09:28:27.450] receiveMessageFromWorker() for ClusterFuture ...
[09:28:27.450] - Validating connection of MultisessionFuture
[09:28:27.450] - received message: FutureResult
[09:28:27.450] - Received FutureResult
[09:28:27.450] - Erased future from FutureRegistry
[09:28:27.450] result() for ClusterFuture ...
[09:28:27.450] - result already collected: FutureResult
[09:28:27.451] result() for ClusterFuture ... done
[09:28:27.451] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:27.451] Future #2
[09:28:27.451] result() for ClusterFuture ...
[09:28:27.451] - result already collected: FutureResult
[09:28:27.451] result() for ClusterFuture ... done
[09:28:27.451] result() for ClusterFuture ...
[09:28:27.451] - result already collected: FutureResult
[09:28:27.451] result() for ClusterFuture ... done
[09:28:27.451] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:27.451] - nx: 2
[09:28:27.452] - relay: TRUE
[09:28:27.452] - stdout: TRUE
[09:28:27.452] - signal: TRUE
[09:28:27.452] - resignal: FALSE
[09:28:27.452] - force: TRUE
[09:28:27.452] - relayed: [n=2] TRUE, FALSE
[09:28:27.452] - queued futures: [n=2] TRUE, FALSE
[09:28:27.452]  - until=2
[09:28:27.452]  - relaying element #2
[09:28:27.452] result() for ClusterFuture ...
[09:28:27.452] - result already collected: FutureResult
[09:28:27.453] result() for ClusterFuture ... done
[09:28:27.453] result() for ClusterFuture ...
[09:28:27.453] - result already collected: FutureResult
[09:28:27.453] result() for ClusterFuture ... done
[09:28:27.453] result() for ClusterFuture ...
[09:28:27.453] - result already collected: FutureResult
[09:28:27.453] result() for ClusterFuture ... done
[09:28:27.453] result() for ClusterFuture ...
[09:28:27.453] - result already collected: FutureResult
[09:28:27.453] result() for ClusterFuture ... done
[09:28:27.453] - relayed: [n=2] TRUE, TRUE
[09:28:27.453] - queued futures: [n=2] TRUE, TRUE
[09:28:27.454] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:27.454]  length: 0 (resolved future 2)
[09:28:27.454] Relaying remaining futures
[09:28:27.454] signalConditionsASAP(NULL, pos=0) ...
[09:28:27.454] - nx: 2
[09:28:27.454] - relay: TRUE
[09:28:27.454] - stdout: TRUE
[09:28:27.454] - signal: TRUE
[09:28:27.454] - resignal: FALSE
[09:28:27.454] - force: TRUE
[09:28:27.454] - relayed: [n=2] TRUE, TRUE
[09:28:27.455] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:27.455] - relayed: [n=2] TRUE, TRUE
[09:28:27.455] - queued futures: [n=2] TRUE, TRUE
[09:28:27.455] signalConditionsASAP(NULL, pos=0) ... done
[09:28:27.455] resolve() on list ... DONE
[09:28:27.455] result() for ClusterFuture ...
[09:28:27.455] - result already collected: FutureResult
[09:28:27.455] result() for ClusterFuture ... done
[09:28:27.455] result() for ClusterFuture ...
[09:28:27.455] - result already collected: FutureResult
[09:28:27.455] result() for ClusterFuture ... done
[09:28:27.456] result() for ClusterFuture ...
[09:28:27.456] - result already collected: FutureResult
[09:28:27.456] result() for ClusterFuture ... done
[09:28:27.456] result() for ClusterFuture ...
[09:28:27.456] - result already collected: FutureResult
[09:28:27.456] result() for ClusterFuture ... done
[09:28:27.456]  - Number of value chunks collected: 2
[09:28:27.456] Resolving 2 futures (chunks) ... DONE
[09:28:27.456] Reducing values from 2 chunks ...
[09:28:27.456]  - Number of values collected after concatenation: 3
[09:28:27.456]  - Number of values expected: 3
[09:28:27.456] Reducing values from 2 chunks ... DONE
[09:28:27.457] future_lapply() ... DONE
[09:28:27.457] plan(): Setting new future strategy stack:
[09:28:27.457] List of future strategies:
[09:28:27.457] 1. sequential:
[09:28:27.457]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:27.457]    - tweaked: FALSE
[09:28:27.457]    - call: plan(sequential)
[09:28:27.458] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[09:28:27.459] plan(): Setting new future strategy stack:
[09:28:27.459] List of future strategies:
[09:28:27.459] 1. FutureStrategy:
[09:28:27.459]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:27.459]    - tweaked: FALSE
[09:28:27.459]    - call: future::plan(oplan)
[09:28:27.460] plan(): nbrOfWorkers() = 1
> 
