
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:36:39.153] plan(): Setting new future strategy stack:
[17:36:39.153] List of future strategies:
[17:36:39.153] 1. sequential:
[17:36:39.153]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.153]    - tweaked: FALSE
[17:36:39.153]    - call: future::plan("sequential")
[17:36:39.168] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[17:36:39.223] plan(): Setting new future strategy stack:
[17:36:39.223] List of future strategies:
[17:36:39.223] 1. sequential:
[17:36:39.223]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.223]    - tweaked: FALSE
[17:36:39.223]    - call: plan(strategy)
[17:36:39.235] plan(): nbrOfWorkers() = 1
[17:36:39.236] future_by_internal() ...
[17:36:39.236] future_lapply() ...
[17:36:39.240] Number of chunks: 1
[17:36:39.240] getGlobalsAndPackagesXApply() ...
[17:36:39.240]  - future.globals: TRUE
[17:36:39.241] getGlobalsAndPackages() ...
[17:36:39.241] Searching for globals...
[17:36:39.243] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:39.243] Searching for globals ... DONE
[17:36:39.244] Resolving globals: FALSE
[17:36:39.244] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:39.245] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:39.245] - globals: [1] ‘FUN’
[17:36:39.245] 
[17:36:39.245] getGlobalsAndPackages() ... DONE
[17:36:39.245]  - globals found/used: [n=1] ‘FUN’
[17:36:39.245]  - needed namespaces: [n=0] 
[17:36:39.246] Finding globals ... DONE
[17:36:39.246]  - use_args: TRUE
[17:36:39.246]  - Getting '...' globals ...
[17:36:39.246] resolve() on list ...
[17:36:39.247]  recursive: 0
[17:36:39.247]  length: 1
[17:36:39.247]  elements: ‘...’
[17:36:39.247]  length: 0 (resolved future 1)
[17:36:39.247] resolve() on list ... DONE
[17:36:39.247]    - '...' content: [n=0] 
[17:36:39.247] List of 1
[17:36:39.247]  $ ...: list()
[17:36:39.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.247]  - attr(*, "where")=List of 1
[17:36:39.247]   ..$ ...:<environment: 0x5622faaf09e0> 
[17:36:39.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.247]  - attr(*, "resolved")= logi TRUE
[17:36:39.247]  - attr(*, "total_size")= num NA
[17:36:39.251]  - Getting '...' globals ... DONE
[17:36:39.252] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.252] List of 2
[17:36:39.252]  $ ...future.FUN:function (object, ...)  
[17:36:39.252]  $ ...          : list()
[17:36:39.252]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.252]  - attr(*, "where")=List of 2
[17:36:39.252]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.252]   ..$ ...          :<environment: 0x5622faaf09e0> 
[17:36:39.252]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.252]  - attr(*, "resolved")= logi FALSE
[17:36:39.252]  - attr(*, "total_size")= num 1240
[17:36:39.254] Packages to be attached in all futures: [n=0] 
[17:36:39.254] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.255] Number of futures (= number of chunks): 1
[17:36:39.255] Launching 1 futures (chunks) ...
[17:36:39.255] Chunk #1 of 1 ...
[17:36:39.255]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.255] getGlobalsAndPackages() ...
[17:36:39.255] Searching for globals...
[17:36:39.256] 
[17:36:39.256] Searching for globals ... DONE
[17:36:39.256] - globals: [0] <none>
[17:36:39.256] getGlobalsAndPackages() ... DONE
[17:36:39.256]    + additional globals found: [n=0] 
[17:36:39.256]    + additional namespaces needed: [n=0] 
[17:36:39.257]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.257]  - seeds: <none>
[17:36:39.257]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.257] getGlobalsAndPackages() ...
[17:36:39.257] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.257] Resolving globals: FALSE
[17:36:39.257] Tweak future expression to call with '...' arguments ...
[17:36:39.257] {
[17:36:39.257]     do.call(function(...) {
[17:36:39.257]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.257]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.257]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.257]             on.exit(options(oopts), add = TRUE)
[17:36:39.257]         }
[17:36:39.257]         {
[17:36:39.257]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.257]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.257]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.257]             })
[17:36:39.257]         }
[17:36:39.257]     }, args = future.call.arguments)
[17:36:39.257] }
[17:36:39.258] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.258] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.258] 
[17:36:39.258] getGlobalsAndPackages() ... DONE
[17:36:39.259] run() for ‘Future’ ...
[17:36:39.259] - state: ‘created’
[17:36:39.259] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:39.259] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.260] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.260]   - Field: ‘label’
[17:36:39.260]   - Field: ‘local’
[17:36:39.260]   - Field: ‘owner’
[17:36:39.260]   - Field: ‘envir’
[17:36:39.260]   - Field: ‘packages’
[17:36:39.260]   - Field: ‘gc’
[17:36:39.260]   - Field: ‘conditions’
[17:36:39.260]   - Field: ‘expr’
[17:36:39.260]   - Field: ‘uuid’
[17:36:39.261]   - Field: ‘seed’
[17:36:39.261]   - Field: ‘version’
[17:36:39.261]   - Field: ‘result’
[17:36:39.261]   - Field: ‘asynchronous’
[17:36:39.261]   - Field: ‘calls’
[17:36:39.261]   - Field: ‘globals’
[17:36:39.261]   - Field: ‘stdout’
[17:36:39.261]   - Field: ‘earlySignal’
[17:36:39.261]   - Field: ‘lazy’
[17:36:39.261]   - Field: ‘state’
[17:36:39.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.262] - Launch lazy future ...
[17:36:39.262] Packages needed by the future expression (n = 0): <none>
[17:36:39.262] Packages needed by future strategies (n = 0): <none>
[17:36:39.263] {
[17:36:39.263]     {
[17:36:39.263]         {
[17:36:39.263]             ...future.startTime <- base::Sys.time()
[17:36:39.263]             {
[17:36:39.263]                 {
[17:36:39.263]                   {
[17:36:39.263]                     base::local({
[17:36:39.263]                       has_future <- base::requireNamespace("future", 
[17:36:39.263]                         quietly = TRUE)
[17:36:39.263]                       if (has_future) {
[17:36:39.263]                         ns <- base::getNamespace("future")
[17:36:39.263]                         version <- ns[[".package"]][["version"]]
[17:36:39.263]                         if (is.null(version)) 
[17:36:39.263]                           version <- utils::packageVersion("future")
[17:36:39.263]                       }
[17:36:39.263]                       else {
[17:36:39.263]                         version <- NULL
[17:36:39.263]                       }
[17:36:39.263]                       if (!has_future || version < "1.8.0") {
[17:36:39.263]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.263]                           "", base::R.version$version.string), 
[17:36:39.263]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:39.263]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.263]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.263]                             "release", "version")], collapse = " "), 
[17:36:39.263]                           hostname = base::Sys.info()[["nodename"]])
[17:36:39.263]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.263]                           info)
[17:36:39.263]                         info <- base::paste(info, collapse = "; ")
[17:36:39.263]                         if (!has_future) {
[17:36:39.263]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.263]                             info)
[17:36:39.263]                         }
[17:36:39.263]                         else {
[17:36:39.263]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.263]                             info, version)
[17:36:39.263]                         }
[17:36:39.263]                         base::stop(msg)
[17:36:39.263]                       }
[17:36:39.263]                     })
[17:36:39.263]                   }
[17:36:39.263]                   ...future.strategy.old <- future::plan("list")
[17:36:39.263]                   options(future.plan = NULL)
[17:36:39.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.263]                 }
[17:36:39.263]                 ...future.workdir <- getwd()
[17:36:39.263]             }
[17:36:39.263]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.263]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.263]         }
[17:36:39.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.263]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.263]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.263]             base::names(...future.oldOptions))
[17:36:39.263]     }
[17:36:39.263]     if (FALSE) {
[17:36:39.263]     }
[17:36:39.263]     else {
[17:36:39.263]         if (TRUE) {
[17:36:39.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.263]                 open = "w")
[17:36:39.263]         }
[17:36:39.263]         else {
[17:36:39.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.263]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.263]         }
[17:36:39.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.263]             base::sink(type = "output", split = FALSE)
[17:36:39.263]             base::close(...future.stdout)
[17:36:39.263]         }, add = TRUE)
[17:36:39.263]     }
[17:36:39.263]     ...future.frame <- base::sys.nframe()
[17:36:39.263]     ...future.conditions <- base::list()
[17:36:39.263]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.263]     if (FALSE) {
[17:36:39.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.263]     }
[17:36:39.263]     ...future.result <- base::tryCatch({
[17:36:39.263]         base::withCallingHandlers({
[17:36:39.263]             ...future.value <- base::withVisible(base::local({
[17:36:39.263]                 do.call(function(...) {
[17:36:39.263]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.263]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.263]                     ...future.globals.maxSize)) {
[17:36:39.263]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.263]                     on.exit(options(oopts), add = TRUE)
[17:36:39.263]                   }
[17:36:39.263]                   {
[17:36:39.263]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.263]                       FUN = function(jj) {
[17:36:39.263]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.263]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.263]                       })
[17:36:39.263]                   }
[17:36:39.263]                 }, args = future.call.arguments)
[17:36:39.263]             }))
[17:36:39.263]             future::FutureResult(value = ...future.value$value, 
[17:36:39.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.263]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.263]                     ...future.globalenv.names))
[17:36:39.263]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.263]         }, condition = base::local({
[17:36:39.263]             c <- base::c
[17:36:39.263]             inherits <- base::inherits
[17:36:39.263]             invokeRestart <- base::invokeRestart
[17:36:39.263]             length <- base::length
[17:36:39.263]             list <- base::list
[17:36:39.263]             seq.int <- base::seq.int
[17:36:39.263]             signalCondition <- base::signalCondition
[17:36:39.263]             sys.calls <- base::sys.calls
[17:36:39.263]             `[[` <- base::`[[`
[17:36:39.263]             `+` <- base::`+`
[17:36:39.263]             `<<-` <- base::`<<-`
[17:36:39.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.263]                   3L)]
[17:36:39.263]             }
[17:36:39.263]             function(cond) {
[17:36:39.263]                 is_error <- inherits(cond, "error")
[17:36:39.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.263]                   NULL)
[17:36:39.263]                 if (is_error) {
[17:36:39.263]                   sessionInformation <- function() {
[17:36:39.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.263]                       search = base::search(), system = base::Sys.info())
[17:36:39.263]                   }
[17:36:39.263]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.263]                     cond$call), session = sessionInformation(), 
[17:36:39.263]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.263]                   signalCondition(cond)
[17:36:39.263]                 }
[17:36:39.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.263]                 "immediateCondition"))) {
[17:36:39.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.263]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.263]                   if (TRUE && !signal) {
[17:36:39.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.263]                     {
[17:36:39.263]                       inherits <- base::inherits
[17:36:39.263]                       invokeRestart <- base::invokeRestart
[17:36:39.263]                       is.null <- base::is.null
[17:36:39.263]                       muffled <- FALSE
[17:36:39.263]                       if (inherits(cond, "message")) {
[17:36:39.263]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.263]                         if (muffled) 
[17:36:39.263]                           invokeRestart("muffleMessage")
[17:36:39.263]                       }
[17:36:39.263]                       else if (inherits(cond, "warning")) {
[17:36:39.263]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.263]                         if (muffled) 
[17:36:39.263]                           invokeRestart("muffleWarning")
[17:36:39.263]                       }
[17:36:39.263]                       else if (inherits(cond, "condition")) {
[17:36:39.263]                         if (!is.null(pattern)) {
[17:36:39.263]                           computeRestarts <- base::computeRestarts
[17:36:39.263]                           grepl <- base::grepl
[17:36:39.263]                           restarts <- computeRestarts(cond)
[17:36:39.263]                           for (restart in restarts) {
[17:36:39.263]                             name <- restart$name
[17:36:39.263]                             if (is.null(name)) 
[17:36:39.263]                               next
[17:36:39.263]                             if (!grepl(pattern, name)) 
[17:36:39.263]                               next
[17:36:39.263]                             invokeRestart(restart)
[17:36:39.263]                             muffled <- TRUE
[17:36:39.263]                             break
[17:36:39.263]                           }
[17:36:39.263]                         }
[17:36:39.263]                       }
[17:36:39.263]                       invisible(muffled)
[17:36:39.263]                     }
[17:36:39.263]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.263]                   }
[17:36:39.263]                 }
[17:36:39.263]                 else {
[17:36:39.263]                   if (TRUE) {
[17:36:39.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.263]                     {
[17:36:39.263]                       inherits <- base::inherits
[17:36:39.263]                       invokeRestart <- base::invokeRestart
[17:36:39.263]                       is.null <- base::is.null
[17:36:39.263]                       muffled <- FALSE
[17:36:39.263]                       if (inherits(cond, "message")) {
[17:36:39.263]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.263]                         if (muffled) 
[17:36:39.263]                           invokeRestart("muffleMessage")
[17:36:39.263]                       }
[17:36:39.263]                       else if (inherits(cond, "warning")) {
[17:36:39.263]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.263]                         if (muffled) 
[17:36:39.263]                           invokeRestart("muffleWarning")
[17:36:39.263]                       }
[17:36:39.263]                       else if (inherits(cond, "condition")) {
[17:36:39.263]                         if (!is.null(pattern)) {
[17:36:39.263]                           computeRestarts <- base::computeRestarts
[17:36:39.263]                           grepl <- base::grepl
[17:36:39.263]                           restarts <- computeRestarts(cond)
[17:36:39.263]                           for (restart in restarts) {
[17:36:39.263]                             name <- restart$name
[17:36:39.263]                             if (is.null(name)) 
[17:36:39.263]                               next
[17:36:39.263]                             if (!grepl(pattern, name)) 
[17:36:39.263]                               next
[17:36:39.263]                             invokeRestart(restart)
[17:36:39.263]                             muffled <- TRUE
[17:36:39.263]                             break
[17:36:39.263]                           }
[17:36:39.263]                         }
[17:36:39.263]                       }
[17:36:39.263]                       invisible(muffled)
[17:36:39.263]                     }
[17:36:39.263]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.263]                   }
[17:36:39.263]                 }
[17:36:39.263]             }
[17:36:39.263]         }))
[17:36:39.263]     }, error = function(ex) {
[17:36:39.263]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.263]                 ...future.rng), started = ...future.startTime, 
[17:36:39.263]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.263]             version = "1.8"), class = "FutureResult")
[17:36:39.263]     }, finally = {
[17:36:39.263]         if (!identical(...future.workdir, getwd())) 
[17:36:39.263]             setwd(...future.workdir)
[17:36:39.263]         {
[17:36:39.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.263]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.263]             }
[17:36:39.263]             base::options(...future.oldOptions)
[17:36:39.263]             if (.Platform$OS.type == "windows") {
[17:36:39.263]                 old_names <- names(...future.oldEnvVars)
[17:36:39.263]                 envs <- base::Sys.getenv()
[17:36:39.263]                 names <- names(envs)
[17:36:39.263]                 common <- intersect(names, old_names)
[17:36:39.263]                 added <- setdiff(names, old_names)
[17:36:39.263]                 removed <- setdiff(old_names, names)
[17:36:39.263]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.263]                   envs[common]]
[17:36:39.263]                 NAMES <- toupper(changed)
[17:36:39.263]                 args <- list()
[17:36:39.263]                 for (kk in seq_along(NAMES)) {
[17:36:39.263]                   name <- changed[[kk]]
[17:36:39.263]                   NAME <- NAMES[[kk]]
[17:36:39.263]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.263]                     next
[17:36:39.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.263]                 }
[17:36:39.263]                 NAMES <- toupper(added)
[17:36:39.263]                 for (kk in seq_along(NAMES)) {
[17:36:39.263]                   name <- added[[kk]]
[17:36:39.263]                   NAME <- NAMES[[kk]]
[17:36:39.263]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.263]                     next
[17:36:39.263]                   args[[name]] <- ""
[17:36:39.263]                 }
[17:36:39.263]                 NAMES <- toupper(removed)
[17:36:39.263]                 for (kk in seq_along(NAMES)) {
[17:36:39.263]                   name <- removed[[kk]]
[17:36:39.263]                   NAME <- NAMES[[kk]]
[17:36:39.263]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.263]                     next
[17:36:39.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.263]                 }
[17:36:39.263]                 if (length(args) > 0) 
[17:36:39.263]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.263]             }
[17:36:39.263]             else {
[17:36:39.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.263]             }
[17:36:39.263]             {
[17:36:39.263]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.263]                   0L) {
[17:36:39.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.263]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.263]                   base::options(opts)
[17:36:39.263]                 }
[17:36:39.263]                 {
[17:36:39.263]                   {
[17:36:39.263]                     NULL
[17:36:39.263]                     RNGkind("Mersenne-Twister")
[17:36:39.263]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.263]                       inherits = FALSE)
[17:36:39.263]                   }
[17:36:39.263]                   options(future.plan = NULL)
[17:36:39.263]                   if (is.na(NA_character_)) 
[17:36:39.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.263]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.263]                     .init = FALSE)
[17:36:39.263]                 }
[17:36:39.263]             }
[17:36:39.263]         }
[17:36:39.263]     })
[17:36:39.263]     if (TRUE) {
[17:36:39.263]         base::sink(type = "output", split = FALSE)
[17:36:39.263]         if (TRUE) {
[17:36:39.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.263]         }
[17:36:39.263]         else {
[17:36:39.263]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.263]         }
[17:36:39.263]         base::close(...future.stdout)
[17:36:39.263]         ...future.stdout <- NULL
[17:36:39.263]     }
[17:36:39.263]     ...future.result$conditions <- ...future.conditions
[17:36:39.263]     ...future.result$finished <- base::Sys.time()
[17:36:39.263]     ...future.result
[17:36:39.263] }
[17:36:39.265] assign_globals() ...
[17:36:39.265] List of 5
[17:36:39.265]  $ ...future.FUN            :function (object, ...)  
[17:36:39.265]  $ future.call.arguments    : list()
[17:36:39.265]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.265]  $ ...future.elements_ii    :List of 3
[17:36:39.265]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:39.265]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:39.265]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.265]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:39.265]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:39.265]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.265]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:39.265]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:39.265]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.265]  $ ...future.seeds_ii       : NULL
[17:36:39.265]  $ ...future.globals.maxSize: NULL
[17:36:39.265]  - attr(*, "where")=List of 5
[17:36:39.265]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.265]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.265]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.265]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.265]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.265]  - attr(*, "resolved")= logi FALSE
[17:36:39.265]  - attr(*, "total_size")= num 1240
[17:36:39.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.265]  - attr(*, "already-done")= logi TRUE
[17:36:39.275] - copied ‘...future.FUN’ to environment
[17:36:39.276] - copied ‘future.call.arguments’ to environment
[17:36:39.276] - copied ‘...future.elements_ii’ to environment
[17:36:39.276] - copied ‘...future.seeds_ii’ to environment
[17:36:39.276] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.276] assign_globals() ... done
[17:36:39.276] plan(): Setting new future strategy stack:
[17:36:39.276] List of future strategies:
[17:36:39.276] 1. sequential:
[17:36:39.276]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.276]    - tweaked: FALSE
[17:36:39.276]    - call: NULL
[17:36:39.277] plan(): nbrOfWorkers() = 1
[17:36:39.279] plan(): Setting new future strategy stack:
[17:36:39.279] List of future strategies:
[17:36:39.279] 1. sequential:
[17:36:39.279]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.279]    - tweaked: FALSE
[17:36:39.279]    - call: plan(strategy)
[17:36:39.280] plan(): nbrOfWorkers() = 1
[17:36:39.280] SequentialFuture started (and completed)
[17:36:39.280] - Launch lazy future ... done
[17:36:39.281] run() for ‘SequentialFuture’ ... done
[17:36:39.281] Created future:
[17:36:39.281] SequentialFuture:
[17:36:39.281] Label: ‘future_by-1’
[17:36:39.281] Expression:
[17:36:39.281] {
[17:36:39.281]     do.call(function(...) {
[17:36:39.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.281]             on.exit(options(oopts), add = TRUE)
[17:36:39.281]         }
[17:36:39.281]         {
[17:36:39.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.281]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.281]             })
[17:36:39.281]         }
[17:36:39.281]     }, args = future.call.arguments)
[17:36:39.281] }
[17:36:39.281] Lazy evaluation: FALSE
[17:36:39.281] Asynchronous evaluation: FALSE
[17:36:39.281] Local evaluation: TRUE
[17:36:39.281] Environment: R_GlobalEnv
[17:36:39.281] Capture standard output: TRUE
[17:36:39.281] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.281] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.281] Packages: <none>
[17:36:39.281] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.281] Resolved: TRUE
[17:36:39.281] Value: 4.62 KiB of class ‘list’
[17:36:39.281] Early signaling: FALSE
[17:36:39.281] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.281] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.282] Chunk #1 of 1 ... DONE
[17:36:39.282] Launching 1 futures (chunks) ... DONE
[17:36:39.282] Resolving 1 futures (chunks) ...
[17:36:39.283] resolve() on list ...
[17:36:39.283]  recursive: 0
[17:36:39.283]  length: 1
[17:36:39.283] 
[17:36:39.283] resolved() for ‘SequentialFuture’ ...
[17:36:39.283] - state: ‘finished’
[17:36:39.283] - run: TRUE
[17:36:39.283] - result: ‘FutureResult’
[17:36:39.283] resolved() for ‘SequentialFuture’ ... done
[17:36:39.284] Future #1
[17:36:39.284] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.284] - nx: 1
[17:36:39.284] - relay: TRUE
[17:36:39.284] - stdout: TRUE
[17:36:39.284] - signal: TRUE
[17:36:39.284] - resignal: FALSE
[17:36:39.284] - force: TRUE
[17:36:39.285] - relayed: [n=1] FALSE
[17:36:39.285] - queued futures: [n=1] FALSE
[17:36:39.285]  - until=1
[17:36:39.285]  - relaying element #1
[17:36:39.285] - relayed: [n=1] TRUE
[17:36:39.285] - queued futures: [n=1] TRUE
[17:36:39.285] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.285]  length: 0 (resolved future 1)
[17:36:39.286] Relaying remaining futures
[17:36:39.286] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.286] - nx: 1
[17:36:39.286] - relay: TRUE
[17:36:39.286] - stdout: TRUE
[17:36:39.286] - signal: TRUE
[17:36:39.286] - resignal: FALSE
[17:36:39.286] - force: TRUE
[17:36:39.286] - relayed: [n=1] TRUE
[17:36:39.286] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.286] - relayed: [n=1] TRUE
[17:36:39.286] - queued futures: [n=1] TRUE
[17:36:39.287] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.287] resolve() on list ... DONE
[17:36:39.287]  - Number of value chunks collected: 1
[17:36:39.287] Resolving 1 futures (chunks) ... DONE
[17:36:39.287] Reducing values from 1 chunks ...
[17:36:39.287]  - Number of values collected after concatenation: 3
[17:36:39.287]  - Number of values expected: 3
[17:36:39.287] Reducing values from 1 chunks ... DONE
[17:36:39.287] future_lapply() ... DONE
[17:36:39.287] future_by_internal() ... DONE
[17:36:39.288] future_by_internal() ...
[17:36:39.288] future_lapply() ...
[17:36:39.289] Number of chunks: 1
[17:36:39.289] getGlobalsAndPackagesXApply() ...
[17:36:39.289]  - future.globals: TRUE
[17:36:39.289] getGlobalsAndPackages() ...
[17:36:39.289] Searching for globals...
[17:36:39.290] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:39.290] Searching for globals ... DONE
[17:36:39.291] Resolving globals: FALSE
[17:36:39.291] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:39.291] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:39.291] - globals: [1] ‘FUN’
[17:36:39.291] 
[17:36:39.292] getGlobalsAndPackages() ... DONE
[17:36:39.292]  - globals found/used: [n=1] ‘FUN’
[17:36:39.292]  - needed namespaces: [n=0] 
[17:36:39.292] Finding globals ... DONE
[17:36:39.292]  - use_args: TRUE
[17:36:39.292]  - Getting '...' globals ...
[17:36:39.292] resolve() on list ...
[17:36:39.292]  recursive: 0
[17:36:39.293]  length: 1
[17:36:39.293]  elements: ‘...’
[17:36:39.293]  length: 0 (resolved future 1)
[17:36:39.293] resolve() on list ... DONE
[17:36:39.293]    - '...' content: [n=1] ‘digits’
[17:36:39.293] List of 1
[17:36:39.293]  $ ...:List of 1
[17:36:39.293]   ..$ digits: int 2
[17:36:39.293]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.293]  - attr(*, "where")=List of 1
[17:36:39.293]   ..$ ...:<environment: 0x5622fc422278> 
[17:36:39.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.293]  - attr(*, "resolved")= logi TRUE
[17:36:39.293]  - attr(*, "total_size")= num NA
[17:36:39.297]  - Getting '...' globals ... DONE
[17:36:39.298] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.298] List of 2
[17:36:39.298]  $ ...future.FUN:function (object, ...)  
[17:36:39.298]  $ ...          :List of 1
[17:36:39.298]   ..$ digits: int 2
[17:36:39.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.298]  - attr(*, "where")=List of 2
[17:36:39.298]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.298]   ..$ ...          :<environment: 0x5622fc422278> 
[17:36:39.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.298]  - attr(*, "resolved")= logi FALSE
[17:36:39.298]  - attr(*, "total_size")= num 1296
[17:36:39.301] Packages to be attached in all futures: [n=0] 
[17:36:39.301] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.301] Number of futures (= number of chunks): 1
[17:36:39.301] Launching 1 futures (chunks) ...
[17:36:39.301] Chunk #1 of 1 ...
[17:36:39.301]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.301] getGlobalsAndPackages() ...
[17:36:39.301] Searching for globals...
[17:36:39.302] 
[17:36:39.302] Searching for globals ... DONE
[17:36:39.302] - globals: [0] <none>
[17:36:39.302] getGlobalsAndPackages() ... DONE
[17:36:39.302]    + additional globals found: [n=0] 
[17:36:39.302]    + additional namespaces needed: [n=0] 
[17:36:39.302]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.302]  - seeds: <none>
[17:36:39.302]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.303] getGlobalsAndPackages() ...
[17:36:39.303] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.303] Resolving globals: FALSE
[17:36:39.303] Tweak future expression to call with '...' arguments ...
[17:36:39.303] {
[17:36:39.303]     do.call(function(...) {
[17:36:39.303]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.303]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.303]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.303]             on.exit(options(oopts), add = TRUE)
[17:36:39.303]         }
[17:36:39.303]         {
[17:36:39.303]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.303]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.303]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.303]             })
[17:36:39.303]         }
[17:36:39.303]     }, args = future.call.arguments)
[17:36:39.303] }
[17:36:39.303] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.304] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.304] 
[17:36:39.304] getGlobalsAndPackages() ... DONE
[17:36:39.304] run() for ‘Future’ ...
[17:36:39.304] - state: ‘created’
[17:36:39.304] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:39.305] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.305]   - Field: ‘label’
[17:36:39.305]   - Field: ‘local’
[17:36:39.305]   - Field: ‘owner’
[17:36:39.305]   - Field: ‘envir’
[17:36:39.305]   - Field: ‘packages’
[17:36:39.305]   - Field: ‘gc’
[17:36:39.305]   - Field: ‘conditions’
[17:36:39.305]   - Field: ‘expr’
[17:36:39.306]   - Field: ‘uuid’
[17:36:39.306]   - Field: ‘seed’
[17:36:39.306]   - Field: ‘version’
[17:36:39.306]   - Field: ‘result’
[17:36:39.306]   - Field: ‘asynchronous’
[17:36:39.306]   - Field: ‘calls’
[17:36:39.306]   - Field: ‘globals’
[17:36:39.306]   - Field: ‘stdout’
[17:36:39.306]   - Field: ‘earlySignal’
[17:36:39.306]   - Field: ‘lazy’
[17:36:39.306]   - Field: ‘state’
[17:36:39.307] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.307] - Launch lazy future ...
[17:36:39.307] Packages needed by the future expression (n = 0): <none>
[17:36:39.307] Packages needed by future strategies (n = 0): <none>
[17:36:39.307] {
[17:36:39.307]     {
[17:36:39.307]         {
[17:36:39.307]             ...future.startTime <- base::Sys.time()
[17:36:39.307]             {
[17:36:39.307]                 {
[17:36:39.307]                   {
[17:36:39.307]                     base::local({
[17:36:39.307]                       has_future <- base::requireNamespace("future", 
[17:36:39.307]                         quietly = TRUE)
[17:36:39.307]                       if (has_future) {
[17:36:39.307]                         ns <- base::getNamespace("future")
[17:36:39.307]                         version <- ns[[".package"]][["version"]]
[17:36:39.307]                         if (is.null(version)) 
[17:36:39.307]                           version <- utils::packageVersion("future")
[17:36:39.307]                       }
[17:36:39.307]                       else {
[17:36:39.307]                         version <- NULL
[17:36:39.307]                       }
[17:36:39.307]                       if (!has_future || version < "1.8.0") {
[17:36:39.307]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.307]                           "", base::R.version$version.string), 
[17:36:39.307]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:39.307]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.307]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.307]                             "release", "version")], collapse = " "), 
[17:36:39.307]                           hostname = base::Sys.info()[["nodename"]])
[17:36:39.307]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.307]                           info)
[17:36:39.307]                         info <- base::paste(info, collapse = "; ")
[17:36:39.307]                         if (!has_future) {
[17:36:39.307]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.307]                             info)
[17:36:39.307]                         }
[17:36:39.307]                         else {
[17:36:39.307]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.307]                             info, version)
[17:36:39.307]                         }
[17:36:39.307]                         base::stop(msg)
[17:36:39.307]                       }
[17:36:39.307]                     })
[17:36:39.307]                   }
[17:36:39.307]                   ...future.strategy.old <- future::plan("list")
[17:36:39.307]                   options(future.plan = NULL)
[17:36:39.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.307]                 }
[17:36:39.307]                 ...future.workdir <- getwd()
[17:36:39.307]             }
[17:36:39.307]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.307]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.307]         }
[17:36:39.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.307]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.307]             base::names(...future.oldOptions))
[17:36:39.307]     }
[17:36:39.307]     if (FALSE) {
[17:36:39.307]     }
[17:36:39.307]     else {
[17:36:39.307]         if (TRUE) {
[17:36:39.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.307]                 open = "w")
[17:36:39.307]         }
[17:36:39.307]         else {
[17:36:39.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.307]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.307]         }
[17:36:39.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.307]             base::sink(type = "output", split = FALSE)
[17:36:39.307]             base::close(...future.stdout)
[17:36:39.307]         }, add = TRUE)
[17:36:39.307]     }
[17:36:39.307]     ...future.frame <- base::sys.nframe()
[17:36:39.307]     ...future.conditions <- base::list()
[17:36:39.307]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.307]     if (FALSE) {
[17:36:39.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.307]     }
[17:36:39.307]     ...future.result <- base::tryCatch({
[17:36:39.307]         base::withCallingHandlers({
[17:36:39.307]             ...future.value <- base::withVisible(base::local({
[17:36:39.307]                 do.call(function(...) {
[17:36:39.307]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.307]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.307]                     ...future.globals.maxSize)) {
[17:36:39.307]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.307]                     on.exit(options(oopts), add = TRUE)
[17:36:39.307]                   }
[17:36:39.307]                   {
[17:36:39.307]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.307]                       FUN = function(jj) {
[17:36:39.307]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.307]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.307]                       })
[17:36:39.307]                   }
[17:36:39.307]                 }, args = future.call.arguments)
[17:36:39.307]             }))
[17:36:39.307]             future::FutureResult(value = ...future.value$value, 
[17:36:39.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.307]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.307]                     ...future.globalenv.names))
[17:36:39.307]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.307]         }, condition = base::local({
[17:36:39.307]             c <- base::c
[17:36:39.307]             inherits <- base::inherits
[17:36:39.307]             invokeRestart <- base::invokeRestart
[17:36:39.307]             length <- base::length
[17:36:39.307]             list <- base::list
[17:36:39.307]             seq.int <- base::seq.int
[17:36:39.307]             signalCondition <- base::signalCondition
[17:36:39.307]             sys.calls <- base::sys.calls
[17:36:39.307]             `[[` <- base::`[[`
[17:36:39.307]             `+` <- base::`+`
[17:36:39.307]             `<<-` <- base::`<<-`
[17:36:39.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.307]                   3L)]
[17:36:39.307]             }
[17:36:39.307]             function(cond) {
[17:36:39.307]                 is_error <- inherits(cond, "error")
[17:36:39.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.307]                   NULL)
[17:36:39.307]                 if (is_error) {
[17:36:39.307]                   sessionInformation <- function() {
[17:36:39.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.307]                       search = base::search(), system = base::Sys.info())
[17:36:39.307]                   }
[17:36:39.307]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.307]                     cond$call), session = sessionInformation(), 
[17:36:39.307]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.307]                   signalCondition(cond)
[17:36:39.307]                 }
[17:36:39.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.307]                 "immediateCondition"))) {
[17:36:39.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.307]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.307]                   if (TRUE && !signal) {
[17:36:39.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.307]                     {
[17:36:39.307]                       inherits <- base::inherits
[17:36:39.307]                       invokeRestart <- base::invokeRestart
[17:36:39.307]                       is.null <- base::is.null
[17:36:39.307]                       muffled <- FALSE
[17:36:39.307]                       if (inherits(cond, "message")) {
[17:36:39.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.307]                         if (muffled) 
[17:36:39.307]                           invokeRestart("muffleMessage")
[17:36:39.307]                       }
[17:36:39.307]                       else if (inherits(cond, "warning")) {
[17:36:39.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.307]                         if (muffled) 
[17:36:39.307]                           invokeRestart("muffleWarning")
[17:36:39.307]                       }
[17:36:39.307]                       else if (inherits(cond, "condition")) {
[17:36:39.307]                         if (!is.null(pattern)) {
[17:36:39.307]                           computeRestarts <- base::computeRestarts
[17:36:39.307]                           grepl <- base::grepl
[17:36:39.307]                           restarts <- computeRestarts(cond)
[17:36:39.307]                           for (restart in restarts) {
[17:36:39.307]                             name <- restart$name
[17:36:39.307]                             if (is.null(name)) 
[17:36:39.307]                               next
[17:36:39.307]                             if (!grepl(pattern, name)) 
[17:36:39.307]                               next
[17:36:39.307]                             invokeRestart(restart)
[17:36:39.307]                             muffled <- TRUE
[17:36:39.307]                             break
[17:36:39.307]                           }
[17:36:39.307]                         }
[17:36:39.307]                       }
[17:36:39.307]                       invisible(muffled)
[17:36:39.307]                     }
[17:36:39.307]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.307]                   }
[17:36:39.307]                 }
[17:36:39.307]                 else {
[17:36:39.307]                   if (TRUE) {
[17:36:39.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.307]                     {
[17:36:39.307]                       inherits <- base::inherits
[17:36:39.307]                       invokeRestart <- base::invokeRestart
[17:36:39.307]                       is.null <- base::is.null
[17:36:39.307]                       muffled <- FALSE
[17:36:39.307]                       if (inherits(cond, "message")) {
[17:36:39.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.307]                         if (muffled) 
[17:36:39.307]                           invokeRestart("muffleMessage")
[17:36:39.307]                       }
[17:36:39.307]                       else if (inherits(cond, "warning")) {
[17:36:39.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.307]                         if (muffled) 
[17:36:39.307]                           invokeRestart("muffleWarning")
[17:36:39.307]                       }
[17:36:39.307]                       else if (inherits(cond, "condition")) {
[17:36:39.307]                         if (!is.null(pattern)) {
[17:36:39.307]                           computeRestarts <- base::computeRestarts
[17:36:39.307]                           grepl <- base::grepl
[17:36:39.307]                           restarts <- computeRestarts(cond)
[17:36:39.307]                           for (restart in restarts) {
[17:36:39.307]                             name <- restart$name
[17:36:39.307]                             if (is.null(name)) 
[17:36:39.307]                               next
[17:36:39.307]                             if (!grepl(pattern, name)) 
[17:36:39.307]                               next
[17:36:39.307]                             invokeRestart(restart)
[17:36:39.307]                             muffled <- TRUE
[17:36:39.307]                             break
[17:36:39.307]                           }
[17:36:39.307]                         }
[17:36:39.307]                       }
[17:36:39.307]                       invisible(muffled)
[17:36:39.307]                     }
[17:36:39.307]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.307]                   }
[17:36:39.307]                 }
[17:36:39.307]             }
[17:36:39.307]         }))
[17:36:39.307]     }, error = function(ex) {
[17:36:39.307]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.307]                 ...future.rng), started = ...future.startTime, 
[17:36:39.307]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.307]             version = "1.8"), class = "FutureResult")
[17:36:39.307]     }, finally = {
[17:36:39.307]         if (!identical(...future.workdir, getwd())) 
[17:36:39.307]             setwd(...future.workdir)
[17:36:39.307]         {
[17:36:39.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.307]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.307]             }
[17:36:39.307]             base::options(...future.oldOptions)
[17:36:39.307]             if (.Platform$OS.type == "windows") {
[17:36:39.307]                 old_names <- names(...future.oldEnvVars)
[17:36:39.307]                 envs <- base::Sys.getenv()
[17:36:39.307]                 names <- names(envs)
[17:36:39.307]                 common <- intersect(names, old_names)
[17:36:39.307]                 added <- setdiff(names, old_names)
[17:36:39.307]                 removed <- setdiff(old_names, names)
[17:36:39.307]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.307]                   envs[common]]
[17:36:39.307]                 NAMES <- toupper(changed)
[17:36:39.307]                 args <- list()
[17:36:39.307]                 for (kk in seq_along(NAMES)) {
[17:36:39.307]                   name <- changed[[kk]]
[17:36:39.307]                   NAME <- NAMES[[kk]]
[17:36:39.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.307]                     next
[17:36:39.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.307]                 }
[17:36:39.307]                 NAMES <- toupper(added)
[17:36:39.307]                 for (kk in seq_along(NAMES)) {
[17:36:39.307]                   name <- added[[kk]]
[17:36:39.307]                   NAME <- NAMES[[kk]]
[17:36:39.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.307]                     next
[17:36:39.307]                   args[[name]] <- ""
[17:36:39.307]                 }
[17:36:39.307]                 NAMES <- toupper(removed)
[17:36:39.307]                 for (kk in seq_along(NAMES)) {
[17:36:39.307]                   name <- removed[[kk]]
[17:36:39.307]                   NAME <- NAMES[[kk]]
[17:36:39.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.307]                     next
[17:36:39.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.307]                 }
[17:36:39.307]                 if (length(args) > 0) 
[17:36:39.307]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.307]             }
[17:36:39.307]             else {
[17:36:39.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.307]             }
[17:36:39.307]             {
[17:36:39.307]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.307]                   0L) {
[17:36:39.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.307]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.307]                   base::options(opts)
[17:36:39.307]                 }
[17:36:39.307]                 {
[17:36:39.307]                   {
[17:36:39.307]                     NULL
[17:36:39.307]                     RNGkind("Mersenne-Twister")
[17:36:39.307]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.307]                       inherits = FALSE)
[17:36:39.307]                   }
[17:36:39.307]                   options(future.plan = NULL)
[17:36:39.307]                   if (is.na(NA_character_)) 
[17:36:39.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.307]                     .init = FALSE)
[17:36:39.307]                 }
[17:36:39.307]             }
[17:36:39.307]         }
[17:36:39.307]     })
[17:36:39.307]     if (TRUE) {
[17:36:39.307]         base::sink(type = "output", split = FALSE)
[17:36:39.307]         if (TRUE) {
[17:36:39.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.307]         }
[17:36:39.307]         else {
[17:36:39.307]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.307]         }
[17:36:39.307]         base::close(...future.stdout)
[17:36:39.307]         ...future.stdout <- NULL
[17:36:39.307]     }
[17:36:39.307]     ...future.result$conditions <- ...future.conditions
[17:36:39.307]     ...future.result$finished <- base::Sys.time()
[17:36:39.307]     ...future.result
[17:36:39.307] }
[17:36:39.309] assign_globals() ...
[17:36:39.309] List of 5
[17:36:39.309]  $ ...future.FUN            :function (object, ...)  
[17:36:39.309]  $ future.call.arguments    :List of 1
[17:36:39.309]   ..$ digits: int 2
[17:36:39.309]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.309]  $ ...future.elements_ii    :List of 6
[17:36:39.309]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:36:39.309]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:36:39.309]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:36:39.309]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:36:39.309]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:36:39.309]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:36:39.309]  $ ...future.seeds_ii       : NULL
[17:36:39.309]  $ ...future.globals.maxSize: NULL
[17:36:39.309]  - attr(*, "where")=List of 5
[17:36:39.309]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.309]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.309]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.309]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.309]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.309]  - attr(*, "resolved")= logi FALSE
[17:36:39.309]  - attr(*, "total_size")= num 1296
[17:36:39.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.309]  - attr(*, "already-done")= logi TRUE
[17:36:39.315] - copied ‘...future.FUN’ to environment
[17:36:39.315] - copied ‘future.call.arguments’ to environment
[17:36:39.316] - copied ‘...future.elements_ii’ to environment
[17:36:39.316] - copied ‘...future.seeds_ii’ to environment
[17:36:39.316] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.316] assign_globals() ... done
[17:36:39.316] plan(): Setting new future strategy stack:
[17:36:39.316] List of future strategies:
[17:36:39.316] 1. sequential:
[17:36:39.316]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.316]    - tweaked: FALSE
[17:36:39.316]    - call: NULL
[17:36:39.317] plan(): nbrOfWorkers() = 1
[17:36:39.319] plan(): Setting new future strategy stack:
[17:36:39.319] List of future strategies:
[17:36:39.319] 1. sequential:
[17:36:39.319]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.319]    - tweaked: FALSE
[17:36:39.319]    - call: plan(strategy)
[17:36:39.320] plan(): nbrOfWorkers() = 1
[17:36:39.320] SequentialFuture started (and completed)
[17:36:39.320] - Launch lazy future ... done
[17:36:39.320] run() for ‘SequentialFuture’ ... done
[17:36:39.320] Created future:
[17:36:39.321] SequentialFuture:
[17:36:39.321] Label: ‘future_by-1’
[17:36:39.321] Expression:
[17:36:39.321] {
[17:36:39.321]     do.call(function(...) {
[17:36:39.321]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.321]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.321]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.321]             on.exit(options(oopts), add = TRUE)
[17:36:39.321]         }
[17:36:39.321]         {
[17:36:39.321]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.321]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.321]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.321]             })
[17:36:39.321]         }
[17:36:39.321]     }, args = future.call.arguments)
[17:36:39.321] }
[17:36:39.321] Lazy evaluation: FALSE
[17:36:39.321] Asynchronous evaluation: FALSE
[17:36:39.321] Local evaluation: TRUE
[17:36:39.321] Environment: R_GlobalEnv
[17:36:39.321] Capture standard output: TRUE
[17:36:39.321] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.321] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.321] Packages: <none>
[17:36:39.321] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.321] Resolved: TRUE
[17:36:39.321] Value: 5.48 KiB of class ‘list’
[17:36:39.321] Early signaling: FALSE
[17:36:39.321] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.321] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.322] Chunk #1 of 1 ... DONE
[17:36:39.322] Launching 1 futures (chunks) ... DONE
[17:36:39.322] Resolving 1 futures (chunks) ...
[17:36:39.322] resolve() on list ...
[17:36:39.322]  recursive: 0
[17:36:39.322]  length: 1
[17:36:39.322] 
[17:36:39.322] resolved() for ‘SequentialFuture’ ...
[17:36:39.322] - state: ‘finished’
[17:36:39.322] - run: TRUE
[17:36:39.322] - result: ‘FutureResult’
[17:36:39.323] resolved() for ‘SequentialFuture’ ... done
[17:36:39.323] Future #1
[17:36:39.323] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.323] - nx: 1
[17:36:39.323] - relay: TRUE
[17:36:39.323] - stdout: TRUE
[17:36:39.323] - signal: TRUE
[17:36:39.323] - resignal: FALSE
[17:36:39.323] - force: TRUE
[17:36:39.323] - relayed: [n=1] FALSE
[17:36:39.323] - queued futures: [n=1] FALSE
[17:36:39.324]  - until=1
[17:36:39.324]  - relaying element #1
[17:36:39.324] - relayed: [n=1] TRUE
[17:36:39.324] - queued futures: [n=1] TRUE
[17:36:39.324] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.324]  length: 0 (resolved future 1)
[17:36:39.324] Relaying remaining futures
[17:36:39.324] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.324] - nx: 1
[17:36:39.324] - relay: TRUE
[17:36:39.325] - stdout: TRUE
[17:36:39.325] - signal: TRUE
[17:36:39.325] - resignal: FALSE
[17:36:39.325] - force: TRUE
[17:36:39.325] - relayed: [n=1] TRUE
[17:36:39.325] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.325] - relayed: [n=1] TRUE
[17:36:39.325] - queued futures: [n=1] TRUE
[17:36:39.325] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.325] resolve() on list ... DONE
[17:36:39.326]  - Number of value chunks collected: 1
[17:36:39.326] Resolving 1 futures (chunks) ... DONE
[17:36:39.326] Reducing values from 1 chunks ...
[17:36:39.326]  - Number of values collected after concatenation: 6
[17:36:39.326]  - Number of values expected: 6
[17:36:39.326] Reducing values from 1 chunks ... DONE
[17:36:39.326] future_lapply() ... DONE
[17:36:39.326] future_by_internal() ... DONE
[17:36:39.329] future_by_internal() ...
[17:36:39.330] future_lapply() ...
[17:36:39.331] Number of chunks: 1
[17:36:39.331] getGlobalsAndPackagesXApply() ...
[17:36:39.331]  - future.globals: TRUE
[17:36:39.331] getGlobalsAndPackages() ...
[17:36:39.331] Searching for globals...
[17:36:39.332] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:39.333] Searching for globals ... DONE
[17:36:39.333] Resolving globals: FALSE
[17:36:39.333] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:36:39.333] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:36:39.334] - globals: [1] ‘FUN’
[17:36:39.334] - packages: [1] ‘stats’
[17:36:39.334] getGlobalsAndPackages() ... DONE
[17:36:39.334]  - globals found/used: [n=1] ‘FUN’
[17:36:39.334]  - needed namespaces: [n=1] ‘stats’
[17:36:39.334] Finding globals ... DONE
[17:36:39.334]  - use_args: TRUE
[17:36:39.334]  - Getting '...' globals ...
[17:36:39.334] resolve() on list ...
[17:36:39.335]  recursive: 0
[17:36:39.335]  length: 1
[17:36:39.335]  elements: ‘...’
[17:36:39.335]  length: 0 (resolved future 1)
[17:36:39.335] resolve() on list ... DONE
[17:36:39.335]    - '...' content: [n=1] ‘singular.ok’
[17:36:39.335] List of 1
[17:36:39.335]  $ ...:List of 1
[17:36:39.335]   ..$ singular.ok: logi FALSE
[17:36:39.335]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.335]  - attr(*, "where")=List of 1
[17:36:39.335]   ..$ ...:<environment: 0x5622fc0ea650> 
[17:36:39.335]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.335]  - attr(*, "resolved")= logi TRUE
[17:36:39.335]  - attr(*, "total_size")= num NA
[17:36:39.338]  - Getting '...' globals ... DONE
[17:36:39.338] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.338] List of 2
[17:36:39.338]  $ ...future.FUN:function (x, ...)  
[17:36:39.338]  $ ...          :List of 1
[17:36:39.338]   ..$ singular.ok: logi FALSE
[17:36:39.338]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.338]  - attr(*, "where")=List of 2
[17:36:39.338]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.338]   ..$ ...          :<environment: 0x5622fc0ea650> 
[17:36:39.338]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.338]  - attr(*, "resolved")= logi FALSE
[17:36:39.338]  - attr(*, "total_size")= num 5384
[17:36:39.342] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:39.343] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.343] Number of futures (= number of chunks): 1
[17:36:39.343] Launching 1 futures (chunks) ...
[17:36:39.343] Chunk #1 of 1 ...
[17:36:39.343]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.343] getGlobalsAndPackages() ...
[17:36:39.343] Searching for globals...
[17:36:39.344] 
[17:36:39.344] Searching for globals ... DONE
[17:36:39.344] - globals: [0] <none>
[17:36:39.344] getGlobalsAndPackages() ... DONE
[17:36:39.344]    + additional globals found: [n=0] 
[17:36:39.344]    + additional namespaces needed: [n=0] 
[17:36:39.344]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.344]  - seeds: <none>
[17:36:39.345]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.345] getGlobalsAndPackages() ...
[17:36:39.345] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.345] Resolving globals: FALSE
[17:36:39.345] Tweak future expression to call with '...' arguments ...
[17:36:39.345] {
[17:36:39.345]     do.call(function(...) {
[17:36:39.345]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.345]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.345]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.345]             on.exit(options(oopts), add = TRUE)
[17:36:39.345]         }
[17:36:39.345]         {
[17:36:39.345]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.345]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.345]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.345]             })
[17:36:39.345]         }
[17:36:39.345]     }, args = future.call.arguments)
[17:36:39.345] }
[17:36:39.345] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.346] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.346] 
[17:36:39.346] getGlobalsAndPackages() ... DONE
[17:36:39.346] run() for ‘Future’ ...
[17:36:39.346] - state: ‘created’
[17:36:39.346] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:39.347] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.347] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.347]   - Field: ‘label’
[17:36:39.347]   - Field: ‘local’
[17:36:39.347]   - Field: ‘owner’
[17:36:39.347]   - Field: ‘envir’
[17:36:39.347]   - Field: ‘packages’
[17:36:39.347]   - Field: ‘gc’
[17:36:39.347]   - Field: ‘conditions’
[17:36:39.347]   - Field: ‘expr’
[17:36:39.348]   - Field: ‘uuid’
[17:36:39.348]   - Field: ‘seed’
[17:36:39.348]   - Field: ‘version’
[17:36:39.348]   - Field: ‘result’
[17:36:39.348]   - Field: ‘asynchronous’
[17:36:39.348]   - Field: ‘calls’
[17:36:39.348]   - Field: ‘globals’
[17:36:39.348]   - Field: ‘stdout’
[17:36:39.348]   - Field: ‘earlySignal’
[17:36:39.348]   - Field: ‘lazy’
[17:36:39.348]   - Field: ‘state’
[17:36:39.349] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.349] - Launch lazy future ...
[17:36:39.349] Packages needed by the future expression (n = 1): ‘stats’
[17:36:39.349] Packages needed by future strategies (n = 0): <none>
[17:36:39.349] {
[17:36:39.349]     {
[17:36:39.349]         {
[17:36:39.349]             ...future.startTime <- base::Sys.time()
[17:36:39.349]             {
[17:36:39.349]                 {
[17:36:39.349]                   {
[17:36:39.349]                     {
[17:36:39.349]                       base::local({
[17:36:39.349]                         has_future <- base::requireNamespace("future", 
[17:36:39.349]                           quietly = TRUE)
[17:36:39.349]                         if (has_future) {
[17:36:39.349]                           ns <- base::getNamespace("future")
[17:36:39.349]                           version <- ns[[".package"]][["version"]]
[17:36:39.349]                           if (is.null(version)) 
[17:36:39.349]                             version <- utils::packageVersion("future")
[17:36:39.349]                         }
[17:36:39.349]                         else {
[17:36:39.349]                           version <- NULL
[17:36:39.349]                         }
[17:36:39.349]                         if (!has_future || version < "1.8.0") {
[17:36:39.349]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.349]                             "", base::R.version$version.string), 
[17:36:39.349]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:39.349]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.349]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.349]                               "release", "version")], collapse = " "), 
[17:36:39.349]                             hostname = base::Sys.info()[["nodename"]])
[17:36:39.349]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.349]                             info)
[17:36:39.349]                           info <- base::paste(info, collapse = "; ")
[17:36:39.349]                           if (!has_future) {
[17:36:39.349]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.349]                               info)
[17:36:39.349]                           }
[17:36:39.349]                           else {
[17:36:39.349]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.349]                               info, version)
[17:36:39.349]                           }
[17:36:39.349]                           base::stop(msg)
[17:36:39.349]                         }
[17:36:39.349]                       })
[17:36:39.349]                     }
[17:36:39.349]                     base::local({
[17:36:39.349]                       for (pkg in "stats") {
[17:36:39.349]                         base::loadNamespace(pkg)
[17:36:39.349]                         base::library(pkg, character.only = TRUE)
[17:36:39.349]                       }
[17:36:39.349]                     })
[17:36:39.349]                   }
[17:36:39.349]                   ...future.strategy.old <- future::plan("list")
[17:36:39.349]                   options(future.plan = NULL)
[17:36:39.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.349]                 }
[17:36:39.349]                 ...future.workdir <- getwd()
[17:36:39.349]             }
[17:36:39.349]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.349]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.349]         }
[17:36:39.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.349]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.349]             base::names(...future.oldOptions))
[17:36:39.349]     }
[17:36:39.349]     if (FALSE) {
[17:36:39.349]     }
[17:36:39.349]     else {
[17:36:39.349]         if (TRUE) {
[17:36:39.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.349]                 open = "w")
[17:36:39.349]         }
[17:36:39.349]         else {
[17:36:39.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.349]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.349]         }
[17:36:39.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.349]             base::sink(type = "output", split = FALSE)
[17:36:39.349]             base::close(...future.stdout)
[17:36:39.349]         }, add = TRUE)
[17:36:39.349]     }
[17:36:39.349]     ...future.frame <- base::sys.nframe()
[17:36:39.349]     ...future.conditions <- base::list()
[17:36:39.349]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.349]     if (FALSE) {
[17:36:39.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.349]     }
[17:36:39.349]     ...future.result <- base::tryCatch({
[17:36:39.349]         base::withCallingHandlers({
[17:36:39.349]             ...future.value <- base::withVisible(base::local({
[17:36:39.349]                 do.call(function(...) {
[17:36:39.349]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.349]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.349]                     ...future.globals.maxSize)) {
[17:36:39.349]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.349]                     on.exit(options(oopts), add = TRUE)
[17:36:39.349]                   }
[17:36:39.349]                   {
[17:36:39.349]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.349]                       FUN = function(jj) {
[17:36:39.349]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.349]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.349]                       })
[17:36:39.349]                   }
[17:36:39.349]                 }, args = future.call.arguments)
[17:36:39.349]             }))
[17:36:39.349]             future::FutureResult(value = ...future.value$value, 
[17:36:39.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.349]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.349]                     ...future.globalenv.names))
[17:36:39.349]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.349]         }, condition = base::local({
[17:36:39.349]             c <- base::c
[17:36:39.349]             inherits <- base::inherits
[17:36:39.349]             invokeRestart <- base::invokeRestart
[17:36:39.349]             length <- base::length
[17:36:39.349]             list <- base::list
[17:36:39.349]             seq.int <- base::seq.int
[17:36:39.349]             signalCondition <- base::signalCondition
[17:36:39.349]             sys.calls <- base::sys.calls
[17:36:39.349]             `[[` <- base::`[[`
[17:36:39.349]             `+` <- base::`+`
[17:36:39.349]             `<<-` <- base::`<<-`
[17:36:39.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.349]                   3L)]
[17:36:39.349]             }
[17:36:39.349]             function(cond) {
[17:36:39.349]                 is_error <- inherits(cond, "error")
[17:36:39.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.349]                   NULL)
[17:36:39.349]                 if (is_error) {
[17:36:39.349]                   sessionInformation <- function() {
[17:36:39.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.349]                       search = base::search(), system = base::Sys.info())
[17:36:39.349]                   }
[17:36:39.349]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.349]                     cond$call), session = sessionInformation(), 
[17:36:39.349]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.349]                   signalCondition(cond)
[17:36:39.349]                 }
[17:36:39.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.349]                 "immediateCondition"))) {
[17:36:39.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.349]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.349]                   if (TRUE && !signal) {
[17:36:39.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.349]                     {
[17:36:39.349]                       inherits <- base::inherits
[17:36:39.349]                       invokeRestart <- base::invokeRestart
[17:36:39.349]                       is.null <- base::is.null
[17:36:39.349]                       muffled <- FALSE
[17:36:39.349]                       if (inherits(cond, "message")) {
[17:36:39.349]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.349]                         if (muffled) 
[17:36:39.349]                           invokeRestart("muffleMessage")
[17:36:39.349]                       }
[17:36:39.349]                       else if (inherits(cond, "warning")) {
[17:36:39.349]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.349]                         if (muffled) 
[17:36:39.349]                           invokeRestart("muffleWarning")
[17:36:39.349]                       }
[17:36:39.349]                       else if (inherits(cond, "condition")) {
[17:36:39.349]                         if (!is.null(pattern)) {
[17:36:39.349]                           computeRestarts <- base::computeRestarts
[17:36:39.349]                           grepl <- base::grepl
[17:36:39.349]                           restarts <- computeRestarts(cond)
[17:36:39.349]                           for (restart in restarts) {
[17:36:39.349]                             name <- restart$name
[17:36:39.349]                             if (is.null(name)) 
[17:36:39.349]                               next
[17:36:39.349]                             if (!grepl(pattern, name)) 
[17:36:39.349]                               next
[17:36:39.349]                             invokeRestart(restart)
[17:36:39.349]                             muffled <- TRUE
[17:36:39.349]                             break
[17:36:39.349]                           }
[17:36:39.349]                         }
[17:36:39.349]                       }
[17:36:39.349]                       invisible(muffled)
[17:36:39.349]                     }
[17:36:39.349]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.349]                   }
[17:36:39.349]                 }
[17:36:39.349]                 else {
[17:36:39.349]                   if (TRUE) {
[17:36:39.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.349]                     {
[17:36:39.349]                       inherits <- base::inherits
[17:36:39.349]                       invokeRestart <- base::invokeRestart
[17:36:39.349]                       is.null <- base::is.null
[17:36:39.349]                       muffled <- FALSE
[17:36:39.349]                       if (inherits(cond, "message")) {
[17:36:39.349]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.349]                         if (muffled) 
[17:36:39.349]                           invokeRestart("muffleMessage")
[17:36:39.349]                       }
[17:36:39.349]                       else if (inherits(cond, "warning")) {
[17:36:39.349]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.349]                         if (muffled) 
[17:36:39.349]                           invokeRestart("muffleWarning")
[17:36:39.349]                       }
[17:36:39.349]                       else if (inherits(cond, "condition")) {
[17:36:39.349]                         if (!is.null(pattern)) {
[17:36:39.349]                           computeRestarts <- base::computeRestarts
[17:36:39.349]                           grepl <- base::grepl
[17:36:39.349]                           restarts <- computeRestarts(cond)
[17:36:39.349]                           for (restart in restarts) {
[17:36:39.349]                             name <- restart$name
[17:36:39.349]                             if (is.null(name)) 
[17:36:39.349]                               next
[17:36:39.349]                             if (!grepl(pattern, name)) 
[17:36:39.349]                               next
[17:36:39.349]                             invokeRestart(restart)
[17:36:39.349]                             muffled <- TRUE
[17:36:39.349]                             break
[17:36:39.349]                           }
[17:36:39.349]                         }
[17:36:39.349]                       }
[17:36:39.349]                       invisible(muffled)
[17:36:39.349]                     }
[17:36:39.349]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.349]                   }
[17:36:39.349]                 }
[17:36:39.349]             }
[17:36:39.349]         }))
[17:36:39.349]     }, error = function(ex) {
[17:36:39.349]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.349]                 ...future.rng), started = ...future.startTime, 
[17:36:39.349]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.349]             version = "1.8"), class = "FutureResult")
[17:36:39.349]     }, finally = {
[17:36:39.349]         if (!identical(...future.workdir, getwd())) 
[17:36:39.349]             setwd(...future.workdir)
[17:36:39.349]         {
[17:36:39.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.349]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.349]             }
[17:36:39.349]             base::options(...future.oldOptions)
[17:36:39.349]             if (.Platform$OS.type == "windows") {
[17:36:39.349]                 old_names <- names(...future.oldEnvVars)
[17:36:39.349]                 envs <- base::Sys.getenv()
[17:36:39.349]                 names <- names(envs)
[17:36:39.349]                 common <- intersect(names, old_names)
[17:36:39.349]                 added <- setdiff(names, old_names)
[17:36:39.349]                 removed <- setdiff(old_names, names)
[17:36:39.349]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.349]                   envs[common]]
[17:36:39.349]                 NAMES <- toupper(changed)
[17:36:39.349]                 args <- list()
[17:36:39.349]                 for (kk in seq_along(NAMES)) {
[17:36:39.349]                   name <- changed[[kk]]
[17:36:39.349]                   NAME <- NAMES[[kk]]
[17:36:39.349]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.349]                     next
[17:36:39.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.349]                 }
[17:36:39.349]                 NAMES <- toupper(added)
[17:36:39.349]                 for (kk in seq_along(NAMES)) {
[17:36:39.349]                   name <- added[[kk]]
[17:36:39.349]                   NAME <- NAMES[[kk]]
[17:36:39.349]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.349]                     next
[17:36:39.349]                   args[[name]] <- ""
[17:36:39.349]                 }
[17:36:39.349]                 NAMES <- toupper(removed)
[17:36:39.349]                 for (kk in seq_along(NAMES)) {
[17:36:39.349]                   name <- removed[[kk]]
[17:36:39.349]                   NAME <- NAMES[[kk]]
[17:36:39.349]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.349]                     next
[17:36:39.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.349]                 }
[17:36:39.349]                 if (length(args) > 0) 
[17:36:39.349]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.349]             }
[17:36:39.349]             else {
[17:36:39.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.349]             }
[17:36:39.349]             {
[17:36:39.349]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.349]                   0L) {
[17:36:39.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.349]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.349]                   base::options(opts)
[17:36:39.349]                 }
[17:36:39.349]                 {
[17:36:39.349]                   {
[17:36:39.349]                     NULL
[17:36:39.349]                     RNGkind("Mersenne-Twister")
[17:36:39.349]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.349]                       inherits = FALSE)
[17:36:39.349]                   }
[17:36:39.349]                   options(future.plan = NULL)
[17:36:39.349]                   if (is.na(NA_character_)) 
[17:36:39.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.349]                     .init = FALSE)
[17:36:39.349]                 }
[17:36:39.349]             }
[17:36:39.349]         }
[17:36:39.349]     })
[17:36:39.349]     if (TRUE) {
[17:36:39.349]         base::sink(type = "output", split = FALSE)
[17:36:39.349]         if (TRUE) {
[17:36:39.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.349]         }
[17:36:39.349]         else {
[17:36:39.349]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.349]         }
[17:36:39.349]         base::close(...future.stdout)
[17:36:39.349]         ...future.stdout <- NULL
[17:36:39.349]     }
[17:36:39.349]     ...future.result$conditions <- ...future.conditions
[17:36:39.349]     ...future.result$finished <- base::Sys.time()
[17:36:39.349]     ...future.result
[17:36:39.349] }
[17:36:39.351] assign_globals() ...
[17:36:39.351] List of 5
[17:36:39.351]  $ ...future.FUN            :function (x, ...)  
[17:36:39.351]  $ future.call.arguments    :List of 1
[17:36:39.351]   ..$ singular.ok: logi FALSE
[17:36:39.351]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.351]  $ ...future.elements_ii    :List of 3
[17:36:39.351]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.351]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:39.351]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.351]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.351]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.351]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:39.351]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.351]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:39.351]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.351]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:39.351]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.351]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:39.351]  $ ...future.seeds_ii       : NULL
[17:36:39.351]  $ ...future.globals.maxSize: NULL
[17:36:39.351]  - attr(*, "where")=List of 5
[17:36:39.351]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.351]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.351]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.351]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.351]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.351]  - attr(*, "resolved")= logi FALSE
[17:36:39.351]  - attr(*, "total_size")= num 5384
[17:36:39.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.351]  - attr(*, "already-done")= logi TRUE
[17:36:39.360] - reassign environment for ‘...future.FUN’
[17:36:39.360] - copied ‘...future.FUN’ to environment
[17:36:39.360] - copied ‘future.call.arguments’ to environment
[17:36:39.360] - copied ‘...future.elements_ii’ to environment
[17:36:39.360] - copied ‘...future.seeds_ii’ to environment
[17:36:39.360] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.360] assign_globals() ... done
[17:36:39.361] plan(): Setting new future strategy stack:
[17:36:39.361] List of future strategies:
[17:36:39.361] 1. sequential:
[17:36:39.361]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.361]    - tweaked: FALSE
[17:36:39.361]    - call: NULL
[17:36:39.361] plan(): nbrOfWorkers() = 1
[17:36:39.365] plan(): Setting new future strategy stack:
[17:36:39.365] List of future strategies:
[17:36:39.365] 1. sequential:
[17:36:39.365]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.365]    - tweaked: FALSE
[17:36:39.365]    - call: plan(strategy)
[17:36:39.366] plan(): nbrOfWorkers() = 1
[17:36:39.366] SequentialFuture started (and completed)
[17:36:39.366] - Launch lazy future ... done
[17:36:39.366] run() for ‘SequentialFuture’ ... done
[17:36:39.366] Created future:
[17:36:39.366] SequentialFuture:
[17:36:39.366] Label: ‘future_by-1’
[17:36:39.366] Expression:
[17:36:39.366] {
[17:36:39.366]     do.call(function(...) {
[17:36:39.366]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.366]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.366]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.366]             on.exit(options(oopts), add = TRUE)
[17:36:39.366]         }
[17:36:39.366]         {
[17:36:39.366]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.366]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.366]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.366]             })
[17:36:39.366]         }
[17:36:39.366]     }, args = future.call.arguments)
[17:36:39.366] }
[17:36:39.366] Lazy evaluation: FALSE
[17:36:39.366] Asynchronous evaluation: FALSE
[17:36:39.366] Local evaluation: TRUE
[17:36:39.366] Environment: R_GlobalEnv
[17:36:39.366] Capture standard output: TRUE
[17:36:39.366] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.366] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.366] Packages: 1 packages (‘stats’)
[17:36:39.366] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.366] Resolved: TRUE
[17:36:39.366] Value: 26.06 KiB of class ‘list’
[17:36:39.366] Early signaling: FALSE
[17:36:39.366] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.366] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.368] Chunk #1 of 1 ... DONE
[17:36:39.368] Launching 1 futures (chunks) ... DONE
[17:36:39.368] Resolving 1 futures (chunks) ...
[17:36:39.368] resolve() on list ...
[17:36:39.368]  recursive: 0
[17:36:39.368]  length: 1
[17:36:39.369] 
[17:36:39.369] resolved() for ‘SequentialFuture’ ...
[17:36:39.369] - state: ‘finished’
[17:36:39.369] - run: TRUE
[17:36:39.369] - result: ‘FutureResult’
[17:36:39.369] resolved() for ‘SequentialFuture’ ... done
[17:36:39.369] Future #1
[17:36:39.369] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.369] - nx: 1
[17:36:39.369] - relay: TRUE
[17:36:39.370] - stdout: TRUE
[17:36:39.370] - signal: TRUE
[17:36:39.370] - resignal: FALSE
[17:36:39.370] - force: TRUE
[17:36:39.370] - relayed: [n=1] FALSE
[17:36:39.370] - queued futures: [n=1] FALSE
[17:36:39.370]  - until=1
[17:36:39.370]  - relaying element #1
[17:36:39.370] - relayed: [n=1] TRUE
[17:36:39.370] - queued futures: [n=1] TRUE
[17:36:39.370] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.371]  length: 0 (resolved future 1)
[17:36:39.371] Relaying remaining futures
[17:36:39.371] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.371] - nx: 1
[17:36:39.371] - relay: TRUE
[17:36:39.371] - stdout: TRUE
[17:36:39.371] - signal: TRUE
[17:36:39.371] - resignal: FALSE
[17:36:39.371] - force: TRUE
[17:36:39.371] - relayed: [n=1] TRUE
[17:36:39.371] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.372] - relayed: [n=1] TRUE
[17:36:39.372] - queued futures: [n=1] TRUE
[17:36:39.372] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.372] resolve() on list ... DONE
[17:36:39.372]  - Number of value chunks collected: 1
[17:36:39.372] Resolving 1 futures (chunks) ... DONE
[17:36:39.372] Reducing values from 1 chunks ...
[17:36:39.372]  - Number of values collected after concatenation: 3
[17:36:39.372]  - Number of values expected: 3
[17:36:39.372] Reducing values from 1 chunks ... DONE
[17:36:39.372] future_lapply() ... DONE
[17:36:39.373] future_by_internal() ... DONE
[17:36:39.376] future_by_internal() ...
[17:36:39.377] future_lapply() ...
[17:36:39.378] Number of chunks: 1
[17:36:39.378] getGlobalsAndPackagesXApply() ...
[17:36:39.378]  - future.globals: TRUE
[17:36:39.378] getGlobalsAndPackages() ...
[17:36:39.378] Searching for globals...
[17:36:39.380] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:39.380] Searching for globals ... DONE
[17:36:39.380] Resolving globals: FALSE
[17:36:39.380] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:36:39.381] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:36:39.381] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:39.381] - packages: [1] ‘stats’
[17:36:39.381] getGlobalsAndPackages() ... DONE
[17:36:39.381]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:39.381]  - needed namespaces: [n=1] ‘stats’
[17:36:39.381] Finding globals ... DONE
[17:36:39.382]  - use_args: TRUE
[17:36:39.382]  - Getting '...' globals ...
[17:36:39.383] resolve() on list ...
[17:36:39.383]  recursive: 0
[17:36:39.383]  length: 1
[17:36:39.383]  elements: ‘...’
[17:36:39.384]  length: 0 (resolved future 1)
[17:36:39.384] resolve() on list ... DONE
[17:36:39.384]    - '...' content: [n=0] 
[17:36:39.384] List of 1
[17:36:39.384]  $ ...: list()
[17:36:39.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.384]  - attr(*, "where")=List of 1
[17:36:39.384]   ..$ ...:<environment: 0x5622fc3a99d8> 
[17:36:39.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.384]  - attr(*, "resolved")= logi TRUE
[17:36:39.384]  - attr(*, "total_size")= num NA
[17:36:39.386]  - Getting '...' globals ... DONE
[17:36:39.387] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:36:39.387] List of 4
[17:36:39.387]  $ ...future.FUN:function (x)  
[17:36:39.387]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:39.387]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.387]  $ ...          : list()
[17:36:39.387]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.387]  - attr(*, "where")=List of 4
[17:36:39.387]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.387]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:36:39.387]   ..$ wool         :<environment: R_EmptyEnv> 
[17:36:39.387]   ..$ ...          :<environment: 0x5622fc3a99d8> 
[17:36:39.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.387]  - attr(*, "resolved")= logi FALSE
[17:36:39.387]  - attr(*, "total_size")= num 2320
[17:36:39.390] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:39.390] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.391] Number of futures (= number of chunks): 1
[17:36:39.391] Launching 1 futures (chunks) ...
[17:36:39.391] Chunk #1 of 1 ...
[17:36:39.391]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.391] getGlobalsAndPackages() ...
[17:36:39.391] Searching for globals...
[17:36:39.391] 
[17:36:39.392] Searching for globals ... DONE
[17:36:39.392] - globals: [0] <none>
[17:36:39.392] getGlobalsAndPackages() ... DONE
[17:36:39.392]    + additional globals found: [n=0] 
[17:36:39.392]    + additional namespaces needed: [n=0] 
[17:36:39.392]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.392]  - seeds: <none>
[17:36:39.392]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.392] getGlobalsAndPackages() ...
[17:36:39.392] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.393] Resolving globals: FALSE
[17:36:39.393] Tweak future expression to call with '...' arguments ...
[17:36:39.393] {
[17:36:39.393]     do.call(function(...) {
[17:36:39.393]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.393]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.393]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.393]             on.exit(options(oopts), add = TRUE)
[17:36:39.393]         }
[17:36:39.393]         {
[17:36:39.393]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.393]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.393]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.393]             })
[17:36:39.393]         }
[17:36:39.393]     }, args = future.call.arguments)
[17:36:39.393] }
[17:36:39.393] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.393] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.394] 
[17:36:39.394] getGlobalsAndPackages() ... DONE
[17:36:39.394] run() for ‘Future’ ...
[17:36:39.394] - state: ‘created’
[17:36:39.394] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:39.394] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.395] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.395]   - Field: ‘label’
[17:36:39.395]   - Field: ‘local’
[17:36:39.395]   - Field: ‘owner’
[17:36:39.395]   - Field: ‘envir’
[17:36:39.395]   - Field: ‘packages’
[17:36:39.395]   - Field: ‘gc’
[17:36:39.395]   - Field: ‘conditions’
[17:36:39.395]   - Field: ‘expr’
[17:36:39.395]   - Field: ‘uuid’
[17:36:39.395]   - Field: ‘seed’
[17:36:39.396]   - Field: ‘version’
[17:36:39.396]   - Field: ‘result’
[17:36:39.396]   - Field: ‘asynchronous’
[17:36:39.396]   - Field: ‘calls’
[17:36:39.396]   - Field: ‘globals’
[17:36:39.396]   - Field: ‘stdout’
[17:36:39.396]   - Field: ‘earlySignal’
[17:36:39.396]   - Field: ‘lazy’
[17:36:39.396]   - Field: ‘state’
[17:36:39.396] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.396] - Launch lazy future ...
[17:36:39.397] Packages needed by the future expression (n = 1): ‘stats’
[17:36:39.397] Packages needed by future strategies (n = 0): <none>
[17:36:39.397] {
[17:36:39.397]     {
[17:36:39.397]         {
[17:36:39.397]             ...future.startTime <- base::Sys.time()
[17:36:39.397]             {
[17:36:39.397]                 {
[17:36:39.397]                   {
[17:36:39.397]                     {
[17:36:39.397]                       base::local({
[17:36:39.397]                         has_future <- base::requireNamespace("future", 
[17:36:39.397]                           quietly = TRUE)
[17:36:39.397]                         if (has_future) {
[17:36:39.397]                           ns <- base::getNamespace("future")
[17:36:39.397]                           version <- ns[[".package"]][["version"]]
[17:36:39.397]                           if (is.null(version)) 
[17:36:39.397]                             version <- utils::packageVersion("future")
[17:36:39.397]                         }
[17:36:39.397]                         else {
[17:36:39.397]                           version <- NULL
[17:36:39.397]                         }
[17:36:39.397]                         if (!has_future || version < "1.8.0") {
[17:36:39.397]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.397]                             "", base::R.version$version.string), 
[17:36:39.397]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:39.397]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.397]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.397]                               "release", "version")], collapse = " "), 
[17:36:39.397]                             hostname = base::Sys.info()[["nodename"]])
[17:36:39.397]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.397]                             info)
[17:36:39.397]                           info <- base::paste(info, collapse = "; ")
[17:36:39.397]                           if (!has_future) {
[17:36:39.397]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.397]                               info)
[17:36:39.397]                           }
[17:36:39.397]                           else {
[17:36:39.397]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.397]                               info, version)
[17:36:39.397]                           }
[17:36:39.397]                           base::stop(msg)
[17:36:39.397]                         }
[17:36:39.397]                       })
[17:36:39.397]                     }
[17:36:39.397]                     base::local({
[17:36:39.397]                       for (pkg in "stats") {
[17:36:39.397]                         base::loadNamespace(pkg)
[17:36:39.397]                         base::library(pkg, character.only = TRUE)
[17:36:39.397]                       }
[17:36:39.397]                     })
[17:36:39.397]                   }
[17:36:39.397]                   ...future.strategy.old <- future::plan("list")
[17:36:39.397]                   options(future.plan = NULL)
[17:36:39.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.397]                 }
[17:36:39.397]                 ...future.workdir <- getwd()
[17:36:39.397]             }
[17:36:39.397]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.397]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.397]         }
[17:36:39.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.397]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.397]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.397]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.397]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.397]             base::names(...future.oldOptions))
[17:36:39.397]     }
[17:36:39.397]     if (FALSE) {
[17:36:39.397]     }
[17:36:39.397]     else {
[17:36:39.397]         if (TRUE) {
[17:36:39.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.397]                 open = "w")
[17:36:39.397]         }
[17:36:39.397]         else {
[17:36:39.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.397]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.397]         }
[17:36:39.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.397]             base::sink(type = "output", split = FALSE)
[17:36:39.397]             base::close(...future.stdout)
[17:36:39.397]         }, add = TRUE)
[17:36:39.397]     }
[17:36:39.397]     ...future.frame <- base::sys.nframe()
[17:36:39.397]     ...future.conditions <- base::list()
[17:36:39.397]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.397]     if (FALSE) {
[17:36:39.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.397]     }
[17:36:39.397]     ...future.result <- base::tryCatch({
[17:36:39.397]         base::withCallingHandlers({
[17:36:39.397]             ...future.value <- base::withVisible(base::local({
[17:36:39.397]                 do.call(function(...) {
[17:36:39.397]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.397]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.397]                     ...future.globals.maxSize)) {
[17:36:39.397]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.397]                     on.exit(options(oopts), add = TRUE)
[17:36:39.397]                   }
[17:36:39.397]                   {
[17:36:39.397]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.397]                       FUN = function(jj) {
[17:36:39.397]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.397]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.397]                       })
[17:36:39.397]                   }
[17:36:39.397]                 }, args = future.call.arguments)
[17:36:39.397]             }))
[17:36:39.397]             future::FutureResult(value = ...future.value$value, 
[17:36:39.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.397]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.397]                     ...future.globalenv.names))
[17:36:39.397]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.397]         }, condition = base::local({
[17:36:39.397]             c <- base::c
[17:36:39.397]             inherits <- base::inherits
[17:36:39.397]             invokeRestart <- base::invokeRestart
[17:36:39.397]             length <- base::length
[17:36:39.397]             list <- base::list
[17:36:39.397]             seq.int <- base::seq.int
[17:36:39.397]             signalCondition <- base::signalCondition
[17:36:39.397]             sys.calls <- base::sys.calls
[17:36:39.397]             `[[` <- base::`[[`
[17:36:39.397]             `+` <- base::`+`
[17:36:39.397]             `<<-` <- base::`<<-`
[17:36:39.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.397]                   3L)]
[17:36:39.397]             }
[17:36:39.397]             function(cond) {
[17:36:39.397]                 is_error <- inherits(cond, "error")
[17:36:39.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.397]                   NULL)
[17:36:39.397]                 if (is_error) {
[17:36:39.397]                   sessionInformation <- function() {
[17:36:39.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.397]                       search = base::search(), system = base::Sys.info())
[17:36:39.397]                   }
[17:36:39.397]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.397]                     cond$call), session = sessionInformation(), 
[17:36:39.397]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.397]                   signalCondition(cond)
[17:36:39.397]                 }
[17:36:39.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.397]                 "immediateCondition"))) {
[17:36:39.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.397]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.397]                   if (TRUE && !signal) {
[17:36:39.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.397]                     {
[17:36:39.397]                       inherits <- base::inherits
[17:36:39.397]                       invokeRestart <- base::invokeRestart
[17:36:39.397]                       is.null <- base::is.null
[17:36:39.397]                       muffled <- FALSE
[17:36:39.397]                       if (inherits(cond, "message")) {
[17:36:39.397]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.397]                         if (muffled) 
[17:36:39.397]                           invokeRestart("muffleMessage")
[17:36:39.397]                       }
[17:36:39.397]                       else if (inherits(cond, "warning")) {
[17:36:39.397]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.397]                         if (muffled) 
[17:36:39.397]                           invokeRestart("muffleWarning")
[17:36:39.397]                       }
[17:36:39.397]                       else if (inherits(cond, "condition")) {
[17:36:39.397]                         if (!is.null(pattern)) {
[17:36:39.397]                           computeRestarts <- base::computeRestarts
[17:36:39.397]                           grepl <- base::grepl
[17:36:39.397]                           restarts <- computeRestarts(cond)
[17:36:39.397]                           for (restart in restarts) {
[17:36:39.397]                             name <- restart$name
[17:36:39.397]                             if (is.null(name)) 
[17:36:39.397]                               next
[17:36:39.397]                             if (!grepl(pattern, name)) 
[17:36:39.397]                               next
[17:36:39.397]                             invokeRestart(restart)
[17:36:39.397]                             muffled <- TRUE
[17:36:39.397]                             break
[17:36:39.397]                           }
[17:36:39.397]                         }
[17:36:39.397]                       }
[17:36:39.397]                       invisible(muffled)
[17:36:39.397]                     }
[17:36:39.397]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.397]                   }
[17:36:39.397]                 }
[17:36:39.397]                 else {
[17:36:39.397]                   if (TRUE) {
[17:36:39.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.397]                     {
[17:36:39.397]                       inherits <- base::inherits
[17:36:39.397]                       invokeRestart <- base::invokeRestart
[17:36:39.397]                       is.null <- base::is.null
[17:36:39.397]                       muffled <- FALSE
[17:36:39.397]                       if (inherits(cond, "message")) {
[17:36:39.397]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.397]                         if (muffled) 
[17:36:39.397]                           invokeRestart("muffleMessage")
[17:36:39.397]                       }
[17:36:39.397]                       else if (inherits(cond, "warning")) {
[17:36:39.397]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.397]                         if (muffled) 
[17:36:39.397]                           invokeRestart("muffleWarning")
[17:36:39.397]                       }
[17:36:39.397]                       else if (inherits(cond, "condition")) {
[17:36:39.397]                         if (!is.null(pattern)) {
[17:36:39.397]                           computeRestarts <- base::computeRestarts
[17:36:39.397]                           grepl <- base::grepl
[17:36:39.397]                           restarts <- computeRestarts(cond)
[17:36:39.397]                           for (restart in restarts) {
[17:36:39.397]                             name <- restart$name
[17:36:39.397]                             if (is.null(name)) 
[17:36:39.397]                               next
[17:36:39.397]                             if (!grepl(pattern, name)) 
[17:36:39.397]                               next
[17:36:39.397]                             invokeRestart(restart)
[17:36:39.397]                             muffled <- TRUE
[17:36:39.397]                             break
[17:36:39.397]                           }
[17:36:39.397]                         }
[17:36:39.397]                       }
[17:36:39.397]                       invisible(muffled)
[17:36:39.397]                     }
[17:36:39.397]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.397]                   }
[17:36:39.397]                 }
[17:36:39.397]             }
[17:36:39.397]         }))
[17:36:39.397]     }, error = function(ex) {
[17:36:39.397]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.397]                 ...future.rng), started = ...future.startTime, 
[17:36:39.397]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.397]             version = "1.8"), class = "FutureResult")
[17:36:39.397]     }, finally = {
[17:36:39.397]         if (!identical(...future.workdir, getwd())) 
[17:36:39.397]             setwd(...future.workdir)
[17:36:39.397]         {
[17:36:39.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.397]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.397]             }
[17:36:39.397]             base::options(...future.oldOptions)
[17:36:39.397]             if (.Platform$OS.type == "windows") {
[17:36:39.397]                 old_names <- names(...future.oldEnvVars)
[17:36:39.397]                 envs <- base::Sys.getenv()
[17:36:39.397]                 names <- names(envs)
[17:36:39.397]                 common <- intersect(names, old_names)
[17:36:39.397]                 added <- setdiff(names, old_names)
[17:36:39.397]                 removed <- setdiff(old_names, names)
[17:36:39.397]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.397]                   envs[common]]
[17:36:39.397]                 NAMES <- toupper(changed)
[17:36:39.397]                 args <- list()
[17:36:39.397]                 for (kk in seq_along(NAMES)) {
[17:36:39.397]                   name <- changed[[kk]]
[17:36:39.397]                   NAME <- NAMES[[kk]]
[17:36:39.397]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.397]                     next
[17:36:39.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.397]                 }
[17:36:39.397]                 NAMES <- toupper(added)
[17:36:39.397]                 for (kk in seq_along(NAMES)) {
[17:36:39.397]                   name <- added[[kk]]
[17:36:39.397]                   NAME <- NAMES[[kk]]
[17:36:39.397]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.397]                     next
[17:36:39.397]                   args[[name]] <- ""
[17:36:39.397]                 }
[17:36:39.397]                 NAMES <- toupper(removed)
[17:36:39.397]                 for (kk in seq_along(NAMES)) {
[17:36:39.397]                   name <- removed[[kk]]
[17:36:39.397]                   NAME <- NAMES[[kk]]
[17:36:39.397]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.397]                     next
[17:36:39.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.397]                 }
[17:36:39.397]                 if (length(args) > 0) 
[17:36:39.397]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.397]             }
[17:36:39.397]             else {
[17:36:39.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.397]             }
[17:36:39.397]             {
[17:36:39.397]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.397]                   0L) {
[17:36:39.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.397]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.397]                   base::options(opts)
[17:36:39.397]                 }
[17:36:39.397]                 {
[17:36:39.397]                   {
[17:36:39.397]                     NULL
[17:36:39.397]                     RNGkind("Mersenne-Twister")
[17:36:39.397]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.397]                       inherits = FALSE)
[17:36:39.397]                   }
[17:36:39.397]                   options(future.plan = NULL)
[17:36:39.397]                   if (is.na(NA_character_)) 
[17:36:39.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.397]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.397]                     .init = FALSE)
[17:36:39.397]                 }
[17:36:39.397]             }
[17:36:39.397]         }
[17:36:39.397]     })
[17:36:39.397]     if (TRUE) {
[17:36:39.397]         base::sink(type = "output", split = FALSE)
[17:36:39.397]         if (TRUE) {
[17:36:39.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.397]         }
[17:36:39.397]         else {
[17:36:39.397]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.397]         }
[17:36:39.397]         base::close(...future.stdout)
[17:36:39.397]         ...future.stdout <- NULL
[17:36:39.397]     }
[17:36:39.397]     ...future.result$conditions <- ...future.conditions
[17:36:39.397]     ...future.result$finished <- base::Sys.time()
[17:36:39.397]     ...future.result
[17:36:39.397] }
[17:36:39.399] assign_globals() ...
[17:36:39.399] List of 7
[17:36:39.399]  $ ...future.FUN            :function (x)  
[17:36:39.399]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:39.399]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.399]  $ future.call.arguments    : list()
[17:36:39.399]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.399]  $ ...future.elements_ii    :List of 3
[17:36:39.399]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.399]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:39.399]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.399]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.399]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.399]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:39.399]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.399]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:39.399]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.399]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:39.399]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.399]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:39.399]  $ ...future.seeds_ii       : NULL
[17:36:39.399]  $ ...future.globals.maxSize: NULL
[17:36:39.399]  - attr(*, "where")=List of 7
[17:36:39.399]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.399]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:36:39.399]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:36:39.399]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.399]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.399]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.399]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.399]  - attr(*, "resolved")= logi FALSE
[17:36:39.399]  - attr(*, "total_size")= num 2320
[17:36:39.399]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.399]  - attr(*, "already-done")= logi TRUE
[17:36:39.410] - reassign environment for ‘...future.FUN’
[17:36:39.410] - copied ‘...future.FUN’ to environment
[17:36:39.410] - copied ‘breaks’ to environment
[17:36:39.410] - copied ‘wool’ to environment
[17:36:39.410] - copied ‘future.call.arguments’ to environment
[17:36:39.410] - copied ‘...future.elements_ii’ to environment
[17:36:39.411] - copied ‘...future.seeds_ii’ to environment
[17:36:39.411] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.411] assign_globals() ... done
[17:36:39.411] plan(): Setting new future strategy stack:
[17:36:39.411] List of future strategies:
[17:36:39.411] 1. sequential:
[17:36:39.411]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.411]    - tweaked: FALSE
[17:36:39.411]    - call: NULL
[17:36:39.412] plan(): nbrOfWorkers() = 1
[17:36:39.414] plan(): Setting new future strategy stack:
[17:36:39.414] List of future strategies:
[17:36:39.414] 1. sequential:
[17:36:39.414]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.414]    - tweaked: FALSE
[17:36:39.414]    - call: plan(strategy)
[17:36:39.415] plan(): nbrOfWorkers() = 1
[17:36:39.415] SequentialFuture started (and completed)
[17:36:39.415] - Launch lazy future ... done
[17:36:39.415] run() for ‘SequentialFuture’ ... done
[17:36:39.415] Created future:
[17:36:39.416] SequentialFuture:
[17:36:39.416] Label: ‘future_by-1’
[17:36:39.416] Expression:
[17:36:39.416] {
[17:36:39.416]     do.call(function(...) {
[17:36:39.416]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.416]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.416]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.416]             on.exit(options(oopts), add = TRUE)
[17:36:39.416]         }
[17:36:39.416]         {
[17:36:39.416]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.416]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.416]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.416]             })
[17:36:39.416]         }
[17:36:39.416]     }, args = future.call.arguments)
[17:36:39.416] }
[17:36:39.416] Lazy evaluation: FALSE
[17:36:39.416] Asynchronous evaluation: FALSE
[17:36:39.416] Local evaluation: TRUE
[17:36:39.416] Environment: 0x5622fc365c50
[17:36:39.416] Capture standard output: TRUE
[17:36:39.416] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.416] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:36:39.416] Packages: 1 packages (‘stats’)
[17:36:39.416] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.416] Resolved: TRUE
[17:36:39.416] Value: 25.57 KiB of class ‘list’
[17:36:39.416] Early signaling: FALSE
[17:36:39.416] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.416] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.417] Chunk #1 of 1 ... DONE
[17:36:39.417] Launching 1 futures (chunks) ... DONE
[17:36:39.417] Resolving 1 futures (chunks) ...
[17:36:39.417] resolve() on list ...
[17:36:39.417]  recursive: 0
[17:36:39.418]  length: 1
[17:36:39.418] 
[17:36:39.418] resolved() for ‘SequentialFuture’ ...
[17:36:39.418] - state: ‘finished’
[17:36:39.418] - run: TRUE
[17:36:39.418] - result: ‘FutureResult’
[17:36:39.418] resolved() for ‘SequentialFuture’ ... done
[17:36:39.418] Future #1
[17:36:39.418] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.418] - nx: 1
[17:36:39.419] - relay: TRUE
[17:36:39.419] - stdout: TRUE
[17:36:39.419] - signal: TRUE
[17:36:39.419] - resignal: FALSE
[17:36:39.419] - force: TRUE
[17:36:39.419] - relayed: [n=1] FALSE
[17:36:39.419] - queued futures: [n=1] FALSE
[17:36:39.419]  - until=1
[17:36:39.419]  - relaying element #1
[17:36:39.419] - relayed: [n=1] TRUE
[17:36:39.419] - queued futures: [n=1] TRUE
[17:36:39.420] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.420]  length: 0 (resolved future 1)
[17:36:39.420] Relaying remaining futures
[17:36:39.420] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.420] - nx: 1
[17:36:39.420] - relay: TRUE
[17:36:39.420] - stdout: TRUE
[17:36:39.420] - signal: TRUE
[17:36:39.420] - resignal: FALSE
[17:36:39.420] - force: TRUE
[17:36:39.420] - relayed: [n=1] TRUE
[17:36:39.421] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.421] - relayed: [n=1] TRUE
[17:36:39.421] - queued futures: [n=1] TRUE
[17:36:39.421] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.421] resolve() on list ... DONE
[17:36:39.421]  - Number of value chunks collected: 1
[17:36:39.421] Resolving 1 futures (chunks) ... DONE
[17:36:39.421] Reducing values from 1 chunks ...
[17:36:39.421]  - Number of values collected after concatenation: 3
[17:36:39.421]  - Number of values expected: 3
[17:36:39.421] Reducing values from 1 chunks ... DONE
[17:36:39.422] future_lapply() ... DONE
[17:36:39.422] future_by_internal() ... DONE
[17:36:39.422] future_by_internal() ...
[17:36:39.422] future_lapply() ...
[17:36:39.423] Number of chunks: 1
[17:36:39.423] getGlobalsAndPackagesXApply() ...
[17:36:39.423]  - future.globals: TRUE
[17:36:39.423] getGlobalsAndPackages() ...
[17:36:39.423] Searching for globals...
[17:36:39.424] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:39.424] Searching for globals ... DONE
[17:36:39.424] Resolving globals: FALSE
[17:36:39.425] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:39.425] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:39.425] - globals: [1] ‘FUN’
[17:36:39.425] 
[17:36:39.427] getGlobalsAndPackages() ... DONE
[17:36:39.427]  - globals found/used: [n=1] ‘FUN’
[17:36:39.427]  - needed namespaces: [n=0] 
[17:36:39.427] Finding globals ... DONE
[17:36:39.427]  - use_args: TRUE
[17:36:39.427]  - Getting '...' globals ...
[17:36:39.428] resolve() on list ...
[17:36:39.428]  recursive: 0
[17:36:39.428]  length: 1
[17:36:39.428]  elements: ‘...’
[17:36:39.428]  length: 0 (resolved future 1)
[17:36:39.428] resolve() on list ... DONE
[17:36:39.428]    - '...' content: [n=0] 
[17:36:39.428] List of 1
[17:36:39.428]  $ ...: list()
[17:36:39.428]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.428]  - attr(*, "where")=List of 1
[17:36:39.428]   ..$ ...:<environment: 0x5622fc5418a0> 
[17:36:39.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.428]  - attr(*, "resolved")= logi TRUE
[17:36:39.428]  - attr(*, "total_size")= num NA
[17:36:39.431]  - Getting '...' globals ... DONE
[17:36:39.431] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.431] List of 2
[17:36:39.431]  $ ...future.FUN:function (object, ...)  
[17:36:39.431]  $ ...          : list()
[17:36:39.431]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.431]  - attr(*, "where")=List of 2
[17:36:39.431]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.431]   ..$ ...          :<environment: 0x5622fc5418a0> 
[17:36:39.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.431]  - attr(*, "resolved")= logi FALSE
[17:36:39.431]  - attr(*, "total_size")= num 1240
[17:36:39.433] Packages to be attached in all futures: [n=0] 
[17:36:39.434] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.434] Number of futures (= number of chunks): 1
[17:36:39.434] Launching 1 futures (chunks) ...
[17:36:39.434] Chunk #1 of 1 ...
[17:36:39.434]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.434] getGlobalsAndPackages() ...
[17:36:39.434] Searching for globals...
[17:36:39.435] 
[17:36:39.435] Searching for globals ... DONE
[17:36:39.435] - globals: [0] <none>
[17:36:39.435] getGlobalsAndPackages() ... DONE
[17:36:39.435]    + additional globals found: [n=0] 
[17:36:39.435]    + additional namespaces needed: [n=0] 
[17:36:39.435]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.435]  - seeds: <none>
[17:36:39.435]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.436] getGlobalsAndPackages() ...
[17:36:39.436] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.436] Resolving globals: FALSE
[17:36:39.436] Tweak future expression to call with '...' arguments ...
[17:36:39.436] {
[17:36:39.436]     do.call(function(...) {
[17:36:39.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.436]             on.exit(options(oopts), add = TRUE)
[17:36:39.436]         }
[17:36:39.436]         {
[17:36:39.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.436]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.436]             })
[17:36:39.436]         }
[17:36:39.436]     }, args = future.call.arguments)
[17:36:39.436] }
[17:36:39.436] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.437] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.437] 
[17:36:39.437] getGlobalsAndPackages() ... DONE
[17:36:39.437] run() for ‘Future’ ...
[17:36:39.437] - state: ‘created’
[17:36:39.437] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:39.437] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.438] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.438]   - Field: ‘label’
[17:36:39.438]   - Field: ‘local’
[17:36:39.438]   - Field: ‘owner’
[17:36:39.438]   - Field: ‘envir’
[17:36:39.438]   - Field: ‘packages’
[17:36:39.438]   - Field: ‘gc’
[17:36:39.438]   - Field: ‘conditions’
[17:36:39.438]   - Field: ‘expr’
[17:36:39.438]   - Field: ‘uuid’
[17:36:39.438]   - Field: ‘seed’
[17:36:39.439]   - Field: ‘version’
[17:36:39.439]   - Field: ‘result’
[17:36:39.439]   - Field: ‘asynchronous’
[17:36:39.439]   - Field: ‘calls’
[17:36:39.439]   - Field: ‘globals’
[17:36:39.439]   - Field: ‘stdout’
[17:36:39.439]   - Field: ‘earlySignal’
[17:36:39.439]   - Field: ‘lazy’
[17:36:39.439]   - Field: ‘state’
[17:36:39.439] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.439] - Launch lazy future ...
[17:36:39.440] Packages needed by the future expression (n = 0): <none>
[17:36:39.440] Packages needed by future strategies (n = 0): <none>
[17:36:39.440] {
[17:36:39.440]     {
[17:36:39.440]         {
[17:36:39.440]             ...future.startTime <- base::Sys.time()
[17:36:39.440]             {
[17:36:39.440]                 {
[17:36:39.440]                   {
[17:36:39.440]                     base::local({
[17:36:39.440]                       has_future <- base::requireNamespace("future", 
[17:36:39.440]                         quietly = TRUE)
[17:36:39.440]                       if (has_future) {
[17:36:39.440]                         ns <- base::getNamespace("future")
[17:36:39.440]                         version <- ns[[".package"]][["version"]]
[17:36:39.440]                         if (is.null(version)) 
[17:36:39.440]                           version <- utils::packageVersion("future")
[17:36:39.440]                       }
[17:36:39.440]                       else {
[17:36:39.440]                         version <- NULL
[17:36:39.440]                       }
[17:36:39.440]                       if (!has_future || version < "1.8.0") {
[17:36:39.440]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.440]                           "", base::R.version$version.string), 
[17:36:39.440]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:39.440]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.440]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.440]                             "release", "version")], collapse = " "), 
[17:36:39.440]                           hostname = base::Sys.info()[["nodename"]])
[17:36:39.440]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.440]                           info)
[17:36:39.440]                         info <- base::paste(info, collapse = "; ")
[17:36:39.440]                         if (!has_future) {
[17:36:39.440]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.440]                             info)
[17:36:39.440]                         }
[17:36:39.440]                         else {
[17:36:39.440]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.440]                             info, version)
[17:36:39.440]                         }
[17:36:39.440]                         base::stop(msg)
[17:36:39.440]                       }
[17:36:39.440]                     })
[17:36:39.440]                   }
[17:36:39.440]                   ...future.strategy.old <- future::plan("list")
[17:36:39.440]                   options(future.plan = NULL)
[17:36:39.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.440]                 }
[17:36:39.440]                 ...future.workdir <- getwd()
[17:36:39.440]             }
[17:36:39.440]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.440]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.440]         }
[17:36:39.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.440]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.440]             base::names(...future.oldOptions))
[17:36:39.440]     }
[17:36:39.440]     if (FALSE) {
[17:36:39.440]     }
[17:36:39.440]     else {
[17:36:39.440]         if (TRUE) {
[17:36:39.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.440]                 open = "w")
[17:36:39.440]         }
[17:36:39.440]         else {
[17:36:39.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.440]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.440]         }
[17:36:39.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.440]             base::sink(type = "output", split = FALSE)
[17:36:39.440]             base::close(...future.stdout)
[17:36:39.440]         }, add = TRUE)
[17:36:39.440]     }
[17:36:39.440]     ...future.frame <- base::sys.nframe()
[17:36:39.440]     ...future.conditions <- base::list()
[17:36:39.440]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.440]     if (FALSE) {
[17:36:39.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.440]     }
[17:36:39.440]     ...future.result <- base::tryCatch({
[17:36:39.440]         base::withCallingHandlers({
[17:36:39.440]             ...future.value <- base::withVisible(base::local({
[17:36:39.440]                 do.call(function(...) {
[17:36:39.440]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.440]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.440]                     ...future.globals.maxSize)) {
[17:36:39.440]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.440]                     on.exit(options(oopts), add = TRUE)
[17:36:39.440]                   }
[17:36:39.440]                   {
[17:36:39.440]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.440]                       FUN = function(jj) {
[17:36:39.440]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.440]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.440]                       })
[17:36:39.440]                   }
[17:36:39.440]                 }, args = future.call.arguments)
[17:36:39.440]             }))
[17:36:39.440]             future::FutureResult(value = ...future.value$value, 
[17:36:39.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.440]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.440]                     ...future.globalenv.names))
[17:36:39.440]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.440]         }, condition = base::local({
[17:36:39.440]             c <- base::c
[17:36:39.440]             inherits <- base::inherits
[17:36:39.440]             invokeRestart <- base::invokeRestart
[17:36:39.440]             length <- base::length
[17:36:39.440]             list <- base::list
[17:36:39.440]             seq.int <- base::seq.int
[17:36:39.440]             signalCondition <- base::signalCondition
[17:36:39.440]             sys.calls <- base::sys.calls
[17:36:39.440]             `[[` <- base::`[[`
[17:36:39.440]             `+` <- base::`+`
[17:36:39.440]             `<<-` <- base::`<<-`
[17:36:39.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.440]                   3L)]
[17:36:39.440]             }
[17:36:39.440]             function(cond) {
[17:36:39.440]                 is_error <- inherits(cond, "error")
[17:36:39.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.440]                   NULL)
[17:36:39.440]                 if (is_error) {
[17:36:39.440]                   sessionInformation <- function() {
[17:36:39.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.440]                       search = base::search(), system = base::Sys.info())
[17:36:39.440]                   }
[17:36:39.440]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.440]                     cond$call), session = sessionInformation(), 
[17:36:39.440]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.440]                   signalCondition(cond)
[17:36:39.440]                 }
[17:36:39.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.440]                 "immediateCondition"))) {
[17:36:39.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.440]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.440]                   if (TRUE && !signal) {
[17:36:39.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.440]                     {
[17:36:39.440]                       inherits <- base::inherits
[17:36:39.440]                       invokeRestart <- base::invokeRestart
[17:36:39.440]                       is.null <- base::is.null
[17:36:39.440]                       muffled <- FALSE
[17:36:39.440]                       if (inherits(cond, "message")) {
[17:36:39.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.440]                         if (muffled) 
[17:36:39.440]                           invokeRestart("muffleMessage")
[17:36:39.440]                       }
[17:36:39.440]                       else if (inherits(cond, "warning")) {
[17:36:39.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.440]                         if (muffled) 
[17:36:39.440]                           invokeRestart("muffleWarning")
[17:36:39.440]                       }
[17:36:39.440]                       else if (inherits(cond, "condition")) {
[17:36:39.440]                         if (!is.null(pattern)) {
[17:36:39.440]                           computeRestarts <- base::computeRestarts
[17:36:39.440]                           grepl <- base::grepl
[17:36:39.440]                           restarts <- computeRestarts(cond)
[17:36:39.440]                           for (restart in restarts) {
[17:36:39.440]                             name <- restart$name
[17:36:39.440]                             if (is.null(name)) 
[17:36:39.440]                               next
[17:36:39.440]                             if (!grepl(pattern, name)) 
[17:36:39.440]                               next
[17:36:39.440]                             invokeRestart(restart)
[17:36:39.440]                             muffled <- TRUE
[17:36:39.440]                             break
[17:36:39.440]                           }
[17:36:39.440]                         }
[17:36:39.440]                       }
[17:36:39.440]                       invisible(muffled)
[17:36:39.440]                     }
[17:36:39.440]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.440]                   }
[17:36:39.440]                 }
[17:36:39.440]                 else {
[17:36:39.440]                   if (TRUE) {
[17:36:39.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.440]                     {
[17:36:39.440]                       inherits <- base::inherits
[17:36:39.440]                       invokeRestart <- base::invokeRestart
[17:36:39.440]                       is.null <- base::is.null
[17:36:39.440]                       muffled <- FALSE
[17:36:39.440]                       if (inherits(cond, "message")) {
[17:36:39.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.440]                         if (muffled) 
[17:36:39.440]                           invokeRestart("muffleMessage")
[17:36:39.440]                       }
[17:36:39.440]                       else if (inherits(cond, "warning")) {
[17:36:39.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.440]                         if (muffled) 
[17:36:39.440]                           invokeRestart("muffleWarning")
[17:36:39.440]                       }
[17:36:39.440]                       else if (inherits(cond, "condition")) {
[17:36:39.440]                         if (!is.null(pattern)) {
[17:36:39.440]                           computeRestarts <- base::computeRestarts
[17:36:39.440]                           grepl <- base::grepl
[17:36:39.440]                           restarts <- computeRestarts(cond)
[17:36:39.440]                           for (restart in restarts) {
[17:36:39.440]                             name <- restart$name
[17:36:39.440]                             if (is.null(name)) 
[17:36:39.440]                               next
[17:36:39.440]                             if (!grepl(pattern, name)) 
[17:36:39.440]                               next
[17:36:39.440]                             invokeRestart(restart)
[17:36:39.440]                             muffled <- TRUE
[17:36:39.440]                             break
[17:36:39.440]                           }
[17:36:39.440]                         }
[17:36:39.440]                       }
[17:36:39.440]                       invisible(muffled)
[17:36:39.440]                     }
[17:36:39.440]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.440]                   }
[17:36:39.440]                 }
[17:36:39.440]             }
[17:36:39.440]         }))
[17:36:39.440]     }, error = function(ex) {
[17:36:39.440]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.440]                 ...future.rng), started = ...future.startTime, 
[17:36:39.440]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.440]             version = "1.8"), class = "FutureResult")
[17:36:39.440]     }, finally = {
[17:36:39.440]         if (!identical(...future.workdir, getwd())) 
[17:36:39.440]             setwd(...future.workdir)
[17:36:39.440]         {
[17:36:39.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.440]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.440]             }
[17:36:39.440]             base::options(...future.oldOptions)
[17:36:39.440]             if (.Platform$OS.type == "windows") {
[17:36:39.440]                 old_names <- names(...future.oldEnvVars)
[17:36:39.440]                 envs <- base::Sys.getenv()
[17:36:39.440]                 names <- names(envs)
[17:36:39.440]                 common <- intersect(names, old_names)
[17:36:39.440]                 added <- setdiff(names, old_names)
[17:36:39.440]                 removed <- setdiff(old_names, names)
[17:36:39.440]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.440]                   envs[common]]
[17:36:39.440]                 NAMES <- toupper(changed)
[17:36:39.440]                 args <- list()
[17:36:39.440]                 for (kk in seq_along(NAMES)) {
[17:36:39.440]                   name <- changed[[kk]]
[17:36:39.440]                   NAME <- NAMES[[kk]]
[17:36:39.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.440]                     next
[17:36:39.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.440]                 }
[17:36:39.440]                 NAMES <- toupper(added)
[17:36:39.440]                 for (kk in seq_along(NAMES)) {
[17:36:39.440]                   name <- added[[kk]]
[17:36:39.440]                   NAME <- NAMES[[kk]]
[17:36:39.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.440]                     next
[17:36:39.440]                   args[[name]] <- ""
[17:36:39.440]                 }
[17:36:39.440]                 NAMES <- toupper(removed)
[17:36:39.440]                 for (kk in seq_along(NAMES)) {
[17:36:39.440]                   name <- removed[[kk]]
[17:36:39.440]                   NAME <- NAMES[[kk]]
[17:36:39.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.440]                     next
[17:36:39.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.440]                 }
[17:36:39.440]                 if (length(args) > 0) 
[17:36:39.440]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.440]             }
[17:36:39.440]             else {
[17:36:39.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.440]             }
[17:36:39.440]             {
[17:36:39.440]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.440]                   0L) {
[17:36:39.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.440]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.440]                   base::options(opts)
[17:36:39.440]                 }
[17:36:39.440]                 {
[17:36:39.440]                   {
[17:36:39.440]                     NULL
[17:36:39.440]                     RNGkind("Mersenne-Twister")
[17:36:39.440]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.440]                       inherits = FALSE)
[17:36:39.440]                   }
[17:36:39.440]                   options(future.plan = NULL)
[17:36:39.440]                   if (is.na(NA_character_)) 
[17:36:39.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.440]                     .init = FALSE)
[17:36:39.440]                 }
[17:36:39.440]             }
[17:36:39.440]         }
[17:36:39.440]     })
[17:36:39.440]     if (TRUE) {
[17:36:39.440]         base::sink(type = "output", split = FALSE)
[17:36:39.440]         if (TRUE) {
[17:36:39.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.440]         }
[17:36:39.440]         else {
[17:36:39.440]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.440]         }
[17:36:39.440]         base::close(...future.stdout)
[17:36:39.440]         ...future.stdout <- NULL
[17:36:39.440]     }
[17:36:39.440]     ...future.result$conditions <- ...future.conditions
[17:36:39.440]     ...future.result$finished <- base::Sys.time()
[17:36:39.440]     ...future.result
[17:36:39.440] }
[17:36:39.442] assign_globals() ...
[17:36:39.442] List of 5
[17:36:39.442]  $ ...future.FUN            :function (object, ...)  
[17:36:39.442]  $ future.call.arguments    : list()
[17:36:39.442]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.442]  $ ...future.elements_ii    :List of 3
[17:36:39.442]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.442]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:39.442]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.442]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.442]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.442]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:39.442]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.442]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:39.442]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.442]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:39.442]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.442]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:39.442]  $ ...future.seeds_ii       : NULL
[17:36:39.442]  $ ...future.globals.maxSize: NULL
[17:36:39.442]  - attr(*, "where")=List of 5
[17:36:39.442]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.442]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.442]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.442]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.442]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.442]  - attr(*, "resolved")= logi FALSE
[17:36:39.442]  - attr(*, "total_size")= num 1240
[17:36:39.442]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.442]  - attr(*, "already-done")= logi TRUE
[17:36:39.452] - copied ‘...future.FUN’ to environment
[17:36:39.452] - copied ‘future.call.arguments’ to environment
[17:36:39.452] - copied ‘...future.elements_ii’ to environment
[17:36:39.452] - copied ‘...future.seeds_ii’ to environment
[17:36:39.452] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.452] assign_globals() ... done
[17:36:39.453] plan(): Setting new future strategy stack:
[17:36:39.453] List of future strategies:
[17:36:39.453] 1. sequential:
[17:36:39.453]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.453]    - tweaked: FALSE
[17:36:39.453]    - call: NULL
[17:36:39.453] plan(): nbrOfWorkers() = 1
[17:36:39.455] plan(): Setting new future strategy stack:
[17:36:39.455] List of future strategies:
[17:36:39.455] 1. sequential:
[17:36:39.455]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.455]    - tweaked: FALSE
[17:36:39.455]    - call: plan(strategy)
[17:36:39.456] plan(): nbrOfWorkers() = 1
[17:36:39.456] SequentialFuture started (and completed)
[17:36:39.456] - Launch lazy future ... done
[17:36:39.456] run() for ‘SequentialFuture’ ... done
[17:36:39.456] Created future:
[17:36:39.457] SequentialFuture:
[17:36:39.457] Label: ‘future_by-1’
[17:36:39.457] Expression:
[17:36:39.457] {
[17:36:39.457]     do.call(function(...) {
[17:36:39.457]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.457]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.457]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.457]             on.exit(options(oopts), add = TRUE)
[17:36:39.457]         }
[17:36:39.457]         {
[17:36:39.457]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.457]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.457]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.457]             })
[17:36:39.457]         }
[17:36:39.457]     }, args = future.call.arguments)
[17:36:39.457] }
[17:36:39.457] Lazy evaluation: FALSE
[17:36:39.457] Asynchronous evaluation: FALSE
[17:36:39.457] Local evaluation: TRUE
[17:36:39.457] Environment: 0x5622fc4db750
[17:36:39.457] Capture standard output: TRUE
[17:36:39.457] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.457] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.457] Packages: <none>
[17:36:39.457] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.457] Resolved: TRUE
[17:36:39.457] Value: 5.37 KiB of class ‘list’
[17:36:39.457] Early signaling: FALSE
[17:36:39.457] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.457] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.458] Chunk #1 of 1 ... DONE
[17:36:39.458] Launching 1 futures (chunks) ... DONE
[17:36:39.458] Resolving 1 futures (chunks) ...
[17:36:39.458] resolve() on list ...
[17:36:39.458]  recursive: 0
[17:36:39.458]  length: 1
[17:36:39.458] 
[17:36:39.458] resolved() for ‘SequentialFuture’ ...
[17:36:39.459] - state: ‘finished’
[17:36:39.459] - run: TRUE
[17:36:39.459] - result: ‘FutureResult’
[17:36:39.459] resolved() for ‘SequentialFuture’ ... done
[17:36:39.459] Future #1
[17:36:39.459] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.459] - nx: 1
[17:36:39.459] - relay: TRUE
[17:36:39.459] - stdout: TRUE
[17:36:39.460] - signal: TRUE
[17:36:39.460] - resignal: FALSE
[17:36:39.460] - force: TRUE
[17:36:39.460] - relayed: [n=1] FALSE
[17:36:39.460] - queued futures: [n=1] FALSE
[17:36:39.460]  - until=1
[17:36:39.460]  - relaying element #1
[17:36:39.460] - relayed: [n=1] TRUE
[17:36:39.460] - queued futures: [n=1] TRUE
[17:36:39.460] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.461]  length: 0 (resolved future 1)
[17:36:39.461] Relaying remaining futures
[17:36:39.461] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.461] - nx: 1
[17:36:39.461] - relay: TRUE
[17:36:39.461] - stdout: TRUE
[17:36:39.461] - signal: TRUE
[17:36:39.461] - resignal: FALSE
[17:36:39.461] - force: TRUE
[17:36:39.461] - relayed: [n=1] TRUE
[17:36:39.461] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.462] - relayed: [n=1] TRUE
[17:36:39.462] - queued futures: [n=1] TRUE
[17:36:39.462] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.462] resolve() on list ... DONE
[17:36:39.462]  - Number of value chunks collected: 1
[17:36:39.462] Resolving 1 futures (chunks) ... DONE
[17:36:39.462] Reducing values from 1 chunks ...
[17:36:39.462]  - Number of values collected after concatenation: 3
[17:36:39.462]  - Number of values expected: 3
[17:36:39.462] Reducing values from 1 chunks ... DONE
[17:36:39.462] future_lapply() ... DONE
[17:36:39.463] future_by_internal() ... DONE
[17:36:39.464] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:36:39.465] future_lapply() ...
[17:36:39.466] Number of chunks: 1
[17:36:39.466] getGlobalsAndPackagesXApply() ...
[17:36:39.466]  - future.globals: TRUE
[17:36:39.466] getGlobalsAndPackages() ...
[17:36:39.466] Searching for globals...
[17:36:39.467] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:39.467] Searching for globals ... DONE
[17:36:39.467] Resolving globals: FALSE
[17:36:39.468] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:39.468] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:39.468] - globals: [1] ‘FUN’
[17:36:39.468] 
[17:36:39.468] getGlobalsAndPackages() ... DONE
[17:36:39.468]  - globals found/used: [n=1] ‘FUN’
[17:36:39.468]  - needed namespaces: [n=0] 
[17:36:39.468] Finding globals ... DONE
[17:36:39.469]  - use_args: TRUE
[17:36:39.469]  - Getting '...' globals ...
[17:36:39.471] resolve() on list ...
[17:36:39.471]  recursive: 0
[17:36:39.471]  length: 1
[17:36:39.471]  elements: ‘...’
[17:36:39.471]  length: 0 (resolved future 1)
[17:36:39.471] resolve() on list ... DONE
[17:36:39.471]    - '...' content: [n=0] 
[17:36:39.471] List of 1
[17:36:39.471]  $ ...: list()
[17:36:39.471]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.471]  - attr(*, "where")=List of 1
[17:36:39.471]   ..$ ...:<environment: 0x5622fc49e108> 
[17:36:39.471]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.471]  - attr(*, "resolved")= logi TRUE
[17:36:39.471]  - attr(*, "total_size")= num NA
[17:36:39.474]  - Getting '...' globals ... DONE
[17:36:39.474] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.474] List of 2
[17:36:39.474]  $ ...future.FUN:function (object, ...)  
[17:36:39.474]  $ ...          : list()
[17:36:39.474]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.474]  - attr(*, "where")=List of 2
[17:36:39.474]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.474]   ..$ ...          :<environment: 0x5622fc49e108> 
[17:36:39.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.474]  - attr(*, "resolved")= logi FALSE
[17:36:39.474]  - attr(*, "total_size")= num 1240
[17:36:39.477] Packages to be attached in all futures: [n=0] 
[17:36:39.477] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.477] Number of futures (= number of chunks): 1
[17:36:39.477] Launching 1 futures (chunks) ...
[17:36:39.477] Chunk #1 of 1 ...
[17:36:39.477]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.477] getGlobalsAndPackages() ...
[17:36:39.477] Searching for globals...
[17:36:39.478] 
[17:36:39.478] Searching for globals ... DONE
[17:36:39.478] - globals: [0] <none>
[17:36:39.478] getGlobalsAndPackages() ... DONE
[17:36:39.478]    + additional globals found: [n=0] 
[17:36:39.478]    + additional namespaces needed: [n=0] 
[17:36:39.478]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.478]  - seeds: <none>
[17:36:39.479]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.479] getGlobalsAndPackages() ...
[17:36:39.479] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.479] Resolving globals: FALSE
[17:36:39.479] Tweak future expression to call with '...' arguments ...
[17:36:39.479] {
[17:36:39.479]     do.call(function(...) {
[17:36:39.479]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.479]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.479]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.479]             on.exit(options(oopts), add = TRUE)
[17:36:39.479]         }
[17:36:39.479]         {
[17:36:39.479]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.479]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.479]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.479]             })
[17:36:39.479]         }
[17:36:39.479]     }, args = future.call.arguments)
[17:36:39.479] }
[17:36:39.479] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.480] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.480] 
[17:36:39.480] getGlobalsAndPackages() ... DONE
[17:36:39.480] run() for ‘Future’ ...
[17:36:39.480] - state: ‘created’
[17:36:39.480] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:39.481] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.481] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.481]   - Field: ‘label’
[17:36:39.481]   - Field: ‘local’
[17:36:39.481]   - Field: ‘owner’
[17:36:39.481]   - Field: ‘envir’
[17:36:39.481]   - Field: ‘packages’
[17:36:39.481]   - Field: ‘gc’
[17:36:39.481]   - Field: ‘conditions’
[17:36:39.482]   - Field: ‘expr’
[17:36:39.482]   - Field: ‘uuid’
[17:36:39.482]   - Field: ‘seed’
[17:36:39.482]   - Field: ‘version’
[17:36:39.482]   - Field: ‘result’
[17:36:39.482]   - Field: ‘asynchronous’
[17:36:39.482]   - Field: ‘calls’
[17:36:39.482]   - Field: ‘globals’
[17:36:39.482]   - Field: ‘stdout’
[17:36:39.482]   - Field: ‘earlySignal’
[17:36:39.482]   - Field: ‘lazy’
[17:36:39.482]   - Field: ‘state’
[17:36:39.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.483] - Launch lazy future ...
[17:36:39.483] Packages needed by the future expression (n = 0): <none>
[17:36:39.483] Packages needed by future strategies (n = 0): <none>
[17:36:39.483] {
[17:36:39.483]     {
[17:36:39.483]         {
[17:36:39.483]             ...future.startTime <- base::Sys.time()
[17:36:39.483]             {
[17:36:39.483]                 {
[17:36:39.483]                   {
[17:36:39.483]                     base::local({
[17:36:39.483]                       has_future <- base::requireNamespace("future", 
[17:36:39.483]                         quietly = TRUE)
[17:36:39.483]                       if (has_future) {
[17:36:39.483]                         ns <- base::getNamespace("future")
[17:36:39.483]                         version <- ns[[".package"]][["version"]]
[17:36:39.483]                         if (is.null(version)) 
[17:36:39.483]                           version <- utils::packageVersion("future")
[17:36:39.483]                       }
[17:36:39.483]                       else {
[17:36:39.483]                         version <- NULL
[17:36:39.483]                       }
[17:36:39.483]                       if (!has_future || version < "1.8.0") {
[17:36:39.483]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.483]                           "", base::R.version$version.string), 
[17:36:39.483]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:39.483]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.483]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.483]                             "release", "version")], collapse = " "), 
[17:36:39.483]                           hostname = base::Sys.info()[["nodename"]])
[17:36:39.483]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.483]                           info)
[17:36:39.483]                         info <- base::paste(info, collapse = "; ")
[17:36:39.483]                         if (!has_future) {
[17:36:39.483]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.483]                             info)
[17:36:39.483]                         }
[17:36:39.483]                         else {
[17:36:39.483]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.483]                             info, version)
[17:36:39.483]                         }
[17:36:39.483]                         base::stop(msg)
[17:36:39.483]                       }
[17:36:39.483]                     })
[17:36:39.483]                   }
[17:36:39.483]                   ...future.strategy.old <- future::plan("list")
[17:36:39.483]                   options(future.plan = NULL)
[17:36:39.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.483]                 }
[17:36:39.483]                 ...future.workdir <- getwd()
[17:36:39.483]             }
[17:36:39.483]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.483]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.483]         }
[17:36:39.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.483]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.483]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.483]             base::names(...future.oldOptions))
[17:36:39.483]     }
[17:36:39.483]     if (FALSE) {
[17:36:39.483]     }
[17:36:39.483]     else {
[17:36:39.483]         if (TRUE) {
[17:36:39.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.483]                 open = "w")
[17:36:39.483]         }
[17:36:39.483]         else {
[17:36:39.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.483]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.483]         }
[17:36:39.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.483]             base::sink(type = "output", split = FALSE)
[17:36:39.483]             base::close(...future.stdout)
[17:36:39.483]         }, add = TRUE)
[17:36:39.483]     }
[17:36:39.483]     ...future.frame <- base::sys.nframe()
[17:36:39.483]     ...future.conditions <- base::list()
[17:36:39.483]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.483]     if (FALSE) {
[17:36:39.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.483]     }
[17:36:39.483]     ...future.result <- base::tryCatch({
[17:36:39.483]         base::withCallingHandlers({
[17:36:39.483]             ...future.value <- base::withVisible(base::local({
[17:36:39.483]                 do.call(function(...) {
[17:36:39.483]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.483]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.483]                     ...future.globals.maxSize)) {
[17:36:39.483]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.483]                     on.exit(options(oopts), add = TRUE)
[17:36:39.483]                   }
[17:36:39.483]                   {
[17:36:39.483]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.483]                       FUN = function(jj) {
[17:36:39.483]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.483]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.483]                       })
[17:36:39.483]                   }
[17:36:39.483]                 }, args = future.call.arguments)
[17:36:39.483]             }))
[17:36:39.483]             future::FutureResult(value = ...future.value$value, 
[17:36:39.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.483]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.483]                     ...future.globalenv.names))
[17:36:39.483]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.483]         }, condition = base::local({
[17:36:39.483]             c <- base::c
[17:36:39.483]             inherits <- base::inherits
[17:36:39.483]             invokeRestart <- base::invokeRestart
[17:36:39.483]             length <- base::length
[17:36:39.483]             list <- base::list
[17:36:39.483]             seq.int <- base::seq.int
[17:36:39.483]             signalCondition <- base::signalCondition
[17:36:39.483]             sys.calls <- base::sys.calls
[17:36:39.483]             `[[` <- base::`[[`
[17:36:39.483]             `+` <- base::`+`
[17:36:39.483]             `<<-` <- base::`<<-`
[17:36:39.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.483]                   3L)]
[17:36:39.483]             }
[17:36:39.483]             function(cond) {
[17:36:39.483]                 is_error <- inherits(cond, "error")
[17:36:39.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.483]                   NULL)
[17:36:39.483]                 if (is_error) {
[17:36:39.483]                   sessionInformation <- function() {
[17:36:39.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.483]                       search = base::search(), system = base::Sys.info())
[17:36:39.483]                   }
[17:36:39.483]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.483]                     cond$call), session = sessionInformation(), 
[17:36:39.483]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.483]                   signalCondition(cond)
[17:36:39.483]                 }
[17:36:39.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.483]                 "immediateCondition"))) {
[17:36:39.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.483]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.483]                   if (TRUE && !signal) {
[17:36:39.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.483]                     {
[17:36:39.483]                       inherits <- base::inherits
[17:36:39.483]                       invokeRestart <- base::invokeRestart
[17:36:39.483]                       is.null <- base::is.null
[17:36:39.483]                       muffled <- FALSE
[17:36:39.483]                       if (inherits(cond, "message")) {
[17:36:39.483]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.483]                         if (muffled) 
[17:36:39.483]                           invokeRestart("muffleMessage")
[17:36:39.483]                       }
[17:36:39.483]                       else if (inherits(cond, "warning")) {
[17:36:39.483]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.483]                         if (muffled) 
[17:36:39.483]                           invokeRestart("muffleWarning")
[17:36:39.483]                       }
[17:36:39.483]                       else if (inherits(cond, "condition")) {
[17:36:39.483]                         if (!is.null(pattern)) {
[17:36:39.483]                           computeRestarts <- base::computeRestarts
[17:36:39.483]                           grepl <- base::grepl
[17:36:39.483]                           restarts <- computeRestarts(cond)
[17:36:39.483]                           for (restart in restarts) {
[17:36:39.483]                             name <- restart$name
[17:36:39.483]                             if (is.null(name)) 
[17:36:39.483]                               next
[17:36:39.483]                             if (!grepl(pattern, name)) 
[17:36:39.483]                               next
[17:36:39.483]                             invokeRestart(restart)
[17:36:39.483]                             muffled <- TRUE
[17:36:39.483]                             break
[17:36:39.483]                           }
[17:36:39.483]                         }
[17:36:39.483]                       }
[17:36:39.483]                       invisible(muffled)
[17:36:39.483]                     }
[17:36:39.483]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.483]                   }
[17:36:39.483]                 }
[17:36:39.483]                 else {
[17:36:39.483]                   if (TRUE) {
[17:36:39.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.483]                     {
[17:36:39.483]                       inherits <- base::inherits
[17:36:39.483]                       invokeRestart <- base::invokeRestart
[17:36:39.483]                       is.null <- base::is.null
[17:36:39.483]                       muffled <- FALSE
[17:36:39.483]                       if (inherits(cond, "message")) {
[17:36:39.483]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.483]                         if (muffled) 
[17:36:39.483]                           invokeRestart("muffleMessage")
[17:36:39.483]                       }
[17:36:39.483]                       else if (inherits(cond, "warning")) {
[17:36:39.483]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.483]                         if (muffled) 
[17:36:39.483]                           invokeRestart("muffleWarning")
[17:36:39.483]                       }
[17:36:39.483]                       else if (inherits(cond, "condition")) {
[17:36:39.483]                         if (!is.null(pattern)) {
[17:36:39.483]                           computeRestarts <- base::computeRestarts
[17:36:39.483]                           grepl <- base::grepl
[17:36:39.483]                           restarts <- computeRestarts(cond)
[17:36:39.483]                           for (restart in restarts) {
[17:36:39.483]                             name <- restart$name
[17:36:39.483]                             if (is.null(name)) 
[17:36:39.483]                               next
[17:36:39.483]                             if (!grepl(pattern, name)) 
[17:36:39.483]                               next
[17:36:39.483]                             invokeRestart(restart)
[17:36:39.483]                             muffled <- TRUE
[17:36:39.483]                             break
[17:36:39.483]                           }
[17:36:39.483]                         }
[17:36:39.483]                       }
[17:36:39.483]                       invisible(muffled)
[17:36:39.483]                     }
[17:36:39.483]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.483]                   }
[17:36:39.483]                 }
[17:36:39.483]             }
[17:36:39.483]         }))
[17:36:39.483]     }, error = function(ex) {
[17:36:39.483]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.483]                 ...future.rng), started = ...future.startTime, 
[17:36:39.483]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.483]             version = "1.8"), class = "FutureResult")
[17:36:39.483]     }, finally = {
[17:36:39.483]         if (!identical(...future.workdir, getwd())) 
[17:36:39.483]             setwd(...future.workdir)
[17:36:39.483]         {
[17:36:39.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.483]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.483]             }
[17:36:39.483]             base::options(...future.oldOptions)
[17:36:39.483]             if (.Platform$OS.type == "windows") {
[17:36:39.483]                 old_names <- names(...future.oldEnvVars)
[17:36:39.483]                 envs <- base::Sys.getenv()
[17:36:39.483]                 names <- names(envs)
[17:36:39.483]                 common <- intersect(names, old_names)
[17:36:39.483]                 added <- setdiff(names, old_names)
[17:36:39.483]                 removed <- setdiff(old_names, names)
[17:36:39.483]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.483]                   envs[common]]
[17:36:39.483]                 NAMES <- toupper(changed)
[17:36:39.483]                 args <- list()
[17:36:39.483]                 for (kk in seq_along(NAMES)) {
[17:36:39.483]                   name <- changed[[kk]]
[17:36:39.483]                   NAME <- NAMES[[kk]]
[17:36:39.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.483]                     next
[17:36:39.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.483]                 }
[17:36:39.483]                 NAMES <- toupper(added)
[17:36:39.483]                 for (kk in seq_along(NAMES)) {
[17:36:39.483]                   name <- added[[kk]]
[17:36:39.483]                   NAME <- NAMES[[kk]]
[17:36:39.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.483]                     next
[17:36:39.483]                   args[[name]] <- ""
[17:36:39.483]                 }
[17:36:39.483]                 NAMES <- toupper(removed)
[17:36:39.483]                 for (kk in seq_along(NAMES)) {
[17:36:39.483]                   name <- removed[[kk]]
[17:36:39.483]                   NAME <- NAMES[[kk]]
[17:36:39.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.483]                     next
[17:36:39.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.483]                 }
[17:36:39.483]                 if (length(args) > 0) 
[17:36:39.483]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.483]             }
[17:36:39.483]             else {
[17:36:39.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.483]             }
[17:36:39.483]             {
[17:36:39.483]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.483]                   0L) {
[17:36:39.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.483]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.483]                   base::options(opts)
[17:36:39.483]                 }
[17:36:39.483]                 {
[17:36:39.483]                   {
[17:36:39.483]                     NULL
[17:36:39.483]                     RNGkind("Mersenne-Twister")
[17:36:39.483]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.483]                       inherits = FALSE)
[17:36:39.483]                   }
[17:36:39.483]                   options(future.plan = NULL)
[17:36:39.483]                   if (is.na(NA_character_)) 
[17:36:39.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.483]                     .init = FALSE)
[17:36:39.483]                 }
[17:36:39.483]             }
[17:36:39.483]         }
[17:36:39.483]     })
[17:36:39.483]     if (TRUE) {
[17:36:39.483]         base::sink(type = "output", split = FALSE)
[17:36:39.483]         if (TRUE) {
[17:36:39.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.483]         }
[17:36:39.483]         else {
[17:36:39.483]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.483]         }
[17:36:39.483]         base::close(...future.stdout)
[17:36:39.483]         ...future.stdout <- NULL
[17:36:39.483]     }
[17:36:39.483]     ...future.result$conditions <- ...future.conditions
[17:36:39.483]     ...future.result$finished <- base::Sys.time()
[17:36:39.483]     ...future.result
[17:36:39.483] }
[17:36:39.485] assign_globals() ...
[17:36:39.485] List of 5
[17:36:39.485]  $ ...future.FUN            :function (object, ...)  
[17:36:39.485]  $ future.call.arguments    : list()
[17:36:39.485]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.485]  $ ...future.elements_ii    :List of 3
[17:36:39.485]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.485]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:39.485]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.485]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.485]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.485]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:39.485]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.485]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:39.485]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.485]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:39.485]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.485]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:39.485]  $ ...future.seeds_ii       : NULL
[17:36:39.485]  $ ...future.globals.maxSize: NULL
[17:36:39.485]  - attr(*, "where")=List of 5
[17:36:39.485]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.485]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.485]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.485]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.485]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.485]  - attr(*, "resolved")= logi FALSE
[17:36:39.485]  - attr(*, "total_size")= num 1240
[17:36:39.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.485]  - attr(*, "already-done")= logi TRUE
[17:36:39.495] - copied ‘...future.FUN’ to environment
[17:36:39.495] - copied ‘future.call.arguments’ to environment
[17:36:39.495] - copied ‘...future.elements_ii’ to environment
[17:36:39.495] - copied ‘...future.seeds_ii’ to environment
[17:36:39.495] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.496] assign_globals() ... done
[17:36:39.496] plan(): Setting new future strategy stack:
[17:36:39.496] List of future strategies:
[17:36:39.496] 1. sequential:
[17:36:39.496]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.496]    - tweaked: FALSE
[17:36:39.496]    - call: NULL
[17:36:39.496] plan(): nbrOfWorkers() = 1
[17:36:39.499] plan(): Setting new future strategy stack:
[17:36:39.499] List of future strategies:
[17:36:39.499] 1. sequential:
[17:36:39.499]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.499]    - tweaked: FALSE
[17:36:39.499]    - call: plan(strategy)
[17:36:39.499] plan(): nbrOfWorkers() = 1
[17:36:39.499] SequentialFuture started (and completed)
[17:36:39.499] - Launch lazy future ... done
[17:36:39.499] run() for ‘SequentialFuture’ ... done
[17:36:39.500] Created future:
[17:36:39.500] SequentialFuture:
[17:36:39.500] Label: ‘future_by-1’
[17:36:39.500] Expression:
[17:36:39.500] {
[17:36:39.500]     do.call(function(...) {
[17:36:39.500]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.500]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.500]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.500]             on.exit(options(oopts), add = TRUE)
[17:36:39.500]         }
[17:36:39.500]         {
[17:36:39.500]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.500]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.500]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.500]             })
[17:36:39.500]         }
[17:36:39.500]     }, args = future.call.arguments)
[17:36:39.500] }
[17:36:39.500] Lazy evaluation: FALSE
[17:36:39.500] Asynchronous evaluation: FALSE
[17:36:39.500] Local evaluation: TRUE
[17:36:39.500] Environment: 0x5622fc347e80
[17:36:39.500] Capture standard output: TRUE
[17:36:39.500] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.500] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.500] Packages: <none>
[17:36:39.500] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.500] Resolved: TRUE
[17:36:39.500] Value: 5.37 KiB of class ‘list’
[17:36:39.500] Early signaling: FALSE
[17:36:39.500] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.500] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.501] Chunk #1 of 1 ... DONE
[17:36:39.501] Launching 1 futures (chunks) ... DONE
[17:36:39.501] Resolving 1 futures (chunks) ...
[17:36:39.501] resolve() on list ...
[17:36:39.501]  recursive: 0
[17:36:39.501]  length: 1
[17:36:39.502] 
[17:36:39.502] resolved() for ‘SequentialFuture’ ...
[17:36:39.502] - state: ‘finished’
[17:36:39.502] - run: TRUE
[17:36:39.502] - result: ‘FutureResult’
[17:36:39.502] resolved() for ‘SequentialFuture’ ... done
[17:36:39.502] Future #1
[17:36:39.502] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.502] - nx: 1
[17:36:39.502] - relay: TRUE
[17:36:39.502] - stdout: TRUE
[17:36:39.503] - signal: TRUE
[17:36:39.503] - resignal: FALSE
[17:36:39.503] - force: TRUE
[17:36:39.503] - relayed: [n=1] FALSE
[17:36:39.503] - queued futures: [n=1] FALSE
[17:36:39.503]  - until=1
[17:36:39.503]  - relaying element #1
[17:36:39.503] - relayed: [n=1] TRUE
[17:36:39.503] - queued futures: [n=1] TRUE
[17:36:39.503] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.504]  length: 0 (resolved future 1)
[17:36:39.504] Relaying remaining futures
[17:36:39.504] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.504] - nx: 1
[17:36:39.504] - relay: TRUE
[17:36:39.504] - stdout: TRUE
[17:36:39.504] - signal: TRUE
[17:36:39.504] - resignal: FALSE
[17:36:39.504] - force: TRUE
[17:36:39.504] - relayed: [n=1] TRUE
[17:36:39.504] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.505] - relayed: [n=1] TRUE
[17:36:39.505] - queued futures: [n=1] TRUE
[17:36:39.505] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.505] resolve() on list ... DONE
[17:36:39.505]  - Number of value chunks collected: 1
[17:36:39.505] Resolving 1 futures (chunks) ... DONE
[17:36:39.505] Reducing values from 1 chunks ...
[17:36:39.505]  - Number of values collected after concatenation: 3
[17:36:39.505]  - Number of values expected: 3
[17:36:39.505] Reducing values from 1 chunks ... DONE
[17:36:39.505] future_lapply() ... DONE
[17:36:39.506] future_by_internal() ... DONE
[17:36:39.506] future_by_internal() ...
- plan('multicore') ...
[17:36:39.507] plan(): Setting new future strategy stack:
[17:36:39.507] List of future strategies:
[17:36:39.507] 1. multicore:
[17:36:39.507]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:39.507]    - tweaked: FALSE
[17:36:39.507]    - call: plan(strategy)
[17:36:39.511] plan(): nbrOfWorkers() = 1
[17:36:39.511] future_by_internal() ...
[17:36:39.511] future_lapply() ...
[17:36:39.515] Number of chunks: 1
[17:36:39.515] getGlobalsAndPackagesXApply() ...
[17:36:39.515]  - future.globals: TRUE
[17:36:39.515] getGlobalsAndPackages() ...
[17:36:39.515] Searching for globals...
[17:36:39.516] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:39.516] Searching for globals ... DONE
[17:36:39.516] Resolving globals: FALSE
[17:36:39.517] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:39.519] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:39.519] - globals: [1] ‘FUN’
[17:36:39.519] 
[17:36:39.519] getGlobalsAndPackages() ... DONE
[17:36:39.519]  - globals found/used: [n=1] ‘FUN’
[17:36:39.519]  - needed namespaces: [n=0] 
[17:36:39.519] Finding globals ... DONE
[17:36:39.519]  - use_args: TRUE
[17:36:39.519]  - Getting '...' globals ...
[17:36:39.520] resolve() on list ...
[17:36:39.520]  recursive: 0
[17:36:39.520]  length: 1
[17:36:39.520]  elements: ‘...’
[17:36:39.520]  length: 0 (resolved future 1)
[17:36:39.520] resolve() on list ... DONE
[17:36:39.520]    - '...' content: [n=0] 
[17:36:39.520] List of 1
[17:36:39.520]  $ ...: list()
[17:36:39.520]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.520]  - attr(*, "where")=List of 1
[17:36:39.520]   ..$ ...:<environment: 0x5622fc4b2578> 
[17:36:39.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.520]  - attr(*, "resolved")= logi TRUE
[17:36:39.520]  - attr(*, "total_size")= num NA
[17:36:39.523]  - Getting '...' globals ... DONE
[17:36:39.523] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.523] List of 2
[17:36:39.523]  $ ...future.FUN:function (object, ...)  
[17:36:39.523]  $ ...          : list()
[17:36:39.523]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.523]  - attr(*, "where")=List of 2
[17:36:39.523]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.523]   ..$ ...          :<environment: 0x5622fc4b2578> 
[17:36:39.523]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.523]  - attr(*, "resolved")= logi FALSE
[17:36:39.523]  - attr(*, "total_size")= num 1240
[17:36:39.526] Packages to be attached in all futures: [n=0] 
[17:36:39.526] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.526] Number of futures (= number of chunks): 1
[17:36:39.526] Launching 1 futures (chunks) ...
[17:36:39.526] Chunk #1 of 1 ...
[17:36:39.526]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.526] getGlobalsAndPackages() ...
[17:36:39.527] Searching for globals...
[17:36:39.527] 
[17:36:39.527] Searching for globals ... DONE
[17:36:39.527] - globals: [0] <none>
[17:36:39.527] getGlobalsAndPackages() ... DONE
[17:36:39.527]    + additional globals found: [n=0] 
[17:36:39.528]    + additional namespaces needed: [n=0] 
[17:36:39.528]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.528]  - seeds: <none>
[17:36:39.528]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.528] getGlobalsAndPackages() ...
[17:36:39.528] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.528] Resolving globals: FALSE
[17:36:39.528] Tweak future expression to call with '...' arguments ...
[17:36:39.528] {
[17:36:39.528]     do.call(function(...) {
[17:36:39.528]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.528]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.528]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.528]             on.exit(options(oopts), add = TRUE)
[17:36:39.528]         }
[17:36:39.528]         {
[17:36:39.528]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.528]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.528]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.528]             })
[17:36:39.528]         }
[17:36:39.528]     }, args = future.call.arguments)
[17:36:39.528] }
[17:36:39.529] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.529] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.529] 
[17:36:39.529] getGlobalsAndPackages() ... DONE
[17:36:39.529] run() for ‘Future’ ...
[17:36:39.530] - state: ‘created’
[17:36:39.530] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:39.533] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.533] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.533]   - Field: ‘label’
[17:36:39.534]   - Field: ‘local’
[17:36:39.534]   - Field: ‘owner’
[17:36:39.534]   - Field: ‘envir’
[17:36:39.534]   - Field: ‘packages’
[17:36:39.534]   - Field: ‘gc’
[17:36:39.534]   - Field: ‘conditions’
[17:36:39.534]   - Field: ‘expr’
[17:36:39.534]   - Field: ‘uuid’
[17:36:39.534]   - Field: ‘seed’
[17:36:39.534]   - Field: ‘version’
[17:36:39.534]   - Field: ‘result’
[17:36:39.535]   - Field: ‘asynchronous’
[17:36:39.535]   - Field: ‘calls’
[17:36:39.535]   - Field: ‘globals’
[17:36:39.535]   - Field: ‘stdout’
[17:36:39.535]   - Field: ‘earlySignal’
[17:36:39.535]   - Field: ‘lazy’
[17:36:39.535]   - Field: ‘state’
[17:36:39.535] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.535] - Launch lazy future ...
[17:36:39.535] Packages needed by the future expression (n = 0): <none>
[17:36:39.536] Packages needed by future strategies (n = 0): <none>
[17:36:39.536] {
[17:36:39.536]     {
[17:36:39.536]         {
[17:36:39.536]             ...future.startTime <- base::Sys.time()
[17:36:39.536]             {
[17:36:39.536]                 {
[17:36:39.536]                   {
[17:36:39.536]                     base::local({
[17:36:39.536]                       has_future <- base::requireNamespace("future", 
[17:36:39.536]                         quietly = TRUE)
[17:36:39.536]                       if (has_future) {
[17:36:39.536]                         ns <- base::getNamespace("future")
[17:36:39.536]                         version <- ns[[".package"]][["version"]]
[17:36:39.536]                         if (is.null(version)) 
[17:36:39.536]                           version <- utils::packageVersion("future")
[17:36:39.536]                       }
[17:36:39.536]                       else {
[17:36:39.536]                         version <- NULL
[17:36:39.536]                       }
[17:36:39.536]                       if (!has_future || version < "1.8.0") {
[17:36:39.536]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.536]                           "", base::R.version$version.string), 
[17:36:39.536]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:39.536]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.536]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.536]                             "release", "version")], collapse = " "), 
[17:36:39.536]                           hostname = base::Sys.info()[["nodename"]])
[17:36:39.536]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.536]                           info)
[17:36:39.536]                         info <- base::paste(info, collapse = "; ")
[17:36:39.536]                         if (!has_future) {
[17:36:39.536]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.536]                             info)
[17:36:39.536]                         }
[17:36:39.536]                         else {
[17:36:39.536]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.536]                             info, version)
[17:36:39.536]                         }
[17:36:39.536]                         base::stop(msg)
[17:36:39.536]                       }
[17:36:39.536]                     })
[17:36:39.536]                   }
[17:36:39.536]                   ...future.strategy.old <- future::plan("list")
[17:36:39.536]                   options(future.plan = NULL)
[17:36:39.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.536]                 }
[17:36:39.536]                 ...future.workdir <- getwd()
[17:36:39.536]             }
[17:36:39.536]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.536]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.536]         }
[17:36:39.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.536]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.536]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.536]             base::names(...future.oldOptions))
[17:36:39.536]     }
[17:36:39.536]     if (FALSE) {
[17:36:39.536]     }
[17:36:39.536]     else {
[17:36:39.536]         if (TRUE) {
[17:36:39.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.536]                 open = "w")
[17:36:39.536]         }
[17:36:39.536]         else {
[17:36:39.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.536]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.536]         }
[17:36:39.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.536]             base::sink(type = "output", split = FALSE)
[17:36:39.536]             base::close(...future.stdout)
[17:36:39.536]         }, add = TRUE)
[17:36:39.536]     }
[17:36:39.536]     ...future.frame <- base::sys.nframe()
[17:36:39.536]     ...future.conditions <- base::list()
[17:36:39.536]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.536]     if (FALSE) {
[17:36:39.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.536]     }
[17:36:39.536]     ...future.result <- base::tryCatch({
[17:36:39.536]         base::withCallingHandlers({
[17:36:39.536]             ...future.value <- base::withVisible(base::local({
[17:36:39.536]                 do.call(function(...) {
[17:36:39.536]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.536]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.536]                     ...future.globals.maxSize)) {
[17:36:39.536]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.536]                     on.exit(options(oopts), add = TRUE)
[17:36:39.536]                   }
[17:36:39.536]                   {
[17:36:39.536]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.536]                       FUN = function(jj) {
[17:36:39.536]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.536]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.536]                       })
[17:36:39.536]                   }
[17:36:39.536]                 }, args = future.call.arguments)
[17:36:39.536]             }))
[17:36:39.536]             future::FutureResult(value = ...future.value$value, 
[17:36:39.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.536]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.536]                     ...future.globalenv.names))
[17:36:39.536]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.536]         }, condition = base::local({
[17:36:39.536]             c <- base::c
[17:36:39.536]             inherits <- base::inherits
[17:36:39.536]             invokeRestart <- base::invokeRestart
[17:36:39.536]             length <- base::length
[17:36:39.536]             list <- base::list
[17:36:39.536]             seq.int <- base::seq.int
[17:36:39.536]             signalCondition <- base::signalCondition
[17:36:39.536]             sys.calls <- base::sys.calls
[17:36:39.536]             `[[` <- base::`[[`
[17:36:39.536]             `+` <- base::`+`
[17:36:39.536]             `<<-` <- base::`<<-`
[17:36:39.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.536]                   3L)]
[17:36:39.536]             }
[17:36:39.536]             function(cond) {
[17:36:39.536]                 is_error <- inherits(cond, "error")
[17:36:39.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.536]                   NULL)
[17:36:39.536]                 if (is_error) {
[17:36:39.536]                   sessionInformation <- function() {
[17:36:39.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.536]                       search = base::search(), system = base::Sys.info())
[17:36:39.536]                   }
[17:36:39.536]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.536]                     cond$call), session = sessionInformation(), 
[17:36:39.536]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.536]                   signalCondition(cond)
[17:36:39.536]                 }
[17:36:39.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.536]                 "immediateCondition"))) {
[17:36:39.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.536]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.536]                   if (TRUE && !signal) {
[17:36:39.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.536]                     {
[17:36:39.536]                       inherits <- base::inherits
[17:36:39.536]                       invokeRestart <- base::invokeRestart
[17:36:39.536]                       is.null <- base::is.null
[17:36:39.536]                       muffled <- FALSE
[17:36:39.536]                       if (inherits(cond, "message")) {
[17:36:39.536]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.536]                         if (muffled) 
[17:36:39.536]                           invokeRestart("muffleMessage")
[17:36:39.536]                       }
[17:36:39.536]                       else if (inherits(cond, "warning")) {
[17:36:39.536]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.536]                         if (muffled) 
[17:36:39.536]                           invokeRestart("muffleWarning")
[17:36:39.536]                       }
[17:36:39.536]                       else if (inherits(cond, "condition")) {
[17:36:39.536]                         if (!is.null(pattern)) {
[17:36:39.536]                           computeRestarts <- base::computeRestarts
[17:36:39.536]                           grepl <- base::grepl
[17:36:39.536]                           restarts <- computeRestarts(cond)
[17:36:39.536]                           for (restart in restarts) {
[17:36:39.536]                             name <- restart$name
[17:36:39.536]                             if (is.null(name)) 
[17:36:39.536]                               next
[17:36:39.536]                             if (!grepl(pattern, name)) 
[17:36:39.536]                               next
[17:36:39.536]                             invokeRestart(restart)
[17:36:39.536]                             muffled <- TRUE
[17:36:39.536]                             break
[17:36:39.536]                           }
[17:36:39.536]                         }
[17:36:39.536]                       }
[17:36:39.536]                       invisible(muffled)
[17:36:39.536]                     }
[17:36:39.536]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.536]                   }
[17:36:39.536]                 }
[17:36:39.536]                 else {
[17:36:39.536]                   if (TRUE) {
[17:36:39.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.536]                     {
[17:36:39.536]                       inherits <- base::inherits
[17:36:39.536]                       invokeRestart <- base::invokeRestart
[17:36:39.536]                       is.null <- base::is.null
[17:36:39.536]                       muffled <- FALSE
[17:36:39.536]                       if (inherits(cond, "message")) {
[17:36:39.536]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.536]                         if (muffled) 
[17:36:39.536]                           invokeRestart("muffleMessage")
[17:36:39.536]                       }
[17:36:39.536]                       else if (inherits(cond, "warning")) {
[17:36:39.536]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.536]                         if (muffled) 
[17:36:39.536]                           invokeRestart("muffleWarning")
[17:36:39.536]                       }
[17:36:39.536]                       else if (inherits(cond, "condition")) {
[17:36:39.536]                         if (!is.null(pattern)) {
[17:36:39.536]                           computeRestarts <- base::computeRestarts
[17:36:39.536]                           grepl <- base::grepl
[17:36:39.536]                           restarts <- computeRestarts(cond)
[17:36:39.536]                           for (restart in restarts) {
[17:36:39.536]                             name <- restart$name
[17:36:39.536]                             if (is.null(name)) 
[17:36:39.536]                               next
[17:36:39.536]                             if (!grepl(pattern, name)) 
[17:36:39.536]                               next
[17:36:39.536]                             invokeRestart(restart)
[17:36:39.536]                             muffled <- TRUE
[17:36:39.536]                             break
[17:36:39.536]                           }
[17:36:39.536]                         }
[17:36:39.536]                       }
[17:36:39.536]                       invisible(muffled)
[17:36:39.536]                     }
[17:36:39.536]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.536]                   }
[17:36:39.536]                 }
[17:36:39.536]             }
[17:36:39.536]         }))
[17:36:39.536]     }, error = function(ex) {
[17:36:39.536]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.536]                 ...future.rng), started = ...future.startTime, 
[17:36:39.536]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.536]             version = "1.8"), class = "FutureResult")
[17:36:39.536]     }, finally = {
[17:36:39.536]         if (!identical(...future.workdir, getwd())) 
[17:36:39.536]             setwd(...future.workdir)
[17:36:39.536]         {
[17:36:39.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.536]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.536]             }
[17:36:39.536]             base::options(...future.oldOptions)
[17:36:39.536]             if (.Platform$OS.type == "windows") {
[17:36:39.536]                 old_names <- names(...future.oldEnvVars)
[17:36:39.536]                 envs <- base::Sys.getenv()
[17:36:39.536]                 names <- names(envs)
[17:36:39.536]                 common <- intersect(names, old_names)
[17:36:39.536]                 added <- setdiff(names, old_names)
[17:36:39.536]                 removed <- setdiff(old_names, names)
[17:36:39.536]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.536]                   envs[common]]
[17:36:39.536]                 NAMES <- toupper(changed)
[17:36:39.536]                 args <- list()
[17:36:39.536]                 for (kk in seq_along(NAMES)) {
[17:36:39.536]                   name <- changed[[kk]]
[17:36:39.536]                   NAME <- NAMES[[kk]]
[17:36:39.536]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.536]                     next
[17:36:39.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.536]                 }
[17:36:39.536]                 NAMES <- toupper(added)
[17:36:39.536]                 for (kk in seq_along(NAMES)) {
[17:36:39.536]                   name <- added[[kk]]
[17:36:39.536]                   NAME <- NAMES[[kk]]
[17:36:39.536]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.536]                     next
[17:36:39.536]                   args[[name]] <- ""
[17:36:39.536]                 }
[17:36:39.536]                 NAMES <- toupper(removed)
[17:36:39.536]                 for (kk in seq_along(NAMES)) {
[17:36:39.536]                   name <- removed[[kk]]
[17:36:39.536]                   NAME <- NAMES[[kk]]
[17:36:39.536]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.536]                     next
[17:36:39.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.536]                 }
[17:36:39.536]                 if (length(args) > 0) 
[17:36:39.536]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.536]             }
[17:36:39.536]             else {
[17:36:39.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.536]             }
[17:36:39.536]             {
[17:36:39.536]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.536]                   0L) {
[17:36:39.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.536]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.536]                   base::options(opts)
[17:36:39.536]                 }
[17:36:39.536]                 {
[17:36:39.536]                   {
[17:36:39.536]                     NULL
[17:36:39.536]                     RNGkind("Mersenne-Twister")
[17:36:39.536]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.536]                       inherits = FALSE)
[17:36:39.536]                   }
[17:36:39.536]                   options(future.plan = NULL)
[17:36:39.536]                   if (is.na(NA_character_)) 
[17:36:39.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.536]                     .init = FALSE)
[17:36:39.536]                 }
[17:36:39.536]             }
[17:36:39.536]         }
[17:36:39.536]     })
[17:36:39.536]     if (TRUE) {
[17:36:39.536]         base::sink(type = "output", split = FALSE)
[17:36:39.536]         if (TRUE) {
[17:36:39.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.536]         }
[17:36:39.536]         else {
[17:36:39.536]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.536]         }
[17:36:39.536]         base::close(...future.stdout)
[17:36:39.536]         ...future.stdout <- NULL
[17:36:39.536]     }
[17:36:39.536]     ...future.result$conditions <- ...future.conditions
[17:36:39.536]     ...future.result$finished <- base::Sys.time()
[17:36:39.536]     ...future.result
[17:36:39.536] }
[17:36:39.538] assign_globals() ...
[17:36:39.538] List of 5
[17:36:39.538]  $ ...future.FUN            :function (object, ...)  
[17:36:39.538]  $ future.call.arguments    : list()
[17:36:39.538]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.538]  $ ...future.elements_ii    :List of 3
[17:36:39.538]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:39.538]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:39.538]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.538]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:39.538]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:39.538]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.538]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:39.538]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:39.538]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.538]  $ ...future.seeds_ii       : NULL
[17:36:39.538]  $ ...future.globals.maxSize: NULL
[17:36:39.538]  - attr(*, "where")=List of 5
[17:36:39.538]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.538]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.538]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.538]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.538]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.538]  - attr(*, "resolved")= logi FALSE
[17:36:39.538]  - attr(*, "total_size")= num 1240
[17:36:39.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.538]  - attr(*, "already-done")= logi TRUE
[17:36:39.547] - copied ‘...future.FUN’ to environment
[17:36:39.547] - copied ‘future.call.arguments’ to environment
[17:36:39.547] - copied ‘...future.elements_ii’ to environment
[17:36:39.547] - copied ‘...future.seeds_ii’ to environment
[17:36:39.547] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.548] assign_globals() ... done
[17:36:39.548] plan(): Setting new future strategy stack:
[17:36:39.548] List of future strategies:
[17:36:39.548] 1. sequential:
[17:36:39.548]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.548]    - tweaked: FALSE
[17:36:39.548]    - call: NULL
[17:36:39.548] plan(): nbrOfWorkers() = 1
[17:36:39.550] plan(): Setting new future strategy stack:
[17:36:39.550] List of future strategies:
[17:36:39.550] 1. multicore:
[17:36:39.550]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:39.550]    - tweaked: FALSE
[17:36:39.550]    - call: plan(strategy)
[17:36:39.554] plan(): nbrOfWorkers() = 1
[17:36:39.554] SequentialFuture started (and completed)
[17:36:39.555] - Launch lazy future ... done
[17:36:39.555] run() for ‘SequentialFuture’ ... done
[17:36:39.555] Created future:
[17:36:39.555] SequentialFuture:
[17:36:39.555] Label: ‘future_by-1’
[17:36:39.555] Expression:
[17:36:39.555] {
[17:36:39.555]     do.call(function(...) {
[17:36:39.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.555]             on.exit(options(oopts), add = TRUE)
[17:36:39.555]         }
[17:36:39.555]         {
[17:36:39.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.555]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.555]             })
[17:36:39.555]         }
[17:36:39.555]     }, args = future.call.arguments)
[17:36:39.555] }
[17:36:39.555] Lazy evaluation: FALSE
[17:36:39.555] Asynchronous evaluation: FALSE
[17:36:39.555] Local evaluation: TRUE
[17:36:39.555] Environment: R_GlobalEnv
[17:36:39.555] Capture standard output: TRUE
[17:36:39.555] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.555] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.555] Packages: <none>
[17:36:39.555] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.555] Resolved: TRUE
[17:36:39.555] Value: 4.62 KiB of class ‘list’
[17:36:39.555] Early signaling: FALSE
[17:36:39.555] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.555] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.556] Chunk #1 of 1 ... DONE
[17:36:39.557] Launching 1 futures (chunks) ... DONE
[17:36:39.557] Resolving 1 futures (chunks) ...
[17:36:39.557] resolve() on list ...
[17:36:39.557]  recursive: 0
[17:36:39.557]  length: 1
[17:36:39.557] 
[17:36:39.557] resolved() for ‘SequentialFuture’ ...
[17:36:39.557] - state: ‘finished’
[17:36:39.557] - run: TRUE
[17:36:39.557] - result: ‘FutureResult’
[17:36:39.558] resolved() for ‘SequentialFuture’ ... done
[17:36:39.558] Future #1
[17:36:39.558] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.558] - nx: 1
[17:36:39.558] - relay: TRUE
[17:36:39.558] - stdout: TRUE
[17:36:39.558] - signal: TRUE
[17:36:39.558] - resignal: FALSE
[17:36:39.558] - force: TRUE
[17:36:39.558] - relayed: [n=1] FALSE
[17:36:39.558] - queued futures: [n=1] FALSE
[17:36:39.559]  - until=1
[17:36:39.559]  - relaying element #1
[17:36:39.559] - relayed: [n=1] TRUE
[17:36:39.559] - queued futures: [n=1] TRUE
[17:36:39.559] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.559]  length: 0 (resolved future 1)
[17:36:39.559] Relaying remaining futures
[17:36:39.559] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.559] - nx: 1
[17:36:39.560] - relay: TRUE
[17:36:39.560] - stdout: TRUE
[17:36:39.560] - signal: TRUE
[17:36:39.560] - resignal: FALSE
[17:36:39.560] - force: TRUE
[17:36:39.560] - relayed: [n=1] TRUE
[17:36:39.560] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.560] - relayed: [n=1] TRUE
[17:36:39.560] - queued futures: [n=1] TRUE
[17:36:39.560] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.560] resolve() on list ... DONE
[17:36:39.561]  - Number of value chunks collected: 1
[17:36:39.561] Resolving 1 futures (chunks) ... DONE
[17:36:39.561] Reducing values from 1 chunks ...
[17:36:39.561]  - Number of values collected after concatenation: 3
[17:36:39.561]  - Number of values expected: 3
[17:36:39.561] Reducing values from 1 chunks ... DONE
[17:36:39.561] future_lapply() ... DONE
[17:36:39.561] future_by_internal() ... DONE
[17:36:39.562] future_by_internal() ...
[17:36:39.562] future_lapply() ...
[17:36:39.566] Number of chunks: 1
[17:36:39.566] getGlobalsAndPackagesXApply() ...
[17:36:39.566]  - future.globals: TRUE
[17:36:39.566] getGlobalsAndPackages() ...
[17:36:39.566] Searching for globals...
[17:36:39.567] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:39.567] Searching for globals ... DONE
[17:36:39.567] Resolving globals: FALSE
[17:36:39.568] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:39.568] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:39.568] - globals: [1] ‘FUN’
[17:36:39.568] 
[17:36:39.570] getGlobalsAndPackages() ... DONE
[17:36:39.570]  - globals found/used: [n=1] ‘FUN’
[17:36:39.570]  - needed namespaces: [n=0] 
[17:36:39.570] Finding globals ... DONE
[17:36:39.571]  - use_args: TRUE
[17:36:39.571]  - Getting '...' globals ...
[17:36:39.571] resolve() on list ...
[17:36:39.571]  recursive: 0
[17:36:39.571]  length: 1
[17:36:39.571]  elements: ‘...’
[17:36:39.571]  length: 0 (resolved future 1)
[17:36:39.571] resolve() on list ... DONE
[17:36:39.572]    - '...' content: [n=1] ‘digits’
[17:36:39.572] List of 1
[17:36:39.572]  $ ...:List of 1
[17:36:39.572]   ..$ digits: int 2
[17:36:39.572]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.572]  - attr(*, "where")=List of 1
[17:36:39.572]   ..$ ...:<environment: 0x5622fc449110> 
[17:36:39.572]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.572]  - attr(*, "resolved")= logi TRUE
[17:36:39.572]  - attr(*, "total_size")= num NA
[17:36:39.575]  - Getting '...' globals ... DONE
[17:36:39.575] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.575] List of 2
[17:36:39.575]  $ ...future.FUN:function (object, ...)  
[17:36:39.575]  $ ...          :List of 1
[17:36:39.575]   ..$ digits: int 2
[17:36:39.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.575]  - attr(*, "where")=List of 2
[17:36:39.575]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.575]   ..$ ...          :<environment: 0x5622fc449110> 
[17:36:39.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.575]  - attr(*, "resolved")= logi FALSE
[17:36:39.575]  - attr(*, "total_size")= num 1296
[17:36:39.578] Packages to be attached in all futures: [n=0] 
[17:36:39.578] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.578] Number of futures (= number of chunks): 1
[17:36:39.578] Launching 1 futures (chunks) ...
[17:36:39.579] Chunk #1 of 1 ...
[17:36:39.579]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.579] getGlobalsAndPackages() ...
[17:36:39.579] Searching for globals...
[17:36:39.579] 
[17:36:39.579] Searching for globals ... DONE
[17:36:39.579] - globals: [0] <none>
[17:36:39.579] getGlobalsAndPackages() ... DONE
[17:36:39.579]    + additional globals found: [n=0] 
[17:36:39.580]    + additional namespaces needed: [n=0] 
[17:36:39.580]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.580]  - seeds: <none>
[17:36:39.580]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.580] getGlobalsAndPackages() ...
[17:36:39.580] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.580] Resolving globals: FALSE
[17:36:39.580] Tweak future expression to call with '...' arguments ...
[17:36:39.580] {
[17:36:39.580]     do.call(function(...) {
[17:36:39.580]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.580]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.580]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.580]             on.exit(options(oopts), add = TRUE)
[17:36:39.580]         }
[17:36:39.580]         {
[17:36:39.580]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.580]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.580]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.580]             })
[17:36:39.580]         }
[17:36:39.580]     }, args = future.call.arguments)
[17:36:39.580] }
[17:36:39.581] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.581] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.581] 
[17:36:39.581] getGlobalsAndPackages() ... DONE
[17:36:39.581] run() for ‘Future’ ...
[17:36:39.582] - state: ‘created’
[17:36:39.582] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:39.585] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.585] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.585]   - Field: ‘label’
[17:36:39.586]   - Field: ‘local’
[17:36:39.586]   - Field: ‘owner’
[17:36:39.586]   - Field: ‘envir’
[17:36:39.586]   - Field: ‘packages’
[17:36:39.586]   - Field: ‘gc’
[17:36:39.586]   - Field: ‘conditions’
[17:36:39.586]   - Field: ‘expr’
[17:36:39.586]   - Field: ‘uuid’
[17:36:39.586]   - Field: ‘seed’
[17:36:39.586]   - Field: ‘version’
[17:36:39.586]   - Field: ‘result’
[17:36:39.587]   - Field: ‘asynchronous’
[17:36:39.587]   - Field: ‘calls’
[17:36:39.587]   - Field: ‘globals’
[17:36:39.587]   - Field: ‘stdout’
[17:36:39.587]   - Field: ‘earlySignal’
[17:36:39.587]   - Field: ‘lazy’
[17:36:39.587]   - Field: ‘state’
[17:36:39.587] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.587] - Launch lazy future ...
[17:36:39.588] Packages needed by the future expression (n = 0): <none>
[17:36:39.588] Packages needed by future strategies (n = 0): <none>
[17:36:39.588] {
[17:36:39.588]     {
[17:36:39.588]         {
[17:36:39.588]             ...future.startTime <- base::Sys.time()
[17:36:39.588]             {
[17:36:39.588]                 {
[17:36:39.588]                   {
[17:36:39.588]                     base::local({
[17:36:39.588]                       has_future <- base::requireNamespace("future", 
[17:36:39.588]                         quietly = TRUE)
[17:36:39.588]                       if (has_future) {
[17:36:39.588]                         ns <- base::getNamespace("future")
[17:36:39.588]                         version <- ns[[".package"]][["version"]]
[17:36:39.588]                         if (is.null(version)) 
[17:36:39.588]                           version <- utils::packageVersion("future")
[17:36:39.588]                       }
[17:36:39.588]                       else {
[17:36:39.588]                         version <- NULL
[17:36:39.588]                       }
[17:36:39.588]                       if (!has_future || version < "1.8.0") {
[17:36:39.588]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.588]                           "", base::R.version$version.string), 
[17:36:39.588]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:39.588]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.588]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.588]                             "release", "version")], collapse = " "), 
[17:36:39.588]                           hostname = base::Sys.info()[["nodename"]])
[17:36:39.588]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.588]                           info)
[17:36:39.588]                         info <- base::paste(info, collapse = "; ")
[17:36:39.588]                         if (!has_future) {
[17:36:39.588]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.588]                             info)
[17:36:39.588]                         }
[17:36:39.588]                         else {
[17:36:39.588]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.588]                             info, version)
[17:36:39.588]                         }
[17:36:39.588]                         base::stop(msg)
[17:36:39.588]                       }
[17:36:39.588]                     })
[17:36:39.588]                   }
[17:36:39.588]                   ...future.strategy.old <- future::plan("list")
[17:36:39.588]                   options(future.plan = NULL)
[17:36:39.588]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.588]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.588]                 }
[17:36:39.588]                 ...future.workdir <- getwd()
[17:36:39.588]             }
[17:36:39.588]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.588]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.588]         }
[17:36:39.588]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.588]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.588]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.588]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.588]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.588]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.588]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.588]             base::names(...future.oldOptions))
[17:36:39.588]     }
[17:36:39.588]     if (FALSE) {
[17:36:39.588]     }
[17:36:39.588]     else {
[17:36:39.588]         if (TRUE) {
[17:36:39.588]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.588]                 open = "w")
[17:36:39.588]         }
[17:36:39.588]         else {
[17:36:39.588]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.588]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.588]         }
[17:36:39.588]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.588]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.588]             base::sink(type = "output", split = FALSE)
[17:36:39.588]             base::close(...future.stdout)
[17:36:39.588]         }, add = TRUE)
[17:36:39.588]     }
[17:36:39.588]     ...future.frame <- base::sys.nframe()
[17:36:39.588]     ...future.conditions <- base::list()
[17:36:39.588]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.588]     if (FALSE) {
[17:36:39.588]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.588]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.588]     }
[17:36:39.588]     ...future.result <- base::tryCatch({
[17:36:39.588]         base::withCallingHandlers({
[17:36:39.588]             ...future.value <- base::withVisible(base::local({
[17:36:39.588]                 do.call(function(...) {
[17:36:39.588]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.588]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.588]                     ...future.globals.maxSize)) {
[17:36:39.588]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.588]                     on.exit(options(oopts), add = TRUE)
[17:36:39.588]                   }
[17:36:39.588]                   {
[17:36:39.588]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.588]                       FUN = function(jj) {
[17:36:39.588]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.588]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.588]                       })
[17:36:39.588]                   }
[17:36:39.588]                 }, args = future.call.arguments)
[17:36:39.588]             }))
[17:36:39.588]             future::FutureResult(value = ...future.value$value, 
[17:36:39.588]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.588]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.588]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.588]                     ...future.globalenv.names))
[17:36:39.588]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.588]         }, condition = base::local({
[17:36:39.588]             c <- base::c
[17:36:39.588]             inherits <- base::inherits
[17:36:39.588]             invokeRestart <- base::invokeRestart
[17:36:39.588]             length <- base::length
[17:36:39.588]             list <- base::list
[17:36:39.588]             seq.int <- base::seq.int
[17:36:39.588]             signalCondition <- base::signalCondition
[17:36:39.588]             sys.calls <- base::sys.calls
[17:36:39.588]             `[[` <- base::`[[`
[17:36:39.588]             `+` <- base::`+`
[17:36:39.588]             `<<-` <- base::`<<-`
[17:36:39.588]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.588]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.588]                   3L)]
[17:36:39.588]             }
[17:36:39.588]             function(cond) {
[17:36:39.588]                 is_error <- inherits(cond, "error")
[17:36:39.588]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.588]                   NULL)
[17:36:39.588]                 if (is_error) {
[17:36:39.588]                   sessionInformation <- function() {
[17:36:39.588]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.588]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.588]                       search = base::search(), system = base::Sys.info())
[17:36:39.588]                   }
[17:36:39.588]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.588]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.588]                     cond$call), session = sessionInformation(), 
[17:36:39.588]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.588]                   signalCondition(cond)
[17:36:39.588]                 }
[17:36:39.588]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.588]                 "immediateCondition"))) {
[17:36:39.588]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.588]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.588]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.588]                   if (TRUE && !signal) {
[17:36:39.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.588]                     {
[17:36:39.588]                       inherits <- base::inherits
[17:36:39.588]                       invokeRestart <- base::invokeRestart
[17:36:39.588]                       is.null <- base::is.null
[17:36:39.588]                       muffled <- FALSE
[17:36:39.588]                       if (inherits(cond, "message")) {
[17:36:39.588]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.588]                         if (muffled) 
[17:36:39.588]                           invokeRestart("muffleMessage")
[17:36:39.588]                       }
[17:36:39.588]                       else if (inherits(cond, "warning")) {
[17:36:39.588]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.588]                         if (muffled) 
[17:36:39.588]                           invokeRestart("muffleWarning")
[17:36:39.588]                       }
[17:36:39.588]                       else if (inherits(cond, "condition")) {
[17:36:39.588]                         if (!is.null(pattern)) {
[17:36:39.588]                           computeRestarts <- base::computeRestarts
[17:36:39.588]                           grepl <- base::grepl
[17:36:39.588]                           restarts <- computeRestarts(cond)
[17:36:39.588]                           for (restart in restarts) {
[17:36:39.588]                             name <- restart$name
[17:36:39.588]                             if (is.null(name)) 
[17:36:39.588]                               next
[17:36:39.588]                             if (!grepl(pattern, name)) 
[17:36:39.588]                               next
[17:36:39.588]                             invokeRestart(restart)
[17:36:39.588]                             muffled <- TRUE
[17:36:39.588]                             break
[17:36:39.588]                           }
[17:36:39.588]                         }
[17:36:39.588]                       }
[17:36:39.588]                       invisible(muffled)
[17:36:39.588]                     }
[17:36:39.588]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.588]                   }
[17:36:39.588]                 }
[17:36:39.588]                 else {
[17:36:39.588]                   if (TRUE) {
[17:36:39.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.588]                     {
[17:36:39.588]                       inherits <- base::inherits
[17:36:39.588]                       invokeRestart <- base::invokeRestart
[17:36:39.588]                       is.null <- base::is.null
[17:36:39.588]                       muffled <- FALSE
[17:36:39.588]                       if (inherits(cond, "message")) {
[17:36:39.588]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.588]                         if (muffled) 
[17:36:39.588]                           invokeRestart("muffleMessage")
[17:36:39.588]                       }
[17:36:39.588]                       else if (inherits(cond, "warning")) {
[17:36:39.588]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.588]                         if (muffled) 
[17:36:39.588]                           invokeRestart("muffleWarning")
[17:36:39.588]                       }
[17:36:39.588]                       else if (inherits(cond, "condition")) {
[17:36:39.588]                         if (!is.null(pattern)) {
[17:36:39.588]                           computeRestarts <- base::computeRestarts
[17:36:39.588]                           grepl <- base::grepl
[17:36:39.588]                           restarts <- computeRestarts(cond)
[17:36:39.588]                           for (restart in restarts) {
[17:36:39.588]                             name <- restart$name
[17:36:39.588]                             if (is.null(name)) 
[17:36:39.588]                               next
[17:36:39.588]                             if (!grepl(pattern, name)) 
[17:36:39.588]                               next
[17:36:39.588]                             invokeRestart(restart)
[17:36:39.588]                             muffled <- TRUE
[17:36:39.588]                             break
[17:36:39.588]                           }
[17:36:39.588]                         }
[17:36:39.588]                       }
[17:36:39.588]                       invisible(muffled)
[17:36:39.588]                     }
[17:36:39.588]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.588]                   }
[17:36:39.588]                 }
[17:36:39.588]             }
[17:36:39.588]         }))
[17:36:39.588]     }, error = function(ex) {
[17:36:39.588]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.588]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.588]                 ...future.rng), started = ...future.startTime, 
[17:36:39.588]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.588]             version = "1.8"), class = "FutureResult")
[17:36:39.588]     }, finally = {
[17:36:39.588]         if (!identical(...future.workdir, getwd())) 
[17:36:39.588]             setwd(...future.workdir)
[17:36:39.588]         {
[17:36:39.588]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.588]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.588]             }
[17:36:39.588]             base::options(...future.oldOptions)
[17:36:39.588]             if (.Platform$OS.type == "windows") {
[17:36:39.588]                 old_names <- names(...future.oldEnvVars)
[17:36:39.588]                 envs <- base::Sys.getenv()
[17:36:39.588]                 names <- names(envs)
[17:36:39.588]                 common <- intersect(names, old_names)
[17:36:39.588]                 added <- setdiff(names, old_names)
[17:36:39.588]                 removed <- setdiff(old_names, names)
[17:36:39.588]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.588]                   envs[common]]
[17:36:39.588]                 NAMES <- toupper(changed)
[17:36:39.588]                 args <- list()
[17:36:39.588]                 for (kk in seq_along(NAMES)) {
[17:36:39.588]                   name <- changed[[kk]]
[17:36:39.588]                   NAME <- NAMES[[kk]]
[17:36:39.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.588]                     next
[17:36:39.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.588]                 }
[17:36:39.588]                 NAMES <- toupper(added)
[17:36:39.588]                 for (kk in seq_along(NAMES)) {
[17:36:39.588]                   name <- added[[kk]]
[17:36:39.588]                   NAME <- NAMES[[kk]]
[17:36:39.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.588]                     next
[17:36:39.588]                   args[[name]] <- ""
[17:36:39.588]                 }
[17:36:39.588]                 NAMES <- toupper(removed)
[17:36:39.588]                 for (kk in seq_along(NAMES)) {
[17:36:39.588]                   name <- removed[[kk]]
[17:36:39.588]                   NAME <- NAMES[[kk]]
[17:36:39.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.588]                     next
[17:36:39.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.588]                 }
[17:36:39.588]                 if (length(args) > 0) 
[17:36:39.588]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.588]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.588]             }
[17:36:39.588]             else {
[17:36:39.588]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.588]             }
[17:36:39.588]             {
[17:36:39.588]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.588]                   0L) {
[17:36:39.588]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.588]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.588]                   base::options(opts)
[17:36:39.588]                 }
[17:36:39.588]                 {
[17:36:39.588]                   {
[17:36:39.588]                     NULL
[17:36:39.588]                     RNGkind("Mersenne-Twister")
[17:36:39.588]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.588]                       inherits = FALSE)
[17:36:39.588]                   }
[17:36:39.588]                   options(future.plan = NULL)
[17:36:39.588]                   if (is.na(NA_character_)) 
[17:36:39.588]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.588]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.588]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.588]                     .init = FALSE)
[17:36:39.588]                 }
[17:36:39.588]             }
[17:36:39.588]         }
[17:36:39.588]     })
[17:36:39.588]     if (TRUE) {
[17:36:39.588]         base::sink(type = "output", split = FALSE)
[17:36:39.588]         if (TRUE) {
[17:36:39.588]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.588]         }
[17:36:39.588]         else {
[17:36:39.588]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.588]         }
[17:36:39.588]         base::close(...future.stdout)
[17:36:39.588]         ...future.stdout <- NULL
[17:36:39.588]     }
[17:36:39.588]     ...future.result$conditions <- ...future.conditions
[17:36:39.588]     ...future.result$finished <- base::Sys.time()
[17:36:39.588]     ...future.result
[17:36:39.588] }
[17:36:39.590] assign_globals() ...
[17:36:39.590] List of 5
[17:36:39.590]  $ ...future.FUN            :function (object, ...)  
[17:36:39.590]  $ future.call.arguments    :List of 1
[17:36:39.590]   ..$ digits: int 2
[17:36:39.590]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.590]  $ ...future.elements_ii    :List of 6
[17:36:39.590]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:36:39.590]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:36:39.590]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:36:39.590]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:36:39.590]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:36:39.590]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:36:39.590]  $ ...future.seeds_ii       : NULL
[17:36:39.590]  $ ...future.globals.maxSize: NULL
[17:36:39.590]  - attr(*, "where")=List of 5
[17:36:39.590]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.590]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.590]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.590]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.590]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.590]  - attr(*, "resolved")= logi FALSE
[17:36:39.590]  - attr(*, "total_size")= num 1296
[17:36:39.590]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.590]  - attr(*, "already-done")= logi TRUE
[17:36:39.598] - copied ‘...future.FUN’ to environment
[17:36:39.598] - copied ‘future.call.arguments’ to environment
[17:36:39.598] - copied ‘...future.elements_ii’ to environment
[17:36:39.598] - copied ‘...future.seeds_ii’ to environment
[17:36:39.599] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.599] assign_globals() ... done
[17:36:39.599] plan(): Setting new future strategy stack:
[17:36:39.599] List of future strategies:
[17:36:39.599] 1. sequential:
[17:36:39.599]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.599]    - tweaked: FALSE
[17:36:39.599]    - call: NULL
[17:36:39.599] plan(): nbrOfWorkers() = 1
[17:36:39.601] plan(): Setting new future strategy stack:
[17:36:39.601] List of future strategies:
[17:36:39.601] 1. multicore:
[17:36:39.601]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:39.601]    - tweaked: FALSE
[17:36:39.601]    - call: plan(strategy)
[17:36:39.605] plan(): nbrOfWorkers() = 1
[17:36:39.605] SequentialFuture started (and completed)
[17:36:39.605] - Launch lazy future ... done
[17:36:39.605] run() for ‘SequentialFuture’ ... done
[17:36:39.605] Created future:
[17:36:39.605] SequentialFuture:
[17:36:39.605] Label: ‘future_by-1’
[17:36:39.605] Expression:
[17:36:39.605] {
[17:36:39.605]     do.call(function(...) {
[17:36:39.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.605]             on.exit(options(oopts), add = TRUE)
[17:36:39.605]         }
[17:36:39.605]         {
[17:36:39.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.605]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.605]             })
[17:36:39.605]         }
[17:36:39.605]     }, args = future.call.arguments)
[17:36:39.605] }
[17:36:39.605] Lazy evaluation: FALSE
[17:36:39.605] Asynchronous evaluation: FALSE
[17:36:39.605] Local evaluation: TRUE
[17:36:39.605] Environment: R_GlobalEnv
[17:36:39.605] Capture standard output: TRUE
[17:36:39.605] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.605] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.605] Packages: <none>
[17:36:39.605] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.605] Resolved: TRUE
[17:36:39.605] Value: 5.48 KiB of class ‘list’
[17:36:39.605] Early signaling: FALSE
[17:36:39.605] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.605] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.606] Chunk #1 of 1 ... DONE
[17:36:39.606] Launching 1 futures (chunks) ... DONE
[17:36:39.606] Resolving 1 futures (chunks) ...
[17:36:39.607] resolve() on list ...
[17:36:39.607]  recursive: 0
[17:36:39.607]  length: 1
[17:36:39.607] 
[17:36:39.607] resolved() for ‘SequentialFuture’ ...
[17:36:39.607] - state: ‘finished’
[17:36:39.607] - run: TRUE
[17:36:39.607] - result: ‘FutureResult’
[17:36:39.607] resolved() for ‘SequentialFuture’ ... done
[17:36:39.607] Future #1
[17:36:39.608] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.608] - nx: 1
[17:36:39.608] - relay: TRUE
[17:36:39.608] - stdout: TRUE
[17:36:39.608] - signal: TRUE
[17:36:39.608] - resignal: FALSE
[17:36:39.608] - force: TRUE
[17:36:39.608] - relayed: [n=1] FALSE
[17:36:39.608] - queued futures: [n=1] FALSE
[17:36:39.608]  - until=1
[17:36:39.608]  - relaying element #1
[17:36:39.609] - relayed: [n=1] TRUE
[17:36:39.609] - queued futures: [n=1] TRUE
[17:36:39.609] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.609]  length: 0 (resolved future 1)
[17:36:39.609] Relaying remaining futures
[17:36:39.609] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.609] - nx: 1
[17:36:39.609] - relay: TRUE
[17:36:39.609] - stdout: TRUE
[17:36:39.609] - signal: TRUE
[17:36:39.609] - resignal: FALSE
[17:36:39.610] - force: TRUE
[17:36:39.610] - relayed: [n=1] TRUE
[17:36:39.610] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.610] - relayed: [n=1] TRUE
[17:36:39.610] - queued futures: [n=1] TRUE
[17:36:39.610] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.610] resolve() on list ... DONE
[17:36:39.610]  - Number of value chunks collected: 1
[17:36:39.610] Resolving 1 futures (chunks) ... DONE
[17:36:39.610] Reducing values from 1 chunks ...
[17:36:39.611]  - Number of values collected after concatenation: 6
[17:36:39.611]  - Number of values expected: 6
[17:36:39.611] Reducing values from 1 chunks ... DONE
[17:36:39.611] future_lapply() ... DONE
[17:36:39.611] future_by_internal() ... DONE
[17:36:39.612] future_by_internal() ...
[17:36:39.612] future_lapply() ...
[17:36:39.616] Number of chunks: 1
[17:36:39.616] getGlobalsAndPackagesXApply() ...
[17:36:39.616]  - future.globals: TRUE
[17:36:39.616] getGlobalsAndPackages() ...
[17:36:39.617] Searching for globals...
[17:36:39.620] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:39.620] Searching for globals ... DONE
[17:36:39.620] Resolving globals: FALSE
[17:36:39.620] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:36:39.621] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:36:39.621] - globals: [1] ‘FUN’
[17:36:39.621] - packages: [1] ‘stats’
[17:36:39.621] getGlobalsAndPackages() ... DONE
[17:36:39.621]  - globals found/used: [n=1] ‘FUN’
[17:36:39.621]  - needed namespaces: [n=1] ‘stats’
[17:36:39.621] Finding globals ... DONE
[17:36:39.621]  - use_args: TRUE
[17:36:39.622]  - Getting '...' globals ...
[17:36:39.622] resolve() on list ...
[17:36:39.622]  recursive: 0
[17:36:39.622]  length: 1
[17:36:39.622]  elements: ‘...’
[17:36:39.622]  length: 0 (resolved future 1)
[17:36:39.622] resolve() on list ... DONE
[17:36:39.622]    - '...' content: [n=1] ‘singular.ok’
[17:36:39.623] List of 1
[17:36:39.623]  $ ...:List of 1
[17:36:39.623]   ..$ singular.ok: logi FALSE
[17:36:39.623]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.623]  - attr(*, "where")=List of 1
[17:36:39.623]   ..$ ...:<environment: 0x5622fc484210> 
[17:36:39.623]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.623]  - attr(*, "resolved")= logi TRUE
[17:36:39.623]  - attr(*, "total_size")= num NA
[17:36:39.625]  - Getting '...' globals ... DONE
[17:36:39.626] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.626] List of 2
[17:36:39.626]  $ ...future.FUN:function (x, ...)  
[17:36:39.626]  $ ...          :List of 1
[17:36:39.626]   ..$ singular.ok: logi FALSE
[17:36:39.626]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.626]  - attr(*, "where")=List of 2
[17:36:39.626]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.626]   ..$ ...          :<environment: 0x5622fc484210> 
[17:36:39.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.626]  - attr(*, "resolved")= logi FALSE
[17:36:39.626]  - attr(*, "total_size")= num 5384
[17:36:39.629] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:39.629] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.629] Number of futures (= number of chunks): 1
[17:36:39.629] Launching 1 futures (chunks) ...
[17:36:39.629] Chunk #1 of 1 ...
[17:36:39.629]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.629] getGlobalsAndPackages() ...
[17:36:39.630] Searching for globals...
[17:36:39.630] 
[17:36:39.630] Searching for globals ... DONE
[17:36:39.630] - globals: [0] <none>
[17:36:39.630] getGlobalsAndPackages() ... DONE
[17:36:39.630]    + additional globals found: [n=0] 
[17:36:39.630]    + additional namespaces needed: [n=0] 
[17:36:39.630]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.631]  - seeds: <none>
[17:36:39.631]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.631] getGlobalsAndPackages() ...
[17:36:39.631] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.631] Resolving globals: FALSE
[17:36:39.631] Tweak future expression to call with '...' arguments ...
[17:36:39.631] {
[17:36:39.631]     do.call(function(...) {
[17:36:39.631]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.631]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.631]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.631]             on.exit(options(oopts), add = TRUE)
[17:36:39.631]         }
[17:36:39.631]         {
[17:36:39.631]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.631]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.631]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.631]             })
[17:36:39.631]         }
[17:36:39.631]     }, args = future.call.arguments)
[17:36:39.631] }
[17:36:39.631] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.632] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.632] 
[17:36:39.632] getGlobalsAndPackages() ... DONE
[17:36:39.632] run() for ‘Future’ ...
[17:36:39.632] - state: ‘created’
[17:36:39.633] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:39.636] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.636] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.636]   - Field: ‘label’
[17:36:39.636]   - Field: ‘local’
[17:36:39.636]   - Field: ‘owner’
[17:36:39.637]   - Field: ‘envir’
[17:36:39.637]   - Field: ‘packages’
[17:36:39.637]   - Field: ‘gc’
[17:36:39.637]   - Field: ‘conditions’
[17:36:39.637]   - Field: ‘expr’
[17:36:39.637]   - Field: ‘uuid’
[17:36:39.637]   - Field: ‘seed’
[17:36:39.637]   - Field: ‘version’
[17:36:39.637]   - Field: ‘result’
[17:36:39.637]   - Field: ‘asynchronous’
[17:36:39.637]   - Field: ‘calls’
[17:36:39.638]   - Field: ‘globals’
[17:36:39.638]   - Field: ‘stdout’
[17:36:39.638]   - Field: ‘earlySignal’
[17:36:39.638]   - Field: ‘lazy’
[17:36:39.638]   - Field: ‘state’
[17:36:39.638] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.638] - Launch lazy future ...
[17:36:39.638] Packages needed by the future expression (n = 1): ‘stats’
[17:36:39.638] Packages needed by future strategies (n = 0): <none>
[17:36:39.639] {
[17:36:39.639]     {
[17:36:39.639]         {
[17:36:39.639]             ...future.startTime <- base::Sys.time()
[17:36:39.639]             {
[17:36:39.639]                 {
[17:36:39.639]                   {
[17:36:39.639]                     {
[17:36:39.639]                       base::local({
[17:36:39.639]                         has_future <- base::requireNamespace("future", 
[17:36:39.639]                           quietly = TRUE)
[17:36:39.639]                         if (has_future) {
[17:36:39.639]                           ns <- base::getNamespace("future")
[17:36:39.639]                           version <- ns[[".package"]][["version"]]
[17:36:39.639]                           if (is.null(version)) 
[17:36:39.639]                             version <- utils::packageVersion("future")
[17:36:39.639]                         }
[17:36:39.639]                         else {
[17:36:39.639]                           version <- NULL
[17:36:39.639]                         }
[17:36:39.639]                         if (!has_future || version < "1.8.0") {
[17:36:39.639]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.639]                             "", base::R.version$version.string), 
[17:36:39.639]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:39.639]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.639]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.639]                               "release", "version")], collapse = " "), 
[17:36:39.639]                             hostname = base::Sys.info()[["nodename"]])
[17:36:39.639]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.639]                             info)
[17:36:39.639]                           info <- base::paste(info, collapse = "; ")
[17:36:39.639]                           if (!has_future) {
[17:36:39.639]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.639]                               info)
[17:36:39.639]                           }
[17:36:39.639]                           else {
[17:36:39.639]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.639]                               info, version)
[17:36:39.639]                           }
[17:36:39.639]                           base::stop(msg)
[17:36:39.639]                         }
[17:36:39.639]                       })
[17:36:39.639]                     }
[17:36:39.639]                     base::local({
[17:36:39.639]                       for (pkg in "stats") {
[17:36:39.639]                         base::loadNamespace(pkg)
[17:36:39.639]                         base::library(pkg, character.only = TRUE)
[17:36:39.639]                       }
[17:36:39.639]                     })
[17:36:39.639]                   }
[17:36:39.639]                   ...future.strategy.old <- future::plan("list")
[17:36:39.639]                   options(future.plan = NULL)
[17:36:39.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.639]                 }
[17:36:39.639]                 ...future.workdir <- getwd()
[17:36:39.639]             }
[17:36:39.639]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.639]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.639]         }
[17:36:39.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.639]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.639]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.639]             base::names(...future.oldOptions))
[17:36:39.639]     }
[17:36:39.639]     if (FALSE) {
[17:36:39.639]     }
[17:36:39.639]     else {
[17:36:39.639]         if (TRUE) {
[17:36:39.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.639]                 open = "w")
[17:36:39.639]         }
[17:36:39.639]         else {
[17:36:39.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.639]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.639]         }
[17:36:39.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.639]             base::sink(type = "output", split = FALSE)
[17:36:39.639]             base::close(...future.stdout)
[17:36:39.639]         }, add = TRUE)
[17:36:39.639]     }
[17:36:39.639]     ...future.frame <- base::sys.nframe()
[17:36:39.639]     ...future.conditions <- base::list()
[17:36:39.639]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.639]     if (FALSE) {
[17:36:39.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.639]     }
[17:36:39.639]     ...future.result <- base::tryCatch({
[17:36:39.639]         base::withCallingHandlers({
[17:36:39.639]             ...future.value <- base::withVisible(base::local({
[17:36:39.639]                 do.call(function(...) {
[17:36:39.639]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.639]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.639]                     ...future.globals.maxSize)) {
[17:36:39.639]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.639]                     on.exit(options(oopts), add = TRUE)
[17:36:39.639]                   }
[17:36:39.639]                   {
[17:36:39.639]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.639]                       FUN = function(jj) {
[17:36:39.639]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.639]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.639]                       })
[17:36:39.639]                   }
[17:36:39.639]                 }, args = future.call.arguments)
[17:36:39.639]             }))
[17:36:39.639]             future::FutureResult(value = ...future.value$value, 
[17:36:39.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.639]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.639]                     ...future.globalenv.names))
[17:36:39.639]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.639]         }, condition = base::local({
[17:36:39.639]             c <- base::c
[17:36:39.639]             inherits <- base::inherits
[17:36:39.639]             invokeRestart <- base::invokeRestart
[17:36:39.639]             length <- base::length
[17:36:39.639]             list <- base::list
[17:36:39.639]             seq.int <- base::seq.int
[17:36:39.639]             signalCondition <- base::signalCondition
[17:36:39.639]             sys.calls <- base::sys.calls
[17:36:39.639]             `[[` <- base::`[[`
[17:36:39.639]             `+` <- base::`+`
[17:36:39.639]             `<<-` <- base::`<<-`
[17:36:39.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.639]                   3L)]
[17:36:39.639]             }
[17:36:39.639]             function(cond) {
[17:36:39.639]                 is_error <- inherits(cond, "error")
[17:36:39.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.639]                   NULL)
[17:36:39.639]                 if (is_error) {
[17:36:39.639]                   sessionInformation <- function() {
[17:36:39.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.639]                       search = base::search(), system = base::Sys.info())
[17:36:39.639]                   }
[17:36:39.639]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.639]                     cond$call), session = sessionInformation(), 
[17:36:39.639]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.639]                   signalCondition(cond)
[17:36:39.639]                 }
[17:36:39.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.639]                 "immediateCondition"))) {
[17:36:39.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.639]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.639]                   if (TRUE && !signal) {
[17:36:39.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.639]                     {
[17:36:39.639]                       inherits <- base::inherits
[17:36:39.639]                       invokeRestart <- base::invokeRestart
[17:36:39.639]                       is.null <- base::is.null
[17:36:39.639]                       muffled <- FALSE
[17:36:39.639]                       if (inherits(cond, "message")) {
[17:36:39.639]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.639]                         if (muffled) 
[17:36:39.639]                           invokeRestart("muffleMessage")
[17:36:39.639]                       }
[17:36:39.639]                       else if (inherits(cond, "warning")) {
[17:36:39.639]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.639]                         if (muffled) 
[17:36:39.639]                           invokeRestart("muffleWarning")
[17:36:39.639]                       }
[17:36:39.639]                       else if (inherits(cond, "condition")) {
[17:36:39.639]                         if (!is.null(pattern)) {
[17:36:39.639]                           computeRestarts <- base::computeRestarts
[17:36:39.639]                           grepl <- base::grepl
[17:36:39.639]                           restarts <- computeRestarts(cond)
[17:36:39.639]                           for (restart in restarts) {
[17:36:39.639]                             name <- restart$name
[17:36:39.639]                             if (is.null(name)) 
[17:36:39.639]                               next
[17:36:39.639]                             if (!grepl(pattern, name)) 
[17:36:39.639]                               next
[17:36:39.639]                             invokeRestart(restart)
[17:36:39.639]                             muffled <- TRUE
[17:36:39.639]                             break
[17:36:39.639]                           }
[17:36:39.639]                         }
[17:36:39.639]                       }
[17:36:39.639]                       invisible(muffled)
[17:36:39.639]                     }
[17:36:39.639]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.639]                   }
[17:36:39.639]                 }
[17:36:39.639]                 else {
[17:36:39.639]                   if (TRUE) {
[17:36:39.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.639]                     {
[17:36:39.639]                       inherits <- base::inherits
[17:36:39.639]                       invokeRestart <- base::invokeRestart
[17:36:39.639]                       is.null <- base::is.null
[17:36:39.639]                       muffled <- FALSE
[17:36:39.639]                       if (inherits(cond, "message")) {
[17:36:39.639]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.639]                         if (muffled) 
[17:36:39.639]                           invokeRestart("muffleMessage")
[17:36:39.639]                       }
[17:36:39.639]                       else if (inherits(cond, "warning")) {
[17:36:39.639]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.639]                         if (muffled) 
[17:36:39.639]                           invokeRestart("muffleWarning")
[17:36:39.639]                       }
[17:36:39.639]                       else if (inherits(cond, "condition")) {
[17:36:39.639]                         if (!is.null(pattern)) {
[17:36:39.639]                           computeRestarts <- base::computeRestarts
[17:36:39.639]                           grepl <- base::grepl
[17:36:39.639]                           restarts <- computeRestarts(cond)
[17:36:39.639]                           for (restart in restarts) {
[17:36:39.639]                             name <- restart$name
[17:36:39.639]                             if (is.null(name)) 
[17:36:39.639]                               next
[17:36:39.639]                             if (!grepl(pattern, name)) 
[17:36:39.639]                               next
[17:36:39.639]                             invokeRestart(restart)
[17:36:39.639]                             muffled <- TRUE
[17:36:39.639]                             break
[17:36:39.639]                           }
[17:36:39.639]                         }
[17:36:39.639]                       }
[17:36:39.639]                       invisible(muffled)
[17:36:39.639]                     }
[17:36:39.639]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.639]                   }
[17:36:39.639]                 }
[17:36:39.639]             }
[17:36:39.639]         }))
[17:36:39.639]     }, error = function(ex) {
[17:36:39.639]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.639]                 ...future.rng), started = ...future.startTime, 
[17:36:39.639]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.639]             version = "1.8"), class = "FutureResult")
[17:36:39.639]     }, finally = {
[17:36:39.639]         if (!identical(...future.workdir, getwd())) 
[17:36:39.639]             setwd(...future.workdir)
[17:36:39.639]         {
[17:36:39.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.639]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.639]             }
[17:36:39.639]             base::options(...future.oldOptions)
[17:36:39.639]             if (.Platform$OS.type == "windows") {
[17:36:39.639]                 old_names <- names(...future.oldEnvVars)
[17:36:39.639]                 envs <- base::Sys.getenv()
[17:36:39.639]                 names <- names(envs)
[17:36:39.639]                 common <- intersect(names, old_names)
[17:36:39.639]                 added <- setdiff(names, old_names)
[17:36:39.639]                 removed <- setdiff(old_names, names)
[17:36:39.639]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.639]                   envs[common]]
[17:36:39.639]                 NAMES <- toupper(changed)
[17:36:39.639]                 args <- list()
[17:36:39.639]                 for (kk in seq_along(NAMES)) {
[17:36:39.639]                   name <- changed[[kk]]
[17:36:39.639]                   NAME <- NAMES[[kk]]
[17:36:39.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.639]                     next
[17:36:39.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.639]                 }
[17:36:39.639]                 NAMES <- toupper(added)
[17:36:39.639]                 for (kk in seq_along(NAMES)) {
[17:36:39.639]                   name <- added[[kk]]
[17:36:39.639]                   NAME <- NAMES[[kk]]
[17:36:39.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.639]                     next
[17:36:39.639]                   args[[name]] <- ""
[17:36:39.639]                 }
[17:36:39.639]                 NAMES <- toupper(removed)
[17:36:39.639]                 for (kk in seq_along(NAMES)) {
[17:36:39.639]                   name <- removed[[kk]]
[17:36:39.639]                   NAME <- NAMES[[kk]]
[17:36:39.639]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.639]                     next
[17:36:39.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.639]                 }
[17:36:39.639]                 if (length(args) > 0) 
[17:36:39.639]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.639]             }
[17:36:39.639]             else {
[17:36:39.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.639]             }
[17:36:39.639]             {
[17:36:39.639]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.639]                   0L) {
[17:36:39.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.639]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.639]                   base::options(opts)
[17:36:39.639]                 }
[17:36:39.639]                 {
[17:36:39.639]                   {
[17:36:39.639]                     NULL
[17:36:39.639]                     RNGkind("Mersenne-Twister")
[17:36:39.639]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.639]                       inherits = FALSE)
[17:36:39.639]                   }
[17:36:39.639]                   options(future.plan = NULL)
[17:36:39.639]                   if (is.na(NA_character_)) 
[17:36:39.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.639]                     .init = FALSE)
[17:36:39.639]                 }
[17:36:39.639]             }
[17:36:39.639]         }
[17:36:39.639]     })
[17:36:39.639]     if (TRUE) {
[17:36:39.639]         base::sink(type = "output", split = FALSE)
[17:36:39.639]         if (TRUE) {
[17:36:39.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.639]         }
[17:36:39.639]         else {
[17:36:39.639]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.639]         }
[17:36:39.639]         base::close(...future.stdout)
[17:36:39.639]         ...future.stdout <- NULL
[17:36:39.639]     }
[17:36:39.639]     ...future.result$conditions <- ...future.conditions
[17:36:39.639]     ...future.result$finished <- base::Sys.time()
[17:36:39.639]     ...future.result
[17:36:39.639] }
[17:36:39.641] assign_globals() ...
[17:36:39.641] List of 5
[17:36:39.641]  $ ...future.FUN            :function (x, ...)  
[17:36:39.641]  $ future.call.arguments    :List of 1
[17:36:39.641]   ..$ singular.ok: logi FALSE
[17:36:39.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.641]  $ ...future.elements_ii    :List of 3
[17:36:39.641]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.641]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:39.641]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.641]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.641]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.641]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:39.641]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.641]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:39.641]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.641]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:39.641]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.641]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:39.641]  $ ...future.seeds_ii       : NULL
[17:36:39.641]  $ ...future.globals.maxSize: NULL
[17:36:39.641]  - attr(*, "where")=List of 5
[17:36:39.641]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.641]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.641]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.641]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.641]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.641]  - attr(*, "resolved")= logi FALSE
[17:36:39.641]  - attr(*, "total_size")= num 5384
[17:36:39.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.641]  - attr(*, "already-done")= logi TRUE
[17:36:39.679] - reassign environment for ‘...future.FUN’
[17:36:39.679] - copied ‘...future.FUN’ to environment
[17:36:39.680] - copied ‘future.call.arguments’ to environment
[17:36:39.680] - copied ‘...future.elements_ii’ to environment
[17:36:39.680] - copied ‘...future.seeds_ii’ to environment
[17:36:39.680] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.680] assign_globals() ... done
[17:36:39.680] plan(): Setting new future strategy stack:
[17:36:39.680] List of future strategies:
[17:36:39.680] 1. sequential:
[17:36:39.680]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.680]    - tweaked: FALSE
[17:36:39.680]    - call: NULL
[17:36:39.681] plan(): nbrOfWorkers() = 1
[17:36:39.684] plan(): Setting new future strategy stack:
[17:36:39.684] List of future strategies:
[17:36:39.684] 1. multicore:
[17:36:39.684]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:39.684]    - tweaked: FALSE
[17:36:39.684]    - call: plan(strategy)
[17:36:39.687] plan(): nbrOfWorkers() = 1
[17:36:39.688] SequentialFuture started (and completed)
[17:36:39.688] - Launch lazy future ... done
[17:36:39.688] run() for ‘SequentialFuture’ ... done
[17:36:39.688] Created future:
[17:36:39.688] SequentialFuture:
[17:36:39.688] Label: ‘future_by-1’
[17:36:39.688] Expression:
[17:36:39.688] {
[17:36:39.688]     do.call(function(...) {
[17:36:39.688]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.688]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.688]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.688]             on.exit(options(oopts), add = TRUE)
[17:36:39.688]         }
[17:36:39.688]         {
[17:36:39.688]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.688]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.688]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.688]             })
[17:36:39.688]         }
[17:36:39.688]     }, args = future.call.arguments)
[17:36:39.688] }
[17:36:39.688] Lazy evaluation: FALSE
[17:36:39.688] Asynchronous evaluation: FALSE
[17:36:39.688] Local evaluation: TRUE
[17:36:39.688] Environment: R_GlobalEnv
[17:36:39.688] Capture standard output: TRUE
[17:36:39.688] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.688] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.688] Packages: 1 packages (‘stats’)
[17:36:39.688] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.688] Resolved: TRUE
[17:36:39.688] Value: 26.06 KiB of class ‘list’
[17:36:39.688] Early signaling: FALSE
[17:36:39.688] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.688] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.690] Chunk #1 of 1 ... DONE
[17:36:39.690] Launching 1 futures (chunks) ... DONE
[17:36:39.690] Resolving 1 futures (chunks) ...
[17:36:39.690] resolve() on list ...
[17:36:39.690]  recursive: 0
[17:36:39.690]  length: 1
[17:36:39.690] 
[17:36:39.690] resolved() for ‘SequentialFuture’ ...
[17:36:39.690] - state: ‘finished’
[17:36:39.691] - run: TRUE
[17:36:39.691] - result: ‘FutureResult’
[17:36:39.691] resolved() for ‘SequentialFuture’ ... done
[17:36:39.691] Future #1
[17:36:39.691] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.691] - nx: 1
[17:36:39.691] - relay: TRUE
[17:36:39.691] - stdout: TRUE
[17:36:39.691] - signal: TRUE
[17:36:39.691] - resignal: FALSE
[17:36:39.691] - force: TRUE
[17:36:39.692] - relayed: [n=1] FALSE
[17:36:39.692] - queued futures: [n=1] FALSE
[17:36:39.692]  - until=1
[17:36:39.692]  - relaying element #1
[17:36:39.692] - relayed: [n=1] TRUE
[17:36:39.692] - queued futures: [n=1] TRUE
[17:36:39.692] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.692]  length: 0 (resolved future 1)
[17:36:39.692] Relaying remaining futures
[17:36:39.693] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.693] - nx: 1
[17:36:39.693] - relay: TRUE
[17:36:39.693] - stdout: TRUE
[17:36:39.693] - signal: TRUE
[17:36:39.693] - resignal: FALSE
[17:36:39.693] - force: TRUE
[17:36:39.693] - relayed: [n=1] TRUE
[17:36:39.693] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.693] - relayed: [n=1] TRUE
[17:36:39.693] - queued futures: [n=1] TRUE
[17:36:39.694] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.694] resolve() on list ... DONE
[17:36:39.694]  - Number of value chunks collected: 1
[17:36:39.694] Resolving 1 futures (chunks) ... DONE
[17:36:39.694] Reducing values from 1 chunks ...
[17:36:39.694]  - Number of values collected after concatenation: 3
[17:36:39.694]  - Number of values expected: 3
[17:36:39.694] Reducing values from 1 chunks ... DONE
[17:36:39.694] future_lapply() ... DONE
[17:36:39.694] future_by_internal() ... DONE
[17:36:39.700] future_by_internal() ...
[17:36:39.700] future_lapply() ...
[17:36:39.704] Number of chunks: 1
[17:36:39.704] getGlobalsAndPackagesXApply() ...
[17:36:39.705]  - future.globals: TRUE
[17:36:39.705] getGlobalsAndPackages() ...
[17:36:39.705] Searching for globals...
[17:36:39.707] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:39.707] Searching for globals ... DONE
[17:36:39.707] Resolving globals: FALSE
[17:36:39.707] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:36:39.708] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:36:39.708] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:39.708] - packages: [1] ‘stats’
[17:36:39.708] getGlobalsAndPackages() ... DONE
[17:36:39.708]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:39.709]  - needed namespaces: [n=1] ‘stats’
[17:36:39.709] Finding globals ... DONE
[17:36:39.709]  - use_args: TRUE
[17:36:39.709]  - Getting '...' globals ...
[17:36:39.709] resolve() on list ...
[17:36:39.709]  recursive: 0
[17:36:39.709]  length: 1
[17:36:39.709]  elements: ‘...’
[17:36:39.710]  length: 0 (resolved future 1)
[17:36:39.710] resolve() on list ... DONE
[17:36:39.710]    - '...' content: [n=0] 
[17:36:39.710] List of 1
[17:36:39.710]  $ ...: list()
[17:36:39.710]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.710]  - attr(*, "where")=List of 1
[17:36:39.710]   ..$ ...:<environment: 0x5622fac1fcd8> 
[17:36:39.710]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.710]  - attr(*, "resolved")= logi TRUE
[17:36:39.710]  - attr(*, "total_size")= num NA
[17:36:39.713]  - Getting '...' globals ... DONE
[17:36:39.713] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:36:39.713] List of 4
[17:36:39.713]  $ ...future.FUN:function (x)  
[17:36:39.713]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:39.713]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.713]  $ ...          : list()
[17:36:39.713]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.713]  - attr(*, "where")=List of 4
[17:36:39.713]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.713]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:36:39.713]   ..$ wool         :<environment: R_EmptyEnv> 
[17:36:39.713]   ..$ ...          :<environment: 0x5622fac1fcd8> 
[17:36:39.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.713]  - attr(*, "resolved")= logi FALSE
[17:36:39.713]  - attr(*, "total_size")= num 2320
[17:36:39.717] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:39.717] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.717] Number of futures (= number of chunks): 1
[17:36:39.717] Launching 1 futures (chunks) ...
[17:36:39.717] Chunk #1 of 1 ...
[17:36:39.717]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.717] getGlobalsAndPackages() ...
[17:36:39.718] Searching for globals...
[17:36:39.718] 
[17:36:39.718] Searching for globals ... DONE
[17:36:39.718] - globals: [0] <none>
[17:36:39.718] getGlobalsAndPackages() ... DONE
[17:36:39.718]    + additional globals found: [n=0] 
[17:36:39.718]    + additional namespaces needed: [n=0] 
[17:36:39.719]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.719]  - seeds: <none>
[17:36:39.719]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.719] getGlobalsAndPackages() ...
[17:36:39.719] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.719] Resolving globals: FALSE
[17:36:39.719] Tweak future expression to call with '...' arguments ...
[17:36:39.719] {
[17:36:39.719]     do.call(function(...) {
[17:36:39.719]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.719]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.719]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.719]             on.exit(options(oopts), add = TRUE)
[17:36:39.719]         }
[17:36:39.719]         {
[17:36:39.719]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.719]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.719]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.719]             })
[17:36:39.719]         }
[17:36:39.719]     }, args = future.call.arguments)
[17:36:39.719] }
[17:36:39.720] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.720] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.720] 
[17:36:39.720] getGlobalsAndPackages() ... DONE
[17:36:39.722] run() for ‘Future’ ...
[17:36:39.722] - state: ‘created’
[17:36:39.722] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:39.726] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.727]   - Field: ‘label’
[17:36:39.727]   - Field: ‘local’
[17:36:39.727]   - Field: ‘owner’
[17:36:39.727]   - Field: ‘envir’
[17:36:39.727]   - Field: ‘packages’
[17:36:39.727]   - Field: ‘gc’
[17:36:39.727]   - Field: ‘conditions’
[17:36:39.728]   - Field: ‘expr’
[17:36:39.728]   - Field: ‘uuid’
[17:36:39.728]   - Field: ‘seed’
[17:36:39.728]   - Field: ‘version’
[17:36:39.728]   - Field: ‘result’
[17:36:39.728]   - Field: ‘asynchronous’
[17:36:39.728]   - Field: ‘calls’
[17:36:39.728]   - Field: ‘globals’
[17:36:39.728]   - Field: ‘stdout’
[17:36:39.728]   - Field: ‘earlySignal’
[17:36:39.729]   - Field: ‘lazy’
[17:36:39.729]   - Field: ‘state’
[17:36:39.729] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.729] - Launch lazy future ...
[17:36:39.729] Packages needed by the future expression (n = 1): ‘stats’
[17:36:39.729] Packages needed by future strategies (n = 0): <none>
[17:36:39.730] {
[17:36:39.730]     {
[17:36:39.730]         {
[17:36:39.730]             ...future.startTime <- base::Sys.time()
[17:36:39.730]             {
[17:36:39.730]                 {
[17:36:39.730]                   {
[17:36:39.730]                     {
[17:36:39.730]                       base::local({
[17:36:39.730]                         has_future <- base::requireNamespace("future", 
[17:36:39.730]                           quietly = TRUE)
[17:36:39.730]                         if (has_future) {
[17:36:39.730]                           ns <- base::getNamespace("future")
[17:36:39.730]                           version <- ns[[".package"]][["version"]]
[17:36:39.730]                           if (is.null(version)) 
[17:36:39.730]                             version <- utils::packageVersion("future")
[17:36:39.730]                         }
[17:36:39.730]                         else {
[17:36:39.730]                           version <- NULL
[17:36:39.730]                         }
[17:36:39.730]                         if (!has_future || version < "1.8.0") {
[17:36:39.730]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.730]                             "", base::R.version$version.string), 
[17:36:39.730]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:39.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.730]                               "release", "version")], collapse = " "), 
[17:36:39.730]                             hostname = base::Sys.info()[["nodename"]])
[17:36:39.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.730]                             info)
[17:36:39.730]                           info <- base::paste(info, collapse = "; ")
[17:36:39.730]                           if (!has_future) {
[17:36:39.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.730]                               info)
[17:36:39.730]                           }
[17:36:39.730]                           else {
[17:36:39.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.730]                               info, version)
[17:36:39.730]                           }
[17:36:39.730]                           base::stop(msg)
[17:36:39.730]                         }
[17:36:39.730]                       })
[17:36:39.730]                     }
[17:36:39.730]                     base::local({
[17:36:39.730]                       for (pkg in "stats") {
[17:36:39.730]                         base::loadNamespace(pkg)
[17:36:39.730]                         base::library(pkg, character.only = TRUE)
[17:36:39.730]                       }
[17:36:39.730]                     })
[17:36:39.730]                   }
[17:36:39.730]                   ...future.strategy.old <- future::plan("list")
[17:36:39.730]                   options(future.plan = NULL)
[17:36:39.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.730]                 }
[17:36:39.730]                 ...future.workdir <- getwd()
[17:36:39.730]             }
[17:36:39.730]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.730]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.730]         }
[17:36:39.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.730]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.730]             base::names(...future.oldOptions))
[17:36:39.730]     }
[17:36:39.730]     if (FALSE) {
[17:36:39.730]     }
[17:36:39.730]     else {
[17:36:39.730]         if (TRUE) {
[17:36:39.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.730]                 open = "w")
[17:36:39.730]         }
[17:36:39.730]         else {
[17:36:39.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.730]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.730]         }
[17:36:39.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.730]             base::sink(type = "output", split = FALSE)
[17:36:39.730]             base::close(...future.stdout)
[17:36:39.730]         }, add = TRUE)
[17:36:39.730]     }
[17:36:39.730]     ...future.frame <- base::sys.nframe()
[17:36:39.730]     ...future.conditions <- base::list()
[17:36:39.730]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.730]     if (FALSE) {
[17:36:39.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.730]     }
[17:36:39.730]     ...future.result <- base::tryCatch({
[17:36:39.730]         base::withCallingHandlers({
[17:36:39.730]             ...future.value <- base::withVisible(base::local({
[17:36:39.730]                 do.call(function(...) {
[17:36:39.730]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.730]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.730]                     ...future.globals.maxSize)) {
[17:36:39.730]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.730]                     on.exit(options(oopts), add = TRUE)
[17:36:39.730]                   }
[17:36:39.730]                   {
[17:36:39.730]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.730]                       FUN = function(jj) {
[17:36:39.730]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.730]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.730]                       })
[17:36:39.730]                   }
[17:36:39.730]                 }, args = future.call.arguments)
[17:36:39.730]             }))
[17:36:39.730]             future::FutureResult(value = ...future.value$value, 
[17:36:39.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.730]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.730]                     ...future.globalenv.names))
[17:36:39.730]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.730]         }, condition = base::local({
[17:36:39.730]             c <- base::c
[17:36:39.730]             inherits <- base::inherits
[17:36:39.730]             invokeRestart <- base::invokeRestart
[17:36:39.730]             length <- base::length
[17:36:39.730]             list <- base::list
[17:36:39.730]             seq.int <- base::seq.int
[17:36:39.730]             signalCondition <- base::signalCondition
[17:36:39.730]             sys.calls <- base::sys.calls
[17:36:39.730]             `[[` <- base::`[[`
[17:36:39.730]             `+` <- base::`+`
[17:36:39.730]             `<<-` <- base::`<<-`
[17:36:39.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.730]                   3L)]
[17:36:39.730]             }
[17:36:39.730]             function(cond) {
[17:36:39.730]                 is_error <- inherits(cond, "error")
[17:36:39.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.730]                   NULL)
[17:36:39.730]                 if (is_error) {
[17:36:39.730]                   sessionInformation <- function() {
[17:36:39.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.730]                       search = base::search(), system = base::Sys.info())
[17:36:39.730]                   }
[17:36:39.730]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.730]                     cond$call), session = sessionInformation(), 
[17:36:39.730]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.730]                   signalCondition(cond)
[17:36:39.730]                 }
[17:36:39.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.730]                 "immediateCondition"))) {
[17:36:39.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.730]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.730]                   if (TRUE && !signal) {
[17:36:39.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.730]                     {
[17:36:39.730]                       inherits <- base::inherits
[17:36:39.730]                       invokeRestart <- base::invokeRestart
[17:36:39.730]                       is.null <- base::is.null
[17:36:39.730]                       muffled <- FALSE
[17:36:39.730]                       if (inherits(cond, "message")) {
[17:36:39.730]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.730]                         if (muffled) 
[17:36:39.730]                           invokeRestart("muffleMessage")
[17:36:39.730]                       }
[17:36:39.730]                       else if (inherits(cond, "warning")) {
[17:36:39.730]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.730]                         if (muffled) 
[17:36:39.730]                           invokeRestart("muffleWarning")
[17:36:39.730]                       }
[17:36:39.730]                       else if (inherits(cond, "condition")) {
[17:36:39.730]                         if (!is.null(pattern)) {
[17:36:39.730]                           computeRestarts <- base::computeRestarts
[17:36:39.730]                           grepl <- base::grepl
[17:36:39.730]                           restarts <- computeRestarts(cond)
[17:36:39.730]                           for (restart in restarts) {
[17:36:39.730]                             name <- restart$name
[17:36:39.730]                             if (is.null(name)) 
[17:36:39.730]                               next
[17:36:39.730]                             if (!grepl(pattern, name)) 
[17:36:39.730]                               next
[17:36:39.730]                             invokeRestart(restart)
[17:36:39.730]                             muffled <- TRUE
[17:36:39.730]                             break
[17:36:39.730]                           }
[17:36:39.730]                         }
[17:36:39.730]                       }
[17:36:39.730]                       invisible(muffled)
[17:36:39.730]                     }
[17:36:39.730]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.730]                   }
[17:36:39.730]                 }
[17:36:39.730]                 else {
[17:36:39.730]                   if (TRUE) {
[17:36:39.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.730]                     {
[17:36:39.730]                       inherits <- base::inherits
[17:36:39.730]                       invokeRestart <- base::invokeRestart
[17:36:39.730]                       is.null <- base::is.null
[17:36:39.730]                       muffled <- FALSE
[17:36:39.730]                       if (inherits(cond, "message")) {
[17:36:39.730]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.730]                         if (muffled) 
[17:36:39.730]                           invokeRestart("muffleMessage")
[17:36:39.730]                       }
[17:36:39.730]                       else if (inherits(cond, "warning")) {
[17:36:39.730]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.730]                         if (muffled) 
[17:36:39.730]                           invokeRestart("muffleWarning")
[17:36:39.730]                       }
[17:36:39.730]                       else if (inherits(cond, "condition")) {
[17:36:39.730]                         if (!is.null(pattern)) {
[17:36:39.730]                           computeRestarts <- base::computeRestarts
[17:36:39.730]                           grepl <- base::grepl
[17:36:39.730]                           restarts <- computeRestarts(cond)
[17:36:39.730]                           for (restart in restarts) {
[17:36:39.730]                             name <- restart$name
[17:36:39.730]                             if (is.null(name)) 
[17:36:39.730]                               next
[17:36:39.730]                             if (!grepl(pattern, name)) 
[17:36:39.730]                               next
[17:36:39.730]                             invokeRestart(restart)
[17:36:39.730]                             muffled <- TRUE
[17:36:39.730]                             break
[17:36:39.730]                           }
[17:36:39.730]                         }
[17:36:39.730]                       }
[17:36:39.730]                       invisible(muffled)
[17:36:39.730]                     }
[17:36:39.730]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.730]                   }
[17:36:39.730]                 }
[17:36:39.730]             }
[17:36:39.730]         }))
[17:36:39.730]     }, error = function(ex) {
[17:36:39.730]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.730]                 ...future.rng), started = ...future.startTime, 
[17:36:39.730]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.730]             version = "1.8"), class = "FutureResult")
[17:36:39.730]     }, finally = {
[17:36:39.730]         if (!identical(...future.workdir, getwd())) 
[17:36:39.730]             setwd(...future.workdir)
[17:36:39.730]         {
[17:36:39.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.730]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.730]             }
[17:36:39.730]             base::options(...future.oldOptions)
[17:36:39.730]             if (.Platform$OS.type == "windows") {
[17:36:39.730]                 old_names <- names(...future.oldEnvVars)
[17:36:39.730]                 envs <- base::Sys.getenv()
[17:36:39.730]                 names <- names(envs)
[17:36:39.730]                 common <- intersect(names, old_names)
[17:36:39.730]                 added <- setdiff(names, old_names)
[17:36:39.730]                 removed <- setdiff(old_names, names)
[17:36:39.730]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.730]                   envs[common]]
[17:36:39.730]                 NAMES <- toupper(changed)
[17:36:39.730]                 args <- list()
[17:36:39.730]                 for (kk in seq_along(NAMES)) {
[17:36:39.730]                   name <- changed[[kk]]
[17:36:39.730]                   NAME <- NAMES[[kk]]
[17:36:39.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.730]                     next
[17:36:39.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.730]                 }
[17:36:39.730]                 NAMES <- toupper(added)
[17:36:39.730]                 for (kk in seq_along(NAMES)) {
[17:36:39.730]                   name <- added[[kk]]
[17:36:39.730]                   NAME <- NAMES[[kk]]
[17:36:39.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.730]                     next
[17:36:39.730]                   args[[name]] <- ""
[17:36:39.730]                 }
[17:36:39.730]                 NAMES <- toupper(removed)
[17:36:39.730]                 for (kk in seq_along(NAMES)) {
[17:36:39.730]                   name <- removed[[kk]]
[17:36:39.730]                   NAME <- NAMES[[kk]]
[17:36:39.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.730]                     next
[17:36:39.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.730]                 }
[17:36:39.730]                 if (length(args) > 0) 
[17:36:39.730]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.730]             }
[17:36:39.730]             else {
[17:36:39.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.730]             }
[17:36:39.730]             {
[17:36:39.730]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.730]                   0L) {
[17:36:39.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.730]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.730]                   base::options(opts)
[17:36:39.730]                 }
[17:36:39.730]                 {
[17:36:39.730]                   {
[17:36:39.730]                     NULL
[17:36:39.730]                     RNGkind("Mersenne-Twister")
[17:36:39.730]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.730]                       inherits = FALSE)
[17:36:39.730]                   }
[17:36:39.730]                   options(future.plan = NULL)
[17:36:39.730]                   if (is.na(NA_character_)) 
[17:36:39.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.730]                     .init = FALSE)
[17:36:39.730]                 }
[17:36:39.730]             }
[17:36:39.730]         }
[17:36:39.730]     })
[17:36:39.730]     if (TRUE) {
[17:36:39.730]         base::sink(type = "output", split = FALSE)
[17:36:39.730]         if (TRUE) {
[17:36:39.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.730]         }
[17:36:39.730]         else {
[17:36:39.730]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.730]         }
[17:36:39.730]         base::close(...future.stdout)
[17:36:39.730]         ...future.stdout <- NULL
[17:36:39.730]     }
[17:36:39.730]     ...future.result$conditions <- ...future.conditions
[17:36:39.730]     ...future.result$finished <- base::Sys.time()
[17:36:39.730]     ...future.result
[17:36:39.730] }
[17:36:39.732] assign_globals() ...
[17:36:39.732] List of 7
[17:36:39.732]  $ ...future.FUN            :function (x)  
[17:36:39.732]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:39.732]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.732]  $ future.call.arguments    : list()
[17:36:39.732]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.732]  $ ...future.elements_ii    :List of 3
[17:36:39.732]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.732]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:39.732]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.732]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.732]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.732]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:39.732]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.732]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:39.732]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.732]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:39.732]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.732]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:39.732]  $ ...future.seeds_ii       : NULL
[17:36:39.732]  $ ...future.globals.maxSize: NULL
[17:36:39.732]  - attr(*, "where")=List of 7
[17:36:39.732]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.732]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:36:39.732]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:36:39.732]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.732]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.732]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.732]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.732]  - attr(*, "resolved")= logi FALSE
[17:36:39.732]  - attr(*, "total_size")= num 2320
[17:36:39.732]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.732]  - attr(*, "already-done")= logi TRUE
[17:36:39.742] - reassign environment for ‘...future.FUN’
[17:36:39.742] - copied ‘...future.FUN’ to environment
[17:36:39.742] - copied ‘breaks’ to environment
[17:36:39.742] - copied ‘wool’ to environment
[17:36:39.742] - copied ‘future.call.arguments’ to environment
[17:36:39.742] - copied ‘...future.elements_ii’ to environment
[17:36:39.742] - copied ‘...future.seeds_ii’ to environment
[17:36:39.742] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.742] assign_globals() ... done
[17:36:39.743] plan(): Setting new future strategy stack:
[17:36:39.743] List of future strategies:
[17:36:39.743] 1. sequential:
[17:36:39.743]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.743]    - tweaked: FALSE
[17:36:39.743]    - call: NULL
[17:36:39.743] plan(): nbrOfWorkers() = 1
[17:36:39.746] plan(): Setting new future strategy stack:
[17:36:39.746] List of future strategies:
[17:36:39.746] 1. multicore:
[17:36:39.746]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:39.746]    - tweaked: FALSE
[17:36:39.746]    - call: plan(strategy)
[17:36:39.751] plan(): nbrOfWorkers() = 1
[17:36:39.751] SequentialFuture started (and completed)
[17:36:39.751] - Launch lazy future ... done
[17:36:39.751] run() for ‘SequentialFuture’ ... done
[17:36:39.751] Created future:
[17:36:39.752] SequentialFuture:
[17:36:39.752] Label: ‘future_by-1’
[17:36:39.752] Expression:
[17:36:39.752] {
[17:36:39.752]     do.call(function(...) {
[17:36:39.752]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.752]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.752]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.752]             on.exit(options(oopts), add = TRUE)
[17:36:39.752]         }
[17:36:39.752]         {
[17:36:39.752]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.752]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.752]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.752]             })
[17:36:39.752]         }
[17:36:39.752]     }, args = future.call.arguments)
[17:36:39.752] }
[17:36:39.752] Lazy evaluation: FALSE
[17:36:39.752] Asynchronous evaluation: FALSE
[17:36:39.752] Local evaluation: TRUE
[17:36:39.752] Environment: 0x5622fade6d70
[17:36:39.752] Capture standard output: TRUE
[17:36:39.752] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.752] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:36:39.752] Packages: 1 packages (‘stats’)
[17:36:39.752] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.752] Resolved: TRUE
[17:36:39.752] Value: 25.57 KiB of class ‘list’
[17:36:39.752] Early signaling: FALSE
[17:36:39.752] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.752] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.755] Chunk #1 of 1 ... DONE
[17:36:39.755] Launching 1 futures (chunks) ... DONE
[17:36:39.755] Resolving 1 futures (chunks) ...
[17:36:39.756] resolve() on list ...
[17:36:39.756]  recursive: 0
[17:36:39.756]  length: 1
[17:36:39.756] 
[17:36:39.756] resolved() for ‘SequentialFuture’ ...
[17:36:39.756] - state: ‘finished’
[17:36:39.756] - run: TRUE
[17:36:39.756] - result: ‘FutureResult’
[17:36:39.757] resolved() for ‘SequentialFuture’ ... done
[17:36:39.757] Future #1
[17:36:39.757] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.757] - nx: 1
[17:36:39.757] - relay: TRUE
[17:36:39.757] - stdout: TRUE
[17:36:39.757] - signal: TRUE
[17:36:39.757] - resignal: FALSE
[17:36:39.758] - force: TRUE
[17:36:39.758] - relayed: [n=1] FALSE
[17:36:39.758] - queued futures: [n=1] FALSE
[17:36:39.758]  - until=1
[17:36:39.758]  - relaying element #1
[17:36:39.758] - relayed: [n=1] TRUE
[17:36:39.758] - queued futures: [n=1] TRUE
[17:36:39.758] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.758]  length: 0 (resolved future 1)
[17:36:39.759] Relaying remaining futures
[17:36:39.759] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.759] - nx: 1
[17:36:39.759] - relay: TRUE
[17:36:39.759] - stdout: TRUE
[17:36:39.759] - signal: TRUE
[17:36:39.759] - resignal: FALSE
[17:36:39.759] - force: TRUE
[17:36:39.759] - relayed: [n=1] TRUE
[17:36:39.759] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.759] - relayed: [n=1] TRUE
[17:36:39.760] - queued futures: [n=1] TRUE
[17:36:39.760] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.760] resolve() on list ... DONE
[17:36:39.760]  - Number of value chunks collected: 1
[17:36:39.760] Resolving 1 futures (chunks) ... DONE
[17:36:39.760] Reducing values from 1 chunks ...
[17:36:39.760]  - Number of values collected after concatenation: 3
[17:36:39.760]  - Number of values expected: 3
[17:36:39.760] Reducing values from 1 chunks ... DONE
[17:36:39.760] future_lapply() ... DONE
[17:36:39.761] future_by_internal() ... DONE
[17:36:39.761] future_by_internal() ...
[17:36:39.761] future_lapply() ...
[17:36:39.765] Number of chunks: 1
[17:36:39.765] getGlobalsAndPackagesXApply() ...
[17:36:39.765]  - future.globals: TRUE
[17:36:39.765] getGlobalsAndPackages() ...
[17:36:39.766] Searching for globals...
[17:36:39.767] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:39.767] Searching for globals ... DONE
[17:36:39.767] Resolving globals: FALSE
[17:36:39.767] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:39.768] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:39.768] - globals: [1] ‘FUN’
[17:36:39.768] 
[17:36:39.768] getGlobalsAndPackages() ... DONE
[17:36:39.768]  - globals found/used: [n=1] ‘FUN’
[17:36:39.768]  - needed namespaces: [n=0] 
[17:36:39.768] Finding globals ... DONE
[17:36:39.768]  - use_args: TRUE
[17:36:39.768]  - Getting '...' globals ...
[17:36:39.769] resolve() on list ...
[17:36:39.769]  recursive: 0
[17:36:39.769]  length: 1
[17:36:39.769]  elements: ‘...’
[17:36:39.769]  length: 0 (resolved future 1)
[17:36:39.769] resolve() on list ... DONE
[17:36:39.769]    - '...' content: [n=0] 
[17:36:39.769] List of 1
[17:36:39.769]  $ ...: list()
[17:36:39.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.769]  - attr(*, "where")=List of 1
[17:36:39.769]   ..$ ...:<environment: 0x5622fad808f0> 
[17:36:39.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.769]  - attr(*, "resolved")= logi TRUE
[17:36:39.769]  - attr(*, "total_size")= num NA
[17:36:39.772]  - Getting '...' globals ... DONE
[17:36:39.772] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.772] List of 2
[17:36:39.772]  $ ...future.FUN:function (object, ...)  
[17:36:39.772]  $ ...          : list()
[17:36:39.772]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.772]  - attr(*, "where")=List of 2
[17:36:39.772]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.772]   ..$ ...          :<environment: 0x5622fad808f0> 
[17:36:39.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.772]  - attr(*, "resolved")= logi FALSE
[17:36:39.772]  - attr(*, "total_size")= num 1240
[17:36:39.775] Packages to be attached in all futures: [n=0] 
[17:36:39.775] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.775] Number of futures (= number of chunks): 1
[17:36:39.775] Launching 1 futures (chunks) ...
[17:36:39.776] Chunk #1 of 1 ...
[17:36:39.776]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.776] getGlobalsAndPackages() ...
[17:36:39.776] Searching for globals...
[17:36:39.776] 
[17:36:39.777] Searching for globals ... DONE
[17:36:39.777] - globals: [0] <none>
[17:36:39.777] getGlobalsAndPackages() ... DONE
[17:36:39.777]    + additional globals found: [n=0] 
[17:36:39.777]    + additional namespaces needed: [n=0] 
[17:36:39.777]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.777]  - seeds: <none>
[17:36:39.777]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.777] getGlobalsAndPackages() ...
[17:36:39.777] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.778] Resolving globals: FALSE
[17:36:39.778] Tweak future expression to call with '...' arguments ...
[17:36:39.778] {
[17:36:39.778]     do.call(function(...) {
[17:36:39.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.778]             on.exit(options(oopts), add = TRUE)
[17:36:39.778]         }
[17:36:39.778]         {
[17:36:39.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.778]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.778]             })
[17:36:39.778]         }
[17:36:39.778]     }, args = future.call.arguments)
[17:36:39.778] }
[17:36:39.778] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.778] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.779] 
[17:36:39.779] getGlobalsAndPackages() ... DONE
[17:36:39.779] run() for ‘Future’ ...
[17:36:39.779] - state: ‘created’
[17:36:39.779] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:39.785] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.785] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.785]   - Field: ‘label’
[17:36:39.785]   - Field: ‘local’
[17:36:39.785]   - Field: ‘owner’
[17:36:39.785]   - Field: ‘envir’
[17:36:39.785]   - Field: ‘packages’
[17:36:39.785]   - Field: ‘gc’
[17:36:39.786]   - Field: ‘conditions’
[17:36:39.786]   - Field: ‘expr’
[17:36:39.786]   - Field: ‘uuid’
[17:36:39.786]   - Field: ‘seed’
[17:36:39.786]   - Field: ‘version’
[17:36:39.786]   - Field: ‘result’
[17:36:39.786]   - Field: ‘asynchronous’
[17:36:39.786]   - Field: ‘calls’
[17:36:39.786]   - Field: ‘globals’
[17:36:39.787]   - Field: ‘stdout’
[17:36:39.787]   - Field: ‘earlySignal’
[17:36:39.787]   - Field: ‘lazy’
[17:36:39.787]   - Field: ‘state’
[17:36:39.787] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.787] - Launch lazy future ...
[17:36:39.787] Packages needed by the future expression (n = 0): <none>
[17:36:39.787] Packages needed by future strategies (n = 0): <none>
[17:36:39.788] {
[17:36:39.788]     {
[17:36:39.788]         {
[17:36:39.788]             ...future.startTime <- base::Sys.time()
[17:36:39.788]             {
[17:36:39.788]                 {
[17:36:39.788]                   {
[17:36:39.788]                     base::local({
[17:36:39.788]                       has_future <- base::requireNamespace("future", 
[17:36:39.788]                         quietly = TRUE)
[17:36:39.788]                       if (has_future) {
[17:36:39.788]                         ns <- base::getNamespace("future")
[17:36:39.788]                         version <- ns[[".package"]][["version"]]
[17:36:39.788]                         if (is.null(version)) 
[17:36:39.788]                           version <- utils::packageVersion("future")
[17:36:39.788]                       }
[17:36:39.788]                       else {
[17:36:39.788]                         version <- NULL
[17:36:39.788]                       }
[17:36:39.788]                       if (!has_future || version < "1.8.0") {
[17:36:39.788]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.788]                           "", base::R.version$version.string), 
[17:36:39.788]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:39.788]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.788]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.788]                             "release", "version")], collapse = " "), 
[17:36:39.788]                           hostname = base::Sys.info()[["nodename"]])
[17:36:39.788]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.788]                           info)
[17:36:39.788]                         info <- base::paste(info, collapse = "; ")
[17:36:39.788]                         if (!has_future) {
[17:36:39.788]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.788]                             info)
[17:36:39.788]                         }
[17:36:39.788]                         else {
[17:36:39.788]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.788]                             info, version)
[17:36:39.788]                         }
[17:36:39.788]                         base::stop(msg)
[17:36:39.788]                       }
[17:36:39.788]                     })
[17:36:39.788]                   }
[17:36:39.788]                   ...future.strategy.old <- future::plan("list")
[17:36:39.788]                   options(future.plan = NULL)
[17:36:39.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.788]                 }
[17:36:39.788]                 ...future.workdir <- getwd()
[17:36:39.788]             }
[17:36:39.788]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.788]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.788]         }
[17:36:39.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.788]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.788]             base::names(...future.oldOptions))
[17:36:39.788]     }
[17:36:39.788]     if (FALSE) {
[17:36:39.788]     }
[17:36:39.788]     else {
[17:36:39.788]         if (TRUE) {
[17:36:39.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.788]                 open = "w")
[17:36:39.788]         }
[17:36:39.788]         else {
[17:36:39.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.788]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.788]         }
[17:36:39.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.788]             base::sink(type = "output", split = FALSE)
[17:36:39.788]             base::close(...future.stdout)
[17:36:39.788]         }, add = TRUE)
[17:36:39.788]     }
[17:36:39.788]     ...future.frame <- base::sys.nframe()
[17:36:39.788]     ...future.conditions <- base::list()
[17:36:39.788]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.788]     if (FALSE) {
[17:36:39.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.788]     }
[17:36:39.788]     ...future.result <- base::tryCatch({
[17:36:39.788]         base::withCallingHandlers({
[17:36:39.788]             ...future.value <- base::withVisible(base::local({
[17:36:39.788]                 do.call(function(...) {
[17:36:39.788]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.788]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.788]                     ...future.globals.maxSize)) {
[17:36:39.788]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.788]                     on.exit(options(oopts), add = TRUE)
[17:36:39.788]                   }
[17:36:39.788]                   {
[17:36:39.788]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.788]                       FUN = function(jj) {
[17:36:39.788]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.788]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.788]                       })
[17:36:39.788]                   }
[17:36:39.788]                 }, args = future.call.arguments)
[17:36:39.788]             }))
[17:36:39.788]             future::FutureResult(value = ...future.value$value, 
[17:36:39.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.788]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.788]                     ...future.globalenv.names))
[17:36:39.788]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.788]         }, condition = base::local({
[17:36:39.788]             c <- base::c
[17:36:39.788]             inherits <- base::inherits
[17:36:39.788]             invokeRestart <- base::invokeRestart
[17:36:39.788]             length <- base::length
[17:36:39.788]             list <- base::list
[17:36:39.788]             seq.int <- base::seq.int
[17:36:39.788]             signalCondition <- base::signalCondition
[17:36:39.788]             sys.calls <- base::sys.calls
[17:36:39.788]             `[[` <- base::`[[`
[17:36:39.788]             `+` <- base::`+`
[17:36:39.788]             `<<-` <- base::`<<-`
[17:36:39.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.788]                   3L)]
[17:36:39.788]             }
[17:36:39.788]             function(cond) {
[17:36:39.788]                 is_error <- inherits(cond, "error")
[17:36:39.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.788]                   NULL)
[17:36:39.788]                 if (is_error) {
[17:36:39.788]                   sessionInformation <- function() {
[17:36:39.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.788]                       search = base::search(), system = base::Sys.info())
[17:36:39.788]                   }
[17:36:39.788]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.788]                     cond$call), session = sessionInformation(), 
[17:36:39.788]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.788]                   signalCondition(cond)
[17:36:39.788]                 }
[17:36:39.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.788]                 "immediateCondition"))) {
[17:36:39.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.788]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.788]                   if (TRUE && !signal) {
[17:36:39.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.788]                     {
[17:36:39.788]                       inherits <- base::inherits
[17:36:39.788]                       invokeRestart <- base::invokeRestart
[17:36:39.788]                       is.null <- base::is.null
[17:36:39.788]                       muffled <- FALSE
[17:36:39.788]                       if (inherits(cond, "message")) {
[17:36:39.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.788]                         if (muffled) 
[17:36:39.788]                           invokeRestart("muffleMessage")
[17:36:39.788]                       }
[17:36:39.788]                       else if (inherits(cond, "warning")) {
[17:36:39.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.788]                         if (muffled) 
[17:36:39.788]                           invokeRestart("muffleWarning")
[17:36:39.788]                       }
[17:36:39.788]                       else if (inherits(cond, "condition")) {
[17:36:39.788]                         if (!is.null(pattern)) {
[17:36:39.788]                           computeRestarts <- base::computeRestarts
[17:36:39.788]                           grepl <- base::grepl
[17:36:39.788]                           restarts <- computeRestarts(cond)
[17:36:39.788]                           for (restart in restarts) {
[17:36:39.788]                             name <- restart$name
[17:36:39.788]                             if (is.null(name)) 
[17:36:39.788]                               next
[17:36:39.788]                             if (!grepl(pattern, name)) 
[17:36:39.788]                               next
[17:36:39.788]                             invokeRestart(restart)
[17:36:39.788]                             muffled <- TRUE
[17:36:39.788]                             break
[17:36:39.788]                           }
[17:36:39.788]                         }
[17:36:39.788]                       }
[17:36:39.788]                       invisible(muffled)
[17:36:39.788]                     }
[17:36:39.788]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.788]                   }
[17:36:39.788]                 }
[17:36:39.788]                 else {
[17:36:39.788]                   if (TRUE) {
[17:36:39.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.788]                     {
[17:36:39.788]                       inherits <- base::inherits
[17:36:39.788]                       invokeRestart <- base::invokeRestart
[17:36:39.788]                       is.null <- base::is.null
[17:36:39.788]                       muffled <- FALSE
[17:36:39.788]                       if (inherits(cond, "message")) {
[17:36:39.788]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.788]                         if (muffled) 
[17:36:39.788]                           invokeRestart("muffleMessage")
[17:36:39.788]                       }
[17:36:39.788]                       else if (inherits(cond, "warning")) {
[17:36:39.788]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.788]                         if (muffled) 
[17:36:39.788]                           invokeRestart("muffleWarning")
[17:36:39.788]                       }
[17:36:39.788]                       else if (inherits(cond, "condition")) {
[17:36:39.788]                         if (!is.null(pattern)) {
[17:36:39.788]                           computeRestarts <- base::computeRestarts
[17:36:39.788]                           grepl <- base::grepl
[17:36:39.788]                           restarts <- computeRestarts(cond)
[17:36:39.788]                           for (restart in restarts) {
[17:36:39.788]                             name <- restart$name
[17:36:39.788]                             if (is.null(name)) 
[17:36:39.788]                               next
[17:36:39.788]                             if (!grepl(pattern, name)) 
[17:36:39.788]                               next
[17:36:39.788]                             invokeRestart(restart)
[17:36:39.788]                             muffled <- TRUE
[17:36:39.788]                             break
[17:36:39.788]                           }
[17:36:39.788]                         }
[17:36:39.788]                       }
[17:36:39.788]                       invisible(muffled)
[17:36:39.788]                     }
[17:36:39.788]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.788]                   }
[17:36:39.788]                 }
[17:36:39.788]             }
[17:36:39.788]         }))
[17:36:39.788]     }, error = function(ex) {
[17:36:39.788]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.788]                 ...future.rng), started = ...future.startTime, 
[17:36:39.788]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.788]             version = "1.8"), class = "FutureResult")
[17:36:39.788]     }, finally = {
[17:36:39.788]         if (!identical(...future.workdir, getwd())) 
[17:36:39.788]             setwd(...future.workdir)
[17:36:39.788]         {
[17:36:39.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.788]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.788]             }
[17:36:39.788]             base::options(...future.oldOptions)
[17:36:39.788]             if (.Platform$OS.type == "windows") {
[17:36:39.788]                 old_names <- names(...future.oldEnvVars)
[17:36:39.788]                 envs <- base::Sys.getenv()
[17:36:39.788]                 names <- names(envs)
[17:36:39.788]                 common <- intersect(names, old_names)
[17:36:39.788]                 added <- setdiff(names, old_names)
[17:36:39.788]                 removed <- setdiff(old_names, names)
[17:36:39.788]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.788]                   envs[common]]
[17:36:39.788]                 NAMES <- toupper(changed)
[17:36:39.788]                 args <- list()
[17:36:39.788]                 for (kk in seq_along(NAMES)) {
[17:36:39.788]                   name <- changed[[kk]]
[17:36:39.788]                   NAME <- NAMES[[kk]]
[17:36:39.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.788]                     next
[17:36:39.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.788]                 }
[17:36:39.788]                 NAMES <- toupper(added)
[17:36:39.788]                 for (kk in seq_along(NAMES)) {
[17:36:39.788]                   name <- added[[kk]]
[17:36:39.788]                   NAME <- NAMES[[kk]]
[17:36:39.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.788]                     next
[17:36:39.788]                   args[[name]] <- ""
[17:36:39.788]                 }
[17:36:39.788]                 NAMES <- toupper(removed)
[17:36:39.788]                 for (kk in seq_along(NAMES)) {
[17:36:39.788]                   name <- removed[[kk]]
[17:36:39.788]                   NAME <- NAMES[[kk]]
[17:36:39.788]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.788]                     next
[17:36:39.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.788]                 }
[17:36:39.788]                 if (length(args) > 0) 
[17:36:39.788]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.788]             }
[17:36:39.788]             else {
[17:36:39.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.788]             }
[17:36:39.788]             {
[17:36:39.788]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.788]                   0L) {
[17:36:39.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.788]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.788]                   base::options(opts)
[17:36:39.788]                 }
[17:36:39.788]                 {
[17:36:39.788]                   {
[17:36:39.788]                     NULL
[17:36:39.788]                     RNGkind("Mersenne-Twister")
[17:36:39.788]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.788]                       inherits = FALSE)
[17:36:39.788]                   }
[17:36:39.788]                   options(future.plan = NULL)
[17:36:39.788]                   if (is.na(NA_character_)) 
[17:36:39.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.788]                     .init = FALSE)
[17:36:39.788]                 }
[17:36:39.788]             }
[17:36:39.788]         }
[17:36:39.788]     })
[17:36:39.788]     if (TRUE) {
[17:36:39.788]         base::sink(type = "output", split = FALSE)
[17:36:39.788]         if (TRUE) {
[17:36:39.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.788]         }
[17:36:39.788]         else {
[17:36:39.788]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.788]         }
[17:36:39.788]         base::close(...future.stdout)
[17:36:39.788]         ...future.stdout <- NULL
[17:36:39.788]     }
[17:36:39.788]     ...future.result$conditions <- ...future.conditions
[17:36:39.788]     ...future.result$finished <- base::Sys.time()
[17:36:39.788]     ...future.result
[17:36:39.788] }
[17:36:39.790] assign_globals() ...
[17:36:39.790] List of 5
[17:36:39.790]  $ ...future.FUN            :function (object, ...)  
[17:36:39.790]  $ future.call.arguments    : list()
[17:36:39.790]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.790]  $ ...future.elements_ii    :List of 3
[17:36:39.790]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.790]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:39.790]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.790]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.790]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.790]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:39.790]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.790]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:39.790]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.790]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:39.790]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.790]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:39.790]  $ ...future.seeds_ii       : NULL
[17:36:39.790]  $ ...future.globals.maxSize: NULL
[17:36:39.790]  - attr(*, "where")=List of 5
[17:36:39.790]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.790]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.790]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.790]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.790]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.790]  - attr(*, "resolved")= logi FALSE
[17:36:39.790]  - attr(*, "total_size")= num 1240
[17:36:39.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.790]  - attr(*, "already-done")= logi TRUE
[17:36:39.798] - copied ‘...future.FUN’ to environment
[17:36:39.798] - copied ‘future.call.arguments’ to environment
[17:36:39.798] - copied ‘...future.elements_ii’ to environment
[17:36:39.798] - copied ‘...future.seeds_ii’ to environment
[17:36:39.799] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.799] assign_globals() ... done
[17:36:39.799] plan(): Setting new future strategy stack:
[17:36:39.799] List of future strategies:
[17:36:39.799] 1. sequential:
[17:36:39.799]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.799]    - tweaked: FALSE
[17:36:39.799]    - call: NULL
[17:36:39.799] plan(): nbrOfWorkers() = 1
[17:36:39.802] plan(): Setting new future strategy stack:
[17:36:39.802] List of future strategies:
[17:36:39.802] 1. multicore:
[17:36:39.802]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:39.802]    - tweaked: FALSE
[17:36:39.802]    - call: plan(strategy)
[17:36:39.806] plan(): nbrOfWorkers() = 1
[17:36:39.806] SequentialFuture started (and completed)
[17:36:39.807] - Launch lazy future ... done
[17:36:39.807] run() for ‘SequentialFuture’ ... done
[17:36:39.807] Created future:
[17:36:39.807] SequentialFuture:
[17:36:39.807] Label: ‘future_by-1’
[17:36:39.807] Expression:
[17:36:39.807] {
[17:36:39.807]     do.call(function(...) {
[17:36:39.807]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.807]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.807]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.807]             on.exit(options(oopts), add = TRUE)
[17:36:39.807]         }
[17:36:39.807]         {
[17:36:39.807]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.807]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.807]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.807]             })
[17:36:39.807]         }
[17:36:39.807]     }, args = future.call.arguments)
[17:36:39.807] }
[17:36:39.807] Lazy evaluation: FALSE
[17:36:39.807] Asynchronous evaluation: FALSE
[17:36:39.807] Local evaluation: TRUE
[17:36:39.807] Environment: 0x5622f9f5fd00
[17:36:39.807] Capture standard output: TRUE
[17:36:39.807] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.807] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.807] Packages: <none>
[17:36:39.807] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.807] Resolved: TRUE
[17:36:39.807] Value: 5.37 KiB of class ‘list’
[17:36:39.807] Early signaling: FALSE
[17:36:39.807] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.807] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.809] Chunk #1 of 1 ... DONE
[17:36:39.809] Launching 1 futures (chunks) ... DONE
[17:36:39.809] Resolving 1 futures (chunks) ...
[17:36:39.809] resolve() on list ...
[17:36:39.809]  recursive: 0
[17:36:39.810]  length: 1
[17:36:39.810] 
[17:36:39.810] resolved() for ‘SequentialFuture’ ...
[17:36:39.810] - state: ‘finished’
[17:36:39.810] - run: TRUE
[17:36:39.810] - result: ‘FutureResult’
[17:36:39.810] resolved() for ‘SequentialFuture’ ... done
[17:36:39.811] Future #1
[17:36:39.811] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.811] - nx: 1
[17:36:39.811] - relay: TRUE
[17:36:39.811] - stdout: TRUE
[17:36:39.811] - signal: TRUE
[17:36:39.811] - resignal: FALSE
[17:36:39.811] - force: TRUE
[17:36:39.812] - relayed: [n=1] FALSE
[17:36:39.812] - queued futures: [n=1] FALSE
[17:36:39.812]  - until=1
[17:36:39.812]  - relaying element #1
[17:36:39.812] - relayed: [n=1] TRUE
[17:36:39.812] - queued futures: [n=1] TRUE
[17:36:39.814] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.814]  length: 0 (resolved future 1)
[17:36:39.815] Relaying remaining futures
[17:36:39.815] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.815] - nx: 1
[17:36:39.815] - relay: TRUE
[17:36:39.815] - stdout: TRUE
[17:36:39.815] - signal: TRUE
[17:36:39.815] - resignal: FALSE
[17:36:39.815] - force: TRUE
[17:36:39.815] - relayed: [n=1] TRUE
[17:36:39.815] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.816] - relayed: [n=1] TRUE
[17:36:39.816] - queued futures: [n=1] TRUE
[17:36:39.816] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.816] resolve() on list ... DONE
[17:36:39.816]  - Number of value chunks collected: 1
[17:36:39.816] Resolving 1 futures (chunks) ... DONE
[17:36:39.816] Reducing values from 1 chunks ...
[17:36:39.816]  - Number of values collected after concatenation: 3
[17:36:39.817]  - Number of values expected: 3
[17:36:39.817] Reducing values from 1 chunks ... DONE
[17:36:39.817] future_lapply() ... DONE
[17:36:39.817] future_by_internal() ... DONE
[17:36:39.818] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:36:39.818] future_lapply() ...
[17:36:39.822] Number of chunks: 1
[17:36:39.822] getGlobalsAndPackagesXApply() ...
[17:36:39.822]  - future.globals: TRUE
[17:36:39.822] getGlobalsAndPackages() ...
[17:36:39.822] Searching for globals...
[17:36:39.823] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:39.824] Searching for globals ... DONE
[17:36:39.824] Resolving globals: FALSE
[17:36:39.824] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:39.824] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:39.824] - globals: [1] ‘FUN’
[17:36:39.825] 
[17:36:39.825] getGlobalsAndPackages() ... DONE
[17:36:39.825]  - globals found/used: [n=1] ‘FUN’
[17:36:39.825]  - needed namespaces: [n=0] 
[17:36:39.825] Finding globals ... DONE
[17:36:39.825]  - use_args: TRUE
[17:36:39.825]  - Getting '...' globals ...
[17:36:39.825] resolve() on list ...
[17:36:39.826]  recursive: 0
[17:36:39.826]  length: 1
[17:36:39.826]  elements: ‘...’
[17:36:39.826]  length: 0 (resolved future 1)
[17:36:39.826] resolve() on list ... DONE
[17:36:39.826]    - '...' content: [n=0] 
[17:36:39.826] List of 1
[17:36:39.826]  $ ...: list()
[17:36:39.826]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.826]  - attr(*, "where")=List of 1
[17:36:39.826]   ..$ ...:<environment: 0x5622fb5a1c68> 
[17:36:39.826]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.826]  - attr(*, "resolved")= logi TRUE
[17:36:39.826]  - attr(*, "total_size")= num NA
[17:36:39.829]  - Getting '...' globals ... DONE
[17:36:39.829] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.829] List of 2
[17:36:39.829]  $ ...future.FUN:function (object, ...)  
[17:36:39.829]  $ ...          : list()
[17:36:39.829]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.829]  - attr(*, "where")=List of 2
[17:36:39.829]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.829]   ..$ ...          :<environment: 0x5622fb5a1c68> 
[17:36:39.829]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.829]  - attr(*, "resolved")= logi FALSE
[17:36:39.829]  - attr(*, "total_size")= num 1240
[17:36:39.832] Packages to be attached in all futures: [n=0] 
[17:36:39.832] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.832] Number of futures (= number of chunks): 1
[17:36:39.832] Launching 1 futures (chunks) ...
[17:36:39.832] Chunk #1 of 1 ...
[17:36:39.832]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.832] getGlobalsAndPackages() ...
[17:36:39.832] Searching for globals...
[17:36:39.833] 
[17:36:39.833] Searching for globals ... DONE
[17:36:39.833] - globals: [0] <none>
[17:36:39.833] getGlobalsAndPackages() ... DONE
[17:36:39.833]    + additional globals found: [n=0] 
[17:36:39.833]    + additional namespaces needed: [n=0] 
[17:36:39.833]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.833]  - seeds: <none>
[17:36:39.834]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.834] getGlobalsAndPackages() ...
[17:36:39.834] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.834] Resolving globals: FALSE
[17:36:39.834] Tweak future expression to call with '...' arguments ...
[17:36:39.834] {
[17:36:39.834]     do.call(function(...) {
[17:36:39.834]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.834]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.834]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.834]             on.exit(options(oopts), add = TRUE)
[17:36:39.834]         }
[17:36:39.834]         {
[17:36:39.834]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.834]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.834]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.834]             })
[17:36:39.834]         }
[17:36:39.834]     }, args = future.call.arguments)
[17:36:39.834] }
[17:36:39.834] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.835] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.835] 
[17:36:39.835] getGlobalsAndPackages() ... DONE
[17:36:39.835] run() for ‘Future’ ...
[17:36:39.835] - state: ‘created’
[17:36:39.835] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:39.839] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.839] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.839]   - Field: ‘label’
[17:36:39.839]   - Field: ‘local’
[17:36:39.839]   - Field: ‘owner’
[17:36:39.840]   - Field: ‘envir’
[17:36:39.840]   - Field: ‘packages’
[17:36:39.840]   - Field: ‘gc’
[17:36:39.840]   - Field: ‘conditions’
[17:36:39.840]   - Field: ‘expr’
[17:36:39.840]   - Field: ‘uuid’
[17:36:39.840]   - Field: ‘seed’
[17:36:39.840]   - Field: ‘version’
[17:36:39.840]   - Field: ‘result’
[17:36:39.840]   - Field: ‘asynchronous’
[17:36:39.841]   - Field: ‘calls’
[17:36:39.841]   - Field: ‘globals’
[17:36:39.841]   - Field: ‘stdout’
[17:36:39.841]   - Field: ‘earlySignal’
[17:36:39.841]   - Field: ‘lazy’
[17:36:39.842]   - Field: ‘state’
[17:36:39.843] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.843] - Launch lazy future ...
[17:36:39.843] Packages needed by the future expression (n = 0): <none>
[17:36:39.843] Packages needed by future strategies (n = 0): <none>
[17:36:39.844] {
[17:36:39.844]     {
[17:36:39.844]         {
[17:36:39.844]             ...future.startTime <- base::Sys.time()
[17:36:39.844]             {
[17:36:39.844]                 {
[17:36:39.844]                   {
[17:36:39.844]                     base::local({
[17:36:39.844]                       has_future <- base::requireNamespace("future", 
[17:36:39.844]                         quietly = TRUE)
[17:36:39.844]                       if (has_future) {
[17:36:39.844]                         ns <- base::getNamespace("future")
[17:36:39.844]                         version <- ns[[".package"]][["version"]]
[17:36:39.844]                         if (is.null(version)) 
[17:36:39.844]                           version <- utils::packageVersion("future")
[17:36:39.844]                       }
[17:36:39.844]                       else {
[17:36:39.844]                         version <- NULL
[17:36:39.844]                       }
[17:36:39.844]                       if (!has_future || version < "1.8.0") {
[17:36:39.844]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.844]                           "", base::R.version$version.string), 
[17:36:39.844]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:39.844]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.844]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.844]                             "release", "version")], collapse = " "), 
[17:36:39.844]                           hostname = base::Sys.info()[["nodename"]])
[17:36:39.844]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.844]                           info)
[17:36:39.844]                         info <- base::paste(info, collapse = "; ")
[17:36:39.844]                         if (!has_future) {
[17:36:39.844]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.844]                             info)
[17:36:39.844]                         }
[17:36:39.844]                         else {
[17:36:39.844]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.844]                             info, version)
[17:36:39.844]                         }
[17:36:39.844]                         base::stop(msg)
[17:36:39.844]                       }
[17:36:39.844]                     })
[17:36:39.844]                   }
[17:36:39.844]                   ...future.strategy.old <- future::plan("list")
[17:36:39.844]                   options(future.plan = NULL)
[17:36:39.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.844]                 }
[17:36:39.844]                 ...future.workdir <- getwd()
[17:36:39.844]             }
[17:36:39.844]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.844]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.844]         }
[17:36:39.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.844]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.844]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.844]             base::names(...future.oldOptions))
[17:36:39.844]     }
[17:36:39.844]     if (FALSE) {
[17:36:39.844]     }
[17:36:39.844]     else {
[17:36:39.844]         if (TRUE) {
[17:36:39.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.844]                 open = "w")
[17:36:39.844]         }
[17:36:39.844]         else {
[17:36:39.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.844]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.844]         }
[17:36:39.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.844]             base::sink(type = "output", split = FALSE)
[17:36:39.844]             base::close(...future.stdout)
[17:36:39.844]         }, add = TRUE)
[17:36:39.844]     }
[17:36:39.844]     ...future.frame <- base::sys.nframe()
[17:36:39.844]     ...future.conditions <- base::list()
[17:36:39.844]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.844]     if (FALSE) {
[17:36:39.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.844]     }
[17:36:39.844]     ...future.result <- base::tryCatch({
[17:36:39.844]         base::withCallingHandlers({
[17:36:39.844]             ...future.value <- base::withVisible(base::local({
[17:36:39.844]                 do.call(function(...) {
[17:36:39.844]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.844]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.844]                     ...future.globals.maxSize)) {
[17:36:39.844]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.844]                     on.exit(options(oopts), add = TRUE)
[17:36:39.844]                   }
[17:36:39.844]                   {
[17:36:39.844]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.844]                       FUN = function(jj) {
[17:36:39.844]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.844]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.844]                       })
[17:36:39.844]                   }
[17:36:39.844]                 }, args = future.call.arguments)
[17:36:39.844]             }))
[17:36:39.844]             future::FutureResult(value = ...future.value$value, 
[17:36:39.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.844]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.844]                     ...future.globalenv.names))
[17:36:39.844]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.844]         }, condition = base::local({
[17:36:39.844]             c <- base::c
[17:36:39.844]             inherits <- base::inherits
[17:36:39.844]             invokeRestart <- base::invokeRestart
[17:36:39.844]             length <- base::length
[17:36:39.844]             list <- base::list
[17:36:39.844]             seq.int <- base::seq.int
[17:36:39.844]             signalCondition <- base::signalCondition
[17:36:39.844]             sys.calls <- base::sys.calls
[17:36:39.844]             `[[` <- base::`[[`
[17:36:39.844]             `+` <- base::`+`
[17:36:39.844]             `<<-` <- base::`<<-`
[17:36:39.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.844]                   3L)]
[17:36:39.844]             }
[17:36:39.844]             function(cond) {
[17:36:39.844]                 is_error <- inherits(cond, "error")
[17:36:39.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.844]                   NULL)
[17:36:39.844]                 if (is_error) {
[17:36:39.844]                   sessionInformation <- function() {
[17:36:39.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.844]                       search = base::search(), system = base::Sys.info())
[17:36:39.844]                   }
[17:36:39.844]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.844]                     cond$call), session = sessionInformation(), 
[17:36:39.844]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.844]                   signalCondition(cond)
[17:36:39.844]                 }
[17:36:39.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.844]                 "immediateCondition"))) {
[17:36:39.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.844]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.844]                   if (TRUE && !signal) {
[17:36:39.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.844]                     {
[17:36:39.844]                       inherits <- base::inherits
[17:36:39.844]                       invokeRestart <- base::invokeRestart
[17:36:39.844]                       is.null <- base::is.null
[17:36:39.844]                       muffled <- FALSE
[17:36:39.844]                       if (inherits(cond, "message")) {
[17:36:39.844]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.844]                         if (muffled) 
[17:36:39.844]                           invokeRestart("muffleMessage")
[17:36:39.844]                       }
[17:36:39.844]                       else if (inherits(cond, "warning")) {
[17:36:39.844]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.844]                         if (muffled) 
[17:36:39.844]                           invokeRestart("muffleWarning")
[17:36:39.844]                       }
[17:36:39.844]                       else if (inherits(cond, "condition")) {
[17:36:39.844]                         if (!is.null(pattern)) {
[17:36:39.844]                           computeRestarts <- base::computeRestarts
[17:36:39.844]                           grepl <- base::grepl
[17:36:39.844]                           restarts <- computeRestarts(cond)
[17:36:39.844]                           for (restart in restarts) {
[17:36:39.844]                             name <- restart$name
[17:36:39.844]                             if (is.null(name)) 
[17:36:39.844]                               next
[17:36:39.844]                             if (!grepl(pattern, name)) 
[17:36:39.844]                               next
[17:36:39.844]                             invokeRestart(restart)
[17:36:39.844]                             muffled <- TRUE
[17:36:39.844]                             break
[17:36:39.844]                           }
[17:36:39.844]                         }
[17:36:39.844]                       }
[17:36:39.844]                       invisible(muffled)
[17:36:39.844]                     }
[17:36:39.844]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.844]                   }
[17:36:39.844]                 }
[17:36:39.844]                 else {
[17:36:39.844]                   if (TRUE) {
[17:36:39.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.844]                     {
[17:36:39.844]                       inherits <- base::inherits
[17:36:39.844]                       invokeRestart <- base::invokeRestart
[17:36:39.844]                       is.null <- base::is.null
[17:36:39.844]                       muffled <- FALSE
[17:36:39.844]                       if (inherits(cond, "message")) {
[17:36:39.844]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.844]                         if (muffled) 
[17:36:39.844]                           invokeRestart("muffleMessage")
[17:36:39.844]                       }
[17:36:39.844]                       else if (inherits(cond, "warning")) {
[17:36:39.844]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.844]                         if (muffled) 
[17:36:39.844]                           invokeRestart("muffleWarning")
[17:36:39.844]                       }
[17:36:39.844]                       else if (inherits(cond, "condition")) {
[17:36:39.844]                         if (!is.null(pattern)) {
[17:36:39.844]                           computeRestarts <- base::computeRestarts
[17:36:39.844]                           grepl <- base::grepl
[17:36:39.844]                           restarts <- computeRestarts(cond)
[17:36:39.844]                           for (restart in restarts) {
[17:36:39.844]                             name <- restart$name
[17:36:39.844]                             if (is.null(name)) 
[17:36:39.844]                               next
[17:36:39.844]                             if (!grepl(pattern, name)) 
[17:36:39.844]                               next
[17:36:39.844]                             invokeRestart(restart)
[17:36:39.844]                             muffled <- TRUE
[17:36:39.844]                             break
[17:36:39.844]                           }
[17:36:39.844]                         }
[17:36:39.844]                       }
[17:36:39.844]                       invisible(muffled)
[17:36:39.844]                     }
[17:36:39.844]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.844]                   }
[17:36:39.844]                 }
[17:36:39.844]             }
[17:36:39.844]         }))
[17:36:39.844]     }, error = function(ex) {
[17:36:39.844]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.844]                 ...future.rng), started = ...future.startTime, 
[17:36:39.844]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.844]             version = "1.8"), class = "FutureResult")
[17:36:39.844]     }, finally = {
[17:36:39.844]         if (!identical(...future.workdir, getwd())) 
[17:36:39.844]             setwd(...future.workdir)
[17:36:39.844]         {
[17:36:39.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.844]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.844]             }
[17:36:39.844]             base::options(...future.oldOptions)
[17:36:39.844]             if (.Platform$OS.type == "windows") {
[17:36:39.844]                 old_names <- names(...future.oldEnvVars)
[17:36:39.844]                 envs <- base::Sys.getenv()
[17:36:39.844]                 names <- names(envs)
[17:36:39.844]                 common <- intersect(names, old_names)
[17:36:39.844]                 added <- setdiff(names, old_names)
[17:36:39.844]                 removed <- setdiff(old_names, names)
[17:36:39.844]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.844]                   envs[common]]
[17:36:39.844]                 NAMES <- toupper(changed)
[17:36:39.844]                 args <- list()
[17:36:39.844]                 for (kk in seq_along(NAMES)) {
[17:36:39.844]                   name <- changed[[kk]]
[17:36:39.844]                   NAME <- NAMES[[kk]]
[17:36:39.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.844]                     next
[17:36:39.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.844]                 }
[17:36:39.844]                 NAMES <- toupper(added)
[17:36:39.844]                 for (kk in seq_along(NAMES)) {
[17:36:39.844]                   name <- added[[kk]]
[17:36:39.844]                   NAME <- NAMES[[kk]]
[17:36:39.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.844]                     next
[17:36:39.844]                   args[[name]] <- ""
[17:36:39.844]                 }
[17:36:39.844]                 NAMES <- toupper(removed)
[17:36:39.844]                 for (kk in seq_along(NAMES)) {
[17:36:39.844]                   name <- removed[[kk]]
[17:36:39.844]                   NAME <- NAMES[[kk]]
[17:36:39.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.844]                     next
[17:36:39.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.844]                 }
[17:36:39.844]                 if (length(args) > 0) 
[17:36:39.844]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.844]             }
[17:36:39.844]             else {
[17:36:39.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.844]             }
[17:36:39.844]             {
[17:36:39.844]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.844]                   0L) {
[17:36:39.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.844]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.844]                   base::options(opts)
[17:36:39.844]                 }
[17:36:39.844]                 {
[17:36:39.844]                   {
[17:36:39.844]                     NULL
[17:36:39.844]                     RNGkind("Mersenne-Twister")
[17:36:39.844]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.844]                       inherits = FALSE)
[17:36:39.844]                   }
[17:36:39.844]                   options(future.plan = NULL)
[17:36:39.844]                   if (is.na(NA_character_)) 
[17:36:39.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.844]                     .init = FALSE)
[17:36:39.844]                 }
[17:36:39.844]             }
[17:36:39.844]         }
[17:36:39.844]     })
[17:36:39.844]     if (TRUE) {
[17:36:39.844]         base::sink(type = "output", split = FALSE)
[17:36:39.844]         if (TRUE) {
[17:36:39.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.844]         }
[17:36:39.844]         else {
[17:36:39.844]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.844]         }
[17:36:39.844]         base::close(...future.stdout)
[17:36:39.844]         ...future.stdout <- NULL
[17:36:39.844]     }
[17:36:39.844]     ...future.result$conditions <- ...future.conditions
[17:36:39.844]     ...future.result$finished <- base::Sys.time()
[17:36:39.844]     ...future.result
[17:36:39.844] }
[17:36:39.845] assign_globals() ...
[17:36:39.845] List of 5
[17:36:39.845]  $ ...future.FUN            :function (object, ...)  
[17:36:39.845]  $ future.call.arguments    : list()
[17:36:39.845]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.845]  $ ...future.elements_ii    :List of 3
[17:36:39.845]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.845]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:39.845]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.845]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:39.845]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.845]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:39.845]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.845]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:39.845]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:39.845]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:39.845]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.845]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:39.845]  $ ...future.seeds_ii       : NULL
[17:36:39.845]  $ ...future.globals.maxSize: NULL
[17:36:39.845]  - attr(*, "where")=List of 5
[17:36:39.845]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.845]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.845]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.845]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.845]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.845]  - attr(*, "resolved")= logi FALSE
[17:36:39.845]  - attr(*, "total_size")= num 1240
[17:36:39.845]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.845]  - attr(*, "already-done")= logi TRUE
[17:36:39.854] - copied ‘...future.FUN’ to environment
[17:36:39.854] - copied ‘future.call.arguments’ to environment
[17:36:39.854] - copied ‘...future.elements_ii’ to environment
[17:36:39.854] - copied ‘...future.seeds_ii’ to environment
[17:36:39.854] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.854] assign_globals() ... done
[17:36:39.855] plan(): Setting new future strategy stack:
[17:36:39.855] List of future strategies:
[17:36:39.855] 1. sequential:
[17:36:39.855]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.855]    - tweaked: FALSE
[17:36:39.855]    - call: NULL
[17:36:39.855] plan(): nbrOfWorkers() = 1
[17:36:39.857] plan(): Setting new future strategy stack:
[17:36:39.858] List of future strategies:
[17:36:39.858] 1. multicore:
[17:36:39.858]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:39.858]    - tweaked: FALSE
[17:36:39.858]    - call: plan(strategy)
[17:36:39.861] plan(): nbrOfWorkers() = 1
[17:36:39.861] SequentialFuture started (and completed)
[17:36:39.861] - Launch lazy future ... done
[17:36:39.862] run() for ‘SequentialFuture’ ... done
[17:36:39.862] Created future:
[17:36:39.862] SequentialFuture:
[17:36:39.862] Label: ‘future_by-1’
[17:36:39.862] Expression:
[17:36:39.862] {
[17:36:39.862]     do.call(function(...) {
[17:36:39.862]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.862]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.862]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.862]             on.exit(options(oopts), add = TRUE)
[17:36:39.862]         }
[17:36:39.862]         {
[17:36:39.862]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.862]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.862]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.862]             })
[17:36:39.862]         }
[17:36:39.862]     }, args = future.call.arguments)
[17:36:39.862] }
[17:36:39.862] Lazy evaluation: FALSE
[17:36:39.862] Asynchronous evaluation: FALSE
[17:36:39.862] Local evaluation: TRUE
[17:36:39.862] Environment: 0x5622fb601828
[17:36:39.862] Capture standard output: TRUE
[17:36:39.862] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.862] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.862] Packages: <none>
[17:36:39.862] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.862] Resolved: TRUE
[17:36:39.862] Value: 5.37 KiB of class ‘list’
[17:36:39.862] Early signaling: FALSE
[17:36:39.862] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.862] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.863] Chunk #1 of 1 ... DONE
[17:36:39.863] Launching 1 futures (chunks) ... DONE
[17:36:39.863] Resolving 1 futures (chunks) ...
[17:36:39.863] resolve() on list ...
[17:36:39.864]  recursive: 0
[17:36:39.864]  length: 1
[17:36:39.864] 
[17:36:39.864] resolved() for ‘SequentialFuture’ ...
[17:36:39.864] - state: ‘finished’
[17:36:39.864] - run: TRUE
[17:36:39.864] - result: ‘FutureResult’
[17:36:39.864] resolved() for ‘SequentialFuture’ ... done
[17:36:39.864] Future #1
[17:36:39.865] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.865] - nx: 1
[17:36:39.865] - relay: TRUE
[17:36:39.865] - stdout: TRUE
[17:36:39.865] - signal: TRUE
[17:36:39.865] - resignal: FALSE
[17:36:39.865] - force: TRUE
[17:36:39.865] - relayed: [n=1] FALSE
[17:36:39.865] - queued futures: [n=1] FALSE
[17:36:39.865]  - until=1
[17:36:39.865]  - relaying element #1
[17:36:39.866] - relayed: [n=1] TRUE
[17:36:39.866] - queued futures: [n=1] TRUE
[17:36:39.866] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.866]  length: 0 (resolved future 1)
[17:36:39.866] Relaying remaining futures
[17:36:39.866] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.866] - nx: 1
[17:36:39.866] - relay: TRUE
[17:36:39.866] - stdout: TRUE
[17:36:39.866] - signal: TRUE
[17:36:39.867] - resignal: FALSE
[17:36:39.867] - force: TRUE
[17:36:39.867] - relayed: [n=1] TRUE
[17:36:39.867] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.867] - relayed: [n=1] TRUE
[17:36:39.867] - queued futures: [n=1] TRUE
[17:36:39.867] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.867] resolve() on list ... DONE
[17:36:39.867]  - Number of value chunks collected: 1
[17:36:39.867] Resolving 1 futures (chunks) ... DONE
[17:36:39.868] Reducing values from 1 chunks ...
[17:36:39.868]  - Number of values collected after concatenation: 3
[17:36:39.868]  - Number of values expected: 3
[17:36:39.868] Reducing values from 1 chunks ... DONE
[17:36:39.868] future_lapply() ... DONE
[17:36:39.868] future_by_internal() ... DONE
[17:36:39.871] future_by_internal() ...
- plan('multisession') ...
[17:36:39.871] plan(): Setting new future strategy stack:
[17:36:39.872] List of future strategies:
[17:36:39.872] 1. multisession:
[17:36:39.872]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:39.872]    - tweaked: FALSE
[17:36:39.872]    - call: plan(strategy)
[17:36:39.872] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:36:39.872] multisession:
[17:36:39.872] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:39.872] - tweaked: FALSE
[17:36:39.872] - call: plan(strategy)
[17:36:39.876] getGlobalsAndPackages() ...
[17:36:39.876] Not searching for globals
[17:36:39.876] - globals: [0] <none>
[17:36:39.877] getGlobalsAndPackages() ... DONE
[17:36:39.877] Packages needed by the future expression (n = 0): <none>
[17:36:39.877] Packages needed by future strategies (n = 0): <none>
[17:36:39.878] {
[17:36:39.878]     {
[17:36:39.878]         {
[17:36:39.878]             ...future.startTime <- base::Sys.time()
[17:36:39.878]             {
[17:36:39.878]                 {
[17:36:39.878]                   {
[17:36:39.878]                     base::local({
[17:36:39.878]                       has_future <- base::requireNamespace("future", 
[17:36:39.878]                         quietly = TRUE)
[17:36:39.878]                       if (has_future) {
[17:36:39.878]                         ns <- base::getNamespace("future")
[17:36:39.878]                         version <- ns[[".package"]][["version"]]
[17:36:39.878]                         if (is.null(version)) 
[17:36:39.878]                           version <- utils::packageVersion("future")
[17:36:39.878]                       }
[17:36:39.878]                       else {
[17:36:39.878]                         version <- NULL
[17:36:39.878]                       }
[17:36:39.878]                       if (!has_future || version < "1.8.0") {
[17:36:39.878]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.878]                           "", base::R.version$version.string), 
[17:36:39.878]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:39.878]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.878]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.878]                             "release", "version")], collapse = " "), 
[17:36:39.878]                           hostname = base::Sys.info()[["nodename"]])
[17:36:39.878]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.878]                           info)
[17:36:39.878]                         info <- base::paste(info, collapse = "; ")
[17:36:39.878]                         if (!has_future) {
[17:36:39.878]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.878]                             info)
[17:36:39.878]                         }
[17:36:39.878]                         else {
[17:36:39.878]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.878]                             info, version)
[17:36:39.878]                         }
[17:36:39.878]                         base::stop(msg)
[17:36:39.878]                       }
[17:36:39.878]                     })
[17:36:39.878]                   }
[17:36:39.878]                   ...future.strategy.old <- future::plan("list")
[17:36:39.878]                   options(future.plan = NULL)
[17:36:39.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.878]                 }
[17:36:39.878]                 ...future.workdir <- getwd()
[17:36:39.878]             }
[17:36:39.878]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.878]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.878]         }
[17:36:39.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.878]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.878]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.878]             base::names(...future.oldOptions))
[17:36:39.878]     }
[17:36:39.878]     if (FALSE) {
[17:36:39.878]     }
[17:36:39.878]     else {
[17:36:39.878]         if (TRUE) {
[17:36:39.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.878]                 open = "w")
[17:36:39.878]         }
[17:36:39.878]         else {
[17:36:39.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.878]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.878]         }
[17:36:39.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.878]             base::sink(type = "output", split = FALSE)
[17:36:39.878]             base::close(...future.stdout)
[17:36:39.878]         }, add = TRUE)
[17:36:39.878]     }
[17:36:39.878]     ...future.frame <- base::sys.nframe()
[17:36:39.878]     ...future.conditions <- base::list()
[17:36:39.878]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.878]     if (FALSE) {
[17:36:39.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.878]     }
[17:36:39.878]     ...future.result <- base::tryCatch({
[17:36:39.878]         base::withCallingHandlers({
[17:36:39.878]             ...future.value <- base::withVisible(base::local(NA))
[17:36:39.878]             future::FutureResult(value = ...future.value$value, 
[17:36:39.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.878]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.878]                     ...future.globalenv.names))
[17:36:39.878]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.878]         }, condition = base::local({
[17:36:39.878]             c <- base::c
[17:36:39.878]             inherits <- base::inherits
[17:36:39.878]             invokeRestart <- base::invokeRestart
[17:36:39.878]             length <- base::length
[17:36:39.878]             list <- base::list
[17:36:39.878]             seq.int <- base::seq.int
[17:36:39.878]             signalCondition <- base::signalCondition
[17:36:39.878]             sys.calls <- base::sys.calls
[17:36:39.878]             `[[` <- base::`[[`
[17:36:39.878]             `+` <- base::`+`
[17:36:39.878]             `<<-` <- base::`<<-`
[17:36:39.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.878]                   3L)]
[17:36:39.878]             }
[17:36:39.878]             function(cond) {
[17:36:39.878]                 is_error <- inherits(cond, "error")
[17:36:39.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.878]                   NULL)
[17:36:39.878]                 if (is_error) {
[17:36:39.878]                   sessionInformation <- function() {
[17:36:39.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.878]                       search = base::search(), system = base::Sys.info())
[17:36:39.878]                   }
[17:36:39.878]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.878]                     cond$call), session = sessionInformation(), 
[17:36:39.878]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.878]                   signalCondition(cond)
[17:36:39.878]                 }
[17:36:39.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.878]                 "immediateCondition"))) {
[17:36:39.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.878]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.878]                   if (TRUE && !signal) {
[17:36:39.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.878]                     {
[17:36:39.878]                       inherits <- base::inherits
[17:36:39.878]                       invokeRestart <- base::invokeRestart
[17:36:39.878]                       is.null <- base::is.null
[17:36:39.878]                       muffled <- FALSE
[17:36:39.878]                       if (inherits(cond, "message")) {
[17:36:39.878]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.878]                         if (muffled) 
[17:36:39.878]                           invokeRestart("muffleMessage")
[17:36:39.878]                       }
[17:36:39.878]                       else if (inherits(cond, "warning")) {
[17:36:39.878]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.878]                         if (muffled) 
[17:36:39.878]                           invokeRestart("muffleWarning")
[17:36:39.878]                       }
[17:36:39.878]                       else if (inherits(cond, "condition")) {
[17:36:39.878]                         if (!is.null(pattern)) {
[17:36:39.878]                           computeRestarts <- base::computeRestarts
[17:36:39.878]                           grepl <- base::grepl
[17:36:39.878]                           restarts <- computeRestarts(cond)
[17:36:39.878]                           for (restart in restarts) {
[17:36:39.878]                             name <- restart$name
[17:36:39.878]                             if (is.null(name)) 
[17:36:39.878]                               next
[17:36:39.878]                             if (!grepl(pattern, name)) 
[17:36:39.878]                               next
[17:36:39.878]                             invokeRestart(restart)
[17:36:39.878]                             muffled <- TRUE
[17:36:39.878]                             break
[17:36:39.878]                           }
[17:36:39.878]                         }
[17:36:39.878]                       }
[17:36:39.878]                       invisible(muffled)
[17:36:39.878]                     }
[17:36:39.878]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.878]                   }
[17:36:39.878]                 }
[17:36:39.878]                 else {
[17:36:39.878]                   if (TRUE) {
[17:36:39.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.878]                     {
[17:36:39.878]                       inherits <- base::inherits
[17:36:39.878]                       invokeRestart <- base::invokeRestart
[17:36:39.878]                       is.null <- base::is.null
[17:36:39.878]                       muffled <- FALSE
[17:36:39.878]                       if (inherits(cond, "message")) {
[17:36:39.878]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.878]                         if (muffled) 
[17:36:39.878]                           invokeRestart("muffleMessage")
[17:36:39.878]                       }
[17:36:39.878]                       else if (inherits(cond, "warning")) {
[17:36:39.878]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.878]                         if (muffled) 
[17:36:39.878]                           invokeRestart("muffleWarning")
[17:36:39.878]                       }
[17:36:39.878]                       else if (inherits(cond, "condition")) {
[17:36:39.878]                         if (!is.null(pattern)) {
[17:36:39.878]                           computeRestarts <- base::computeRestarts
[17:36:39.878]                           grepl <- base::grepl
[17:36:39.878]                           restarts <- computeRestarts(cond)
[17:36:39.878]                           for (restart in restarts) {
[17:36:39.878]                             name <- restart$name
[17:36:39.878]                             if (is.null(name)) 
[17:36:39.878]                               next
[17:36:39.878]                             if (!grepl(pattern, name)) 
[17:36:39.878]                               next
[17:36:39.878]                             invokeRestart(restart)
[17:36:39.878]                             muffled <- TRUE
[17:36:39.878]                             break
[17:36:39.878]                           }
[17:36:39.878]                         }
[17:36:39.878]                       }
[17:36:39.878]                       invisible(muffled)
[17:36:39.878]                     }
[17:36:39.878]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.878]                   }
[17:36:39.878]                 }
[17:36:39.878]             }
[17:36:39.878]         }))
[17:36:39.878]     }, error = function(ex) {
[17:36:39.878]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.878]                 ...future.rng), started = ...future.startTime, 
[17:36:39.878]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.878]             version = "1.8"), class = "FutureResult")
[17:36:39.878]     }, finally = {
[17:36:39.878]         if (!identical(...future.workdir, getwd())) 
[17:36:39.878]             setwd(...future.workdir)
[17:36:39.878]         {
[17:36:39.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.878]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.878]             }
[17:36:39.878]             base::options(...future.oldOptions)
[17:36:39.878]             if (.Platform$OS.type == "windows") {
[17:36:39.878]                 old_names <- names(...future.oldEnvVars)
[17:36:39.878]                 envs <- base::Sys.getenv()
[17:36:39.878]                 names <- names(envs)
[17:36:39.878]                 common <- intersect(names, old_names)
[17:36:39.878]                 added <- setdiff(names, old_names)
[17:36:39.878]                 removed <- setdiff(old_names, names)
[17:36:39.878]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.878]                   envs[common]]
[17:36:39.878]                 NAMES <- toupper(changed)
[17:36:39.878]                 args <- list()
[17:36:39.878]                 for (kk in seq_along(NAMES)) {
[17:36:39.878]                   name <- changed[[kk]]
[17:36:39.878]                   NAME <- NAMES[[kk]]
[17:36:39.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.878]                     next
[17:36:39.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.878]                 }
[17:36:39.878]                 NAMES <- toupper(added)
[17:36:39.878]                 for (kk in seq_along(NAMES)) {
[17:36:39.878]                   name <- added[[kk]]
[17:36:39.878]                   NAME <- NAMES[[kk]]
[17:36:39.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.878]                     next
[17:36:39.878]                   args[[name]] <- ""
[17:36:39.878]                 }
[17:36:39.878]                 NAMES <- toupper(removed)
[17:36:39.878]                 for (kk in seq_along(NAMES)) {
[17:36:39.878]                   name <- removed[[kk]]
[17:36:39.878]                   NAME <- NAMES[[kk]]
[17:36:39.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.878]                     next
[17:36:39.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.878]                 }
[17:36:39.878]                 if (length(args) > 0) 
[17:36:39.878]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.878]             }
[17:36:39.878]             else {
[17:36:39.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.878]             }
[17:36:39.878]             {
[17:36:39.878]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.878]                   0L) {
[17:36:39.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.878]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.878]                   base::options(opts)
[17:36:39.878]                 }
[17:36:39.878]                 {
[17:36:39.878]                   {
[17:36:39.878]                     NULL
[17:36:39.878]                     RNGkind("Mersenne-Twister")
[17:36:39.878]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.878]                       inherits = FALSE)
[17:36:39.878]                   }
[17:36:39.878]                   options(future.plan = NULL)
[17:36:39.878]                   if (is.na(NA_character_)) 
[17:36:39.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.878]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.878]                     .init = FALSE)
[17:36:39.878]                 }
[17:36:39.878]             }
[17:36:39.878]         }
[17:36:39.878]     })
[17:36:39.878]     if (TRUE) {
[17:36:39.878]         base::sink(type = "output", split = FALSE)
[17:36:39.878]         if (TRUE) {
[17:36:39.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.878]         }
[17:36:39.878]         else {
[17:36:39.878]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.878]         }
[17:36:39.878]         base::close(...future.stdout)
[17:36:39.878]         ...future.stdout <- NULL
[17:36:39.878]     }
[17:36:39.878]     ...future.result$conditions <- ...future.conditions
[17:36:39.878]     ...future.result$finished <- base::Sys.time()
[17:36:39.878]     ...future.result
[17:36:39.878] }
[17:36:39.880] plan(): Setting new future strategy stack:
[17:36:39.880] List of future strategies:
[17:36:39.880] 1. sequential:
[17:36:39.880]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.880]    - tweaked: FALSE
[17:36:39.880]    - call: NULL
[17:36:39.880] plan(): nbrOfWorkers() = 1
[17:36:39.881] plan(): Setting new future strategy stack:
[17:36:39.881] List of future strategies:
[17:36:39.881] 1. multisession:
[17:36:39.881]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:39.881]    - tweaked: FALSE
[17:36:39.881]    - call: plan(strategy)
[17:36:39.884] plan(): nbrOfWorkers() = 1
[17:36:39.885] SequentialFuture started (and completed)
[17:36:39.885] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:36:39.888] plan(): nbrOfWorkers() = 1
[17:36:39.888] future_by_internal() ...
[17:36:39.888] future_lapply() ...
[17:36:39.891] Number of chunks: 1
[17:36:39.892] getGlobalsAndPackagesXApply() ...
[17:36:39.892]  - future.globals: TRUE
[17:36:39.892] getGlobalsAndPackages() ...
[17:36:39.892] Searching for globals...
[17:36:39.893] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:39.893] Searching for globals ... DONE
[17:36:39.893] Resolving globals: FALSE
[17:36:39.894] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:39.894] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:39.894] - globals: [1] ‘FUN’
[17:36:39.894] 
[17:36:39.894] getGlobalsAndPackages() ... DONE
[17:36:39.894]  - globals found/used: [n=1] ‘FUN’
[17:36:39.894]  - needed namespaces: [n=0] 
[17:36:39.895] Finding globals ... DONE
[17:36:39.895]  - use_args: TRUE
[17:36:39.895]  - Getting '...' globals ...
[17:36:39.895] resolve() on list ...
[17:36:39.895]  recursive: 0
[17:36:39.895]  length: 1
[17:36:39.895]  elements: ‘...’
[17:36:39.895]  length: 0 (resolved future 1)
[17:36:39.895] resolve() on list ... DONE
[17:36:39.896]    - '...' content: [n=0] 
[17:36:39.896] List of 1
[17:36:39.896]  $ ...: list()
[17:36:39.896]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.896]  - attr(*, "where")=List of 1
[17:36:39.896]   ..$ ...:<environment: 0x5622fb8d1040> 
[17:36:39.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.896]  - attr(*, "resolved")= logi TRUE
[17:36:39.896]  - attr(*, "total_size")= num NA
[17:36:39.898]  - Getting '...' globals ... DONE
[17:36:39.898] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.898] List of 2
[17:36:39.898]  $ ...future.FUN:function (object, ...)  
[17:36:39.898]  $ ...          : list()
[17:36:39.898]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.898]  - attr(*, "where")=List of 2
[17:36:39.898]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.898]   ..$ ...          :<environment: 0x5622fb8d1040> 
[17:36:39.898]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.898]  - attr(*, "resolved")= logi FALSE
[17:36:39.898]  - attr(*, "total_size")= num 1240
[17:36:39.901] Packages to be attached in all futures: [n=0] 
[17:36:39.901] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.901] Number of futures (= number of chunks): 1
[17:36:39.902] Launching 1 futures (chunks) ...
[17:36:39.902] Chunk #1 of 1 ...
[17:36:39.902]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.902] getGlobalsAndPackages() ...
[17:36:39.902] Searching for globals...
[17:36:39.902] 
[17:36:39.903] Searching for globals ... DONE
[17:36:39.903] - globals: [0] <none>
[17:36:39.903] getGlobalsAndPackages() ... DONE
[17:36:39.903]    + additional globals found: [n=0] 
[17:36:39.904]    + additional namespaces needed: [n=0] 
[17:36:39.905]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.905]  - seeds: <none>
[17:36:39.905]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.905] getGlobalsAndPackages() ...
[17:36:39.905] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.905] Resolving globals: FALSE
[17:36:39.905] Tweak future expression to call with '...' arguments ...
[17:36:39.905] {
[17:36:39.905]     do.call(function(...) {
[17:36:39.905]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.905]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.905]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.905]             on.exit(options(oopts), add = TRUE)
[17:36:39.905]         }
[17:36:39.905]         {
[17:36:39.905]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.905]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.905]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.905]             })
[17:36:39.905]         }
[17:36:39.905]     }, args = future.call.arguments)
[17:36:39.905] }
[17:36:39.906] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.906] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.906] 
[17:36:39.906] getGlobalsAndPackages() ... DONE
[17:36:39.907] run() for ‘Future’ ...
[17:36:39.907] - state: ‘created’
[17:36:39.907] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:39.911] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.911] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.911]   - Field: ‘label’
[17:36:39.911]   - Field: ‘local’
[17:36:39.911]   - Field: ‘owner’
[17:36:39.911]   - Field: ‘envir’
[17:36:39.911]   - Field: ‘packages’
[17:36:39.912]   - Field: ‘gc’
[17:36:39.912]   - Field: ‘conditions’
[17:36:39.912]   - Field: ‘expr’
[17:36:39.912]   - Field: ‘uuid’
[17:36:39.912]   - Field: ‘seed’
[17:36:39.912]   - Field: ‘version’
[17:36:39.912]   - Field: ‘result’
[17:36:39.912]   - Field: ‘asynchronous’
[17:36:39.912]   - Field: ‘calls’
[17:36:39.913]   - Field: ‘globals’
[17:36:39.913]   - Field: ‘stdout’
[17:36:39.913]   - Field: ‘earlySignal’
[17:36:39.913]   - Field: ‘lazy’
[17:36:39.913]   - Field: ‘state’
[17:36:39.913] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.913] - Launch lazy future ...
[17:36:39.913] Packages needed by the future expression (n = 0): <none>
[17:36:39.913] Packages needed by future strategies (n = 0): <none>
[17:36:39.914] {
[17:36:39.914]     {
[17:36:39.914]         {
[17:36:39.914]             ...future.startTime <- base::Sys.time()
[17:36:39.914]             {
[17:36:39.914]                 {
[17:36:39.914]                   {
[17:36:39.914]                     base::local({
[17:36:39.914]                       has_future <- base::requireNamespace("future", 
[17:36:39.914]                         quietly = TRUE)
[17:36:39.914]                       if (has_future) {
[17:36:39.914]                         ns <- base::getNamespace("future")
[17:36:39.914]                         version <- ns[[".package"]][["version"]]
[17:36:39.914]                         if (is.null(version)) 
[17:36:39.914]                           version <- utils::packageVersion("future")
[17:36:39.914]                       }
[17:36:39.914]                       else {
[17:36:39.914]                         version <- NULL
[17:36:39.914]                       }
[17:36:39.914]                       if (!has_future || version < "1.8.0") {
[17:36:39.914]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.914]                           "", base::R.version$version.string), 
[17:36:39.914]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:39.914]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.914]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.914]                             "release", "version")], collapse = " "), 
[17:36:39.914]                           hostname = base::Sys.info()[["nodename"]])
[17:36:39.914]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.914]                           info)
[17:36:39.914]                         info <- base::paste(info, collapse = "; ")
[17:36:39.914]                         if (!has_future) {
[17:36:39.914]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.914]                             info)
[17:36:39.914]                         }
[17:36:39.914]                         else {
[17:36:39.914]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.914]                             info, version)
[17:36:39.914]                         }
[17:36:39.914]                         base::stop(msg)
[17:36:39.914]                       }
[17:36:39.914]                     })
[17:36:39.914]                   }
[17:36:39.914]                   ...future.strategy.old <- future::plan("list")
[17:36:39.914]                   options(future.plan = NULL)
[17:36:39.914]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.914]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.914]                 }
[17:36:39.914]                 ...future.workdir <- getwd()
[17:36:39.914]             }
[17:36:39.914]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.914]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.914]         }
[17:36:39.914]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.914]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.914]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.914]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.914]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.914]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.914]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.914]             base::names(...future.oldOptions))
[17:36:39.914]     }
[17:36:39.914]     if (FALSE) {
[17:36:39.914]     }
[17:36:39.914]     else {
[17:36:39.914]         if (TRUE) {
[17:36:39.914]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.914]                 open = "w")
[17:36:39.914]         }
[17:36:39.914]         else {
[17:36:39.914]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.914]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.914]         }
[17:36:39.914]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.914]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.914]             base::sink(type = "output", split = FALSE)
[17:36:39.914]             base::close(...future.stdout)
[17:36:39.914]         }, add = TRUE)
[17:36:39.914]     }
[17:36:39.914]     ...future.frame <- base::sys.nframe()
[17:36:39.914]     ...future.conditions <- base::list()
[17:36:39.914]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.914]     if (FALSE) {
[17:36:39.914]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.914]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.914]     }
[17:36:39.914]     ...future.result <- base::tryCatch({
[17:36:39.914]         base::withCallingHandlers({
[17:36:39.914]             ...future.value <- base::withVisible(base::local({
[17:36:39.914]                 do.call(function(...) {
[17:36:39.914]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.914]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.914]                     ...future.globals.maxSize)) {
[17:36:39.914]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.914]                     on.exit(options(oopts), add = TRUE)
[17:36:39.914]                   }
[17:36:39.914]                   {
[17:36:39.914]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.914]                       FUN = function(jj) {
[17:36:39.914]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.914]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.914]                       })
[17:36:39.914]                   }
[17:36:39.914]                 }, args = future.call.arguments)
[17:36:39.914]             }))
[17:36:39.914]             future::FutureResult(value = ...future.value$value, 
[17:36:39.914]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.914]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.914]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.914]                     ...future.globalenv.names))
[17:36:39.914]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.914]         }, condition = base::local({
[17:36:39.914]             c <- base::c
[17:36:39.914]             inherits <- base::inherits
[17:36:39.914]             invokeRestart <- base::invokeRestart
[17:36:39.914]             length <- base::length
[17:36:39.914]             list <- base::list
[17:36:39.914]             seq.int <- base::seq.int
[17:36:39.914]             signalCondition <- base::signalCondition
[17:36:39.914]             sys.calls <- base::sys.calls
[17:36:39.914]             `[[` <- base::`[[`
[17:36:39.914]             `+` <- base::`+`
[17:36:39.914]             `<<-` <- base::`<<-`
[17:36:39.914]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.914]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.914]                   3L)]
[17:36:39.914]             }
[17:36:39.914]             function(cond) {
[17:36:39.914]                 is_error <- inherits(cond, "error")
[17:36:39.914]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.914]                   NULL)
[17:36:39.914]                 if (is_error) {
[17:36:39.914]                   sessionInformation <- function() {
[17:36:39.914]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.914]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.914]                       search = base::search(), system = base::Sys.info())
[17:36:39.914]                   }
[17:36:39.914]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.914]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.914]                     cond$call), session = sessionInformation(), 
[17:36:39.914]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.914]                   signalCondition(cond)
[17:36:39.914]                 }
[17:36:39.914]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.914]                 "immediateCondition"))) {
[17:36:39.914]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.914]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.914]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.914]                   if (TRUE && !signal) {
[17:36:39.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.914]                     {
[17:36:39.914]                       inherits <- base::inherits
[17:36:39.914]                       invokeRestart <- base::invokeRestart
[17:36:39.914]                       is.null <- base::is.null
[17:36:39.914]                       muffled <- FALSE
[17:36:39.914]                       if (inherits(cond, "message")) {
[17:36:39.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.914]                         if (muffled) 
[17:36:39.914]                           invokeRestart("muffleMessage")
[17:36:39.914]                       }
[17:36:39.914]                       else if (inherits(cond, "warning")) {
[17:36:39.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.914]                         if (muffled) 
[17:36:39.914]                           invokeRestart("muffleWarning")
[17:36:39.914]                       }
[17:36:39.914]                       else if (inherits(cond, "condition")) {
[17:36:39.914]                         if (!is.null(pattern)) {
[17:36:39.914]                           computeRestarts <- base::computeRestarts
[17:36:39.914]                           grepl <- base::grepl
[17:36:39.914]                           restarts <- computeRestarts(cond)
[17:36:39.914]                           for (restart in restarts) {
[17:36:39.914]                             name <- restart$name
[17:36:39.914]                             if (is.null(name)) 
[17:36:39.914]                               next
[17:36:39.914]                             if (!grepl(pattern, name)) 
[17:36:39.914]                               next
[17:36:39.914]                             invokeRestart(restart)
[17:36:39.914]                             muffled <- TRUE
[17:36:39.914]                             break
[17:36:39.914]                           }
[17:36:39.914]                         }
[17:36:39.914]                       }
[17:36:39.914]                       invisible(muffled)
[17:36:39.914]                     }
[17:36:39.914]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.914]                   }
[17:36:39.914]                 }
[17:36:39.914]                 else {
[17:36:39.914]                   if (TRUE) {
[17:36:39.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.914]                     {
[17:36:39.914]                       inherits <- base::inherits
[17:36:39.914]                       invokeRestart <- base::invokeRestart
[17:36:39.914]                       is.null <- base::is.null
[17:36:39.914]                       muffled <- FALSE
[17:36:39.914]                       if (inherits(cond, "message")) {
[17:36:39.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.914]                         if (muffled) 
[17:36:39.914]                           invokeRestart("muffleMessage")
[17:36:39.914]                       }
[17:36:39.914]                       else if (inherits(cond, "warning")) {
[17:36:39.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.914]                         if (muffled) 
[17:36:39.914]                           invokeRestart("muffleWarning")
[17:36:39.914]                       }
[17:36:39.914]                       else if (inherits(cond, "condition")) {
[17:36:39.914]                         if (!is.null(pattern)) {
[17:36:39.914]                           computeRestarts <- base::computeRestarts
[17:36:39.914]                           grepl <- base::grepl
[17:36:39.914]                           restarts <- computeRestarts(cond)
[17:36:39.914]                           for (restart in restarts) {
[17:36:39.914]                             name <- restart$name
[17:36:39.914]                             if (is.null(name)) 
[17:36:39.914]                               next
[17:36:39.914]                             if (!grepl(pattern, name)) 
[17:36:39.914]                               next
[17:36:39.914]                             invokeRestart(restart)
[17:36:39.914]                             muffled <- TRUE
[17:36:39.914]                             break
[17:36:39.914]                           }
[17:36:39.914]                         }
[17:36:39.914]                       }
[17:36:39.914]                       invisible(muffled)
[17:36:39.914]                     }
[17:36:39.914]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.914]                   }
[17:36:39.914]                 }
[17:36:39.914]             }
[17:36:39.914]         }))
[17:36:39.914]     }, error = function(ex) {
[17:36:39.914]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.914]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.914]                 ...future.rng), started = ...future.startTime, 
[17:36:39.914]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.914]             version = "1.8"), class = "FutureResult")
[17:36:39.914]     }, finally = {
[17:36:39.914]         if (!identical(...future.workdir, getwd())) 
[17:36:39.914]             setwd(...future.workdir)
[17:36:39.914]         {
[17:36:39.914]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.914]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.914]             }
[17:36:39.914]             base::options(...future.oldOptions)
[17:36:39.914]             if (.Platform$OS.type == "windows") {
[17:36:39.914]                 old_names <- names(...future.oldEnvVars)
[17:36:39.914]                 envs <- base::Sys.getenv()
[17:36:39.914]                 names <- names(envs)
[17:36:39.914]                 common <- intersect(names, old_names)
[17:36:39.914]                 added <- setdiff(names, old_names)
[17:36:39.914]                 removed <- setdiff(old_names, names)
[17:36:39.914]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.914]                   envs[common]]
[17:36:39.914]                 NAMES <- toupper(changed)
[17:36:39.914]                 args <- list()
[17:36:39.914]                 for (kk in seq_along(NAMES)) {
[17:36:39.914]                   name <- changed[[kk]]
[17:36:39.914]                   NAME <- NAMES[[kk]]
[17:36:39.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.914]                     next
[17:36:39.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.914]                 }
[17:36:39.914]                 NAMES <- toupper(added)
[17:36:39.914]                 for (kk in seq_along(NAMES)) {
[17:36:39.914]                   name <- added[[kk]]
[17:36:39.914]                   NAME <- NAMES[[kk]]
[17:36:39.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.914]                     next
[17:36:39.914]                   args[[name]] <- ""
[17:36:39.914]                 }
[17:36:39.914]                 NAMES <- toupper(removed)
[17:36:39.914]                 for (kk in seq_along(NAMES)) {
[17:36:39.914]                   name <- removed[[kk]]
[17:36:39.914]                   NAME <- NAMES[[kk]]
[17:36:39.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.914]                     next
[17:36:39.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.914]                 }
[17:36:39.914]                 if (length(args) > 0) 
[17:36:39.914]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.914]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.914]             }
[17:36:39.914]             else {
[17:36:39.914]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.914]             }
[17:36:39.914]             {
[17:36:39.914]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.914]                   0L) {
[17:36:39.914]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.914]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.914]                   base::options(opts)
[17:36:39.914]                 }
[17:36:39.914]                 {
[17:36:39.914]                   {
[17:36:39.914]                     NULL
[17:36:39.914]                     RNGkind("Mersenne-Twister")
[17:36:39.914]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.914]                       inherits = FALSE)
[17:36:39.914]                   }
[17:36:39.914]                   options(future.plan = NULL)
[17:36:39.914]                   if (is.na(NA_character_)) 
[17:36:39.914]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.914]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.914]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.914]                     .init = FALSE)
[17:36:39.914]                 }
[17:36:39.914]             }
[17:36:39.914]         }
[17:36:39.914]     })
[17:36:39.914]     if (TRUE) {
[17:36:39.914]         base::sink(type = "output", split = FALSE)
[17:36:39.914]         if (TRUE) {
[17:36:39.914]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.914]         }
[17:36:39.914]         else {
[17:36:39.914]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.914]         }
[17:36:39.914]         base::close(...future.stdout)
[17:36:39.914]         ...future.stdout <- NULL
[17:36:39.914]     }
[17:36:39.914]     ...future.result$conditions <- ...future.conditions
[17:36:39.914]     ...future.result$finished <- base::Sys.time()
[17:36:39.914]     ...future.result
[17:36:39.914] }
[17:36:39.916] assign_globals() ...
[17:36:39.916] List of 5
[17:36:39.916]  $ ...future.FUN            :function (object, ...)  
[17:36:39.916]  $ future.call.arguments    : list()
[17:36:39.916]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.916]  $ ...future.elements_ii    :List of 3
[17:36:39.916]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:39.916]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:39.916]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.916]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:39.916]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:39.916]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.916]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:39.916]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:39.916]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:39.916]  $ ...future.seeds_ii       : NULL
[17:36:39.916]  $ ...future.globals.maxSize: NULL
[17:36:39.916]  - attr(*, "where")=List of 5
[17:36:39.916]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.916]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.916]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.916]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.916]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.916]  - attr(*, "resolved")= logi FALSE
[17:36:39.916]  - attr(*, "total_size")= num 1240
[17:36:39.916]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.916]  - attr(*, "already-done")= logi TRUE
[17:36:39.923] - copied ‘...future.FUN’ to environment
[17:36:39.923] - copied ‘future.call.arguments’ to environment
[17:36:39.923] - copied ‘...future.elements_ii’ to environment
[17:36:39.923] - copied ‘...future.seeds_ii’ to environment
[17:36:39.923] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.924] assign_globals() ... done
[17:36:39.924] plan(): Setting new future strategy stack:
[17:36:39.924] List of future strategies:
[17:36:39.924] 1. sequential:
[17:36:39.924]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.924]    - tweaked: FALSE
[17:36:39.924]    - call: NULL
[17:36:39.924] plan(): nbrOfWorkers() = 1
[17:36:39.926] plan(): Setting new future strategy stack:
[17:36:39.926] List of future strategies:
[17:36:39.926] 1. multisession:
[17:36:39.926]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:39.926]    - tweaked: FALSE
[17:36:39.926]    - call: plan(strategy)
[17:36:39.930] plan(): nbrOfWorkers() = 1
[17:36:39.930] SequentialFuture started (and completed)
[17:36:39.930] - Launch lazy future ... done
[17:36:39.930] run() for ‘SequentialFuture’ ... done
[17:36:39.930] Created future:
[17:36:39.931] SequentialFuture:
[17:36:39.931] Label: ‘future_by-1’
[17:36:39.931] Expression:
[17:36:39.931] {
[17:36:39.931]     do.call(function(...) {
[17:36:39.931]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.931]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.931]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.931]             on.exit(options(oopts), add = TRUE)
[17:36:39.931]         }
[17:36:39.931]         {
[17:36:39.931]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.931]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.931]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.931]             })
[17:36:39.931]         }
[17:36:39.931]     }, args = future.call.arguments)
[17:36:39.931] }
[17:36:39.931] Lazy evaluation: FALSE
[17:36:39.931] Asynchronous evaluation: FALSE
[17:36:39.931] Local evaluation: TRUE
[17:36:39.931] Environment: R_GlobalEnv
[17:36:39.931] Capture standard output: TRUE
[17:36:39.931] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.931] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.931] Packages: <none>
[17:36:39.931] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.931] Resolved: TRUE
[17:36:39.931] Value: 4.62 KiB of class ‘list’
[17:36:39.931] Early signaling: FALSE
[17:36:39.931] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.931] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.932] Chunk #1 of 1 ... DONE
[17:36:39.932] Launching 1 futures (chunks) ... DONE
[17:36:39.932] Resolving 1 futures (chunks) ...
[17:36:39.932] resolve() on list ...
[17:36:39.932]  recursive: 0
[17:36:39.932]  length: 1
[17:36:39.932] 
[17:36:39.932] resolved() for ‘SequentialFuture’ ...
[17:36:39.933] - state: ‘finished’
[17:36:39.933] - run: TRUE
[17:36:39.933] - result: ‘FutureResult’
[17:36:39.933] resolved() for ‘SequentialFuture’ ... done
[17:36:39.933] Future #1
[17:36:39.934] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.935] - nx: 1
[17:36:39.935] - relay: TRUE
[17:36:39.935] - stdout: TRUE
[17:36:39.935] - signal: TRUE
[17:36:39.935] - resignal: FALSE
[17:36:39.935] - force: TRUE
[17:36:39.935] - relayed: [n=1] FALSE
[17:36:39.935] - queued futures: [n=1] FALSE
[17:36:39.935]  - until=1
[17:36:39.935]  - relaying element #1
[17:36:39.936] - relayed: [n=1] TRUE
[17:36:39.936] - queued futures: [n=1] TRUE
[17:36:39.936] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.936]  length: 0 (resolved future 1)
[17:36:39.936] Relaying remaining futures
[17:36:39.936] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.936] - nx: 1
[17:36:39.936] - relay: TRUE
[17:36:39.937] - stdout: TRUE
[17:36:39.937] - signal: TRUE
[17:36:39.937] - resignal: FALSE
[17:36:39.937] - force: TRUE
[17:36:39.937] - relayed: [n=1] TRUE
[17:36:39.937] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.937] - relayed: [n=1] TRUE
[17:36:39.937] - queued futures: [n=1] TRUE
[17:36:39.937] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.937] resolve() on list ... DONE
[17:36:39.938]  - Number of value chunks collected: 1
[17:36:39.938] Resolving 1 futures (chunks) ... DONE
[17:36:39.938] Reducing values from 1 chunks ...
[17:36:39.938]  - Number of values collected after concatenation: 3
[17:36:39.938]  - Number of values expected: 3
[17:36:39.938] Reducing values from 1 chunks ... DONE
[17:36:39.938] future_lapply() ... DONE
[17:36:39.938] future_by_internal() ... DONE
[17:36:39.938] future_by_internal() ...
[17:36:39.939] future_lapply() ...
[17:36:39.942] Number of chunks: 1
[17:36:39.942] getGlobalsAndPackagesXApply() ...
[17:36:39.943]  - future.globals: TRUE
[17:36:39.943] getGlobalsAndPackages() ...
[17:36:39.943] Searching for globals...
[17:36:39.944] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:39.944] Searching for globals ... DONE
[17:36:39.944] Resolving globals: FALSE
[17:36:39.944] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:39.945] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:39.945] - globals: [1] ‘FUN’
[17:36:39.945] 
[17:36:39.945] getGlobalsAndPackages() ... DONE
[17:36:39.945]  - globals found/used: [n=1] ‘FUN’
[17:36:39.945]  - needed namespaces: [n=0] 
[17:36:39.945] Finding globals ... DONE
[17:36:39.945]  - use_args: TRUE
[17:36:39.946]  - Getting '...' globals ...
[17:36:39.946] resolve() on list ...
[17:36:39.946]  recursive: 0
[17:36:39.946]  length: 1
[17:36:39.946]  elements: ‘...’
[17:36:39.946]  length: 0 (resolved future 1)
[17:36:39.946] resolve() on list ... DONE
[17:36:39.946]    - '...' content: [n=1] ‘digits’
[17:36:39.947] List of 1
[17:36:39.947]  $ ...:List of 1
[17:36:39.947]   ..$ digits: int 2
[17:36:39.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.947]  - attr(*, "where")=List of 1
[17:36:39.947]   ..$ ...:<environment: 0x5622fb555e70> 
[17:36:39.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.947]  - attr(*, "resolved")= logi TRUE
[17:36:39.947]  - attr(*, "total_size")= num NA
[17:36:39.949]  - Getting '...' globals ... DONE
[17:36:39.950] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:39.950] List of 2
[17:36:39.950]  $ ...future.FUN:function (object, ...)  
[17:36:39.950]  $ ...          :List of 1
[17:36:39.950]   ..$ digits: int 2
[17:36:39.950]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.950]  - attr(*, "where")=List of 2
[17:36:39.950]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:39.950]   ..$ ...          :<environment: 0x5622fb555e70> 
[17:36:39.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.950]  - attr(*, "resolved")= logi FALSE
[17:36:39.950]  - attr(*, "total_size")= num 1296
[17:36:39.953] Packages to be attached in all futures: [n=0] 
[17:36:39.953] getGlobalsAndPackagesXApply() ... DONE
[17:36:39.953] Number of futures (= number of chunks): 1
[17:36:39.953] Launching 1 futures (chunks) ...
[17:36:39.953] Chunk #1 of 1 ...
[17:36:39.953]  - Finding globals in 'X' for chunk #1 ...
[17:36:39.953] getGlobalsAndPackages() ...
[17:36:39.954] Searching for globals...
[17:36:39.954] 
[17:36:39.954] Searching for globals ... DONE
[17:36:39.954] - globals: [0] <none>
[17:36:39.954] getGlobalsAndPackages() ... DONE
[17:36:39.954]    + additional globals found: [n=0] 
[17:36:39.954]    + additional namespaces needed: [n=0] 
[17:36:39.954]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:39.954]  - seeds: <none>
[17:36:39.955]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.955] getGlobalsAndPackages() ...
[17:36:39.955] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.955] Resolving globals: FALSE
[17:36:39.955] Tweak future expression to call with '...' arguments ...
[17:36:39.955] {
[17:36:39.955]     do.call(function(...) {
[17:36:39.955]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.955]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.955]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.955]             on.exit(options(oopts), add = TRUE)
[17:36:39.955]         }
[17:36:39.955]         {
[17:36:39.955]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.955]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.955]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.955]             })
[17:36:39.955]         }
[17:36:39.955]     }, args = future.call.arguments)
[17:36:39.955] }
[17:36:39.955] Tweak future expression to call with '...' arguments ... DONE
[17:36:39.956] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:39.956] 
[17:36:39.956] getGlobalsAndPackages() ... DONE
[17:36:39.956] run() for ‘Future’ ...
[17:36:39.956] - state: ‘created’
[17:36:39.956] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:39.960] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.960] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:39.960]   - Field: ‘label’
[17:36:39.960]   - Field: ‘local’
[17:36:39.960]   - Field: ‘owner’
[17:36:39.960]   - Field: ‘envir’
[17:36:39.962]   - Field: ‘packages’
[17:36:39.962]   - Field: ‘gc’
[17:36:39.962]   - Field: ‘conditions’
[17:36:39.962]   - Field: ‘expr’
[17:36:39.963]   - Field: ‘uuid’
[17:36:39.963]   - Field: ‘seed’
[17:36:39.963]   - Field: ‘version’
[17:36:39.963]   - Field: ‘result’
[17:36:39.963]   - Field: ‘asynchronous’
[17:36:39.963]   - Field: ‘calls’
[17:36:39.963]   - Field: ‘globals’
[17:36:39.963]   - Field: ‘stdout’
[17:36:39.963]   - Field: ‘earlySignal’
[17:36:39.963]   - Field: ‘lazy’
[17:36:39.964]   - Field: ‘state’
[17:36:39.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:39.964] - Launch lazy future ...
[17:36:39.964] Packages needed by the future expression (n = 0): <none>
[17:36:39.964] Packages needed by future strategies (n = 0): <none>
[17:36:39.965] {
[17:36:39.965]     {
[17:36:39.965]         {
[17:36:39.965]             ...future.startTime <- base::Sys.time()
[17:36:39.965]             {
[17:36:39.965]                 {
[17:36:39.965]                   {
[17:36:39.965]                     base::local({
[17:36:39.965]                       has_future <- base::requireNamespace("future", 
[17:36:39.965]                         quietly = TRUE)
[17:36:39.965]                       if (has_future) {
[17:36:39.965]                         ns <- base::getNamespace("future")
[17:36:39.965]                         version <- ns[[".package"]][["version"]]
[17:36:39.965]                         if (is.null(version)) 
[17:36:39.965]                           version <- utils::packageVersion("future")
[17:36:39.965]                       }
[17:36:39.965]                       else {
[17:36:39.965]                         version <- NULL
[17:36:39.965]                       }
[17:36:39.965]                       if (!has_future || version < "1.8.0") {
[17:36:39.965]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:39.965]                           "", base::R.version$version.string), 
[17:36:39.965]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:39.965]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:39.965]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:39.965]                             "release", "version")], collapse = " "), 
[17:36:39.965]                           hostname = base::Sys.info()[["nodename"]])
[17:36:39.965]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:39.965]                           info)
[17:36:39.965]                         info <- base::paste(info, collapse = "; ")
[17:36:39.965]                         if (!has_future) {
[17:36:39.965]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:39.965]                             info)
[17:36:39.965]                         }
[17:36:39.965]                         else {
[17:36:39.965]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:39.965]                             info, version)
[17:36:39.965]                         }
[17:36:39.965]                         base::stop(msg)
[17:36:39.965]                       }
[17:36:39.965]                     })
[17:36:39.965]                   }
[17:36:39.965]                   ...future.strategy.old <- future::plan("list")
[17:36:39.965]                   options(future.plan = NULL)
[17:36:39.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:39.965]                 }
[17:36:39.965]                 ...future.workdir <- getwd()
[17:36:39.965]             }
[17:36:39.965]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:39.965]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:39.965]         }
[17:36:39.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:39.965]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:39.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:39.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:39.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:39.965]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:39.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:39.965]             base::names(...future.oldOptions))
[17:36:39.965]     }
[17:36:39.965]     if (FALSE) {
[17:36:39.965]     }
[17:36:39.965]     else {
[17:36:39.965]         if (TRUE) {
[17:36:39.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:39.965]                 open = "w")
[17:36:39.965]         }
[17:36:39.965]         else {
[17:36:39.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:39.965]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:39.965]         }
[17:36:39.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:39.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:39.965]             base::sink(type = "output", split = FALSE)
[17:36:39.965]             base::close(...future.stdout)
[17:36:39.965]         }, add = TRUE)
[17:36:39.965]     }
[17:36:39.965]     ...future.frame <- base::sys.nframe()
[17:36:39.965]     ...future.conditions <- base::list()
[17:36:39.965]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:39.965]     if (FALSE) {
[17:36:39.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:39.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:39.965]     }
[17:36:39.965]     ...future.result <- base::tryCatch({
[17:36:39.965]         base::withCallingHandlers({
[17:36:39.965]             ...future.value <- base::withVisible(base::local({
[17:36:39.965]                 do.call(function(...) {
[17:36:39.965]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.965]                   if (!identical(...future.globals.maxSize.org, 
[17:36:39.965]                     ...future.globals.maxSize)) {
[17:36:39.965]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.965]                     on.exit(options(oopts), add = TRUE)
[17:36:39.965]                   }
[17:36:39.965]                   {
[17:36:39.965]                     lapply(seq_along(...future.elements_ii), 
[17:36:39.965]                       FUN = function(jj) {
[17:36:39.965]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.965]                         ...future.FUN(...future.X_jj, ...)
[17:36:39.965]                       })
[17:36:39.965]                   }
[17:36:39.965]                 }, args = future.call.arguments)
[17:36:39.965]             }))
[17:36:39.965]             future::FutureResult(value = ...future.value$value, 
[17:36:39.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.965]                   ...future.rng), globalenv = if (FALSE) 
[17:36:39.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:39.965]                     ...future.globalenv.names))
[17:36:39.965]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:39.965]         }, condition = base::local({
[17:36:39.965]             c <- base::c
[17:36:39.965]             inherits <- base::inherits
[17:36:39.965]             invokeRestart <- base::invokeRestart
[17:36:39.965]             length <- base::length
[17:36:39.965]             list <- base::list
[17:36:39.965]             seq.int <- base::seq.int
[17:36:39.965]             signalCondition <- base::signalCondition
[17:36:39.965]             sys.calls <- base::sys.calls
[17:36:39.965]             `[[` <- base::`[[`
[17:36:39.965]             `+` <- base::`+`
[17:36:39.965]             `<<-` <- base::`<<-`
[17:36:39.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:39.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:39.965]                   3L)]
[17:36:39.965]             }
[17:36:39.965]             function(cond) {
[17:36:39.965]                 is_error <- inherits(cond, "error")
[17:36:39.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:39.965]                   NULL)
[17:36:39.965]                 if (is_error) {
[17:36:39.965]                   sessionInformation <- function() {
[17:36:39.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:39.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:39.965]                       search = base::search(), system = base::Sys.info())
[17:36:39.965]                   }
[17:36:39.965]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:39.965]                     cond$call), session = sessionInformation(), 
[17:36:39.965]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:39.965]                   signalCondition(cond)
[17:36:39.965]                 }
[17:36:39.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:39.965]                 "immediateCondition"))) {
[17:36:39.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:39.965]                   ...future.conditions[[length(...future.conditions) + 
[17:36:39.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:39.965]                   if (TRUE && !signal) {
[17:36:39.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.965]                     {
[17:36:39.965]                       inherits <- base::inherits
[17:36:39.965]                       invokeRestart <- base::invokeRestart
[17:36:39.965]                       is.null <- base::is.null
[17:36:39.965]                       muffled <- FALSE
[17:36:39.965]                       if (inherits(cond, "message")) {
[17:36:39.965]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.965]                         if (muffled) 
[17:36:39.965]                           invokeRestart("muffleMessage")
[17:36:39.965]                       }
[17:36:39.965]                       else if (inherits(cond, "warning")) {
[17:36:39.965]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.965]                         if (muffled) 
[17:36:39.965]                           invokeRestart("muffleWarning")
[17:36:39.965]                       }
[17:36:39.965]                       else if (inherits(cond, "condition")) {
[17:36:39.965]                         if (!is.null(pattern)) {
[17:36:39.965]                           computeRestarts <- base::computeRestarts
[17:36:39.965]                           grepl <- base::grepl
[17:36:39.965]                           restarts <- computeRestarts(cond)
[17:36:39.965]                           for (restart in restarts) {
[17:36:39.965]                             name <- restart$name
[17:36:39.965]                             if (is.null(name)) 
[17:36:39.965]                               next
[17:36:39.965]                             if (!grepl(pattern, name)) 
[17:36:39.965]                               next
[17:36:39.965]                             invokeRestart(restart)
[17:36:39.965]                             muffled <- TRUE
[17:36:39.965]                             break
[17:36:39.965]                           }
[17:36:39.965]                         }
[17:36:39.965]                       }
[17:36:39.965]                       invisible(muffled)
[17:36:39.965]                     }
[17:36:39.965]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.965]                   }
[17:36:39.965]                 }
[17:36:39.965]                 else {
[17:36:39.965]                   if (TRUE) {
[17:36:39.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:39.965]                     {
[17:36:39.965]                       inherits <- base::inherits
[17:36:39.965]                       invokeRestart <- base::invokeRestart
[17:36:39.965]                       is.null <- base::is.null
[17:36:39.965]                       muffled <- FALSE
[17:36:39.965]                       if (inherits(cond, "message")) {
[17:36:39.965]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:39.965]                         if (muffled) 
[17:36:39.965]                           invokeRestart("muffleMessage")
[17:36:39.965]                       }
[17:36:39.965]                       else if (inherits(cond, "warning")) {
[17:36:39.965]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:39.965]                         if (muffled) 
[17:36:39.965]                           invokeRestart("muffleWarning")
[17:36:39.965]                       }
[17:36:39.965]                       else if (inherits(cond, "condition")) {
[17:36:39.965]                         if (!is.null(pattern)) {
[17:36:39.965]                           computeRestarts <- base::computeRestarts
[17:36:39.965]                           grepl <- base::grepl
[17:36:39.965]                           restarts <- computeRestarts(cond)
[17:36:39.965]                           for (restart in restarts) {
[17:36:39.965]                             name <- restart$name
[17:36:39.965]                             if (is.null(name)) 
[17:36:39.965]                               next
[17:36:39.965]                             if (!grepl(pattern, name)) 
[17:36:39.965]                               next
[17:36:39.965]                             invokeRestart(restart)
[17:36:39.965]                             muffled <- TRUE
[17:36:39.965]                             break
[17:36:39.965]                           }
[17:36:39.965]                         }
[17:36:39.965]                       }
[17:36:39.965]                       invisible(muffled)
[17:36:39.965]                     }
[17:36:39.965]                     muffleCondition(cond, pattern = "^muffle")
[17:36:39.965]                   }
[17:36:39.965]                 }
[17:36:39.965]             }
[17:36:39.965]         }))
[17:36:39.965]     }, error = function(ex) {
[17:36:39.965]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:39.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:39.965]                 ...future.rng), started = ...future.startTime, 
[17:36:39.965]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:39.965]             version = "1.8"), class = "FutureResult")
[17:36:39.965]     }, finally = {
[17:36:39.965]         if (!identical(...future.workdir, getwd())) 
[17:36:39.965]             setwd(...future.workdir)
[17:36:39.965]         {
[17:36:39.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:39.965]                 ...future.oldOptions$nwarnings <- NULL
[17:36:39.965]             }
[17:36:39.965]             base::options(...future.oldOptions)
[17:36:39.965]             if (.Platform$OS.type == "windows") {
[17:36:39.965]                 old_names <- names(...future.oldEnvVars)
[17:36:39.965]                 envs <- base::Sys.getenv()
[17:36:39.965]                 names <- names(envs)
[17:36:39.965]                 common <- intersect(names, old_names)
[17:36:39.965]                 added <- setdiff(names, old_names)
[17:36:39.965]                 removed <- setdiff(old_names, names)
[17:36:39.965]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:39.965]                   envs[common]]
[17:36:39.965]                 NAMES <- toupper(changed)
[17:36:39.965]                 args <- list()
[17:36:39.965]                 for (kk in seq_along(NAMES)) {
[17:36:39.965]                   name <- changed[[kk]]
[17:36:39.965]                   NAME <- NAMES[[kk]]
[17:36:39.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.965]                     next
[17:36:39.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.965]                 }
[17:36:39.965]                 NAMES <- toupper(added)
[17:36:39.965]                 for (kk in seq_along(NAMES)) {
[17:36:39.965]                   name <- added[[kk]]
[17:36:39.965]                   NAME <- NAMES[[kk]]
[17:36:39.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.965]                     next
[17:36:39.965]                   args[[name]] <- ""
[17:36:39.965]                 }
[17:36:39.965]                 NAMES <- toupper(removed)
[17:36:39.965]                 for (kk in seq_along(NAMES)) {
[17:36:39.965]                   name <- removed[[kk]]
[17:36:39.965]                   NAME <- NAMES[[kk]]
[17:36:39.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:39.965]                     next
[17:36:39.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:39.965]                 }
[17:36:39.965]                 if (length(args) > 0) 
[17:36:39.965]                   base::do.call(base::Sys.setenv, args = args)
[17:36:39.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:39.965]             }
[17:36:39.965]             else {
[17:36:39.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:39.965]             }
[17:36:39.965]             {
[17:36:39.965]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:39.965]                   0L) {
[17:36:39.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:39.965]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:39.965]                   base::options(opts)
[17:36:39.965]                 }
[17:36:39.965]                 {
[17:36:39.965]                   {
[17:36:39.965]                     NULL
[17:36:39.965]                     RNGkind("Mersenne-Twister")
[17:36:39.965]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:39.965]                       inherits = FALSE)
[17:36:39.965]                   }
[17:36:39.965]                   options(future.plan = NULL)
[17:36:39.965]                   if (is.na(NA_character_)) 
[17:36:39.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:39.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:39.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:39.965]                     .init = FALSE)
[17:36:39.965]                 }
[17:36:39.965]             }
[17:36:39.965]         }
[17:36:39.965]     })
[17:36:39.965]     if (TRUE) {
[17:36:39.965]         base::sink(type = "output", split = FALSE)
[17:36:39.965]         if (TRUE) {
[17:36:39.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:39.965]         }
[17:36:39.965]         else {
[17:36:39.965]             ...future.result["stdout"] <- base::list(NULL)
[17:36:39.965]         }
[17:36:39.965]         base::close(...future.stdout)
[17:36:39.965]         ...future.stdout <- NULL
[17:36:39.965]     }
[17:36:39.965]     ...future.result$conditions <- ...future.conditions
[17:36:39.965]     ...future.result$finished <- base::Sys.time()
[17:36:39.965]     ...future.result
[17:36:39.965] }
[17:36:39.966] assign_globals() ...
[17:36:39.966] List of 5
[17:36:39.966]  $ ...future.FUN            :function (object, ...)  
[17:36:39.966]  $ future.call.arguments    :List of 1
[17:36:39.966]   ..$ digits: int 2
[17:36:39.966]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.966]  $ ...future.elements_ii    :List of 6
[17:36:39.966]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:36:39.966]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:36:39.966]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:36:39.966]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:36:39.966]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:36:39.966]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:36:39.966]  $ ...future.seeds_ii       : NULL
[17:36:39.966]  $ ...future.globals.maxSize: NULL
[17:36:39.966]  - attr(*, "where")=List of 5
[17:36:39.966]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:39.966]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:39.966]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:39.966]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:39.966]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:39.966]  - attr(*, "resolved")= logi FALSE
[17:36:39.966]  - attr(*, "total_size")= num 1296
[17:36:39.966]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.966]  - attr(*, "already-done")= logi TRUE
[17:36:39.973] - copied ‘...future.FUN’ to environment
[17:36:39.973] - copied ‘future.call.arguments’ to environment
[17:36:39.973] - copied ‘...future.elements_ii’ to environment
[17:36:39.973] - copied ‘...future.seeds_ii’ to environment
[17:36:39.973] - copied ‘...future.globals.maxSize’ to environment
[17:36:39.973] assign_globals() ... done
[17:36:39.974] plan(): Setting new future strategy stack:
[17:36:39.974] List of future strategies:
[17:36:39.974] 1. sequential:
[17:36:39.974]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:39.974]    - tweaked: FALSE
[17:36:39.974]    - call: NULL
[17:36:39.974] plan(): nbrOfWorkers() = 1
[17:36:39.976] plan(): Setting new future strategy stack:
[17:36:39.976] List of future strategies:
[17:36:39.976] 1. multisession:
[17:36:39.976]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:39.976]    - tweaked: FALSE
[17:36:39.976]    - call: plan(strategy)
[17:36:39.979] plan(): nbrOfWorkers() = 1
[17:36:39.979] SequentialFuture started (and completed)
[17:36:39.979] - Launch lazy future ... done
[17:36:39.979] run() for ‘SequentialFuture’ ... done
[17:36:39.980] Created future:
[17:36:39.980] SequentialFuture:
[17:36:39.980] Label: ‘future_by-1’
[17:36:39.980] Expression:
[17:36:39.980] {
[17:36:39.980]     do.call(function(...) {
[17:36:39.980]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:39.980]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:39.980]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:39.980]             on.exit(options(oopts), add = TRUE)
[17:36:39.980]         }
[17:36:39.980]         {
[17:36:39.980]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:39.980]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:39.980]                 ...future.FUN(...future.X_jj, ...)
[17:36:39.980]             })
[17:36:39.980]         }
[17:36:39.980]     }, args = future.call.arguments)
[17:36:39.980] }
[17:36:39.980] Lazy evaluation: FALSE
[17:36:39.980] Asynchronous evaluation: FALSE
[17:36:39.980] Local evaluation: TRUE
[17:36:39.980] Environment: R_GlobalEnv
[17:36:39.980] Capture standard output: TRUE
[17:36:39.980] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:39.980] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:39.980] Packages: <none>
[17:36:39.980] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:39.980] Resolved: TRUE
[17:36:39.980] Value: 5.48 KiB of class ‘list’
[17:36:39.980] Early signaling: FALSE
[17:36:39.980] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:39.980] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:39.981] Chunk #1 of 1 ... DONE
[17:36:39.981] Launching 1 futures (chunks) ... DONE
[17:36:39.981] Resolving 1 futures (chunks) ...
[17:36:39.981] resolve() on list ...
[17:36:39.981]  recursive: 0
[17:36:39.981]  length: 1
[17:36:39.981] 
[17:36:39.981] resolved() for ‘SequentialFuture’ ...
[17:36:39.982] - state: ‘finished’
[17:36:39.982] - run: TRUE
[17:36:39.982] - result: ‘FutureResult’
[17:36:39.982] resolved() for ‘SequentialFuture’ ... done
[17:36:39.982] Future #1
[17:36:39.982] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:39.982] - nx: 1
[17:36:39.982] - relay: TRUE
[17:36:39.982] - stdout: TRUE
[17:36:39.982] - signal: TRUE
[17:36:39.983] - resignal: FALSE
[17:36:39.983] - force: TRUE
[17:36:39.983] - relayed: [n=1] FALSE
[17:36:39.983] - queued futures: [n=1] FALSE
[17:36:39.983]  - until=1
[17:36:39.983]  - relaying element #1
[17:36:39.983] - relayed: [n=1] TRUE
[17:36:39.983] - queued futures: [n=1] TRUE
[17:36:39.983] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:39.983]  length: 0 (resolved future 1)
[17:36:39.984] Relaying remaining futures
[17:36:39.984] signalConditionsASAP(NULL, pos=0) ...
[17:36:39.984] - nx: 1
[17:36:39.984] - relay: TRUE
[17:36:39.984] - stdout: TRUE
[17:36:39.984] - signal: TRUE
[17:36:39.984] - resignal: FALSE
[17:36:39.984] - force: TRUE
[17:36:39.984] - relayed: [n=1] TRUE
[17:36:39.984] - queued futures: [n=1] TRUE
 - flush all
[17:36:39.984] - relayed: [n=1] TRUE
[17:36:39.985] - queued futures: [n=1] TRUE
[17:36:39.985] signalConditionsASAP(NULL, pos=0) ... done
[17:36:39.985] resolve() on list ... DONE
[17:36:39.985]  - Number of value chunks collected: 1
[17:36:39.985] Resolving 1 futures (chunks) ... DONE
[17:36:39.985] Reducing values from 1 chunks ...
[17:36:39.985]  - Number of values collected after concatenation: 6
[17:36:39.985]  - Number of values expected: 6
[17:36:39.985] Reducing values from 1 chunks ... DONE
[17:36:39.985] future_lapply() ... DONE
[17:36:39.986] future_by_internal() ... DONE
[17:36:39.988] future_by_internal() ...
[17:36:39.989] future_lapply() ...
[17:36:39.993] Number of chunks: 1
[17:36:39.993] getGlobalsAndPackagesXApply() ...
[17:36:39.993]  - future.globals: TRUE
[17:36:39.993] getGlobalsAndPackages() ...
[17:36:39.993] Searching for globals...
[17:36:39.995] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:39.995] Searching for globals ... DONE
[17:36:39.995] Resolving globals: FALSE
[17:36:39.996] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:36:39.996] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:36:39.996] - globals: [1] ‘FUN’
[17:36:39.996] - packages: [1] ‘stats’
[17:36:39.996] getGlobalsAndPackages() ... DONE
[17:36:39.996]  - globals found/used: [n=1] ‘FUN’
[17:36:39.997]  - needed namespaces: [n=1] ‘stats’
[17:36:39.997] Finding globals ... DONE
[17:36:39.997]  - use_args: TRUE
[17:36:39.997]  - Getting '...' globals ...
[17:36:39.997] resolve() on list ...
[17:36:39.997]  recursive: 0
[17:36:39.997]  length: 1
[17:36:39.997]  elements: ‘...’
[17:36:39.998]  length: 0 (resolved future 1)
[17:36:39.998] resolve() on list ... DONE
[17:36:39.998]    - '...' content: [n=1] ‘singular.ok’
[17:36:39.998] List of 1
[17:36:39.998]  $ ...:List of 1
[17:36:39.998]   ..$ singular.ok: logi FALSE
[17:36:39.998]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:39.998]  - attr(*, "where")=List of 1
[17:36:39.998]   ..$ ...:<environment: 0x5622fc69d848> 
[17:36:39.998]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:39.998]  - attr(*, "resolved")= logi TRUE
[17:36:39.998]  - attr(*, "total_size")= num NA
[17:36:40.001]  - Getting '...' globals ... DONE
[17:36:40.001] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:40.001] List of 2
[17:36:40.001]  $ ...future.FUN:function (x, ...)  
[17:36:40.001]  $ ...          :List of 1
[17:36:40.001]   ..$ singular.ok: logi FALSE
[17:36:40.001]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.001]  - attr(*, "where")=List of 2
[17:36:40.001]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.001]   ..$ ...          :<environment: 0x5622fc69d848> 
[17:36:40.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.001]  - attr(*, "resolved")= logi FALSE
[17:36:40.001]  - attr(*, "total_size")= num 5384
[17:36:40.004] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:40.004] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.004] Number of futures (= number of chunks): 1
[17:36:40.005] Launching 1 futures (chunks) ...
[17:36:40.005] Chunk #1 of 1 ...
[17:36:40.005]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.005] getGlobalsAndPackages() ...
[17:36:40.005] Searching for globals...
[17:36:40.005] 
[17:36:40.006] Searching for globals ... DONE
[17:36:40.006] - globals: [0] <none>
[17:36:40.006] getGlobalsAndPackages() ... DONE
[17:36:40.006]    + additional globals found: [n=0] 
[17:36:40.006]    + additional namespaces needed: [n=0] 
[17:36:40.006]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.006]  - seeds: <none>
[17:36:40.006]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.006] getGlobalsAndPackages() ...
[17:36:40.006] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.007] Resolving globals: FALSE
[17:36:40.007] Tweak future expression to call with '...' arguments ...
[17:36:40.007] {
[17:36:40.007]     do.call(function(...) {
[17:36:40.007]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.007]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.007]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.007]             on.exit(options(oopts), add = TRUE)
[17:36:40.007]         }
[17:36:40.007]         {
[17:36:40.007]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.007]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.007]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.007]             })
[17:36:40.007]         }
[17:36:40.007]     }, args = future.call.arguments)
[17:36:40.007] }
[17:36:40.007] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.007] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.008] 
[17:36:40.008] getGlobalsAndPackages() ... DONE
[17:36:40.008] run() for ‘Future’ ...
[17:36:40.008] - state: ‘created’
[17:36:40.008] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.012] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.012] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:40.012]   - Field: ‘label’
[17:36:40.012]   - Field: ‘local’
[17:36:40.012]   - Field: ‘owner’
[17:36:40.012]   - Field: ‘envir’
[17:36:40.012]   - Field: ‘packages’
[17:36:40.013]   - Field: ‘gc’
[17:36:40.013]   - Field: ‘conditions’
[17:36:40.013]   - Field: ‘expr’
[17:36:40.013]   - Field: ‘uuid’
[17:36:40.013]   - Field: ‘seed’
[17:36:40.013]   - Field: ‘version’
[17:36:40.013]   - Field: ‘result’
[17:36:40.013]   - Field: ‘asynchronous’
[17:36:40.013]   - Field: ‘calls’
[17:36:40.013]   - Field: ‘globals’
[17:36:40.013]   - Field: ‘stdout’
[17:36:40.014]   - Field: ‘earlySignal’
[17:36:40.014]   - Field: ‘lazy’
[17:36:40.014]   - Field: ‘state’
[17:36:40.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:40.016] - Launch lazy future ...
[17:36:40.016] Packages needed by the future expression (n = 1): ‘stats’
[17:36:40.016] Packages needed by future strategies (n = 0): <none>
[17:36:40.017] {
[17:36:40.017]     {
[17:36:40.017]         {
[17:36:40.017]             ...future.startTime <- base::Sys.time()
[17:36:40.017]             {
[17:36:40.017]                 {
[17:36:40.017]                   {
[17:36:40.017]                     {
[17:36:40.017]                       base::local({
[17:36:40.017]                         has_future <- base::requireNamespace("future", 
[17:36:40.017]                           quietly = TRUE)
[17:36:40.017]                         if (has_future) {
[17:36:40.017]                           ns <- base::getNamespace("future")
[17:36:40.017]                           version <- ns[[".package"]][["version"]]
[17:36:40.017]                           if (is.null(version)) 
[17:36:40.017]                             version <- utils::packageVersion("future")
[17:36:40.017]                         }
[17:36:40.017]                         else {
[17:36:40.017]                           version <- NULL
[17:36:40.017]                         }
[17:36:40.017]                         if (!has_future || version < "1.8.0") {
[17:36:40.017]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.017]                             "", base::R.version$version.string), 
[17:36:40.017]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:40.017]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.017]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.017]                               "release", "version")], collapse = " "), 
[17:36:40.017]                             hostname = base::Sys.info()[["nodename"]])
[17:36:40.017]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.017]                             info)
[17:36:40.017]                           info <- base::paste(info, collapse = "; ")
[17:36:40.017]                           if (!has_future) {
[17:36:40.017]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.017]                               info)
[17:36:40.017]                           }
[17:36:40.017]                           else {
[17:36:40.017]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.017]                               info, version)
[17:36:40.017]                           }
[17:36:40.017]                           base::stop(msg)
[17:36:40.017]                         }
[17:36:40.017]                       })
[17:36:40.017]                     }
[17:36:40.017]                     base::local({
[17:36:40.017]                       for (pkg in "stats") {
[17:36:40.017]                         base::loadNamespace(pkg)
[17:36:40.017]                         base::library(pkg, character.only = TRUE)
[17:36:40.017]                       }
[17:36:40.017]                     })
[17:36:40.017]                   }
[17:36:40.017]                   ...future.strategy.old <- future::plan("list")
[17:36:40.017]                   options(future.plan = NULL)
[17:36:40.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.017]                 }
[17:36:40.017]                 ...future.workdir <- getwd()
[17:36:40.017]             }
[17:36:40.017]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.017]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.017]         }
[17:36:40.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:40.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.017]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.017]             base::names(...future.oldOptions))
[17:36:40.017]     }
[17:36:40.017]     if (FALSE) {
[17:36:40.017]     }
[17:36:40.017]     else {
[17:36:40.017]         if (TRUE) {
[17:36:40.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.017]                 open = "w")
[17:36:40.017]         }
[17:36:40.017]         else {
[17:36:40.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.017]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.017]         }
[17:36:40.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.017]             base::sink(type = "output", split = FALSE)
[17:36:40.017]             base::close(...future.stdout)
[17:36:40.017]         }, add = TRUE)
[17:36:40.017]     }
[17:36:40.017]     ...future.frame <- base::sys.nframe()
[17:36:40.017]     ...future.conditions <- base::list()
[17:36:40.017]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.017]     if (FALSE) {
[17:36:40.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.017]     }
[17:36:40.017]     ...future.result <- base::tryCatch({
[17:36:40.017]         base::withCallingHandlers({
[17:36:40.017]             ...future.value <- base::withVisible(base::local({
[17:36:40.017]                 do.call(function(...) {
[17:36:40.017]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.017]                   if (!identical(...future.globals.maxSize.org, 
[17:36:40.017]                     ...future.globals.maxSize)) {
[17:36:40.017]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.017]                     on.exit(options(oopts), add = TRUE)
[17:36:40.017]                   }
[17:36:40.017]                   {
[17:36:40.017]                     lapply(seq_along(...future.elements_ii), 
[17:36:40.017]                       FUN = function(jj) {
[17:36:40.017]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.017]                         ...future.FUN(...future.X_jj, ...)
[17:36:40.017]                       })
[17:36:40.017]                   }
[17:36:40.017]                 }, args = future.call.arguments)
[17:36:40.017]             }))
[17:36:40.017]             future::FutureResult(value = ...future.value$value, 
[17:36:40.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.017]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.017]                     ...future.globalenv.names))
[17:36:40.017]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.017]         }, condition = base::local({
[17:36:40.017]             c <- base::c
[17:36:40.017]             inherits <- base::inherits
[17:36:40.017]             invokeRestart <- base::invokeRestart
[17:36:40.017]             length <- base::length
[17:36:40.017]             list <- base::list
[17:36:40.017]             seq.int <- base::seq.int
[17:36:40.017]             signalCondition <- base::signalCondition
[17:36:40.017]             sys.calls <- base::sys.calls
[17:36:40.017]             `[[` <- base::`[[`
[17:36:40.017]             `+` <- base::`+`
[17:36:40.017]             `<<-` <- base::`<<-`
[17:36:40.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.017]                   3L)]
[17:36:40.017]             }
[17:36:40.017]             function(cond) {
[17:36:40.017]                 is_error <- inherits(cond, "error")
[17:36:40.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.017]                   NULL)
[17:36:40.017]                 if (is_error) {
[17:36:40.017]                   sessionInformation <- function() {
[17:36:40.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.017]                       search = base::search(), system = base::Sys.info())
[17:36:40.017]                   }
[17:36:40.017]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.017]                     cond$call), session = sessionInformation(), 
[17:36:40.017]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.017]                   signalCondition(cond)
[17:36:40.017]                 }
[17:36:40.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.017]                 "immediateCondition"))) {
[17:36:40.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.017]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.017]                   if (TRUE && !signal) {
[17:36:40.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.017]                     {
[17:36:40.017]                       inherits <- base::inherits
[17:36:40.017]                       invokeRestart <- base::invokeRestart
[17:36:40.017]                       is.null <- base::is.null
[17:36:40.017]                       muffled <- FALSE
[17:36:40.017]                       if (inherits(cond, "message")) {
[17:36:40.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.017]                         if (muffled) 
[17:36:40.017]                           invokeRestart("muffleMessage")
[17:36:40.017]                       }
[17:36:40.017]                       else if (inherits(cond, "warning")) {
[17:36:40.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.017]                         if (muffled) 
[17:36:40.017]                           invokeRestart("muffleWarning")
[17:36:40.017]                       }
[17:36:40.017]                       else if (inherits(cond, "condition")) {
[17:36:40.017]                         if (!is.null(pattern)) {
[17:36:40.017]                           computeRestarts <- base::computeRestarts
[17:36:40.017]                           grepl <- base::grepl
[17:36:40.017]                           restarts <- computeRestarts(cond)
[17:36:40.017]                           for (restart in restarts) {
[17:36:40.017]                             name <- restart$name
[17:36:40.017]                             if (is.null(name)) 
[17:36:40.017]                               next
[17:36:40.017]                             if (!grepl(pattern, name)) 
[17:36:40.017]                               next
[17:36:40.017]                             invokeRestart(restart)
[17:36:40.017]                             muffled <- TRUE
[17:36:40.017]                             break
[17:36:40.017]                           }
[17:36:40.017]                         }
[17:36:40.017]                       }
[17:36:40.017]                       invisible(muffled)
[17:36:40.017]                     }
[17:36:40.017]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.017]                   }
[17:36:40.017]                 }
[17:36:40.017]                 else {
[17:36:40.017]                   if (TRUE) {
[17:36:40.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.017]                     {
[17:36:40.017]                       inherits <- base::inherits
[17:36:40.017]                       invokeRestart <- base::invokeRestart
[17:36:40.017]                       is.null <- base::is.null
[17:36:40.017]                       muffled <- FALSE
[17:36:40.017]                       if (inherits(cond, "message")) {
[17:36:40.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.017]                         if (muffled) 
[17:36:40.017]                           invokeRestart("muffleMessage")
[17:36:40.017]                       }
[17:36:40.017]                       else if (inherits(cond, "warning")) {
[17:36:40.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.017]                         if (muffled) 
[17:36:40.017]                           invokeRestart("muffleWarning")
[17:36:40.017]                       }
[17:36:40.017]                       else if (inherits(cond, "condition")) {
[17:36:40.017]                         if (!is.null(pattern)) {
[17:36:40.017]                           computeRestarts <- base::computeRestarts
[17:36:40.017]                           grepl <- base::grepl
[17:36:40.017]                           restarts <- computeRestarts(cond)
[17:36:40.017]                           for (restart in restarts) {
[17:36:40.017]                             name <- restart$name
[17:36:40.017]                             if (is.null(name)) 
[17:36:40.017]                               next
[17:36:40.017]                             if (!grepl(pattern, name)) 
[17:36:40.017]                               next
[17:36:40.017]                             invokeRestart(restart)
[17:36:40.017]                             muffled <- TRUE
[17:36:40.017]                             break
[17:36:40.017]                           }
[17:36:40.017]                         }
[17:36:40.017]                       }
[17:36:40.017]                       invisible(muffled)
[17:36:40.017]                     }
[17:36:40.017]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.017]                   }
[17:36:40.017]                 }
[17:36:40.017]             }
[17:36:40.017]         }))
[17:36:40.017]     }, error = function(ex) {
[17:36:40.017]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.017]                 ...future.rng), started = ...future.startTime, 
[17:36:40.017]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.017]             version = "1.8"), class = "FutureResult")
[17:36:40.017]     }, finally = {
[17:36:40.017]         if (!identical(...future.workdir, getwd())) 
[17:36:40.017]             setwd(...future.workdir)
[17:36:40.017]         {
[17:36:40.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.017]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.017]             }
[17:36:40.017]             base::options(...future.oldOptions)
[17:36:40.017]             if (.Platform$OS.type == "windows") {
[17:36:40.017]                 old_names <- names(...future.oldEnvVars)
[17:36:40.017]                 envs <- base::Sys.getenv()
[17:36:40.017]                 names <- names(envs)
[17:36:40.017]                 common <- intersect(names, old_names)
[17:36:40.017]                 added <- setdiff(names, old_names)
[17:36:40.017]                 removed <- setdiff(old_names, names)
[17:36:40.017]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.017]                   envs[common]]
[17:36:40.017]                 NAMES <- toupper(changed)
[17:36:40.017]                 args <- list()
[17:36:40.017]                 for (kk in seq_along(NAMES)) {
[17:36:40.017]                   name <- changed[[kk]]
[17:36:40.017]                   NAME <- NAMES[[kk]]
[17:36:40.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.017]                     next
[17:36:40.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.017]                 }
[17:36:40.017]                 NAMES <- toupper(added)
[17:36:40.017]                 for (kk in seq_along(NAMES)) {
[17:36:40.017]                   name <- added[[kk]]
[17:36:40.017]                   NAME <- NAMES[[kk]]
[17:36:40.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.017]                     next
[17:36:40.017]                   args[[name]] <- ""
[17:36:40.017]                 }
[17:36:40.017]                 NAMES <- toupper(removed)
[17:36:40.017]                 for (kk in seq_along(NAMES)) {
[17:36:40.017]                   name <- removed[[kk]]
[17:36:40.017]                   NAME <- NAMES[[kk]]
[17:36:40.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.017]                     next
[17:36:40.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.017]                 }
[17:36:40.017]                 if (length(args) > 0) 
[17:36:40.017]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.017]             }
[17:36:40.017]             else {
[17:36:40.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.017]             }
[17:36:40.017]             {
[17:36:40.017]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.017]                   0L) {
[17:36:40.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.017]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.017]                   base::options(opts)
[17:36:40.017]                 }
[17:36:40.017]                 {
[17:36:40.017]                   {
[17:36:40.017]                     NULL
[17:36:40.017]                     RNGkind("Mersenne-Twister")
[17:36:40.017]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:40.017]                       inherits = FALSE)
[17:36:40.017]                   }
[17:36:40.017]                   options(future.plan = NULL)
[17:36:40.017]                   if (is.na(NA_character_)) 
[17:36:40.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.017]                     .init = FALSE)
[17:36:40.017]                 }
[17:36:40.017]             }
[17:36:40.017]         }
[17:36:40.017]     })
[17:36:40.017]     if (TRUE) {
[17:36:40.017]         base::sink(type = "output", split = FALSE)
[17:36:40.017]         if (TRUE) {
[17:36:40.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.017]         }
[17:36:40.017]         else {
[17:36:40.017]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.017]         }
[17:36:40.017]         base::close(...future.stdout)
[17:36:40.017]         ...future.stdout <- NULL
[17:36:40.017]     }
[17:36:40.017]     ...future.result$conditions <- ...future.conditions
[17:36:40.017]     ...future.result$finished <- base::Sys.time()
[17:36:40.017]     ...future.result
[17:36:40.017] }
[17:36:40.019] assign_globals() ...
[17:36:40.019] List of 5
[17:36:40.019]  $ ...future.FUN            :function (x, ...)  
[17:36:40.019]  $ future.call.arguments    :List of 1
[17:36:40.019]   ..$ singular.ok: logi FALSE
[17:36:40.019]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.019]  $ ...future.elements_ii    :List of 3
[17:36:40.019]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.019]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.019]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.019]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.019]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.019]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.019]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.019]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:40.019]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.019]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.019]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.019]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:40.019]  $ ...future.seeds_ii       : NULL
[17:36:40.019]  $ ...future.globals.maxSize: NULL
[17:36:40.019]  - attr(*, "where")=List of 5
[17:36:40.019]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.019]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.019]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.019]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.019]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.019]  - attr(*, "resolved")= logi FALSE
[17:36:40.019]  - attr(*, "total_size")= num 5384
[17:36:40.019]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.019]  - attr(*, "already-done")= logi TRUE
[17:36:40.028] - reassign environment for ‘...future.FUN’
[17:36:40.028] - copied ‘...future.FUN’ to environment
[17:36:40.028] - copied ‘future.call.arguments’ to environment
[17:36:40.028] - copied ‘...future.elements_ii’ to environment
[17:36:40.028] - copied ‘...future.seeds_ii’ to environment
[17:36:40.028] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.028] assign_globals() ... done
[17:36:40.029] plan(): Setting new future strategy stack:
[17:36:40.029] List of future strategies:
[17:36:40.029] 1. sequential:
[17:36:40.029]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.029]    - tweaked: FALSE
[17:36:40.029]    - call: NULL
[17:36:40.029] plan(): nbrOfWorkers() = 1
[17:36:40.032] plan(): Setting new future strategy stack:
[17:36:40.032] List of future strategies:
[17:36:40.032] 1. multisession:
[17:36:40.032]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:40.032]    - tweaked: FALSE
[17:36:40.032]    - call: plan(strategy)
[17:36:40.035] plan(): nbrOfWorkers() = 1
[17:36:40.036] SequentialFuture started (and completed)
[17:36:40.036] - Launch lazy future ... done
[17:36:40.036] run() for ‘SequentialFuture’ ... done
[17:36:40.036] Created future:
[17:36:40.036] SequentialFuture:
[17:36:40.036] Label: ‘future_by-1’
[17:36:40.036] Expression:
[17:36:40.036] {
[17:36:40.036]     do.call(function(...) {
[17:36:40.036]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.036]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.036]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.036]             on.exit(options(oopts), add = TRUE)
[17:36:40.036]         }
[17:36:40.036]         {
[17:36:40.036]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.036]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.036]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.036]             })
[17:36:40.036]         }
[17:36:40.036]     }, args = future.call.arguments)
[17:36:40.036] }
[17:36:40.036] Lazy evaluation: FALSE
[17:36:40.036] Asynchronous evaluation: FALSE
[17:36:40.036] Local evaluation: TRUE
[17:36:40.036] Environment: R_GlobalEnv
[17:36:40.036] Capture standard output: TRUE
[17:36:40.036] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.036] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.036] Packages: 1 packages (‘stats’)
[17:36:40.036] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.036] Resolved: TRUE
[17:36:40.036] Value: 26.06 KiB of class ‘list’
[17:36:40.036] Early signaling: FALSE
[17:36:40.036] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.036] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.038] Chunk #1 of 1 ... DONE
[17:36:40.038] Launching 1 futures (chunks) ... DONE
[17:36:40.038] Resolving 1 futures (chunks) ...
[17:36:40.038] resolve() on list ...
[17:36:40.038]  recursive: 0
[17:36:40.038]  length: 1
[17:36:40.038] 
[17:36:40.038] resolved() for ‘SequentialFuture’ ...
[17:36:40.038] - state: ‘finished’
[17:36:40.039] - run: TRUE
[17:36:40.039] - result: ‘FutureResult’
[17:36:40.039] resolved() for ‘SequentialFuture’ ... done
[17:36:40.039] Future #1
[17:36:40.039] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:40.039] - nx: 1
[17:36:40.039] - relay: TRUE
[17:36:40.039] - stdout: TRUE
[17:36:40.039] - signal: TRUE
[17:36:40.039] - resignal: FALSE
[17:36:40.040] - force: TRUE
[17:36:40.040] - relayed: [n=1] FALSE
[17:36:40.040] - queued futures: [n=1] FALSE
[17:36:40.040]  - until=1
[17:36:40.040]  - relaying element #1
[17:36:40.040] - relayed: [n=1] TRUE
[17:36:40.040] - queued futures: [n=1] TRUE
[17:36:40.040] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:40.040]  length: 0 (resolved future 1)
[17:36:40.042] Relaying remaining futures
[17:36:40.042] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.042] - nx: 1
[17:36:40.042] - relay: TRUE
[17:36:40.042] - stdout: TRUE
[17:36:40.043] - signal: TRUE
[17:36:40.043] - resignal: FALSE
[17:36:40.043] - force: TRUE
[17:36:40.043] - relayed: [n=1] TRUE
[17:36:40.043] - queued futures: [n=1] TRUE
 - flush all
[17:36:40.043] - relayed: [n=1] TRUE
[17:36:40.043] - queued futures: [n=1] TRUE
[17:36:40.043] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.043] resolve() on list ... DONE
[17:36:40.044]  - Number of value chunks collected: 1
[17:36:40.044] Resolving 1 futures (chunks) ... DONE
[17:36:40.044] Reducing values from 1 chunks ...
[17:36:40.044]  - Number of values collected after concatenation: 3
[17:36:40.044]  - Number of values expected: 3
[17:36:40.044] Reducing values from 1 chunks ... DONE
[17:36:40.044] future_lapply() ... DONE
[17:36:40.044] future_by_internal() ... DONE
[17:36:40.048] future_by_internal() ...
[17:36:40.049] future_lapply() ...
[17:36:40.053] Number of chunks: 1
[17:36:40.053] getGlobalsAndPackagesXApply() ...
[17:36:40.053]  - future.globals: TRUE
[17:36:40.053] getGlobalsAndPackages() ...
[17:36:40.053] Searching for globals...
[17:36:40.055] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:40.055] Searching for globals ... DONE
[17:36:40.055] Resolving globals: FALSE
[17:36:40.055] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:36:40.056] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:36:40.056] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:40.056] - packages: [1] ‘stats’
[17:36:40.056] getGlobalsAndPackages() ... DONE
[17:36:40.056]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:40.056]  - needed namespaces: [n=1] ‘stats’
[17:36:40.056] Finding globals ... DONE
[17:36:40.057]  - use_args: TRUE
[17:36:40.057]  - Getting '...' globals ...
[17:36:40.057] resolve() on list ...
[17:36:40.057]  recursive: 0
[17:36:40.057]  length: 1
[17:36:40.057]  elements: ‘...’
[17:36:40.057]  length: 0 (resolved future 1)
[17:36:40.057] resolve() on list ... DONE
[17:36:40.058]    - '...' content: [n=0] 
[17:36:40.058] List of 1
[17:36:40.058]  $ ...: list()
[17:36:40.058]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.058]  - attr(*, "where")=List of 1
[17:36:40.058]   ..$ ...:<environment: 0x5622fb8c8b38> 
[17:36:40.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.058]  - attr(*, "resolved")= logi TRUE
[17:36:40.058]  - attr(*, "total_size")= num NA
[17:36:40.060]  - Getting '...' globals ... DONE
[17:36:40.060] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:36:40.060] List of 4
[17:36:40.060]  $ ...future.FUN:function (x)  
[17:36:40.060]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:40.060]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.060]  $ ...          : list()
[17:36:40.060]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.060]  - attr(*, "where")=List of 4
[17:36:40.060]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.060]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:36:40.060]   ..$ wool         :<environment: R_EmptyEnv> 
[17:36:40.060]   ..$ ...          :<environment: 0x5622fb8c8b38> 
[17:36:40.060]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.060]  - attr(*, "resolved")= logi FALSE
[17:36:40.060]  - attr(*, "total_size")= num 2320
[17:36:40.066] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:40.066] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.066] Number of futures (= number of chunks): 1
[17:36:40.067] Launching 1 futures (chunks) ...
[17:36:40.067] Chunk #1 of 1 ...
[17:36:40.067]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.067] getGlobalsAndPackages() ...
[17:36:40.067] Searching for globals...
[17:36:40.067] 
[17:36:40.068] Searching for globals ... DONE
[17:36:40.068] - globals: [0] <none>
[17:36:40.068] getGlobalsAndPackages() ... DONE
[17:36:40.068]    + additional globals found: [n=0] 
[17:36:40.068]    + additional namespaces needed: [n=0] 
[17:36:40.068]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.068]  - seeds: <none>
[17:36:40.068]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.068] getGlobalsAndPackages() ...
[17:36:40.068] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.069] Resolving globals: FALSE
[17:36:40.069] Tweak future expression to call with '...' arguments ...
[17:36:40.069] {
[17:36:40.069]     do.call(function(...) {
[17:36:40.069]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.069]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.069]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.069]             on.exit(options(oopts), add = TRUE)
[17:36:40.069]         }
[17:36:40.069]         {
[17:36:40.069]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.069]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.069]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.069]             })
[17:36:40.069]         }
[17:36:40.069]     }, args = future.call.arguments)
[17:36:40.069] }
[17:36:40.069] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.069] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.070] 
[17:36:40.070] getGlobalsAndPackages() ... DONE
[17:36:40.070] run() for ‘Future’ ...
[17:36:40.070] - state: ‘created’
[17:36:40.070] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.074] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:40.074]   - Field: ‘label’
[17:36:40.074]   - Field: ‘local’
[17:36:40.074]   - Field: ‘owner’
[17:36:40.074]   - Field: ‘envir’
[17:36:40.074]   - Field: ‘packages’
[17:36:40.074]   - Field: ‘gc’
[17:36:40.074]   - Field: ‘conditions’
[17:36:40.075]   - Field: ‘expr’
[17:36:40.075]   - Field: ‘uuid’
[17:36:40.075]   - Field: ‘seed’
[17:36:40.075]   - Field: ‘version’
[17:36:40.075]   - Field: ‘result’
[17:36:40.075]   - Field: ‘asynchronous’
[17:36:40.075]   - Field: ‘calls’
[17:36:40.075]   - Field: ‘globals’
[17:36:40.075]   - Field: ‘stdout’
[17:36:40.075]   - Field: ‘earlySignal’
[17:36:40.075]   - Field: ‘lazy’
[17:36:40.076]   - Field: ‘state’
[17:36:40.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:40.076] - Launch lazy future ...
[17:36:40.076] Packages needed by the future expression (n = 1): ‘stats’
[17:36:40.076] Packages needed by future strategies (n = 0): <none>
[17:36:40.077] {
[17:36:40.077]     {
[17:36:40.077]         {
[17:36:40.077]             ...future.startTime <- base::Sys.time()
[17:36:40.077]             {
[17:36:40.077]                 {
[17:36:40.077]                   {
[17:36:40.077]                     {
[17:36:40.077]                       base::local({
[17:36:40.077]                         has_future <- base::requireNamespace("future", 
[17:36:40.077]                           quietly = TRUE)
[17:36:40.077]                         if (has_future) {
[17:36:40.077]                           ns <- base::getNamespace("future")
[17:36:40.077]                           version <- ns[[".package"]][["version"]]
[17:36:40.077]                           if (is.null(version)) 
[17:36:40.077]                             version <- utils::packageVersion("future")
[17:36:40.077]                         }
[17:36:40.077]                         else {
[17:36:40.077]                           version <- NULL
[17:36:40.077]                         }
[17:36:40.077]                         if (!has_future || version < "1.8.0") {
[17:36:40.077]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.077]                             "", base::R.version$version.string), 
[17:36:40.077]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:40.077]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.077]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.077]                               "release", "version")], collapse = " "), 
[17:36:40.077]                             hostname = base::Sys.info()[["nodename"]])
[17:36:40.077]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.077]                             info)
[17:36:40.077]                           info <- base::paste(info, collapse = "; ")
[17:36:40.077]                           if (!has_future) {
[17:36:40.077]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.077]                               info)
[17:36:40.077]                           }
[17:36:40.077]                           else {
[17:36:40.077]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.077]                               info, version)
[17:36:40.077]                           }
[17:36:40.077]                           base::stop(msg)
[17:36:40.077]                         }
[17:36:40.077]                       })
[17:36:40.077]                     }
[17:36:40.077]                     base::local({
[17:36:40.077]                       for (pkg in "stats") {
[17:36:40.077]                         base::loadNamespace(pkg)
[17:36:40.077]                         base::library(pkg, character.only = TRUE)
[17:36:40.077]                       }
[17:36:40.077]                     })
[17:36:40.077]                   }
[17:36:40.077]                   ...future.strategy.old <- future::plan("list")
[17:36:40.077]                   options(future.plan = NULL)
[17:36:40.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.077]                 }
[17:36:40.077]                 ...future.workdir <- getwd()
[17:36:40.077]             }
[17:36:40.077]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.077]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.077]         }
[17:36:40.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.077]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:40.077]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.077]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.077]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.077]             base::names(...future.oldOptions))
[17:36:40.077]     }
[17:36:40.077]     if (FALSE) {
[17:36:40.077]     }
[17:36:40.077]     else {
[17:36:40.077]         if (TRUE) {
[17:36:40.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.077]                 open = "w")
[17:36:40.077]         }
[17:36:40.077]         else {
[17:36:40.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.077]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.077]         }
[17:36:40.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.077]             base::sink(type = "output", split = FALSE)
[17:36:40.077]             base::close(...future.stdout)
[17:36:40.077]         }, add = TRUE)
[17:36:40.077]     }
[17:36:40.077]     ...future.frame <- base::sys.nframe()
[17:36:40.077]     ...future.conditions <- base::list()
[17:36:40.077]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.077]     if (FALSE) {
[17:36:40.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.077]     }
[17:36:40.077]     ...future.result <- base::tryCatch({
[17:36:40.077]         base::withCallingHandlers({
[17:36:40.077]             ...future.value <- base::withVisible(base::local({
[17:36:40.077]                 do.call(function(...) {
[17:36:40.077]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.077]                   if (!identical(...future.globals.maxSize.org, 
[17:36:40.077]                     ...future.globals.maxSize)) {
[17:36:40.077]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.077]                     on.exit(options(oopts), add = TRUE)
[17:36:40.077]                   }
[17:36:40.077]                   {
[17:36:40.077]                     lapply(seq_along(...future.elements_ii), 
[17:36:40.077]                       FUN = function(jj) {
[17:36:40.077]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.077]                         ...future.FUN(...future.X_jj, ...)
[17:36:40.077]                       })
[17:36:40.077]                   }
[17:36:40.077]                 }, args = future.call.arguments)
[17:36:40.077]             }))
[17:36:40.077]             future::FutureResult(value = ...future.value$value, 
[17:36:40.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.077]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.077]                     ...future.globalenv.names))
[17:36:40.077]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.077]         }, condition = base::local({
[17:36:40.077]             c <- base::c
[17:36:40.077]             inherits <- base::inherits
[17:36:40.077]             invokeRestart <- base::invokeRestart
[17:36:40.077]             length <- base::length
[17:36:40.077]             list <- base::list
[17:36:40.077]             seq.int <- base::seq.int
[17:36:40.077]             signalCondition <- base::signalCondition
[17:36:40.077]             sys.calls <- base::sys.calls
[17:36:40.077]             `[[` <- base::`[[`
[17:36:40.077]             `+` <- base::`+`
[17:36:40.077]             `<<-` <- base::`<<-`
[17:36:40.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.077]                   3L)]
[17:36:40.077]             }
[17:36:40.077]             function(cond) {
[17:36:40.077]                 is_error <- inherits(cond, "error")
[17:36:40.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.077]                   NULL)
[17:36:40.077]                 if (is_error) {
[17:36:40.077]                   sessionInformation <- function() {
[17:36:40.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.077]                       search = base::search(), system = base::Sys.info())
[17:36:40.077]                   }
[17:36:40.077]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.077]                     cond$call), session = sessionInformation(), 
[17:36:40.077]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.077]                   signalCondition(cond)
[17:36:40.077]                 }
[17:36:40.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.077]                 "immediateCondition"))) {
[17:36:40.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.077]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.077]                   if (TRUE && !signal) {
[17:36:40.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.077]                     {
[17:36:40.077]                       inherits <- base::inherits
[17:36:40.077]                       invokeRestart <- base::invokeRestart
[17:36:40.077]                       is.null <- base::is.null
[17:36:40.077]                       muffled <- FALSE
[17:36:40.077]                       if (inherits(cond, "message")) {
[17:36:40.077]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.077]                         if (muffled) 
[17:36:40.077]                           invokeRestart("muffleMessage")
[17:36:40.077]                       }
[17:36:40.077]                       else if (inherits(cond, "warning")) {
[17:36:40.077]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.077]                         if (muffled) 
[17:36:40.077]                           invokeRestart("muffleWarning")
[17:36:40.077]                       }
[17:36:40.077]                       else if (inherits(cond, "condition")) {
[17:36:40.077]                         if (!is.null(pattern)) {
[17:36:40.077]                           computeRestarts <- base::computeRestarts
[17:36:40.077]                           grepl <- base::grepl
[17:36:40.077]                           restarts <- computeRestarts(cond)
[17:36:40.077]                           for (restart in restarts) {
[17:36:40.077]                             name <- restart$name
[17:36:40.077]                             if (is.null(name)) 
[17:36:40.077]                               next
[17:36:40.077]                             if (!grepl(pattern, name)) 
[17:36:40.077]                               next
[17:36:40.077]                             invokeRestart(restart)
[17:36:40.077]                             muffled <- TRUE
[17:36:40.077]                             break
[17:36:40.077]                           }
[17:36:40.077]                         }
[17:36:40.077]                       }
[17:36:40.077]                       invisible(muffled)
[17:36:40.077]                     }
[17:36:40.077]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.077]                   }
[17:36:40.077]                 }
[17:36:40.077]                 else {
[17:36:40.077]                   if (TRUE) {
[17:36:40.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.077]                     {
[17:36:40.077]                       inherits <- base::inherits
[17:36:40.077]                       invokeRestart <- base::invokeRestart
[17:36:40.077]                       is.null <- base::is.null
[17:36:40.077]                       muffled <- FALSE
[17:36:40.077]                       if (inherits(cond, "message")) {
[17:36:40.077]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.077]                         if (muffled) 
[17:36:40.077]                           invokeRestart("muffleMessage")
[17:36:40.077]                       }
[17:36:40.077]                       else if (inherits(cond, "warning")) {
[17:36:40.077]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.077]                         if (muffled) 
[17:36:40.077]                           invokeRestart("muffleWarning")
[17:36:40.077]                       }
[17:36:40.077]                       else if (inherits(cond, "condition")) {
[17:36:40.077]                         if (!is.null(pattern)) {
[17:36:40.077]                           computeRestarts <- base::computeRestarts
[17:36:40.077]                           grepl <- base::grepl
[17:36:40.077]                           restarts <- computeRestarts(cond)
[17:36:40.077]                           for (restart in restarts) {
[17:36:40.077]                             name <- restart$name
[17:36:40.077]                             if (is.null(name)) 
[17:36:40.077]                               next
[17:36:40.077]                             if (!grepl(pattern, name)) 
[17:36:40.077]                               next
[17:36:40.077]                             invokeRestart(restart)
[17:36:40.077]                             muffled <- TRUE
[17:36:40.077]                             break
[17:36:40.077]                           }
[17:36:40.077]                         }
[17:36:40.077]                       }
[17:36:40.077]                       invisible(muffled)
[17:36:40.077]                     }
[17:36:40.077]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.077]                   }
[17:36:40.077]                 }
[17:36:40.077]             }
[17:36:40.077]         }))
[17:36:40.077]     }, error = function(ex) {
[17:36:40.077]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.077]                 ...future.rng), started = ...future.startTime, 
[17:36:40.077]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.077]             version = "1.8"), class = "FutureResult")
[17:36:40.077]     }, finally = {
[17:36:40.077]         if (!identical(...future.workdir, getwd())) 
[17:36:40.077]             setwd(...future.workdir)
[17:36:40.077]         {
[17:36:40.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.077]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.077]             }
[17:36:40.077]             base::options(...future.oldOptions)
[17:36:40.077]             if (.Platform$OS.type == "windows") {
[17:36:40.077]                 old_names <- names(...future.oldEnvVars)
[17:36:40.077]                 envs <- base::Sys.getenv()
[17:36:40.077]                 names <- names(envs)
[17:36:40.077]                 common <- intersect(names, old_names)
[17:36:40.077]                 added <- setdiff(names, old_names)
[17:36:40.077]                 removed <- setdiff(old_names, names)
[17:36:40.077]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.077]                   envs[common]]
[17:36:40.077]                 NAMES <- toupper(changed)
[17:36:40.077]                 args <- list()
[17:36:40.077]                 for (kk in seq_along(NAMES)) {
[17:36:40.077]                   name <- changed[[kk]]
[17:36:40.077]                   NAME <- NAMES[[kk]]
[17:36:40.077]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.077]                     next
[17:36:40.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.077]                 }
[17:36:40.077]                 NAMES <- toupper(added)
[17:36:40.077]                 for (kk in seq_along(NAMES)) {
[17:36:40.077]                   name <- added[[kk]]
[17:36:40.077]                   NAME <- NAMES[[kk]]
[17:36:40.077]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.077]                     next
[17:36:40.077]                   args[[name]] <- ""
[17:36:40.077]                 }
[17:36:40.077]                 NAMES <- toupper(removed)
[17:36:40.077]                 for (kk in seq_along(NAMES)) {
[17:36:40.077]                   name <- removed[[kk]]
[17:36:40.077]                   NAME <- NAMES[[kk]]
[17:36:40.077]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.077]                     next
[17:36:40.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.077]                 }
[17:36:40.077]                 if (length(args) > 0) 
[17:36:40.077]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.077]             }
[17:36:40.077]             else {
[17:36:40.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.077]             }
[17:36:40.077]             {
[17:36:40.077]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.077]                   0L) {
[17:36:40.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.077]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.077]                   base::options(opts)
[17:36:40.077]                 }
[17:36:40.077]                 {
[17:36:40.077]                   {
[17:36:40.077]                     NULL
[17:36:40.077]                     RNGkind("Mersenne-Twister")
[17:36:40.077]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:40.077]                       inherits = FALSE)
[17:36:40.077]                   }
[17:36:40.077]                   options(future.plan = NULL)
[17:36:40.077]                   if (is.na(NA_character_)) 
[17:36:40.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.077]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.077]                     .init = FALSE)
[17:36:40.077]                 }
[17:36:40.077]             }
[17:36:40.077]         }
[17:36:40.077]     })
[17:36:40.077]     if (TRUE) {
[17:36:40.077]         base::sink(type = "output", split = FALSE)
[17:36:40.077]         if (TRUE) {
[17:36:40.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.077]         }
[17:36:40.077]         else {
[17:36:40.077]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.077]         }
[17:36:40.077]         base::close(...future.stdout)
[17:36:40.077]         ...future.stdout <- NULL
[17:36:40.077]     }
[17:36:40.077]     ...future.result$conditions <- ...future.conditions
[17:36:40.077]     ...future.result$finished <- base::Sys.time()
[17:36:40.077]     ...future.result
[17:36:40.077] }
[17:36:40.078] assign_globals() ...
[17:36:40.078] List of 7
[17:36:40.078]  $ ...future.FUN            :function (x)  
[17:36:40.078]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:40.078]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.078]  $ future.call.arguments    : list()
[17:36:40.078]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.078]  $ ...future.elements_ii    :List of 3
[17:36:40.078]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.078]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.078]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.078]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.078]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.078]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.078]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.078]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:40.078]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.078]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.078]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.078]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:40.078]  $ ...future.seeds_ii       : NULL
[17:36:40.078]  $ ...future.globals.maxSize: NULL
[17:36:40.078]  - attr(*, "where")=List of 7
[17:36:40.078]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.078]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:36:40.078]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:36:40.078]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.078]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.078]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.078]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.078]  - attr(*, "resolved")= logi FALSE
[17:36:40.078]  - attr(*, "total_size")= num 2320
[17:36:40.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.078]  - attr(*, "already-done")= logi TRUE
[17:36:40.088] - reassign environment for ‘...future.FUN’
[17:36:40.088] - copied ‘...future.FUN’ to environment
[17:36:40.088] - copied ‘breaks’ to environment
[17:36:40.088] - copied ‘wool’ to environment
[17:36:40.090] - copied ‘future.call.arguments’ to environment
[17:36:40.090] - copied ‘...future.elements_ii’ to environment
[17:36:40.090] - copied ‘...future.seeds_ii’ to environment
[17:36:40.090] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.090] assign_globals() ... done
[17:36:40.091] plan(): Setting new future strategy stack:
[17:36:40.091] List of future strategies:
[17:36:40.091] 1. sequential:
[17:36:40.091]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.091]    - tweaked: FALSE
[17:36:40.091]    - call: NULL
[17:36:40.091] plan(): nbrOfWorkers() = 1
[17:36:40.094] plan(): Setting new future strategy stack:
[17:36:40.094] List of future strategies:
[17:36:40.094] 1. multisession:
[17:36:40.094]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:40.094]    - tweaked: FALSE
[17:36:40.094]    - call: plan(strategy)
[17:36:40.098] plan(): nbrOfWorkers() = 1
[17:36:40.098] SequentialFuture started (and completed)
[17:36:40.098] - Launch lazy future ... done
[17:36:40.098] run() for ‘SequentialFuture’ ... done
[17:36:40.098] Created future:
[17:36:40.099] SequentialFuture:
[17:36:40.099] Label: ‘future_by-1’
[17:36:40.099] Expression:
[17:36:40.099] {
[17:36:40.099]     do.call(function(...) {
[17:36:40.099]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.099]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.099]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.099]             on.exit(options(oopts), add = TRUE)
[17:36:40.099]         }
[17:36:40.099]         {
[17:36:40.099]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.099]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.099]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.099]             })
[17:36:40.099]         }
[17:36:40.099]     }, args = future.call.arguments)
[17:36:40.099] }
[17:36:40.099] Lazy evaluation: FALSE
[17:36:40.099] Asynchronous evaluation: FALSE
[17:36:40.099] Local evaluation: TRUE
[17:36:40.099] Environment: 0x5622fa978448
[17:36:40.099] Capture standard output: TRUE
[17:36:40.099] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.099] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:36:40.099] Packages: 1 packages (‘stats’)
[17:36:40.099] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.099] Resolved: TRUE
[17:36:40.099] Value: 25.57 KiB of class ‘list’
[17:36:40.099] Early signaling: FALSE
[17:36:40.099] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.099] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.100] Chunk #1 of 1 ... DONE
[17:36:40.100] Launching 1 futures (chunks) ... DONE
[17:36:40.100] Resolving 1 futures (chunks) ...
[17:36:40.101] resolve() on list ...
[17:36:40.101]  recursive: 0
[17:36:40.101]  length: 1
[17:36:40.101] 
[17:36:40.101] resolved() for ‘SequentialFuture’ ...
[17:36:40.101] - state: ‘finished’
[17:36:40.101] - run: TRUE
[17:36:40.101] - result: ‘FutureResult’
[17:36:40.101] resolved() for ‘SequentialFuture’ ... done
[17:36:40.101] Future #1
[17:36:40.101] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:40.102] - nx: 1
[17:36:40.102] - relay: TRUE
[17:36:40.102] - stdout: TRUE
[17:36:40.102] - signal: TRUE
[17:36:40.102] - resignal: FALSE
[17:36:40.102] - force: TRUE
[17:36:40.102] - relayed: [n=1] FALSE
[17:36:40.102] - queued futures: [n=1] FALSE
[17:36:40.102]  - until=1
[17:36:40.102]  - relaying element #1
[17:36:40.103] - relayed: [n=1] TRUE
[17:36:40.103] - queued futures: [n=1] TRUE
[17:36:40.103] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:40.103]  length: 0 (resolved future 1)
[17:36:40.103] Relaying remaining futures
[17:36:40.103] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.103] - nx: 1
[17:36:40.103] - relay: TRUE
[17:36:40.103] - stdout: TRUE
[17:36:40.103] - signal: TRUE
[17:36:40.103] - resignal: FALSE
[17:36:40.103] - force: TRUE
[17:36:40.104] - relayed: [n=1] TRUE
[17:36:40.104] - queued futures: [n=1] TRUE
 - flush all
[17:36:40.104] - relayed: [n=1] TRUE
[17:36:40.104] - queued futures: [n=1] TRUE
[17:36:40.104] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.104] resolve() on list ... DONE
[17:36:40.104]  - Number of value chunks collected: 1
[17:36:40.104] Resolving 1 futures (chunks) ... DONE
[17:36:40.104] Reducing values from 1 chunks ...
[17:36:40.104]  - Number of values collected after concatenation: 3
[17:36:40.105]  - Number of values expected: 3
[17:36:40.105] Reducing values from 1 chunks ... DONE
[17:36:40.105] future_lapply() ... DONE
[17:36:40.105] future_by_internal() ... DONE
[17:36:40.105] future_by_internal() ...
[17:36:40.106] future_lapply() ...
[17:36:40.109] Number of chunks: 1
[17:36:40.109] getGlobalsAndPackagesXApply() ...
[17:36:40.109]  - future.globals: TRUE
[17:36:40.109] getGlobalsAndPackages() ...
[17:36:40.109] Searching for globals...
[17:36:40.111] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:40.111] Searching for globals ... DONE
[17:36:40.111] Resolving globals: FALSE
[17:36:40.111] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:40.111] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:40.112] - globals: [1] ‘FUN’
[17:36:40.112] 
[17:36:40.112] getGlobalsAndPackages() ... DONE
[17:36:40.112]  - globals found/used: [n=1] ‘FUN’
[17:36:40.112]  - needed namespaces: [n=0] 
[17:36:40.112] Finding globals ... DONE
[17:36:40.112]  - use_args: TRUE
[17:36:40.112]  - Getting '...' globals ...
[17:36:40.113] resolve() on list ...
[17:36:40.113]  recursive: 0
[17:36:40.113]  length: 1
[17:36:40.113]  elements: ‘...’
[17:36:40.113]  length: 0 (resolved future 1)
[17:36:40.113] resolve() on list ... DONE
[17:36:40.113]    - '...' content: [n=0] 
[17:36:40.113] List of 1
[17:36:40.113]  $ ...: list()
[17:36:40.113]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.113]  - attr(*, "where")=List of 1
[17:36:40.113]   ..$ ...:<environment: 0x5622fc0e65a8> 
[17:36:40.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.113]  - attr(*, "resolved")= logi TRUE
[17:36:40.113]  - attr(*, "total_size")= num NA
[17:36:40.117]  - Getting '...' globals ... DONE
[17:36:40.118] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:40.118] List of 2
[17:36:40.118]  $ ...future.FUN:function (object, ...)  
[17:36:40.118]  $ ...          : list()
[17:36:40.118]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.118]  - attr(*, "where")=List of 2
[17:36:40.118]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.118]   ..$ ...          :<environment: 0x5622fc0e65a8> 
[17:36:40.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.118]  - attr(*, "resolved")= logi FALSE
[17:36:40.118]  - attr(*, "total_size")= num 1240
[17:36:40.121] Packages to be attached in all futures: [n=0] 
[17:36:40.121] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.121] Number of futures (= number of chunks): 1
[17:36:40.121] Launching 1 futures (chunks) ...
[17:36:40.121] Chunk #1 of 1 ...
[17:36:40.121]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.121] getGlobalsAndPackages() ...
[17:36:40.121] Searching for globals...
[17:36:40.122] 
[17:36:40.122] Searching for globals ... DONE
[17:36:40.122] - globals: [0] <none>
[17:36:40.122] getGlobalsAndPackages() ... DONE
[17:36:40.122]    + additional globals found: [n=0] 
[17:36:40.122]    + additional namespaces needed: [n=0] 
[17:36:40.122]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.123]  - seeds: <none>
[17:36:40.123]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.123] getGlobalsAndPackages() ...
[17:36:40.123] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.123] Resolving globals: FALSE
[17:36:40.123] Tweak future expression to call with '...' arguments ...
[17:36:40.123] {
[17:36:40.123]     do.call(function(...) {
[17:36:40.123]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.123]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.123]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.123]             on.exit(options(oopts), add = TRUE)
[17:36:40.123]         }
[17:36:40.123]         {
[17:36:40.123]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.123]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.123]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.123]             })
[17:36:40.123]         }
[17:36:40.123]     }, args = future.call.arguments)
[17:36:40.123] }
[17:36:40.123] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.124] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.124] 
[17:36:40.124] getGlobalsAndPackages() ... DONE
[17:36:40.124] run() for ‘Future’ ...
[17:36:40.124] - state: ‘created’
[17:36:40.125] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.128] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:40.128]   - Field: ‘label’
[17:36:40.128]   - Field: ‘local’
[17:36:40.128]   - Field: ‘owner’
[17:36:40.128]   - Field: ‘envir’
[17:36:40.129]   - Field: ‘packages’
[17:36:40.129]   - Field: ‘gc’
[17:36:40.129]   - Field: ‘conditions’
[17:36:40.129]   - Field: ‘expr’
[17:36:40.129]   - Field: ‘uuid’
[17:36:40.129]   - Field: ‘seed’
[17:36:40.129]   - Field: ‘version’
[17:36:40.129]   - Field: ‘result’
[17:36:40.129]   - Field: ‘asynchronous’
[17:36:40.129]   - Field: ‘calls’
[17:36:40.129]   - Field: ‘globals’
[17:36:40.130]   - Field: ‘stdout’
[17:36:40.130]   - Field: ‘earlySignal’
[17:36:40.130]   - Field: ‘lazy’
[17:36:40.130]   - Field: ‘state’
[17:36:40.130] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:40.130] - Launch lazy future ...
[17:36:40.130] Packages needed by the future expression (n = 0): <none>
[17:36:40.130] Packages needed by future strategies (n = 0): <none>
[17:36:40.131] {
[17:36:40.131]     {
[17:36:40.131]         {
[17:36:40.131]             ...future.startTime <- base::Sys.time()
[17:36:40.131]             {
[17:36:40.131]                 {
[17:36:40.131]                   {
[17:36:40.131]                     base::local({
[17:36:40.131]                       has_future <- base::requireNamespace("future", 
[17:36:40.131]                         quietly = TRUE)
[17:36:40.131]                       if (has_future) {
[17:36:40.131]                         ns <- base::getNamespace("future")
[17:36:40.131]                         version <- ns[[".package"]][["version"]]
[17:36:40.131]                         if (is.null(version)) 
[17:36:40.131]                           version <- utils::packageVersion("future")
[17:36:40.131]                       }
[17:36:40.131]                       else {
[17:36:40.131]                         version <- NULL
[17:36:40.131]                       }
[17:36:40.131]                       if (!has_future || version < "1.8.0") {
[17:36:40.131]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.131]                           "", base::R.version$version.string), 
[17:36:40.131]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:40.131]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.131]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.131]                             "release", "version")], collapse = " "), 
[17:36:40.131]                           hostname = base::Sys.info()[["nodename"]])
[17:36:40.131]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.131]                           info)
[17:36:40.131]                         info <- base::paste(info, collapse = "; ")
[17:36:40.131]                         if (!has_future) {
[17:36:40.131]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.131]                             info)
[17:36:40.131]                         }
[17:36:40.131]                         else {
[17:36:40.131]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.131]                             info, version)
[17:36:40.131]                         }
[17:36:40.131]                         base::stop(msg)
[17:36:40.131]                       }
[17:36:40.131]                     })
[17:36:40.131]                   }
[17:36:40.131]                   ...future.strategy.old <- future::plan("list")
[17:36:40.131]                   options(future.plan = NULL)
[17:36:40.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.131]                 }
[17:36:40.131]                 ...future.workdir <- getwd()
[17:36:40.131]             }
[17:36:40.131]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.131]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.131]         }
[17:36:40.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.131]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:40.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.131]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.131]             base::names(...future.oldOptions))
[17:36:40.131]     }
[17:36:40.131]     if (FALSE) {
[17:36:40.131]     }
[17:36:40.131]     else {
[17:36:40.131]         if (TRUE) {
[17:36:40.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.131]                 open = "w")
[17:36:40.131]         }
[17:36:40.131]         else {
[17:36:40.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.131]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.131]         }
[17:36:40.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.131]             base::sink(type = "output", split = FALSE)
[17:36:40.131]             base::close(...future.stdout)
[17:36:40.131]         }, add = TRUE)
[17:36:40.131]     }
[17:36:40.131]     ...future.frame <- base::sys.nframe()
[17:36:40.131]     ...future.conditions <- base::list()
[17:36:40.131]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.131]     if (FALSE) {
[17:36:40.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.131]     }
[17:36:40.131]     ...future.result <- base::tryCatch({
[17:36:40.131]         base::withCallingHandlers({
[17:36:40.131]             ...future.value <- base::withVisible(base::local({
[17:36:40.131]                 do.call(function(...) {
[17:36:40.131]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.131]                   if (!identical(...future.globals.maxSize.org, 
[17:36:40.131]                     ...future.globals.maxSize)) {
[17:36:40.131]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.131]                     on.exit(options(oopts), add = TRUE)
[17:36:40.131]                   }
[17:36:40.131]                   {
[17:36:40.131]                     lapply(seq_along(...future.elements_ii), 
[17:36:40.131]                       FUN = function(jj) {
[17:36:40.131]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.131]                         ...future.FUN(...future.X_jj, ...)
[17:36:40.131]                       })
[17:36:40.131]                   }
[17:36:40.131]                 }, args = future.call.arguments)
[17:36:40.131]             }))
[17:36:40.131]             future::FutureResult(value = ...future.value$value, 
[17:36:40.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.131]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.131]                     ...future.globalenv.names))
[17:36:40.131]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.131]         }, condition = base::local({
[17:36:40.131]             c <- base::c
[17:36:40.131]             inherits <- base::inherits
[17:36:40.131]             invokeRestart <- base::invokeRestart
[17:36:40.131]             length <- base::length
[17:36:40.131]             list <- base::list
[17:36:40.131]             seq.int <- base::seq.int
[17:36:40.131]             signalCondition <- base::signalCondition
[17:36:40.131]             sys.calls <- base::sys.calls
[17:36:40.131]             `[[` <- base::`[[`
[17:36:40.131]             `+` <- base::`+`
[17:36:40.131]             `<<-` <- base::`<<-`
[17:36:40.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.131]                   3L)]
[17:36:40.131]             }
[17:36:40.131]             function(cond) {
[17:36:40.131]                 is_error <- inherits(cond, "error")
[17:36:40.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.131]                   NULL)
[17:36:40.131]                 if (is_error) {
[17:36:40.131]                   sessionInformation <- function() {
[17:36:40.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.131]                       search = base::search(), system = base::Sys.info())
[17:36:40.131]                   }
[17:36:40.131]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.131]                     cond$call), session = sessionInformation(), 
[17:36:40.131]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.131]                   signalCondition(cond)
[17:36:40.131]                 }
[17:36:40.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.131]                 "immediateCondition"))) {
[17:36:40.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.131]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.131]                   if (TRUE && !signal) {
[17:36:40.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.131]                     {
[17:36:40.131]                       inherits <- base::inherits
[17:36:40.131]                       invokeRestart <- base::invokeRestart
[17:36:40.131]                       is.null <- base::is.null
[17:36:40.131]                       muffled <- FALSE
[17:36:40.131]                       if (inherits(cond, "message")) {
[17:36:40.131]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.131]                         if (muffled) 
[17:36:40.131]                           invokeRestart("muffleMessage")
[17:36:40.131]                       }
[17:36:40.131]                       else if (inherits(cond, "warning")) {
[17:36:40.131]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.131]                         if (muffled) 
[17:36:40.131]                           invokeRestart("muffleWarning")
[17:36:40.131]                       }
[17:36:40.131]                       else if (inherits(cond, "condition")) {
[17:36:40.131]                         if (!is.null(pattern)) {
[17:36:40.131]                           computeRestarts <- base::computeRestarts
[17:36:40.131]                           grepl <- base::grepl
[17:36:40.131]                           restarts <- computeRestarts(cond)
[17:36:40.131]                           for (restart in restarts) {
[17:36:40.131]                             name <- restart$name
[17:36:40.131]                             if (is.null(name)) 
[17:36:40.131]                               next
[17:36:40.131]                             if (!grepl(pattern, name)) 
[17:36:40.131]                               next
[17:36:40.131]                             invokeRestart(restart)
[17:36:40.131]                             muffled <- TRUE
[17:36:40.131]                             break
[17:36:40.131]                           }
[17:36:40.131]                         }
[17:36:40.131]                       }
[17:36:40.131]                       invisible(muffled)
[17:36:40.131]                     }
[17:36:40.131]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.131]                   }
[17:36:40.131]                 }
[17:36:40.131]                 else {
[17:36:40.131]                   if (TRUE) {
[17:36:40.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.131]                     {
[17:36:40.131]                       inherits <- base::inherits
[17:36:40.131]                       invokeRestart <- base::invokeRestart
[17:36:40.131]                       is.null <- base::is.null
[17:36:40.131]                       muffled <- FALSE
[17:36:40.131]                       if (inherits(cond, "message")) {
[17:36:40.131]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.131]                         if (muffled) 
[17:36:40.131]                           invokeRestart("muffleMessage")
[17:36:40.131]                       }
[17:36:40.131]                       else if (inherits(cond, "warning")) {
[17:36:40.131]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.131]                         if (muffled) 
[17:36:40.131]                           invokeRestart("muffleWarning")
[17:36:40.131]                       }
[17:36:40.131]                       else if (inherits(cond, "condition")) {
[17:36:40.131]                         if (!is.null(pattern)) {
[17:36:40.131]                           computeRestarts <- base::computeRestarts
[17:36:40.131]                           grepl <- base::grepl
[17:36:40.131]                           restarts <- computeRestarts(cond)
[17:36:40.131]                           for (restart in restarts) {
[17:36:40.131]                             name <- restart$name
[17:36:40.131]                             if (is.null(name)) 
[17:36:40.131]                               next
[17:36:40.131]                             if (!grepl(pattern, name)) 
[17:36:40.131]                               next
[17:36:40.131]                             invokeRestart(restart)
[17:36:40.131]                             muffled <- TRUE
[17:36:40.131]                             break
[17:36:40.131]                           }
[17:36:40.131]                         }
[17:36:40.131]                       }
[17:36:40.131]                       invisible(muffled)
[17:36:40.131]                     }
[17:36:40.131]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.131]                   }
[17:36:40.131]                 }
[17:36:40.131]             }
[17:36:40.131]         }))
[17:36:40.131]     }, error = function(ex) {
[17:36:40.131]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.131]                 ...future.rng), started = ...future.startTime, 
[17:36:40.131]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.131]             version = "1.8"), class = "FutureResult")
[17:36:40.131]     }, finally = {
[17:36:40.131]         if (!identical(...future.workdir, getwd())) 
[17:36:40.131]             setwd(...future.workdir)
[17:36:40.131]         {
[17:36:40.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.131]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.131]             }
[17:36:40.131]             base::options(...future.oldOptions)
[17:36:40.131]             if (.Platform$OS.type == "windows") {
[17:36:40.131]                 old_names <- names(...future.oldEnvVars)
[17:36:40.131]                 envs <- base::Sys.getenv()
[17:36:40.131]                 names <- names(envs)
[17:36:40.131]                 common <- intersect(names, old_names)
[17:36:40.131]                 added <- setdiff(names, old_names)
[17:36:40.131]                 removed <- setdiff(old_names, names)
[17:36:40.131]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.131]                   envs[common]]
[17:36:40.131]                 NAMES <- toupper(changed)
[17:36:40.131]                 args <- list()
[17:36:40.131]                 for (kk in seq_along(NAMES)) {
[17:36:40.131]                   name <- changed[[kk]]
[17:36:40.131]                   NAME <- NAMES[[kk]]
[17:36:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.131]                     next
[17:36:40.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.131]                 }
[17:36:40.131]                 NAMES <- toupper(added)
[17:36:40.131]                 for (kk in seq_along(NAMES)) {
[17:36:40.131]                   name <- added[[kk]]
[17:36:40.131]                   NAME <- NAMES[[kk]]
[17:36:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.131]                     next
[17:36:40.131]                   args[[name]] <- ""
[17:36:40.131]                 }
[17:36:40.131]                 NAMES <- toupper(removed)
[17:36:40.131]                 for (kk in seq_along(NAMES)) {
[17:36:40.131]                   name <- removed[[kk]]
[17:36:40.131]                   NAME <- NAMES[[kk]]
[17:36:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.131]                     next
[17:36:40.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.131]                 }
[17:36:40.131]                 if (length(args) > 0) 
[17:36:40.131]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.131]             }
[17:36:40.131]             else {
[17:36:40.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.131]             }
[17:36:40.131]             {
[17:36:40.131]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.131]                   0L) {
[17:36:40.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.131]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.131]                   base::options(opts)
[17:36:40.131]                 }
[17:36:40.131]                 {
[17:36:40.131]                   {
[17:36:40.131]                     NULL
[17:36:40.131]                     RNGkind("Mersenne-Twister")
[17:36:40.131]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:40.131]                       inherits = FALSE)
[17:36:40.131]                   }
[17:36:40.131]                   options(future.plan = NULL)
[17:36:40.131]                   if (is.na(NA_character_)) 
[17:36:40.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.131]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.131]                     .init = FALSE)
[17:36:40.131]                 }
[17:36:40.131]             }
[17:36:40.131]         }
[17:36:40.131]     })
[17:36:40.131]     if (TRUE) {
[17:36:40.131]         base::sink(type = "output", split = FALSE)
[17:36:40.131]         if (TRUE) {
[17:36:40.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.131]         }
[17:36:40.131]         else {
[17:36:40.131]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.131]         }
[17:36:40.131]         base::close(...future.stdout)
[17:36:40.131]         ...future.stdout <- NULL
[17:36:40.131]     }
[17:36:40.131]     ...future.result$conditions <- ...future.conditions
[17:36:40.131]     ...future.result$finished <- base::Sys.time()
[17:36:40.131]     ...future.result
[17:36:40.131] }
[17:36:40.132] assign_globals() ...
[17:36:40.133] List of 5
[17:36:40.133]  $ ...future.FUN            :function (object, ...)  
[17:36:40.133]  $ future.call.arguments    : list()
[17:36:40.133]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.133]  $ ...future.elements_ii    :List of 3
[17:36:40.133]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.133]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.133]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.133]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.133]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.133]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.133]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.133]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:40.133]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.133]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.133]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.133]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:40.133]  $ ...future.seeds_ii       : NULL
[17:36:40.133]  $ ...future.globals.maxSize: NULL
[17:36:40.133]  - attr(*, "where")=List of 5
[17:36:40.133]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.133]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.133]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.133]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.133]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.133]  - attr(*, "resolved")= logi FALSE
[17:36:40.133]  - attr(*, "total_size")= num 1240
[17:36:40.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.133]  - attr(*, "already-done")= logi TRUE
[17:36:40.142] - copied ‘...future.FUN’ to environment
[17:36:40.143] - copied ‘future.call.arguments’ to environment
[17:36:40.143] - copied ‘...future.elements_ii’ to environment
[17:36:40.143] - copied ‘...future.seeds_ii’ to environment
[17:36:40.143] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.143] assign_globals() ... done
[17:36:40.143] plan(): Setting new future strategy stack:
[17:36:40.143] List of future strategies:
[17:36:40.143] 1. sequential:
[17:36:40.143]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.143]    - tweaked: FALSE
[17:36:40.143]    - call: NULL
[17:36:40.144] plan(): nbrOfWorkers() = 1
[17:36:40.146] plan(): Setting new future strategy stack:
[17:36:40.146] List of future strategies:
[17:36:40.146] 1. multisession:
[17:36:40.146]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:40.146]    - tweaked: FALSE
[17:36:40.146]    - call: plan(strategy)
[17:36:40.150] plan(): nbrOfWorkers() = 1
[17:36:40.150] SequentialFuture started (and completed)
[17:36:40.150] - Launch lazy future ... done
[17:36:40.150] run() for ‘SequentialFuture’ ... done
[17:36:40.150] Created future:
[17:36:40.151] SequentialFuture:
[17:36:40.151] Label: ‘future_by-1’
[17:36:40.151] Expression:
[17:36:40.151] {
[17:36:40.151]     do.call(function(...) {
[17:36:40.151]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.151]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.151]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.151]             on.exit(options(oopts), add = TRUE)
[17:36:40.151]         }
[17:36:40.151]         {
[17:36:40.151]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.151]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.151]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.151]             })
[17:36:40.151]         }
[17:36:40.151]     }, args = future.call.arguments)
[17:36:40.151] }
[17:36:40.151] Lazy evaluation: FALSE
[17:36:40.151] Asynchronous evaluation: FALSE
[17:36:40.151] Local evaluation: TRUE
[17:36:40.151] Environment: 0x5622fc0a7138
[17:36:40.151] Capture standard output: TRUE
[17:36:40.151] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.151] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.151] Packages: <none>
[17:36:40.151] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.151] Resolved: TRUE
[17:36:40.151] Value: 5.37 KiB of class ‘list’
[17:36:40.151] Early signaling: FALSE
[17:36:40.151] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.151] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.152] Chunk #1 of 1 ... DONE
[17:36:40.152] Launching 1 futures (chunks) ... DONE
[17:36:40.152] Resolving 1 futures (chunks) ...
[17:36:40.152] resolve() on list ...
[17:36:40.152]  recursive: 0
[17:36:40.152]  length: 1
[17:36:40.152] 
[17:36:40.153] resolved() for ‘SequentialFuture’ ...
[17:36:40.153] - state: ‘finished’
[17:36:40.153] - run: TRUE
[17:36:40.153] - result: ‘FutureResult’
[17:36:40.153] resolved() for ‘SequentialFuture’ ... done
[17:36:40.153] Future #1
[17:36:40.153] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:40.153] - nx: 1
[17:36:40.153] - relay: TRUE
[17:36:40.153] - stdout: TRUE
[17:36:40.153] - signal: TRUE
[17:36:40.154] - resignal: FALSE
[17:36:40.154] - force: TRUE
[17:36:40.154] - relayed: [n=1] FALSE
[17:36:40.154] - queued futures: [n=1] FALSE
[17:36:40.154]  - until=1
[17:36:40.154]  - relaying element #1
[17:36:40.154] - relayed: [n=1] TRUE
[17:36:40.154] - queued futures: [n=1] TRUE
[17:36:40.154] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:40.154]  length: 0 (resolved future 1)
[17:36:40.155] Relaying remaining futures
[17:36:40.155] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.155] - nx: 1
[17:36:40.155] - relay: TRUE
[17:36:40.155] - stdout: TRUE
[17:36:40.155] - signal: TRUE
[17:36:40.155] - resignal: FALSE
[17:36:40.155] - force: TRUE
[17:36:40.155] - relayed: [n=1] TRUE
[17:36:40.155] - queued futures: [n=1] TRUE
 - flush all
[17:36:40.155] - relayed: [n=1] TRUE
[17:36:40.156] - queued futures: [n=1] TRUE
[17:36:40.156] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.156] resolve() on list ... DONE
[17:36:40.156]  - Number of value chunks collected: 1
[17:36:40.156] Resolving 1 futures (chunks) ... DONE
[17:36:40.156] Reducing values from 1 chunks ...
[17:36:40.156]  - Number of values collected after concatenation: 3
[17:36:40.156]  - Number of values expected: 3
[17:36:40.156] Reducing values from 1 chunks ... DONE
[17:36:40.156] future_lapply() ... DONE
[17:36:40.156] future_by_internal() ... DONE
[17:36:40.157] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:36:40.158] future_lapply() ...
[17:36:40.161] Number of chunks: 1
[17:36:40.162] getGlobalsAndPackagesXApply() ...
[17:36:40.162]  - future.globals: TRUE
[17:36:40.162] getGlobalsAndPackages() ...
[17:36:40.162] Searching for globals...
[17:36:40.163] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:40.163] Searching for globals ... DONE
[17:36:40.163] Resolving globals: FALSE
[17:36:40.163] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:40.164] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:40.164] - globals: [1] ‘FUN’
[17:36:40.164] 
[17:36:40.164] getGlobalsAndPackages() ... DONE
[17:36:40.164]  - globals found/used: [n=1] ‘FUN’
[17:36:40.164]  - needed namespaces: [n=0] 
[17:36:40.164] Finding globals ... DONE
[17:36:40.164]  - use_args: TRUE
[17:36:40.165]  - Getting '...' globals ...
[17:36:40.165] resolve() on list ...
[17:36:40.165]  recursive: 0
[17:36:40.165]  length: 1
[17:36:40.165]  elements: ‘...’
[17:36:40.165]  length: 0 (resolved future 1)
[17:36:40.165] resolve() on list ... DONE
[17:36:40.165]    - '...' content: [n=0] 
[17:36:40.166] List of 1
[17:36:40.166]  $ ...: list()
[17:36:40.166]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.166]  - attr(*, "where")=List of 1
[17:36:40.166]   ..$ ...:<environment: 0x5622fc12c0f0> 
[17:36:40.166]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.166]  - attr(*, "resolved")= logi TRUE
[17:36:40.166]  - attr(*, "total_size")= num NA
[17:36:40.170]  - Getting '...' globals ... DONE
[17:36:40.170] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:40.170] List of 2
[17:36:40.170]  $ ...future.FUN:function (object, ...)  
[17:36:40.170]  $ ...          : list()
[17:36:40.170]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.170]  - attr(*, "where")=List of 2
[17:36:40.170]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.170]   ..$ ...          :<environment: 0x5622fc12c0f0> 
[17:36:40.170]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.170]  - attr(*, "resolved")= logi FALSE
[17:36:40.170]  - attr(*, "total_size")= num 1240
[17:36:40.173] Packages to be attached in all futures: [n=0] 
[17:36:40.173] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.173] Number of futures (= number of chunks): 1
[17:36:40.173] Launching 1 futures (chunks) ...
[17:36:40.174] Chunk #1 of 1 ...
[17:36:40.174]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.174] getGlobalsAndPackages() ...
[17:36:40.174] Searching for globals...
[17:36:40.174] 
[17:36:40.174] Searching for globals ... DONE
[17:36:40.175] - globals: [0] <none>
[17:36:40.175] getGlobalsAndPackages() ... DONE
[17:36:40.175]    + additional globals found: [n=0] 
[17:36:40.175]    + additional namespaces needed: [n=0] 
[17:36:40.175]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.175]  - seeds: <none>
[17:36:40.175]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.175] getGlobalsAndPackages() ...
[17:36:40.175] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.175] Resolving globals: FALSE
[17:36:40.175] Tweak future expression to call with '...' arguments ...
[17:36:40.176] {
[17:36:40.176]     do.call(function(...) {
[17:36:40.176]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.176]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.176]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.176]             on.exit(options(oopts), add = TRUE)
[17:36:40.176]         }
[17:36:40.176]         {
[17:36:40.176]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.176]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.176]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.176]             })
[17:36:40.176]         }
[17:36:40.176]     }, args = future.call.arguments)
[17:36:40.176] }
[17:36:40.176] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.176] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.176] 
[17:36:40.176] getGlobalsAndPackages() ... DONE
[17:36:40.177] run() for ‘Future’ ...
[17:36:40.177] - state: ‘created’
[17:36:40.177] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.181] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.181] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:40.181]   - Field: ‘label’
[17:36:40.181]   - Field: ‘local’
[17:36:40.181]   - Field: ‘owner’
[17:36:40.181]   - Field: ‘envir’
[17:36:40.181]   - Field: ‘packages’
[17:36:40.181]   - Field: ‘gc’
[17:36:40.181]   - Field: ‘conditions’
[17:36:40.182]   - Field: ‘expr’
[17:36:40.182]   - Field: ‘uuid’
[17:36:40.182]   - Field: ‘seed’
[17:36:40.182]   - Field: ‘version’
[17:36:40.182]   - Field: ‘result’
[17:36:40.182]   - Field: ‘asynchronous’
[17:36:40.182]   - Field: ‘calls’
[17:36:40.182]   - Field: ‘globals’
[17:36:40.182]   - Field: ‘stdout’
[17:36:40.182]   - Field: ‘earlySignal’
[17:36:40.182]   - Field: ‘lazy’
[17:36:40.183]   - Field: ‘state’
[17:36:40.183] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:40.183] - Launch lazy future ...
[17:36:40.183] Packages needed by the future expression (n = 0): <none>
[17:36:40.183] Packages needed by future strategies (n = 0): <none>
[17:36:40.183] {
[17:36:40.183]     {
[17:36:40.183]         {
[17:36:40.183]             ...future.startTime <- base::Sys.time()
[17:36:40.183]             {
[17:36:40.183]                 {
[17:36:40.183]                   {
[17:36:40.183]                     base::local({
[17:36:40.183]                       has_future <- base::requireNamespace("future", 
[17:36:40.183]                         quietly = TRUE)
[17:36:40.183]                       if (has_future) {
[17:36:40.183]                         ns <- base::getNamespace("future")
[17:36:40.183]                         version <- ns[[".package"]][["version"]]
[17:36:40.183]                         if (is.null(version)) 
[17:36:40.183]                           version <- utils::packageVersion("future")
[17:36:40.183]                       }
[17:36:40.183]                       else {
[17:36:40.183]                         version <- NULL
[17:36:40.183]                       }
[17:36:40.183]                       if (!has_future || version < "1.8.0") {
[17:36:40.183]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.183]                           "", base::R.version$version.string), 
[17:36:40.183]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:40.183]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.183]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.183]                             "release", "version")], collapse = " "), 
[17:36:40.183]                           hostname = base::Sys.info()[["nodename"]])
[17:36:40.183]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.183]                           info)
[17:36:40.183]                         info <- base::paste(info, collapse = "; ")
[17:36:40.183]                         if (!has_future) {
[17:36:40.183]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.183]                             info)
[17:36:40.183]                         }
[17:36:40.183]                         else {
[17:36:40.183]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.183]                             info, version)
[17:36:40.183]                         }
[17:36:40.183]                         base::stop(msg)
[17:36:40.183]                       }
[17:36:40.183]                     })
[17:36:40.183]                   }
[17:36:40.183]                   ...future.strategy.old <- future::plan("list")
[17:36:40.183]                   options(future.plan = NULL)
[17:36:40.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.183]                 }
[17:36:40.183]                 ...future.workdir <- getwd()
[17:36:40.183]             }
[17:36:40.183]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.183]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.183]         }
[17:36:40.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:40.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.183]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.183]             base::names(...future.oldOptions))
[17:36:40.183]     }
[17:36:40.183]     if (FALSE) {
[17:36:40.183]     }
[17:36:40.183]     else {
[17:36:40.183]         if (TRUE) {
[17:36:40.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.183]                 open = "w")
[17:36:40.183]         }
[17:36:40.183]         else {
[17:36:40.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.183]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.183]         }
[17:36:40.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.183]             base::sink(type = "output", split = FALSE)
[17:36:40.183]             base::close(...future.stdout)
[17:36:40.183]         }, add = TRUE)
[17:36:40.183]     }
[17:36:40.183]     ...future.frame <- base::sys.nframe()
[17:36:40.183]     ...future.conditions <- base::list()
[17:36:40.183]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.183]     if (FALSE) {
[17:36:40.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.183]     }
[17:36:40.183]     ...future.result <- base::tryCatch({
[17:36:40.183]         base::withCallingHandlers({
[17:36:40.183]             ...future.value <- base::withVisible(base::local({
[17:36:40.183]                 do.call(function(...) {
[17:36:40.183]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.183]                   if (!identical(...future.globals.maxSize.org, 
[17:36:40.183]                     ...future.globals.maxSize)) {
[17:36:40.183]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.183]                     on.exit(options(oopts), add = TRUE)
[17:36:40.183]                   }
[17:36:40.183]                   {
[17:36:40.183]                     lapply(seq_along(...future.elements_ii), 
[17:36:40.183]                       FUN = function(jj) {
[17:36:40.183]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.183]                         ...future.FUN(...future.X_jj, ...)
[17:36:40.183]                       })
[17:36:40.183]                   }
[17:36:40.183]                 }, args = future.call.arguments)
[17:36:40.183]             }))
[17:36:40.183]             future::FutureResult(value = ...future.value$value, 
[17:36:40.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.183]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.183]                     ...future.globalenv.names))
[17:36:40.183]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.183]         }, condition = base::local({
[17:36:40.183]             c <- base::c
[17:36:40.183]             inherits <- base::inherits
[17:36:40.183]             invokeRestart <- base::invokeRestart
[17:36:40.183]             length <- base::length
[17:36:40.183]             list <- base::list
[17:36:40.183]             seq.int <- base::seq.int
[17:36:40.183]             signalCondition <- base::signalCondition
[17:36:40.183]             sys.calls <- base::sys.calls
[17:36:40.183]             `[[` <- base::`[[`
[17:36:40.183]             `+` <- base::`+`
[17:36:40.183]             `<<-` <- base::`<<-`
[17:36:40.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.183]                   3L)]
[17:36:40.183]             }
[17:36:40.183]             function(cond) {
[17:36:40.183]                 is_error <- inherits(cond, "error")
[17:36:40.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.183]                   NULL)
[17:36:40.183]                 if (is_error) {
[17:36:40.183]                   sessionInformation <- function() {
[17:36:40.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.183]                       search = base::search(), system = base::Sys.info())
[17:36:40.183]                   }
[17:36:40.183]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.183]                     cond$call), session = sessionInformation(), 
[17:36:40.183]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.183]                   signalCondition(cond)
[17:36:40.183]                 }
[17:36:40.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.183]                 "immediateCondition"))) {
[17:36:40.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.183]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.183]                   if (TRUE && !signal) {
[17:36:40.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.183]                     {
[17:36:40.183]                       inherits <- base::inherits
[17:36:40.183]                       invokeRestart <- base::invokeRestart
[17:36:40.183]                       is.null <- base::is.null
[17:36:40.183]                       muffled <- FALSE
[17:36:40.183]                       if (inherits(cond, "message")) {
[17:36:40.183]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.183]                         if (muffled) 
[17:36:40.183]                           invokeRestart("muffleMessage")
[17:36:40.183]                       }
[17:36:40.183]                       else if (inherits(cond, "warning")) {
[17:36:40.183]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.183]                         if (muffled) 
[17:36:40.183]                           invokeRestart("muffleWarning")
[17:36:40.183]                       }
[17:36:40.183]                       else if (inherits(cond, "condition")) {
[17:36:40.183]                         if (!is.null(pattern)) {
[17:36:40.183]                           computeRestarts <- base::computeRestarts
[17:36:40.183]                           grepl <- base::grepl
[17:36:40.183]                           restarts <- computeRestarts(cond)
[17:36:40.183]                           for (restart in restarts) {
[17:36:40.183]                             name <- restart$name
[17:36:40.183]                             if (is.null(name)) 
[17:36:40.183]                               next
[17:36:40.183]                             if (!grepl(pattern, name)) 
[17:36:40.183]                               next
[17:36:40.183]                             invokeRestart(restart)
[17:36:40.183]                             muffled <- TRUE
[17:36:40.183]                             break
[17:36:40.183]                           }
[17:36:40.183]                         }
[17:36:40.183]                       }
[17:36:40.183]                       invisible(muffled)
[17:36:40.183]                     }
[17:36:40.183]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.183]                   }
[17:36:40.183]                 }
[17:36:40.183]                 else {
[17:36:40.183]                   if (TRUE) {
[17:36:40.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.183]                     {
[17:36:40.183]                       inherits <- base::inherits
[17:36:40.183]                       invokeRestart <- base::invokeRestart
[17:36:40.183]                       is.null <- base::is.null
[17:36:40.183]                       muffled <- FALSE
[17:36:40.183]                       if (inherits(cond, "message")) {
[17:36:40.183]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.183]                         if (muffled) 
[17:36:40.183]                           invokeRestart("muffleMessage")
[17:36:40.183]                       }
[17:36:40.183]                       else if (inherits(cond, "warning")) {
[17:36:40.183]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.183]                         if (muffled) 
[17:36:40.183]                           invokeRestart("muffleWarning")
[17:36:40.183]                       }
[17:36:40.183]                       else if (inherits(cond, "condition")) {
[17:36:40.183]                         if (!is.null(pattern)) {
[17:36:40.183]                           computeRestarts <- base::computeRestarts
[17:36:40.183]                           grepl <- base::grepl
[17:36:40.183]                           restarts <- computeRestarts(cond)
[17:36:40.183]                           for (restart in restarts) {
[17:36:40.183]                             name <- restart$name
[17:36:40.183]                             if (is.null(name)) 
[17:36:40.183]                               next
[17:36:40.183]                             if (!grepl(pattern, name)) 
[17:36:40.183]                               next
[17:36:40.183]                             invokeRestart(restart)
[17:36:40.183]                             muffled <- TRUE
[17:36:40.183]                             break
[17:36:40.183]                           }
[17:36:40.183]                         }
[17:36:40.183]                       }
[17:36:40.183]                       invisible(muffled)
[17:36:40.183]                     }
[17:36:40.183]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.183]                   }
[17:36:40.183]                 }
[17:36:40.183]             }
[17:36:40.183]         }))
[17:36:40.183]     }, error = function(ex) {
[17:36:40.183]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.183]                 ...future.rng), started = ...future.startTime, 
[17:36:40.183]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.183]             version = "1.8"), class = "FutureResult")
[17:36:40.183]     }, finally = {
[17:36:40.183]         if (!identical(...future.workdir, getwd())) 
[17:36:40.183]             setwd(...future.workdir)
[17:36:40.183]         {
[17:36:40.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.183]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.183]             }
[17:36:40.183]             base::options(...future.oldOptions)
[17:36:40.183]             if (.Platform$OS.type == "windows") {
[17:36:40.183]                 old_names <- names(...future.oldEnvVars)
[17:36:40.183]                 envs <- base::Sys.getenv()
[17:36:40.183]                 names <- names(envs)
[17:36:40.183]                 common <- intersect(names, old_names)
[17:36:40.183]                 added <- setdiff(names, old_names)
[17:36:40.183]                 removed <- setdiff(old_names, names)
[17:36:40.183]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.183]                   envs[common]]
[17:36:40.183]                 NAMES <- toupper(changed)
[17:36:40.183]                 args <- list()
[17:36:40.183]                 for (kk in seq_along(NAMES)) {
[17:36:40.183]                   name <- changed[[kk]]
[17:36:40.183]                   NAME <- NAMES[[kk]]
[17:36:40.183]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.183]                     next
[17:36:40.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.183]                 }
[17:36:40.183]                 NAMES <- toupper(added)
[17:36:40.183]                 for (kk in seq_along(NAMES)) {
[17:36:40.183]                   name <- added[[kk]]
[17:36:40.183]                   NAME <- NAMES[[kk]]
[17:36:40.183]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.183]                     next
[17:36:40.183]                   args[[name]] <- ""
[17:36:40.183]                 }
[17:36:40.183]                 NAMES <- toupper(removed)
[17:36:40.183]                 for (kk in seq_along(NAMES)) {
[17:36:40.183]                   name <- removed[[kk]]
[17:36:40.183]                   NAME <- NAMES[[kk]]
[17:36:40.183]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.183]                     next
[17:36:40.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.183]                 }
[17:36:40.183]                 if (length(args) > 0) 
[17:36:40.183]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.183]             }
[17:36:40.183]             else {
[17:36:40.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.183]             }
[17:36:40.183]             {
[17:36:40.183]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.183]                   0L) {
[17:36:40.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.183]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.183]                   base::options(opts)
[17:36:40.183]                 }
[17:36:40.183]                 {
[17:36:40.183]                   {
[17:36:40.183]                     NULL
[17:36:40.183]                     RNGkind("Mersenne-Twister")
[17:36:40.183]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:40.183]                       inherits = FALSE)
[17:36:40.183]                   }
[17:36:40.183]                   options(future.plan = NULL)
[17:36:40.183]                   if (is.na(NA_character_)) 
[17:36:40.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.183]                     .init = FALSE)
[17:36:40.183]                 }
[17:36:40.183]             }
[17:36:40.183]         }
[17:36:40.183]     })
[17:36:40.183]     if (TRUE) {
[17:36:40.183]         base::sink(type = "output", split = FALSE)
[17:36:40.183]         if (TRUE) {
[17:36:40.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.183]         }
[17:36:40.183]         else {
[17:36:40.183]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.183]         }
[17:36:40.183]         base::close(...future.stdout)
[17:36:40.183]         ...future.stdout <- NULL
[17:36:40.183]     }
[17:36:40.183]     ...future.result$conditions <- ...future.conditions
[17:36:40.183]     ...future.result$finished <- base::Sys.time()
[17:36:40.183]     ...future.result
[17:36:40.183] }
[17:36:40.185] assign_globals() ...
[17:36:40.185] List of 5
[17:36:40.185]  $ ...future.FUN            :function (object, ...)  
[17:36:40.185]  $ future.call.arguments    : list()
[17:36:40.185]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.185]  $ ...future.elements_ii    :List of 3
[17:36:40.185]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.185]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.185]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.185]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.185]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.185]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.185]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.185]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:40.185]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.185]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.185]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.185]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:40.185]  $ ...future.seeds_ii       : NULL
[17:36:40.185]  $ ...future.globals.maxSize: NULL
[17:36:40.185]  - attr(*, "where")=List of 5
[17:36:40.185]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.185]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.185]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.185]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.185]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.185]  - attr(*, "resolved")= logi FALSE
[17:36:40.185]  - attr(*, "total_size")= num 1240
[17:36:40.185]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.185]  - attr(*, "already-done")= logi TRUE
[17:36:40.196] - copied ‘...future.FUN’ to environment
[17:36:40.196] - copied ‘future.call.arguments’ to environment
[17:36:40.196] - copied ‘...future.elements_ii’ to environment
[17:36:40.196] - copied ‘...future.seeds_ii’ to environment
[17:36:40.196] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.196] assign_globals() ... done
[17:36:40.196] plan(): Setting new future strategy stack:
[17:36:40.197] List of future strategies:
[17:36:40.197] 1. sequential:
[17:36:40.197]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.197]    - tweaked: FALSE
[17:36:40.197]    - call: NULL
[17:36:40.197] plan(): nbrOfWorkers() = 1
[17:36:40.199] plan(): Setting new future strategy stack:
[17:36:40.199] List of future strategies:
[17:36:40.199] 1. multisession:
[17:36:40.199]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:40.199]    - tweaked: FALSE
[17:36:40.199]    - call: plan(strategy)
[17:36:40.203] plan(): nbrOfWorkers() = 1
[17:36:40.203] SequentialFuture started (and completed)
[17:36:40.203] - Launch lazy future ... done
[17:36:40.203] run() for ‘SequentialFuture’ ... done
[17:36:40.204] Created future:
[17:36:40.204] SequentialFuture:
[17:36:40.204] Label: ‘future_by-1’
[17:36:40.204] Expression:
[17:36:40.204] {
[17:36:40.204]     do.call(function(...) {
[17:36:40.204]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.204]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.204]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.204]             on.exit(options(oopts), add = TRUE)
[17:36:40.204]         }
[17:36:40.204]         {
[17:36:40.204]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.204]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.204]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.204]             })
[17:36:40.204]         }
[17:36:40.204]     }, args = future.call.arguments)
[17:36:40.204] }
[17:36:40.204] Lazy evaluation: FALSE
[17:36:40.204] Asynchronous evaluation: FALSE
[17:36:40.204] Local evaluation: TRUE
[17:36:40.204] Environment: 0x5622fc0cc688
[17:36:40.204] Capture standard output: TRUE
[17:36:40.204] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.204] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.204] Packages: <none>
[17:36:40.204] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.204] Resolved: TRUE
[17:36:40.204] Value: 5.37 KiB of class ‘list’
[17:36:40.204] Early signaling: FALSE
[17:36:40.204] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.204] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.205] Chunk #1 of 1 ... DONE
[17:36:40.205] Launching 1 futures (chunks) ... DONE
[17:36:40.205] Resolving 1 futures (chunks) ...
[17:36:40.205] resolve() on list ...
[17:36:40.205]  recursive: 0
[17:36:40.206]  length: 1
[17:36:40.206] 
[17:36:40.206] resolved() for ‘SequentialFuture’ ...
[17:36:40.206] - state: ‘finished’
[17:36:40.206] - run: TRUE
[17:36:40.206] - result: ‘FutureResult’
[17:36:40.206] resolved() for ‘SequentialFuture’ ... done
[17:36:40.206] Future #1
[17:36:40.206] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:40.206] - nx: 1
[17:36:40.207] - relay: TRUE
[17:36:40.207] - stdout: TRUE
[17:36:40.207] - signal: TRUE
[17:36:40.207] - resignal: FALSE
[17:36:40.207] - force: TRUE
[17:36:40.207] - relayed: [n=1] FALSE
[17:36:40.207] - queued futures: [n=1] FALSE
[17:36:40.207]  - until=1
[17:36:40.207]  - relaying element #1
[17:36:40.207] - relayed: [n=1] TRUE
[17:36:40.207] - queued futures: [n=1] TRUE
[17:36:40.208] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:40.208]  length: 0 (resolved future 1)
[17:36:40.208] Relaying remaining futures
[17:36:40.208] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.208] - nx: 1
[17:36:40.208] - relay: TRUE
[17:36:40.208] - stdout: TRUE
[17:36:40.208] - signal: TRUE
[17:36:40.208] - resignal: FALSE
[17:36:40.208] - force: TRUE
[17:36:40.208] - relayed: [n=1] TRUE
[17:36:40.209] - queued futures: [n=1] TRUE
 - flush all
[17:36:40.209] - relayed: [n=1] TRUE
[17:36:40.209] - queued futures: [n=1] TRUE
[17:36:40.209] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.209] resolve() on list ... DONE
[17:36:40.209]  - Number of value chunks collected: 1
[17:36:40.209] Resolving 1 futures (chunks) ... DONE
[17:36:40.209] Reducing values from 1 chunks ...
[17:36:40.209]  - Number of values collected after concatenation: 3
[17:36:40.209]  - Number of values expected: 3
[17:36:40.210] Reducing values from 1 chunks ... DONE
[17:36:40.210] future_lapply() ... DONE
[17:36:40.210] future_by_internal() ... DONE
[17:36:40.211] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[17:36:40.211] plan(): Setting new future strategy stack:
[17:36:40.211] List of future strategies:
[17:36:40.211] 1. sequential:
[17:36:40.211]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.211]    - tweaked: FALSE
[17:36:40.211]    - call: plan(strategy)
[17:36:40.212] plan(): nbrOfWorkers() = 1
[17:36:40.212] future_by_internal() ...
[17:36:40.212] future_lapply() ...
[17:36:40.213] Number of chunks: 1
[17:36:40.213] getGlobalsAndPackagesXApply() ...
[17:36:40.213]  - future.globals: TRUE
[17:36:40.213] getGlobalsAndPackages() ...
[17:36:40.213] Searching for globals...
[17:36:40.214] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:40.214] Searching for globals ... DONE
[17:36:40.215] Resolving globals: FALSE
[17:36:40.215] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:40.215] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:40.215] - globals: [1] ‘FUN’
[17:36:40.215] 
[17:36:40.216] getGlobalsAndPackages() ... DONE
[17:36:40.216]  - globals found/used: [n=1] ‘FUN’
[17:36:40.216]  - needed namespaces: [n=0] 
[17:36:40.216] Finding globals ... DONE
[17:36:40.216]  - use_args: TRUE
[17:36:40.216]  - Getting '...' globals ...
[17:36:40.216] resolve() on list ...
[17:36:40.216]  recursive: 0
[17:36:40.217]  length: 1
[17:36:40.217]  elements: ‘...’
[17:36:40.217]  length: 0 (resolved future 1)
[17:36:40.217] resolve() on list ... DONE
[17:36:40.217]    - '...' content: [n=0] 
[17:36:40.217] List of 1
[17:36:40.217]  $ ...: list()
[17:36:40.217]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.217]  - attr(*, "where")=List of 1
[17:36:40.217]   ..$ ...:<environment: 0x5622fc2cfc68> 
[17:36:40.217]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.217]  - attr(*, "resolved")= logi TRUE
[17:36:40.217]  - attr(*, "total_size")= num NA
[17:36:40.222]  - Getting '...' globals ... DONE
[17:36:40.222] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:40.222] List of 2
[17:36:40.222]  $ ...future.FUN:function (object, ...)  
[17:36:40.222]  $ ...          : list()
[17:36:40.222]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.222]  - attr(*, "where")=List of 2
[17:36:40.222]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.222]   ..$ ...          :<environment: 0x5622fc2cfc68> 
[17:36:40.222]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.222]  - attr(*, "resolved")= logi FALSE
[17:36:40.222]  - attr(*, "total_size")= num 1240
[17:36:40.225] Packages to be attached in all futures: [n=0] 
[17:36:40.225] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.225] Number of futures (= number of chunks): 1
[17:36:40.225] Launching 1 futures (chunks) ...
[17:36:40.225] Chunk #1 of 1 ...
[17:36:40.225]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.225] getGlobalsAndPackages() ...
[17:36:40.225] Searching for globals...
[17:36:40.226] 
[17:36:40.226] Searching for globals ... DONE
[17:36:40.226] - globals: [0] <none>
[17:36:40.226] getGlobalsAndPackages() ... DONE
[17:36:40.226]    + additional globals found: [n=0] 
[17:36:40.226]    + additional namespaces needed: [n=0] 
[17:36:40.226]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.227]  - seeds: <none>
[17:36:40.227]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.227] getGlobalsAndPackages() ...
[17:36:40.227] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.227] Resolving globals: FALSE
[17:36:40.227] Tweak future expression to call with '...' arguments ...
[17:36:40.227] {
[17:36:40.227]     do.call(function(...) {
[17:36:40.227]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.227]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.227]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.227]             on.exit(options(oopts), add = TRUE)
[17:36:40.227]         }
[17:36:40.227]         {
[17:36:40.227]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.227]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.227]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.227]             })
[17:36:40.227]         }
[17:36:40.227]     }, args = future.call.arguments)
[17:36:40.227] }
[17:36:40.227] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.228] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.228] 
[17:36:40.228] getGlobalsAndPackages() ... DONE
[17:36:40.228] run() for ‘Future’ ...
[17:36:40.228] - state: ‘created’
[17:36:40.229] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:40.229] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:40.229]   - Field: ‘label’
[17:36:40.229]   - Field: ‘local’
[17:36:40.229]   - Field: ‘owner’
[17:36:40.229]   - Field: ‘envir’
[17:36:40.229]   - Field: ‘packages’
[17:36:40.229]   - Field: ‘gc’
[17:36:40.230]   - Field: ‘conditions’
[17:36:40.230]   - Field: ‘expr’
[17:36:40.230]   - Field: ‘uuid’
[17:36:40.230]   - Field: ‘seed’
[17:36:40.230]   - Field: ‘version’
[17:36:40.230]   - Field: ‘result’
[17:36:40.230]   - Field: ‘asynchronous’
[17:36:40.230]   - Field: ‘calls’
[17:36:40.230]   - Field: ‘globals’
[17:36:40.230]   - Field: ‘stdout’
[17:36:40.230]   - Field: ‘earlySignal’
[17:36:40.231]   - Field: ‘lazy’
[17:36:40.231]   - Field: ‘state’
[17:36:40.231] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:40.231] - Launch lazy future ...
[17:36:40.231] Packages needed by the future expression (n = 0): <none>
[17:36:40.231] Packages needed by future strategies (n = 0): <none>
[17:36:40.232] {
[17:36:40.232]     {
[17:36:40.232]         {
[17:36:40.232]             ...future.startTime <- base::Sys.time()
[17:36:40.232]             {
[17:36:40.232]                 {
[17:36:40.232]                   {
[17:36:40.232]                     base::local({
[17:36:40.232]                       has_future <- base::requireNamespace("future", 
[17:36:40.232]                         quietly = TRUE)
[17:36:40.232]                       if (has_future) {
[17:36:40.232]                         ns <- base::getNamespace("future")
[17:36:40.232]                         version <- ns[[".package"]][["version"]]
[17:36:40.232]                         if (is.null(version)) 
[17:36:40.232]                           version <- utils::packageVersion("future")
[17:36:40.232]                       }
[17:36:40.232]                       else {
[17:36:40.232]                         version <- NULL
[17:36:40.232]                       }
[17:36:40.232]                       if (!has_future || version < "1.8.0") {
[17:36:40.232]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.232]                           "", base::R.version$version.string), 
[17:36:40.232]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:40.232]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.232]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.232]                             "release", "version")], collapse = " "), 
[17:36:40.232]                           hostname = base::Sys.info()[["nodename"]])
[17:36:40.232]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.232]                           info)
[17:36:40.232]                         info <- base::paste(info, collapse = "; ")
[17:36:40.232]                         if (!has_future) {
[17:36:40.232]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.232]                             info)
[17:36:40.232]                         }
[17:36:40.232]                         else {
[17:36:40.232]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.232]                             info, version)
[17:36:40.232]                         }
[17:36:40.232]                         base::stop(msg)
[17:36:40.232]                       }
[17:36:40.232]                     })
[17:36:40.232]                   }
[17:36:40.232]                   ...future.strategy.old <- future::plan("list")
[17:36:40.232]                   options(future.plan = NULL)
[17:36:40.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.232]                 }
[17:36:40.232]                 ...future.workdir <- getwd()
[17:36:40.232]             }
[17:36:40.232]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.232]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.232]         }
[17:36:40.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.232]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:40.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.232]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.232]             base::names(...future.oldOptions))
[17:36:40.232]     }
[17:36:40.232]     if (FALSE) {
[17:36:40.232]     }
[17:36:40.232]     else {
[17:36:40.232]         if (TRUE) {
[17:36:40.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.232]                 open = "w")
[17:36:40.232]         }
[17:36:40.232]         else {
[17:36:40.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.232]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.232]         }
[17:36:40.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.232]             base::sink(type = "output", split = FALSE)
[17:36:40.232]             base::close(...future.stdout)
[17:36:40.232]         }, add = TRUE)
[17:36:40.232]     }
[17:36:40.232]     ...future.frame <- base::sys.nframe()
[17:36:40.232]     ...future.conditions <- base::list()
[17:36:40.232]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.232]     if (FALSE) {
[17:36:40.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.232]     }
[17:36:40.232]     ...future.result <- base::tryCatch({
[17:36:40.232]         base::withCallingHandlers({
[17:36:40.232]             ...future.value <- base::withVisible(base::local({
[17:36:40.232]                 do.call(function(...) {
[17:36:40.232]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.232]                   if (!identical(...future.globals.maxSize.org, 
[17:36:40.232]                     ...future.globals.maxSize)) {
[17:36:40.232]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.232]                     on.exit(options(oopts), add = TRUE)
[17:36:40.232]                   }
[17:36:40.232]                   {
[17:36:40.232]                     lapply(seq_along(...future.elements_ii), 
[17:36:40.232]                       FUN = function(jj) {
[17:36:40.232]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.232]                         ...future.FUN(...future.X_jj, ...)
[17:36:40.232]                       })
[17:36:40.232]                   }
[17:36:40.232]                 }, args = future.call.arguments)
[17:36:40.232]             }))
[17:36:40.232]             future::FutureResult(value = ...future.value$value, 
[17:36:40.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.232]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.232]                     ...future.globalenv.names))
[17:36:40.232]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.232]         }, condition = base::local({
[17:36:40.232]             c <- base::c
[17:36:40.232]             inherits <- base::inherits
[17:36:40.232]             invokeRestart <- base::invokeRestart
[17:36:40.232]             length <- base::length
[17:36:40.232]             list <- base::list
[17:36:40.232]             seq.int <- base::seq.int
[17:36:40.232]             signalCondition <- base::signalCondition
[17:36:40.232]             sys.calls <- base::sys.calls
[17:36:40.232]             `[[` <- base::`[[`
[17:36:40.232]             `+` <- base::`+`
[17:36:40.232]             `<<-` <- base::`<<-`
[17:36:40.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.232]                   3L)]
[17:36:40.232]             }
[17:36:40.232]             function(cond) {
[17:36:40.232]                 is_error <- inherits(cond, "error")
[17:36:40.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.232]                   NULL)
[17:36:40.232]                 if (is_error) {
[17:36:40.232]                   sessionInformation <- function() {
[17:36:40.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.232]                       search = base::search(), system = base::Sys.info())
[17:36:40.232]                   }
[17:36:40.232]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.232]                     cond$call), session = sessionInformation(), 
[17:36:40.232]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.232]                   signalCondition(cond)
[17:36:40.232]                 }
[17:36:40.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.232]                 "immediateCondition"))) {
[17:36:40.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.232]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.232]                   if (TRUE && !signal) {
[17:36:40.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.232]                     {
[17:36:40.232]                       inherits <- base::inherits
[17:36:40.232]                       invokeRestart <- base::invokeRestart
[17:36:40.232]                       is.null <- base::is.null
[17:36:40.232]                       muffled <- FALSE
[17:36:40.232]                       if (inherits(cond, "message")) {
[17:36:40.232]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.232]                         if (muffled) 
[17:36:40.232]                           invokeRestart("muffleMessage")
[17:36:40.232]                       }
[17:36:40.232]                       else if (inherits(cond, "warning")) {
[17:36:40.232]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.232]                         if (muffled) 
[17:36:40.232]                           invokeRestart("muffleWarning")
[17:36:40.232]                       }
[17:36:40.232]                       else if (inherits(cond, "condition")) {
[17:36:40.232]                         if (!is.null(pattern)) {
[17:36:40.232]                           computeRestarts <- base::computeRestarts
[17:36:40.232]                           grepl <- base::grepl
[17:36:40.232]                           restarts <- computeRestarts(cond)
[17:36:40.232]                           for (restart in restarts) {
[17:36:40.232]                             name <- restart$name
[17:36:40.232]                             if (is.null(name)) 
[17:36:40.232]                               next
[17:36:40.232]                             if (!grepl(pattern, name)) 
[17:36:40.232]                               next
[17:36:40.232]                             invokeRestart(restart)
[17:36:40.232]                             muffled <- TRUE
[17:36:40.232]                             break
[17:36:40.232]                           }
[17:36:40.232]                         }
[17:36:40.232]                       }
[17:36:40.232]                       invisible(muffled)
[17:36:40.232]                     }
[17:36:40.232]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.232]                   }
[17:36:40.232]                 }
[17:36:40.232]                 else {
[17:36:40.232]                   if (TRUE) {
[17:36:40.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.232]                     {
[17:36:40.232]                       inherits <- base::inherits
[17:36:40.232]                       invokeRestart <- base::invokeRestart
[17:36:40.232]                       is.null <- base::is.null
[17:36:40.232]                       muffled <- FALSE
[17:36:40.232]                       if (inherits(cond, "message")) {
[17:36:40.232]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.232]                         if (muffled) 
[17:36:40.232]                           invokeRestart("muffleMessage")
[17:36:40.232]                       }
[17:36:40.232]                       else if (inherits(cond, "warning")) {
[17:36:40.232]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.232]                         if (muffled) 
[17:36:40.232]                           invokeRestart("muffleWarning")
[17:36:40.232]                       }
[17:36:40.232]                       else if (inherits(cond, "condition")) {
[17:36:40.232]                         if (!is.null(pattern)) {
[17:36:40.232]                           computeRestarts <- base::computeRestarts
[17:36:40.232]                           grepl <- base::grepl
[17:36:40.232]                           restarts <- computeRestarts(cond)
[17:36:40.232]                           for (restart in restarts) {
[17:36:40.232]                             name <- restart$name
[17:36:40.232]                             if (is.null(name)) 
[17:36:40.232]                               next
[17:36:40.232]                             if (!grepl(pattern, name)) 
[17:36:40.232]                               next
[17:36:40.232]                             invokeRestart(restart)
[17:36:40.232]                             muffled <- TRUE
[17:36:40.232]                             break
[17:36:40.232]                           }
[17:36:40.232]                         }
[17:36:40.232]                       }
[17:36:40.232]                       invisible(muffled)
[17:36:40.232]                     }
[17:36:40.232]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.232]                   }
[17:36:40.232]                 }
[17:36:40.232]             }
[17:36:40.232]         }))
[17:36:40.232]     }, error = function(ex) {
[17:36:40.232]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.232]                 ...future.rng), started = ...future.startTime, 
[17:36:40.232]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.232]             version = "1.8"), class = "FutureResult")
[17:36:40.232]     }, finally = {
[17:36:40.232]         if (!identical(...future.workdir, getwd())) 
[17:36:40.232]             setwd(...future.workdir)
[17:36:40.232]         {
[17:36:40.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.232]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.232]             }
[17:36:40.232]             base::options(...future.oldOptions)
[17:36:40.232]             if (.Platform$OS.type == "windows") {
[17:36:40.232]                 old_names <- names(...future.oldEnvVars)
[17:36:40.232]                 envs <- base::Sys.getenv()
[17:36:40.232]                 names <- names(envs)
[17:36:40.232]                 common <- intersect(names, old_names)
[17:36:40.232]                 added <- setdiff(names, old_names)
[17:36:40.232]                 removed <- setdiff(old_names, names)
[17:36:40.232]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.232]                   envs[common]]
[17:36:40.232]                 NAMES <- toupper(changed)
[17:36:40.232]                 args <- list()
[17:36:40.232]                 for (kk in seq_along(NAMES)) {
[17:36:40.232]                   name <- changed[[kk]]
[17:36:40.232]                   NAME <- NAMES[[kk]]
[17:36:40.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.232]                     next
[17:36:40.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.232]                 }
[17:36:40.232]                 NAMES <- toupper(added)
[17:36:40.232]                 for (kk in seq_along(NAMES)) {
[17:36:40.232]                   name <- added[[kk]]
[17:36:40.232]                   NAME <- NAMES[[kk]]
[17:36:40.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.232]                     next
[17:36:40.232]                   args[[name]] <- ""
[17:36:40.232]                 }
[17:36:40.232]                 NAMES <- toupper(removed)
[17:36:40.232]                 for (kk in seq_along(NAMES)) {
[17:36:40.232]                   name <- removed[[kk]]
[17:36:40.232]                   NAME <- NAMES[[kk]]
[17:36:40.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.232]                     next
[17:36:40.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.232]                 }
[17:36:40.232]                 if (length(args) > 0) 
[17:36:40.232]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.232]             }
[17:36:40.232]             else {
[17:36:40.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.232]             }
[17:36:40.232]             {
[17:36:40.232]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.232]                   0L) {
[17:36:40.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.232]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.232]                   base::options(opts)
[17:36:40.232]                 }
[17:36:40.232]                 {
[17:36:40.232]                   {
[17:36:40.232]                     NULL
[17:36:40.232]                     RNGkind("Mersenne-Twister")
[17:36:40.232]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:40.232]                       inherits = FALSE)
[17:36:40.232]                   }
[17:36:40.232]                   options(future.plan = NULL)
[17:36:40.232]                   if (is.na(NA_character_)) 
[17:36:40.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.232]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.232]                     .init = FALSE)
[17:36:40.232]                 }
[17:36:40.232]             }
[17:36:40.232]         }
[17:36:40.232]     })
[17:36:40.232]     if (TRUE) {
[17:36:40.232]         base::sink(type = "output", split = FALSE)
[17:36:40.232]         if (TRUE) {
[17:36:40.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.232]         }
[17:36:40.232]         else {
[17:36:40.232]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.232]         }
[17:36:40.232]         base::close(...future.stdout)
[17:36:40.232]         ...future.stdout <- NULL
[17:36:40.232]     }
[17:36:40.232]     ...future.result$conditions <- ...future.conditions
[17:36:40.232]     ...future.result$finished <- base::Sys.time()
[17:36:40.232]     ...future.result
[17:36:40.232] }
[17:36:40.233] assign_globals() ...
[17:36:40.233] List of 5
[17:36:40.233]  $ ...future.FUN            :function (object, ...)  
[17:36:40.233]  $ future.call.arguments    : list()
[17:36:40.233]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.233]  $ ...future.elements_ii    :List of 3
[17:36:40.233]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:40.233]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.233]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.233]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:40.233]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.233]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.233]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:40.233]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.233]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.233]  $ ...future.seeds_ii       : NULL
[17:36:40.233]  $ ...future.globals.maxSize: NULL
[17:36:40.233]  - attr(*, "where")=List of 5
[17:36:40.233]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.233]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.233]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.233]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.233]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.233]  - attr(*, "resolved")= logi FALSE
[17:36:40.233]  - attr(*, "total_size")= num 1240
[17:36:40.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.233]  - attr(*, "already-done")= logi TRUE
[17:36:40.243] - copied ‘...future.FUN’ to environment
[17:36:40.243] - copied ‘future.call.arguments’ to environment
[17:36:40.244] - copied ‘...future.elements_ii’ to environment
[17:36:40.244] - copied ‘...future.seeds_ii’ to environment
[17:36:40.244] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.244] assign_globals() ... done
[17:36:40.244] plan(): Setting new future strategy stack:
[17:36:40.244] List of future strategies:
[17:36:40.244] 1. sequential:
[17:36:40.244]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.244]    - tweaked: FALSE
[17:36:40.244]    - call: NULL
[17:36:40.245] plan(): nbrOfWorkers() = 1
[17:36:40.247] plan(): Setting new future strategy stack:
[17:36:40.247] List of future strategies:
[17:36:40.247] 1. sequential:
[17:36:40.247]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.247]    - tweaked: FALSE
[17:36:40.247]    - call: plan(strategy)
[17:36:40.247] plan(): nbrOfWorkers() = 1
[17:36:40.248] SequentialFuture started (and completed)
[17:36:40.248] - Launch lazy future ... done
[17:36:40.248] run() for ‘SequentialFuture’ ... done
[17:36:40.248] Created future:
[17:36:40.248] SequentialFuture:
[17:36:40.248] Label: ‘future_by-1’
[17:36:40.248] Expression:
[17:36:40.248] {
[17:36:40.248]     do.call(function(...) {
[17:36:40.248]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.248]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.248]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.248]             on.exit(options(oopts), add = TRUE)
[17:36:40.248]         }
[17:36:40.248]         {
[17:36:40.248]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.248]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.248]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.248]             })
[17:36:40.248]         }
[17:36:40.248]     }, args = future.call.arguments)
[17:36:40.248] }
[17:36:40.248] Lazy evaluation: FALSE
[17:36:40.248] Asynchronous evaluation: FALSE
[17:36:40.248] Local evaluation: TRUE
[17:36:40.248] Environment: R_GlobalEnv
[17:36:40.248] Capture standard output: TRUE
[17:36:40.248] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.248] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.248] Packages: <none>
[17:36:40.248] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.248] Resolved: TRUE
[17:36:40.248] Value: 4.62 KiB of class ‘list’
[17:36:40.248] Early signaling: FALSE
[17:36:40.248] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.248] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.249] Chunk #1 of 1 ... DONE
[17:36:40.249] Launching 1 futures (chunks) ... DONE
[17:36:40.249] Resolving 1 futures (chunks) ...
[17:36:40.249] resolve() on list ...
[17:36:40.250]  recursive: 0
[17:36:40.250]  length: 1
[17:36:40.250] 
[17:36:40.250] resolved() for ‘SequentialFuture’ ...
[17:36:40.250] - state: ‘finished’
[17:36:40.250] - run: TRUE
[17:36:40.250] - result: ‘FutureResult’
[17:36:40.250] resolved() for ‘SequentialFuture’ ... done
[17:36:40.250] Future #1
[17:36:40.250] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:40.251] - nx: 1
[17:36:40.251] - relay: TRUE
[17:36:40.251] - stdout: TRUE
[17:36:40.251] - signal: TRUE
[17:36:40.251] - resignal: FALSE
[17:36:40.251] - force: TRUE
[17:36:40.251] - relayed: [n=1] FALSE
[17:36:40.251] - queued futures: [n=1] FALSE
[17:36:40.251]  - until=1
[17:36:40.251]  - relaying element #1
[17:36:40.251] - relayed: [n=1] TRUE
[17:36:40.252] - queued futures: [n=1] TRUE
[17:36:40.252] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:40.252]  length: 0 (resolved future 1)
[17:36:40.252] Relaying remaining futures
[17:36:40.252] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.252] - nx: 1
[17:36:40.252] - relay: TRUE
[17:36:40.252] - stdout: TRUE
[17:36:40.252] - signal: TRUE
[17:36:40.252] - resignal: FALSE
[17:36:40.252] - force: TRUE
[17:36:40.253] - relayed: [n=1] TRUE
[17:36:40.253] - queued futures: [n=1] TRUE
 - flush all
[17:36:40.253] - relayed: [n=1] TRUE
[17:36:40.253] - queued futures: [n=1] TRUE
[17:36:40.253] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.253] resolve() on list ... DONE
[17:36:40.253]  - Number of value chunks collected: 1
[17:36:40.253] Resolving 1 futures (chunks) ... DONE
[17:36:40.253] Reducing values from 1 chunks ...
[17:36:40.253]  - Number of values collected after concatenation: 3
[17:36:40.254]  - Number of values expected: 3
[17:36:40.254] Reducing values from 1 chunks ... DONE
[17:36:40.254] future_lapply() ... DONE
[17:36:40.254] future_by_internal() ... DONE
[17:36:40.254] future_by_internal() ...
[17:36:40.254] future_lapply() ...
[17:36:40.255] Number of chunks: 1
[17:36:40.255] getGlobalsAndPackagesXApply() ...
[17:36:40.255]  - future.globals: TRUE
[17:36:40.255] getGlobalsAndPackages() ...
[17:36:40.255] Searching for globals...
[17:36:40.256] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:40.256] Searching for globals ... DONE
[17:36:40.256] Resolving globals: FALSE
[17:36:40.257] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:40.257] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:40.257] - globals: [1] ‘FUN’
[17:36:40.257] 
[17:36:40.257] getGlobalsAndPackages() ... DONE
[17:36:40.258]  - globals found/used: [n=1] ‘FUN’
[17:36:40.258]  - needed namespaces: [n=0] 
[17:36:40.258] Finding globals ... DONE
[17:36:40.258]  - use_args: TRUE
[17:36:40.258]  - Getting '...' globals ...
[17:36:40.258] resolve() on list ...
[17:36:40.258]  recursive: 0
[17:36:40.258]  length: 1
[17:36:40.258]  elements: ‘...’
[17:36:40.259]  length: 0 (resolved future 1)
[17:36:40.259] resolve() on list ... DONE
[17:36:40.259]    - '...' content: [n=1] ‘digits’
[17:36:40.259] List of 1
[17:36:40.259]  $ ...:List of 1
[17:36:40.259]   ..$ digits: int 2
[17:36:40.259]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.259]  - attr(*, "where")=List of 1
[17:36:40.259]   ..$ ...:<environment: 0x5622fbd4b220> 
[17:36:40.259]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.259]  - attr(*, "resolved")= logi TRUE
[17:36:40.259]  - attr(*, "total_size")= num NA
[17:36:40.262]  - Getting '...' globals ... DONE
[17:36:40.262] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:40.262] List of 2
[17:36:40.262]  $ ...future.FUN:function (object, ...)  
[17:36:40.262]  $ ...          :List of 1
[17:36:40.262]   ..$ digits: int 2
[17:36:40.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.262]  - attr(*, "where")=List of 2
[17:36:40.262]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.262]   ..$ ...          :<environment: 0x5622fbd4b220> 
[17:36:40.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.262]  - attr(*, "resolved")= logi FALSE
[17:36:40.262]  - attr(*, "total_size")= num 1296
[17:36:40.266] Packages to be attached in all futures: [n=0] 
[17:36:40.266] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.267] Number of futures (= number of chunks): 1
[17:36:40.267] Launching 1 futures (chunks) ...
[17:36:40.267] Chunk #1 of 1 ...
[17:36:40.267]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.267] getGlobalsAndPackages() ...
[17:36:40.267] Searching for globals...
[17:36:40.267] 
[17:36:40.268] Searching for globals ... DONE
[17:36:40.268] - globals: [0] <none>
[17:36:40.268] getGlobalsAndPackages() ... DONE
[17:36:40.268]    + additional globals found: [n=0] 
[17:36:40.268]    + additional namespaces needed: [n=0] 
[17:36:40.268]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.268]  - seeds: <none>
[17:36:40.268]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.268] getGlobalsAndPackages() ...
[17:36:40.268] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.269] Resolving globals: FALSE
[17:36:40.269] Tweak future expression to call with '...' arguments ...
[17:36:40.269] {
[17:36:40.269]     do.call(function(...) {
[17:36:40.269]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.269]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.269]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.269]             on.exit(options(oopts), add = TRUE)
[17:36:40.269]         }
[17:36:40.269]         {
[17:36:40.269]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.269]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.269]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.269]             })
[17:36:40.269]         }
[17:36:40.269]     }, args = future.call.arguments)
[17:36:40.269] }
[17:36:40.269] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.269] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.269] 
[17:36:40.270] getGlobalsAndPackages() ... DONE
[17:36:40.270] run() for ‘Future’ ...
[17:36:40.270] - state: ‘created’
[17:36:40.270] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:40.270] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.270] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:40.271]   - Field: ‘label’
[17:36:40.271]   - Field: ‘local’
[17:36:40.271]   - Field: ‘owner’
[17:36:40.271]   - Field: ‘envir’
[17:36:40.271]   - Field: ‘packages’
[17:36:40.271]   - Field: ‘gc’
[17:36:40.271]   - Field: ‘conditions’
[17:36:40.271]   - Field: ‘expr’
[17:36:40.271]   - Field: ‘uuid’
[17:36:40.271]   - Field: ‘seed’
[17:36:40.271]   - Field: ‘version’
[17:36:40.272]   - Field: ‘result’
[17:36:40.272]   - Field: ‘asynchronous’
[17:36:40.272]   - Field: ‘calls’
[17:36:40.272]   - Field: ‘globals’
[17:36:40.272]   - Field: ‘stdout’
[17:36:40.272]   - Field: ‘earlySignal’
[17:36:40.272]   - Field: ‘lazy’
[17:36:40.272]   - Field: ‘state’
[17:36:40.272] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:40.272] - Launch lazy future ...
[17:36:40.273] Packages needed by the future expression (n = 0): <none>
[17:36:40.273] Packages needed by future strategies (n = 0): <none>
[17:36:40.273] {
[17:36:40.273]     {
[17:36:40.273]         {
[17:36:40.273]             ...future.startTime <- base::Sys.time()
[17:36:40.273]             {
[17:36:40.273]                 {
[17:36:40.273]                   {
[17:36:40.273]                     base::local({
[17:36:40.273]                       has_future <- base::requireNamespace("future", 
[17:36:40.273]                         quietly = TRUE)
[17:36:40.273]                       if (has_future) {
[17:36:40.273]                         ns <- base::getNamespace("future")
[17:36:40.273]                         version <- ns[[".package"]][["version"]]
[17:36:40.273]                         if (is.null(version)) 
[17:36:40.273]                           version <- utils::packageVersion("future")
[17:36:40.273]                       }
[17:36:40.273]                       else {
[17:36:40.273]                         version <- NULL
[17:36:40.273]                       }
[17:36:40.273]                       if (!has_future || version < "1.8.0") {
[17:36:40.273]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.273]                           "", base::R.version$version.string), 
[17:36:40.273]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:40.273]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.273]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.273]                             "release", "version")], collapse = " "), 
[17:36:40.273]                           hostname = base::Sys.info()[["nodename"]])
[17:36:40.273]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.273]                           info)
[17:36:40.273]                         info <- base::paste(info, collapse = "; ")
[17:36:40.273]                         if (!has_future) {
[17:36:40.273]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.273]                             info)
[17:36:40.273]                         }
[17:36:40.273]                         else {
[17:36:40.273]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.273]                             info, version)
[17:36:40.273]                         }
[17:36:40.273]                         base::stop(msg)
[17:36:40.273]                       }
[17:36:40.273]                     })
[17:36:40.273]                   }
[17:36:40.273]                   ...future.strategy.old <- future::plan("list")
[17:36:40.273]                   options(future.plan = NULL)
[17:36:40.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.273]                 }
[17:36:40.273]                 ...future.workdir <- getwd()
[17:36:40.273]             }
[17:36:40.273]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.273]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.273]         }
[17:36:40.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.273]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:40.273]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.273]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.273]             base::names(...future.oldOptions))
[17:36:40.273]     }
[17:36:40.273]     if (FALSE) {
[17:36:40.273]     }
[17:36:40.273]     else {
[17:36:40.273]         if (TRUE) {
[17:36:40.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.273]                 open = "w")
[17:36:40.273]         }
[17:36:40.273]         else {
[17:36:40.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.273]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.273]         }
[17:36:40.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.273]             base::sink(type = "output", split = FALSE)
[17:36:40.273]             base::close(...future.stdout)
[17:36:40.273]         }, add = TRUE)
[17:36:40.273]     }
[17:36:40.273]     ...future.frame <- base::sys.nframe()
[17:36:40.273]     ...future.conditions <- base::list()
[17:36:40.273]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.273]     if (FALSE) {
[17:36:40.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.273]     }
[17:36:40.273]     ...future.result <- base::tryCatch({
[17:36:40.273]         base::withCallingHandlers({
[17:36:40.273]             ...future.value <- base::withVisible(base::local({
[17:36:40.273]                 do.call(function(...) {
[17:36:40.273]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.273]                   if (!identical(...future.globals.maxSize.org, 
[17:36:40.273]                     ...future.globals.maxSize)) {
[17:36:40.273]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.273]                     on.exit(options(oopts), add = TRUE)
[17:36:40.273]                   }
[17:36:40.273]                   {
[17:36:40.273]                     lapply(seq_along(...future.elements_ii), 
[17:36:40.273]                       FUN = function(jj) {
[17:36:40.273]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.273]                         ...future.FUN(...future.X_jj, ...)
[17:36:40.273]                       })
[17:36:40.273]                   }
[17:36:40.273]                 }, args = future.call.arguments)
[17:36:40.273]             }))
[17:36:40.273]             future::FutureResult(value = ...future.value$value, 
[17:36:40.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.273]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.273]                     ...future.globalenv.names))
[17:36:40.273]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.273]         }, condition = base::local({
[17:36:40.273]             c <- base::c
[17:36:40.273]             inherits <- base::inherits
[17:36:40.273]             invokeRestart <- base::invokeRestart
[17:36:40.273]             length <- base::length
[17:36:40.273]             list <- base::list
[17:36:40.273]             seq.int <- base::seq.int
[17:36:40.273]             signalCondition <- base::signalCondition
[17:36:40.273]             sys.calls <- base::sys.calls
[17:36:40.273]             `[[` <- base::`[[`
[17:36:40.273]             `+` <- base::`+`
[17:36:40.273]             `<<-` <- base::`<<-`
[17:36:40.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.273]                   3L)]
[17:36:40.273]             }
[17:36:40.273]             function(cond) {
[17:36:40.273]                 is_error <- inherits(cond, "error")
[17:36:40.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.273]                   NULL)
[17:36:40.273]                 if (is_error) {
[17:36:40.273]                   sessionInformation <- function() {
[17:36:40.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.273]                       search = base::search(), system = base::Sys.info())
[17:36:40.273]                   }
[17:36:40.273]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.273]                     cond$call), session = sessionInformation(), 
[17:36:40.273]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.273]                   signalCondition(cond)
[17:36:40.273]                 }
[17:36:40.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.273]                 "immediateCondition"))) {
[17:36:40.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.273]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.273]                   if (TRUE && !signal) {
[17:36:40.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.273]                     {
[17:36:40.273]                       inherits <- base::inherits
[17:36:40.273]                       invokeRestart <- base::invokeRestart
[17:36:40.273]                       is.null <- base::is.null
[17:36:40.273]                       muffled <- FALSE
[17:36:40.273]                       if (inherits(cond, "message")) {
[17:36:40.273]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.273]                         if (muffled) 
[17:36:40.273]                           invokeRestart("muffleMessage")
[17:36:40.273]                       }
[17:36:40.273]                       else if (inherits(cond, "warning")) {
[17:36:40.273]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.273]                         if (muffled) 
[17:36:40.273]                           invokeRestart("muffleWarning")
[17:36:40.273]                       }
[17:36:40.273]                       else if (inherits(cond, "condition")) {
[17:36:40.273]                         if (!is.null(pattern)) {
[17:36:40.273]                           computeRestarts <- base::computeRestarts
[17:36:40.273]                           grepl <- base::grepl
[17:36:40.273]                           restarts <- computeRestarts(cond)
[17:36:40.273]                           for (restart in restarts) {
[17:36:40.273]                             name <- restart$name
[17:36:40.273]                             if (is.null(name)) 
[17:36:40.273]                               next
[17:36:40.273]                             if (!grepl(pattern, name)) 
[17:36:40.273]                               next
[17:36:40.273]                             invokeRestart(restart)
[17:36:40.273]                             muffled <- TRUE
[17:36:40.273]                             break
[17:36:40.273]                           }
[17:36:40.273]                         }
[17:36:40.273]                       }
[17:36:40.273]                       invisible(muffled)
[17:36:40.273]                     }
[17:36:40.273]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.273]                   }
[17:36:40.273]                 }
[17:36:40.273]                 else {
[17:36:40.273]                   if (TRUE) {
[17:36:40.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.273]                     {
[17:36:40.273]                       inherits <- base::inherits
[17:36:40.273]                       invokeRestart <- base::invokeRestart
[17:36:40.273]                       is.null <- base::is.null
[17:36:40.273]                       muffled <- FALSE
[17:36:40.273]                       if (inherits(cond, "message")) {
[17:36:40.273]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.273]                         if (muffled) 
[17:36:40.273]                           invokeRestart("muffleMessage")
[17:36:40.273]                       }
[17:36:40.273]                       else if (inherits(cond, "warning")) {
[17:36:40.273]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.273]                         if (muffled) 
[17:36:40.273]                           invokeRestart("muffleWarning")
[17:36:40.273]                       }
[17:36:40.273]                       else if (inherits(cond, "condition")) {
[17:36:40.273]                         if (!is.null(pattern)) {
[17:36:40.273]                           computeRestarts <- base::computeRestarts
[17:36:40.273]                           grepl <- base::grepl
[17:36:40.273]                           restarts <- computeRestarts(cond)
[17:36:40.273]                           for (restart in restarts) {
[17:36:40.273]                             name <- restart$name
[17:36:40.273]                             if (is.null(name)) 
[17:36:40.273]                               next
[17:36:40.273]                             if (!grepl(pattern, name)) 
[17:36:40.273]                               next
[17:36:40.273]                             invokeRestart(restart)
[17:36:40.273]                             muffled <- TRUE
[17:36:40.273]                             break
[17:36:40.273]                           }
[17:36:40.273]                         }
[17:36:40.273]                       }
[17:36:40.273]                       invisible(muffled)
[17:36:40.273]                     }
[17:36:40.273]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.273]                   }
[17:36:40.273]                 }
[17:36:40.273]             }
[17:36:40.273]         }))
[17:36:40.273]     }, error = function(ex) {
[17:36:40.273]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.273]                 ...future.rng), started = ...future.startTime, 
[17:36:40.273]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.273]             version = "1.8"), class = "FutureResult")
[17:36:40.273]     }, finally = {
[17:36:40.273]         if (!identical(...future.workdir, getwd())) 
[17:36:40.273]             setwd(...future.workdir)
[17:36:40.273]         {
[17:36:40.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.273]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.273]             }
[17:36:40.273]             base::options(...future.oldOptions)
[17:36:40.273]             if (.Platform$OS.type == "windows") {
[17:36:40.273]                 old_names <- names(...future.oldEnvVars)
[17:36:40.273]                 envs <- base::Sys.getenv()
[17:36:40.273]                 names <- names(envs)
[17:36:40.273]                 common <- intersect(names, old_names)
[17:36:40.273]                 added <- setdiff(names, old_names)
[17:36:40.273]                 removed <- setdiff(old_names, names)
[17:36:40.273]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.273]                   envs[common]]
[17:36:40.273]                 NAMES <- toupper(changed)
[17:36:40.273]                 args <- list()
[17:36:40.273]                 for (kk in seq_along(NAMES)) {
[17:36:40.273]                   name <- changed[[kk]]
[17:36:40.273]                   NAME <- NAMES[[kk]]
[17:36:40.273]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.273]                     next
[17:36:40.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.273]                 }
[17:36:40.273]                 NAMES <- toupper(added)
[17:36:40.273]                 for (kk in seq_along(NAMES)) {
[17:36:40.273]                   name <- added[[kk]]
[17:36:40.273]                   NAME <- NAMES[[kk]]
[17:36:40.273]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.273]                     next
[17:36:40.273]                   args[[name]] <- ""
[17:36:40.273]                 }
[17:36:40.273]                 NAMES <- toupper(removed)
[17:36:40.273]                 for (kk in seq_along(NAMES)) {
[17:36:40.273]                   name <- removed[[kk]]
[17:36:40.273]                   NAME <- NAMES[[kk]]
[17:36:40.273]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.273]                     next
[17:36:40.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.273]                 }
[17:36:40.273]                 if (length(args) > 0) 
[17:36:40.273]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.273]             }
[17:36:40.273]             else {
[17:36:40.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.273]             }
[17:36:40.273]             {
[17:36:40.273]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.273]                   0L) {
[17:36:40.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.273]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.273]                   base::options(opts)
[17:36:40.273]                 }
[17:36:40.273]                 {
[17:36:40.273]                   {
[17:36:40.273]                     NULL
[17:36:40.273]                     RNGkind("Mersenne-Twister")
[17:36:40.273]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:40.273]                       inherits = FALSE)
[17:36:40.273]                   }
[17:36:40.273]                   options(future.plan = NULL)
[17:36:40.273]                   if (is.na(NA_character_)) 
[17:36:40.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.273]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.273]                     .init = FALSE)
[17:36:40.273]                 }
[17:36:40.273]             }
[17:36:40.273]         }
[17:36:40.273]     })
[17:36:40.273]     if (TRUE) {
[17:36:40.273]         base::sink(type = "output", split = FALSE)
[17:36:40.273]         if (TRUE) {
[17:36:40.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.273]         }
[17:36:40.273]         else {
[17:36:40.273]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.273]         }
[17:36:40.273]         base::close(...future.stdout)
[17:36:40.273]         ...future.stdout <- NULL
[17:36:40.273]     }
[17:36:40.273]     ...future.result$conditions <- ...future.conditions
[17:36:40.273]     ...future.result$finished <- base::Sys.time()
[17:36:40.273]     ...future.result
[17:36:40.273] }
[17:36:40.275] assign_globals() ...
[17:36:40.275] List of 5
[17:36:40.275]  $ ...future.FUN            :function (object, ...)  
[17:36:40.275]  $ future.call.arguments    :List of 1
[17:36:40.275]   ..$ digits: int 2
[17:36:40.275]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.275]  $ ...future.elements_ii    :List of 6
[17:36:40.275]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:36:40.275]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:36:40.275]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:36:40.275]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:36:40.275]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:36:40.275]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:36:40.275]  $ ...future.seeds_ii       : NULL
[17:36:40.275]  $ ...future.globals.maxSize: NULL
[17:36:40.275]  - attr(*, "where")=List of 5
[17:36:40.275]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.275]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.275]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.275]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.275]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.275]  - attr(*, "resolved")= logi FALSE
[17:36:40.275]  - attr(*, "total_size")= num 1296
[17:36:40.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.275]  - attr(*, "already-done")= logi TRUE
[17:36:40.281] - copied ‘...future.FUN’ to environment
[17:36:40.281] - copied ‘future.call.arguments’ to environment
[17:36:40.281] - copied ‘...future.elements_ii’ to environment
[17:36:40.281] - copied ‘...future.seeds_ii’ to environment
[17:36:40.281] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.282] assign_globals() ... done
[17:36:40.282] plan(): Setting new future strategy stack:
[17:36:40.282] List of future strategies:
[17:36:40.282] 1. sequential:
[17:36:40.282]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.282]    - tweaked: FALSE
[17:36:40.282]    - call: NULL
[17:36:40.282] plan(): nbrOfWorkers() = 1
[17:36:40.284] plan(): Setting new future strategy stack:
[17:36:40.284] List of future strategies:
[17:36:40.284] 1. sequential:
[17:36:40.284]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.284]    - tweaked: FALSE
[17:36:40.284]    - call: plan(strategy)
[17:36:40.284] plan(): nbrOfWorkers() = 1
[17:36:40.284] SequentialFuture started (and completed)
[17:36:40.284] - Launch lazy future ... done
[17:36:40.285] run() for ‘SequentialFuture’ ... done
[17:36:40.285] Created future:
[17:36:40.285] SequentialFuture:
[17:36:40.285] Label: ‘future_by-1’
[17:36:40.285] Expression:
[17:36:40.285] {
[17:36:40.285]     do.call(function(...) {
[17:36:40.285]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.285]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.285]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.285]             on.exit(options(oopts), add = TRUE)
[17:36:40.285]         }
[17:36:40.285]         {
[17:36:40.285]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.285]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.285]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.285]             })
[17:36:40.285]         }
[17:36:40.285]     }, args = future.call.arguments)
[17:36:40.285] }
[17:36:40.285] Lazy evaluation: FALSE
[17:36:40.285] Asynchronous evaluation: FALSE
[17:36:40.285] Local evaluation: TRUE
[17:36:40.285] Environment: R_GlobalEnv
[17:36:40.285] Capture standard output: TRUE
[17:36:40.285] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.285] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.285] Packages: <none>
[17:36:40.285] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.285] Resolved: TRUE
[17:36:40.285] Value: 5.48 KiB of class ‘list’
[17:36:40.285] Early signaling: FALSE
[17:36:40.285] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.285] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.286] Chunk #1 of 1 ... DONE
[17:36:40.286] Launching 1 futures (chunks) ... DONE
[17:36:40.286] Resolving 1 futures (chunks) ...
[17:36:40.286] resolve() on list ...
[17:36:40.286]  recursive: 0
[17:36:40.286]  length: 1
[17:36:40.286] 
[17:36:40.286] resolved() for ‘SequentialFuture’ ...
[17:36:40.287] - state: ‘finished’
[17:36:40.287] - run: TRUE
[17:36:40.288] - result: ‘FutureResult’
[17:36:40.288] resolved() for ‘SequentialFuture’ ... done
[17:36:40.288] Future #1
[17:36:40.289] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:40.289] - nx: 1
[17:36:40.289] - relay: TRUE
[17:36:40.289] - stdout: TRUE
[17:36:40.289] - signal: TRUE
[17:36:40.289] - resignal: FALSE
[17:36:40.289] - force: TRUE
[17:36:40.289] - relayed: [n=1] FALSE
[17:36:40.289] - queued futures: [n=1] FALSE
[17:36:40.289]  - until=1
[17:36:40.290]  - relaying element #1
[17:36:40.290] - relayed: [n=1] TRUE
[17:36:40.290] - queued futures: [n=1] TRUE
[17:36:40.290] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:40.290]  length: 0 (resolved future 1)
[17:36:40.290] Relaying remaining futures
[17:36:40.290] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.290] - nx: 1
[17:36:40.290] - relay: TRUE
[17:36:40.291] - stdout: TRUE
[17:36:40.291] - signal: TRUE
[17:36:40.291] - resignal: FALSE
[17:36:40.291] - force: TRUE
[17:36:40.291] - relayed: [n=1] TRUE
[17:36:40.291] - queued futures: [n=1] TRUE
 - flush all
[17:36:40.291] - relayed: [n=1] TRUE
[17:36:40.291] - queued futures: [n=1] TRUE
[17:36:40.291] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.291] resolve() on list ... DONE
[17:36:40.292]  - Number of value chunks collected: 1
[17:36:40.292] Resolving 1 futures (chunks) ... DONE
[17:36:40.292] Reducing values from 1 chunks ...
[17:36:40.292]  - Number of values collected after concatenation: 6
[17:36:40.292]  - Number of values expected: 6
[17:36:40.292] Reducing values from 1 chunks ... DONE
[17:36:40.292] future_lapply() ... DONE
[17:36:40.292] future_by_internal() ... DONE
[17:36:40.293] future_by_internal() ...
[17:36:40.294] future_lapply() ...
[17:36:40.295] Number of chunks: 1
[17:36:40.295] getGlobalsAndPackagesXApply() ...
[17:36:40.295]  - future.globals: TRUE
[17:36:40.295] getGlobalsAndPackages() ...
[17:36:40.295] Searching for globals...
[17:36:40.296] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:40.297] Searching for globals ... DONE
[17:36:40.297] Resolving globals: FALSE
[17:36:40.297] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:36:40.297] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:36:40.298] - globals: [1] ‘FUN’
[17:36:40.298] - packages: [1] ‘stats’
[17:36:40.298] getGlobalsAndPackages() ... DONE
[17:36:40.298]  - globals found/used: [n=1] ‘FUN’
[17:36:40.298]  - needed namespaces: [n=1] ‘stats’
[17:36:40.298] Finding globals ... DONE
[17:36:40.298]  - use_args: TRUE
[17:36:40.298]  - Getting '...' globals ...
[17:36:40.299] resolve() on list ...
[17:36:40.299]  recursive: 0
[17:36:40.299]  length: 1
[17:36:40.299]  elements: ‘...’
[17:36:40.299]  length: 0 (resolved future 1)
[17:36:40.299] resolve() on list ... DONE
[17:36:40.299]    - '...' content: [n=1] ‘singular.ok’
[17:36:40.299] List of 1
[17:36:40.299]  $ ...:List of 1
[17:36:40.299]   ..$ singular.ok: logi FALSE
[17:36:40.299]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.299]  - attr(*, "where")=List of 1
[17:36:40.299]   ..$ ...:<environment: 0x5622fb24b158> 
[17:36:40.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.299]  - attr(*, "resolved")= logi TRUE
[17:36:40.299]  - attr(*, "total_size")= num NA
[17:36:40.302]  - Getting '...' globals ... DONE
[17:36:40.302] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:40.302] List of 2
[17:36:40.302]  $ ...future.FUN:function (x, ...)  
[17:36:40.302]  $ ...          :List of 1
[17:36:40.302]   ..$ singular.ok: logi FALSE
[17:36:40.302]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.302]  - attr(*, "where")=List of 2
[17:36:40.302]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.302]   ..$ ...          :<environment: 0x5622fb24b158> 
[17:36:40.302]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.302]  - attr(*, "resolved")= logi FALSE
[17:36:40.302]  - attr(*, "total_size")= num 5384
[17:36:40.305] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:40.305] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.306] Number of futures (= number of chunks): 1
[17:36:40.306] Launching 1 futures (chunks) ...
[17:36:40.306] Chunk #1 of 1 ...
[17:36:40.306]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.306] getGlobalsAndPackages() ...
[17:36:40.306] Searching for globals...
[17:36:40.307] 
[17:36:40.307] Searching for globals ... DONE
[17:36:40.307] - globals: [0] <none>
[17:36:40.307] getGlobalsAndPackages() ... DONE
[17:36:40.307]    + additional globals found: [n=0] 
[17:36:40.307]    + additional namespaces needed: [n=0] 
[17:36:40.307]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.307]  - seeds: <none>
[17:36:40.307]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.307] getGlobalsAndPackages() ...
[17:36:40.307] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.308] Resolving globals: FALSE
[17:36:40.308] Tweak future expression to call with '...' arguments ...
[17:36:40.308] {
[17:36:40.308]     do.call(function(...) {
[17:36:40.308]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.308]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.308]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.308]             on.exit(options(oopts), add = TRUE)
[17:36:40.308]         }
[17:36:40.308]         {
[17:36:40.308]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.308]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.308]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.308]             })
[17:36:40.308]         }
[17:36:40.308]     }, args = future.call.arguments)
[17:36:40.308] }
[17:36:40.309] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.310] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.310] 
[17:36:40.310] getGlobalsAndPackages() ... DONE
[17:36:40.310] run() for ‘Future’ ...
[17:36:40.310] - state: ‘created’
[17:36:40.311] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:40.311] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:40.311]   - Field: ‘label’
[17:36:40.311]   - Field: ‘local’
[17:36:40.311]   - Field: ‘owner’
[17:36:40.311]   - Field: ‘envir’
[17:36:40.311]   - Field: ‘packages’
[17:36:40.312]   - Field: ‘gc’
[17:36:40.312]   - Field: ‘conditions’
[17:36:40.312]   - Field: ‘expr’
[17:36:40.312]   - Field: ‘uuid’
[17:36:40.312]   - Field: ‘seed’
[17:36:40.312]   - Field: ‘version’
[17:36:40.312]   - Field: ‘result’
[17:36:40.312]   - Field: ‘asynchronous’
[17:36:40.312]   - Field: ‘calls’
[17:36:40.313]   - Field: ‘globals’
[17:36:40.313]   - Field: ‘stdout’
[17:36:40.313]   - Field: ‘earlySignal’
[17:36:40.313]   - Field: ‘lazy’
[17:36:40.313]   - Field: ‘state’
[17:36:40.313] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:40.313] - Launch lazy future ...
[17:36:40.313] Packages needed by the future expression (n = 1): ‘stats’
[17:36:40.313] Packages needed by future strategies (n = 0): <none>
[17:36:40.314] {
[17:36:40.314]     {
[17:36:40.314]         {
[17:36:40.314]             ...future.startTime <- base::Sys.time()
[17:36:40.314]             {
[17:36:40.314]                 {
[17:36:40.314]                   {
[17:36:40.314]                     {
[17:36:40.314]                       base::local({
[17:36:40.314]                         has_future <- base::requireNamespace("future", 
[17:36:40.314]                           quietly = TRUE)
[17:36:40.314]                         if (has_future) {
[17:36:40.314]                           ns <- base::getNamespace("future")
[17:36:40.314]                           version <- ns[[".package"]][["version"]]
[17:36:40.314]                           if (is.null(version)) 
[17:36:40.314]                             version <- utils::packageVersion("future")
[17:36:40.314]                         }
[17:36:40.314]                         else {
[17:36:40.314]                           version <- NULL
[17:36:40.314]                         }
[17:36:40.314]                         if (!has_future || version < "1.8.0") {
[17:36:40.314]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.314]                             "", base::R.version$version.string), 
[17:36:40.314]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:40.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.314]                               "release", "version")], collapse = " "), 
[17:36:40.314]                             hostname = base::Sys.info()[["nodename"]])
[17:36:40.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.314]                             info)
[17:36:40.314]                           info <- base::paste(info, collapse = "; ")
[17:36:40.314]                           if (!has_future) {
[17:36:40.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.314]                               info)
[17:36:40.314]                           }
[17:36:40.314]                           else {
[17:36:40.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.314]                               info, version)
[17:36:40.314]                           }
[17:36:40.314]                           base::stop(msg)
[17:36:40.314]                         }
[17:36:40.314]                       })
[17:36:40.314]                     }
[17:36:40.314]                     base::local({
[17:36:40.314]                       for (pkg in "stats") {
[17:36:40.314]                         base::loadNamespace(pkg)
[17:36:40.314]                         base::library(pkg, character.only = TRUE)
[17:36:40.314]                       }
[17:36:40.314]                     })
[17:36:40.314]                   }
[17:36:40.314]                   ...future.strategy.old <- future::plan("list")
[17:36:40.314]                   options(future.plan = NULL)
[17:36:40.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.314]                 }
[17:36:40.314]                 ...future.workdir <- getwd()
[17:36:40.314]             }
[17:36:40.314]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.314]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.314]         }
[17:36:40.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.314]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:40.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.314]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.314]             base::names(...future.oldOptions))
[17:36:40.314]     }
[17:36:40.314]     if (FALSE) {
[17:36:40.314]     }
[17:36:40.314]     else {
[17:36:40.314]         if (TRUE) {
[17:36:40.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.314]                 open = "w")
[17:36:40.314]         }
[17:36:40.314]         else {
[17:36:40.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.314]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.314]         }
[17:36:40.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.314]             base::sink(type = "output", split = FALSE)
[17:36:40.314]             base::close(...future.stdout)
[17:36:40.314]         }, add = TRUE)
[17:36:40.314]     }
[17:36:40.314]     ...future.frame <- base::sys.nframe()
[17:36:40.314]     ...future.conditions <- base::list()
[17:36:40.314]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.314]     if (FALSE) {
[17:36:40.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.314]     }
[17:36:40.314]     ...future.result <- base::tryCatch({
[17:36:40.314]         base::withCallingHandlers({
[17:36:40.314]             ...future.value <- base::withVisible(base::local({
[17:36:40.314]                 do.call(function(...) {
[17:36:40.314]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.314]                   if (!identical(...future.globals.maxSize.org, 
[17:36:40.314]                     ...future.globals.maxSize)) {
[17:36:40.314]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.314]                     on.exit(options(oopts), add = TRUE)
[17:36:40.314]                   }
[17:36:40.314]                   {
[17:36:40.314]                     lapply(seq_along(...future.elements_ii), 
[17:36:40.314]                       FUN = function(jj) {
[17:36:40.314]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.314]                         ...future.FUN(...future.X_jj, ...)
[17:36:40.314]                       })
[17:36:40.314]                   }
[17:36:40.314]                 }, args = future.call.arguments)
[17:36:40.314]             }))
[17:36:40.314]             future::FutureResult(value = ...future.value$value, 
[17:36:40.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.314]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.314]                     ...future.globalenv.names))
[17:36:40.314]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.314]         }, condition = base::local({
[17:36:40.314]             c <- base::c
[17:36:40.314]             inherits <- base::inherits
[17:36:40.314]             invokeRestart <- base::invokeRestart
[17:36:40.314]             length <- base::length
[17:36:40.314]             list <- base::list
[17:36:40.314]             seq.int <- base::seq.int
[17:36:40.314]             signalCondition <- base::signalCondition
[17:36:40.314]             sys.calls <- base::sys.calls
[17:36:40.314]             `[[` <- base::`[[`
[17:36:40.314]             `+` <- base::`+`
[17:36:40.314]             `<<-` <- base::`<<-`
[17:36:40.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.314]                   3L)]
[17:36:40.314]             }
[17:36:40.314]             function(cond) {
[17:36:40.314]                 is_error <- inherits(cond, "error")
[17:36:40.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.314]                   NULL)
[17:36:40.314]                 if (is_error) {
[17:36:40.314]                   sessionInformation <- function() {
[17:36:40.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.314]                       search = base::search(), system = base::Sys.info())
[17:36:40.314]                   }
[17:36:40.314]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.314]                     cond$call), session = sessionInformation(), 
[17:36:40.314]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.314]                   signalCondition(cond)
[17:36:40.314]                 }
[17:36:40.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.314]                 "immediateCondition"))) {
[17:36:40.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.314]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.314]                   if (TRUE && !signal) {
[17:36:40.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.314]                     {
[17:36:40.314]                       inherits <- base::inherits
[17:36:40.314]                       invokeRestart <- base::invokeRestart
[17:36:40.314]                       is.null <- base::is.null
[17:36:40.314]                       muffled <- FALSE
[17:36:40.314]                       if (inherits(cond, "message")) {
[17:36:40.314]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.314]                         if (muffled) 
[17:36:40.314]                           invokeRestart("muffleMessage")
[17:36:40.314]                       }
[17:36:40.314]                       else if (inherits(cond, "warning")) {
[17:36:40.314]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.314]                         if (muffled) 
[17:36:40.314]                           invokeRestart("muffleWarning")
[17:36:40.314]                       }
[17:36:40.314]                       else if (inherits(cond, "condition")) {
[17:36:40.314]                         if (!is.null(pattern)) {
[17:36:40.314]                           computeRestarts <- base::computeRestarts
[17:36:40.314]                           grepl <- base::grepl
[17:36:40.314]                           restarts <- computeRestarts(cond)
[17:36:40.314]                           for (restart in restarts) {
[17:36:40.314]                             name <- restart$name
[17:36:40.314]                             if (is.null(name)) 
[17:36:40.314]                               next
[17:36:40.314]                             if (!grepl(pattern, name)) 
[17:36:40.314]                               next
[17:36:40.314]                             invokeRestart(restart)
[17:36:40.314]                             muffled <- TRUE
[17:36:40.314]                             break
[17:36:40.314]                           }
[17:36:40.314]                         }
[17:36:40.314]                       }
[17:36:40.314]                       invisible(muffled)
[17:36:40.314]                     }
[17:36:40.314]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.314]                   }
[17:36:40.314]                 }
[17:36:40.314]                 else {
[17:36:40.314]                   if (TRUE) {
[17:36:40.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.314]                     {
[17:36:40.314]                       inherits <- base::inherits
[17:36:40.314]                       invokeRestart <- base::invokeRestart
[17:36:40.314]                       is.null <- base::is.null
[17:36:40.314]                       muffled <- FALSE
[17:36:40.314]                       if (inherits(cond, "message")) {
[17:36:40.314]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.314]                         if (muffled) 
[17:36:40.314]                           invokeRestart("muffleMessage")
[17:36:40.314]                       }
[17:36:40.314]                       else if (inherits(cond, "warning")) {
[17:36:40.314]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.314]                         if (muffled) 
[17:36:40.314]                           invokeRestart("muffleWarning")
[17:36:40.314]                       }
[17:36:40.314]                       else if (inherits(cond, "condition")) {
[17:36:40.314]                         if (!is.null(pattern)) {
[17:36:40.314]                           computeRestarts <- base::computeRestarts
[17:36:40.314]                           grepl <- base::grepl
[17:36:40.314]                           restarts <- computeRestarts(cond)
[17:36:40.314]                           for (restart in restarts) {
[17:36:40.314]                             name <- restart$name
[17:36:40.314]                             if (is.null(name)) 
[17:36:40.314]                               next
[17:36:40.314]                             if (!grepl(pattern, name)) 
[17:36:40.314]                               next
[17:36:40.314]                             invokeRestart(restart)
[17:36:40.314]                             muffled <- TRUE
[17:36:40.314]                             break
[17:36:40.314]                           }
[17:36:40.314]                         }
[17:36:40.314]                       }
[17:36:40.314]                       invisible(muffled)
[17:36:40.314]                     }
[17:36:40.314]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.314]                   }
[17:36:40.314]                 }
[17:36:40.314]             }
[17:36:40.314]         }))
[17:36:40.314]     }, error = function(ex) {
[17:36:40.314]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.314]                 ...future.rng), started = ...future.startTime, 
[17:36:40.314]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.314]             version = "1.8"), class = "FutureResult")
[17:36:40.314]     }, finally = {
[17:36:40.314]         if (!identical(...future.workdir, getwd())) 
[17:36:40.314]             setwd(...future.workdir)
[17:36:40.314]         {
[17:36:40.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.314]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.314]             }
[17:36:40.314]             base::options(...future.oldOptions)
[17:36:40.314]             if (.Platform$OS.type == "windows") {
[17:36:40.314]                 old_names <- names(...future.oldEnvVars)
[17:36:40.314]                 envs <- base::Sys.getenv()
[17:36:40.314]                 names <- names(envs)
[17:36:40.314]                 common <- intersect(names, old_names)
[17:36:40.314]                 added <- setdiff(names, old_names)
[17:36:40.314]                 removed <- setdiff(old_names, names)
[17:36:40.314]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.314]                   envs[common]]
[17:36:40.314]                 NAMES <- toupper(changed)
[17:36:40.314]                 args <- list()
[17:36:40.314]                 for (kk in seq_along(NAMES)) {
[17:36:40.314]                   name <- changed[[kk]]
[17:36:40.314]                   NAME <- NAMES[[kk]]
[17:36:40.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.314]                     next
[17:36:40.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.314]                 }
[17:36:40.314]                 NAMES <- toupper(added)
[17:36:40.314]                 for (kk in seq_along(NAMES)) {
[17:36:40.314]                   name <- added[[kk]]
[17:36:40.314]                   NAME <- NAMES[[kk]]
[17:36:40.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.314]                     next
[17:36:40.314]                   args[[name]] <- ""
[17:36:40.314]                 }
[17:36:40.314]                 NAMES <- toupper(removed)
[17:36:40.314]                 for (kk in seq_along(NAMES)) {
[17:36:40.314]                   name <- removed[[kk]]
[17:36:40.314]                   NAME <- NAMES[[kk]]
[17:36:40.314]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.314]                     next
[17:36:40.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.314]                 }
[17:36:40.314]                 if (length(args) > 0) 
[17:36:40.314]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.314]             }
[17:36:40.314]             else {
[17:36:40.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.314]             }
[17:36:40.314]             {
[17:36:40.314]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.314]                   0L) {
[17:36:40.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.314]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.314]                   base::options(opts)
[17:36:40.314]                 }
[17:36:40.314]                 {
[17:36:40.314]                   {
[17:36:40.314]                     NULL
[17:36:40.314]                     RNGkind("Mersenne-Twister")
[17:36:40.314]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:40.314]                       inherits = FALSE)
[17:36:40.314]                   }
[17:36:40.314]                   options(future.plan = NULL)
[17:36:40.314]                   if (is.na(NA_character_)) 
[17:36:40.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.314]                     .init = FALSE)
[17:36:40.314]                 }
[17:36:40.314]             }
[17:36:40.314]         }
[17:36:40.314]     })
[17:36:40.314]     if (TRUE) {
[17:36:40.314]         base::sink(type = "output", split = FALSE)
[17:36:40.314]         if (TRUE) {
[17:36:40.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.314]         }
[17:36:40.314]         else {
[17:36:40.314]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.314]         }
[17:36:40.314]         base::close(...future.stdout)
[17:36:40.314]         ...future.stdout <- NULL
[17:36:40.314]     }
[17:36:40.314]     ...future.result$conditions <- ...future.conditions
[17:36:40.314]     ...future.result$finished <- base::Sys.time()
[17:36:40.314]     ...future.result
[17:36:40.314] }
[17:36:40.316] assign_globals() ...
[17:36:40.316] List of 5
[17:36:40.316]  $ ...future.FUN            :function (x, ...)  
[17:36:40.316]  $ future.call.arguments    :List of 1
[17:36:40.316]   ..$ singular.ok: logi FALSE
[17:36:40.316]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.316]  $ ...future.elements_ii    :List of 3
[17:36:40.316]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.316]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.316]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.316]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.316]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.316]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.316]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.316]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:40.316]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.316]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.316]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.316]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:40.316]  $ ...future.seeds_ii       : NULL
[17:36:40.316]  $ ...future.globals.maxSize: NULL
[17:36:40.316]  - attr(*, "where")=List of 5
[17:36:40.316]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.316]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.316]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.316]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.316]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.316]  - attr(*, "resolved")= logi FALSE
[17:36:40.316]  - attr(*, "total_size")= num 5384
[17:36:40.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.316]  - attr(*, "already-done")= logi TRUE
[17:36:40.324] - reassign environment for ‘...future.FUN’
[17:36:40.324] - copied ‘...future.FUN’ to environment
[17:36:40.324] - copied ‘future.call.arguments’ to environment
[17:36:40.324] - copied ‘...future.elements_ii’ to environment
[17:36:40.325] - copied ‘...future.seeds_ii’ to environment
[17:36:40.325] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.325] assign_globals() ... done
[17:36:40.325] plan(): Setting new future strategy stack:
[17:36:40.325] List of future strategies:
[17:36:40.325] 1. sequential:
[17:36:40.325]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.325]    - tweaked: FALSE
[17:36:40.325]    - call: NULL
[17:36:40.326] plan(): nbrOfWorkers() = 1
[17:36:40.328] plan(): Setting new future strategy stack:
[17:36:40.328] List of future strategies:
[17:36:40.328] 1. sequential:
[17:36:40.328]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.328]    - tweaked: FALSE
[17:36:40.328]    - call: plan(strategy)
[17:36:40.329] plan(): nbrOfWorkers() = 1
[17:36:40.329] SequentialFuture started (and completed)
[17:36:40.329] - Launch lazy future ... done
[17:36:40.329] run() for ‘SequentialFuture’ ... done
[17:36:40.329] Created future:
[17:36:40.329] SequentialFuture:
[17:36:40.329] Label: ‘future_by-1’
[17:36:40.329] Expression:
[17:36:40.329] {
[17:36:40.329]     do.call(function(...) {
[17:36:40.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.329]             on.exit(options(oopts), add = TRUE)
[17:36:40.329]         }
[17:36:40.329]         {
[17:36:40.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.329]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.329]             })
[17:36:40.329]         }
[17:36:40.329]     }, args = future.call.arguments)
[17:36:40.329] }
[17:36:40.329] Lazy evaluation: FALSE
[17:36:40.329] Asynchronous evaluation: FALSE
[17:36:40.329] Local evaluation: TRUE
[17:36:40.329] Environment: R_GlobalEnv
[17:36:40.329] Capture standard output: TRUE
[17:36:40.329] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.329] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.329] Packages: 1 packages (‘stats’)
[17:36:40.329] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.329] Resolved: TRUE
[17:36:40.329] Value: 26.06 KiB of class ‘list’
[17:36:40.329] Early signaling: FALSE
[17:36:40.329] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.329] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.331] Chunk #1 of 1 ... DONE
[17:36:40.332] Launching 1 futures (chunks) ... DONE
[17:36:40.332] Resolving 1 futures (chunks) ...
[17:36:40.333] resolve() on list ...
[17:36:40.333]  recursive: 0
[17:36:40.333]  length: 1
[17:36:40.333] 
[17:36:40.333] resolved() for ‘SequentialFuture’ ...
[17:36:40.333] - state: ‘finished’
[17:36:40.333] - run: TRUE
[17:36:40.333] - result: ‘FutureResult’
[17:36:40.333] resolved() for ‘SequentialFuture’ ... done
[17:36:40.333] Future #1
[17:36:40.334] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:40.334] - nx: 1
[17:36:40.334] - relay: TRUE
[17:36:40.334] - stdout: TRUE
[17:36:40.334] - signal: TRUE
[17:36:40.334] - resignal: FALSE
[17:36:40.334] - force: TRUE
[17:36:40.334] - relayed: [n=1] FALSE
[17:36:40.334] - queued futures: [n=1] FALSE
[17:36:40.334]  - until=1
[17:36:40.335]  - relaying element #1
[17:36:40.335] - relayed: [n=1] TRUE
[17:36:40.335] - queued futures: [n=1] TRUE
[17:36:40.335] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:40.335]  length: 0 (resolved future 1)
[17:36:40.335] Relaying remaining futures
[17:36:40.335] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.335] - nx: 1
[17:36:40.335] - relay: TRUE
[17:36:40.336] - stdout: TRUE
[17:36:40.336] - signal: TRUE
[17:36:40.336] - resignal: FALSE
[17:36:40.336] - force: TRUE
[17:36:40.336] - relayed: [n=1] TRUE
[17:36:40.336] - queued futures: [n=1] TRUE
 - flush all
[17:36:40.336] - relayed: [n=1] TRUE
[17:36:40.336] - queued futures: [n=1] TRUE
[17:36:40.336] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.336] resolve() on list ... DONE
[17:36:40.337]  - Number of value chunks collected: 1
[17:36:40.337] Resolving 1 futures (chunks) ... DONE
[17:36:40.337] Reducing values from 1 chunks ...
[17:36:40.337]  - Number of values collected after concatenation: 3
[17:36:40.337]  - Number of values expected: 3
[17:36:40.337] Reducing values from 1 chunks ... DONE
[17:36:40.337] future_lapply() ... DONE
[17:36:40.337] future_by_internal() ... DONE
[17:36:40.341] future_by_internal() ...
[17:36:40.341] future_lapply() ...
[17:36:40.342] Number of chunks: 1
[17:36:40.342] getGlobalsAndPackagesXApply() ...
[17:36:40.342]  - future.globals: TRUE
[17:36:40.343] getGlobalsAndPackages() ...
[17:36:40.343] Searching for globals...
[17:36:40.344] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:40.344] Searching for globals ... DONE
[17:36:40.344] Resolving globals: FALSE
[17:36:40.345] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:36:40.345] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:36:40.345] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:40.346] - packages: [1] ‘stats’
[17:36:40.346] getGlobalsAndPackages() ... DONE
[17:36:40.346]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:40.346]  - needed namespaces: [n=1] ‘stats’
[17:36:40.346] Finding globals ... DONE
[17:36:40.346]  - use_args: TRUE
[17:36:40.346]  - Getting '...' globals ...
[17:36:40.346] resolve() on list ...
[17:36:40.346]  recursive: 0
[17:36:40.347]  length: 1
[17:36:40.347]  elements: ‘...’
[17:36:40.347]  length: 0 (resolved future 1)
[17:36:40.347] resolve() on list ... DONE
[17:36:40.347]    - '...' content: [n=0] 
[17:36:40.347] List of 1
[17:36:40.347]  $ ...: list()
[17:36:40.347]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.347]  - attr(*, "where")=List of 1
[17:36:40.347]   ..$ ...:<environment: 0x5622fb9d9d98> 
[17:36:40.347]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.347]  - attr(*, "resolved")= logi TRUE
[17:36:40.347]  - attr(*, "total_size")= num NA
[17:36:40.349]  - Getting '...' globals ... DONE
[17:36:40.350] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:36:40.350] List of 4
[17:36:40.350]  $ ...future.FUN:function (x)  
[17:36:40.350]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:40.350]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.350]  $ ...          : list()
[17:36:40.350]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.350]  - attr(*, "where")=List of 4
[17:36:40.350]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.350]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:36:40.350]   ..$ wool         :<environment: R_EmptyEnv> 
[17:36:40.350]   ..$ ...          :<environment: 0x5622fb9d9d98> 
[17:36:40.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.350]  - attr(*, "resolved")= logi FALSE
[17:36:40.350]  - attr(*, "total_size")= num 2320
[17:36:40.355] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:40.356] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.356] Number of futures (= number of chunks): 1
[17:36:40.356] Launching 1 futures (chunks) ...
[17:36:40.356] Chunk #1 of 1 ...
[17:36:40.356]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.356] getGlobalsAndPackages() ...
[17:36:40.356] Searching for globals...
[17:36:40.357] 
[17:36:40.357] Searching for globals ... DONE
[17:36:40.357] - globals: [0] <none>
[17:36:40.357] getGlobalsAndPackages() ... DONE
[17:36:40.357]    + additional globals found: [n=0] 
[17:36:40.357]    + additional namespaces needed: [n=0] 
[17:36:40.357]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.357]  - seeds: <none>
[17:36:40.358]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.358] getGlobalsAndPackages() ...
[17:36:40.358] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.358] Resolving globals: FALSE
[17:36:40.358] Tweak future expression to call with '...' arguments ...
[17:36:40.358] {
[17:36:40.358]     do.call(function(...) {
[17:36:40.358]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.358]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.358]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.358]             on.exit(options(oopts), add = TRUE)
[17:36:40.358]         }
[17:36:40.358]         {
[17:36:40.358]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.358]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.358]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.358]             })
[17:36:40.358]         }
[17:36:40.358]     }, args = future.call.arguments)
[17:36:40.358] }
[17:36:40.358] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.359] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.359] 
[17:36:40.359] getGlobalsAndPackages() ... DONE
[17:36:40.359] run() for ‘Future’ ...
[17:36:40.359] - state: ‘created’
[17:36:40.359] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:40.360] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.360] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:40.360]   - Field: ‘label’
[17:36:40.360]   - Field: ‘local’
[17:36:40.360]   - Field: ‘owner’
[17:36:40.360]   - Field: ‘envir’
[17:36:40.360]   - Field: ‘packages’
[17:36:40.360]   - Field: ‘gc’
[17:36:40.361]   - Field: ‘conditions’
[17:36:40.361]   - Field: ‘expr’
[17:36:40.361]   - Field: ‘uuid’
[17:36:40.361]   - Field: ‘seed’
[17:36:40.361]   - Field: ‘version’
[17:36:40.361]   - Field: ‘result’
[17:36:40.361]   - Field: ‘asynchronous’
[17:36:40.361]   - Field: ‘calls’
[17:36:40.361]   - Field: ‘globals’
[17:36:40.361]   - Field: ‘stdout’
[17:36:40.361]   - Field: ‘earlySignal’
[17:36:40.362]   - Field: ‘lazy’
[17:36:40.362]   - Field: ‘state’
[17:36:40.362] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:40.362] - Launch lazy future ...
[17:36:40.362] Packages needed by the future expression (n = 1): ‘stats’
[17:36:40.362] Packages needed by future strategies (n = 0): <none>
[17:36:40.363] {
[17:36:40.363]     {
[17:36:40.363]         {
[17:36:40.363]             ...future.startTime <- base::Sys.time()
[17:36:40.363]             {
[17:36:40.363]                 {
[17:36:40.363]                   {
[17:36:40.363]                     {
[17:36:40.363]                       base::local({
[17:36:40.363]                         has_future <- base::requireNamespace("future", 
[17:36:40.363]                           quietly = TRUE)
[17:36:40.363]                         if (has_future) {
[17:36:40.363]                           ns <- base::getNamespace("future")
[17:36:40.363]                           version <- ns[[".package"]][["version"]]
[17:36:40.363]                           if (is.null(version)) 
[17:36:40.363]                             version <- utils::packageVersion("future")
[17:36:40.363]                         }
[17:36:40.363]                         else {
[17:36:40.363]                           version <- NULL
[17:36:40.363]                         }
[17:36:40.363]                         if (!has_future || version < "1.8.0") {
[17:36:40.363]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.363]                             "", base::R.version$version.string), 
[17:36:40.363]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:40.363]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.363]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.363]                               "release", "version")], collapse = " "), 
[17:36:40.363]                             hostname = base::Sys.info()[["nodename"]])
[17:36:40.363]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.363]                             info)
[17:36:40.363]                           info <- base::paste(info, collapse = "; ")
[17:36:40.363]                           if (!has_future) {
[17:36:40.363]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.363]                               info)
[17:36:40.363]                           }
[17:36:40.363]                           else {
[17:36:40.363]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.363]                               info, version)
[17:36:40.363]                           }
[17:36:40.363]                           base::stop(msg)
[17:36:40.363]                         }
[17:36:40.363]                       })
[17:36:40.363]                     }
[17:36:40.363]                     base::local({
[17:36:40.363]                       for (pkg in "stats") {
[17:36:40.363]                         base::loadNamespace(pkg)
[17:36:40.363]                         base::library(pkg, character.only = TRUE)
[17:36:40.363]                       }
[17:36:40.363]                     })
[17:36:40.363]                   }
[17:36:40.363]                   ...future.strategy.old <- future::plan("list")
[17:36:40.363]                   options(future.plan = NULL)
[17:36:40.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.363]                 }
[17:36:40.363]                 ...future.workdir <- getwd()
[17:36:40.363]             }
[17:36:40.363]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.363]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.363]         }
[17:36:40.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.363]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:40.363]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.363]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.363]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.363]             base::names(...future.oldOptions))
[17:36:40.363]     }
[17:36:40.363]     if (FALSE) {
[17:36:40.363]     }
[17:36:40.363]     else {
[17:36:40.363]         if (TRUE) {
[17:36:40.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.363]                 open = "w")
[17:36:40.363]         }
[17:36:40.363]         else {
[17:36:40.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.363]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.363]         }
[17:36:40.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.363]             base::sink(type = "output", split = FALSE)
[17:36:40.363]             base::close(...future.stdout)
[17:36:40.363]         }, add = TRUE)
[17:36:40.363]     }
[17:36:40.363]     ...future.frame <- base::sys.nframe()
[17:36:40.363]     ...future.conditions <- base::list()
[17:36:40.363]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.363]     if (FALSE) {
[17:36:40.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.363]     }
[17:36:40.363]     ...future.result <- base::tryCatch({
[17:36:40.363]         base::withCallingHandlers({
[17:36:40.363]             ...future.value <- base::withVisible(base::local({
[17:36:40.363]                 do.call(function(...) {
[17:36:40.363]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.363]                   if (!identical(...future.globals.maxSize.org, 
[17:36:40.363]                     ...future.globals.maxSize)) {
[17:36:40.363]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.363]                     on.exit(options(oopts), add = TRUE)
[17:36:40.363]                   }
[17:36:40.363]                   {
[17:36:40.363]                     lapply(seq_along(...future.elements_ii), 
[17:36:40.363]                       FUN = function(jj) {
[17:36:40.363]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.363]                         ...future.FUN(...future.X_jj, ...)
[17:36:40.363]                       })
[17:36:40.363]                   }
[17:36:40.363]                 }, args = future.call.arguments)
[17:36:40.363]             }))
[17:36:40.363]             future::FutureResult(value = ...future.value$value, 
[17:36:40.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.363]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.363]                     ...future.globalenv.names))
[17:36:40.363]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.363]         }, condition = base::local({
[17:36:40.363]             c <- base::c
[17:36:40.363]             inherits <- base::inherits
[17:36:40.363]             invokeRestart <- base::invokeRestart
[17:36:40.363]             length <- base::length
[17:36:40.363]             list <- base::list
[17:36:40.363]             seq.int <- base::seq.int
[17:36:40.363]             signalCondition <- base::signalCondition
[17:36:40.363]             sys.calls <- base::sys.calls
[17:36:40.363]             `[[` <- base::`[[`
[17:36:40.363]             `+` <- base::`+`
[17:36:40.363]             `<<-` <- base::`<<-`
[17:36:40.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.363]                   3L)]
[17:36:40.363]             }
[17:36:40.363]             function(cond) {
[17:36:40.363]                 is_error <- inherits(cond, "error")
[17:36:40.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.363]                   NULL)
[17:36:40.363]                 if (is_error) {
[17:36:40.363]                   sessionInformation <- function() {
[17:36:40.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.363]                       search = base::search(), system = base::Sys.info())
[17:36:40.363]                   }
[17:36:40.363]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.363]                     cond$call), session = sessionInformation(), 
[17:36:40.363]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.363]                   signalCondition(cond)
[17:36:40.363]                 }
[17:36:40.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.363]                 "immediateCondition"))) {
[17:36:40.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.363]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.363]                   if (TRUE && !signal) {
[17:36:40.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.363]                     {
[17:36:40.363]                       inherits <- base::inherits
[17:36:40.363]                       invokeRestart <- base::invokeRestart
[17:36:40.363]                       is.null <- base::is.null
[17:36:40.363]                       muffled <- FALSE
[17:36:40.363]                       if (inherits(cond, "message")) {
[17:36:40.363]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.363]                         if (muffled) 
[17:36:40.363]                           invokeRestart("muffleMessage")
[17:36:40.363]                       }
[17:36:40.363]                       else if (inherits(cond, "warning")) {
[17:36:40.363]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.363]                         if (muffled) 
[17:36:40.363]                           invokeRestart("muffleWarning")
[17:36:40.363]                       }
[17:36:40.363]                       else if (inherits(cond, "condition")) {
[17:36:40.363]                         if (!is.null(pattern)) {
[17:36:40.363]                           computeRestarts <- base::computeRestarts
[17:36:40.363]                           grepl <- base::grepl
[17:36:40.363]                           restarts <- computeRestarts(cond)
[17:36:40.363]                           for (restart in restarts) {
[17:36:40.363]                             name <- restart$name
[17:36:40.363]                             if (is.null(name)) 
[17:36:40.363]                               next
[17:36:40.363]                             if (!grepl(pattern, name)) 
[17:36:40.363]                               next
[17:36:40.363]                             invokeRestart(restart)
[17:36:40.363]                             muffled <- TRUE
[17:36:40.363]                             break
[17:36:40.363]                           }
[17:36:40.363]                         }
[17:36:40.363]                       }
[17:36:40.363]                       invisible(muffled)
[17:36:40.363]                     }
[17:36:40.363]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.363]                   }
[17:36:40.363]                 }
[17:36:40.363]                 else {
[17:36:40.363]                   if (TRUE) {
[17:36:40.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.363]                     {
[17:36:40.363]                       inherits <- base::inherits
[17:36:40.363]                       invokeRestart <- base::invokeRestart
[17:36:40.363]                       is.null <- base::is.null
[17:36:40.363]                       muffled <- FALSE
[17:36:40.363]                       if (inherits(cond, "message")) {
[17:36:40.363]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.363]                         if (muffled) 
[17:36:40.363]                           invokeRestart("muffleMessage")
[17:36:40.363]                       }
[17:36:40.363]                       else if (inherits(cond, "warning")) {
[17:36:40.363]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.363]                         if (muffled) 
[17:36:40.363]                           invokeRestart("muffleWarning")
[17:36:40.363]                       }
[17:36:40.363]                       else if (inherits(cond, "condition")) {
[17:36:40.363]                         if (!is.null(pattern)) {
[17:36:40.363]                           computeRestarts <- base::computeRestarts
[17:36:40.363]                           grepl <- base::grepl
[17:36:40.363]                           restarts <- computeRestarts(cond)
[17:36:40.363]                           for (restart in restarts) {
[17:36:40.363]                             name <- restart$name
[17:36:40.363]                             if (is.null(name)) 
[17:36:40.363]                               next
[17:36:40.363]                             if (!grepl(pattern, name)) 
[17:36:40.363]                               next
[17:36:40.363]                             invokeRestart(restart)
[17:36:40.363]                             muffled <- TRUE
[17:36:40.363]                             break
[17:36:40.363]                           }
[17:36:40.363]                         }
[17:36:40.363]                       }
[17:36:40.363]                       invisible(muffled)
[17:36:40.363]                     }
[17:36:40.363]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.363]                   }
[17:36:40.363]                 }
[17:36:40.363]             }
[17:36:40.363]         }))
[17:36:40.363]     }, error = function(ex) {
[17:36:40.363]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.363]                 ...future.rng), started = ...future.startTime, 
[17:36:40.363]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.363]             version = "1.8"), class = "FutureResult")
[17:36:40.363]     }, finally = {
[17:36:40.363]         if (!identical(...future.workdir, getwd())) 
[17:36:40.363]             setwd(...future.workdir)
[17:36:40.363]         {
[17:36:40.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.363]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.363]             }
[17:36:40.363]             base::options(...future.oldOptions)
[17:36:40.363]             if (.Platform$OS.type == "windows") {
[17:36:40.363]                 old_names <- names(...future.oldEnvVars)
[17:36:40.363]                 envs <- base::Sys.getenv()
[17:36:40.363]                 names <- names(envs)
[17:36:40.363]                 common <- intersect(names, old_names)
[17:36:40.363]                 added <- setdiff(names, old_names)
[17:36:40.363]                 removed <- setdiff(old_names, names)
[17:36:40.363]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.363]                   envs[common]]
[17:36:40.363]                 NAMES <- toupper(changed)
[17:36:40.363]                 args <- list()
[17:36:40.363]                 for (kk in seq_along(NAMES)) {
[17:36:40.363]                   name <- changed[[kk]]
[17:36:40.363]                   NAME <- NAMES[[kk]]
[17:36:40.363]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.363]                     next
[17:36:40.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.363]                 }
[17:36:40.363]                 NAMES <- toupper(added)
[17:36:40.363]                 for (kk in seq_along(NAMES)) {
[17:36:40.363]                   name <- added[[kk]]
[17:36:40.363]                   NAME <- NAMES[[kk]]
[17:36:40.363]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.363]                     next
[17:36:40.363]                   args[[name]] <- ""
[17:36:40.363]                 }
[17:36:40.363]                 NAMES <- toupper(removed)
[17:36:40.363]                 for (kk in seq_along(NAMES)) {
[17:36:40.363]                   name <- removed[[kk]]
[17:36:40.363]                   NAME <- NAMES[[kk]]
[17:36:40.363]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.363]                     next
[17:36:40.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.363]                 }
[17:36:40.363]                 if (length(args) > 0) 
[17:36:40.363]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.363]             }
[17:36:40.363]             else {
[17:36:40.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.363]             }
[17:36:40.363]             {
[17:36:40.363]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.363]                   0L) {
[17:36:40.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.363]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.363]                   base::options(opts)
[17:36:40.363]                 }
[17:36:40.363]                 {
[17:36:40.363]                   {
[17:36:40.363]                     NULL
[17:36:40.363]                     RNGkind("Mersenne-Twister")
[17:36:40.363]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:40.363]                       inherits = FALSE)
[17:36:40.363]                   }
[17:36:40.363]                   options(future.plan = NULL)
[17:36:40.363]                   if (is.na(NA_character_)) 
[17:36:40.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.363]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.363]                     .init = FALSE)
[17:36:40.363]                 }
[17:36:40.363]             }
[17:36:40.363]         }
[17:36:40.363]     })
[17:36:40.363]     if (TRUE) {
[17:36:40.363]         base::sink(type = "output", split = FALSE)
[17:36:40.363]         if (TRUE) {
[17:36:40.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.363]         }
[17:36:40.363]         else {
[17:36:40.363]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.363]         }
[17:36:40.363]         base::close(...future.stdout)
[17:36:40.363]         ...future.stdout <- NULL
[17:36:40.363]     }
[17:36:40.363]     ...future.result$conditions <- ...future.conditions
[17:36:40.363]     ...future.result$finished <- base::Sys.time()
[17:36:40.363]     ...future.result
[17:36:40.363] }
[17:36:40.364] assign_globals() ...
[17:36:40.365] List of 7
[17:36:40.365]  $ ...future.FUN            :function (x)  
[17:36:40.365]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:40.365]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.365]  $ future.call.arguments    : list()
[17:36:40.365]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.365]  $ ...future.elements_ii    :List of 3
[17:36:40.365]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.365]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.365]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.365]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.365]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.365]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.365]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.365]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:40.365]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.365]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.365]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.365]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:40.365]  $ ...future.seeds_ii       : NULL
[17:36:40.365]  $ ...future.globals.maxSize: NULL
[17:36:40.365]  - attr(*, "where")=List of 7
[17:36:40.365]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.365]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:36:40.365]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:36:40.365]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.365]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.365]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.365]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.365]  - attr(*, "resolved")= logi FALSE
[17:36:40.365]  - attr(*, "total_size")= num 2320
[17:36:40.365]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.365]  - attr(*, "already-done")= logi TRUE
[17:36:40.376] - reassign environment for ‘...future.FUN’
[17:36:40.376] - copied ‘...future.FUN’ to environment
[17:36:40.376] - copied ‘breaks’ to environment
[17:36:40.376] - copied ‘wool’ to environment
[17:36:40.376] - copied ‘future.call.arguments’ to environment
[17:36:40.376] - copied ‘...future.elements_ii’ to environment
[17:36:40.376] - copied ‘...future.seeds_ii’ to environment
[17:36:40.377] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.377] assign_globals() ... done
[17:36:40.377] plan(): Setting new future strategy stack:
[17:36:40.377] List of future strategies:
[17:36:40.377] 1. sequential:
[17:36:40.377]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.377]    - tweaked: FALSE
[17:36:40.377]    - call: NULL
[17:36:40.378] plan(): nbrOfWorkers() = 1
[17:36:40.381] plan(): Setting new future strategy stack:
[17:36:40.381] List of future strategies:
[17:36:40.381] 1. sequential:
[17:36:40.381]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.381]    - tweaked: FALSE
[17:36:40.381]    - call: plan(strategy)
[17:36:40.381] plan(): nbrOfWorkers() = 1
[17:36:40.382] SequentialFuture started (and completed)
[17:36:40.382] - Launch lazy future ... done
[17:36:40.382] run() for ‘SequentialFuture’ ... done
[17:36:40.382] Created future:
[17:36:40.382] SequentialFuture:
[17:36:40.382] Label: ‘future_by-1’
[17:36:40.382] Expression:
[17:36:40.382] {
[17:36:40.382]     do.call(function(...) {
[17:36:40.382]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.382]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.382]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.382]             on.exit(options(oopts), add = TRUE)
[17:36:40.382]         }
[17:36:40.382]         {
[17:36:40.382]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.382]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.382]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.382]             })
[17:36:40.382]         }
[17:36:40.382]     }, args = future.call.arguments)
[17:36:40.382] }
[17:36:40.382] Lazy evaluation: FALSE
[17:36:40.382] Asynchronous evaluation: FALSE
[17:36:40.382] Local evaluation: TRUE
[17:36:40.382] Environment: 0x5622fb9a1f48
[17:36:40.382] Capture standard output: TRUE
[17:36:40.382] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.382] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:36:40.382] Packages: 1 packages (‘stats’)
[17:36:40.382] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.382] Resolved: TRUE
[17:36:40.382] Value: 25.57 KiB of class ‘list’
[17:36:40.382] Early signaling: FALSE
[17:36:40.382] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.382] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.384] Chunk #1 of 1 ... DONE
[17:36:40.384] Launching 1 futures (chunks) ... DONE
[17:36:40.384] Resolving 1 futures (chunks) ...
[17:36:40.384] resolve() on list ...
[17:36:40.384]  recursive: 0
[17:36:40.384]  length: 1
[17:36:40.384] 
[17:36:40.384] resolved() for ‘SequentialFuture’ ...
[17:36:40.384] - state: ‘finished’
[17:36:40.384] - run: TRUE
[17:36:40.385] - result: ‘FutureResult’
[17:36:40.385] resolved() for ‘SequentialFuture’ ... done
[17:36:40.385] Future #1
[17:36:40.385] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:40.385] - nx: 1
[17:36:40.385] - relay: TRUE
[17:36:40.385] - stdout: TRUE
[17:36:40.385] - signal: TRUE
[17:36:40.385] - resignal: FALSE
[17:36:40.385] - force: TRUE
[17:36:40.385] - relayed: [n=1] FALSE
[17:36:40.386] - queued futures: [n=1] FALSE
[17:36:40.386]  - until=1
[17:36:40.386]  - relaying element #1
[17:36:40.386] - relayed: [n=1] TRUE
[17:36:40.386] - queued futures: [n=1] TRUE
[17:36:40.386] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:40.386]  length: 0 (resolved future 1)
[17:36:40.386] Relaying remaining futures
[17:36:40.386] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.386] - nx: 1
[17:36:40.387] - relay: TRUE
[17:36:40.387] - stdout: TRUE
[17:36:40.387] - signal: TRUE
[17:36:40.387] - resignal: FALSE
[17:36:40.387] - force: TRUE
[17:36:40.387] - relayed: [n=1] TRUE
[17:36:40.387] - queued futures: [n=1] TRUE
 - flush all
[17:36:40.387] - relayed: [n=1] TRUE
[17:36:40.387] - queued futures: [n=1] TRUE
[17:36:40.387] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.387] resolve() on list ... DONE
[17:36:40.388]  - Number of value chunks collected: 1
[17:36:40.388] Resolving 1 futures (chunks) ... DONE
[17:36:40.388] Reducing values from 1 chunks ...
[17:36:40.388]  - Number of values collected after concatenation: 3
[17:36:40.388]  - Number of values expected: 3
[17:36:40.388] Reducing values from 1 chunks ... DONE
[17:36:40.388] future_lapply() ... DONE
[17:36:40.388] future_by_internal() ... DONE
[17:36:40.389] future_by_internal() ...
[17:36:40.389] future_lapply() ...
[17:36:40.389] Number of chunks: 1
[17:36:40.390] getGlobalsAndPackagesXApply() ...
[17:36:40.390]  - future.globals: TRUE
[17:36:40.390] getGlobalsAndPackages() ...
[17:36:40.390] Searching for globals...
[17:36:40.391] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:40.391] Searching for globals ... DONE
[17:36:40.391] Resolving globals: FALSE
[17:36:40.391] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:40.392] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:40.392] - globals: [1] ‘FUN’
[17:36:40.392] 
[17:36:40.392] getGlobalsAndPackages() ... DONE
[17:36:40.392]  - globals found/used: [n=1] ‘FUN’
[17:36:40.392]  - needed namespaces: [n=0] 
[17:36:40.392] Finding globals ... DONE
[17:36:40.392]  - use_args: TRUE
[17:36:40.393]  - Getting '...' globals ...
[17:36:40.393] resolve() on list ...
[17:36:40.393]  recursive: 0
[17:36:40.393]  length: 1
[17:36:40.393]  elements: ‘...’
[17:36:40.393]  length: 0 (resolved future 1)
[17:36:40.393] resolve() on list ... DONE
[17:36:40.393]    - '...' content: [n=0] 
[17:36:40.394] List of 1
[17:36:40.394]  $ ...: list()
[17:36:40.394]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.394]  - attr(*, "where")=List of 1
[17:36:40.394]   ..$ ...:<environment: 0x5622fc0778b0> 
[17:36:40.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.394]  - attr(*, "resolved")= logi TRUE
[17:36:40.394]  - attr(*, "total_size")= num NA
[17:36:40.396]  - Getting '...' globals ... DONE
[17:36:40.398] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:40.398] List of 2
[17:36:40.398]  $ ...future.FUN:function (object, ...)  
[17:36:40.398]  $ ...          : list()
[17:36:40.398]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.398]  - attr(*, "where")=List of 2
[17:36:40.398]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.398]   ..$ ...          :<environment: 0x5622fc0778b0> 
[17:36:40.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.398]  - attr(*, "resolved")= logi FALSE
[17:36:40.398]  - attr(*, "total_size")= num 1240
[17:36:40.401] Packages to be attached in all futures: [n=0] 
[17:36:40.401] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.401] Number of futures (= number of chunks): 1
[17:36:40.401] Launching 1 futures (chunks) ...
[17:36:40.401] Chunk #1 of 1 ...
[17:36:40.402]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.402] getGlobalsAndPackages() ...
[17:36:40.402] Searching for globals...
[17:36:40.402] 
[17:36:40.402] Searching for globals ... DONE
[17:36:40.402] - globals: [0] <none>
[17:36:40.403] getGlobalsAndPackages() ... DONE
[17:36:40.403]    + additional globals found: [n=0] 
[17:36:40.403]    + additional namespaces needed: [n=0] 
[17:36:40.403]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.403]  - seeds: <none>
[17:36:40.403]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.403] getGlobalsAndPackages() ...
[17:36:40.403] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.403] Resolving globals: FALSE
[17:36:40.403] Tweak future expression to call with '...' arguments ...
[17:36:40.404] {
[17:36:40.404]     do.call(function(...) {
[17:36:40.404]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.404]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.404]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.404]             on.exit(options(oopts), add = TRUE)
[17:36:40.404]         }
[17:36:40.404]         {
[17:36:40.404]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.404]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.404]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.404]             })
[17:36:40.404]         }
[17:36:40.404]     }, args = future.call.arguments)
[17:36:40.404] }
[17:36:40.404] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.404] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.404] 
[17:36:40.404] getGlobalsAndPackages() ... DONE
[17:36:40.405] run() for ‘Future’ ...
[17:36:40.405] - state: ‘created’
[17:36:40.405] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:40.405] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.405] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:40.405]   - Field: ‘label’
[17:36:40.405]   - Field: ‘local’
[17:36:40.406]   - Field: ‘owner’
[17:36:40.406]   - Field: ‘envir’
[17:36:40.406]   - Field: ‘packages’
[17:36:40.406]   - Field: ‘gc’
[17:36:40.406]   - Field: ‘conditions’
[17:36:40.406]   - Field: ‘expr’
[17:36:40.406]   - Field: ‘uuid’
[17:36:40.406]   - Field: ‘seed’
[17:36:40.406]   - Field: ‘version’
[17:36:40.406]   - Field: ‘result’
[17:36:40.406]   - Field: ‘asynchronous’
[17:36:40.407]   - Field: ‘calls’
[17:36:40.407]   - Field: ‘globals’
[17:36:40.407]   - Field: ‘stdout’
[17:36:40.407]   - Field: ‘earlySignal’
[17:36:40.407]   - Field: ‘lazy’
[17:36:40.407]   - Field: ‘state’
[17:36:40.407] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:40.407] - Launch lazy future ...
[17:36:40.407] Packages needed by the future expression (n = 0): <none>
[17:36:40.407] Packages needed by future strategies (n = 0): <none>
[17:36:40.408] {
[17:36:40.408]     {
[17:36:40.408]         {
[17:36:40.408]             ...future.startTime <- base::Sys.time()
[17:36:40.408]             {
[17:36:40.408]                 {
[17:36:40.408]                   {
[17:36:40.408]                     base::local({
[17:36:40.408]                       has_future <- base::requireNamespace("future", 
[17:36:40.408]                         quietly = TRUE)
[17:36:40.408]                       if (has_future) {
[17:36:40.408]                         ns <- base::getNamespace("future")
[17:36:40.408]                         version <- ns[[".package"]][["version"]]
[17:36:40.408]                         if (is.null(version)) 
[17:36:40.408]                           version <- utils::packageVersion("future")
[17:36:40.408]                       }
[17:36:40.408]                       else {
[17:36:40.408]                         version <- NULL
[17:36:40.408]                       }
[17:36:40.408]                       if (!has_future || version < "1.8.0") {
[17:36:40.408]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.408]                           "", base::R.version$version.string), 
[17:36:40.408]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:40.408]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.408]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.408]                             "release", "version")], collapse = " "), 
[17:36:40.408]                           hostname = base::Sys.info()[["nodename"]])
[17:36:40.408]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.408]                           info)
[17:36:40.408]                         info <- base::paste(info, collapse = "; ")
[17:36:40.408]                         if (!has_future) {
[17:36:40.408]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.408]                             info)
[17:36:40.408]                         }
[17:36:40.408]                         else {
[17:36:40.408]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.408]                             info, version)
[17:36:40.408]                         }
[17:36:40.408]                         base::stop(msg)
[17:36:40.408]                       }
[17:36:40.408]                     })
[17:36:40.408]                   }
[17:36:40.408]                   ...future.strategy.old <- future::plan("list")
[17:36:40.408]                   options(future.plan = NULL)
[17:36:40.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.408]                 }
[17:36:40.408]                 ...future.workdir <- getwd()
[17:36:40.408]             }
[17:36:40.408]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.408]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.408]         }
[17:36:40.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.408]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:40.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.408]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.408]             base::names(...future.oldOptions))
[17:36:40.408]     }
[17:36:40.408]     if (FALSE) {
[17:36:40.408]     }
[17:36:40.408]     else {
[17:36:40.408]         if (TRUE) {
[17:36:40.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.408]                 open = "w")
[17:36:40.408]         }
[17:36:40.408]         else {
[17:36:40.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.408]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.408]         }
[17:36:40.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.408]             base::sink(type = "output", split = FALSE)
[17:36:40.408]             base::close(...future.stdout)
[17:36:40.408]         }, add = TRUE)
[17:36:40.408]     }
[17:36:40.408]     ...future.frame <- base::sys.nframe()
[17:36:40.408]     ...future.conditions <- base::list()
[17:36:40.408]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.408]     if (FALSE) {
[17:36:40.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.408]     }
[17:36:40.408]     ...future.result <- base::tryCatch({
[17:36:40.408]         base::withCallingHandlers({
[17:36:40.408]             ...future.value <- base::withVisible(base::local({
[17:36:40.408]                 do.call(function(...) {
[17:36:40.408]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.408]                   if (!identical(...future.globals.maxSize.org, 
[17:36:40.408]                     ...future.globals.maxSize)) {
[17:36:40.408]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.408]                     on.exit(options(oopts), add = TRUE)
[17:36:40.408]                   }
[17:36:40.408]                   {
[17:36:40.408]                     lapply(seq_along(...future.elements_ii), 
[17:36:40.408]                       FUN = function(jj) {
[17:36:40.408]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.408]                         ...future.FUN(...future.X_jj, ...)
[17:36:40.408]                       })
[17:36:40.408]                   }
[17:36:40.408]                 }, args = future.call.arguments)
[17:36:40.408]             }))
[17:36:40.408]             future::FutureResult(value = ...future.value$value, 
[17:36:40.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.408]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.408]                     ...future.globalenv.names))
[17:36:40.408]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.408]         }, condition = base::local({
[17:36:40.408]             c <- base::c
[17:36:40.408]             inherits <- base::inherits
[17:36:40.408]             invokeRestart <- base::invokeRestart
[17:36:40.408]             length <- base::length
[17:36:40.408]             list <- base::list
[17:36:40.408]             seq.int <- base::seq.int
[17:36:40.408]             signalCondition <- base::signalCondition
[17:36:40.408]             sys.calls <- base::sys.calls
[17:36:40.408]             `[[` <- base::`[[`
[17:36:40.408]             `+` <- base::`+`
[17:36:40.408]             `<<-` <- base::`<<-`
[17:36:40.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.408]                   3L)]
[17:36:40.408]             }
[17:36:40.408]             function(cond) {
[17:36:40.408]                 is_error <- inherits(cond, "error")
[17:36:40.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.408]                   NULL)
[17:36:40.408]                 if (is_error) {
[17:36:40.408]                   sessionInformation <- function() {
[17:36:40.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.408]                       search = base::search(), system = base::Sys.info())
[17:36:40.408]                   }
[17:36:40.408]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.408]                     cond$call), session = sessionInformation(), 
[17:36:40.408]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.408]                   signalCondition(cond)
[17:36:40.408]                 }
[17:36:40.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.408]                 "immediateCondition"))) {
[17:36:40.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.408]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.408]                   if (TRUE && !signal) {
[17:36:40.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.408]                     {
[17:36:40.408]                       inherits <- base::inherits
[17:36:40.408]                       invokeRestart <- base::invokeRestart
[17:36:40.408]                       is.null <- base::is.null
[17:36:40.408]                       muffled <- FALSE
[17:36:40.408]                       if (inherits(cond, "message")) {
[17:36:40.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.408]                         if (muffled) 
[17:36:40.408]                           invokeRestart("muffleMessage")
[17:36:40.408]                       }
[17:36:40.408]                       else if (inherits(cond, "warning")) {
[17:36:40.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.408]                         if (muffled) 
[17:36:40.408]                           invokeRestart("muffleWarning")
[17:36:40.408]                       }
[17:36:40.408]                       else if (inherits(cond, "condition")) {
[17:36:40.408]                         if (!is.null(pattern)) {
[17:36:40.408]                           computeRestarts <- base::computeRestarts
[17:36:40.408]                           grepl <- base::grepl
[17:36:40.408]                           restarts <- computeRestarts(cond)
[17:36:40.408]                           for (restart in restarts) {
[17:36:40.408]                             name <- restart$name
[17:36:40.408]                             if (is.null(name)) 
[17:36:40.408]                               next
[17:36:40.408]                             if (!grepl(pattern, name)) 
[17:36:40.408]                               next
[17:36:40.408]                             invokeRestart(restart)
[17:36:40.408]                             muffled <- TRUE
[17:36:40.408]                             break
[17:36:40.408]                           }
[17:36:40.408]                         }
[17:36:40.408]                       }
[17:36:40.408]                       invisible(muffled)
[17:36:40.408]                     }
[17:36:40.408]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.408]                   }
[17:36:40.408]                 }
[17:36:40.408]                 else {
[17:36:40.408]                   if (TRUE) {
[17:36:40.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.408]                     {
[17:36:40.408]                       inherits <- base::inherits
[17:36:40.408]                       invokeRestart <- base::invokeRestart
[17:36:40.408]                       is.null <- base::is.null
[17:36:40.408]                       muffled <- FALSE
[17:36:40.408]                       if (inherits(cond, "message")) {
[17:36:40.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.408]                         if (muffled) 
[17:36:40.408]                           invokeRestart("muffleMessage")
[17:36:40.408]                       }
[17:36:40.408]                       else if (inherits(cond, "warning")) {
[17:36:40.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.408]                         if (muffled) 
[17:36:40.408]                           invokeRestart("muffleWarning")
[17:36:40.408]                       }
[17:36:40.408]                       else if (inherits(cond, "condition")) {
[17:36:40.408]                         if (!is.null(pattern)) {
[17:36:40.408]                           computeRestarts <- base::computeRestarts
[17:36:40.408]                           grepl <- base::grepl
[17:36:40.408]                           restarts <- computeRestarts(cond)
[17:36:40.408]                           for (restart in restarts) {
[17:36:40.408]                             name <- restart$name
[17:36:40.408]                             if (is.null(name)) 
[17:36:40.408]                               next
[17:36:40.408]                             if (!grepl(pattern, name)) 
[17:36:40.408]                               next
[17:36:40.408]                             invokeRestart(restart)
[17:36:40.408]                             muffled <- TRUE
[17:36:40.408]                             break
[17:36:40.408]                           }
[17:36:40.408]                         }
[17:36:40.408]                       }
[17:36:40.408]                       invisible(muffled)
[17:36:40.408]                     }
[17:36:40.408]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.408]                   }
[17:36:40.408]                 }
[17:36:40.408]             }
[17:36:40.408]         }))
[17:36:40.408]     }, error = function(ex) {
[17:36:40.408]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.408]                 ...future.rng), started = ...future.startTime, 
[17:36:40.408]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.408]             version = "1.8"), class = "FutureResult")
[17:36:40.408]     }, finally = {
[17:36:40.408]         if (!identical(...future.workdir, getwd())) 
[17:36:40.408]             setwd(...future.workdir)
[17:36:40.408]         {
[17:36:40.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.408]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.408]             }
[17:36:40.408]             base::options(...future.oldOptions)
[17:36:40.408]             if (.Platform$OS.type == "windows") {
[17:36:40.408]                 old_names <- names(...future.oldEnvVars)
[17:36:40.408]                 envs <- base::Sys.getenv()
[17:36:40.408]                 names <- names(envs)
[17:36:40.408]                 common <- intersect(names, old_names)
[17:36:40.408]                 added <- setdiff(names, old_names)
[17:36:40.408]                 removed <- setdiff(old_names, names)
[17:36:40.408]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.408]                   envs[common]]
[17:36:40.408]                 NAMES <- toupper(changed)
[17:36:40.408]                 args <- list()
[17:36:40.408]                 for (kk in seq_along(NAMES)) {
[17:36:40.408]                   name <- changed[[kk]]
[17:36:40.408]                   NAME <- NAMES[[kk]]
[17:36:40.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.408]                     next
[17:36:40.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.408]                 }
[17:36:40.408]                 NAMES <- toupper(added)
[17:36:40.408]                 for (kk in seq_along(NAMES)) {
[17:36:40.408]                   name <- added[[kk]]
[17:36:40.408]                   NAME <- NAMES[[kk]]
[17:36:40.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.408]                     next
[17:36:40.408]                   args[[name]] <- ""
[17:36:40.408]                 }
[17:36:40.408]                 NAMES <- toupper(removed)
[17:36:40.408]                 for (kk in seq_along(NAMES)) {
[17:36:40.408]                   name <- removed[[kk]]
[17:36:40.408]                   NAME <- NAMES[[kk]]
[17:36:40.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.408]                     next
[17:36:40.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.408]                 }
[17:36:40.408]                 if (length(args) > 0) 
[17:36:40.408]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.408]             }
[17:36:40.408]             else {
[17:36:40.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.408]             }
[17:36:40.408]             {
[17:36:40.408]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.408]                   0L) {
[17:36:40.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.408]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.408]                   base::options(opts)
[17:36:40.408]                 }
[17:36:40.408]                 {
[17:36:40.408]                   {
[17:36:40.408]                     NULL
[17:36:40.408]                     RNGkind("Mersenne-Twister")
[17:36:40.408]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:40.408]                       inherits = FALSE)
[17:36:40.408]                   }
[17:36:40.408]                   options(future.plan = NULL)
[17:36:40.408]                   if (is.na(NA_character_)) 
[17:36:40.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.408]                     .init = FALSE)
[17:36:40.408]                 }
[17:36:40.408]             }
[17:36:40.408]         }
[17:36:40.408]     })
[17:36:40.408]     if (TRUE) {
[17:36:40.408]         base::sink(type = "output", split = FALSE)
[17:36:40.408]         if (TRUE) {
[17:36:40.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.408]         }
[17:36:40.408]         else {
[17:36:40.408]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.408]         }
[17:36:40.408]         base::close(...future.stdout)
[17:36:40.408]         ...future.stdout <- NULL
[17:36:40.408]     }
[17:36:40.408]     ...future.result$conditions <- ...future.conditions
[17:36:40.408]     ...future.result$finished <- base::Sys.time()
[17:36:40.408]     ...future.result
[17:36:40.408] }
[17:36:40.410] assign_globals() ...
[17:36:40.410] List of 5
[17:36:40.410]  $ ...future.FUN            :function (object, ...)  
[17:36:40.410]  $ future.call.arguments    : list()
[17:36:40.410]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.410]  $ ...future.elements_ii    :List of 3
[17:36:40.410]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.410]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.410]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.410]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.410]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.410]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.410]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.410]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:40.410]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.410]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.410]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.410]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:40.410]  $ ...future.seeds_ii       : NULL
[17:36:40.410]  $ ...future.globals.maxSize: NULL
[17:36:40.410]  - attr(*, "where")=List of 5
[17:36:40.410]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.410]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.410]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.410]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.410]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.410]  - attr(*, "resolved")= logi FALSE
[17:36:40.410]  - attr(*, "total_size")= num 1240
[17:36:40.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.410]  - attr(*, "already-done")= logi TRUE
[17:36:40.418] - copied ‘...future.FUN’ to environment
[17:36:40.418] - copied ‘future.call.arguments’ to environment
[17:36:40.418] - copied ‘...future.elements_ii’ to environment
[17:36:40.418] - copied ‘...future.seeds_ii’ to environment
[17:36:40.418] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.418] assign_globals() ... done
[17:36:40.418] plan(): Setting new future strategy stack:
[17:36:40.420] List of future strategies:
[17:36:40.420] 1. sequential:
[17:36:40.420]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.420]    - tweaked: FALSE
[17:36:40.420]    - call: NULL
[17:36:40.421] plan(): nbrOfWorkers() = 1
[17:36:40.423] plan(): Setting new future strategy stack:
[17:36:40.423] List of future strategies:
[17:36:40.423] 1. sequential:
[17:36:40.423]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.423]    - tweaked: FALSE
[17:36:40.423]    - call: plan(strategy)
[17:36:40.424] plan(): nbrOfWorkers() = 1
[17:36:40.424] SequentialFuture started (and completed)
[17:36:40.424] - Launch lazy future ... done
[17:36:40.424] run() for ‘SequentialFuture’ ... done
[17:36:40.424] Created future:
[17:36:40.424] SequentialFuture:
[17:36:40.424] Label: ‘future_by-1’
[17:36:40.424] Expression:
[17:36:40.424] {
[17:36:40.424]     do.call(function(...) {
[17:36:40.424]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.424]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.424]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.424]             on.exit(options(oopts), add = TRUE)
[17:36:40.424]         }
[17:36:40.424]         {
[17:36:40.424]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.424]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.424]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.424]             })
[17:36:40.424]         }
[17:36:40.424]     }, args = future.call.arguments)
[17:36:40.424] }
[17:36:40.424] Lazy evaluation: FALSE
[17:36:40.424] Asynchronous evaluation: FALSE
[17:36:40.424] Local evaluation: TRUE
[17:36:40.424] Environment: 0x5622fc00ccd0
[17:36:40.424] Capture standard output: TRUE
[17:36:40.424] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.424] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.424] Packages: <none>
[17:36:40.424] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.424] Resolved: TRUE
[17:36:40.424] Value: 5.37 KiB of class ‘list’
[17:36:40.424] Early signaling: FALSE
[17:36:40.424] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.424] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.426] Chunk #1 of 1 ... DONE
[17:36:40.426] Launching 1 futures (chunks) ... DONE
[17:36:40.426] Resolving 1 futures (chunks) ...
[17:36:40.426] resolve() on list ...
[17:36:40.426]  recursive: 0
[17:36:40.426]  length: 1
[17:36:40.426] 
[17:36:40.426] resolved() for ‘SequentialFuture’ ...
[17:36:40.426] - state: ‘finished’
[17:36:40.426] - run: TRUE
[17:36:40.427] - result: ‘FutureResult’
[17:36:40.427] resolved() for ‘SequentialFuture’ ... done
[17:36:40.427] Future #1
[17:36:40.427] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:40.427] - nx: 1
[17:36:40.427] - relay: TRUE
[17:36:40.427] - stdout: TRUE
[17:36:40.427] - signal: TRUE
[17:36:40.427] - resignal: FALSE
[17:36:40.427] - force: TRUE
[17:36:40.427] - relayed: [n=1] FALSE
[17:36:40.428] - queued futures: [n=1] FALSE
[17:36:40.428]  - until=1
[17:36:40.428]  - relaying element #1
[17:36:40.428] - relayed: [n=1] TRUE
[17:36:40.428] - queued futures: [n=1] TRUE
[17:36:40.428] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:40.428]  length: 0 (resolved future 1)
[17:36:40.428] Relaying remaining futures
[17:36:40.428] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.428] - nx: 1
[17:36:40.429] - relay: TRUE
[17:36:40.429] - stdout: TRUE
[17:36:40.429] - signal: TRUE
[17:36:40.429] - resignal: FALSE
[17:36:40.429] - force: TRUE
[17:36:40.429] - relayed: [n=1] TRUE
[17:36:40.429] - queued futures: [n=1] TRUE
 - flush all
[17:36:40.429] - relayed: [n=1] TRUE
[17:36:40.429] - queued futures: [n=1] TRUE
[17:36:40.429] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.429] resolve() on list ... DONE
[17:36:40.430]  - Number of value chunks collected: 1
[17:36:40.430] Resolving 1 futures (chunks) ... DONE
[17:36:40.430] Reducing values from 1 chunks ...
[17:36:40.430]  - Number of values collected after concatenation: 3
[17:36:40.430]  - Number of values expected: 3
[17:36:40.430] Reducing values from 1 chunks ... DONE
[17:36:40.430] future_lapply() ... DONE
[17:36:40.430] future_by_internal() ... DONE
[17:36:40.431] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:36:40.431] future_lapply() ...
[17:36:40.432] Number of chunks: 1
[17:36:40.432] getGlobalsAndPackagesXApply() ...
[17:36:40.432]  - future.globals: TRUE
[17:36:40.432] getGlobalsAndPackages() ...
[17:36:40.432] Searching for globals...
[17:36:40.433] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:40.433] Searching for globals ... DONE
[17:36:40.434] Resolving globals: FALSE
[17:36:40.434] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:40.434] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:40.434] - globals: [1] ‘FUN’
[17:36:40.434] 
[17:36:40.435] getGlobalsAndPackages() ... DONE
[17:36:40.435]  - globals found/used: [n=1] ‘FUN’
[17:36:40.435]  - needed namespaces: [n=0] 
[17:36:40.435] Finding globals ... DONE
[17:36:40.435]  - use_args: TRUE
[17:36:40.435]  - Getting '...' globals ...
[17:36:40.435] resolve() on list ...
[17:36:40.435]  recursive: 0
[17:36:40.435]  length: 1
[17:36:40.436]  elements: ‘...’
[17:36:40.436]  length: 0 (resolved future 1)
[17:36:40.436] resolve() on list ... DONE
[17:36:40.436]    - '...' content: [n=0] 
[17:36:40.436] List of 1
[17:36:40.436]  $ ...: list()
[17:36:40.436]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.436]  - attr(*, "where")=List of 1
[17:36:40.436]   ..$ ...:<environment: 0x5622fba63a70> 
[17:36:40.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.436]  - attr(*, "resolved")= logi TRUE
[17:36:40.436]  - attr(*, "total_size")= num NA
[17:36:40.438]  - Getting '...' globals ... DONE
[17:36:40.438] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:40.439] List of 2
[17:36:40.439]  $ ...future.FUN:function (object, ...)  
[17:36:40.439]  $ ...          : list()
[17:36:40.439]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.439]  - attr(*, "where")=List of 2
[17:36:40.439]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.439]   ..$ ...          :<environment: 0x5622fba63a70> 
[17:36:40.439]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.439]  - attr(*, "resolved")= logi FALSE
[17:36:40.439]  - attr(*, "total_size")= num 1240
[17:36:40.443] Packages to be attached in all futures: [n=0] 
[17:36:40.443] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.443] Number of futures (= number of chunks): 1
[17:36:40.443] Launching 1 futures (chunks) ...
[17:36:40.444] Chunk #1 of 1 ...
[17:36:40.444]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.444] getGlobalsAndPackages() ...
[17:36:40.444] Searching for globals...
[17:36:40.444] 
[17:36:40.445] Searching for globals ... DONE
[17:36:40.445] - globals: [0] <none>
[17:36:40.445] getGlobalsAndPackages() ... DONE
[17:36:40.445]    + additional globals found: [n=0] 
[17:36:40.445]    + additional namespaces needed: [n=0] 
[17:36:40.445]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.445]  - seeds: <none>
[17:36:40.445]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.445] getGlobalsAndPackages() ...
[17:36:40.446] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.446] Resolving globals: FALSE
[17:36:40.446] Tweak future expression to call with '...' arguments ...
[17:36:40.446] {
[17:36:40.446]     do.call(function(...) {
[17:36:40.446]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.446]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.446]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.446]             on.exit(options(oopts), add = TRUE)
[17:36:40.446]         }
[17:36:40.446]         {
[17:36:40.446]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.446]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.446]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.446]             })
[17:36:40.446]         }
[17:36:40.446]     }, args = future.call.arguments)
[17:36:40.446] }
[17:36:40.446] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.447] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.447] 
[17:36:40.447] getGlobalsAndPackages() ... DONE
[17:36:40.447] run() for ‘Future’ ...
[17:36:40.447] - state: ‘created’
[17:36:40.447] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:36:40.448] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.448] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:36:40.448]   - Field: ‘label’
[17:36:40.448]   - Field: ‘local’
[17:36:40.448]   - Field: ‘owner’
[17:36:40.448]   - Field: ‘envir’
[17:36:40.448]   - Field: ‘packages’
[17:36:40.448]   - Field: ‘gc’
[17:36:40.448]   - Field: ‘conditions’
[17:36:40.448]   - Field: ‘expr’
[17:36:40.449]   - Field: ‘uuid’
[17:36:40.449]   - Field: ‘seed’
[17:36:40.449]   - Field: ‘version’
[17:36:40.449]   - Field: ‘result’
[17:36:40.449]   - Field: ‘asynchronous’
[17:36:40.449]   - Field: ‘calls’
[17:36:40.449]   - Field: ‘globals’
[17:36:40.449]   - Field: ‘stdout’
[17:36:40.449]   - Field: ‘earlySignal’
[17:36:40.449]   - Field: ‘lazy’
[17:36:40.449]   - Field: ‘state’
[17:36:40.450] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:36:40.450] - Launch lazy future ...
[17:36:40.450] Packages needed by the future expression (n = 0): <none>
[17:36:40.450] Packages needed by future strategies (n = 0): <none>
[17:36:40.450] {
[17:36:40.450]     {
[17:36:40.450]         {
[17:36:40.450]             ...future.startTime <- base::Sys.time()
[17:36:40.450]             {
[17:36:40.450]                 {
[17:36:40.450]                   {
[17:36:40.450]                     base::local({
[17:36:40.450]                       has_future <- base::requireNamespace("future", 
[17:36:40.450]                         quietly = TRUE)
[17:36:40.450]                       if (has_future) {
[17:36:40.450]                         ns <- base::getNamespace("future")
[17:36:40.450]                         version <- ns[[".package"]][["version"]]
[17:36:40.450]                         if (is.null(version)) 
[17:36:40.450]                           version <- utils::packageVersion("future")
[17:36:40.450]                       }
[17:36:40.450]                       else {
[17:36:40.450]                         version <- NULL
[17:36:40.450]                       }
[17:36:40.450]                       if (!has_future || version < "1.8.0") {
[17:36:40.450]                         info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.450]                           "", base::R.version$version.string), 
[17:36:40.450]                           platform = base::sprintf("%s (%s-bit)", 
[17:36:40.450]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.450]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.450]                             "release", "version")], collapse = " "), 
[17:36:40.450]                           hostname = base::Sys.info()[["nodename"]])
[17:36:40.450]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.450]                           info)
[17:36:40.450]                         info <- base::paste(info, collapse = "; ")
[17:36:40.450]                         if (!has_future) {
[17:36:40.450]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.450]                             info)
[17:36:40.450]                         }
[17:36:40.450]                         else {
[17:36:40.450]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.450]                             info, version)
[17:36:40.450]                         }
[17:36:40.450]                         base::stop(msg)
[17:36:40.450]                       }
[17:36:40.450]                     })
[17:36:40.450]                   }
[17:36:40.450]                   ...future.strategy.old <- future::plan("list")
[17:36:40.450]                   options(future.plan = NULL)
[17:36:40.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.450]                 }
[17:36:40.450]                 ...future.workdir <- getwd()
[17:36:40.450]             }
[17:36:40.450]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.450]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.450]         }
[17:36:40.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:40.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.450]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.450]             base::names(...future.oldOptions))
[17:36:40.450]     }
[17:36:40.450]     if (FALSE) {
[17:36:40.450]     }
[17:36:40.450]     else {
[17:36:40.450]         if (TRUE) {
[17:36:40.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.450]                 open = "w")
[17:36:40.450]         }
[17:36:40.450]         else {
[17:36:40.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.450]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.450]         }
[17:36:40.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.450]             base::sink(type = "output", split = FALSE)
[17:36:40.450]             base::close(...future.stdout)
[17:36:40.450]         }, add = TRUE)
[17:36:40.450]     }
[17:36:40.450]     ...future.frame <- base::sys.nframe()
[17:36:40.450]     ...future.conditions <- base::list()
[17:36:40.450]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.450]     if (FALSE) {
[17:36:40.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.450]     }
[17:36:40.450]     ...future.result <- base::tryCatch({
[17:36:40.450]         base::withCallingHandlers({
[17:36:40.450]             ...future.value <- base::withVisible(base::local({
[17:36:40.450]                 do.call(function(...) {
[17:36:40.450]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.450]                   if (!identical(...future.globals.maxSize.org, 
[17:36:40.450]                     ...future.globals.maxSize)) {
[17:36:40.450]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.450]                     on.exit(options(oopts), add = TRUE)
[17:36:40.450]                   }
[17:36:40.450]                   {
[17:36:40.450]                     lapply(seq_along(...future.elements_ii), 
[17:36:40.450]                       FUN = function(jj) {
[17:36:40.450]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.450]                         ...future.FUN(...future.X_jj, ...)
[17:36:40.450]                       })
[17:36:40.450]                   }
[17:36:40.450]                 }, args = future.call.arguments)
[17:36:40.450]             }))
[17:36:40.450]             future::FutureResult(value = ...future.value$value, 
[17:36:40.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.450]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.450]                     ...future.globalenv.names))
[17:36:40.450]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.450]         }, condition = base::local({
[17:36:40.450]             c <- base::c
[17:36:40.450]             inherits <- base::inherits
[17:36:40.450]             invokeRestart <- base::invokeRestart
[17:36:40.450]             length <- base::length
[17:36:40.450]             list <- base::list
[17:36:40.450]             seq.int <- base::seq.int
[17:36:40.450]             signalCondition <- base::signalCondition
[17:36:40.450]             sys.calls <- base::sys.calls
[17:36:40.450]             `[[` <- base::`[[`
[17:36:40.450]             `+` <- base::`+`
[17:36:40.450]             `<<-` <- base::`<<-`
[17:36:40.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.450]                   3L)]
[17:36:40.450]             }
[17:36:40.450]             function(cond) {
[17:36:40.450]                 is_error <- inherits(cond, "error")
[17:36:40.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.450]                   NULL)
[17:36:40.450]                 if (is_error) {
[17:36:40.450]                   sessionInformation <- function() {
[17:36:40.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.450]                       search = base::search(), system = base::Sys.info())
[17:36:40.450]                   }
[17:36:40.450]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.450]                     cond$call), session = sessionInformation(), 
[17:36:40.450]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.450]                   signalCondition(cond)
[17:36:40.450]                 }
[17:36:40.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.450]                 "immediateCondition"))) {
[17:36:40.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.450]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.450]                   if (TRUE && !signal) {
[17:36:40.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.450]                     {
[17:36:40.450]                       inherits <- base::inherits
[17:36:40.450]                       invokeRestart <- base::invokeRestart
[17:36:40.450]                       is.null <- base::is.null
[17:36:40.450]                       muffled <- FALSE
[17:36:40.450]                       if (inherits(cond, "message")) {
[17:36:40.450]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.450]                         if (muffled) 
[17:36:40.450]                           invokeRestart("muffleMessage")
[17:36:40.450]                       }
[17:36:40.450]                       else if (inherits(cond, "warning")) {
[17:36:40.450]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.450]                         if (muffled) 
[17:36:40.450]                           invokeRestart("muffleWarning")
[17:36:40.450]                       }
[17:36:40.450]                       else if (inherits(cond, "condition")) {
[17:36:40.450]                         if (!is.null(pattern)) {
[17:36:40.450]                           computeRestarts <- base::computeRestarts
[17:36:40.450]                           grepl <- base::grepl
[17:36:40.450]                           restarts <- computeRestarts(cond)
[17:36:40.450]                           for (restart in restarts) {
[17:36:40.450]                             name <- restart$name
[17:36:40.450]                             if (is.null(name)) 
[17:36:40.450]                               next
[17:36:40.450]                             if (!grepl(pattern, name)) 
[17:36:40.450]                               next
[17:36:40.450]                             invokeRestart(restart)
[17:36:40.450]                             muffled <- TRUE
[17:36:40.450]                             break
[17:36:40.450]                           }
[17:36:40.450]                         }
[17:36:40.450]                       }
[17:36:40.450]                       invisible(muffled)
[17:36:40.450]                     }
[17:36:40.450]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.450]                   }
[17:36:40.450]                 }
[17:36:40.450]                 else {
[17:36:40.450]                   if (TRUE) {
[17:36:40.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.450]                     {
[17:36:40.450]                       inherits <- base::inherits
[17:36:40.450]                       invokeRestart <- base::invokeRestart
[17:36:40.450]                       is.null <- base::is.null
[17:36:40.450]                       muffled <- FALSE
[17:36:40.450]                       if (inherits(cond, "message")) {
[17:36:40.450]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.450]                         if (muffled) 
[17:36:40.450]                           invokeRestart("muffleMessage")
[17:36:40.450]                       }
[17:36:40.450]                       else if (inherits(cond, "warning")) {
[17:36:40.450]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.450]                         if (muffled) 
[17:36:40.450]                           invokeRestart("muffleWarning")
[17:36:40.450]                       }
[17:36:40.450]                       else if (inherits(cond, "condition")) {
[17:36:40.450]                         if (!is.null(pattern)) {
[17:36:40.450]                           computeRestarts <- base::computeRestarts
[17:36:40.450]                           grepl <- base::grepl
[17:36:40.450]                           restarts <- computeRestarts(cond)
[17:36:40.450]                           for (restart in restarts) {
[17:36:40.450]                             name <- restart$name
[17:36:40.450]                             if (is.null(name)) 
[17:36:40.450]                               next
[17:36:40.450]                             if (!grepl(pattern, name)) 
[17:36:40.450]                               next
[17:36:40.450]                             invokeRestart(restart)
[17:36:40.450]                             muffled <- TRUE
[17:36:40.450]                             break
[17:36:40.450]                           }
[17:36:40.450]                         }
[17:36:40.450]                       }
[17:36:40.450]                       invisible(muffled)
[17:36:40.450]                     }
[17:36:40.450]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.450]                   }
[17:36:40.450]                 }
[17:36:40.450]             }
[17:36:40.450]         }))
[17:36:40.450]     }, error = function(ex) {
[17:36:40.450]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.450]                 ...future.rng), started = ...future.startTime, 
[17:36:40.450]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.450]             version = "1.8"), class = "FutureResult")
[17:36:40.450]     }, finally = {
[17:36:40.450]         if (!identical(...future.workdir, getwd())) 
[17:36:40.450]             setwd(...future.workdir)
[17:36:40.450]         {
[17:36:40.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.450]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.450]             }
[17:36:40.450]             base::options(...future.oldOptions)
[17:36:40.450]             if (.Platform$OS.type == "windows") {
[17:36:40.450]                 old_names <- names(...future.oldEnvVars)
[17:36:40.450]                 envs <- base::Sys.getenv()
[17:36:40.450]                 names <- names(envs)
[17:36:40.450]                 common <- intersect(names, old_names)
[17:36:40.450]                 added <- setdiff(names, old_names)
[17:36:40.450]                 removed <- setdiff(old_names, names)
[17:36:40.450]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.450]                   envs[common]]
[17:36:40.450]                 NAMES <- toupper(changed)
[17:36:40.450]                 args <- list()
[17:36:40.450]                 for (kk in seq_along(NAMES)) {
[17:36:40.450]                   name <- changed[[kk]]
[17:36:40.450]                   NAME <- NAMES[[kk]]
[17:36:40.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.450]                     next
[17:36:40.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.450]                 }
[17:36:40.450]                 NAMES <- toupper(added)
[17:36:40.450]                 for (kk in seq_along(NAMES)) {
[17:36:40.450]                   name <- added[[kk]]
[17:36:40.450]                   NAME <- NAMES[[kk]]
[17:36:40.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.450]                     next
[17:36:40.450]                   args[[name]] <- ""
[17:36:40.450]                 }
[17:36:40.450]                 NAMES <- toupper(removed)
[17:36:40.450]                 for (kk in seq_along(NAMES)) {
[17:36:40.450]                   name <- removed[[kk]]
[17:36:40.450]                   NAME <- NAMES[[kk]]
[17:36:40.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.450]                     next
[17:36:40.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.450]                 }
[17:36:40.450]                 if (length(args) > 0) 
[17:36:40.450]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.450]             }
[17:36:40.450]             else {
[17:36:40.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.450]             }
[17:36:40.450]             {
[17:36:40.450]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.450]                   0L) {
[17:36:40.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.450]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.450]                   base::options(opts)
[17:36:40.450]                 }
[17:36:40.450]                 {
[17:36:40.450]                   {
[17:36:40.450]                     NULL
[17:36:40.450]                     RNGkind("Mersenne-Twister")
[17:36:40.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:36:40.450]                       inherits = FALSE)
[17:36:40.450]                   }
[17:36:40.450]                   options(future.plan = NULL)
[17:36:40.450]                   if (is.na(NA_character_)) 
[17:36:40.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.450]                     .init = FALSE)
[17:36:40.450]                 }
[17:36:40.450]             }
[17:36:40.450]         }
[17:36:40.450]     })
[17:36:40.450]     if (TRUE) {
[17:36:40.450]         base::sink(type = "output", split = FALSE)
[17:36:40.450]         if (TRUE) {
[17:36:40.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.450]         }
[17:36:40.450]         else {
[17:36:40.450]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.450]         }
[17:36:40.450]         base::close(...future.stdout)
[17:36:40.450]         ...future.stdout <- NULL
[17:36:40.450]     }
[17:36:40.450]     ...future.result$conditions <- ...future.conditions
[17:36:40.450]     ...future.result$finished <- base::Sys.time()
[17:36:40.450]     ...future.result
[17:36:40.450] }
[17:36:40.452] assign_globals() ...
[17:36:40.452] List of 5
[17:36:40.452]  $ ...future.FUN            :function (object, ...)  
[17:36:40.452]  $ future.call.arguments    : list()
[17:36:40.452]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.452]  $ ...future.elements_ii    :List of 3
[17:36:40.452]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.452]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.452]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.452]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.452]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.452]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.452]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.452]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:40.452]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.452]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.452]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.452]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:40.452]  $ ...future.seeds_ii       : NULL
[17:36:40.452]  $ ...future.globals.maxSize: NULL
[17:36:40.452]  - attr(*, "where")=List of 5
[17:36:40.452]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.452]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.452]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.452]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.452]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.452]  - attr(*, "resolved")= logi FALSE
[17:36:40.452]  - attr(*, "total_size")= num 1240
[17:36:40.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.452]  - attr(*, "already-done")= logi TRUE
[17:36:40.460] - copied ‘...future.FUN’ to environment
[17:36:40.460] - copied ‘future.call.arguments’ to environment
[17:36:40.461] - copied ‘...future.elements_ii’ to environment
[17:36:40.461] - copied ‘...future.seeds_ii’ to environment
[17:36:40.461] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.461] assign_globals() ... done
[17:36:40.461] plan(): Setting new future strategy stack:
[17:36:40.461] List of future strategies:
[17:36:40.461] 1. sequential:
[17:36:40.461]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.461]    - tweaked: FALSE
[17:36:40.461]    - call: NULL
[17:36:40.462] plan(): nbrOfWorkers() = 1
[17:36:40.466] plan(): Setting new future strategy stack:
[17:36:40.466] List of future strategies:
[17:36:40.466] 1. sequential:
[17:36:40.466]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.466]    - tweaked: FALSE
[17:36:40.466]    - call: plan(strategy)
[17:36:40.466] plan(): nbrOfWorkers() = 1
[17:36:40.467] SequentialFuture started (and completed)
[17:36:40.467] - Launch lazy future ... done
[17:36:40.467] run() for ‘SequentialFuture’ ... done
[17:36:40.467] Created future:
[17:36:40.467] SequentialFuture:
[17:36:40.467] Label: ‘future_by-1’
[17:36:40.467] Expression:
[17:36:40.467] {
[17:36:40.467]     do.call(function(...) {
[17:36:40.467]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.467]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.467]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.467]             on.exit(options(oopts), add = TRUE)
[17:36:40.467]         }
[17:36:40.467]         {
[17:36:40.467]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.467]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.467]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.467]             })
[17:36:40.467]         }
[17:36:40.467]     }, args = future.call.arguments)
[17:36:40.467] }
[17:36:40.467] Lazy evaluation: FALSE
[17:36:40.467] Asynchronous evaluation: FALSE
[17:36:40.467] Local evaluation: TRUE
[17:36:40.467] Environment: 0x5622fb9c10d8
[17:36:40.467] Capture standard output: TRUE
[17:36:40.467] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.467] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.467] Packages: <none>
[17:36:40.467] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.467] Resolved: TRUE
[17:36:40.467] Value: 5.37 KiB of class ‘list’
[17:36:40.467] Early signaling: FALSE
[17:36:40.467] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.467] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:36:40.469] Chunk #1 of 1 ... DONE
[17:36:40.469] Launching 1 futures (chunks) ... DONE
[17:36:40.469] Resolving 1 futures (chunks) ...
[17:36:40.469] resolve() on list ...
[17:36:40.469]  recursive: 0
[17:36:40.469]  length: 1
[17:36:40.469] 
[17:36:40.469] resolved() for ‘SequentialFuture’ ...
[17:36:40.470] - state: ‘finished’
[17:36:40.470] - run: TRUE
[17:36:40.470] - result: ‘FutureResult’
[17:36:40.470] resolved() for ‘SequentialFuture’ ... done
[17:36:40.470] Future #1
[17:36:40.470] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:36:40.470] - nx: 1
[17:36:40.470] - relay: TRUE
[17:36:40.470] - stdout: TRUE
[17:36:40.470] - signal: TRUE
[17:36:40.470] - resignal: FALSE
[17:36:40.471] - force: TRUE
[17:36:40.471] - relayed: [n=1] FALSE
[17:36:40.471] - queued futures: [n=1] FALSE
[17:36:40.471]  - until=1
[17:36:40.471]  - relaying element #1
[17:36:40.471] - relayed: [n=1] TRUE
[17:36:40.471] - queued futures: [n=1] TRUE
[17:36:40.471] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:36:40.471]  length: 0 (resolved future 1)
[17:36:40.471] Relaying remaining futures
[17:36:40.472] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.472] - nx: 1
[17:36:40.472] - relay: TRUE
[17:36:40.472] - stdout: TRUE
[17:36:40.472] - signal: TRUE
[17:36:40.472] - resignal: FALSE
[17:36:40.472] - force: TRUE
[17:36:40.472] - relayed: [n=1] TRUE
[17:36:40.472] - queued futures: [n=1] TRUE
 - flush all
[17:36:40.472] - relayed: [n=1] TRUE
[17:36:40.473] - queued futures: [n=1] TRUE
[17:36:40.473] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.473] resolve() on list ... DONE
[17:36:40.473]  - Number of value chunks collected: 1
[17:36:40.473] Resolving 1 futures (chunks) ... DONE
[17:36:40.473] Reducing values from 1 chunks ...
[17:36:40.473]  - Number of values collected after concatenation: 3
[17:36:40.473]  - Number of values expected: 3
[17:36:40.473] Reducing values from 1 chunks ... DONE
[17:36:40.473] future_lapply() ... DONE
[17:36:40.473] future_by_internal() ... DONE
[17:36:40.474] future_by_internal() ...
- plan('multicore') ...
[17:36:40.475] plan(): Setting new future strategy stack:
[17:36:40.475] List of future strategies:
[17:36:40.475] 1. multicore:
[17:36:40.475]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:40.475]    - tweaked: FALSE
[17:36:40.475]    - call: plan(strategy)
[17:36:40.479] plan(): nbrOfWorkers() = 2
[17:36:40.479] future_by_internal() ...
[17:36:40.479] future_lapply() ...
[17:36:40.484] Number of chunks: 2
[17:36:40.484] getGlobalsAndPackagesXApply() ...
[17:36:40.484]  - future.globals: TRUE
[17:36:40.484] getGlobalsAndPackages() ...
[17:36:40.484] Searching for globals...
[17:36:40.485] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:40.485] Searching for globals ... DONE
[17:36:40.485] Resolving globals: FALSE
[17:36:40.486] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:40.486] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:40.486] - globals: [1] ‘FUN’
[17:36:40.486] 
[17:36:40.486] getGlobalsAndPackages() ... DONE
[17:36:40.487]  - globals found/used: [n=1] ‘FUN’
[17:36:40.487]  - needed namespaces: [n=0] 
[17:36:40.487] Finding globals ... DONE
[17:36:40.487]  - use_args: TRUE
[17:36:40.487]  - Getting '...' globals ...
[17:36:40.487] resolve() on list ...
[17:36:40.487]  recursive: 0
[17:36:40.487]  length: 1
[17:36:40.488]  elements: ‘...’
[17:36:40.488]  length: 0 (resolved future 1)
[17:36:40.488] resolve() on list ... DONE
[17:36:40.488]    - '...' content: [n=0] 
[17:36:40.488] List of 1
[17:36:40.488]  $ ...: list()
[17:36:40.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.488]  - attr(*, "where")=List of 1
[17:36:40.488]   ..$ ...:<environment: 0x5622fbd432c8> 
[17:36:40.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.488]  - attr(*, "resolved")= logi TRUE
[17:36:40.488]  - attr(*, "total_size")= num NA
[17:36:40.491]  - Getting '...' globals ... DONE
[17:36:40.493] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:40.493] List of 2
[17:36:40.493]  $ ...future.FUN:function (object, ...)  
[17:36:40.493]  $ ...          : list()
[17:36:40.493]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.493]  - attr(*, "where")=List of 2
[17:36:40.493]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.493]   ..$ ...          :<environment: 0x5622fbd432c8> 
[17:36:40.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.493]  - attr(*, "resolved")= logi FALSE
[17:36:40.493]  - attr(*, "total_size")= num 1240
[17:36:40.496] Packages to be attached in all futures: [n=0] 
[17:36:40.496] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.497] Number of futures (= number of chunks): 2
[17:36:40.497] Launching 2 futures (chunks) ...
[17:36:40.497] Chunk #1 of 2 ...
[17:36:40.497]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.497] getGlobalsAndPackages() ...
[17:36:40.497] Searching for globals...
[17:36:40.498] 
[17:36:40.498] Searching for globals ... DONE
[17:36:40.498] - globals: [0] <none>
[17:36:40.498] getGlobalsAndPackages() ... DONE
[17:36:40.498]    + additional globals found: [n=0] 
[17:36:40.498]    + additional namespaces needed: [n=0] 
[17:36:40.498]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.498]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:40.498]  - seeds: <none>
[17:36:40.498]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.499] getGlobalsAndPackages() ...
[17:36:40.499] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.499] Resolving globals: FALSE
[17:36:40.499] Tweak future expression to call with '...' arguments ...
[17:36:40.499] {
[17:36:40.499]     do.call(function(...) {
[17:36:40.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.499]             on.exit(options(oopts), add = TRUE)
[17:36:40.499]         }
[17:36:40.499]         {
[17:36:40.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.499]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.499]             })
[17:36:40.499]         }
[17:36:40.499]     }, args = future.call.arguments)
[17:36:40.499] }
[17:36:40.499] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.500] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.500] 
[17:36:40.500] getGlobalsAndPackages() ... DONE
[17:36:40.500] run() for ‘Future’ ...
[17:36:40.500] - state: ‘created’
[17:36:40.500] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.504] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.504] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:40.504]   - Field: ‘label’
[17:36:40.505]   - Field: ‘local’
[17:36:40.505]   - Field: ‘owner’
[17:36:40.505]   - Field: ‘envir’
[17:36:40.505]   - Field: ‘workers’
[17:36:40.505]   - Field: ‘packages’
[17:36:40.505]   - Field: ‘gc’
[17:36:40.505]   - Field: ‘job’
[17:36:40.505]   - Field: ‘conditions’
[17:36:40.505]   - Field: ‘expr’
[17:36:40.505]   - Field: ‘uuid’
[17:36:40.505]   - Field: ‘seed’
[17:36:40.506]   - Field: ‘version’
[17:36:40.506]   - Field: ‘result’
[17:36:40.506]   - Field: ‘asynchronous’
[17:36:40.506]   - Field: ‘calls’
[17:36:40.506]   - Field: ‘globals’
[17:36:40.506]   - Field: ‘stdout’
[17:36:40.506]   - Field: ‘earlySignal’
[17:36:40.506]   - Field: ‘lazy’
[17:36:40.506]   - Field: ‘state’
[17:36:40.506] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:40.506] - Launch lazy future ...
[17:36:40.507] Packages needed by the future expression (n = 0): <none>
[17:36:40.508] Packages needed by future strategies (n = 0): <none>
[17:36:40.508] {
[17:36:40.508]     {
[17:36:40.508]         {
[17:36:40.508]             ...future.startTime <- base::Sys.time()
[17:36:40.508]             {
[17:36:40.508]                 {
[17:36:40.508]                   {
[17:36:40.508]                     {
[17:36:40.508]                       base::local({
[17:36:40.508]                         has_future <- base::requireNamespace("future", 
[17:36:40.508]                           quietly = TRUE)
[17:36:40.508]                         if (has_future) {
[17:36:40.508]                           ns <- base::getNamespace("future")
[17:36:40.508]                           version <- ns[[".package"]][["version"]]
[17:36:40.508]                           if (is.null(version)) 
[17:36:40.508]                             version <- utils::packageVersion("future")
[17:36:40.508]                         }
[17:36:40.508]                         else {
[17:36:40.508]                           version <- NULL
[17:36:40.508]                         }
[17:36:40.508]                         if (!has_future || version < "1.8.0") {
[17:36:40.508]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.508]                             "", base::R.version$version.string), 
[17:36:40.508]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:40.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.508]                               "release", "version")], collapse = " "), 
[17:36:40.508]                             hostname = base::Sys.info()[["nodename"]])
[17:36:40.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.508]                             info)
[17:36:40.508]                           info <- base::paste(info, collapse = "; ")
[17:36:40.508]                           if (!has_future) {
[17:36:40.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.508]                               info)
[17:36:40.508]                           }
[17:36:40.508]                           else {
[17:36:40.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.508]                               info, version)
[17:36:40.508]                           }
[17:36:40.508]                           base::stop(msg)
[17:36:40.508]                         }
[17:36:40.508]                       })
[17:36:40.508]                     }
[17:36:40.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:40.508]                     base::options(mc.cores = 1L)
[17:36:40.508]                   }
[17:36:40.508]                   ...future.strategy.old <- future::plan("list")
[17:36:40.508]                   options(future.plan = NULL)
[17:36:40.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.508]                 }
[17:36:40.508]                 ...future.workdir <- getwd()
[17:36:40.508]             }
[17:36:40.508]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.508]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.508]         }
[17:36:40.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.508]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:40.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.508]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.508]             base::names(...future.oldOptions))
[17:36:40.508]     }
[17:36:40.508]     if (FALSE) {
[17:36:40.508]     }
[17:36:40.508]     else {
[17:36:40.508]         if (TRUE) {
[17:36:40.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.508]                 open = "w")
[17:36:40.508]         }
[17:36:40.508]         else {
[17:36:40.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.508]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.508]         }
[17:36:40.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.508]             base::sink(type = "output", split = FALSE)
[17:36:40.508]             base::close(...future.stdout)
[17:36:40.508]         }, add = TRUE)
[17:36:40.508]     }
[17:36:40.508]     ...future.frame <- base::sys.nframe()
[17:36:40.508]     ...future.conditions <- base::list()
[17:36:40.508]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.508]     if (FALSE) {
[17:36:40.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.508]     }
[17:36:40.508]     ...future.result <- base::tryCatch({
[17:36:40.508]         base::withCallingHandlers({
[17:36:40.508]             ...future.value <- base::withVisible(base::local({
[17:36:40.508]                 withCallingHandlers({
[17:36:40.508]                   {
[17:36:40.508]                     do.call(function(...) {
[17:36:40.508]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.508]                       if (!identical(...future.globals.maxSize.org, 
[17:36:40.508]                         ...future.globals.maxSize)) {
[17:36:40.508]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.508]                         on.exit(options(oopts), add = TRUE)
[17:36:40.508]                       }
[17:36:40.508]                       {
[17:36:40.508]                         lapply(seq_along(...future.elements_ii), 
[17:36:40.508]                           FUN = function(jj) {
[17:36:40.508]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.508]                             ...future.FUN(...future.X_jj, ...)
[17:36:40.508]                           })
[17:36:40.508]                       }
[17:36:40.508]                     }, args = future.call.arguments)
[17:36:40.508]                   }
[17:36:40.508]                 }, immediateCondition = function(cond) {
[17:36:40.508]                   save_rds <- function (object, pathname, ...) 
[17:36:40.508]                   {
[17:36:40.508]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:40.508]                     if (file_test("-f", pathname_tmp)) {
[17:36:40.508]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.508]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:40.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.508]                         fi_tmp[["mtime"]])
[17:36:40.508]                     }
[17:36:40.508]                     tryCatch({
[17:36:40.508]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:40.508]                     }, error = function(ex) {
[17:36:40.508]                       msg <- conditionMessage(ex)
[17:36:40.508]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.508]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:40.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.508]                         fi_tmp[["mtime"]], msg)
[17:36:40.508]                       ex$message <- msg
[17:36:40.508]                       stop(ex)
[17:36:40.508]                     })
[17:36:40.508]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:40.508]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:40.508]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:40.508]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.508]                       fi <- file.info(pathname)
[17:36:40.508]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:40.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.508]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:40.508]                         fi[["size"]], fi[["mtime"]])
[17:36:40.508]                       stop(msg)
[17:36:40.508]                     }
[17:36:40.508]                     invisible(pathname)
[17:36:40.508]                   }
[17:36:40.508]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:40.508]                     rootPath = tempdir()) 
[17:36:40.508]                   {
[17:36:40.508]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:40.508]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:40.508]                       tmpdir = path, fileext = ".rds")
[17:36:40.508]                     save_rds(obj, file)
[17:36:40.508]                   }
[17:36:40.508]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:40.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.508]                   {
[17:36:40.508]                     inherits <- base::inherits
[17:36:40.508]                     invokeRestart <- base::invokeRestart
[17:36:40.508]                     is.null <- base::is.null
[17:36:40.508]                     muffled <- FALSE
[17:36:40.508]                     if (inherits(cond, "message")) {
[17:36:40.508]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:40.508]                       if (muffled) 
[17:36:40.508]                         invokeRestart("muffleMessage")
[17:36:40.508]                     }
[17:36:40.508]                     else if (inherits(cond, "warning")) {
[17:36:40.508]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:40.508]                       if (muffled) 
[17:36:40.508]                         invokeRestart("muffleWarning")
[17:36:40.508]                     }
[17:36:40.508]                     else if (inherits(cond, "condition")) {
[17:36:40.508]                       if (!is.null(pattern)) {
[17:36:40.508]                         computeRestarts <- base::computeRestarts
[17:36:40.508]                         grepl <- base::grepl
[17:36:40.508]                         restarts <- computeRestarts(cond)
[17:36:40.508]                         for (restart in restarts) {
[17:36:40.508]                           name <- restart$name
[17:36:40.508]                           if (is.null(name)) 
[17:36:40.508]                             next
[17:36:40.508]                           if (!grepl(pattern, name)) 
[17:36:40.508]                             next
[17:36:40.508]                           invokeRestart(restart)
[17:36:40.508]                           muffled <- TRUE
[17:36:40.508]                           break
[17:36:40.508]                         }
[17:36:40.508]                       }
[17:36:40.508]                     }
[17:36:40.508]                     invisible(muffled)
[17:36:40.508]                   }
[17:36:40.508]                   muffleCondition(cond)
[17:36:40.508]                 })
[17:36:40.508]             }))
[17:36:40.508]             future::FutureResult(value = ...future.value$value, 
[17:36:40.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.508]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.508]                     ...future.globalenv.names))
[17:36:40.508]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.508]         }, condition = base::local({
[17:36:40.508]             c <- base::c
[17:36:40.508]             inherits <- base::inherits
[17:36:40.508]             invokeRestart <- base::invokeRestart
[17:36:40.508]             length <- base::length
[17:36:40.508]             list <- base::list
[17:36:40.508]             seq.int <- base::seq.int
[17:36:40.508]             signalCondition <- base::signalCondition
[17:36:40.508]             sys.calls <- base::sys.calls
[17:36:40.508]             `[[` <- base::`[[`
[17:36:40.508]             `+` <- base::`+`
[17:36:40.508]             `<<-` <- base::`<<-`
[17:36:40.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.508]                   3L)]
[17:36:40.508]             }
[17:36:40.508]             function(cond) {
[17:36:40.508]                 is_error <- inherits(cond, "error")
[17:36:40.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.508]                   NULL)
[17:36:40.508]                 if (is_error) {
[17:36:40.508]                   sessionInformation <- function() {
[17:36:40.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.508]                       search = base::search(), system = base::Sys.info())
[17:36:40.508]                   }
[17:36:40.508]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.508]                     cond$call), session = sessionInformation(), 
[17:36:40.508]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.508]                   signalCondition(cond)
[17:36:40.508]                 }
[17:36:40.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.508]                 "immediateCondition"))) {
[17:36:40.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.508]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.508]                   if (TRUE && !signal) {
[17:36:40.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.508]                     {
[17:36:40.508]                       inherits <- base::inherits
[17:36:40.508]                       invokeRestart <- base::invokeRestart
[17:36:40.508]                       is.null <- base::is.null
[17:36:40.508]                       muffled <- FALSE
[17:36:40.508]                       if (inherits(cond, "message")) {
[17:36:40.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.508]                         if (muffled) 
[17:36:40.508]                           invokeRestart("muffleMessage")
[17:36:40.508]                       }
[17:36:40.508]                       else if (inherits(cond, "warning")) {
[17:36:40.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.508]                         if (muffled) 
[17:36:40.508]                           invokeRestart("muffleWarning")
[17:36:40.508]                       }
[17:36:40.508]                       else if (inherits(cond, "condition")) {
[17:36:40.508]                         if (!is.null(pattern)) {
[17:36:40.508]                           computeRestarts <- base::computeRestarts
[17:36:40.508]                           grepl <- base::grepl
[17:36:40.508]                           restarts <- computeRestarts(cond)
[17:36:40.508]                           for (restart in restarts) {
[17:36:40.508]                             name <- restart$name
[17:36:40.508]                             if (is.null(name)) 
[17:36:40.508]                               next
[17:36:40.508]                             if (!grepl(pattern, name)) 
[17:36:40.508]                               next
[17:36:40.508]                             invokeRestart(restart)
[17:36:40.508]                             muffled <- TRUE
[17:36:40.508]                             break
[17:36:40.508]                           }
[17:36:40.508]                         }
[17:36:40.508]                       }
[17:36:40.508]                       invisible(muffled)
[17:36:40.508]                     }
[17:36:40.508]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.508]                   }
[17:36:40.508]                 }
[17:36:40.508]                 else {
[17:36:40.508]                   if (TRUE) {
[17:36:40.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.508]                     {
[17:36:40.508]                       inherits <- base::inherits
[17:36:40.508]                       invokeRestart <- base::invokeRestart
[17:36:40.508]                       is.null <- base::is.null
[17:36:40.508]                       muffled <- FALSE
[17:36:40.508]                       if (inherits(cond, "message")) {
[17:36:40.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.508]                         if (muffled) 
[17:36:40.508]                           invokeRestart("muffleMessage")
[17:36:40.508]                       }
[17:36:40.508]                       else if (inherits(cond, "warning")) {
[17:36:40.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.508]                         if (muffled) 
[17:36:40.508]                           invokeRestart("muffleWarning")
[17:36:40.508]                       }
[17:36:40.508]                       else if (inherits(cond, "condition")) {
[17:36:40.508]                         if (!is.null(pattern)) {
[17:36:40.508]                           computeRestarts <- base::computeRestarts
[17:36:40.508]                           grepl <- base::grepl
[17:36:40.508]                           restarts <- computeRestarts(cond)
[17:36:40.508]                           for (restart in restarts) {
[17:36:40.508]                             name <- restart$name
[17:36:40.508]                             if (is.null(name)) 
[17:36:40.508]                               next
[17:36:40.508]                             if (!grepl(pattern, name)) 
[17:36:40.508]                               next
[17:36:40.508]                             invokeRestart(restart)
[17:36:40.508]                             muffled <- TRUE
[17:36:40.508]                             break
[17:36:40.508]                           }
[17:36:40.508]                         }
[17:36:40.508]                       }
[17:36:40.508]                       invisible(muffled)
[17:36:40.508]                     }
[17:36:40.508]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.508]                   }
[17:36:40.508]                 }
[17:36:40.508]             }
[17:36:40.508]         }))
[17:36:40.508]     }, error = function(ex) {
[17:36:40.508]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.508]                 ...future.rng), started = ...future.startTime, 
[17:36:40.508]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.508]             version = "1.8"), class = "FutureResult")
[17:36:40.508]     }, finally = {
[17:36:40.508]         if (!identical(...future.workdir, getwd())) 
[17:36:40.508]             setwd(...future.workdir)
[17:36:40.508]         {
[17:36:40.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.508]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.508]             }
[17:36:40.508]             base::options(...future.oldOptions)
[17:36:40.508]             if (.Platform$OS.type == "windows") {
[17:36:40.508]                 old_names <- names(...future.oldEnvVars)
[17:36:40.508]                 envs <- base::Sys.getenv()
[17:36:40.508]                 names <- names(envs)
[17:36:40.508]                 common <- intersect(names, old_names)
[17:36:40.508]                 added <- setdiff(names, old_names)
[17:36:40.508]                 removed <- setdiff(old_names, names)
[17:36:40.508]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.508]                   envs[common]]
[17:36:40.508]                 NAMES <- toupper(changed)
[17:36:40.508]                 args <- list()
[17:36:40.508]                 for (kk in seq_along(NAMES)) {
[17:36:40.508]                   name <- changed[[kk]]
[17:36:40.508]                   NAME <- NAMES[[kk]]
[17:36:40.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.508]                     next
[17:36:40.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.508]                 }
[17:36:40.508]                 NAMES <- toupper(added)
[17:36:40.508]                 for (kk in seq_along(NAMES)) {
[17:36:40.508]                   name <- added[[kk]]
[17:36:40.508]                   NAME <- NAMES[[kk]]
[17:36:40.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.508]                     next
[17:36:40.508]                   args[[name]] <- ""
[17:36:40.508]                 }
[17:36:40.508]                 NAMES <- toupper(removed)
[17:36:40.508]                 for (kk in seq_along(NAMES)) {
[17:36:40.508]                   name <- removed[[kk]]
[17:36:40.508]                   NAME <- NAMES[[kk]]
[17:36:40.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.508]                     next
[17:36:40.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.508]                 }
[17:36:40.508]                 if (length(args) > 0) 
[17:36:40.508]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.508]             }
[17:36:40.508]             else {
[17:36:40.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.508]             }
[17:36:40.508]             {
[17:36:40.508]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.508]                   0L) {
[17:36:40.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.508]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.508]                   base::options(opts)
[17:36:40.508]                 }
[17:36:40.508]                 {
[17:36:40.508]                   {
[17:36:40.508]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:40.508]                     NULL
[17:36:40.508]                   }
[17:36:40.508]                   options(future.plan = NULL)
[17:36:40.508]                   if (is.na(NA_character_)) 
[17:36:40.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.508]                     .init = FALSE)
[17:36:40.508]                 }
[17:36:40.508]             }
[17:36:40.508]         }
[17:36:40.508]     })
[17:36:40.508]     if (TRUE) {
[17:36:40.508]         base::sink(type = "output", split = FALSE)
[17:36:40.508]         if (TRUE) {
[17:36:40.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.508]         }
[17:36:40.508]         else {
[17:36:40.508]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.508]         }
[17:36:40.508]         base::close(...future.stdout)
[17:36:40.508]         ...future.stdout <- NULL
[17:36:40.508]     }
[17:36:40.508]     ...future.result$conditions <- ...future.conditions
[17:36:40.508]     ...future.result$finished <- base::Sys.time()
[17:36:40.508]     ...future.result
[17:36:40.508] }
[17:36:40.510] assign_globals() ...
[17:36:40.510] List of 5
[17:36:40.510]  $ ...future.FUN            :function (object, ...)  
[17:36:40.510]  $ future.call.arguments    : list()
[17:36:40.510]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.510]  $ ...future.elements_ii    :List of 1
[17:36:40.510]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:40.510]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.510]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.510]  $ ...future.seeds_ii       : NULL
[17:36:40.510]  $ ...future.globals.maxSize: NULL
[17:36:40.510]  - attr(*, "where")=List of 5
[17:36:40.510]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.510]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.510]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.510]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.510]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.510]  - attr(*, "resolved")= logi FALSE
[17:36:40.510]  - attr(*, "total_size")= num 1240
[17:36:40.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.510]  - attr(*, "already-done")= logi TRUE
[17:36:40.516] - copied ‘...future.FUN’ to environment
[17:36:40.516] - copied ‘future.call.arguments’ to environment
[17:36:40.516] - copied ‘...future.elements_ii’ to environment
[17:36:40.516] - copied ‘...future.seeds_ii’ to environment
[17:36:40.516] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.516] assign_globals() ... done
[17:36:40.517] requestCore(): workers = 2
[17:36:40.519] MulticoreFuture started
[17:36:40.520] - Launch lazy future ... done
[17:36:40.520] plan(): Setting new future strategy stack:
[17:36:40.520] run() for ‘MulticoreFuture’ ... done
[17:36:40.521] Created future:
[17:36:40.520] List of future strategies:
[17:36:40.520] 1. sequential:
[17:36:40.520]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.520]    - tweaked: FALSE
[17:36:40.520]    - call: NULL
[17:36:40.526] plan(): nbrOfWorkers() = 1
[17:36:40.531] plan(): Setting new future strategy stack:
[17:36:40.531] List of future strategies:
[17:36:40.531] 1. multicore:
[17:36:40.531]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:40.531]    - tweaked: FALSE
[17:36:40.531]    - call: plan(strategy)
[17:36:40.538] plan(): nbrOfWorkers() = 2
[17:36:40.521] MulticoreFuture:
[17:36:40.521] Label: ‘future_by-1’
[17:36:40.521] Expression:
[17:36:40.521] {
[17:36:40.521]     do.call(function(...) {
[17:36:40.521]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.521]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.521]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.521]             on.exit(options(oopts), add = TRUE)
[17:36:40.521]         }
[17:36:40.521]         {
[17:36:40.521]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.521]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.521]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.521]             })
[17:36:40.521]         }
[17:36:40.521]     }, args = future.call.arguments)
[17:36:40.521] }
[17:36:40.521] Lazy evaluation: FALSE
[17:36:40.521] Asynchronous evaluation: TRUE
[17:36:40.521] Local evaluation: TRUE
[17:36:40.521] Environment: R_GlobalEnv
[17:36:40.521] Capture standard output: TRUE
[17:36:40.521] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.521] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.521] Packages: <none>
[17:36:40.521] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.521] Resolved: TRUE
[17:36:40.521] Value: <not collected>
[17:36:40.521] Conditions captured: <none>
[17:36:40.521] Early signaling: FALSE
[17:36:40.521] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.521] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.540] Chunk #1 of 2 ... DONE
[17:36:40.540] Chunk #2 of 2 ...
[17:36:40.540]  - Finding globals in 'X' for chunk #2 ...
[17:36:40.540] getGlobalsAndPackages() ...
[17:36:40.541] Searching for globals...
[17:36:40.542] 
[17:36:40.542] Searching for globals ... DONE
[17:36:40.542] - globals: [0] <none>
[17:36:40.542] getGlobalsAndPackages() ... DONE
[17:36:40.542]    + additional globals found: [n=0] 
[17:36:40.543]    + additional namespaces needed: [n=0] 
[17:36:40.543]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:40.543]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:40.543]  - seeds: <none>
[17:36:40.543]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.544] getGlobalsAndPackages() ...
[17:36:40.544] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.544] Resolving globals: FALSE
[17:36:40.544] Tweak future expression to call with '...' arguments ...
[17:36:40.545] {
[17:36:40.545]     do.call(function(...) {
[17:36:40.545]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.545]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.545]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.545]             on.exit(options(oopts), add = TRUE)
[17:36:40.545]         }
[17:36:40.545]         {
[17:36:40.545]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.545]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.545]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.545]             })
[17:36:40.545]         }
[17:36:40.545]     }, args = future.call.arguments)
[17:36:40.545] }
[17:36:40.545] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.546] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.546] 
[17:36:40.546] getGlobalsAndPackages() ... DONE
[17:36:40.547] run() for ‘Future’ ...
[17:36:40.547] - state: ‘created’
[17:36:40.547] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.552] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:40.552]   - Field: ‘label’
[17:36:40.552]   - Field: ‘local’
[17:36:40.552]   - Field: ‘owner’
[17:36:40.552]   - Field: ‘envir’
[17:36:40.553]   - Field: ‘workers’
[17:36:40.553]   - Field: ‘packages’
[17:36:40.553]   - Field: ‘gc’
[17:36:40.553]   - Field: ‘job’
[17:36:40.553]   - Field: ‘conditions’
[17:36:40.553]   - Field: ‘expr’
[17:36:40.553]   - Field: ‘uuid’
[17:36:40.554]   - Field: ‘seed’
[17:36:40.554]   - Field: ‘version’
[17:36:40.554]   - Field: ‘result’
[17:36:40.554]   - Field: ‘asynchronous’
[17:36:40.554]   - Field: ‘calls’
[17:36:40.554]   - Field: ‘globals’
[17:36:40.554]   - Field: ‘stdout’
[17:36:40.554]   - Field: ‘earlySignal’
[17:36:40.555]   - Field: ‘lazy’
[17:36:40.555]   - Field: ‘state’
[17:36:40.555] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:40.555] - Launch lazy future ...
[17:36:40.555] Packages needed by the future expression (n = 0): <none>
[17:36:40.555] Packages needed by future strategies (n = 0): <none>
[17:36:40.556] {
[17:36:40.556]     {
[17:36:40.556]         {
[17:36:40.556]             ...future.startTime <- base::Sys.time()
[17:36:40.556]             {
[17:36:40.556]                 {
[17:36:40.556]                   {
[17:36:40.556]                     {
[17:36:40.556]                       base::local({
[17:36:40.556]                         has_future <- base::requireNamespace("future", 
[17:36:40.556]                           quietly = TRUE)
[17:36:40.556]                         if (has_future) {
[17:36:40.556]                           ns <- base::getNamespace("future")
[17:36:40.556]                           version <- ns[[".package"]][["version"]]
[17:36:40.556]                           if (is.null(version)) 
[17:36:40.556]                             version <- utils::packageVersion("future")
[17:36:40.556]                         }
[17:36:40.556]                         else {
[17:36:40.556]                           version <- NULL
[17:36:40.556]                         }
[17:36:40.556]                         if (!has_future || version < "1.8.0") {
[17:36:40.556]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.556]                             "", base::R.version$version.string), 
[17:36:40.556]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:40.556]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.556]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.556]                               "release", "version")], collapse = " "), 
[17:36:40.556]                             hostname = base::Sys.info()[["nodename"]])
[17:36:40.556]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.556]                             info)
[17:36:40.556]                           info <- base::paste(info, collapse = "; ")
[17:36:40.556]                           if (!has_future) {
[17:36:40.556]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.556]                               info)
[17:36:40.556]                           }
[17:36:40.556]                           else {
[17:36:40.556]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.556]                               info, version)
[17:36:40.556]                           }
[17:36:40.556]                           base::stop(msg)
[17:36:40.556]                         }
[17:36:40.556]                       })
[17:36:40.556]                     }
[17:36:40.556]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:40.556]                     base::options(mc.cores = 1L)
[17:36:40.556]                   }
[17:36:40.556]                   ...future.strategy.old <- future::plan("list")
[17:36:40.556]                   options(future.plan = NULL)
[17:36:40.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.556]                 }
[17:36:40.556]                 ...future.workdir <- getwd()
[17:36:40.556]             }
[17:36:40.556]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.556]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.556]         }
[17:36:40.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.556]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:40.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.556]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.556]             base::names(...future.oldOptions))
[17:36:40.556]     }
[17:36:40.556]     if (FALSE) {
[17:36:40.556]     }
[17:36:40.556]     else {
[17:36:40.556]         if (TRUE) {
[17:36:40.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.556]                 open = "w")
[17:36:40.556]         }
[17:36:40.556]         else {
[17:36:40.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.556]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.556]         }
[17:36:40.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.556]             base::sink(type = "output", split = FALSE)
[17:36:40.556]             base::close(...future.stdout)
[17:36:40.556]         }, add = TRUE)
[17:36:40.556]     }
[17:36:40.556]     ...future.frame <- base::sys.nframe()
[17:36:40.556]     ...future.conditions <- base::list()
[17:36:40.556]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.556]     if (FALSE) {
[17:36:40.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.556]     }
[17:36:40.556]     ...future.result <- base::tryCatch({
[17:36:40.556]         base::withCallingHandlers({
[17:36:40.556]             ...future.value <- base::withVisible(base::local({
[17:36:40.556]                 withCallingHandlers({
[17:36:40.556]                   {
[17:36:40.556]                     do.call(function(...) {
[17:36:40.556]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.556]                       if (!identical(...future.globals.maxSize.org, 
[17:36:40.556]                         ...future.globals.maxSize)) {
[17:36:40.556]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.556]                         on.exit(options(oopts), add = TRUE)
[17:36:40.556]                       }
[17:36:40.556]                       {
[17:36:40.556]                         lapply(seq_along(...future.elements_ii), 
[17:36:40.556]                           FUN = function(jj) {
[17:36:40.556]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.556]                             ...future.FUN(...future.X_jj, ...)
[17:36:40.556]                           })
[17:36:40.556]                       }
[17:36:40.556]                     }, args = future.call.arguments)
[17:36:40.556]                   }
[17:36:40.556]                 }, immediateCondition = function(cond) {
[17:36:40.556]                   save_rds <- function (object, pathname, ...) 
[17:36:40.556]                   {
[17:36:40.556]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:40.556]                     if (file_test("-f", pathname_tmp)) {
[17:36:40.556]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.556]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:40.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.556]                         fi_tmp[["mtime"]])
[17:36:40.556]                     }
[17:36:40.556]                     tryCatch({
[17:36:40.556]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:40.556]                     }, error = function(ex) {
[17:36:40.556]                       msg <- conditionMessage(ex)
[17:36:40.556]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.556]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:40.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.556]                         fi_tmp[["mtime"]], msg)
[17:36:40.556]                       ex$message <- msg
[17:36:40.556]                       stop(ex)
[17:36:40.556]                     })
[17:36:40.556]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:40.556]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:40.556]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:40.556]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.556]                       fi <- file.info(pathname)
[17:36:40.556]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:40.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.556]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:40.556]                         fi[["size"]], fi[["mtime"]])
[17:36:40.556]                       stop(msg)
[17:36:40.556]                     }
[17:36:40.556]                     invisible(pathname)
[17:36:40.556]                   }
[17:36:40.556]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:40.556]                     rootPath = tempdir()) 
[17:36:40.556]                   {
[17:36:40.556]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:40.556]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:40.556]                       tmpdir = path, fileext = ".rds")
[17:36:40.556]                     save_rds(obj, file)
[17:36:40.556]                   }
[17:36:40.556]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:40.556]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.556]                   {
[17:36:40.556]                     inherits <- base::inherits
[17:36:40.556]                     invokeRestart <- base::invokeRestart
[17:36:40.556]                     is.null <- base::is.null
[17:36:40.556]                     muffled <- FALSE
[17:36:40.556]                     if (inherits(cond, "message")) {
[17:36:40.556]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:40.556]                       if (muffled) 
[17:36:40.556]                         invokeRestart("muffleMessage")
[17:36:40.556]                     }
[17:36:40.556]                     else if (inherits(cond, "warning")) {
[17:36:40.556]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:40.556]                       if (muffled) 
[17:36:40.556]                         invokeRestart("muffleWarning")
[17:36:40.556]                     }
[17:36:40.556]                     else if (inherits(cond, "condition")) {
[17:36:40.556]                       if (!is.null(pattern)) {
[17:36:40.556]                         computeRestarts <- base::computeRestarts
[17:36:40.556]                         grepl <- base::grepl
[17:36:40.556]                         restarts <- computeRestarts(cond)
[17:36:40.556]                         for (restart in restarts) {
[17:36:40.556]                           name <- restart$name
[17:36:40.556]                           if (is.null(name)) 
[17:36:40.556]                             next
[17:36:40.556]                           if (!grepl(pattern, name)) 
[17:36:40.556]                             next
[17:36:40.556]                           invokeRestart(restart)
[17:36:40.556]                           muffled <- TRUE
[17:36:40.556]                           break
[17:36:40.556]                         }
[17:36:40.556]                       }
[17:36:40.556]                     }
[17:36:40.556]                     invisible(muffled)
[17:36:40.556]                   }
[17:36:40.556]                   muffleCondition(cond)
[17:36:40.556]                 })
[17:36:40.556]             }))
[17:36:40.556]             future::FutureResult(value = ...future.value$value, 
[17:36:40.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.556]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.556]                     ...future.globalenv.names))
[17:36:40.556]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.556]         }, condition = base::local({
[17:36:40.556]             c <- base::c
[17:36:40.556]             inherits <- base::inherits
[17:36:40.556]             invokeRestart <- base::invokeRestart
[17:36:40.556]             length <- base::length
[17:36:40.556]             list <- base::list
[17:36:40.556]             seq.int <- base::seq.int
[17:36:40.556]             signalCondition <- base::signalCondition
[17:36:40.556]             sys.calls <- base::sys.calls
[17:36:40.556]             `[[` <- base::`[[`
[17:36:40.556]             `+` <- base::`+`
[17:36:40.556]             `<<-` <- base::`<<-`
[17:36:40.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.556]                   3L)]
[17:36:40.556]             }
[17:36:40.556]             function(cond) {
[17:36:40.556]                 is_error <- inherits(cond, "error")
[17:36:40.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.556]                   NULL)
[17:36:40.556]                 if (is_error) {
[17:36:40.556]                   sessionInformation <- function() {
[17:36:40.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.556]                       search = base::search(), system = base::Sys.info())
[17:36:40.556]                   }
[17:36:40.556]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.556]                     cond$call), session = sessionInformation(), 
[17:36:40.556]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.556]                   signalCondition(cond)
[17:36:40.556]                 }
[17:36:40.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.556]                 "immediateCondition"))) {
[17:36:40.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.556]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.556]                   if (TRUE && !signal) {
[17:36:40.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.556]                     {
[17:36:40.556]                       inherits <- base::inherits
[17:36:40.556]                       invokeRestart <- base::invokeRestart
[17:36:40.556]                       is.null <- base::is.null
[17:36:40.556]                       muffled <- FALSE
[17:36:40.556]                       if (inherits(cond, "message")) {
[17:36:40.556]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.556]                         if (muffled) 
[17:36:40.556]                           invokeRestart("muffleMessage")
[17:36:40.556]                       }
[17:36:40.556]                       else if (inherits(cond, "warning")) {
[17:36:40.556]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.556]                         if (muffled) 
[17:36:40.556]                           invokeRestart("muffleWarning")
[17:36:40.556]                       }
[17:36:40.556]                       else if (inherits(cond, "condition")) {
[17:36:40.556]                         if (!is.null(pattern)) {
[17:36:40.556]                           computeRestarts <- base::computeRestarts
[17:36:40.556]                           grepl <- base::grepl
[17:36:40.556]                           restarts <- computeRestarts(cond)
[17:36:40.556]                           for (restart in restarts) {
[17:36:40.556]                             name <- restart$name
[17:36:40.556]                             if (is.null(name)) 
[17:36:40.556]                               next
[17:36:40.556]                             if (!grepl(pattern, name)) 
[17:36:40.556]                               next
[17:36:40.556]                             invokeRestart(restart)
[17:36:40.556]                             muffled <- TRUE
[17:36:40.556]                             break
[17:36:40.556]                           }
[17:36:40.556]                         }
[17:36:40.556]                       }
[17:36:40.556]                       invisible(muffled)
[17:36:40.556]                     }
[17:36:40.556]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.556]                   }
[17:36:40.556]                 }
[17:36:40.556]                 else {
[17:36:40.556]                   if (TRUE) {
[17:36:40.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.556]                     {
[17:36:40.556]                       inherits <- base::inherits
[17:36:40.556]                       invokeRestart <- base::invokeRestart
[17:36:40.556]                       is.null <- base::is.null
[17:36:40.556]                       muffled <- FALSE
[17:36:40.556]                       if (inherits(cond, "message")) {
[17:36:40.556]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.556]                         if (muffled) 
[17:36:40.556]                           invokeRestart("muffleMessage")
[17:36:40.556]                       }
[17:36:40.556]                       else if (inherits(cond, "warning")) {
[17:36:40.556]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.556]                         if (muffled) 
[17:36:40.556]                           invokeRestart("muffleWarning")
[17:36:40.556]                       }
[17:36:40.556]                       else if (inherits(cond, "condition")) {
[17:36:40.556]                         if (!is.null(pattern)) {
[17:36:40.556]                           computeRestarts <- base::computeRestarts
[17:36:40.556]                           grepl <- base::grepl
[17:36:40.556]                           restarts <- computeRestarts(cond)
[17:36:40.556]                           for (restart in restarts) {
[17:36:40.556]                             name <- restart$name
[17:36:40.556]                             if (is.null(name)) 
[17:36:40.556]                               next
[17:36:40.556]                             if (!grepl(pattern, name)) 
[17:36:40.556]                               next
[17:36:40.556]                             invokeRestart(restart)
[17:36:40.556]                             muffled <- TRUE
[17:36:40.556]                             break
[17:36:40.556]                           }
[17:36:40.556]                         }
[17:36:40.556]                       }
[17:36:40.556]                       invisible(muffled)
[17:36:40.556]                     }
[17:36:40.556]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.556]                   }
[17:36:40.556]                 }
[17:36:40.556]             }
[17:36:40.556]         }))
[17:36:40.556]     }, error = function(ex) {
[17:36:40.556]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.556]                 ...future.rng), started = ...future.startTime, 
[17:36:40.556]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.556]             version = "1.8"), class = "FutureResult")
[17:36:40.556]     }, finally = {
[17:36:40.556]         if (!identical(...future.workdir, getwd())) 
[17:36:40.556]             setwd(...future.workdir)
[17:36:40.556]         {
[17:36:40.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.556]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.556]             }
[17:36:40.556]             base::options(...future.oldOptions)
[17:36:40.556]             if (.Platform$OS.type == "windows") {
[17:36:40.556]                 old_names <- names(...future.oldEnvVars)
[17:36:40.556]                 envs <- base::Sys.getenv()
[17:36:40.556]                 names <- names(envs)
[17:36:40.556]                 common <- intersect(names, old_names)
[17:36:40.556]                 added <- setdiff(names, old_names)
[17:36:40.556]                 removed <- setdiff(old_names, names)
[17:36:40.556]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.556]                   envs[common]]
[17:36:40.556]                 NAMES <- toupper(changed)
[17:36:40.556]                 args <- list()
[17:36:40.556]                 for (kk in seq_along(NAMES)) {
[17:36:40.556]                   name <- changed[[kk]]
[17:36:40.556]                   NAME <- NAMES[[kk]]
[17:36:40.556]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.556]                     next
[17:36:40.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.556]                 }
[17:36:40.556]                 NAMES <- toupper(added)
[17:36:40.556]                 for (kk in seq_along(NAMES)) {
[17:36:40.556]                   name <- added[[kk]]
[17:36:40.556]                   NAME <- NAMES[[kk]]
[17:36:40.556]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.556]                     next
[17:36:40.556]                   args[[name]] <- ""
[17:36:40.556]                 }
[17:36:40.556]                 NAMES <- toupper(removed)
[17:36:40.556]                 for (kk in seq_along(NAMES)) {
[17:36:40.556]                   name <- removed[[kk]]
[17:36:40.556]                   NAME <- NAMES[[kk]]
[17:36:40.556]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.556]                     next
[17:36:40.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.556]                 }
[17:36:40.556]                 if (length(args) > 0) 
[17:36:40.556]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.556]             }
[17:36:40.556]             else {
[17:36:40.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.556]             }
[17:36:40.556]             {
[17:36:40.556]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.556]                   0L) {
[17:36:40.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.556]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.556]                   base::options(opts)
[17:36:40.556]                 }
[17:36:40.556]                 {
[17:36:40.556]                   {
[17:36:40.556]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:40.556]                     NULL
[17:36:40.556]                   }
[17:36:40.556]                   options(future.plan = NULL)
[17:36:40.556]                   if (is.na(NA_character_)) 
[17:36:40.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.556]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.556]                     .init = FALSE)
[17:36:40.556]                 }
[17:36:40.556]             }
[17:36:40.556]         }
[17:36:40.556]     })
[17:36:40.556]     if (TRUE) {
[17:36:40.556]         base::sink(type = "output", split = FALSE)
[17:36:40.556]         if (TRUE) {
[17:36:40.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.556]         }
[17:36:40.556]         else {
[17:36:40.556]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.556]         }
[17:36:40.556]         base::close(...future.stdout)
[17:36:40.556]         ...future.stdout <- NULL
[17:36:40.556]     }
[17:36:40.556]     ...future.result$conditions <- ...future.conditions
[17:36:40.556]     ...future.result$finished <- base::Sys.time()
[17:36:40.556]     ...future.result
[17:36:40.556] }
[17:36:40.559] assign_globals() ...
[17:36:40.559] List of 5
[17:36:40.559]  $ ...future.FUN            :function (object, ...)  
[17:36:40.559]  $ future.call.arguments    : list()
[17:36:40.559]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.559]  $ ...future.elements_ii    :List of 2
[17:36:40.559]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:40.559]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.559]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.559]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:36:40.559]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.559]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.559]  $ ...future.seeds_ii       : NULL
[17:36:40.559]  $ ...future.globals.maxSize: NULL
[17:36:40.559]  - attr(*, "where")=List of 5
[17:36:40.559]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.559]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.559]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.559]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.559]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.559]  - attr(*, "resolved")= logi FALSE
[17:36:40.559]  - attr(*, "total_size")= num 1240
[17:36:40.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.559]  - attr(*, "already-done")= logi TRUE
[17:36:40.567] - copied ‘...future.FUN’ to environment
[17:36:40.567] - copied ‘future.call.arguments’ to environment
[17:36:40.567] - copied ‘...future.elements_ii’ to environment
[17:36:40.567] - copied ‘...future.seeds_ii’ to environment
[17:36:40.567] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.567] assign_globals() ... done
[17:36:40.567] requestCore(): workers = 2
[17:36:40.575] MulticoreFuture started
[17:36:40.576] - Launch lazy future ... done
[17:36:40.576] plan(): Setting new future strategy stack:
[17:36:40.576] run() for ‘MulticoreFuture’ ... done
[17:36:40.577] Created future:
[17:36:40.576] List of future strategies:
[17:36:40.576] 1. sequential:
[17:36:40.576]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.576]    - tweaked: FALSE
[17:36:40.576]    - call: NULL
[17:36:40.578] plan(): nbrOfWorkers() = 1
[17:36:40.584] plan(): Setting new future strategy stack:
[17:36:40.584] List of future strategies:
[17:36:40.584] 1. multicore:
[17:36:40.584]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:40.584]    - tweaked: FALSE
[17:36:40.584]    - call: plan(strategy)
[17:36:40.590] plan(): nbrOfWorkers() = 2
[17:36:40.577] MulticoreFuture:
[17:36:40.577] Label: ‘future_by-2’
[17:36:40.577] Expression:
[17:36:40.577] {
[17:36:40.577]     do.call(function(...) {
[17:36:40.577]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.577]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.577]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.577]             on.exit(options(oopts), add = TRUE)
[17:36:40.577]         }
[17:36:40.577]         {
[17:36:40.577]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.577]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.577]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.577]             })
[17:36:40.577]         }
[17:36:40.577]     }, args = future.call.arguments)
[17:36:40.577] }
[17:36:40.577] Lazy evaluation: FALSE
[17:36:40.577] Asynchronous evaluation: TRUE
[17:36:40.577] Local evaluation: TRUE
[17:36:40.577] Environment: R_GlobalEnv
[17:36:40.577] Capture standard output: TRUE
[17:36:40.577] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.577] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.577] Packages: <none>
[17:36:40.577] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.577] Resolved: TRUE
[17:36:40.577] Value: <not collected>
[17:36:40.577] Conditions captured: <none>
[17:36:40.577] Early signaling: FALSE
[17:36:40.577] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.577] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.591] Chunk #2 of 2 ... DONE
[17:36:40.591] Launching 2 futures (chunks) ... DONE
[17:36:40.592] Resolving 2 futures (chunks) ...
[17:36:40.592] resolve() on list ...
[17:36:40.592]  recursive: 0
[17:36:40.592]  length: 2
[17:36:40.592] 
[17:36:40.593] Future #1
[17:36:40.594] result() for MulticoreFuture ...
[17:36:40.595] result() for MulticoreFuture ...
[17:36:40.596] result() for MulticoreFuture ... done
[17:36:40.596] result() for MulticoreFuture ... done
[17:36:40.596] result() for MulticoreFuture ...
[17:36:40.596] result() for MulticoreFuture ... done
[17:36:40.596] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:40.596] - nx: 2
[17:36:40.596] - relay: TRUE
[17:36:40.597] - stdout: TRUE
[17:36:40.597] - signal: TRUE
[17:36:40.597] - resignal: FALSE
[17:36:40.597] - force: TRUE
[17:36:40.597] - relayed: [n=2] FALSE, FALSE
[17:36:40.597] - queued futures: [n=2] FALSE, FALSE
[17:36:40.598]  - until=1
[17:36:40.598]  - relaying element #1
[17:36:40.598] result() for MulticoreFuture ...
[17:36:40.598] result() for MulticoreFuture ... done
[17:36:40.598] result() for MulticoreFuture ...
[17:36:40.598] result() for MulticoreFuture ... done
[17:36:40.599] result() for MulticoreFuture ...
[17:36:40.599] result() for MulticoreFuture ... done
[17:36:40.599] result() for MulticoreFuture ...
[17:36:40.599] result() for MulticoreFuture ... done
[17:36:40.599] - relayed: [n=2] TRUE, FALSE
[17:36:40.599] - queued futures: [n=2] TRUE, FALSE
[17:36:40.600] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:40.600]  length: 1 (resolved future 1)
[17:36:40.600] Future #2
[17:36:40.600] result() for MulticoreFuture ...
[17:36:40.601] result() for MulticoreFuture ...
[17:36:40.601] result() for MulticoreFuture ... done
[17:36:40.601] result() for MulticoreFuture ... done
[17:36:40.601] result() for MulticoreFuture ...
[17:36:40.601] result() for MulticoreFuture ... done
[17:36:40.602] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:40.602] - nx: 2
[17:36:40.602] - relay: TRUE
[17:36:40.602] - stdout: TRUE
[17:36:40.602] - signal: TRUE
[17:36:40.602] - resignal: FALSE
[17:36:40.602] - force: TRUE
[17:36:40.602] - relayed: [n=2] TRUE, FALSE
[17:36:40.602] - queued futures: [n=2] TRUE, FALSE
[17:36:40.603]  - until=2
[17:36:40.603]  - relaying element #2
[17:36:40.603] result() for MulticoreFuture ...
[17:36:40.603] result() for MulticoreFuture ... done
[17:36:40.603] result() for MulticoreFuture ...
[17:36:40.603] result() for MulticoreFuture ... done
[17:36:40.603] result() for MulticoreFuture ...
[17:36:40.603] result() for MulticoreFuture ... done
[17:36:40.604] result() for MulticoreFuture ...
[17:36:40.604] result() for MulticoreFuture ... done
[17:36:40.604] - relayed: [n=2] TRUE, TRUE
[17:36:40.604] - queued futures: [n=2] TRUE, TRUE
[17:36:40.604] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:40.604]  length: 0 (resolved future 2)
[17:36:40.604] Relaying remaining futures
[17:36:40.604] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.604] - nx: 2
[17:36:40.605] - relay: TRUE
[17:36:40.605] - stdout: TRUE
[17:36:40.605] - signal: TRUE
[17:36:40.605] - resignal: FALSE
[17:36:40.605] - force: TRUE
[17:36:40.605] - relayed: [n=2] TRUE, TRUE
[17:36:40.605] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:40.605] - relayed: [n=2] TRUE, TRUE
[17:36:40.605] - queued futures: [n=2] TRUE, TRUE
[17:36:40.605] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.606] resolve() on list ... DONE
[17:36:40.606] result() for MulticoreFuture ...
[17:36:40.606] result() for MulticoreFuture ... done
[17:36:40.606] result() for MulticoreFuture ...
[17:36:40.606] result() for MulticoreFuture ... done
[17:36:40.606] result() for MulticoreFuture ...
[17:36:40.606] result() for MulticoreFuture ... done
[17:36:40.606] result() for MulticoreFuture ...
[17:36:40.606] result() for MulticoreFuture ... done
[17:36:40.607]  - Number of value chunks collected: 2
[17:36:40.607] Resolving 2 futures (chunks) ... DONE
[17:36:40.607] Reducing values from 2 chunks ...
[17:36:40.607]  - Number of values collected after concatenation: 3
[17:36:40.607]  - Number of values expected: 3
[17:36:40.607] Reducing values from 2 chunks ... DONE
[17:36:40.607] future_lapply() ... DONE
[17:36:40.607] future_by_internal() ... DONE
[17:36:40.608] future_by_internal() ...
[17:36:40.608] future_lapply() ...
[17:36:40.613] Number of chunks: 2
[17:36:40.613] getGlobalsAndPackagesXApply() ...
[17:36:40.613]  - future.globals: TRUE
[17:36:40.613] getGlobalsAndPackages() ...
[17:36:40.613] Searching for globals...
[17:36:40.614] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:40.614] Searching for globals ... DONE
[17:36:40.614] Resolving globals: FALSE
[17:36:40.615] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:40.615] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:40.615] - globals: [1] ‘FUN’
[17:36:40.615] 
[17:36:40.616] getGlobalsAndPackages() ... DONE
[17:36:40.616]  - globals found/used: [n=1] ‘FUN’
[17:36:40.616]  - needed namespaces: [n=0] 
[17:36:40.616] Finding globals ... DONE
[17:36:40.616]  - use_args: TRUE
[17:36:40.616]  - Getting '...' globals ...
[17:36:40.616] resolve() on list ...
[17:36:40.617]  recursive: 0
[17:36:40.617]  length: 1
[17:36:40.619]  elements: ‘...’
[17:36:40.619]  length: 0 (resolved future 1)
[17:36:40.619] resolve() on list ... DONE
[17:36:40.619]    - '...' content: [n=1] ‘digits’
[17:36:40.619] List of 1
[17:36:40.619]  $ ...:List of 1
[17:36:40.619]   ..$ digits: int 2
[17:36:40.619]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.619]  - attr(*, "where")=List of 1
[17:36:40.619]   ..$ ...:<environment: 0x5622fc1201d0> 
[17:36:40.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.619]  - attr(*, "resolved")= logi TRUE
[17:36:40.619]  - attr(*, "total_size")= num NA
[17:36:40.623]  - Getting '...' globals ... DONE
[17:36:40.623] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:40.624] List of 2
[17:36:40.624]  $ ...future.FUN:function (object, ...)  
[17:36:40.624]  $ ...          :List of 1
[17:36:40.624]   ..$ digits: int 2
[17:36:40.624]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.624]  - attr(*, "where")=List of 2
[17:36:40.624]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.624]   ..$ ...          :<environment: 0x5622fc1201d0> 
[17:36:40.624]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.624]  - attr(*, "resolved")= logi FALSE
[17:36:40.624]  - attr(*, "total_size")= num 1296
[17:36:40.627] Packages to be attached in all futures: [n=0] 
[17:36:40.627] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.627] Number of futures (= number of chunks): 2
[17:36:40.627] Launching 2 futures (chunks) ...
[17:36:40.627] Chunk #1 of 2 ...
[17:36:40.627]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.627] getGlobalsAndPackages() ...
[17:36:40.628] Searching for globals...
[17:36:40.628] 
[17:36:40.628] Searching for globals ... DONE
[17:36:40.628] - globals: [0] <none>
[17:36:40.628] getGlobalsAndPackages() ... DONE
[17:36:40.628]    + additional globals found: [n=0] 
[17:36:40.628]    + additional namespaces needed: [n=0] 
[17:36:40.628]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.628]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:40.629]  - seeds: <none>
[17:36:40.629]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.629] getGlobalsAndPackages() ...
[17:36:40.629] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.629] Resolving globals: FALSE
[17:36:40.629] Tweak future expression to call with '...' arguments ...
[17:36:40.629] {
[17:36:40.629]     do.call(function(...) {
[17:36:40.629]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.629]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.629]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.629]             on.exit(options(oopts), add = TRUE)
[17:36:40.629]         }
[17:36:40.629]         {
[17:36:40.629]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.629]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.629]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.629]             })
[17:36:40.629]         }
[17:36:40.629]     }, args = future.call.arguments)
[17:36:40.629] }
[17:36:40.630] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.630] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.630] 
[17:36:40.630] getGlobalsAndPackages() ... DONE
[17:36:40.630] run() for ‘Future’ ...
[17:36:40.631] - state: ‘created’
[17:36:40.631] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.634] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:40.635]   - Field: ‘label’
[17:36:40.635]   - Field: ‘local’
[17:36:40.635]   - Field: ‘owner’
[17:36:40.635]   - Field: ‘envir’
[17:36:40.635]   - Field: ‘workers’
[17:36:40.635]   - Field: ‘packages’
[17:36:40.635]   - Field: ‘gc’
[17:36:40.635]   - Field: ‘job’
[17:36:40.635]   - Field: ‘conditions’
[17:36:40.635]   - Field: ‘expr’
[17:36:40.636]   - Field: ‘uuid’
[17:36:40.636]   - Field: ‘seed’
[17:36:40.636]   - Field: ‘version’
[17:36:40.636]   - Field: ‘result’
[17:36:40.636]   - Field: ‘asynchronous’
[17:36:40.636]   - Field: ‘calls’
[17:36:40.636]   - Field: ‘globals’
[17:36:40.636]   - Field: ‘stdout’
[17:36:40.636]   - Field: ‘earlySignal’
[17:36:40.636]   - Field: ‘lazy’
[17:36:40.636]   - Field: ‘state’
[17:36:40.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:40.637] - Launch lazy future ...
[17:36:40.637] Packages needed by the future expression (n = 0): <none>
[17:36:40.637] Packages needed by future strategies (n = 0): <none>
[17:36:40.638] {
[17:36:40.638]     {
[17:36:40.638]         {
[17:36:40.638]             ...future.startTime <- base::Sys.time()
[17:36:40.638]             {
[17:36:40.638]                 {
[17:36:40.638]                   {
[17:36:40.638]                     {
[17:36:40.638]                       base::local({
[17:36:40.638]                         has_future <- base::requireNamespace("future", 
[17:36:40.638]                           quietly = TRUE)
[17:36:40.638]                         if (has_future) {
[17:36:40.638]                           ns <- base::getNamespace("future")
[17:36:40.638]                           version <- ns[[".package"]][["version"]]
[17:36:40.638]                           if (is.null(version)) 
[17:36:40.638]                             version <- utils::packageVersion("future")
[17:36:40.638]                         }
[17:36:40.638]                         else {
[17:36:40.638]                           version <- NULL
[17:36:40.638]                         }
[17:36:40.638]                         if (!has_future || version < "1.8.0") {
[17:36:40.638]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.638]                             "", base::R.version$version.string), 
[17:36:40.638]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:40.638]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.638]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.638]                               "release", "version")], collapse = " "), 
[17:36:40.638]                             hostname = base::Sys.info()[["nodename"]])
[17:36:40.638]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.638]                             info)
[17:36:40.638]                           info <- base::paste(info, collapse = "; ")
[17:36:40.638]                           if (!has_future) {
[17:36:40.638]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.638]                               info)
[17:36:40.638]                           }
[17:36:40.638]                           else {
[17:36:40.638]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.638]                               info, version)
[17:36:40.638]                           }
[17:36:40.638]                           base::stop(msg)
[17:36:40.638]                         }
[17:36:40.638]                       })
[17:36:40.638]                     }
[17:36:40.638]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:40.638]                     base::options(mc.cores = 1L)
[17:36:40.638]                   }
[17:36:40.638]                   ...future.strategy.old <- future::plan("list")
[17:36:40.638]                   options(future.plan = NULL)
[17:36:40.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.638]                 }
[17:36:40.638]                 ...future.workdir <- getwd()
[17:36:40.638]             }
[17:36:40.638]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.638]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.638]         }
[17:36:40.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.638]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:40.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.638]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.638]             base::names(...future.oldOptions))
[17:36:40.638]     }
[17:36:40.638]     if (FALSE) {
[17:36:40.638]     }
[17:36:40.638]     else {
[17:36:40.638]         if (TRUE) {
[17:36:40.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.638]                 open = "w")
[17:36:40.638]         }
[17:36:40.638]         else {
[17:36:40.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.638]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.638]         }
[17:36:40.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.638]             base::sink(type = "output", split = FALSE)
[17:36:40.638]             base::close(...future.stdout)
[17:36:40.638]         }, add = TRUE)
[17:36:40.638]     }
[17:36:40.638]     ...future.frame <- base::sys.nframe()
[17:36:40.638]     ...future.conditions <- base::list()
[17:36:40.638]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.638]     if (FALSE) {
[17:36:40.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.638]     }
[17:36:40.638]     ...future.result <- base::tryCatch({
[17:36:40.638]         base::withCallingHandlers({
[17:36:40.638]             ...future.value <- base::withVisible(base::local({
[17:36:40.638]                 withCallingHandlers({
[17:36:40.638]                   {
[17:36:40.638]                     do.call(function(...) {
[17:36:40.638]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.638]                       if (!identical(...future.globals.maxSize.org, 
[17:36:40.638]                         ...future.globals.maxSize)) {
[17:36:40.638]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.638]                         on.exit(options(oopts), add = TRUE)
[17:36:40.638]                       }
[17:36:40.638]                       {
[17:36:40.638]                         lapply(seq_along(...future.elements_ii), 
[17:36:40.638]                           FUN = function(jj) {
[17:36:40.638]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.638]                             ...future.FUN(...future.X_jj, ...)
[17:36:40.638]                           })
[17:36:40.638]                       }
[17:36:40.638]                     }, args = future.call.arguments)
[17:36:40.638]                   }
[17:36:40.638]                 }, immediateCondition = function(cond) {
[17:36:40.638]                   save_rds <- function (object, pathname, ...) 
[17:36:40.638]                   {
[17:36:40.638]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:40.638]                     if (file_test("-f", pathname_tmp)) {
[17:36:40.638]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.638]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:40.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.638]                         fi_tmp[["mtime"]])
[17:36:40.638]                     }
[17:36:40.638]                     tryCatch({
[17:36:40.638]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:40.638]                     }, error = function(ex) {
[17:36:40.638]                       msg <- conditionMessage(ex)
[17:36:40.638]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.638]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:40.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.638]                         fi_tmp[["mtime"]], msg)
[17:36:40.638]                       ex$message <- msg
[17:36:40.638]                       stop(ex)
[17:36:40.638]                     })
[17:36:40.638]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:40.638]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:40.638]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:40.638]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.638]                       fi <- file.info(pathname)
[17:36:40.638]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:40.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.638]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:40.638]                         fi[["size"]], fi[["mtime"]])
[17:36:40.638]                       stop(msg)
[17:36:40.638]                     }
[17:36:40.638]                     invisible(pathname)
[17:36:40.638]                   }
[17:36:40.638]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:40.638]                     rootPath = tempdir()) 
[17:36:40.638]                   {
[17:36:40.638]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:40.638]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:40.638]                       tmpdir = path, fileext = ".rds")
[17:36:40.638]                     save_rds(obj, file)
[17:36:40.638]                   }
[17:36:40.638]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:40.638]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.638]                   {
[17:36:40.638]                     inherits <- base::inherits
[17:36:40.638]                     invokeRestart <- base::invokeRestart
[17:36:40.638]                     is.null <- base::is.null
[17:36:40.638]                     muffled <- FALSE
[17:36:40.638]                     if (inherits(cond, "message")) {
[17:36:40.638]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:40.638]                       if (muffled) 
[17:36:40.638]                         invokeRestart("muffleMessage")
[17:36:40.638]                     }
[17:36:40.638]                     else if (inherits(cond, "warning")) {
[17:36:40.638]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:40.638]                       if (muffled) 
[17:36:40.638]                         invokeRestart("muffleWarning")
[17:36:40.638]                     }
[17:36:40.638]                     else if (inherits(cond, "condition")) {
[17:36:40.638]                       if (!is.null(pattern)) {
[17:36:40.638]                         computeRestarts <- base::computeRestarts
[17:36:40.638]                         grepl <- base::grepl
[17:36:40.638]                         restarts <- computeRestarts(cond)
[17:36:40.638]                         for (restart in restarts) {
[17:36:40.638]                           name <- restart$name
[17:36:40.638]                           if (is.null(name)) 
[17:36:40.638]                             next
[17:36:40.638]                           if (!grepl(pattern, name)) 
[17:36:40.638]                             next
[17:36:40.638]                           invokeRestart(restart)
[17:36:40.638]                           muffled <- TRUE
[17:36:40.638]                           break
[17:36:40.638]                         }
[17:36:40.638]                       }
[17:36:40.638]                     }
[17:36:40.638]                     invisible(muffled)
[17:36:40.638]                   }
[17:36:40.638]                   muffleCondition(cond)
[17:36:40.638]                 })
[17:36:40.638]             }))
[17:36:40.638]             future::FutureResult(value = ...future.value$value, 
[17:36:40.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.638]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.638]                     ...future.globalenv.names))
[17:36:40.638]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.638]         }, condition = base::local({
[17:36:40.638]             c <- base::c
[17:36:40.638]             inherits <- base::inherits
[17:36:40.638]             invokeRestart <- base::invokeRestart
[17:36:40.638]             length <- base::length
[17:36:40.638]             list <- base::list
[17:36:40.638]             seq.int <- base::seq.int
[17:36:40.638]             signalCondition <- base::signalCondition
[17:36:40.638]             sys.calls <- base::sys.calls
[17:36:40.638]             `[[` <- base::`[[`
[17:36:40.638]             `+` <- base::`+`
[17:36:40.638]             `<<-` <- base::`<<-`
[17:36:40.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.638]                   3L)]
[17:36:40.638]             }
[17:36:40.638]             function(cond) {
[17:36:40.638]                 is_error <- inherits(cond, "error")
[17:36:40.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.638]                   NULL)
[17:36:40.638]                 if (is_error) {
[17:36:40.638]                   sessionInformation <- function() {
[17:36:40.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.638]                       search = base::search(), system = base::Sys.info())
[17:36:40.638]                   }
[17:36:40.638]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.638]                     cond$call), session = sessionInformation(), 
[17:36:40.638]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.638]                   signalCondition(cond)
[17:36:40.638]                 }
[17:36:40.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.638]                 "immediateCondition"))) {
[17:36:40.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.638]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.638]                   if (TRUE && !signal) {
[17:36:40.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.638]                     {
[17:36:40.638]                       inherits <- base::inherits
[17:36:40.638]                       invokeRestart <- base::invokeRestart
[17:36:40.638]                       is.null <- base::is.null
[17:36:40.638]                       muffled <- FALSE
[17:36:40.638]                       if (inherits(cond, "message")) {
[17:36:40.638]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.638]                         if (muffled) 
[17:36:40.638]                           invokeRestart("muffleMessage")
[17:36:40.638]                       }
[17:36:40.638]                       else if (inherits(cond, "warning")) {
[17:36:40.638]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.638]                         if (muffled) 
[17:36:40.638]                           invokeRestart("muffleWarning")
[17:36:40.638]                       }
[17:36:40.638]                       else if (inherits(cond, "condition")) {
[17:36:40.638]                         if (!is.null(pattern)) {
[17:36:40.638]                           computeRestarts <- base::computeRestarts
[17:36:40.638]                           grepl <- base::grepl
[17:36:40.638]                           restarts <- computeRestarts(cond)
[17:36:40.638]                           for (restart in restarts) {
[17:36:40.638]                             name <- restart$name
[17:36:40.638]                             if (is.null(name)) 
[17:36:40.638]                               next
[17:36:40.638]                             if (!grepl(pattern, name)) 
[17:36:40.638]                               next
[17:36:40.638]                             invokeRestart(restart)
[17:36:40.638]                             muffled <- TRUE
[17:36:40.638]                             break
[17:36:40.638]                           }
[17:36:40.638]                         }
[17:36:40.638]                       }
[17:36:40.638]                       invisible(muffled)
[17:36:40.638]                     }
[17:36:40.638]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.638]                   }
[17:36:40.638]                 }
[17:36:40.638]                 else {
[17:36:40.638]                   if (TRUE) {
[17:36:40.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.638]                     {
[17:36:40.638]                       inherits <- base::inherits
[17:36:40.638]                       invokeRestart <- base::invokeRestart
[17:36:40.638]                       is.null <- base::is.null
[17:36:40.638]                       muffled <- FALSE
[17:36:40.638]                       if (inherits(cond, "message")) {
[17:36:40.638]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.638]                         if (muffled) 
[17:36:40.638]                           invokeRestart("muffleMessage")
[17:36:40.638]                       }
[17:36:40.638]                       else if (inherits(cond, "warning")) {
[17:36:40.638]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.638]                         if (muffled) 
[17:36:40.638]                           invokeRestart("muffleWarning")
[17:36:40.638]                       }
[17:36:40.638]                       else if (inherits(cond, "condition")) {
[17:36:40.638]                         if (!is.null(pattern)) {
[17:36:40.638]                           computeRestarts <- base::computeRestarts
[17:36:40.638]                           grepl <- base::grepl
[17:36:40.638]                           restarts <- computeRestarts(cond)
[17:36:40.638]                           for (restart in restarts) {
[17:36:40.638]                             name <- restart$name
[17:36:40.638]                             if (is.null(name)) 
[17:36:40.638]                               next
[17:36:40.638]                             if (!grepl(pattern, name)) 
[17:36:40.638]                               next
[17:36:40.638]                             invokeRestart(restart)
[17:36:40.638]                             muffled <- TRUE
[17:36:40.638]                             break
[17:36:40.638]                           }
[17:36:40.638]                         }
[17:36:40.638]                       }
[17:36:40.638]                       invisible(muffled)
[17:36:40.638]                     }
[17:36:40.638]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.638]                   }
[17:36:40.638]                 }
[17:36:40.638]             }
[17:36:40.638]         }))
[17:36:40.638]     }, error = function(ex) {
[17:36:40.638]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.638]                 ...future.rng), started = ...future.startTime, 
[17:36:40.638]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.638]             version = "1.8"), class = "FutureResult")
[17:36:40.638]     }, finally = {
[17:36:40.638]         if (!identical(...future.workdir, getwd())) 
[17:36:40.638]             setwd(...future.workdir)
[17:36:40.638]         {
[17:36:40.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.638]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.638]             }
[17:36:40.638]             base::options(...future.oldOptions)
[17:36:40.638]             if (.Platform$OS.type == "windows") {
[17:36:40.638]                 old_names <- names(...future.oldEnvVars)
[17:36:40.638]                 envs <- base::Sys.getenv()
[17:36:40.638]                 names <- names(envs)
[17:36:40.638]                 common <- intersect(names, old_names)
[17:36:40.638]                 added <- setdiff(names, old_names)
[17:36:40.638]                 removed <- setdiff(old_names, names)
[17:36:40.638]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.638]                   envs[common]]
[17:36:40.638]                 NAMES <- toupper(changed)
[17:36:40.638]                 args <- list()
[17:36:40.638]                 for (kk in seq_along(NAMES)) {
[17:36:40.638]                   name <- changed[[kk]]
[17:36:40.638]                   NAME <- NAMES[[kk]]
[17:36:40.638]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.638]                     next
[17:36:40.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.638]                 }
[17:36:40.638]                 NAMES <- toupper(added)
[17:36:40.638]                 for (kk in seq_along(NAMES)) {
[17:36:40.638]                   name <- added[[kk]]
[17:36:40.638]                   NAME <- NAMES[[kk]]
[17:36:40.638]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.638]                     next
[17:36:40.638]                   args[[name]] <- ""
[17:36:40.638]                 }
[17:36:40.638]                 NAMES <- toupper(removed)
[17:36:40.638]                 for (kk in seq_along(NAMES)) {
[17:36:40.638]                   name <- removed[[kk]]
[17:36:40.638]                   NAME <- NAMES[[kk]]
[17:36:40.638]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.638]                     next
[17:36:40.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.638]                 }
[17:36:40.638]                 if (length(args) > 0) 
[17:36:40.638]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.638]             }
[17:36:40.638]             else {
[17:36:40.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.638]             }
[17:36:40.638]             {
[17:36:40.638]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.638]                   0L) {
[17:36:40.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.638]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.638]                   base::options(opts)
[17:36:40.638]                 }
[17:36:40.638]                 {
[17:36:40.638]                   {
[17:36:40.638]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:40.638]                     NULL
[17:36:40.638]                   }
[17:36:40.638]                   options(future.plan = NULL)
[17:36:40.638]                   if (is.na(NA_character_)) 
[17:36:40.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.638]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.638]                     .init = FALSE)
[17:36:40.638]                 }
[17:36:40.638]             }
[17:36:40.638]         }
[17:36:40.638]     })
[17:36:40.638]     if (TRUE) {
[17:36:40.638]         base::sink(type = "output", split = FALSE)
[17:36:40.638]         if (TRUE) {
[17:36:40.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.638]         }
[17:36:40.638]         else {
[17:36:40.638]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.638]         }
[17:36:40.638]         base::close(...future.stdout)
[17:36:40.638]         ...future.stdout <- NULL
[17:36:40.638]     }
[17:36:40.638]     ...future.result$conditions <- ...future.conditions
[17:36:40.638]     ...future.result$finished <- base::Sys.time()
[17:36:40.638]     ...future.result
[17:36:40.638] }
[17:36:40.640] assign_globals() ...
[17:36:40.640] List of 5
[17:36:40.640]  $ ...future.FUN            :function (object, ...)  
[17:36:40.640]  $ future.call.arguments    :List of 1
[17:36:40.640]   ..$ digits: int 2
[17:36:40.640]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.640]  $ ...future.elements_ii    :List of 3
[17:36:40.640]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:36:40.640]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:36:40.640]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:36:40.640]  $ ...future.seeds_ii       : NULL
[17:36:40.640]  $ ...future.globals.maxSize: NULL
[17:36:40.640]  - attr(*, "where")=List of 5
[17:36:40.640]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.640]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.640]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.640]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.640]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.640]  - attr(*, "resolved")= logi FALSE
[17:36:40.640]  - attr(*, "total_size")= num 1296
[17:36:40.640]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.640]  - attr(*, "already-done")= logi TRUE
[17:36:40.648] - copied ‘...future.FUN’ to environment
[17:36:40.648] - copied ‘future.call.arguments’ to environment
[17:36:40.648] - copied ‘...future.elements_ii’ to environment
[17:36:40.648] - copied ‘...future.seeds_ii’ to environment
[17:36:40.649] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.649] assign_globals() ... done
[17:36:40.649] requestCore(): workers = 2
[17:36:40.651] MulticoreFuture started
[17:36:40.651] - Launch lazy future ... done
[17:36:40.652] run() for ‘MulticoreFuture’ ... done
[17:36:40.652] Created future:
[17:36:40.652] plan(): Setting new future strategy stack:
[17:36:40.652] List of future strategies:
[17:36:40.652] 1. sequential:
[17:36:40.652]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.652]    - tweaked: FALSE
[17:36:40.652]    - call: NULL
[17:36:40.653] plan(): nbrOfWorkers() = 1
[17:36:40.657] plan(): Setting new future strategy stack:
[17:36:40.657] List of future strategies:
[17:36:40.657] 1. multicore:
[17:36:40.657]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:40.657]    - tweaked: FALSE
[17:36:40.657]    - call: plan(strategy)
[17:36:40.663] plan(): nbrOfWorkers() = 2
[17:36:40.652] MulticoreFuture:
[17:36:40.652] Label: ‘future_by-1’
[17:36:40.652] Expression:
[17:36:40.652] {
[17:36:40.652]     do.call(function(...) {
[17:36:40.652]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.652]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.652]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.652]             on.exit(options(oopts), add = TRUE)
[17:36:40.652]         }
[17:36:40.652]         {
[17:36:40.652]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.652]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.652]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.652]             })
[17:36:40.652]         }
[17:36:40.652]     }, args = future.call.arguments)
[17:36:40.652] }
[17:36:40.652] Lazy evaluation: FALSE
[17:36:40.652] Asynchronous evaluation: TRUE
[17:36:40.652] Local evaluation: TRUE
[17:36:40.652] Environment: R_GlobalEnv
[17:36:40.652] Capture standard output: TRUE
[17:36:40.652] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.652] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.652] Packages: <none>
[17:36:40.652] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.652] Resolved: TRUE
[17:36:40.652] Value: <not collected>
[17:36:40.652] Conditions captured: <none>
[17:36:40.652] Early signaling: FALSE
[17:36:40.652] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.652] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.664] Chunk #1 of 2 ... DONE
[17:36:40.664] Chunk #2 of 2 ...
[17:36:40.664]  - Finding globals in 'X' for chunk #2 ...
[17:36:40.665] getGlobalsAndPackages() ...
[17:36:40.665] Searching for globals...
[17:36:40.665] 
[17:36:40.665] Searching for globals ... DONE
[17:36:40.666] - globals: [0] <none>
[17:36:40.666] getGlobalsAndPackages() ... DONE
[17:36:40.666]    + additional globals found: [n=0] 
[17:36:40.666]    + additional namespaces needed: [n=0] 
[17:36:40.666]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:40.666]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:40.666]  - seeds: <none>
[17:36:40.667]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.667] getGlobalsAndPackages() ...
[17:36:40.667] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.667] Resolving globals: FALSE
[17:36:40.667] Tweak future expression to call with '...' arguments ...
[17:36:40.667] {
[17:36:40.667]     do.call(function(...) {
[17:36:40.667]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.667]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.667]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.667]             on.exit(options(oopts), add = TRUE)
[17:36:40.667]         }
[17:36:40.667]         {
[17:36:40.667]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.667]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.667]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.667]             })
[17:36:40.667]         }
[17:36:40.667]     }, args = future.call.arguments)
[17:36:40.667] }
[17:36:40.668] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.668] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.669] 
[17:36:40.669] getGlobalsAndPackages() ... DONE
[17:36:40.669] run() for ‘Future’ ...
[17:36:40.670] - state: ‘created’
[17:36:40.670] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.674] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:40.675]   - Field: ‘label’
[17:36:40.675]   - Field: ‘local’
[17:36:40.675]   - Field: ‘owner’
[17:36:40.675]   - Field: ‘envir’
[17:36:40.675]   - Field: ‘workers’
[17:36:40.676]   - Field: ‘packages’
[17:36:40.676]   - Field: ‘gc’
[17:36:40.676]   - Field: ‘job’
[17:36:40.676]   - Field: ‘conditions’
[17:36:40.676]   - Field: ‘expr’
[17:36:40.676]   - Field: ‘uuid’
[17:36:40.676]   - Field: ‘seed’
[17:36:40.677]   - Field: ‘version’
[17:36:40.677]   - Field: ‘result’
[17:36:40.677]   - Field: ‘asynchronous’
[17:36:40.677]   - Field: ‘calls’
[17:36:40.677]   - Field: ‘globals’
[17:36:40.677]   - Field: ‘stdout’
[17:36:40.678]   - Field: ‘earlySignal’
[17:36:40.678]   - Field: ‘lazy’
[17:36:40.678]   - Field: ‘state’
[17:36:40.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:40.678] - Launch lazy future ...
[17:36:40.679] Packages needed by the future expression (n = 0): <none>
[17:36:40.679] Packages needed by future strategies (n = 0): <none>
[17:36:40.680] {
[17:36:40.680]     {
[17:36:40.680]         {
[17:36:40.680]             ...future.startTime <- base::Sys.time()
[17:36:40.680]             {
[17:36:40.680]                 {
[17:36:40.680]                   {
[17:36:40.680]                     {
[17:36:40.680]                       base::local({
[17:36:40.680]                         has_future <- base::requireNamespace("future", 
[17:36:40.680]                           quietly = TRUE)
[17:36:40.680]                         if (has_future) {
[17:36:40.680]                           ns <- base::getNamespace("future")
[17:36:40.680]                           version <- ns[[".package"]][["version"]]
[17:36:40.680]                           if (is.null(version)) 
[17:36:40.680]                             version <- utils::packageVersion("future")
[17:36:40.680]                         }
[17:36:40.680]                         else {
[17:36:40.680]                           version <- NULL
[17:36:40.680]                         }
[17:36:40.680]                         if (!has_future || version < "1.8.0") {
[17:36:40.680]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.680]                             "", base::R.version$version.string), 
[17:36:40.680]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:40.680]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:40.680]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.680]                               "release", "version")], collapse = " "), 
[17:36:40.680]                             hostname = base::Sys.info()[["nodename"]])
[17:36:40.680]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.680]                             info)
[17:36:40.680]                           info <- base::paste(info, collapse = "; ")
[17:36:40.680]                           if (!has_future) {
[17:36:40.680]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.680]                               info)
[17:36:40.680]                           }
[17:36:40.680]                           else {
[17:36:40.680]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.680]                               info, version)
[17:36:40.680]                           }
[17:36:40.680]                           base::stop(msg)
[17:36:40.680]                         }
[17:36:40.680]                       })
[17:36:40.680]                     }
[17:36:40.680]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:40.680]                     base::options(mc.cores = 1L)
[17:36:40.680]                   }
[17:36:40.680]                   ...future.strategy.old <- future::plan("list")
[17:36:40.680]                   options(future.plan = NULL)
[17:36:40.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.680]                 }
[17:36:40.680]                 ...future.workdir <- getwd()
[17:36:40.680]             }
[17:36:40.680]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.680]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.680]         }
[17:36:40.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.680]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:40.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.680]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.680]             base::names(...future.oldOptions))
[17:36:40.680]     }
[17:36:40.680]     if (FALSE) {
[17:36:40.680]     }
[17:36:40.680]     else {
[17:36:40.680]         if (TRUE) {
[17:36:40.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.680]                 open = "w")
[17:36:40.680]         }
[17:36:40.680]         else {
[17:36:40.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.680]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.680]         }
[17:36:40.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.680]             base::sink(type = "output", split = FALSE)
[17:36:40.680]             base::close(...future.stdout)
[17:36:40.680]         }, add = TRUE)
[17:36:40.680]     }
[17:36:40.680]     ...future.frame <- base::sys.nframe()
[17:36:40.680]     ...future.conditions <- base::list()
[17:36:40.680]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.680]     if (FALSE) {
[17:36:40.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.680]     }
[17:36:40.680]     ...future.result <- base::tryCatch({
[17:36:40.680]         base::withCallingHandlers({
[17:36:40.680]             ...future.value <- base::withVisible(base::local({
[17:36:40.680]                 withCallingHandlers({
[17:36:40.680]                   {
[17:36:40.680]                     do.call(function(...) {
[17:36:40.680]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.680]                       if (!identical(...future.globals.maxSize.org, 
[17:36:40.680]                         ...future.globals.maxSize)) {
[17:36:40.680]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.680]                         on.exit(options(oopts), add = TRUE)
[17:36:40.680]                       }
[17:36:40.680]                       {
[17:36:40.680]                         lapply(seq_along(...future.elements_ii), 
[17:36:40.680]                           FUN = function(jj) {
[17:36:40.680]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.680]                             ...future.FUN(...future.X_jj, ...)
[17:36:40.680]                           })
[17:36:40.680]                       }
[17:36:40.680]                     }, args = future.call.arguments)
[17:36:40.680]                   }
[17:36:40.680]                 }, immediateCondition = function(cond) {
[17:36:40.680]                   save_rds <- function (object, pathname, ...) 
[17:36:40.680]                   {
[17:36:40.680]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:40.680]                     if (file_test("-f", pathname_tmp)) {
[17:36:40.680]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.680]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:40.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.680]                         fi_tmp[["mtime"]])
[17:36:40.680]                     }
[17:36:40.680]                     tryCatch({
[17:36:40.680]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:40.680]                     }, error = function(ex) {
[17:36:40.680]                       msg <- conditionMessage(ex)
[17:36:40.680]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.680]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:40.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.680]                         fi_tmp[["mtime"]], msg)
[17:36:40.680]                       ex$message <- msg
[17:36:40.680]                       stop(ex)
[17:36:40.680]                     })
[17:36:40.680]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:40.680]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:40.680]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:40.680]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.680]                       fi <- file.info(pathname)
[17:36:40.680]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:40.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.680]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:40.680]                         fi[["size"]], fi[["mtime"]])
[17:36:40.680]                       stop(msg)
[17:36:40.680]                     }
[17:36:40.680]                     invisible(pathname)
[17:36:40.680]                   }
[17:36:40.680]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:40.680]                     rootPath = tempdir()) 
[17:36:40.680]                   {
[17:36:40.680]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:40.680]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:40.680]                       tmpdir = path, fileext = ".rds")
[17:36:40.680]                     save_rds(obj, file)
[17:36:40.680]                   }
[17:36:40.680]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:40.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.680]                   {
[17:36:40.680]                     inherits <- base::inherits
[17:36:40.680]                     invokeRestart <- base::invokeRestart
[17:36:40.680]                     is.null <- base::is.null
[17:36:40.680]                     muffled <- FALSE
[17:36:40.680]                     if (inherits(cond, "message")) {
[17:36:40.680]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:40.680]                       if (muffled) 
[17:36:40.680]                         invokeRestart("muffleMessage")
[17:36:40.680]                     }
[17:36:40.680]                     else if (inherits(cond, "warning")) {
[17:36:40.680]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:40.680]                       if (muffled) 
[17:36:40.680]                         invokeRestart("muffleWarning")
[17:36:40.680]                     }
[17:36:40.680]                     else if (inherits(cond, "condition")) {
[17:36:40.680]                       if (!is.null(pattern)) {
[17:36:40.680]                         computeRestarts <- base::computeRestarts
[17:36:40.680]                         grepl <- base::grepl
[17:36:40.680]                         restarts <- computeRestarts(cond)
[17:36:40.680]                         for (restart in restarts) {
[17:36:40.680]                           name <- restart$name
[17:36:40.680]                           if (is.null(name)) 
[17:36:40.680]                             next
[17:36:40.680]                           if (!grepl(pattern, name)) 
[17:36:40.680]                             next
[17:36:40.680]                           invokeRestart(restart)
[17:36:40.680]                           muffled <- TRUE
[17:36:40.680]                           break
[17:36:40.680]                         }
[17:36:40.680]                       }
[17:36:40.680]                     }
[17:36:40.680]                     invisible(muffled)
[17:36:40.680]                   }
[17:36:40.680]                   muffleCondition(cond)
[17:36:40.680]                 })
[17:36:40.680]             }))
[17:36:40.680]             future::FutureResult(value = ...future.value$value, 
[17:36:40.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.680]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.680]                     ...future.globalenv.names))
[17:36:40.680]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.680]         }, condition = base::local({
[17:36:40.680]             c <- base::c
[17:36:40.680]             inherits <- base::inherits
[17:36:40.680]             invokeRestart <- base::invokeRestart
[17:36:40.680]             length <- base::length
[17:36:40.680]             list <- base::list
[17:36:40.680]             seq.int <- base::seq.int
[17:36:40.680]             signalCondition <- base::signalCondition
[17:36:40.680]             sys.calls <- base::sys.calls
[17:36:40.680]             `[[` <- base::`[[`
[17:36:40.680]             `+` <- base::`+`
[17:36:40.680]             `<<-` <- base::`<<-`
[17:36:40.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.680]                   3L)]
[17:36:40.680]             }
[17:36:40.680]             function(cond) {
[17:36:40.680]                 is_error <- inherits(cond, "error")
[17:36:40.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.680]                   NULL)
[17:36:40.680]                 if (is_error) {
[17:36:40.680]                   sessionInformation <- function() {
[17:36:40.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.680]                       search = base::search(), system = base::Sys.info())
[17:36:40.680]                   }
[17:36:40.680]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.680]                     cond$call), session = sessionInformation(), 
[17:36:40.680]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.680]                   signalCondition(cond)
[17:36:40.680]                 }
[17:36:40.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.680]                 "immediateCondition"))) {
[17:36:40.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.680]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.680]                   if (TRUE && !signal) {
[17:36:40.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.680]                     {
[17:36:40.680]                       inherits <- base::inherits
[17:36:40.680]                       invokeRestart <- base::invokeRestart
[17:36:40.680]                       is.null <- base::is.null
[17:36:40.680]                       muffled <- FALSE
[17:36:40.680]                       if (inherits(cond, "message")) {
[17:36:40.680]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.680]                         if (muffled) 
[17:36:40.680]                           invokeRestart("muffleMessage")
[17:36:40.680]                       }
[17:36:40.680]                       else if (inherits(cond, "warning")) {
[17:36:40.680]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.680]                         if (muffled) 
[17:36:40.680]                           invokeRestart("muffleWarning")
[17:36:40.680]                       }
[17:36:40.680]                       else if (inherits(cond, "condition")) {
[17:36:40.680]                         if (!is.null(pattern)) {
[17:36:40.680]                           computeRestarts <- base::computeRestarts
[17:36:40.680]                           grepl <- base::grepl
[17:36:40.680]                           restarts <- computeRestarts(cond)
[17:36:40.680]                           for (restart in restarts) {
[17:36:40.680]                             name <- restart$name
[17:36:40.680]                             if (is.null(name)) 
[17:36:40.680]                               next
[17:36:40.680]                             if (!grepl(pattern, name)) 
[17:36:40.680]                               next
[17:36:40.680]                             invokeRestart(restart)
[17:36:40.680]                             muffled <- TRUE
[17:36:40.680]                             break
[17:36:40.680]                           }
[17:36:40.680]                         }
[17:36:40.680]                       }
[17:36:40.680]                       invisible(muffled)
[17:36:40.680]                     }
[17:36:40.680]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.680]                   }
[17:36:40.680]                 }
[17:36:40.680]                 else {
[17:36:40.680]                   if (TRUE) {
[17:36:40.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.680]                     {
[17:36:40.680]                       inherits <- base::inherits
[17:36:40.680]                       invokeRestart <- base::invokeRestart
[17:36:40.680]                       is.null <- base::is.null
[17:36:40.680]                       muffled <- FALSE
[17:36:40.680]                       if (inherits(cond, "message")) {
[17:36:40.680]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.680]                         if (muffled) 
[17:36:40.680]                           invokeRestart("muffleMessage")
[17:36:40.680]                       }
[17:36:40.680]                       else if (inherits(cond, "warning")) {
[17:36:40.680]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.680]                         if (muffled) 
[17:36:40.680]                           invokeRestart("muffleWarning")
[17:36:40.680]                       }
[17:36:40.680]                       else if (inherits(cond, "condition")) {
[17:36:40.680]                         if (!is.null(pattern)) {
[17:36:40.680]                           computeRestarts <- base::computeRestarts
[17:36:40.680]                           grepl <- base::grepl
[17:36:40.680]                           restarts <- computeRestarts(cond)
[17:36:40.680]                           for (restart in restarts) {
[17:36:40.680]                             name <- restart$name
[17:36:40.680]                             if (is.null(name)) 
[17:36:40.680]                               next
[17:36:40.680]                             if (!grepl(pattern, name)) 
[17:36:40.680]                               next
[17:36:40.680]                             invokeRestart(restart)
[17:36:40.680]                             muffled <- TRUE
[17:36:40.680]                             break
[17:36:40.680]                           }
[17:36:40.680]                         }
[17:36:40.680]                       }
[17:36:40.680]                       invisible(muffled)
[17:36:40.680]                     }
[17:36:40.680]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.680]                   }
[17:36:40.680]                 }
[17:36:40.680]             }
[17:36:40.680]         }))
[17:36:40.680]     }, error = function(ex) {
[17:36:40.680]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.680]                 ...future.rng), started = ...future.startTime, 
[17:36:40.680]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.680]             version = "1.8"), class = "FutureResult")
[17:36:40.680]     }, finally = {
[17:36:40.680]         if (!identical(...future.workdir, getwd())) 
[17:36:40.680]             setwd(...future.workdir)
[17:36:40.680]         {
[17:36:40.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.680]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.680]             }
[17:36:40.680]             base::options(...future.oldOptions)
[17:36:40.680]             if (.Platform$OS.type == "windows") {
[17:36:40.680]                 old_names <- names(...future.oldEnvVars)
[17:36:40.680]                 envs <- base::Sys.getenv()
[17:36:40.680]                 names <- names(envs)
[17:36:40.680]                 common <- intersect(names, old_names)
[17:36:40.680]                 added <- setdiff(names, old_names)
[17:36:40.680]                 removed <- setdiff(old_names, names)
[17:36:40.680]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.680]                   envs[common]]
[17:36:40.680]                 NAMES <- toupper(changed)
[17:36:40.680]                 args <- list()
[17:36:40.680]                 for (kk in seq_along(NAMES)) {
[17:36:40.680]                   name <- changed[[kk]]
[17:36:40.680]                   NAME <- NAMES[[kk]]
[17:36:40.680]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.680]                     next
[17:36:40.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.680]                 }
[17:36:40.680]                 NAMES <- toupper(added)
[17:36:40.680]                 for (kk in seq_along(NAMES)) {
[17:36:40.680]                   name <- added[[kk]]
[17:36:40.680]                   NAME <- NAMES[[kk]]
[17:36:40.680]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.680]                     next
[17:36:40.680]                   args[[name]] <- ""
[17:36:40.680]                 }
[17:36:40.680]                 NAMES <- toupper(removed)
[17:36:40.680]                 for (kk in seq_along(NAMES)) {
[17:36:40.680]                   name <- removed[[kk]]
[17:36:40.680]                   NAME <- NAMES[[kk]]
[17:36:40.680]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.680]                     next
[17:36:40.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.680]                 }
[17:36:40.680]                 if (length(args) > 0) 
[17:36:40.680]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.680]             }
[17:36:40.680]             else {
[17:36:40.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.680]             }
[17:36:40.680]             {
[17:36:40.680]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.680]                   0L) {
[17:36:40.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.680]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.680]                   base::options(opts)
[17:36:40.680]                 }
[17:36:40.680]                 {
[17:36:40.680]                   {
[17:36:40.680]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:40.680]                     NULL
[17:36:40.680]                   }
[17:36:40.680]                   options(future.plan = NULL)
[17:36:40.680]                   if (is.na(NA_character_)) 
[17:36:40.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.680]                     .init = FALSE)
[17:36:40.680]                 }
[17:36:40.680]             }
[17:36:40.680]         }
[17:36:40.680]     })
[17:36:40.680]     if (TRUE) {
[17:36:40.680]         base::sink(type = "output", split = FALSE)
[17:36:40.680]         if (TRUE) {
[17:36:40.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.680]         }
[17:36:40.680]         else {
[17:36:40.680]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.680]         }
[17:36:40.680]         base::close(...future.stdout)
[17:36:40.680]         ...future.stdout <- NULL
[17:36:40.680]     }
[17:36:40.680]     ...future.result$conditions <- ...future.conditions
[17:36:40.680]     ...future.result$finished <- base::Sys.time()
[17:36:40.680]     ...future.result
[17:36:40.680] }
[17:36:40.683] assign_globals() ...
[17:36:40.683] List of 5
[17:36:40.683]  $ ...future.FUN            :function (object, ...)  
[17:36:40.683]  $ future.call.arguments    :List of 1
[17:36:40.683]   ..$ digits: int 2
[17:36:40.683]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.683]  $ ...future.elements_ii    :List of 3
[17:36:40.683]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:36:40.683]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:36:40.683]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:36:40.683]  $ ...future.seeds_ii       : NULL
[17:36:40.683]  $ ...future.globals.maxSize: NULL
[17:36:40.683]  - attr(*, "where")=List of 5
[17:36:40.683]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.683]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.683]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.683]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.683]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.683]  - attr(*, "resolved")= logi FALSE
[17:36:40.683]  - attr(*, "total_size")= num 1296
[17:36:40.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.683]  - attr(*, "already-done")= logi TRUE
[17:36:40.695] - copied ‘...future.FUN’ to environment
[17:36:40.696] - copied ‘future.call.arguments’ to environment
[17:36:40.696] - copied ‘...future.elements_ii’ to environment
[17:36:40.696] - copied ‘...future.seeds_ii’ to environment
[17:36:40.696] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.696] assign_globals() ... done
[17:36:40.696] requestCore(): workers = 2
[17:36:40.699] MulticoreFuture started
[17:36:40.700] - Launch lazy future ... done
[17:36:40.700] plan(): Setting new future strategy stack:
[17:36:40.700] run() for ‘MulticoreFuture’ ... done
[17:36:40.701] Created future:
[17:36:40.700] List of future strategies:
[17:36:40.700] 1. sequential:
[17:36:40.700]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.700]    - tweaked: FALSE
[17:36:40.700]    - call: NULL
[17:36:40.702] plan(): nbrOfWorkers() = 1
[17:36:40.705] plan(): Setting new future strategy stack:
[17:36:40.706] List of future strategies:
[17:36:40.706] 1. multicore:
[17:36:40.706]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:40.706]    - tweaked: FALSE
[17:36:40.706]    - call: plan(strategy)
[17:36:40.711] plan(): nbrOfWorkers() = 2
[17:36:40.701] MulticoreFuture:
[17:36:40.701] Label: ‘future_by-2’
[17:36:40.701] Expression:
[17:36:40.701] {
[17:36:40.701]     do.call(function(...) {
[17:36:40.701]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.701]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.701]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.701]             on.exit(options(oopts), add = TRUE)
[17:36:40.701]         }
[17:36:40.701]         {
[17:36:40.701]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.701]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.701]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.701]             })
[17:36:40.701]         }
[17:36:40.701]     }, args = future.call.arguments)
[17:36:40.701] }
[17:36:40.701] Lazy evaluation: FALSE
[17:36:40.701] Asynchronous evaluation: TRUE
[17:36:40.701] Local evaluation: TRUE
[17:36:40.701] Environment: R_GlobalEnv
[17:36:40.701] Capture standard output: TRUE
[17:36:40.701] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.701] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.701] Packages: <none>
[17:36:40.701] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.701] Resolved: TRUE
[17:36:40.701] Value: <not collected>
[17:36:40.701] Conditions captured: <none>
[17:36:40.701] Early signaling: FALSE
[17:36:40.701] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.701] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.712] Chunk #2 of 2 ... DONE
[17:36:40.712] Launching 2 futures (chunks) ... DONE
[17:36:40.713] Resolving 2 futures (chunks) ...
[17:36:40.713] resolve() on list ...
[17:36:40.713]  recursive: 0
[17:36:40.713]  length: 2
[17:36:40.713] 
[17:36:40.713] Future #1
[17:36:40.714] result() for MulticoreFuture ...
[17:36:40.715] result() for MulticoreFuture ...
[17:36:40.715] result() for MulticoreFuture ... done
[17:36:40.715] result() for MulticoreFuture ... done
[17:36:40.715] result() for MulticoreFuture ...
[17:36:40.715] result() for MulticoreFuture ... done
[17:36:40.715] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:40.716] - nx: 2
[17:36:40.716] - relay: TRUE
[17:36:40.716] - stdout: TRUE
[17:36:40.716] - signal: TRUE
[17:36:40.716] - resignal: FALSE
[17:36:40.716] - force: TRUE
[17:36:40.717] - relayed: [n=2] FALSE, FALSE
[17:36:40.717] - queued futures: [n=2] FALSE, FALSE
[17:36:40.717]  - until=1
[17:36:40.717]  - relaying element #1
[17:36:40.717] result() for MulticoreFuture ...
[17:36:40.717] result() for MulticoreFuture ... done
[17:36:40.718] result() for MulticoreFuture ...
[17:36:40.718] result() for MulticoreFuture ... done
[17:36:40.718] result() for MulticoreFuture ...
[17:36:40.718] result() for MulticoreFuture ... done
[17:36:40.718] result() for MulticoreFuture ...
[17:36:40.718] result() for MulticoreFuture ... done
[17:36:40.718] - relayed: [n=2] TRUE, FALSE
[17:36:40.719] - queued futures: [n=2] TRUE, FALSE
[17:36:40.719] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:40.719]  length: 1 (resolved future 1)
[17:36:40.719] Future #2
[17:36:40.719] result() for MulticoreFuture ...
[17:36:40.720] result() for MulticoreFuture ...
[17:36:40.720] result() for MulticoreFuture ... done
[17:36:40.720] result() for MulticoreFuture ... done
[17:36:40.721] result() for MulticoreFuture ...
[17:36:40.721] result() for MulticoreFuture ... done
[17:36:40.721] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:40.721] - nx: 2
[17:36:40.721] - relay: TRUE
[17:36:40.721] - stdout: TRUE
[17:36:40.721] - signal: TRUE
[17:36:40.721] - resignal: FALSE
[17:36:40.722] - force: TRUE
[17:36:40.722] - relayed: [n=2] TRUE, FALSE
[17:36:40.722] - queued futures: [n=2] TRUE, FALSE
[17:36:40.722]  - until=2
[17:36:40.722]  - relaying element #2
[17:36:40.722] result() for MulticoreFuture ...
[17:36:40.722] result() for MulticoreFuture ... done
[17:36:40.722] result() for MulticoreFuture ...
[17:36:40.723] result() for MulticoreFuture ... done
[17:36:40.723] result() for MulticoreFuture ...
[17:36:40.723] result() for MulticoreFuture ... done
[17:36:40.723] result() for MulticoreFuture ...
[17:36:40.723] result() for MulticoreFuture ... done
[17:36:40.723] - relayed: [n=2] TRUE, TRUE
[17:36:40.723] - queued futures: [n=2] TRUE, TRUE
[17:36:40.723] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:40.724]  length: 0 (resolved future 2)
[17:36:40.724] Relaying remaining futures
[17:36:40.724] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.724] - nx: 2
[17:36:40.724] - relay: TRUE
[17:36:40.724] - stdout: TRUE
[17:36:40.724] - signal: TRUE
[17:36:40.724] - resignal: FALSE
[17:36:40.724] - force: TRUE
[17:36:40.725] - relayed: [n=2] TRUE, TRUE
[17:36:40.725] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:40.725] - relayed: [n=2] TRUE, TRUE
[17:36:40.725] - queued futures: [n=2] TRUE, TRUE
[17:36:40.725] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.725] resolve() on list ... DONE
[17:36:40.725] result() for MulticoreFuture ...
[17:36:40.725] result() for MulticoreFuture ... done
[17:36:40.725] result() for MulticoreFuture ...
[17:36:40.726] result() for MulticoreFuture ... done
[17:36:40.726] result() for MulticoreFuture ...
[17:36:40.726] result() for MulticoreFuture ... done
[17:36:40.726] result() for MulticoreFuture ...
[17:36:40.726] result() for MulticoreFuture ... done
[17:36:40.726]  - Number of value chunks collected: 2
[17:36:40.726] Resolving 2 futures (chunks) ... DONE
[17:36:40.726] Reducing values from 2 chunks ...
[17:36:40.727]  - Number of values collected after concatenation: 6
[17:36:40.727]  - Number of values expected: 6
[17:36:40.727] Reducing values from 2 chunks ... DONE
[17:36:40.727] future_lapply() ... DONE
[17:36:40.727] future_by_internal() ... DONE
[17:36:40.728] future_by_internal() ...
[17:36:40.729] future_lapply() ...
[17:36:40.736] Number of chunks: 2
[17:36:40.736] getGlobalsAndPackagesXApply() ...
[17:36:40.736]  - future.globals: TRUE
[17:36:40.736] getGlobalsAndPackages() ...
[17:36:40.737] Searching for globals...
[17:36:40.739] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:40.739] Searching for globals ... DONE
[17:36:40.739] Resolving globals: FALSE
[17:36:40.740] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:36:40.740] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:36:40.740] - globals: [1] ‘FUN’
[17:36:40.740] - packages: [1] ‘stats’
[17:36:40.741] getGlobalsAndPackages() ... DONE
[17:36:40.741]  - globals found/used: [n=1] ‘FUN’
[17:36:40.741]  - needed namespaces: [n=1] ‘stats’
[17:36:40.741] Finding globals ... DONE
[17:36:40.741]  - use_args: TRUE
[17:36:40.741]  - Getting '...' globals ...
[17:36:40.741] resolve() on list ...
[17:36:40.741]  recursive: 0
[17:36:40.742]  length: 1
[17:36:40.742]  elements: ‘...’
[17:36:40.742]  length: 0 (resolved future 1)
[17:36:40.742] resolve() on list ... DONE
[17:36:40.742]    - '...' content: [n=1] ‘singular.ok’
[17:36:40.742] List of 1
[17:36:40.742]  $ ...:List of 1
[17:36:40.742]   ..$ singular.ok: logi FALSE
[17:36:40.742]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.742]  - attr(*, "where")=List of 1
[17:36:40.742]   ..$ ...:<environment: 0x5622fc3560e8> 
[17:36:40.742]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.742]  - attr(*, "resolved")= logi TRUE
[17:36:40.742]  - attr(*, "total_size")= num NA
[17:36:40.745]  - Getting '...' globals ... DONE
[17:36:40.745] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:40.745] List of 2
[17:36:40.745]  $ ...future.FUN:function (x, ...)  
[17:36:40.745]  $ ...          :List of 1
[17:36:40.745]   ..$ singular.ok: logi FALSE
[17:36:40.745]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.745]  - attr(*, "where")=List of 2
[17:36:40.745]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.745]   ..$ ...          :<environment: 0x5622fc3560e8> 
[17:36:40.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.745]  - attr(*, "resolved")= logi FALSE
[17:36:40.745]  - attr(*, "total_size")= num 5384
[17:36:40.748] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:40.749] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.749] Number of futures (= number of chunks): 2
[17:36:40.749] Launching 2 futures (chunks) ...
[17:36:40.749] Chunk #1 of 2 ...
[17:36:40.749]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.749] getGlobalsAndPackages() ...
[17:36:40.749] Searching for globals...
[17:36:40.750] 
[17:36:40.750] Searching for globals ... DONE
[17:36:40.750] - globals: [0] <none>
[17:36:40.750] getGlobalsAndPackages() ... DONE
[17:36:40.750]    + additional globals found: [n=0] 
[17:36:40.750]    + additional namespaces needed: [n=0] 
[17:36:40.750]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.750]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:40.750]  - seeds: <none>
[17:36:40.750]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.751] getGlobalsAndPackages() ...
[17:36:40.751] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.751] Resolving globals: FALSE
[17:36:40.751] Tweak future expression to call with '...' arguments ...
[17:36:40.751] {
[17:36:40.751]     do.call(function(...) {
[17:36:40.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.751]             on.exit(options(oopts), add = TRUE)
[17:36:40.751]         }
[17:36:40.751]         {
[17:36:40.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.751]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.751]             })
[17:36:40.751]         }
[17:36:40.751]     }, args = future.call.arguments)
[17:36:40.751] }
[17:36:40.751] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.752] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.752] 
[17:36:40.752] getGlobalsAndPackages() ... DONE
[17:36:40.752] run() for ‘Future’ ...
[17:36:40.752] - state: ‘created’
[17:36:40.753] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.756] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.756] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:40.756]   - Field: ‘label’
[17:36:40.756]   - Field: ‘local’
[17:36:40.757]   - Field: ‘owner’
[17:36:40.757]   - Field: ‘envir’
[17:36:40.759]   - Field: ‘workers’
[17:36:40.759]   - Field: ‘packages’
[17:36:40.759]   - Field: ‘gc’
[17:36:40.759]   - Field: ‘job’
[17:36:40.759]   - Field: ‘conditions’
[17:36:40.759]   - Field: ‘expr’
[17:36:40.759]   - Field: ‘uuid’
[17:36:40.759]   - Field: ‘seed’
[17:36:40.760]   - Field: ‘version’
[17:36:40.760]   - Field: ‘result’
[17:36:40.760]   - Field: ‘asynchronous’
[17:36:40.760]   - Field: ‘calls’
[17:36:40.760]   - Field: ‘globals’
[17:36:40.760]   - Field: ‘stdout’
[17:36:40.760]   - Field: ‘earlySignal’
[17:36:40.760]   - Field: ‘lazy’
[17:36:40.760]   - Field: ‘state’
[17:36:40.761] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:40.761] - Launch lazy future ...
[17:36:40.761] Packages needed by the future expression (n = 1): ‘stats’
[17:36:40.761] Packages needed by future strategies (n = 0): <none>
[17:36:40.762] {
[17:36:40.762]     {
[17:36:40.762]         {
[17:36:40.762]             ...future.startTime <- base::Sys.time()
[17:36:40.762]             {
[17:36:40.762]                 {
[17:36:40.762]                   {
[17:36:40.762]                     {
[17:36:40.762]                       {
[17:36:40.762]                         base::local({
[17:36:40.762]                           has_future <- base::requireNamespace("future", 
[17:36:40.762]                             quietly = TRUE)
[17:36:40.762]                           if (has_future) {
[17:36:40.762]                             ns <- base::getNamespace("future")
[17:36:40.762]                             version <- ns[[".package"]][["version"]]
[17:36:40.762]                             if (is.null(version)) 
[17:36:40.762]                               version <- utils::packageVersion("future")
[17:36:40.762]                           }
[17:36:40.762]                           else {
[17:36:40.762]                             version <- NULL
[17:36:40.762]                           }
[17:36:40.762]                           if (!has_future || version < "1.8.0") {
[17:36:40.762]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.762]                               "", base::R.version$version.string), 
[17:36:40.762]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:40.762]                                 base::R.version$platform, 8 * 
[17:36:40.762]                                   base::.Machine$sizeof.pointer), 
[17:36:40.762]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.762]                                 "release", "version")], collapse = " "), 
[17:36:40.762]                               hostname = base::Sys.info()[["nodename"]])
[17:36:40.762]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.762]                               info)
[17:36:40.762]                             info <- base::paste(info, collapse = "; ")
[17:36:40.762]                             if (!has_future) {
[17:36:40.762]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.762]                                 info)
[17:36:40.762]                             }
[17:36:40.762]                             else {
[17:36:40.762]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.762]                                 info, version)
[17:36:40.762]                             }
[17:36:40.762]                             base::stop(msg)
[17:36:40.762]                           }
[17:36:40.762]                         })
[17:36:40.762]                       }
[17:36:40.762]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:40.762]                       base::options(mc.cores = 1L)
[17:36:40.762]                     }
[17:36:40.762]                     base::local({
[17:36:40.762]                       for (pkg in "stats") {
[17:36:40.762]                         base::loadNamespace(pkg)
[17:36:40.762]                         base::library(pkg, character.only = TRUE)
[17:36:40.762]                       }
[17:36:40.762]                     })
[17:36:40.762]                   }
[17:36:40.762]                   ...future.strategy.old <- future::plan("list")
[17:36:40.762]                   options(future.plan = NULL)
[17:36:40.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.762]                 }
[17:36:40.762]                 ...future.workdir <- getwd()
[17:36:40.762]             }
[17:36:40.762]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.762]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.762]         }
[17:36:40.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.762]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:40.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.762]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.762]             base::names(...future.oldOptions))
[17:36:40.762]     }
[17:36:40.762]     if (FALSE) {
[17:36:40.762]     }
[17:36:40.762]     else {
[17:36:40.762]         if (TRUE) {
[17:36:40.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.762]                 open = "w")
[17:36:40.762]         }
[17:36:40.762]         else {
[17:36:40.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.762]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.762]         }
[17:36:40.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.762]             base::sink(type = "output", split = FALSE)
[17:36:40.762]             base::close(...future.stdout)
[17:36:40.762]         }, add = TRUE)
[17:36:40.762]     }
[17:36:40.762]     ...future.frame <- base::sys.nframe()
[17:36:40.762]     ...future.conditions <- base::list()
[17:36:40.762]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.762]     if (FALSE) {
[17:36:40.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.762]     }
[17:36:40.762]     ...future.result <- base::tryCatch({
[17:36:40.762]         base::withCallingHandlers({
[17:36:40.762]             ...future.value <- base::withVisible(base::local({
[17:36:40.762]                 withCallingHandlers({
[17:36:40.762]                   {
[17:36:40.762]                     do.call(function(...) {
[17:36:40.762]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.762]                       if (!identical(...future.globals.maxSize.org, 
[17:36:40.762]                         ...future.globals.maxSize)) {
[17:36:40.762]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.762]                         on.exit(options(oopts), add = TRUE)
[17:36:40.762]                       }
[17:36:40.762]                       {
[17:36:40.762]                         lapply(seq_along(...future.elements_ii), 
[17:36:40.762]                           FUN = function(jj) {
[17:36:40.762]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.762]                             ...future.FUN(...future.X_jj, ...)
[17:36:40.762]                           })
[17:36:40.762]                       }
[17:36:40.762]                     }, args = future.call.arguments)
[17:36:40.762]                   }
[17:36:40.762]                 }, immediateCondition = function(cond) {
[17:36:40.762]                   save_rds <- function (object, pathname, ...) 
[17:36:40.762]                   {
[17:36:40.762]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:40.762]                     if (file_test("-f", pathname_tmp)) {
[17:36:40.762]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.762]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:40.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.762]                         fi_tmp[["mtime"]])
[17:36:40.762]                     }
[17:36:40.762]                     tryCatch({
[17:36:40.762]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:40.762]                     }, error = function(ex) {
[17:36:40.762]                       msg <- conditionMessage(ex)
[17:36:40.762]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.762]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:40.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.762]                         fi_tmp[["mtime"]], msg)
[17:36:40.762]                       ex$message <- msg
[17:36:40.762]                       stop(ex)
[17:36:40.762]                     })
[17:36:40.762]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:40.762]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:40.762]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:40.762]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.762]                       fi <- file.info(pathname)
[17:36:40.762]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:40.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.762]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:40.762]                         fi[["size"]], fi[["mtime"]])
[17:36:40.762]                       stop(msg)
[17:36:40.762]                     }
[17:36:40.762]                     invisible(pathname)
[17:36:40.762]                   }
[17:36:40.762]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:40.762]                     rootPath = tempdir()) 
[17:36:40.762]                   {
[17:36:40.762]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:40.762]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:40.762]                       tmpdir = path, fileext = ".rds")
[17:36:40.762]                     save_rds(obj, file)
[17:36:40.762]                   }
[17:36:40.762]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:40.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.762]                   {
[17:36:40.762]                     inherits <- base::inherits
[17:36:40.762]                     invokeRestart <- base::invokeRestart
[17:36:40.762]                     is.null <- base::is.null
[17:36:40.762]                     muffled <- FALSE
[17:36:40.762]                     if (inherits(cond, "message")) {
[17:36:40.762]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:40.762]                       if (muffled) 
[17:36:40.762]                         invokeRestart("muffleMessage")
[17:36:40.762]                     }
[17:36:40.762]                     else if (inherits(cond, "warning")) {
[17:36:40.762]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:40.762]                       if (muffled) 
[17:36:40.762]                         invokeRestart("muffleWarning")
[17:36:40.762]                     }
[17:36:40.762]                     else if (inherits(cond, "condition")) {
[17:36:40.762]                       if (!is.null(pattern)) {
[17:36:40.762]                         computeRestarts <- base::computeRestarts
[17:36:40.762]                         grepl <- base::grepl
[17:36:40.762]                         restarts <- computeRestarts(cond)
[17:36:40.762]                         for (restart in restarts) {
[17:36:40.762]                           name <- restart$name
[17:36:40.762]                           if (is.null(name)) 
[17:36:40.762]                             next
[17:36:40.762]                           if (!grepl(pattern, name)) 
[17:36:40.762]                             next
[17:36:40.762]                           invokeRestart(restart)
[17:36:40.762]                           muffled <- TRUE
[17:36:40.762]                           break
[17:36:40.762]                         }
[17:36:40.762]                       }
[17:36:40.762]                     }
[17:36:40.762]                     invisible(muffled)
[17:36:40.762]                   }
[17:36:40.762]                   muffleCondition(cond)
[17:36:40.762]                 })
[17:36:40.762]             }))
[17:36:40.762]             future::FutureResult(value = ...future.value$value, 
[17:36:40.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.762]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.762]                     ...future.globalenv.names))
[17:36:40.762]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.762]         }, condition = base::local({
[17:36:40.762]             c <- base::c
[17:36:40.762]             inherits <- base::inherits
[17:36:40.762]             invokeRestart <- base::invokeRestart
[17:36:40.762]             length <- base::length
[17:36:40.762]             list <- base::list
[17:36:40.762]             seq.int <- base::seq.int
[17:36:40.762]             signalCondition <- base::signalCondition
[17:36:40.762]             sys.calls <- base::sys.calls
[17:36:40.762]             `[[` <- base::`[[`
[17:36:40.762]             `+` <- base::`+`
[17:36:40.762]             `<<-` <- base::`<<-`
[17:36:40.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.762]                   3L)]
[17:36:40.762]             }
[17:36:40.762]             function(cond) {
[17:36:40.762]                 is_error <- inherits(cond, "error")
[17:36:40.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.762]                   NULL)
[17:36:40.762]                 if (is_error) {
[17:36:40.762]                   sessionInformation <- function() {
[17:36:40.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.762]                       search = base::search(), system = base::Sys.info())
[17:36:40.762]                   }
[17:36:40.762]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.762]                     cond$call), session = sessionInformation(), 
[17:36:40.762]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.762]                   signalCondition(cond)
[17:36:40.762]                 }
[17:36:40.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.762]                 "immediateCondition"))) {
[17:36:40.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.762]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.762]                   if (TRUE && !signal) {
[17:36:40.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.762]                     {
[17:36:40.762]                       inherits <- base::inherits
[17:36:40.762]                       invokeRestart <- base::invokeRestart
[17:36:40.762]                       is.null <- base::is.null
[17:36:40.762]                       muffled <- FALSE
[17:36:40.762]                       if (inherits(cond, "message")) {
[17:36:40.762]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.762]                         if (muffled) 
[17:36:40.762]                           invokeRestart("muffleMessage")
[17:36:40.762]                       }
[17:36:40.762]                       else if (inherits(cond, "warning")) {
[17:36:40.762]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.762]                         if (muffled) 
[17:36:40.762]                           invokeRestart("muffleWarning")
[17:36:40.762]                       }
[17:36:40.762]                       else if (inherits(cond, "condition")) {
[17:36:40.762]                         if (!is.null(pattern)) {
[17:36:40.762]                           computeRestarts <- base::computeRestarts
[17:36:40.762]                           grepl <- base::grepl
[17:36:40.762]                           restarts <- computeRestarts(cond)
[17:36:40.762]                           for (restart in restarts) {
[17:36:40.762]                             name <- restart$name
[17:36:40.762]                             if (is.null(name)) 
[17:36:40.762]                               next
[17:36:40.762]                             if (!grepl(pattern, name)) 
[17:36:40.762]                               next
[17:36:40.762]                             invokeRestart(restart)
[17:36:40.762]                             muffled <- TRUE
[17:36:40.762]                             break
[17:36:40.762]                           }
[17:36:40.762]                         }
[17:36:40.762]                       }
[17:36:40.762]                       invisible(muffled)
[17:36:40.762]                     }
[17:36:40.762]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.762]                   }
[17:36:40.762]                 }
[17:36:40.762]                 else {
[17:36:40.762]                   if (TRUE) {
[17:36:40.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.762]                     {
[17:36:40.762]                       inherits <- base::inherits
[17:36:40.762]                       invokeRestart <- base::invokeRestart
[17:36:40.762]                       is.null <- base::is.null
[17:36:40.762]                       muffled <- FALSE
[17:36:40.762]                       if (inherits(cond, "message")) {
[17:36:40.762]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.762]                         if (muffled) 
[17:36:40.762]                           invokeRestart("muffleMessage")
[17:36:40.762]                       }
[17:36:40.762]                       else if (inherits(cond, "warning")) {
[17:36:40.762]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.762]                         if (muffled) 
[17:36:40.762]                           invokeRestart("muffleWarning")
[17:36:40.762]                       }
[17:36:40.762]                       else if (inherits(cond, "condition")) {
[17:36:40.762]                         if (!is.null(pattern)) {
[17:36:40.762]                           computeRestarts <- base::computeRestarts
[17:36:40.762]                           grepl <- base::grepl
[17:36:40.762]                           restarts <- computeRestarts(cond)
[17:36:40.762]                           for (restart in restarts) {
[17:36:40.762]                             name <- restart$name
[17:36:40.762]                             if (is.null(name)) 
[17:36:40.762]                               next
[17:36:40.762]                             if (!grepl(pattern, name)) 
[17:36:40.762]                               next
[17:36:40.762]                             invokeRestart(restart)
[17:36:40.762]                             muffled <- TRUE
[17:36:40.762]                             break
[17:36:40.762]                           }
[17:36:40.762]                         }
[17:36:40.762]                       }
[17:36:40.762]                       invisible(muffled)
[17:36:40.762]                     }
[17:36:40.762]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.762]                   }
[17:36:40.762]                 }
[17:36:40.762]             }
[17:36:40.762]         }))
[17:36:40.762]     }, error = function(ex) {
[17:36:40.762]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.762]                 ...future.rng), started = ...future.startTime, 
[17:36:40.762]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.762]             version = "1.8"), class = "FutureResult")
[17:36:40.762]     }, finally = {
[17:36:40.762]         if (!identical(...future.workdir, getwd())) 
[17:36:40.762]             setwd(...future.workdir)
[17:36:40.762]         {
[17:36:40.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.762]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.762]             }
[17:36:40.762]             base::options(...future.oldOptions)
[17:36:40.762]             if (.Platform$OS.type == "windows") {
[17:36:40.762]                 old_names <- names(...future.oldEnvVars)
[17:36:40.762]                 envs <- base::Sys.getenv()
[17:36:40.762]                 names <- names(envs)
[17:36:40.762]                 common <- intersect(names, old_names)
[17:36:40.762]                 added <- setdiff(names, old_names)
[17:36:40.762]                 removed <- setdiff(old_names, names)
[17:36:40.762]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.762]                   envs[common]]
[17:36:40.762]                 NAMES <- toupper(changed)
[17:36:40.762]                 args <- list()
[17:36:40.762]                 for (kk in seq_along(NAMES)) {
[17:36:40.762]                   name <- changed[[kk]]
[17:36:40.762]                   NAME <- NAMES[[kk]]
[17:36:40.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.762]                     next
[17:36:40.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.762]                 }
[17:36:40.762]                 NAMES <- toupper(added)
[17:36:40.762]                 for (kk in seq_along(NAMES)) {
[17:36:40.762]                   name <- added[[kk]]
[17:36:40.762]                   NAME <- NAMES[[kk]]
[17:36:40.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.762]                     next
[17:36:40.762]                   args[[name]] <- ""
[17:36:40.762]                 }
[17:36:40.762]                 NAMES <- toupper(removed)
[17:36:40.762]                 for (kk in seq_along(NAMES)) {
[17:36:40.762]                   name <- removed[[kk]]
[17:36:40.762]                   NAME <- NAMES[[kk]]
[17:36:40.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.762]                     next
[17:36:40.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.762]                 }
[17:36:40.762]                 if (length(args) > 0) 
[17:36:40.762]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.762]             }
[17:36:40.762]             else {
[17:36:40.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.762]             }
[17:36:40.762]             {
[17:36:40.762]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.762]                   0L) {
[17:36:40.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.762]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.762]                   base::options(opts)
[17:36:40.762]                 }
[17:36:40.762]                 {
[17:36:40.762]                   {
[17:36:40.762]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:40.762]                     NULL
[17:36:40.762]                   }
[17:36:40.762]                   options(future.plan = NULL)
[17:36:40.762]                   if (is.na(NA_character_)) 
[17:36:40.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.762]                     .init = FALSE)
[17:36:40.762]                 }
[17:36:40.762]             }
[17:36:40.762]         }
[17:36:40.762]     })
[17:36:40.762]     if (TRUE) {
[17:36:40.762]         base::sink(type = "output", split = FALSE)
[17:36:40.762]         if (TRUE) {
[17:36:40.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.762]         }
[17:36:40.762]         else {
[17:36:40.762]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.762]         }
[17:36:40.762]         base::close(...future.stdout)
[17:36:40.762]         ...future.stdout <- NULL
[17:36:40.762]     }
[17:36:40.762]     ...future.result$conditions <- ...future.conditions
[17:36:40.762]     ...future.result$finished <- base::Sys.time()
[17:36:40.762]     ...future.result
[17:36:40.762] }
[17:36:40.764] assign_globals() ...
[17:36:40.764] List of 5
[17:36:40.764]  $ ...future.FUN            :function (x, ...)  
[17:36:40.764]  $ future.call.arguments    :List of 1
[17:36:40.764]   ..$ singular.ok: logi FALSE
[17:36:40.764]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.764]  $ ...future.elements_ii    :List of 1
[17:36:40.764]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.764]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.764]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.764]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.764]  $ ...future.seeds_ii       : NULL
[17:36:40.764]  $ ...future.globals.maxSize: NULL
[17:36:40.764]  - attr(*, "where")=List of 5
[17:36:40.764]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.764]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.764]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.764]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.764]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.764]  - attr(*, "resolved")= logi FALSE
[17:36:40.764]  - attr(*, "total_size")= num 5384
[17:36:40.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.764]  - attr(*, "already-done")= logi TRUE
[17:36:40.771] - reassign environment for ‘...future.FUN’
[17:36:40.771] - copied ‘...future.FUN’ to environment
[17:36:40.771] - copied ‘future.call.arguments’ to environment
[17:36:40.771] - copied ‘...future.elements_ii’ to environment
[17:36:40.771] - copied ‘...future.seeds_ii’ to environment
[17:36:40.771] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.771] assign_globals() ... done
[17:36:40.771] requestCore(): workers = 2
[17:36:40.774] MulticoreFuture started
[17:36:40.774] - Launch lazy future ... done
[17:36:40.774] run() for ‘MulticoreFuture’ ... done
[17:36:40.774] Created future:
[17:36:40.775] plan(): Setting new future strategy stack:
[17:36:40.775] List of future strategies:
[17:36:40.775] 1. sequential:
[17:36:40.775]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.775]    - tweaked: FALSE
[17:36:40.775]    - call: NULL
[17:36:40.776] plan(): nbrOfWorkers() = 1
[17:36:40.780] plan(): Setting new future strategy stack:
[17:36:40.780] List of future strategies:
[17:36:40.780] 1. multicore:
[17:36:40.780]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:40.780]    - tweaked: FALSE
[17:36:40.780]    - call: plan(strategy)
[17:36:40.786] plan(): nbrOfWorkers() = 2
[17:36:40.775] MulticoreFuture:
[17:36:40.775] Label: ‘future_by-1’
[17:36:40.775] Expression:
[17:36:40.775] {
[17:36:40.775]     do.call(function(...) {
[17:36:40.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.775]             on.exit(options(oopts), add = TRUE)
[17:36:40.775]         }
[17:36:40.775]         {
[17:36:40.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.775]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.775]             })
[17:36:40.775]         }
[17:36:40.775]     }, args = future.call.arguments)
[17:36:40.775] }
[17:36:40.775] Lazy evaluation: FALSE
[17:36:40.775] Asynchronous evaluation: TRUE
[17:36:40.775] Local evaluation: TRUE
[17:36:40.775] Environment: R_GlobalEnv
[17:36:40.775] Capture standard output: TRUE
[17:36:40.775] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.775] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.775] Packages: 1 packages (‘stats’)
[17:36:40.775] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.775] Resolved: TRUE
[17:36:40.775] Value: <not collected>
[17:36:40.775] Conditions captured: <none>
[17:36:40.775] Early signaling: FALSE
[17:36:40.775] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.775] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.787] Chunk #1 of 2 ... DONE
[17:36:40.787] Chunk #2 of 2 ...
[17:36:40.788]  - Finding globals in 'X' for chunk #2 ...
[17:36:40.788] getGlobalsAndPackages() ...
[17:36:40.788] Searching for globals...
[17:36:40.789] 
[17:36:40.789] Searching for globals ... DONE
[17:36:40.789] - globals: [0] <none>
[17:36:40.789] getGlobalsAndPackages() ... DONE
[17:36:40.789]    + additional globals found: [n=0] 
[17:36:40.789]    + additional namespaces needed: [n=0] 
[17:36:40.790]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:40.790]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:40.790]  - seeds: <none>
[17:36:40.790]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.790] getGlobalsAndPackages() ...
[17:36:40.790] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.790] Resolving globals: FALSE
[17:36:40.790] Tweak future expression to call with '...' arguments ...
[17:36:40.791] {
[17:36:40.791]     do.call(function(...) {
[17:36:40.791]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.791]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.791]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.791]             on.exit(options(oopts), add = TRUE)
[17:36:40.791]         }
[17:36:40.791]         {
[17:36:40.791]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.791]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.791]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.791]             })
[17:36:40.791]         }
[17:36:40.791]     }, args = future.call.arguments)
[17:36:40.791] }
[17:36:40.791] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.792] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.792] 
[17:36:40.792] getGlobalsAndPackages() ... DONE
[17:36:40.792] run() for ‘Future’ ...
[17:36:40.793] - state: ‘created’
[17:36:40.793] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.798] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.798] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:40.798]   - Field: ‘label’
[17:36:40.799]   - Field: ‘local’
[17:36:40.799]   - Field: ‘owner’
[17:36:40.799]   - Field: ‘envir’
[17:36:40.799]   - Field: ‘workers’
[17:36:40.799]   - Field: ‘packages’
[17:36:40.802]   - Field: ‘gc’
[17:36:40.803]   - Field: ‘job’
[17:36:40.803]   - Field: ‘conditions’
[17:36:40.804]   - Field: ‘expr’
[17:36:40.804]   - Field: ‘uuid’
[17:36:40.804]   - Field: ‘seed’
[17:36:40.805]   - Field: ‘version’
[17:36:40.805]   - Field: ‘result’
[17:36:40.805]   - Field: ‘asynchronous’
[17:36:40.805]   - Field: ‘calls’
[17:36:40.806]   - Field: ‘globals’
[17:36:40.806]   - Field: ‘stdout’
[17:36:40.806]   - Field: ‘earlySignal’
[17:36:40.806]   - Field: ‘lazy’
[17:36:40.806]   - Field: ‘state’
[17:36:40.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:40.807] - Launch lazy future ...
[17:36:40.808] Packages needed by the future expression (n = 1): ‘stats’
[17:36:40.808] Packages needed by future strategies (n = 0): <none>
[17:36:40.809] {
[17:36:40.809]     {
[17:36:40.809]         {
[17:36:40.809]             ...future.startTime <- base::Sys.time()
[17:36:40.809]             {
[17:36:40.809]                 {
[17:36:40.809]                   {
[17:36:40.809]                     {
[17:36:40.809]                       {
[17:36:40.809]                         base::local({
[17:36:40.809]                           has_future <- base::requireNamespace("future", 
[17:36:40.809]                             quietly = TRUE)
[17:36:40.809]                           if (has_future) {
[17:36:40.809]                             ns <- base::getNamespace("future")
[17:36:40.809]                             version <- ns[[".package"]][["version"]]
[17:36:40.809]                             if (is.null(version)) 
[17:36:40.809]                               version <- utils::packageVersion("future")
[17:36:40.809]                           }
[17:36:40.809]                           else {
[17:36:40.809]                             version <- NULL
[17:36:40.809]                           }
[17:36:40.809]                           if (!has_future || version < "1.8.0") {
[17:36:40.809]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.809]                               "", base::R.version$version.string), 
[17:36:40.809]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:40.809]                                 base::R.version$platform, 8 * 
[17:36:40.809]                                   base::.Machine$sizeof.pointer), 
[17:36:40.809]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.809]                                 "release", "version")], collapse = " "), 
[17:36:40.809]                               hostname = base::Sys.info()[["nodename"]])
[17:36:40.809]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.809]                               info)
[17:36:40.809]                             info <- base::paste(info, collapse = "; ")
[17:36:40.809]                             if (!has_future) {
[17:36:40.809]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.809]                                 info)
[17:36:40.809]                             }
[17:36:40.809]                             else {
[17:36:40.809]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.809]                                 info, version)
[17:36:40.809]                             }
[17:36:40.809]                             base::stop(msg)
[17:36:40.809]                           }
[17:36:40.809]                         })
[17:36:40.809]                       }
[17:36:40.809]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:40.809]                       base::options(mc.cores = 1L)
[17:36:40.809]                     }
[17:36:40.809]                     base::local({
[17:36:40.809]                       for (pkg in "stats") {
[17:36:40.809]                         base::loadNamespace(pkg)
[17:36:40.809]                         base::library(pkg, character.only = TRUE)
[17:36:40.809]                       }
[17:36:40.809]                     })
[17:36:40.809]                   }
[17:36:40.809]                   ...future.strategy.old <- future::plan("list")
[17:36:40.809]                   options(future.plan = NULL)
[17:36:40.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.809]                 }
[17:36:40.809]                 ...future.workdir <- getwd()
[17:36:40.809]             }
[17:36:40.809]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.809]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.809]         }
[17:36:40.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.809]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:40.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.809]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.809]             base::names(...future.oldOptions))
[17:36:40.809]     }
[17:36:40.809]     if (FALSE) {
[17:36:40.809]     }
[17:36:40.809]     else {
[17:36:40.809]         if (TRUE) {
[17:36:40.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.809]                 open = "w")
[17:36:40.809]         }
[17:36:40.809]         else {
[17:36:40.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.809]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.809]         }
[17:36:40.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.809]             base::sink(type = "output", split = FALSE)
[17:36:40.809]             base::close(...future.stdout)
[17:36:40.809]         }, add = TRUE)
[17:36:40.809]     }
[17:36:40.809]     ...future.frame <- base::sys.nframe()
[17:36:40.809]     ...future.conditions <- base::list()
[17:36:40.809]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.809]     if (FALSE) {
[17:36:40.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.809]     }
[17:36:40.809]     ...future.result <- base::tryCatch({
[17:36:40.809]         base::withCallingHandlers({
[17:36:40.809]             ...future.value <- base::withVisible(base::local({
[17:36:40.809]                 withCallingHandlers({
[17:36:40.809]                   {
[17:36:40.809]                     do.call(function(...) {
[17:36:40.809]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.809]                       if (!identical(...future.globals.maxSize.org, 
[17:36:40.809]                         ...future.globals.maxSize)) {
[17:36:40.809]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.809]                         on.exit(options(oopts), add = TRUE)
[17:36:40.809]                       }
[17:36:40.809]                       {
[17:36:40.809]                         lapply(seq_along(...future.elements_ii), 
[17:36:40.809]                           FUN = function(jj) {
[17:36:40.809]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.809]                             ...future.FUN(...future.X_jj, ...)
[17:36:40.809]                           })
[17:36:40.809]                       }
[17:36:40.809]                     }, args = future.call.arguments)
[17:36:40.809]                   }
[17:36:40.809]                 }, immediateCondition = function(cond) {
[17:36:40.809]                   save_rds <- function (object, pathname, ...) 
[17:36:40.809]                   {
[17:36:40.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:40.809]                     if (file_test("-f", pathname_tmp)) {
[17:36:40.809]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:40.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.809]                         fi_tmp[["mtime"]])
[17:36:40.809]                     }
[17:36:40.809]                     tryCatch({
[17:36:40.809]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:40.809]                     }, error = function(ex) {
[17:36:40.809]                       msg <- conditionMessage(ex)
[17:36:40.809]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:40.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.809]                         fi_tmp[["mtime"]], msg)
[17:36:40.809]                       ex$message <- msg
[17:36:40.809]                       stop(ex)
[17:36:40.809]                     })
[17:36:40.809]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:40.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:40.809]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:40.809]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.809]                       fi <- file.info(pathname)
[17:36:40.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:40.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:40.809]                         fi[["size"]], fi[["mtime"]])
[17:36:40.809]                       stop(msg)
[17:36:40.809]                     }
[17:36:40.809]                     invisible(pathname)
[17:36:40.809]                   }
[17:36:40.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:40.809]                     rootPath = tempdir()) 
[17:36:40.809]                   {
[17:36:40.809]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:40.809]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:40.809]                       tmpdir = path, fileext = ".rds")
[17:36:40.809]                     save_rds(obj, file)
[17:36:40.809]                   }
[17:36:40.809]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:40.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.809]                   {
[17:36:40.809]                     inherits <- base::inherits
[17:36:40.809]                     invokeRestart <- base::invokeRestart
[17:36:40.809]                     is.null <- base::is.null
[17:36:40.809]                     muffled <- FALSE
[17:36:40.809]                     if (inherits(cond, "message")) {
[17:36:40.809]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:40.809]                       if (muffled) 
[17:36:40.809]                         invokeRestart("muffleMessage")
[17:36:40.809]                     }
[17:36:40.809]                     else if (inherits(cond, "warning")) {
[17:36:40.809]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:40.809]                       if (muffled) 
[17:36:40.809]                         invokeRestart("muffleWarning")
[17:36:40.809]                     }
[17:36:40.809]                     else if (inherits(cond, "condition")) {
[17:36:40.809]                       if (!is.null(pattern)) {
[17:36:40.809]                         computeRestarts <- base::computeRestarts
[17:36:40.809]                         grepl <- base::grepl
[17:36:40.809]                         restarts <- computeRestarts(cond)
[17:36:40.809]                         for (restart in restarts) {
[17:36:40.809]                           name <- restart$name
[17:36:40.809]                           if (is.null(name)) 
[17:36:40.809]                             next
[17:36:40.809]                           if (!grepl(pattern, name)) 
[17:36:40.809]                             next
[17:36:40.809]                           invokeRestart(restart)
[17:36:40.809]                           muffled <- TRUE
[17:36:40.809]                           break
[17:36:40.809]                         }
[17:36:40.809]                       }
[17:36:40.809]                     }
[17:36:40.809]                     invisible(muffled)
[17:36:40.809]                   }
[17:36:40.809]                   muffleCondition(cond)
[17:36:40.809]                 })
[17:36:40.809]             }))
[17:36:40.809]             future::FutureResult(value = ...future.value$value, 
[17:36:40.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.809]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.809]                     ...future.globalenv.names))
[17:36:40.809]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.809]         }, condition = base::local({
[17:36:40.809]             c <- base::c
[17:36:40.809]             inherits <- base::inherits
[17:36:40.809]             invokeRestart <- base::invokeRestart
[17:36:40.809]             length <- base::length
[17:36:40.809]             list <- base::list
[17:36:40.809]             seq.int <- base::seq.int
[17:36:40.809]             signalCondition <- base::signalCondition
[17:36:40.809]             sys.calls <- base::sys.calls
[17:36:40.809]             `[[` <- base::`[[`
[17:36:40.809]             `+` <- base::`+`
[17:36:40.809]             `<<-` <- base::`<<-`
[17:36:40.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.809]                   3L)]
[17:36:40.809]             }
[17:36:40.809]             function(cond) {
[17:36:40.809]                 is_error <- inherits(cond, "error")
[17:36:40.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.809]                   NULL)
[17:36:40.809]                 if (is_error) {
[17:36:40.809]                   sessionInformation <- function() {
[17:36:40.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.809]                       search = base::search(), system = base::Sys.info())
[17:36:40.809]                   }
[17:36:40.809]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.809]                     cond$call), session = sessionInformation(), 
[17:36:40.809]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.809]                   signalCondition(cond)
[17:36:40.809]                 }
[17:36:40.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.809]                 "immediateCondition"))) {
[17:36:40.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.809]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.809]                   if (TRUE && !signal) {
[17:36:40.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.809]                     {
[17:36:40.809]                       inherits <- base::inherits
[17:36:40.809]                       invokeRestart <- base::invokeRestart
[17:36:40.809]                       is.null <- base::is.null
[17:36:40.809]                       muffled <- FALSE
[17:36:40.809]                       if (inherits(cond, "message")) {
[17:36:40.809]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.809]                         if (muffled) 
[17:36:40.809]                           invokeRestart("muffleMessage")
[17:36:40.809]                       }
[17:36:40.809]                       else if (inherits(cond, "warning")) {
[17:36:40.809]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.809]                         if (muffled) 
[17:36:40.809]                           invokeRestart("muffleWarning")
[17:36:40.809]                       }
[17:36:40.809]                       else if (inherits(cond, "condition")) {
[17:36:40.809]                         if (!is.null(pattern)) {
[17:36:40.809]                           computeRestarts <- base::computeRestarts
[17:36:40.809]                           grepl <- base::grepl
[17:36:40.809]                           restarts <- computeRestarts(cond)
[17:36:40.809]                           for (restart in restarts) {
[17:36:40.809]                             name <- restart$name
[17:36:40.809]                             if (is.null(name)) 
[17:36:40.809]                               next
[17:36:40.809]                             if (!grepl(pattern, name)) 
[17:36:40.809]                               next
[17:36:40.809]                             invokeRestart(restart)
[17:36:40.809]                             muffled <- TRUE
[17:36:40.809]                             break
[17:36:40.809]                           }
[17:36:40.809]                         }
[17:36:40.809]                       }
[17:36:40.809]                       invisible(muffled)
[17:36:40.809]                     }
[17:36:40.809]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.809]                   }
[17:36:40.809]                 }
[17:36:40.809]                 else {
[17:36:40.809]                   if (TRUE) {
[17:36:40.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.809]                     {
[17:36:40.809]                       inherits <- base::inherits
[17:36:40.809]                       invokeRestart <- base::invokeRestart
[17:36:40.809]                       is.null <- base::is.null
[17:36:40.809]                       muffled <- FALSE
[17:36:40.809]                       if (inherits(cond, "message")) {
[17:36:40.809]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.809]                         if (muffled) 
[17:36:40.809]                           invokeRestart("muffleMessage")
[17:36:40.809]                       }
[17:36:40.809]                       else if (inherits(cond, "warning")) {
[17:36:40.809]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.809]                         if (muffled) 
[17:36:40.809]                           invokeRestart("muffleWarning")
[17:36:40.809]                       }
[17:36:40.809]                       else if (inherits(cond, "condition")) {
[17:36:40.809]                         if (!is.null(pattern)) {
[17:36:40.809]                           computeRestarts <- base::computeRestarts
[17:36:40.809]                           grepl <- base::grepl
[17:36:40.809]                           restarts <- computeRestarts(cond)
[17:36:40.809]                           for (restart in restarts) {
[17:36:40.809]                             name <- restart$name
[17:36:40.809]                             if (is.null(name)) 
[17:36:40.809]                               next
[17:36:40.809]                             if (!grepl(pattern, name)) 
[17:36:40.809]                               next
[17:36:40.809]                             invokeRestart(restart)
[17:36:40.809]                             muffled <- TRUE
[17:36:40.809]                             break
[17:36:40.809]                           }
[17:36:40.809]                         }
[17:36:40.809]                       }
[17:36:40.809]                       invisible(muffled)
[17:36:40.809]                     }
[17:36:40.809]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.809]                   }
[17:36:40.809]                 }
[17:36:40.809]             }
[17:36:40.809]         }))
[17:36:40.809]     }, error = function(ex) {
[17:36:40.809]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.809]                 ...future.rng), started = ...future.startTime, 
[17:36:40.809]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.809]             version = "1.8"), class = "FutureResult")
[17:36:40.809]     }, finally = {
[17:36:40.809]         if (!identical(...future.workdir, getwd())) 
[17:36:40.809]             setwd(...future.workdir)
[17:36:40.809]         {
[17:36:40.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.809]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.809]             }
[17:36:40.809]             base::options(...future.oldOptions)
[17:36:40.809]             if (.Platform$OS.type == "windows") {
[17:36:40.809]                 old_names <- names(...future.oldEnvVars)
[17:36:40.809]                 envs <- base::Sys.getenv()
[17:36:40.809]                 names <- names(envs)
[17:36:40.809]                 common <- intersect(names, old_names)
[17:36:40.809]                 added <- setdiff(names, old_names)
[17:36:40.809]                 removed <- setdiff(old_names, names)
[17:36:40.809]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.809]                   envs[common]]
[17:36:40.809]                 NAMES <- toupper(changed)
[17:36:40.809]                 args <- list()
[17:36:40.809]                 for (kk in seq_along(NAMES)) {
[17:36:40.809]                   name <- changed[[kk]]
[17:36:40.809]                   NAME <- NAMES[[kk]]
[17:36:40.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.809]                     next
[17:36:40.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.809]                 }
[17:36:40.809]                 NAMES <- toupper(added)
[17:36:40.809]                 for (kk in seq_along(NAMES)) {
[17:36:40.809]                   name <- added[[kk]]
[17:36:40.809]                   NAME <- NAMES[[kk]]
[17:36:40.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.809]                     next
[17:36:40.809]                   args[[name]] <- ""
[17:36:40.809]                 }
[17:36:40.809]                 NAMES <- toupper(removed)
[17:36:40.809]                 for (kk in seq_along(NAMES)) {
[17:36:40.809]                   name <- removed[[kk]]
[17:36:40.809]                   NAME <- NAMES[[kk]]
[17:36:40.809]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.809]                     next
[17:36:40.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.809]                 }
[17:36:40.809]                 if (length(args) > 0) 
[17:36:40.809]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.809]             }
[17:36:40.809]             else {
[17:36:40.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.809]             }
[17:36:40.809]             {
[17:36:40.809]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.809]                   0L) {
[17:36:40.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.809]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.809]                   base::options(opts)
[17:36:40.809]                 }
[17:36:40.809]                 {
[17:36:40.809]                   {
[17:36:40.809]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:40.809]                     NULL
[17:36:40.809]                   }
[17:36:40.809]                   options(future.plan = NULL)
[17:36:40.809]                   if (is.na(NA_character_)) 
[17:36:40.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.809]                     .init = FALSE)
[17:36:40.809]                 }
[17:36:40.809]             }
[17:36:40.809]         }
[17:36:40.809]     })
[17:36:40.809]     if (TRUE) {
[17:36:40.809]         base::sink(type = "output", split = FALSE)
[17:36:40.809]         if (TRUE) {
[17:36:40.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.809]         }
[17:36:40.809]         else {
[17:36:40.809]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.809]         }
[17:36:40.809]         base::close(...future.stdout)
[17:36:40.809]         ...future.stdout <- NULL
[17:36:40.809]     }
[17:36:40.809]     ...future.result$conditions <- ...future.conditions
[17:36:40.809]     ...future.result$finished <- base::Sys.time()
[17:36:40.809]     ...future.result
[17:36:40.809] }
[17:36:40.812] assign_globals() ...
[17:36:40.812] List of 5
[17:36:40.812]  $ ...future.FUN            :function (x, ...)  
[17:36:40.812]  $ future.call.arguments    :List of 1
[17:36:40.812]   ..$ singular.ok: logi FALSE
[17:36:40.812]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.812]  $ ...future.elements_ii    :List of 2
[17:36:40.812]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.812]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.812]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.812]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:40.812]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.812]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.812]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.812]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:40.812]  $ ...future.seeds_ii       : NULL
[17:36:40.812]  $ ...future.globals.maxSize: NULL
[17:36:40.812]  - attr(*, "where")=List of 5
[17:36:40.812]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.812]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.812]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.812]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.812]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.812]  - attr(*, "resolved")= logi FALSE
[17:36:40.812]  - attr(*, "total_size")= num 5384
[17:36:40.812]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.812]  - attr(*, "already-done")= logi TRUE
[17:36:40.824] - reassign environment for ‘...future.FUN’
[17:36:40.824] - copied ‘...future.FUN’ to environment
[17:36:40.824] - copied ‘future.call.arguments’ to environment
[17:36:40.824] - copied ‘...future.elements_ii’ to environment
[17:36:40.824] - copied ‘...future.seeds_ii’ to environment
[17:36:40.824] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.824] assign_globals() ... done
[17:36:40.824] requestCore(): workers = 2
[17:36:40.827] MulticoreFuture started
[17:36:40.827] - Launch lazy future ... done
[17:36:40.827] run() for ‘MulticoreFuture’ ... done
[17:36:40.828] Created future:
[17:36:40.828] plan(): Setting new future strategy stack:
[17:36:40.828] List of future strategies:
[17:36:40.828] 1. sequential:
[17:36:40.828]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.828]    - tweaked: FALSE
[17:36:40.828]    - call: NULL
[17:36:40.829] plan(): nbrOfWorkers() = 1
[17:36:40.834] plan(): Setting new future strategy stack:
[17:36:40.834] List of future strategies:
[17:36:40.834] 1. multicore:
[17:36:40.834]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:40.834]    - tweaked: FALSE
[17:36:40.834]    - call: plan(strategy)
[17:36:40.840] plan(): nbrOfWorkers() = 2
[17:36:40.828] MulticoreFuture:
[17:36:40.828] Label: ‘future_by-2’
[17:36:40.828] Expression:
[17:36:40.828] {
[17:36:40.828]     do.call(function(...) {
[17:36:40.828]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.828]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.828]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.828]             on.exit(options(oopts), add = TRUE)
[17:36:40.828]         }
[17:36:40.828]         {
[17:36:40.828]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.828]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.828]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.828]             })
[17:36:40.828]         }
[17:36:40.828]     }, args = future.call.arguments)
[17:36:40.828] }
[17:36:40.828] Lazy evaluation: FALSE
[17:36:40.828] Asynchronous evaluation: TRUE
[17:36:40.828] Local evaluation: TRUE
[17:36:40.828] Environment: R_GlobalEnv
[17:36:40.828] Capture standard output: TRUE
[17:36:40.828] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.828] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:40.828] Packages: 1 packages (‘stats’)
[17:36:40.828] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.828] Resolved: FALSE
[17:36:40.828] Value: <not collected>
[17:36:40.828] Conditions captured: <none>
[17:36:40.828] Early signaling: FALSE
[17:36:40.828] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.828] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.841] Chunk #2 of 2 ... DONE
[17:36:40.841] Launching 2 futures (chunks) ... DONE
[17:36:40.841] Resolving 2 futures (chunks) ...
[17:36:40.841] resolve() on list ...
[17:36:40.842]  recursive: 0
[17:36:40.842]  length: 2
[17:36:40.842] 
[17:36:40.842] Future #1
[17:36:40.842] result() for MulticoreFuture ...
[17:36:40.844] result() for MulticoreFuture ...
[17:36:40.844] result() for MulticoreFuture ... done
[17:36:40.844] result() for MulticoreFuture ... done
[17:36:40.844] result() for MulticoreFuture ...
[17:36:40.844] result() for MulticoreFuture ... done
[17:36:40.845] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:40.845] - nx: 2
[17:36:40.845] - relay: TRUE
[17:36:40.845] - stdout: TRUE
[17:36:40.845] - signal: TRUE
[17:36:40.845] - resignal: FALSE
[17:36:40.845] - force: TRUE
[17:36:40.845] - relayed: [n=2] FALSE, FALSE
[17:36:40.845] - queued futures: [n=2] FALSE, FALSE
[17:36:40.846]  - until=1
[17:36:40.846]  - relaying element #1
[17:36:40.846] result() for MulticoreFuture ...
[17:36:40.846] result() for MulticoreFuture ... done
[17:36:40.846] result() for MulticoreFuture ...
[17:36:40.846] result() for MulticoreFuture ... done
[17:36:40.846] result() for MulticoreFuture ...
[17:36:40.847] result() for MulticoreFuture ... done
[17:36:40.847] result() for MulticoreFuture ...
[17:36:40.847] result() for MulticoreFuture ... done
[17:36:40.847] - relayed: [n=2] TRUE, FALSE
[17:36:40.847] - queued futures: [n=2] TRUE, FALSE
[17:36:40.851] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:40.851]  length: 1 (resolved future 1)
[17:36:40.852] Future #2
[17:36:40.852] result() for MulticoreFuture ...
[17:36:40.855] result() for MulticoreFuture ...
[17:36:40.855] result() for MulticoreFuture ... done
[17:36:40.855] result() for MulticoreFuture ... done
[17:36:40.855] result() for MulticoreFuture ...
[17:36:40.856] result() for MulticoreFuture ... done
[17:36:40.856] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:40.856] - nx: 2
[17:36:40.856] - relay: TRUE
[17:36:40.857] - stdout: TRUE
[17:36:40.857] - signal: TRUE
[17:36:40.857] - resignal: FALSE
[17:36:40.857] - force: TRUE
[17:36:40.857] - relayed: [n=2] TRUE, FALSE
[17:36:40.857] - queued futures: [n=2] TRUE, FALSE
[17:36:40.857]  - until=2
[17:36:40.858]  - relaying element #2
[17:36:40.858] result() for MulticoreFuture ...
[17:36:40.858] result() for MulticoreFuture ... done
[17:36:40.858] result() for MulticoreFuture ...
[17:36:40.858] result() for MulticoreFuture ... done
[17:36:40.858] result() for MulticoreFuture ...
[17:36:40.858] result() for MulticoreFuture ... done
[17:36:40.859] result() for MulticoreFuture ...
[17:36:40.859] result() for MulticoreFuture ... done
[17:36:40.859] - relayed: [n=2] TRUE, TRUE
[17:36:40.859] - queued futures: [n=2] TRUE, TRUE
[17:36:40.859] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:40.859]  length: 0 (resolved future 2)
[17:36:40.859] Relaying remaining futures
[17:36:40.859] signalConditionsASAP(NULL, pos=0) ...
[17:36:40.859] - nx: 2
[17:36:40.860] - relay: TRUE
[17:36:40.860] - stdout: TRUE
[17:36:40.860] - signal: TRUE
[17:36:40.860] - resignal: FALSE
[17:36:40.860] - force: TRUE
[17:36:40.860] - relayed: [n=2] TRUE, TRUE
[17:36:40.860] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:40.860] - relayed: [n=2] TRUE, TRUE
[17:36:40.861] - queued futures: [n=2] TRUE, TRUE
[17:36:40.861] signalConditionsASAP(NULL, pos=0) ... done
[17:36:40.861] resolve() on list ... DONE
[17:36:40.861] result() for MulticoreFuture ...
[17:36:40.861] result() for MulticoreFuture ... done
[17:36:40.861] result() for MulticoreFuture ...
[17:36:40.861] result() for MulticoreFuture ... done
[17:36:40.861] result() for MulticoreFuture ...
[17:36:40.861] result() for MulticoreFuture ... done
[17:36:40.862] result() for MulticoreFuture ...
[17:36:40.862] result() for MulticoreFuture ... done
[17:36:40.862]  - Number of value chunks collected: 2
[17:36:40.862] Resolving 2 futures (chunks) ... DONE
[17:36:40.862] Reducing values from 2 chunks ...
[17:36:40.862]  - Number of values collected after concatenation: 3
[17:36:40.862]  - Number of values expected: 3
[17:36:40.862] Reducing values from 2 chunks ... DONE
[17:36:40.863] future_lapply() ... DONE
[17:36:40.863] future_by_internal() ... DONE
[17:36:40.867] future_by_internal() ...
[17:36:40.868] future_lapply() ...
[17:36:40.873] Number of chunks: 2
[17:36:40.873] getGlobalsAndPackagesXApply() ...
[17:36:40.873]  - future.globals: TRUE
[17:36:40.873] getGlobalsAndPackages() ...
[17:36:40.873] Searching for globals...
[17:36:40.879] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:40.880] Searching for globals ... DONE
[17:36:40.880] Resolving globals: FALSE
[17:36:40.880] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:36:40.881] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:36:40.881] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:40.881] - packages: [1] ‘stats’
[17:36:40.881] getGlobalsAndPackages() ... DONE
[17:36:40.881]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:40.881]  - needed namespaces: [n=1] ‘stats’
[17:36:40.881] Finding globals ... DONE
[17:36:40.882]  - use_args: TRUE
[17:36:40.882]  - Getting '...' globals ...
[17:36:40.882] resolve() on list ...
[17:36:40.882]  recursive: 0
[17:36:40.882]  length: 1
[17:36:40.882]  elements: ‘...’
[17:36:40.882]  length: 0 (resolved future 1)
[17:36:40.883] resolve() on list ... DONE
[17:36:40.883]    - '...' content: [n=0] 
[17:36:40.883] List of 1
[17:36:40.883]  $ ...: list()
[17:36:40.883]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.883]  - attr(*, "where")=List of 1
[17:36:40.883]   ..$ ...:<environment: 0x5622fc104a28> 
[17:36:40.883]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.883]  - attr(*, "resolved")= logi TRUE
[17:36:40.883]  - attr(*, "total_size")= num NA
[17:36:40.886]  - Getting '...' globals ... DONE
[17:36:40.886] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:36:40.886] List of 4
[17:36:40.886]  $ ...future.FUN:function (x)  
[17:36:40.886]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:40.886]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.886]  $ ...          : list()
[17:36:40.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.886]  - attr(*, "where")=List of 4
[17:36:40.886]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:40.886]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:36:40.886]   ..$ wool         :<environment: R_EmptyEnv> 
[17:36:40.886]   ..$ ...          :<environment: 0x5622fc104a28> 
[17:36:40.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.886]  - attr(*, "resolved")= logi FALSE
[17:36:40.886]  - attr(*, "total_size")= num 2320
[17:36:40.890] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:40.890] getGlobalsAndPackagesXApply() ... DONE
[17:36:40.890] Number of futures (= number of chunks): 2
[17:36:40.890] Launching 2 futures (chunks) ...
[17:36:40.890] Chunk #1 of 2 ...
[17:36:40.891]  - Finding globals in 'X' for chunk #1 ...
[17:36:40.891] getGlobalsAndPackages() ...
[17:36:40.891] Searching for globals...
[17:36:40.891] 
[17:36:40.891] Searching for globals ... DONE
[17:36:40.891] - globals: [0] <none>
[17:36:40.891] getGlobalsAndPackages() ... DONE
[17:36:40.891]    + additional globals found: [n=0] 
[17:36:40.892]    + additional namespaces needed: [n=0] 
[17:36:40.892]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:40.892]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:40.892]  - seeds: <none>
[17:36:40.892]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.892] getGlobalsAndPackages() ...
[17:36:40.892] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.892] Resolving globals: FALSE
[17:36:40.892] Tweak future expression to call with '...' arguments ...
[17:36:40.893] {
[17:36:40.893]     do.call(function(...) {
[17:36:40.893]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.893]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.893]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.893]             on.exit(options(oopts), add = TRUE)
[17:36:40.893]         }
[17:36:40.893]         {
[17:36:40.893]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.893]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.893]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.893]             })
[17:36:40.893]         }
[17:36:40.893]     }, args = future.call.arguments)
[17:36:40.893] }
[17:36:40.893] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.893] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.893] 
[17:36:40.893] getGlobalsAndPackages() ... DONE
[17:36:40.894] run() for ‘Future’ ...
[17:36:40.894] - state: ‘created’
[17:36:40.894] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.898] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:40.898]   - Field: ‘label’
[17:36:40.898]   - Field: ‘local’
[17:36:40.898]   - Field: ‘owner’
[17:36:40.898]   - Field: ‘envir’
[17:36:40.898]   - Field: ‘workers’
[17:36:40.898]   - Field: ‘packages’
[17:36:40.899]   - Field: ‘gc’
[17:36:40.899]   - Field: ‘job’
[17:36:40.899]   - Field: ‘conditions’
[17:36:40.899]   - Field: ‘expr’
[17:36:40.899]   - Field: ‘uuid’
[17:36:40.899]   - Field: ‘seed’
[17:36:40.899]   - Field: ‘version’
[17:36:40.899]   - Field: ‘result’
[17:36:40.899]   - Field: ‘asynchronous’
[17:36:40.899]   - Field: ‘calls’
[17:36:40.899]   - Field: ‘globals’
[17:36:40.900]   - Field: ‘stdout’
[17:36:40.900]   - Field: ‘earlySignal’
[17:36:40.900]   - Field: ‘lazy’
[17:36:40.900]   - Field: ‘state’
[17:36:40.900] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:40.900] - Launch lazy future ...
[17:36:40.900] Packages needed by the future expression (n = 1): ‘stats’
[17:36:40.900] Packages needed by future strategies (n = 0): <none>
[17:36:40.901] {
[17:36:40.901]     {
[17:36:40.901]         {
[17:36:40.901]             ...future.startTime <- base::Sys.time()
[17:36:40.901]             {
[17:36:40.901]                 {
[17:36:40.901]                   {
[17:36:40.901]                     {
[17:36:40.901]                       {
[17:36:40.901]                         base::local({
[17:36:40.901]                           has_future <- base::requireNamespace("future", 
[17:36:40.901]                             quietly = TRUE)
[17:36:40.901]                           if (has_future) {
[17:36:40.901]                             ns <- base::getNamespace("future")
[17:36:40.901]                             version <- ns[[".package"]][["version"]]
[17:36:40.901]                             if (is.null(version)) 
[17:36:40.901]                               version <- utils::packageVersion("future")
[17:36:40.901]                           }
[17:36:40.901]                           else {
[17:36:40.901]                             version <- NULL
[17:36:40.901]                           }
[17:36:40.901]                           if (!has_future || version < "1.8.0") {
[17:36:40.901]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.901]                               "", base::R.version$version.string), 
[17:36:40.901]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:40.901]                                 base::R.version$platform, 8 * 
[17:36:40.901]                                   base::.Machine$sizeof.pointer), 
[17:36:40.901]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.901]                                 "release", "version")], collapse = " "), 
[17:36:40.901]                               hostname = base::Sys.info()[["nodename"]])
[17:36:40.901]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.901]                               info)
[17:36:40.901]                             info <- base::paste(info, collapse = "; ")
[17:36:40.901]                             if (!has_future) {
[17:36:40.901]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.901]                                 info)
[17:36:40.901]                             }
[17:36:40.901]                             else {
[17:36:40.901]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.901]                                 info, version)
[17:36:40.901]                             }
[17:36:40.901]                             base::stop(msg)
[17:36:40.901]                           }
[17:36:40.901]                         })
[17:36:40.901]                       }
[17:36:40.901]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:40.901]                       base::options(mc.cores = 1L)
[17:36:40.901]                     }
[17:36:40.901]                     base::local({
[17:36:40.901]                       for (pkg in "stats") {
[17:36:40.901]                         base::loadNamespace(pkg)
[17:36:40.901]                         base::library(pkg, character.only = TRUE)
[17:36:40.901]                       }
[17:36:40.901]                     })
[17:36:40.901]                   }
[17:36:40.901]                   ...future.strategy.old <- future::plan("list")
[17:36:40.901]                   options(future.plan = NULL)
[17:36:40.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.901]                 }
[17:36:40.901]                 ...future.workdir <- getwd()
[17:36:40.901]             }
[17:36:40.901]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.901]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.901]         }
[17:36:40.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.901]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:40.901]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.901]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.901]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.901]             base::names(...future.oldOptions))
[17:36:40.901]     }
[17:36:40.901]     if (FALSE) {
[17:36:40.901]     }
[17:36:40.901]     else {
[17:36:40.901]         if (TRUE) {
[17:36:40.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.901]                 open = "w")
[17:36:40.901]         }
[17:36:40.901]         else {
[17:36:40.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.901]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.901]         }
[17:36:40.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.901]             base::sink(type = "output", split = FALSE)
[17:36:40.901]             base::close(...future.stdout)
[17:36:40.901]         }, add = TRUE)
[17:36:40.901]     }
[17:36:40.901]     ...future.frame <- base::sys.nframe()
[17:36:40.901]     ...future.conditions <- base::list()
[17:36:40.901]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.901]     if (FALSE) {
[17:36:40.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.901]     }
[17:36:40.901]     ...future.result <- base::tryCatch({
[17:36:40.901]         base::withCallingHandlers({
[17:36:40.901]             ...future.value <- base::withVisible(base::local({
[17:36:40.901]                 withCallingHandlers({
[17:36:40.901]                   {
[17:36:40.901]                     do.call(function(...) {
[17:36:40.901]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.901]                       if (!identical(...future.globals.maxSize.org, 
[17:36:40.901]                         ...future.globals.maxSize)) {
[17:36:40.901]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.901]                         on.exit(options(oopts), add = TRUE)
[17:36:40.901]                       }
[17:36:40.901]                       {
[17:36:40.901]                         lapply(seq_along(...future.elements_ii), 
[17:36:40.901]                           FUN = function(jj) {
[17:36:40.901]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.901]                             ...future.FUN(...future.X_jj, ...)
[17:36:40.901]                           })
[17:36:40.901]                       }
[17:36:40.901]                     }, args = future.call.arguments)
[17:36:40.901]                   }
[17:36:40.901]                 }, immediateCondition = function(cond) {
[17:36:40.901]                   save_rds <- function (object, pathname, ...) 
[17:36:40.901]                   {
[17:36:40.901]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:40.901]                     if (file_test("-f", pathname_tmp)) {
[17:36:40.901]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.901]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:40.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.901]                         fi_tmp[["mtime"]])
[17:36:40.901]                     }
[17:36:40.901]                     tryCatch({
[17:36:40.901]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:40.901]                     }, error = function(ex) {
[17:36:40.901]                       msg <- conditionMessage(ex)
[17:36:40.901]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.901]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:40.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.901]                         fi_tmp[["mtime"]], msg)
[17:36:40.901]                       ex$message <- msg
[17:36:40.901]                       stop(ex)
[17:36:40.901]                     })
[17:36:40.901]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:40.901]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:40.901]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:40.901]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.901]                       fi <- file.info(pathname)
[17:36:40.901]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:40.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.901]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:40.901]                         fi[["size"]], fi[["mtime"]])
[17:36:40.901]                       stop(msg)
[17:36:40.901]                     }
[17:36:40.901]                     invisible(pathname)
[17:36:40.901]                   }
[17:36:40.901]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:40.901]                     rootPath = tempdir()) 
[17:36:40.901]                   {
[17:36:40.901]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:40.901]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:40.901]                       tmpdir = path, fileext = ".rds")
[17:36:40.901]                     save_rds(obj, file)
[17:36:40.901]                   }
[17:36:40.901]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:40.901]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.901]                   {
[17:36:40.901]                     inherits <- base::inherits
[17:36:40.901]                     invokeRestart <- base::invokeRestart
[17:36:40.901]                     is.null <- base::is.null
[17:36:40.901]                     muffled <- FALSE
[17:36:40.901]                     if (inherits(cond, "message")) {
[17:36:40.901]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:40.901]                       if (muffled) 
[17:36:40.901]                         invokeRestart("muffleMessage")
[17:36:40.901]                     }
[17:36:40.901]                     else if (inherits(cond, "warning")) {
[17:36:40.901]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:40.901]                       if (muffled) 
[17:36:40.901]                         invokeRestart("muffleWarning")
[17:36:40.901]                     }
[17:36:40.901]                     else if (inherits(cond, "condition")) {
[17:36:40.901]                       if (!is.null(pattern)) {
[17:36:40.901]                         computeRestarts <- base::computeRestarts
[17:36:40.901]                         grepl <- base::grepl
[17:36:40.901]                         restarts <- computeRestarts(cond)
[17:36:40.901]                         for (restart in restarts) {
[17:36:40.901]                           name <- restart$name
[17:36:40.901]                           if (is.null(name)) 
[17:36:40.901]                             next
[17:36:40.901]                           if (!grepl(pattern, name)) 
[17:36:40.901]                             next
[17:36:40.901]                           invokeRestart(restart)
[17:36:40.901]                           muffled <- TRUE
[17:36:40.901]                           break
[17:36:40.901]                         }
[17:36:40.901]                       }
[17:36:40.901]                     }
[17:36:40.901]                     invisible(muffled)
[17:36:40.901]                   }
[17:36:40.901]                   muffleCondition(cond)
[17:36:40.901]                 })
[17:36:40.901]             }))
[17:36:40.901]             future::FutureResult(value = ...future.value$value, 
[17:36:40.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.901]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.901]                     ...future.globalenv.names))
[17:36:40.901]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.901]         }, condition = base::local({
[17:36:40.901]             c <- base::c
[17:36:40.901]             inherits <- base::inherits
[17:36:40.901]             invokeRestart <- base::invokeRestart
[17:36:40.901]             length <- base::length
[17:36:40.901]             list <- base::list
[17:36:40.901]             seq.int <- base::seq.int
[17:36:40.901]             signalCondition <- base::signalCondition
[17:36:40.901]             sys.calls <- base::sys.calls
[17:36:40.901]             `[[` <- base::`[[`
[17:36:40.901]             `+` <- base::`+`
[17:36:40.901]             `<<-` <- base::`<<-`
[17:36:40.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.901]                   3L)]
[17:36:40.901]             }
[17:36:40.901]             function(cond) {
[17:36:40.901]                 is_error <- inherits(cond, "error")
[17:36:40.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.901]                   NULL)
[17:36:40.901]                 if (is_error) {
[17:36:40.901]                   sessionInformation <- function() {
[17:36:40.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.901]                       search = base::search(), system = base::Sys.info())
[17:36:40.901]                   }
[17:36:40.901]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.901]                     cond$call), session = sessionInformation(), 
[17:36:40.901]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.901]                   signalCondition(cond)
[17:36:40.901]                 }
[17:36:40.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.901]                 "immediateCondition"))) {
[17:36:40.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.901]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.901]                   if (TRUE && !signal) {
[17:36:40.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.901]                     {
[17:36:40.901]                       inherits <- base::inherits
[17:36:40.901]                       invokeRestart <- base::invokeRestart
[17:36:40.901]                       is.null <- base::is.null
[17:36:40.901]                       muffled <- FALSE
[17:36:40.901]                       if (inherits(cond, "message")) {
[17:36:40.901]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.901]                         if (muffled) 
[17:36:40.901]                           invokeRestart("muffleMessage")
[17:36:40.901]                       }
[17:36:40.901]                       else if (inherits(cond, "warning")) {
[17:36:40.901]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.901]                         if (muffled) 
[17:36:40.901]                           invokeRestart("muffleWarning")
[17:36:40.901]                       }
[17:36:40.901]                       else if (inherits(cond, "condition")) {
[17:36:40.901]                         if (!is.null(pattern)) {
[17:36:40.901]                           computeRestarts <- base::computeRestarts
[17:36:40.901]                           grepl <- base::grepl
[17:36:40.901]                           restarts <- computeRestarts(cond)
[17:36:40.901]                           for (restart in restarts) {
[17:36:40.901]                             name <- restart$name
[17:36:40.901]                             if (is.null(name)) 
[17:36:40.901]                               next
[17:36:40.901]                             if (!grepl(pattern, name)) 
[17:36:40.901]                               next
[17:36:40.901]                             invokeRestart(restart)
[17:36:40.901]                             muffled <- TRUE
[17:36:40.901]                             break
[17:36:40.901]                           }
[17:36:40.901]                         }
[17:36:40.901]                       }
[17:36:40.901]                       invisible(muffled)
[17:36:40.901]                     }
[17:36:40.901]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.901]                   }
[17:36:40.901]                 }
[17:36:40.901]                 else {
[17:36:40.901]                   if (TRUE) {
[17:36:40.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.901]                     {
[17:36:40.901]                       inherits <- base::inherits
[17:36:40.901]                       invokeRestart <- base::invokeRestart
[17:36:40.901]                       is.null <- base::is.null
[17:36:40.901]                       muffled <- FALSE
[17:36:40.901]                       if (inherits(cond, "message")) {
[17:36:40.901]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.901]                         if (muffled) 
[17:36:40.901]                           invokeRestart("muffleMessage")
[17:36:40.901]                       }
[17:36:40.901]                       else if (inherits(cond, "warning")) {
[17:36:40.901]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.901]                         if (muffled) 
[17:36:40.901]                           invokeRestart("muffleWarning")
[17:36:40.901]                       }
[17:36:40.901]                       else if (inherits(cond, "condition")) {
[17:36:40.901]                         if (!is.null(pattern)) {
[17:36:40.901]                           computeRestarts <- base::computeRestarts
[17:36:40.901]                           grepl <- base::grepl
[17:36:40.901]                           restarts <- computeRestarts(cond)
[17:36:40.901]                           for (restart in restarts) {
[17:36:40.901]                             name <- restart$name
[17:36:40.901]                             if (is.null(name)) 
[17:36:40.901]                               next
[17:36:40.901]                             if (!grepl(pattern, name)) 
[17:36:40.901]                               next
[17:36:40.901]                             invokeRestart(restart)
[17:36:40.901]                             muffled <- TRUE
[17:36:40.901]                             break
[17:36:40.901]                           }
[17:36:40.901]                         }
[17:36:40.901]                       }
[17:36:40.901]                       invisible(muffled)
[17:36:40.901]                     }
[17:36:40.901]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.901]                   }
[17:36:40.901]                 }
[17:36:40.901]             }
[17:36:40.901]         }))
[17:36:40.901]     }, error = function(ex) {
[17:36:40.901]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.901]                 ...future.rng), started = ...future.startTime, 
[17:36:40.901]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.901]             version = "1.8"), class = "FutureResult")
[17:36:40.901]     }, finally = {
[17:36:40.901]         if (!identical(...future.workdir, getwd())) 
[17:36:40.901]             setwd(...future.workdir)
[17:36:40.901]         {
[17:36:40.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.901]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.901]             }
[17:36:40.901]             base::options(...future.oldOptions)
[17:36:40.901]             if (.Platform$OS.type == "windows") {
[17:36:40.901]                 old_names <- names(...future.oldEnvVars)
[17:36:40.901]                 envs <- base::Sys.getenv()
[17:36:40.901]                 names <- names(envs)
[17:36:40.901]                 common <- intersect(names, old_names)
[17:36:40.901]                 added <- setdiff(names, old_names)
[17:36:40.901]                 removed <- setdiff(old_names, names)
[17:36:40.901]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.901]                   envs[common]]
[17:36:40.901]                 NAMES <- toupper(changed)
[17:36:40.901]                 args <- list()
[17:36:40.901]                 for (kk in seq_along(NAMES)) {
[17:36:40.901]                   name <- changed[[kk]]
[17:36:40.901]                   NAME <- NAMES[[kk]]
[17:36:40.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.901]                     next
[17:36:40.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.901]                 }
[17:36:40.901]                 NAMES <- toupper(added)
[17:36:40.901]                 for (kk in seq_along(NAMES)) {
[17:36:40.901]                   name <- added[[kk]]
[17:36:40.901]                   NAME <- NAMES[[kk]]
[17:36:40.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.901]                     next
[17:36:40.901]                   args[[name]] <- ""
[17:36:40.901]                 }
[17:36:40.901]                 NAMES <- toupper(removed)
[17:36:40.901]                 for (kk in seq_along(NAMES)) {
[17:36:40.901]                   name <- removed[[kk]]
[17:36:40.901]                   NAME <- NAMES[[kk]]
[17:36:40.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.901]                     next
[17:36:40.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.901]                 }
[17:36:40.901]                 if (length(args) > 0) 
[17:36:40.901]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.901]             }
[17:36:40.901]             else {
[17:36:40.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.901]             }
[17:36:40.901]             {
[17:36:40.901]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.901]                   0L) {
[17:36:40.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.901]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.901]                   base::options(opts)
[17:36:40.901]                 }
[17:36:40.901]                 {
[17:36:40.901]                   {
[17:36:40.901]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:40.901]                     NULL
[17:36:40.901]                   }
[17:36:40.901]                   options(future.plan = NULL)
[17:36:40.901]                   if (is.na(NA_character_)) 
[17:36:40.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.901]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.901]                     .init = FALSE)
[17:36:40.901]                 }
[17:36:40.901]             }
[17:36:40.901]         }
[17:36:40.901]     })
[17:36:40.901]     if (TRUE) {
[17:36:40.901]         base::sink(type = "output", split = FALSE)
[17:36:40.901]         if (TRUE) {
[17:36:40.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.901]         }
[17:36:40.901]         else {
[17:36:40.901]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.901]         }
[17:36:40.901]         base::close(...future.stdout)
[17:36:40.901]         ...future.stdout <- NULL
[17:36:40.901]     }
[17:36:40.901]     ...future.result$conditions <- ...future.conditions
[17:36:40.901]     ...future.result$finished <- base::Sys.time()
[17:36:40.901]     ...future.result
[17:36:40.901] }
[17:36:40.905] assign_globals() ...
[17:36:40.905] List of 7
[17:36:40.905]  $ ...future.FUN            :function (x)  
[17:36:40.905]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:40.905]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.905]  $ future.call.arguments    : list()
[17:36:40.905]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.905]  $ ...future.elements_ii    :List of 1
[17:36:40.905]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.905]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:40.905]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.905]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.905]  $ ...future.seeds_ii       : NULL
[17:36:40.905]  $ ...future.globals.maxSize: NULL
[17:36:40.905]  - attr(*, "where")=List of 7
[17:36:40.905]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.905]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:36:40.905]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:36:40.905]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.905]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.905]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.905]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.905]  - attr(*, "resolved")= logi FALSE
[17:36:40.905]  - attr(*, "total_size")= num 2320
[17:36:40.905]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.905]  - attr(*, "already-done")= logi TRUE
[17:36:40.913] - reassign environment for ‘...future.FUN’
[17:36:40.913] - copied ‘...future.FUN’ to environment
[17:36:40.914] - copied ‘breaks’ to environment
[17:36:40.914] - copied ‘wool’ to environment
[17:36:40.914] - copied ‘future.call.arguments’ to environment
[17:36:40.914] - copied ‘...future.elements_ii’ to environment
[17:36:40.914] - copied ‘...future.seeds_ii’ to environment
[17:36:40.914] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.914] assign_globals() ... done
[17:36:40.914] requestCore(): workers = 2
[17:36:40.917] MulticoreFuture started
[17:36:40.917] - Launch lazy future ... done
[17:36:40.917] run() for ‘MulticoreFuture’ ... done
[17:36:40.917] Created future:
[17:36:40.918] plan(): Setting new future strategy stack:
[17:36:40.918] List of future strategies:
[17:36:40.918] 1. sequential:
[17:36:40.918]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.918]    - tweaked: FALSE
[17:36:40.918]    - call: NULL
[17:36:40.919] plan(): nbrOfWorkers() = 1
[17:36:40.923] plan(): Setting new future strategy stack:
[17:36:40.923] List of future strategies:
[17:36:40.923] 1. multicore:
[17:36:40.923]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:40.923]    - tweaked: FALSE
[17:36:40.923]    - call: plan(strategy)
[17:36:40.929] plan(): nbrOfWorkers() = 2
[17:36:40.918] MulticoreFuture:
[17:36:40.918] Label: ‘future_by-1’
[17:36:40.918] Expression:
[17:36:40.918] {
[17:36:40.918]     do.call(function(...) {
[17:36:40.918]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.918]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.918]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.918]             on.exit(options(oopts), add = TRUE)
[17:36:40.918]         }
[17:36:40.918]         {
[17:36:40.918]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.918]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.918]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.918]             })
[17:36:40.918]         }
[17:36:40.918]     }, args = future.call.arguments)
[17:36:40.918] }
[17:36:40.918] Lazy evaluation: FALSE
[17:36:40.918] Asynchronous evaluation: TRUE
[17:36:40.918] Local evaluation: TRUE
[17:36:40.918] Environment: 0x5622fc0b2f50
[17:36:40.918] Capture standard output: TRUE
[17:36:40.918] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.918] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[17:36:40.918] Packages: 1 packages (‘stats’)
[17:36:40.918] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.918] Resolved: TRUE
[17:36:40.918] Value: <not collected>
[17:36:40.918] Conditions captured: <none>
[17:36:40.918] Early signaling: FALSE
[17:36:40.918] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.918] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.930] Chunk #1 of 2 ... DONE
[17:36:40.931] Chunk #2 of 2 ...
[17:36:40.931]  - Finding globals in 'X' for chunk #2 ...
[17:36:40.931] getGlobalsAndPackages() ...
[17:36:40.931] Searching for globals...
[17:36:40.932] 
[17:36:40.932] Searching for globals ... DONE
[17:36:40.932] - globals: [0] <none>
[17:36:40.932] getGlobalsAndPackages() ... DONE
[17:36:40.932]    + additional globals found: [n=0] 
[17:36:40.932]    + additional namespaces needed: [n=0] 
[17:36:40.933]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:40.933]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:40.933]  - seeds: <none>
[17:36:40.933]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.933] getGlobalsAndPackages() ...
[17:36:40.933] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.933] Resolving globals: FALSE
[17:36:40.934] Tweak future expression to call with '...' arguments ...
[17:36:40.934] {
[17:36:40.934]     do.call(function(...) {
[17:36:40.934]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.934]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.934]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.934]             on.exit(options(oopts), add = TRUE)
[17:36:40.934]         }
[17:36:40.934]         {
[17:36:40.934]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.934]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.934]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.934]             })
[17:36:40.934]         }
[17:36:40.934]     }, args = future.call.arguments)
[17:36:40.934] }
[17:36:40.934] Tweak future expression to call with '...' arguments ... DONE
[17:36:40.935] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:40.935] 
[17:36:40.935] getGlobalsAndPackages() ... DONE
[17:36:40.936] run() for ‘Future’ ...
[17:36:40.936] - state: ‘created’
[17:36:40.936] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:40.941] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.941] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:40.941]   - Field: ‘label’
[17:36:40.941]   - Field: ‘local’
[17:36:40.941]   - Field: ‘owner’
[17:36:40.941]   - Field: ‘envir’
[17:36:40.942]   - Field: ‘workers’
[17:36:40.942]   - Field: ‘packages’
[17:36:40.942]   - Field: ‘gc’
[17:36:40.942]   - Field: ‘job’
[17:36:40.942]   - Field: ‘conditions’
[17:36:40.942]   - Field: ‘expr’
[17:36:40.942]   - Field: ‘uuid’
[17:36:40.943]   - Field: ‘seed’
[17:36:40.943]   - Field: ‘version’
[17:36:40.943]   - Field: ‘result’
[17:36:40.943]   - Field: ‘asynchronous’
[17:36:40.943]   - Field: ‘calls’
[17:36:40.943]   - Field: ‘globals’
[17:36:40.943]   - Field: ‘stdout’
[17:36:40.944]   - Field: ‘earlySignal’
[17:36:40.944]   - Field: ‘lazy’
[17:36:40.944]   - Field: ‘state’
[17:36:40.944] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:40.944] - Launch lazy future ...
[17:36:40.945] Packages needed by the future expression (n = 1): ‘stats’
[17:36:40.945] Packages needed by future strategies (n = 0): <none>
[17:36:40.946] {
[17:36:40.946]     {
[17:36:40.946]         {
[17:36:40.946]             ...future.startTime <- base::Sys.time()
[17:36:40.946]             {
[17:36:40.946]                 {
[17:36:40.946]                   {
[17:36:40.946]                     {
[17:36:40.946]                       {
[17:36:40.946]                         base::local({
[17:36:40.946]                           has_future <- base::requireNamespace("future", 
[17:36:40.946]                             quietly = TRUE)
[17:36:40.946]                           if (has_future) {
[17:36:40.946]                             ns <- base::getNamespace("future")
[17:36:40.946]                             version <- ns[[".package"]][["version"]]
[17:36:40.946]                             if (is.null(version)) 
[17:36:40.946]                               version <- utils::packageVersion("future")
[17:36:40.946]                           }
[17:36:40.946]                           else {
[17:36:40.946]                             version <- NULL
[17:36:40.946]                           }
[17:36:40.946]                           if (!has_future || version < "1.8.0") {
[17:36:40.946]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:40.946]                               "", base::R.version$version.string), 
[17:36:40.946]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:40.946]                                 base::R.version$platform, 8 * 
[17:36:40.946]                                   base::.Machine$sizeof.pointer), 
[17:36:40.946]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:40.946]                                 "release", "version")], collapse = " "), 
[17:36:40.946]                               hostname = base::Sys.info()[["nodename"]])
[17:36:40.946]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:40.946]                               info)
[17:36:40.946]                             info <- base::paste(info, collapse = "; ")
[17:36:40.946]                             if (!has_future) {
[17:36:40.946]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:40.946]                                 info)
[17:36:40.946]                             }
[17:36:40.946]                             else {
[17:36:40.946]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:40.946]                                 info, version)
[17:36:40.946]                             }
[17:36:40.946]                             base::stop(msg)
[17:36:40.946]                           }
[17:36:40.946]                         })
[17:36:40.946]                       }
[17:36:40.946]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:40.946]                       base::options(mc.cores = 1L)
[17:36:40.946]                     }
[17:36:40.946]                     base::local({
[17:36:40.946]                       for (pkg in "stats") {
[17:36:40.946]                         base::loadNamespace(pkg)
[17:36:40.946]                         base::library(pkg, character.only = TRUE)
[17:36:40.946]                       }
[17:36:40.946]                     })
[17:36:40.946]                   }
[17:36:40.946]                   ...future.strategy.old <- future::plan("list")
[17:36:40.946]                   options(future.plan = NULL)
[17:36:40.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:40.946]                 }
[17:36:40.946]                 ...future.workdir <- getwd()
[17:36:40.946]             }
[17:36:40.946]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:40.946]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:40.946]         }
[17:36:40.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:40.946]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:40.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:40.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:40.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:40.946]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:40.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:40.946]             base::names(...future.oldOptions))
[17:36:40.946]     }
[17:36:40.946]     if (FALSE) {
[17:36:40.946]     }
[17:36:40.946]     else {
[17:36:40.946]         if (TRUE) {
[17:36:40.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:40.946]                 open = "w")
[17:36:40.946]         }
[17:36:40.946]         else {
[17:36:40.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:40.946]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:40.946]         }
[17:36:40.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:40.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:40.946]             base::sink(type = "output", split = FALSE)
[17:36:40.946]             base::close(...future.stdout)
[17:36:40.946]         }, add = TRUE)
[17:36:40.946]     }
[17:36:40.946]     ...future.frame <- base::sys.nframe()
[17:36:40.946]     ...future.conditions <- base::list()
[17:36:40.946]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:40.946]     if (FALSE) {
[17:36:40.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:40.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:40.946]     }
[17:36:40.946]     ...future.result <- base::tryCatch({
[17:36:40.946]         base::withCallingHandlers({
[17:36:40.946]             ...future.value <- base::withVisible(base::local({
[17:36:40.946]                 withCallingHandlers({
[17:36:40.946]                   {
[17:36:40.946]                     do.call(function(...) {
[17:36:40.946]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.946]                       if (!identical(...future.globals.maxSize.org, 
[17:36:40.946]                         ...future.globals.maxSize)) {
[17:36:40.946]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.946]                         on.exit(options(oopts), add = TRUE)
[17:36:40.946]                       }
[17:36:40.946]                       {
[17:36:40.946]                         lapply(seq_along(...future.elements_ii), 
[17:36:40.946]                           FUN = function(jj) {
[17:36:40.946]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.946]                             ...future.FUN(...future.X_jj, ...)
[17:36:40.946]                           })
[17:36:40.946]                       }
[17:36:40.946]                     }, args = future.call.arguments)
[17:36:40.946]                   }
[17:36:40.946]                 }, immediateCondition = function(cond) {
[17:36:40.946]                   save_rds <- function (object, pathname, ...) 
[17:36:40.946]                   {
[17:36:40.946]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:40.946]                     if (file_test("-f", pathname_tmp)) {
[17:36:40.946]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.946]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:40.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.946]                         fi_tmp[["mtime"]])
[17:36:40.946]                     }
[17:36:40.946]                     tryCatch({
[17:36:40.946]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:40.946]                     }, error = function(ex) {
[17:36:40.946]                       msg <- conditionMessage(ex)
[17:36:40.946]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.946]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:40.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.946]                         fi_tmp[["mtime"]], msg)
[17:36:40.946]                       ex$message <- msg
[17:36:40.946]                       stop(ex)
[17:36:40.946]                     })
[17:36:40.946]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:40.946]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:40.946]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:40.946]                       fi_tmp <- file.info(pathname_tmp)
[17:36:40.946]                       fi <- file.info(pathname)
[17:36:40.946]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:40.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:40.946]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:40.946]                         fi[["size"]], fi[["mtime"]])
[17:36:40.946]                       stop(msg)
[17:36:40.946]                     }
[17:36:40.946]                     invisible(pathname)
[17:36:40.946]                   }
[17:36:40.946]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:40.946]                     rootPath = tempdir()) 
[17:36:40.946]                   {
[17:36:40.946]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:40.946]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:40.946]                       tmpdir = path, fileext = ".rds")
[17:36:40.946]                     save_rds(obj, file)
[17:36:40.946]                   }
[17:36:40.946]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:40.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.946]                   {
[17:36:40.946]                     inherits <- base::inherits
[17:36:40.946]                     invokeRestart <- base::invokeRestart
[17:36:40.946]                     is.null <- base::is.null
[17:36:40.946]                     muffled <- FALSE
[17:36:40.946]                     if (inherits(cond, "message")) {
[17:36:40.946]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:40.946]                       if (muffled) 
[17:36:40.946]                         invokeRestart("muffleMessage")
[17:36:40.946]                     }
[17:36:40.946]                     else if (inherits(cond, "warning")) {
[17:36:40.946]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:40.946]                       if (muffled) 
[17:36:40.946]                         invokeRestart("muffleWarning")
[17:36:40.946]                     }
[17:36:40.946]                     else if (inherits(cond, "condition")) {
[17:36:40.946]                       if (!is.null(pattern)) {
[17:36:40.946]                         computeRestarts <- base::computeRestarts
[17:36:40.946]                         grepl <- base::grepl
[17:36:40.946]                         restarts <- computeRestarts(cond)
[17:36:40.946]                         for (restart in restarts) {
[17:36:40.946]                           name <- restart$name
[17:36:40.946]                           if (is.null(name)) 
[17:36:40.946]                             next
[17:36:40.946]                           if (!grepl(pattern, name)) 
[17:36:40.946]                             next
[17:36:40.946]                           invokeRestart(restart)
[17:36:40.946]                           muffled <- TRUE
[17:36:40.946]                           break
[17:36:40.946]                         }
[17:36:40.946]                       }
[17:36:40.946]                     }
[17:36:40.946]                     invisible(muffled)
[17:36:40.946]                   }
[17:36:40.946]                   muffleCondition(cond)
[17:36:40.946]                 })
[17:36:40.946]             }))
[17:36:40.946]             future::FutureResult(value = ...future.value$value, 
[17:36:40.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.946]                   ...future.rng), globalenv = if (FALSE) 
[17:36:40.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:40.946]                     ...future.globalenv.names))
[17:36:40.946]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:40.946]         }, condition = base::local({
[17:36:40.946]             c <- base::c
[17:36:40.946]             inherits <- base::inherits
[17:36:40.946]             invokeRestart <- base::invokeRestart
[17:36:40.946]             length <- base::length
[17:36:40.946]             list <- base::list
[17:36:40.946]             seq.int <- base::seq.int
[17:36:40.946]             signalCondition <- base::signalCondition
[17:36:40.946]             sys.calls <- base::sys.calls
[17:36:40.946]             `[[` <- base::`[[`
[17:36:40.946]             `+` <- base::`+`
[17:36:40.946]             `<<-` <- base::`<<-`
[17:36:40.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:40.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:40.946]                   3L)]
[17:36:40.946]             }
[17:36:40.946]             function(cond) {
[17:36:40.946]                 is_error <- inherits(cond, "error")
[17:36:40.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:40.946]                   NULL)
[17:36:40.946]                 if (is_error) {
[17:36:40.946]                   sessionInformation <- function() {
[17:36:40.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:40.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:40.946]                       search = base::search(), system = base::Sys.info())
[17:36:40.946]                   }
[17:36:40.946]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:40.946]                     cond$call), session = sessionInformation(), 
[17:36:40.946]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:40.946]                   signalCondition(cond)
[17:36:40.946]                 }
[17:36:40.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:40.946]                 "immediateCondition"))) {
[17:36:40.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:40.946]                   ...future.conditions[[length(...future.conditions) + 
[17:36:40.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:40.946]                   if (TRUE && !signal) {
[17:36:40.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.946]                     {
[17:36:40.946]                       inherits <- base::inherits
[17:36:40.946]                       invokeRestart <- base::invokeRestart
[17:36:40.946]                       is.null <- base::is.null
[17:36:40.946]                       muffled <- FALSE
[17:36:40.946]                       if (inherits(cond, "message")) {
[17:36:40.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.946]                         if (muffled) 
[17:36:40.946]                           invokeRestart("muffleMessage")
[17:36:40.946]                       }
[17:36:40.946]                       else if (inherits(cond, "warning")) {
[17:36:40.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.946]                         if (muffled) 
[17:36:40.946]                           invokeRestart("muffleWarning")
[17:36:40.946]                       }
[17:36:40.946]                       else if (inherits(cond, "condition")) {
[17:36:40.946]                         if (!is.null(pattern)) {
[17:36:40.946]                           computeRestarts <- base::computeRestarts
[17:36:40.946]                           grepl <- base::grepl
[17:36:40.946]                           restarts <- computeRestarts(cond)
[17:36:40.946]                           for (restart in restarts) {
[17:36:40.946]                             name <- restart$name
[17:36:40.946]                             if (is.null(name)) 
[17:36:40.946]                               next
[17:36:40.946]                             if (!grepl(pattern, name)) 
[17:36:40.946]                               next
[17:36:40.946]                             invokeRestart(restart)
[17:36:40.946]                             muffled <- TRUE
[17:36:40.946]                             break
[17:36:40.946]                           }
[17:36:40.946]                         }
[17:36:40.946]                       }
[17:36:40.946]                       invisible(muffled)
[17:36:40.946]                     }
[17:36:40.946]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.946]                   }
[17:36:40.946]                 }
[17:36:40.946]                 else {
[17:36:40.946]                   if (TRUE) {
[17:36:40.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:40.946]                     {
[17:36:40.946]                       inherits <- base::inherits
[17:36:40.946]                       invokeRestart <- base::invokeRestart
[17:36:40.946]                       is.null <- base::is.null
[17:36:40.946]                       muffled <- FALSE
[17:36:40.946]                       if (inherits(cond, "message")) {
[17:36:40.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:40.946]                         if (muffled) 
[17:36:40.946]                           invokeRestart("muffleMessage")
[17:36:40.946]                       }
[17:36:40.946]                       else if (inherits(cond, "warning")) {
[17:36:40.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:40.946]                         if (muffled) 
[17:36:40.946]                           invokeRestart("muffleWarning")
[17:36:40.946]                       }
[17:36:40.946]                       else if (inherits(cond, "condition")) {
[17:36:40.946]                         if (!is.null(pattern)) {
[17:36:40.946]                           computeRestarts <- base::computeRestarts
[17:36:40.946]                           grepl <- base::grepl
[17:36:40.946]                           restarts <- computeRestarts(cond)
[17:36:40.946]                           for (restart in restarts) {
[17:36:40.946]                             name <- restart$name
[17:36:40.946]                             if (is.null(name)) 
[17:36:40.946]                               next
[17:36:40.946]                             if (!grepl(pattern, name)) 
[17:36:40.946]                               next
[17:36:40.946]                             invokeRestart(restart)
[17:36:40.946]                             muffled <- TRUE
[17:36:40.946]                             break
[17:36:40.946]                           }
[17:36:40.946]                         }
[17:36:40.946]                       }
[17:36:40.946]                       invisible(muffled)
[17:36:40.946]                     }
[17:36:40.946]                     muffleCondition(cond, pattern = "^muffle")
[17:36:40.946]                   }
[17:36:40.946]                 }
[17:36:40.946]             }
[17:36:40.946]         }))
[17:36:40.946]     }, error = function(ex) {
[17:36:40.946]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:40.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:40.946]                 ...future.rng), started = ...future.startTime, 
[17:36:40.946]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:40.946]             version = "1.8"), class = "FutureResult")
[17:36:40.946]     }, finally = {
[17:36:40.946]         if (!identical(...future.workdir, getwd())) 
[17:36:40.946]             setwd(...future.workdir)
[17:36:40.946]         {
[17:36:40.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:40.946]                 ...future.oldOptions$nwarnings <- NULL
[17:36:40.946]             }
[17:36:40.946]             base::options(...future.oldOptions)
[17:36:40.946]             if (.Platform$OS.type == "windows") {
[17:36:40.946]                 old_names <- names(...future.oldEnvVars)
[17:36:40.946]                 envs <- base::Sys.getenv()
[17:36:40.946]                 names <- names(envs)
[17:36:40.946]                 common <- intersect(names, old_names)
[17:36:40.946]                 added <- setdiff(names, old_names)
[17:36:40.946]                 removed <- setdiff(old_names, names)
[17:36:40.946]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:40.946]                   envs[common]]
[17:36:40.946]                 NAMES <- toupper(changed)
[17:36:40.946]                 args <- list()
[17:36:40.946]                 for (kk in seq_along(NAMES)) {
[17:36:40.946]                   name <- changed[[kk]]
[17:36:40.946]                   NAME <- NAMES[[kk]]
[17:36:40.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.946]                     next
[17:36:40.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.946]                 }
[17:36:40.946]                 NAMES <- toupper(added)
[17:36:40.946]                 for (kk in seq_along(NAMES)) {
[17:36:40.946]                   name <- added[[kk]]
[17:36:40.946]                   NAME <- NAMES[[kk]]
[17:36:40.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.946]                     next
[17:36:40.946]                   args[[name]] <- ""
[17:36:40.946]                 }
[17:36:40.946]                 NAMES <- toupper(removed)
[17:36:40.946]                 for (kk in seq_along(NAMES)) {
[17:36:40.946]                   name <- removed[[kk]]
[17:36:40.946]                   NAME <- NAMES[[kk]]
[17:36:40.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:40.946]                     next
[17:36:40.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:40.946]                 }
[17:36:40.946]                 if (length(args) > 0) 
[17:36:40.946]                   base::do.call(base::Sys.setenv, args = args)
[17:36:40.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:40.946]             }
[17:36:40.946]             else {
[17:36:40.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:40.946]             }
[17:36:40.946]             {
[17:36:40.946]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:40.946]                   0L) {
[17:36:40.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:40.946]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:40.946]                   base::options(opts)
[17:36:40.946]                 }
[17:36:40.946]                 {
[17:36:40.946]                   {
[17:36:40.946]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:40.946]                     NULL
[17:36:40.946]                   }
[17:36:40.946]                   options(future.plan = NULL)
[17:36:40.946]                   if (is.na(NA_character_)) 
[17:36:40.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:40.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:40.946]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:40.946]                     .init = FALSE)
[17:36:40.946]                 }
[17:36:40.946]             }
[17:36:40.946]         }
[17:36:40.946]     })
[17:36:40.946]     if (TRUE) {
[17:36:40.946]         base::sink(type = "output", split = FALSE)
[17:36:40.946]         if (TRUE) {
[17:36:40.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:40.946]         }
[17:36:40.946]         else {
[17:36:40.946]             ...future.result["stdout"] <- base::list(NULL)
[17:36:40.946]         }
[17:36:40.946]         base::close(...future.stdout)
[17:36:40.946]         ...future.stdout <- NULL
[17:36:40.946]     }
[17:36:40.946]     ...future.result$conditions <- ...future.conditions
[17:36:40.946]     ...future.result$finished <- base::Sys.time()
[17:36:40.946]     ...future.result
[17:36:40.946] }
[17:36:40.951] assign_globals() ...
[17:36:40.951] List of 7
[17:36:40.951]  $ ...future.FUN            :function (x)  
[17:36:40.951]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:40.951]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:40.951]  $ future.call.arguments    : list()
[17:36:40.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:40.951]  $ ...future.elements_ii    :List of 2
[17:36:40.951]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.951]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:40.951]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.951]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:40.951]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:40.951]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:40.951]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:40.951]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:40.951]  $ ...future.seeds_ii       : NULL
[17:36:40.951]  $ ...future.globals.maxSize: NULL
[17:36:40.951]  - attr(*, "where")=List of 7
[17:36:40.951]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:40.951]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:36:40.951]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:36:40.951]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:40.951]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:40.951]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:40.951]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:40.951]  - attr(*, "resolved")= logi FALSE
[17:36:40.951]  - attr(*, "total_size")= num 2320
[17:36:40.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:40.951]  - attr(*, "already-done")= logi TRUE
[17:36:40.966] - reassign environment for ‘...future.FUN’
[17:36:40.967] - copied ‘...future.FUN’ to environment
[17:36:40.967] - copied ‘breaks’ to environment
[17:36:40.967] - copied ‘wool’ to environment
[17:36:40.967] - copied ‘future.call.arguments’ to environment
[17:36:40.967] - copied ‘...future.elements_ii’ to environment
[17:36:40.967] - copied ‘...future.seeds_ii’ to environment
[17:36:40.967] - copied ‘...future.globals.maxSize’ to environment
[17:36:40.967] assign_globals() ... done
[17:36:40.968] requestCore(): workers = 2
[17:36:40.970] MulticoreFuture started
[17:36:40.970] - Launch lazy future ... done
[17:36:40.970] run() for ‘MulticoreFuture’ ... done
[17:36:40.971] Created future:
[17:36:40.971] plan(): Setting new future strategy stack:
[17:36:40.971] List of future strategies:
[17:36:40.971] 1. sequential:
[17:36:40.971]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:40.971]    - tweaked: FALSE
[17:36:40.971]    - call: NULL
[17:36:40.972] plan(): nbrOfWorkers() = 1
[17:36:40.977] plan(): Setting new future strategy stack:
[17:36:40.977] List of future strategies:
[17:36:40.977] 1. multicore:
[17:36:40.977]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:40.977]    - tweaked: FALSE
[17:36:40.977]    - call: plan(strategy)
[17:36:40.983] plan(): nbrOfWorkers() = 2
[17:36:40.971] MulticoreFuture:
[17:36:40.971] Label: ‘future_by-2’
[17:36:40.971] Expression:
[17:36:40.971] {
[17:36:40.971]     do.call(function(...) {
[17:36:40.971]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:40.971]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:40.971]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:40.971]             on.exit(options(oopts), add = TRUE)
[17:36:40.971]         }
[17:36:40.971]         {
[17:36:40.971]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:40.971]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:40.971]                 ...future.FUN(...future.X_jj, ...)
[17:36:40.971]             })
[17:36:40.971]         }
[17:36:40.971]     }, args = future.call.arguments)
[17:36:40.971] }
[17:36:40.971] Lazy evaluation: FALSE
[17:36:40.971] Asynchronous evaluation: TRUE
[17:36:40.971] Local evaluation: TRUE
[17:36:40.971] Environment: 0x5622fc0b2f50
[17:36:40.971] Capture standard output: TRUE
[17:36:40.971] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:40.971] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[17:36:40.971] Packages: 1 packages (‘stats’)
[17:36:40.971] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:40.971] Resolved: FALSE
[17:36:40.971] Value: <not collected>
[17:36:40.971] Conditions captured: <none>
[17:36:40.971] Early signaling: FALSE
[17:36:40.971] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:40.971] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:40.984] Chunk #2 of 2 ... DONE
[17:36:40.984] Launching 2 futures (chunks) ... DONE
[17:36:40.985] Resolving 2 futures (chunks) ...
[17:36:40.985] resolve() on list ...
[17:36:40.985]  recursive: 0
[17:36:40.985]  length: 2
[17:36:40.985] 
[17:36:40.986] Future #1
[17:36:40.986] result() for MulticoreFuture ...
[17:36:40.987] result() for MulticoreFuture ...
[17:36:40.987] result() for MulticoreFuture ... done
[17:36:40.988] result() for MulticoreFuture ... done
[17:36:40.988] result() for MulticoreFuture ...
[17:36:40.988] result() for MulticoreFuture ... done
[17:36:40.988] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:40.988] - nx: 2
[17:36:40.988] - relay: TRUE
[17:36:40.988] - stdout: TRUE
[17:36:40.988] - signal: TRUE
[17:36:40.989] - resignal: FALSE
[17:36:40.989] - force: TRUE
[17:36:40.989] - relayed: [n=2] FALSE, FALSE
[17:36:40.989] - queued futures: [n=2] FALSE, FALSE
[17:36:40.989]  - until=1
[17:36:40.989]  - relaying element #1
[17:36:40.989] result() for MulticoreFuture ...
[17:36:40.989] result() for MulticoreFuture ... done
[17:36:40.990] result() for MulticoreFuture ...
[17:36:40.990] result() for MulticoreFuture ... done
[17:36:40.990] result() for MulticoreFuture ...
[17:36:40.990] result() for MulticoreFuture ... done
[17:36:40.990] result() for MulticoreFuture ...
[17:36:40.990] result() for MulticoreFuture ... done
[17:36:40.991] - relayed: [n=2] TRUE, FALSE
[17:36:40.991] - queued futures: [n=2] TRUE, FALSE
[17:36:40.991] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:40.991]  length: 1 (resolved future 1)
[17:36:40.991] Future #2
[17:36:40.991] result() for MulticoreFuture ...
[17:36:40.993] result() for MulticoreFuture ...
[17:36:40.993] result() for MulticoreFuture ... done
[17:36:40.993] result() for MulticoreFuture ... done
[17:36:40.993] result() for MulticoreFuture ...
[17:36:40.993] result() for MulticoreFuture ... done
[17:36:40.994] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:40.994] - nx: 2
[17:36:40.994] - relay: TRUE
[17:36:40.994] - stdout: TRUE
[17:36:40.994] - signal: TRUE
[17:36:40.994] - resignal: FALSE
[17:36:40.994] - force: TRUE
[17:36:40.994] - relayed: [n=2] TRUE, FALSE
[17:36:40.995] - queued futures: [n=2] TRUE, FALSE
[17:36:40.995]  - until=2
[17:36:40.995]  - relaying element #2
[17:36:40.995] result() for MulticoreFuture ...
[17:36:40.997] result() for MulticoreFuture ... done
[17:36:40.997] result() for MulticoreFuture ...
[17:36:40.998] result() for MulticoreFuture ... done
[17:36:40.998] result() for MulticoreFuture ...
[17:36:40.998] result() for MulticoreFuture ... done
[17:36:40.998] result() for MulticoreFuture ...
[17:36:40.998] result() for MulticoreFuture ... done
[17:36:40.999] - relayed: [n=2] TRUE, TRUE
[17:36:40.999] - queued futures: [n=2] TRUE, TRUE
[17:36:40.999] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:40.999]  length: 0 (resolved future 2)
[17:36:40.999] Relaying remaining futures
[17:36:40.999] signalConditionsASAP(NULL, pos=0) ...
[17:36:41.000] - nx: 2
[17:36:41.000] - relay: TRUE
[17:36:41.000] - stdout: TRUE
[17:36:41.000] - signal: TRUE
[17:36:41.000] - resignal: FALSE
[17:36:41.000] - force: TRUE
[17:36:41.000] - relayed: [n=2] TRUE, TRUE
[17:36:41.001] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:41.001] - relayed: [n=2] TRUE, TRUE
[17:36:41.001] - queued futures: [n=2] TRUE, TRUE
[17:36:41.001] signalConditionsASAP(NULL, pos=0) ... done
[17:36:41.001] resolve() on list ... DONE
[17:36:41.001] result() for MulticoreFuture ...
[17:36:41.002] result() for MulticoreFuture ... done
[17:36:41.002] result() for MulticoreFuture ...
[17:36:41.002] result() for MulticoreFuture ... done
[17:36:41.002] result() for MulticoreFuture ...
[17:36:41.002] result() for MulticoreFuture ... done
[17:36:41.002] result() for MulticoreFuture ...
[17:36:41.002] result() for MulticoreFuture ... done
[17:36:41.003]  - Number of value chunks collected: 2
[17:36:41.003] Resolving 2 futures (chunks) ... DONE
[17:36:41.003] Reducing values from 2 chunks ...
[17:36:41.003]  - Number of values collected after concatenation: 3
[17:36:41.003]  - Number of values expected: 3
[17:36:41.003] Reducing values from 2 chunks ... DONE
[17:36:41.004] future_lapply() ... DONE
[17:36:41.004] future_by_internal() ... DONE
[17:36:41.004] future_by_internal() ...
[17:36:41.005] future_lapply() ...
[17:36:41.010] Number of chunks: 2
[17:36:41.010] getGlobalsAndPackagesXApply() ...
[17:36:41.010]  - future.globals: TRUE
[17:36:41.010] getGlobalsAndPackages() ...
[17:36:41.010] Searching for globals...
[17:36:41.011] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:41.012] Searching for globals ... DONE
[17:36:41.012] Resolving globals: FALSE
[17:36:41.012] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:41.013] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:41.013] - globals: [1] ‘FUN’
[17:36:41.013] 
[17:36:41.013] getGlobalsAndPackages() ... DONE
[17:36:41.013]  - globals found/used: [n=1] ‘FUN’
[17:36:41.013]  - needed namespaces: [n=0] 
[17:36:41.013] Finding globals ... DONE
[17:36:41.013]  - use_args: TRUE
[17:36:41.013]  - Getting '...' globals ...
[17:36:41.014] resolve() on list ...
[17:36:41.014]  recursive: 0
[17:36:41.014]  length: 1
[17:36:41.014]  elements: ‘...’
[17:36:41.014]  length: 0 (resolved future 1)
[17:36:41.014] resolve() on list ... DONE
[17:36:41.014]    - '...' content: [n=0] 
[17:36:41.015] List of 1
[17:36:41.015]  $ ...: list()
[17:36:41.015]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:41.015]  - attr(*, "where")=List of 1
[17:36:41.015]   ..$ ...:<environment: 0x5622fc13cf28> 
[17:36:41.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:41.015]  - attr(*, "resolved")= logi TRUE
[17:36:41.015]  - attr(*, "total_size")= num NA
[17:36:41.017]  - Getting '...' globals ... DONE
[17:36:41.018] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:41.018] List of 2
[17:36:41.018]  $ ...future.FUN:function (object, ...)  
[17:36:41.018]  $ ...          : list()
[17:36:41.018]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:41.018]  - attr(*, "where")=List of 2
[17:36:41.018]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:41.018]   ..$ ...          :<environment: 0x5622fc13cf28> 
[17:36:41.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:41.018]  - attr(*, "resolved")= logi FALSE
[17:36:41.018]  - attr(*, "total_size")= num 1240
[17:36:41.020] Packages to be attached in all futures: [n=0] 
[17:36:41.020] getGlobalsAndPackagesXApply() ... DONE
[17:36:41.021] Number of futures (= number of chunks): 2
[17:36:41.021] Launching 2 futures (chunks) ...
[17:36:41.021] Chunk #1 of 2 ...
[17:36:41.021]  - Finding globals in 'X' for chunk #1 ...
[17:36:41.021] getGlobalsAndPackages() ...
[17:36:41.021] Searching for globals...
[17:36:41.022] 
[17:36:41.022] Searching for globals ... DONE
[17:36:41.022] - globals: [0] <none>
[17:36:41.022] getGlobalsAndPackages() ... DONE
[17:36:41.022]    + additional globals found: [n=0] 
[17:36:41.022]    + additional namespaces needed: [n=0] 
[17:36:41.024]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:41.024]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:41.024]  - seeds: <none>
[17:36:41.025]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.025] getGlobalsAndPackages() ...
[17:36:41.025] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.025] Resolving globals: FALSE
[17:36:41.025] Tweak future expression to call with '...' arguments ...
[17:36:41.025] {
[17:36:41.025]     do.call(function(...) {
[17:36:41.025]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.025]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:41.025]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.025]             on.exit(options(oopts), add = TRUE)
[17:36:41.025]         }
[17:36:41.025]         {
[17:36:41.025]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:41.025]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.025]                 ...future.FUN(...future.X_jj, ...)
[17:36:41.025]             })
[17:36:41.025]         }
[17:36:41.025]     }, args = future.call.arguments)
[17:36:41.025] }
[17:36:41.026] Tweak future expression to call with '...' arguments ... DONE
[17:36:41.026] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.026] 
[17:36:41.026] getGlobalsAndPackages() ... DONE
[17:36:41.026] run() for ‘Future’ ...
[17:36:41.027] - state: ‘created’
[17:36:41.027] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:41.031] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:41.031] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:41.032]   - Field: ‘label’
[17:36:41.032]   - Field: ‘local’
[17:36:41.032]   - Field: ‘owner’
[17:36:41.032]   - Field: ‘envir’
[17:36:41.032]   - Field: ‘workers’
[17:36:41.032]   - Field: ‘packages’
[17:36:41.032]   - Field: ‘gc’
[17:36:41.033]   - Field: ‘job’
[17:36:41.033]   - Field: ‘conditions’
[17:36:41.033]   - Field: ‘expr’
[17:36:41.033]   - Field: ‘uuid’
[17:36:41.033]   - Field: ‘seed’
[17:36:41.033]   - Field: ‘version’
[17:36:41.033]   - Field: ‘result’
[17:36:41.033]   - Field: ‘asynchronous’
[17:36:41.033]   - Field: ‘calls’
[17:36:41.034]   - Field: ‘globals’
[17:36:41.034]   - Field: ‘stdout’
[17:36:41.034]   - Field: ‘earlySignal’
[17:36:41.034]   - Field: ‘lazy’
[17:36:41.034]   - Field: ‘state’
[17:36:41.034] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:41.034] - Launch lazy future ...
[17:36:41.034] Packages needed by the future expression (n = 0): <none>
[17:36:41.035] Packages needed by future strategies (n = 0): <none>
[17:36:41.035] {
[17:36:41.035]     {
[17:36:41.035]         {
[17:36:41.035]             ...future.startTime <- base::Sys.time()
[17:36:41.035]             {
[17:36:41.035]                 {
[17:36:41.035]                   {
[17:36:41.035]                     {
[17:36:41.035]                       base::local({
[17:36:41.035]                         has_future <- base::requireNamespace("future", 
[17:36:41.035]                           quietly = TRUE)
[17:36:41.035]                         if (has_future) {
[17:36:41.035]                           ns <- base::getNamespace("future")
[17:36:41.035]                           version <- ns[[".package"]][["version"]]
[17:36:41.035]                           if (is.null(version)) 
[17:36:41.035]                             version <- utils::packageVersion("future")
[17:36:41.035]                         }
[17:36:41.035]                         else {
[17:36:41.035]                           version <- NULL
[17:36:41.035]                         }
[17:36:41.035]                         if (!has_future || version < "1.8.0") {
[17:36:41.035]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:41.035]                             "", base::R.version$version.string), 
[17:36:41.035]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:41.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:41.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:41.035]                               "release", "version")], collapse = " "), 
[17:36:41.035]                             hostname = base::Sys.info()[["nodename"]])
[17:36:41.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:41.035]                             info)
[17:36:41.035]                           info <- base::paste(info, collapse = "; ")
[17:36:41.035]                           if (!has_future) {
[17:36:41.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:41.035]                               info)
[17:36:41.035]                           }
[17:36:41.035]                           else {
[17:36:41.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:41.035]                               info, version)
[17:36:41.035]                           }
[17:36:41.035]                           base::stop(msg)
[17:36:41.035]                         }
[17:36:41.035]                       })
[17:36:41.035]                     }
[17:36:41.035]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:41.035]                     base::options(mc.cores = 1L)
[17:36:41.035]                   }
[17:36:41.035]                   ...future.strategy.old <- future::plan("list")
[17:36:41.035]                   options(future.plan = NULL)
[17:36:41.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:41.035]                 }
[17:36:41.035]                 ...future.workdir <- getwd()
[17:36:41.035]             }
[17:36:41.035]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:41.035]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:41.035]         }
[17:36:41.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:41.035]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:41.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:41.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:41.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:41.035]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:41.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:41.035]             base::names(...future.oldOptions))
[17:36:41.035]     }
[17:36:41.035]     if (FALSE) {
[17:36:41.035]     }
[17:36:41.035]     else {
[17:36:41.035]         if (TRUE) {
[17:36:41.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:41.035]                 open = "w")
[17:36:41.035]         }
[17:36:41.035]         else {
[17:36:41.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:41.035]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:41.035]         }
[17:36:41.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:41.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:41.035]             base::sink(type = "output", split = FALSE)
[17:36:41.035]             base::close(...future.stdout)
[17:36:41.035]         }, add = TRUE)
[17:36:41.035]     }
[17:36:41.035]     ...future.frame <- base::sys.nframe()
[17:36:41.035]     ...future.conditions <- base::list()
[17:36:41.035]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:41.035]     if (FALSE) {
[17:36:41.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:41.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:41.035]     }
[17:36:41.035]     ...future.result <- base::tryCatch({
[17:36:41.035]         base::withCallingHandlers({
[17:36:41.035]             ...future.value <- base::withVisible(base::local({
[17:36:41.035]                 withCallingHandlers({
[17:36:41.035]                   {
[17:36:41.035]                     do.call(function(...) {
[17:36:41.035]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.035]                       if (!identical(...future.globals.maxSize.org, 
[17:36:41.035]                         ...future.globals.maxSize)) {
[17:36:41.035]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.035]                         on.exit(options(oopts), add = TRUE)
[17:36:41.035]                       }
[17:36:41.035]                       {
[17:36:41.035]                         lapply(seq_along(...future.elements_ii), 
[17:36:41.035]                           FUN = function(jj) {
[17:36:41.035]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.035]                             ...future.FUN(...future.X_jj, ...)
[17:36:41.035]                           })
[17:36:41.035]                       }
[17:36:41.035]                     }, args = future.call.arguments)
[17:36:41.035]                   }
[17:36:41.035]                 }, immediateCondition = function(cond) {
[17:36:41.035]                   save_rds <- function (object, pathname, ...) 
[17:36:41.035]                   {
[17:36:41.035]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:41.035]                     if (file_test("-f", pathname_tmp)) {
[17:36:41.035]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.035]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:41.035]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.035]                         fi_tmp[["mtime"]])
[17:36:41.035]                     }
[17:36:41.035]                     tryCatch({
[17:36:41.035]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:41.035]                     }, error = function(ex) {
[17:36:41.035]                       msg <- conditionMessage(ex)
[17:36:41.035]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.035]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:41.035]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.035]                         fi_tmp[["mtime"]], msg)
[17:36:41.035]                       ex$message <- msg
[17:36:41.035]                       stop(ex)
[17:36:41.035]                     })
[17:36:41.035]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:41.035]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:41.035]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:41.035]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.035]                       fi <- file.info(pathname)
[17:36:41.035]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:41.035]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.035]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:41.035]                         fi[["size"]], fi[["mtime"]])
[17:36:41.035]                       stop(msg)
[17:36:41.035]                     }
[17:36:41.035]                     invisible(pathname)
[17:36:41.035]                   }
[17:36:41.035]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:41.035]                     rootPath = tempdir()) 
[17:36:41.035]                   {
[17:36:41.035]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:41.035]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:41.035]                       tmpdir = path, fileext = ".rds")
[17:36:41.035]                     save_rds(obj, file)
[17:36:41.035]                   }
[17:36:41.035]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:41.035]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.035]                   {
[17:36:41.035]                     inherits <- base::inherits
[17:36:41.035]                     invokeRestart <- base::invokeRestart
[17:36:41.035]                     is.null <- base::is.null
[17:36:41.035]                     muffled <- FALSE
[17:36:41.035]                     if (inherits(cond, "message")) {
[17:36:41.035]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:41.035]                       if (muffled) 
[17:36:41.035]                         invokeRestart("muffleMessage")
[17:36:41.035]                     }
[17:36:41.035]                     else if (inherits(cond, "warning")) {
[17:36:41.035]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:41.035]                       if (muffled) 
[17:36:41.035]                         invokeRestart("muffleWarning")
[17:36:41.035]                     }
[17:36:41.035]                     else if (inherits(cond, "condition")) {
[17:36:41.035]                       if (!is.null(pattern)) {
[17:36:41.035]                         computeRestarts <- base::computeRestarts
[17:36:41.035]                         grepl <- base::grepl
[17:36:41.035]                         restarts <- computeRestarts(cond)
[17:36:41.035]                         for (restart in restarts) {
[17:36:41.035]                           name <- restart$name
[17:36:41.035]                           if (is.null(name)) 
[17:36:41.035]                             next
[17:36:41.035]                           if (!grepl(pattern, name)) 
[17:36:41.035]                             next
[17:36:41.035]                           invokeRestart(restart)
[17:36:41.035]                           muffled <- TRUE
[17:36:41.035]                           break
[17:36:41.035]                         }
[17:36:41.035]                       }
[17:36:41.035]                     }
[17:36:41.035]                     invisible(muffled)
[17:36:41.035]                   }
[17:36:41.035]                   muffleCondition(cond)
[17:36:41.035]                 })
[17:36:41.035]             }))
[17:36:41.035]             future::FutureResult(value = ...future.value$value, 
[17:36:41.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.035]                   ...future.rng), globalenv = if (FALSE) 
[17:36:41.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:41.035]                     ...future.globalenv.names))
[17:36:41.035]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:41.035]         }, condition = base::local({
[17:36:41.035]             c <- base::c
[17:36:41.035]             inherits <- base::inherits
[17:36:41.035]             invokeRestart <- base::invokeRestart
[17:36:41.035]             length <- base::length
[17:36:41.035]             list <- base::list
[17:36:41.035]             seq.int <- base::seq.int
[17:36:41.035]             signalCondition <- base::signalCondition
[17:36:41.035]             sys.calls <- base::sys.calls
[17:36:41.035]             `[[` <- base::`[[`
[17:36:41.035]             `+` <- base::`+`
[17:36:41.035]             `<<-` <- base::`<<-`
[17:36:41.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:41.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:41.035]                   3L)]
[17:36:41.035]             }
[17:36:41.035]             function(cond) {
[17:36:41.035]                 is_error <- inherits(cond, "error")
[17:36:41.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:41.035]                   NULL)
[17:36:41.035]                 if (is_error) {
[17:36:41.035]                   sessionInformation <- function() {
[17:36:41.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:41.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:41.035]                       search = base::search(), system = base::Sys.info())
[17:36:41.035]                   }
[17:36:41.035]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:41.035]                     cond$call), session = sessionInformation(), 
[17:36:41.035]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:41.035]                   signalCondition(cond)
[17:36:41.035]                 }
[17:36:41.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:41.035]                 "immediateCondition"))) {
[17:36:41.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:41.035]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:41.035]                   if (TRUE && !signal) {
[17:36:41.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.035]                     {
[17:36:41.035]                       inherits <- base::inherits
[17:36:41.035]                       invokeRestart <- base::invokeRestart
[17:36:41.035]                       is.null <- base::is.null
[17:36:41.035]                       muffled <- FALSE
[17:36:41.035]                       if (inherits(cond, "message")) {
[17:36:41.035]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.035]                         if (muffled) 
[17:36:41.035]                           invokeRestart("muffleMessage")
[17:36:41.035]                       }
[17:36:41.035]                       else if (inherits(cond, "warning")) {
[17:36:41.035]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.035]                         if (muffled) 
[17:36:41.035]                           invokeRestart("muffleWarning")
[17:36:41.035]                       }
[17:36:41.035]                       else if (inherits(cond, "condition")) {
[17:36:41.035]                         if (!is.null(pattern)) {
[17:36:41.035]                           computeRestarts <- base::computeRestarts
[17:36:41.035]                           grepl <- base::grepl
[17:36:41.035]                           restarts <- computeRestarts(cond)
[17:36:41.035]                           for (restart in restarts) {
[17:36:41.035]                             name <- restart$name
[17:36:41.035]                             if (is.null(name)) 
[17:36:41.035]                               next
[17:36:41.035]                             if (!grepl(pattern, name)) 
[17:36:41.035]                               next
[17:36:41.035]                             invokeRestart(restart)
[17:36:41.035]                             muffled <- TRUE
[17:36:41.035]                             break
[17:36:41.035]                           }
[17:36:41.035]                         }
[17:36:41.035]                       }
[17:36:41.035]                       invisible(muffled)
[17:36:41.035]                     }
[17:36:41.035]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.035]                   }
[17:36:41.035]                 }
[17:36:41.035]                 else {
[17:36:41.035]                   if (TRUE) {
[17:36:41.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.035]                     {
[17:36:41.035]                       inherits <- base::inherits
[17:36:41.035]                       invokeRestart <- base::invokeRestart
[17:36:41.035]                       is.null <- base::is.null
[17:36:41.035]                       muffled <- FALSE
[17:36:41.035]                       if (inherits(cond, "message")) {
[17:36:41.035]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.035]                         if (muffled) 
[17:36:41.035]                           invokeRestart("muffleMessage")
[17:36:41.035]                       }
[17:36:41.035]                       else if (inherits(cond, "warning")) {
[17:36:41.035]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.035]                         if (muffled) 
[17:36:41.035]                           invokeRestart("muffleWarning")
[17:36:41.035]                       }
[17:36:41.035]                       else if (inherits(cond, "condition")) {
[17:36:41.035]                         if (!is.null(pattern)) {
[17:36:41.035]                           computeRestarts <- base::computeRestarts
[17:36:41.035]                           grepl <- base::grepl
[17:36:41.035]                           restarts <- computeRestarts(cond)
[17:36:41.035]                           for (restart in restarts) {
[17:36:41.035]                             name <- restart$name
[17:36:41.035]                             if (is.null(name)) 
[17:36:41.035]                               next
[17:36:41.035]                             if (!grepl(pattern, name)) 
[17:36:41.035]                               next
[17:36:41.035]                             invokeRestart(restart)
[17:36:41.035]                             muffled <- TRUE
[17:36:41.035]                             break
[17:36:41.035]                           }
[17:36:41.035]                         }
[17:36:41.035]                       }
[17:36:41.035]                       invisible(muffled)
[17:36:41.035]                     }
[17:36:41.035]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.035]                   }
[17:36:41.035]                 }
[17:36:41.035]             }
[17:36:41.035]         }))
[17:36:41.035]     }, error = function(ex) {
[17:36:41.035]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:41.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.035]                 ...future.rng), started = ...future.startTime, 
[17:36:41.035]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:41.035]             version = "1.8"), class = "FutureResult")
[17:36:41.035]     }, finally = {
[17:36:41.035]         if (!identical(...future.workdir, getwd())) 
[17:36:41.035]             setwd(...future.workdir)
[17:36:41.035]         {
[17:36:41.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:41.035]                 ...future.oldOptions$nwarnings <- NULL
[17:36:41.035]             }
[17:36:41.035]             base::options(...future.oldOptions)
[17:36:41.035]             if (.Platform$OS.type == "windows") {
[17:36:41.035]                 old_names <- names(...future.oldEnvVars)
[17:36:41.035]                 envs <- base::Sys.getenv()
[17:36:41.035]                 names <- names(envs)
[17:36:41.035]                 common <- intersect(names, old_names)
[17:36:41.035]                 added <- setdiff(names, old_names)
[17:36:41.035]                 removed <- setdiff(old_names, names)
[17:36:41.035]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:41.035]                   envs[common]]
[17:36:41.035]                 NAMES <- toupper(changed)
[17:36:41.035]                 args <- list()
[17:36:41.035]                 for (kk in seq_along(NAMES)) {
[17:36:41.035]                   name <- changed[[kk]]
[17:36:41.035]                   NAME <- NAMES[[kk]]
[17:36:41.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.035]                     next
[17:36:41.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.035]                 }
[17:36:41.035]                 NAMES <- toupper(added)
[17:36:41.035]                 for (kk in seq_along(NAMES)) {
[17:36:41.035]                   name <- added[[kk]]
[17:36:41.035]                   NAME <- NAMES[[kk]]
[17:36:41.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.035]                     next
[17:36:41.035]                   args[[name]] <- ""
[17:36:41.035]                 }
[17:36:41.035]                 NAMES <- toupper(removed)
[17:36:41.035]                 for (kk in seq_along(NAMES)) {
[17:36:41.035]                   name <- removed[[kk]]
[17:36:41.035]                   NAME <- NAMES[[kk]]
[17:36:41.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.035]                     next
[17:36:41.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.035]                 }
[17:36:41.035]                 if (length(args) > 0) 
[17:36:41.035]                   base::do.call(base::Sys.setenv, args = args)
[17:36:41.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:41.035]             }
[17:36:41.035]             else {
[17:36:41.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:41.035]             }
[17:36:41.035]             {
[17:36:41.035]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:41.035]                   0L) {
[17:36:41.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:41.035]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:41.035]                   base::options(opts)
[17:36:41.035]                 }
[17:36:41.035]                 {
[17:36:41.035]                   {
[17:36:41.035]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:41.035]                     NULL
[17:36:41.035]                   }
[17:36:41.035]                   options(future.plan = NULL)
[17:36:41.035]                   if (is.na(NA_character_)) 
[17:36:41.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:41.035]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:41.035]                     .init = FALSE)
[17:36:41.035]                 }
[17:36:41.035]             }
[17:36:41.035]         }
[17:36:41.035]     })
[17:36:41.035]     if (TRUE) {
[17:36:41.035]         base::sink(type = "output", split = FALSE)
[17:36:41.035]         if (TRUE) {
[17:36:41.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:41.035]         }
[17:36:41.035]         else {
[17:36:41.035]             ...future.result["stdout"] <- base::list(NULL)
[17:36:41.035]         }
[17:36:41.035]         base::close(...future.stdout)
[17:36:41.035]         ...future.stdout <- NULL
[17:36:41.035]     }
[17:36:41.035]     ...future.result$conditions <- ...future.conditions
[17:36:41.035]     ...future.result$finished <- base::Sys.time()
[17:36:41.035]     ...future.result
[17:36:41.035] }
[17:36:41.038] assign_globals() ...
[17:36:41.038] List of 5
[17:36:41.038]  $ ...future.FUN            :function (object, ...)  
[17:36:41.038]  $ future.call.arguments    : list()
[17:36:41.038]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:41.038]  $ ...future.elements_ii    :List of 1
[17:36:41.038]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:41.038]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:41.038]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:41.038]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:41.038]  $ ...future.seeds_ii       : NULL
[17:36:41.038]  $ ...future.globals.maxSize: NULL
[17:36:41.038]  - attr(*, "where")=List of 5
[17:36:41.038]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:41.038]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:41.038]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:41.038]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:41.038]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:41.038]  - attr(*, "resolved")= logi FALSE
[17:36:41.038]  - attr(*, "total_size")= num 1240
[17:36:41.038]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:41.038]  - attr(*, "already-done")= logi TRUE
[17:36:41.043] - copied ‘...future.FUN’ to environment
[17:36:41.044] - copied ‘future.call.arguments’ to environment
[17:36:41.044] - copied ‘...future.elements_ii’ to environment
[17:36:41.044] - copied ‘...future.seeds_ii’ to environment
[17:36:41.044] - copied ‘...future.globals.maxSize’ to environment
[17:36:41.044] assign_globals() ... done
[17:36:41.044] requestCore(): workers = 2
[17:36:41.046] MulticoreFuture started
[17:36:41.047] - Launch lazy future ... done
[17:36:41.047] run() for ‘MulticoreFuture’ ... done
[17:36:41.047] Created future:
[17:36:41.047] plan(): Setting new future strategy stack:
[17:36:41.048] List of future strategies:
[17:36:41.048] 1. sequential:
[17:36:41.048]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:41.048]    - tweaked: FALSE
[17:36:41.048]    - call: NULL
[17:36:41.049] plan(): nbrOfWorkers() = 1
[17:36:41.052] plan(): Setting new future strategy stack:
[17:36:41.052] List of future strategies:
[17:36:41.052] 1. multicore:
[17:36:41.052]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:41.052]    - tweaked: FALSE
[17:36:41.052]    - call: plan(strategy)
[17:36:41.057] plan(): nbrOfWorkers() = 2
[17:36:41.047] MulticoreFuture:
[17:36:41.047] Label: ‘future_by-1’
[17:36:41.047] Expression:
[17:36:41.047] {
[17:36:41.047]     do.call(function(...) {
[17:36:41.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:41.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.047]             on.exit(options(oopts), add = TRUE)
[17:36:41.047]         }
[17:36:41.047]         {
[17:36:41.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:41.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.047]                 ...future.FUN(...future.X_jj, ...)
[17:36:41.047]             })
[17:36:41.047]         }
[17:36:41.047]     }, args = future.call.arguments)
[17:36:41.047] }
[17:36:41.047] Lazy evaluation: FALSE
[17:36:41.047] Asynchronous evaluation: TRUE
[17:36:41.047] Local evaluation: TRUE
[17:36:41.047] Environment: 0x5622fca11398
[17:36:41.047] Capture standard output: TRUE
[17:36:41.047] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:41.047] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:41.047] Packages: <none>
[17:36:41.047] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:41.047] Resolved: TRUE
[17:36:41.047] Value: <not collected>
[17:36:41.047] Conditions captured: <none>
[17:36:41.047] Early signaling: FALSE
[17:36:41.047] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:41.047] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:41.058] Chunk #1 of 2 ... DONE
[17:36:41.059] Chunk #2 of 2 ...
[17:36:41.059]  - Finding globals in 'X' for chunk #2 ...
[17:36:41.059] getGlobalsAndPackages() ...
[17:36:41.059] Searching for globals...
[17:36:41.060] 
[17:36:41.060] Searching for globals ... DONE
[17:36:41.060] - globals: [0] <none>
[17:36:41.060] getGlobalsAndPackages() ... DONE
[17:36:41.060]    + additional globals found: [n=0] 
[17:36:41.061]    + additional namespaces needed: [n=0] 
[17:36:41.061]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:41.061]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:41.061]  - seeds: <none>
[17:36:41.061]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.061] getGlobalsAndPackages() ...
[17:36:41.061] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.062] Resolving globals: FALSE
[17:36:41.062] Tweak future expression to call with '...' arguments ...
[17:36:41.062] {
[17:36:41.062]     do.call(function(...) {
[17:36:41.062]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.062]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:41.062]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.062]             on.exit(options(oopts), add = TRUE)
[17:36:41.062]         }
[17:36:41.062]         {
[17:36:41.062]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:41.062]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.062]                 ...future.FUN(...future.X_jj, ...)
[17:36:41.062]             })
[17:36:41.062]         }
[17:36:41.062]     }, args = future.call.arguments)
[17:36:41.062] }
[17:36:41.066] Tweak future expression to call with '...' arguments ... DONE
[17:36:41.067] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.068] 
[17:36:41.068] getGlobalsAndPackages() ... DONE
[17:36:41.069] run() for ‘Future’ ...
[17:36:41.069] - state: ‘created’
[17:36:41.070] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:41.075] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:41.076] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:41.076]   - Field: ‘label’
[17:36:41.076]   - Field: ‘local’
[17:36:41.077]   - Field: ‘owner’
[17:36:41.077]   - Field: ‘envir’
[17:36:41.077]   - Field: ‘workers’
[17:36:41.077]   - Field: ‘packages’
[17:36:41.077]   - Field: ‘gc’
[17:36:41.078]   - Field: ‘job’
[17:36:41.078]   - Field: ‘conditions’
[17:36:41.078]   - Field: ‘expr’
[17:36:41.078]   - Field: ‘uuid’
[17:36:41.079]   - Field: ‘seed’
[17:36:41.079]   - Field: ‘version’
[17:36:41.079]   - Field: ‘result’
[17:36:41.079]   - Field: ‘asynchronous’
[17:36:41.079]   - Field: ‘calls’
[17:36:41.080]   - Field: ‘globals’
[17:36:41.080]   - Field: ‘stdout’
[17:36:41.080]   - Field: ‘earlySignal’
[17:36:41.080]   - Field: ‘lazy’
[17:36:41.080]   - Field: ‘state’
[17:36:41.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:41.081] - Launch lazy future ...
[17:36:41.081] Packages needed by the future expression (n = 0): <none>
[17:36:41.081] Packages needed by future strategies (n = 0): <none>
[17:36:41.082] {
[17:36:41.082]     {
[17:36:41.082]         {
[17:36:41.082]             ...future.startTime <- base::Sys.time()
[17:36:41.082]             {
[17:36:41.082]                 {
[17:36:41.082]                   {
[17:36:41.082]                     {
[17:36:41.082]                       base::local({
[17:36:41.082]                         has_future <- base::requireNamespace("future", 
[17:36:41.082]                           quietly = TRUE)
[17:36:41.082]                         if (has_future) {
[17:36:41.082]                           ns <- base::getNamespace("future")
[17:36:41.082]                           version <- ns[[".package"]][["version"]]
[17:36:41.082]                           if (is.null(version)) 
[17:36:41.082]                             version <- utils::packageVersion("future")
[17:36:41.082]                         }
[17:36:41.082]                         else {
[17:36:41.082]                           version <- NULL
[17:36:41.082]                         }
[17:36:41.082]                         if (!has_future || version < "1.8.0") {
[17:36:41.082]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:41.082]                             "", base::R.version$version.string), 
[17:36:41.082]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:41.082]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:41.082]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:41.082]                               "release", "version")], collapse = " "), 
[17:36:41.082]                             hostname = base::Sys.info()[["nodename"]])
[17:36:41.082]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:41.082]                             info)
[17:36:41.082]                           info <- base::paste(info, collapse = "; ")
[17:36:41.082]                           if (!has_future) {
[17:36:41.082]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:41.082]                               info)
[17:36:41.082]                           }
[17:36:41.082]                           else {
[17:36:41.082]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:41.082]                               info, version)
[17:36:41.082]                           }
[17:36:41.082]                           base::stop(msg)
[17:36:41.082]                         }
[17:36:41.082]                       })
[17:36:41.082]                     }
[17:36:41.082]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:41.082]                     base::options(mc.cores = 1L)
[17:36:41.082]                   }
[17:36:41.082]                   ...future.strategy.old <- future::plan("list")
[17:36:41.082]                   options(future.plan = NULL)
[17:36:41.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:41.082]                 }
[17:36:41.082]                 ...future.workdir <- getwd()
[17:36:41.082]             }
[17:36:41.082]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:41.082]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:41.082]         }
[17:36:41.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:41.082]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:41.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:41.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:41.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:41.082]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:41.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:41.082]             base::names(...future.oldOptions))
[17:36:41.082]     }
[17:36:41.082]     if (FALSE) {
[17:36:41.082]     }
[17:36:41.082]     else {
[17:36:41.082]         if (TRUE) {
[17:36:41.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:41.082]                 open = "w")
[17:36:41.082]         }
[17:36:41.082]         else {
[17:36:41.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:41.082]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:41.082]         }
[17:36:41.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:41.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:41.082]             base::sink(type = "output", split = FALSE)
[17:36:41.082]             base::close(...future.stdout)
[17:36:41.082]         }, add = TRUE)
[17:36:41.082]     }
[17:36:41.082]     ...future.frame <- base::sys.nframe()
[17:36:41.082]     ...future.conditions <- base::list()
[17:36:41.082]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:41.082]     if (FALSE) {
[17:36:41.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:41.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:41.082]     }
[17:36:41.082]     ...future.result <- base::tryCatch({
[17:36:41.082]         base::withCallingHandlers({
[17:36:41.082]             ...future.value <- base::withVisible(base::local({
[17:36:41.082]                 withCallingHandlers({
[17:36:41.082]                   {
[17:36:41.082]                     do.call(function(...) {
[17:36:41.082]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.082]                       if (!identical(...future.globals.maxSize.org, 
[17:36:41.082]                         ...future.globals.maxSize)) {
[17:36:41.082]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.082]                         on.exit(options(oopts), add = TRUE)
[17:36:41.082]                       }
[17:36:41.082]                       {
[17:36:41.082]                         lapply(seq_along(...future.elements_ii), 
[17:36:41.082]                           FUN = function(jj) {
[17:36:41.082]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.082]                             ...future.FUN(...future.X_jj, ...)
[17:36:41.082]                           })
[17:36:41.082]                       }
[17:36:41.082]                     }, args = future.call.arguments)
[17:36:41.082]                   }
[17:36:41.082]                 }, immediateCondition = function(cond) {
[17:36:41.082]                   save_rds <- function (object, pathname, ...) 
[17:36:41.082]                   {
[17:36:41.082]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:41.082]                     if (file_test("-f", pathname_tmp)) {
[17:36:41.082]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.082]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:41.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.082]                         fi_tmp[["mtime"]])
[17:36:41.082]                     }
[17:36:41.082]                     tryCatch({
[17:36:41.082]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:41.082]                     }, error = function(ex) {
[17:36:41.082]                       msg <- conditionMessage(ex)
[17:36:41.082]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.082]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:41.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.082]                         fi_tmp[["mtime"]], msg)
[17:36:41.082]                       ex$message <- msg
[17:36:41.082]                       stop(ex)
[17:36:41.082]                     })
[17:36:41.082]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:41.082]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:41.082]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:41.082]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.082]                       fi <- file.info(pathname)
[17:36:41.082]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:41.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.082]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:41.082]                         fi[["size"]], fi[["mtime"]])
[17:36:41.082]                       stop(msg)
[17:36:41.082]                     }
[17:36:41.082]                     invisible(pathname)
[17:36:41.082]                   }
[17:36:41.082]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:41.082]                     rootPath = tempdir()) 
[17:36:41.082]                   {
[17:36:41.082]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:41.082]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:41.082]                       tmpdir = path, fileext = ".rds")
[17:36:41.082]                     save_rds(obj, file)
[17:36:41.082]                   }
[17:36:41.082]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:41.082]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.082]                   {
[17:36:41.082]                     inherits <- base::inherits
[17:36:41.082]                     invokeRestart <- base::invokeRestart
[17:36:41.082]                     is.null <- base::is.null
[17:36:41.082]                     muffled <- FALSE
[17:36:41.082]                     if (inherits(cond, "message")) {
[17:36:41.082]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:41.082]                       if (muffled) 
[17:36:41.082]                         invokeRestart("muffleMessage")
[17:36:41.082]                     }
[17:36:41.082]                     else if (inherits(cond, "warning")) {
[17:36:41.082]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:41.082]                       if (muffled) 
[17:36:41.082]                         invokeRestart("muffleWarning")
[17:36:41.082]                     }
[17:36:41.082]                     else if (inherits(cond, "condition")) {
[17:36:41.082]                       if (!is.null(pattern)) {
[17:36:41.082]                         computeRestarts <- base::computeRestarts
[17:36:41.082]                         grepl <- base::grepl
[17:36:41.082]                         restarts <- computeRestarts(cond)
[17:36:41.082]                         for (restart in restarts) {
[17:36:41.082]                           name <- restart$name
[17:36:41.082]                           if (is.null(name)) 
[17:36:41.082]                             next
[17:36:41.082]                           if (!grepl(pattern, name)) 
[17:36:41.082]                             next
[17:36:41.082]                           invokeRestart(restart)
[17:36:41.082]                           muffled <- TRUE
[17:36:41.082]                           break
[17:36:41.082]                         }
[17:36:41.082]                       }
[17:36:41.082]                     }
[17:36:41.082]                     invisible(muffled)
[17:36:41.082]                   }
[17:36:41.082]                   muffleCondition(cond)
[17:36:41.082]                 })
[17:36:41.082]             }))
[17:36:41.082]             future::FutureResult(value = ...future.value$value, 
[17:36:41.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.082]                   ...future.rng), globalenv = if (FALSE) 
[17:36:41.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:41.082]                     ...future.globalenv.names))
[17:36:41.082]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:41.082]         }, condition = base::local({
[17:36:41.082]             c <- base::c
[17:36:41.082]             inherits <- base::inherits
[17:36:41.082]             invokeRestart <- base::invokeRestart
[17:36:41.082]             length <- base::length
[17:36:41.082]             list <- base::list
[17:36:41.082]             seq.int <- base::seq.int
[17:36:41.082]             signalCondition <- base::signalCondition
[17:36:41.082]             sys.calls <- base::sys.calls
[17:36:41.082]             `[[` <- base::`[[`
[17:36:41.082]             `+` <- base::`+`
[17:36:41.082]             `<<-` <- base::`<<-`
[17:36:41.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:41.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:41.082]                   3L)]
[17:36:41.082]             }
[17:36:41.082]             function(cond) {
[17:36:41.082]                 is_error <- inherits(cond, "error")
[17:36:41.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:41.082]                   NULL)
[17:36:41.082]                 if (is_error) {
[17:36:41.082]                   sessionInformation <- function() {
[17:36:41.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:41.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:41.082]                       search = base::search(), system = base::Sys.info())
[17:36:41.082]                   }
[17:36:41.082]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:41.082]                     cond$call), session = sessionInformation(), 
[17:36:41.082]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:41.082]                   signalCondition(cond)
[17:36:41.082]                 }
[17:36:41.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:41.082]                 "immediateCondition"))) {
[17:36:41.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:41.082]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:41.082]                   if (TRUE && !signal) {
[17:36:41.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.082]                     {
[17:36:41.082]                       inherits <- base::inherits
[17:36:41.082]                       invokeRestart <- base::invokeRestart
[17:36:41.082]                       is.null <- base::is.null
[17:36:41.082]                       muffled <- FALSE
[17:36:41.082]                       if (inherits(cond, "message")) {
[17:36:41.082]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.082]                         if (muffled) 
[17:36:41.082]                           invokeRestart("muffleMessage")
[17:36:41.082]                       }
[17:36:41.082]                       else if (inherits(cond, "warning")) {
[17:36:41.082]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.082]                         if (muffled) 
[17:36:41.082]                           invokeRestart("muffleWarning")
[17:36:41.082]                       }
[17:36:41.082]                       else if (inherits(cond, "condition")) {
[17:36:41.082]                         if (!is.null(pattern)) {
[17:36:41.082]                           computeRestarts <- base::computeRestarts
[17:36:41.082]                           grepl <- base::grepl
[17:36:41.082]                           restarts <- computeRestarts(cond)
[17:36:41.082]                           for (restart in restarts) {
[17:36:41.082]                             name <- restart$name
[17:36:41.082]                             if (is.null(name)) 
[17:36:41.082]                               next
[17:36:41.082]                             if (!grepl(pattern, name)) 
[17:36:41.082]                               next
[17:36:41.082]                             invokeRestart(restart)
[17:36:41.082]                             muffled <- TRUE
[17:36:41.082]                             break
[17:36:41.082]                           }
[17:36:41.082]                         }
[17:36:41.082]                       }
[17:36:41.082]                       invisible(muffled)
[17:36:41.082]                     }
[17:36:41.082]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.082]                   }
[17:36:41.082]                 }
[17:36:41.082]                 else {
[17:36:41.082]                   if (TRUE) {
[17:36:41.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.082]                     {
[17:36:41.082]                       inherits <- base::inherits
[17:36:41.082]                       invokeRestart <- base::invokeRestart
[17:36:41.082]                       is.null <- base::is.null
[17:36:41.082]                       muffled <- FALSE
[17:36:41.082]                       if (inherits(cond, "message")) {
[17:36:41.082]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.082]                         if (muffled) 
[17:36:41.082]                           invokeRestart("muffleMessage")
[17:36:41.082]                       }
[17:36:41.082]                       else if (inherits(cond, "warning")) {
[17:36:41.082]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.082]                         if (muffled) 
[17:36:41.082]                           invokeRestart("muffleWarning")
[17:36:41.082]                       }
[17:36:41.082]                       else if (inherits(cond, "condition")) {
[17:36:41.082]                         if (!is.null(pattern)) {
[17:36:41.082]                           computeRestarts <- base::computeRestarts
[17:36:41.082]                           grepl <- base::grepl
[17:36:41.082]                           restarts <- computeRestarts(cond)
[17:36:41.082]                           for (restart in restarts) {
[17:36:41.082]                             name <- restart$name
[17:36:41.082]                             if (is.null(name)) 
[17:36:41.082]                               next
[17:36:41.082]                             if (!grepl(pattern, name)) 
[17:36:41.082]                               next
[17:36:41.082]                             invokeRestart(restart)
[17:36:41.082]                             muffled <- TRUE
[17:36:41.082]                             break
[17:36:41.082]                           }
[17:36:41.082]                         }
[17:36:41.082]                       }
[17:36:41.082]                       invisible(muffled)
[17:36:41.082]                     }
[17:36:41.082]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.082]                   }
[17:36:41.082]                 }
[17:36:41.082]             }
[17:36:41.082]         }))
[17:36:41.082]     }, error = function(ex) {
[17:36:41.082]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:41.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.082]                 ...future.rng), started = ...future.startTime, 
[17:36:41.082]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:41.082]             version = "1.8"), class = "FutureResult")
[17:36:41.082]     }, finally = {
[17:36:41.082]         if (!identical(...future.workdir, getwd())) 
[17:36:41.082]             setwd(...future.workdir)
[17:36:41.082]         {
[17:36:41.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:41.082]                 ...future.oldOptions$nwarnings <- NULL
[17:36:41.082]             }
[17:36:41.082]             base::options(...future.oldOptions)
[17:36:41.082]             if (.Platform$OS.type == "windows") {
[17:36:41.082]                 old_names <- names(...future.oldEnvVars)
[17:36:41.082]                 envs <- base::Sys.getenv()
[17:36:41.082]                 names <- names(envs)
[17:36:41.082]                 common <- intersect(names, old_names)
[17:36:41.082]                 added <- setdiff(names, old_names)
[17:36:41.082]                 removed <- setdiff(old_names, names)
[17:36:41.082]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:41.082]                   envs[common]]
[17:36:41.082]                 NAMES <- toupper(changed)
[17:36:41.082]                 args <- list()
[17:36:41.082]                 for (kk in seq_along(NAMES)) {
[17:36:41.082]                   name <- changed[[kk]]
[17:36:41.082]                   NAME <- NAMES[[kk]]
[17:36:41.082]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.082]                     next
[17:36:41.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.082]                 }
[17:36:41.082]                 NAMES <- toupper(added)
[17:36:41.082]                 for (kk in seq_along(NAMES)) {
[17:36:41.082]                   name <- added[[kk]]
[17:36:41.082]                   NAME <- NAMES[[kk]]
[17:36:41.082]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.082]                     next
[17:36:41.082]                   args[[name]] <- ""
[17:36:41.082]                 }
[17:36:41.082]                 NAMES <- toupper(removed)
[17:36:41.082]                 for (kk in seq_along(NAMES)) {
[17:36:41.082]                   name <- removed[[kk]]
[17:36:41.082]                   NAME <- NAMES[[kk]]
[17:36:41.082]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.082]                     next
[17:36:41.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.082]                 }
[17:36:41.082]                 if (length(args) > 0) 
[17:36:41.082]                   base::do.call(base::Sys.setenv, args = args)
[17:36:41.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:41.082]             }
[17:36:41.082]             else {
[17:36:41.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:41.082]             }
[17:36:41.082]             {
[17:36:41.082]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:41.082]                   0L) {
[17:36:41.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:41.082]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:41.082]                   base::options(opts)
[17:36:41.082]                 }
[17:36:41.082]                 {
[17:36:41.082]                   {
[17:36:41.082]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:41.082]                     NULL
[17:36:41.082]                   }
[17:36:41.082]                   options(future.plan = NULL)
[17:36:41.082]                   if (is.na(NA_character_)) 
[17:36:41.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:41.082]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:41.082]                     .init = FALSE)
[17:36:41.082]                 }
[17:36:41.082]             }
[17:36:41.082]         }
[17:36:41.082]     })
[17:36:41.082]     if (TRUE) {
[17:36:41.082]         base::sink(type = "output", split = FALSE)
[17:36:41.082]         if (TRUE) {
[17:36:41.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:41.082]         }
[17:36:41.082]         else {
[17:36:41.082]             ...future.result["stdout"] <- base::list(NULL)
[17:36:41.082]         }
[17:36:41.082]         base::close(...future.stdout)
[17:36:41.082]         ...future.stdout <- NULL
[17:36:41.082]     }
[17:36:41.082]     ...future.result$conditions <- ...future.conditions
[17:36:41.082]     ...future.result$finished <- base::Sys.time()
[17:36:41.082]     ...future.result
[17:36:41.082] }
[17:36:41.085] assign_globals() ...
[17:36:41.085] List of 5
[17:36:41.085]  $ ...future.FUN            :function (object, ...)  
[17:36:41.085]  $ future.call.arguments    : list()
[17:36:41.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:41.085]  $ ...future.elements_ii    :List of 2
[17:36:41.085]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:41.085]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:41.085]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:41.085]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:41.085]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:41.085]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:41.085]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:41.085]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:41.085]  $ ...future.seeds_ii       : NULL
[17:36:41.085]  $ ...future.globals.maxSize: NULL
[17:36:41.085]  - attr(*, "where")=List of 5
[17:36:41.085]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:41.085]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:41.085]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:41.085]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:41.085]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:41.085]  - attr(*, "resolved")= logi FALSE
[17:36:41.085]  - attr(*, "total_size")= num 1240
[17:36:41.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:41.085]  - attr(*, "already-done")= logi TRUE
[17:36:41.095] - copied ‘...future.FUN’ to environment
[17:36:41.095] - copied ‘future.call.arguments’ to environment
[17:36:41.095] - copied ‘...future.elements_ii’ to environment
[17:36:41.095] - copied ‘...future.seeds_ii’ to environment
[17:36:41.095] - copied ‘...future.globals.maxSize’ to environment
[17:36:41.095] assign_globals() ... done
[17:36:41.095] requestCore(): workers = 2
[17:36:41.098] MulticoreFuture started
[17:36:41.098] - Launch lazy future ... done
[17:36:41.098] run() for ‘MulticoreFuture’ ... done
[17:36:41.098] Created future:
[17:36:41.099] plan(): Setting new future strategy stack:
[17:36:41.099] List of future strategies:
[17:36:41.099] 1. sequential:
[17:36:41.099]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:41.099]    - tweaked: FALSE
[17:36:41.099]    - call: NULL
[17:36:41.100] plan(): nbrOfWorkers() = 1
[17:36:41.104] plan(): Setting new future strategy stack:
[17:36:41.104] List of future strategies:
[17:36:41.104] 1. multicore:
[17:36:41.104]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:41.104]    - tweaked: FALSE
[17:36:41.104]    - call: plan(strategy)
[17:36:41.099] MulticoreFuture:
[17:36:41.099] Label: ‘future_by-2’
[17:36:41.099] Expression:
[17:36:41.099] {
[17:36:41.099]     do.call(function(...) {
[17:36:41.099]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.099]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:41.099]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.099]             on.exit(options(oopts), add = TRUE)
[17:36:41.099]         }
[17:36:41.099]         {
[17:36:41.099]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:41.099]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.099]                 ...future.FUN(...future.X_jj, ...)
[17:36:41.099]             })
[17:36:41.099]         }
[17:36:41.099]     }, args = future.call.arguments)
[17:36:41.099] }
[17:36:41.099] Lazy evaluation: FALSE
[17:36:41.099] Asynchronous evaluation: TRUE
[17:36:41.099] Local evaluation: TRUE
[17:36:41.099] Environment: 0x5622fca11398
[17:36:41.099] Capture standard output: TRUE
[17:36:41.099] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:41.099] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:41.099] Packages: <none>
[17:36:41.099] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:41.099] Resolved: FALSE
[17:36:41.099] Value: <not collected>
[17:36:41.099] Conditions captured: <none>
[17:36:41.099] Early signaling: FALSE
[17:36:41.099] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:41.099] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:41.112] Chunk #2 of 2 ... DONE
[17:36:41.112] Launching 2 futures (chunks) ... DONE
[17:36:41.112] Resolving 2 futures (chunks) ...
[17:36:41.113] resolve() on list ...
[17:36:41.113]  recursive: 0
[17:36:41.113]  length: 2
[17:36:41.113] 
[17:36:41.113] Future #1
[17:36:41.113] result() for MulticoreFuture ...
[17:36:41.114] result() for MulticoreFuture ...
[17:36:41.114] plan(): nbrOfWorkers() = 2
[17:36:41.114] result() for MulticoreFuture ... done
[17:36:41.115] result() for MulticoreFuture ... done
[17:36:41.115] result() for MulticoreFuture ...
[17:36:41.115] result() for MulticoreFuture ... done
[17:36:41.118] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:41.118] - nx: 2
[17:36:41.118] - relay: TRUE
[17:36:41.118] - stdout: TRUE
[17:36:41.118] - signal: TRUE
[17:36:41.119] - resignal: FALSE
[17:36:41.119] - force: TRUE
[17:36:41.119] - relayed: [n=2] FALSE, FALSE
[17:36:41.120] - queued futures: [n=2] FALSE, FALSE
[17:36:41.120]  - until=1
[17:36:41.120]  - relaying element #1
[17:36:41.121] result() for MulticoreFuture ...
[17:36:41.121] result() for MulticoreFuture ... done
[17:36:41.121] result() for MulticoreFuture ...
[17:36:41.121] result() for MulticoreFuture ... done
[17:36:41.122] result() for MulticoreFuture ...
[17:36:41.122] result() for MulticoreFuture ... done
[17:36:41.122] result() for MulticoreFuture ...
[17:36:41.122] result() for MulticoreFuture ... done
[17:36:41.123] - relayed: [n=2] TRUE, FALSE
[17:36:41.123] - queued futures: [n=2] TRUE, FALSE
[17:36:41.123] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:41.123]  length: 1 (resolved future 1)
[17:36:41.124] Future #2
[17:36:41.124] result() for MulticoreFuture ...
[17:36:41.125] result() for MulticoreFuture ...
[17:36:41.125] result() for MulticoreFuture ... done
[17:36:41.126] result() for MulticoreFuture ... done
[17:36:41.126] result() for MulticoreFuture ...
[17:36:41.126] result() for MulticoreFuture ... done
[17:36:41.126] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:41.126] - nx: 2
[17:36:41.127] - relay: TRUE
[17:36:41.127] - stdout: TRUE
[17:36:41.127] - signal: TRUE
[17:36:41.127] - resignal: FALSE
[17:36:41.127] - force: TRUE
[17:36:41.128] - relayed: [n=2] TRUE, FALSE
[17:36:41.128] - queued futures: [n=2] TRUE, FALSE
[17:36:41.128]  - until=2
[17:36:41.128]  - relaying element #2
[17:36:41.128] result() for MulticoreFuture ...
[17:36:41.128] result() for MulticoreFuture ... done
[17:36:41.128] result() for MulticoreFuture ...
[17:36:41.129] result() for MulticoreFuture ... done
[17:36:41.129] result() for MulticoreFuture ...
[17:36:41.129] result() for MulticoreFuture ... done
[17:36:41.129] result() for MulticoreFuture ...
[17:36:41.129] result() for MulticoreFuture ... done
[17:36:41.129] - relayed: [n=2] TRUE, TRUE
[17:36:41.129] - queued futures: [n=2] TRUE, TRUE
[17:36:41.129] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:41.130]  length: 0 (resolved future 2)
[17:36:41.130] Relaying remaining futures
[17:36:41.130] signalConditionsASAP(NULL, pos=0) ...
[17:36:41.130] - nx: 2
[17:36:41.130] - relay: TRUE
[17:36:41.130] - stdout: TRUE
[17:36:41.130] - signal: TRUE
[17:36:41.130] - resignal: FALSE
[17:36:41.130] - force: TRUE
[17:36:41.131] - relayed: [n=2] TRUE, TRUE
[17:36:41.131] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:41.131] - relayed: [n=2] TRUE, TRUE
[17:36:41.131] - queued futures: [n=2] TRUE, TRUE
[17:36:41.131] signalConditionsASAP(NULL, pos=0) ... done
[17:36:41.131] resolve() on list ... DONE
[17:36:41.131] result() for MulticoreFuture ...
[17:36:41.131] result() for MulticoreFuture ... done
[17:36:41.131] result() for MulticoreFuture ...
[17:36:41.132] result() for MulticoreFuture ... done
[17:36:41.132] result() for MulticoreFuture ...
[17:36:41.132] result() for MulticoreFuture ... done
[17:36:41.132] result() for MulticoreFuture ...
[17:36:41.132] result() for MulticoreFuture ... done
[17:36:41.132]  - Number of value chunks collected: 2
[17:36:41.132] Resolving 2 futures (chunks) ... DONE
[17:36:41.132] Reducing values from 2 chunks ...
[17:36:41.133]  - Number of values collected after concatenation: 3
[17:36:41.133]  - Number of values expected: 3
[17:36:41.133] Reducing values from 2 chunks ... DONE
[17:36:41.133] future_lapply() ... DONE
[17:36:41.133] future_by_internal() ... DONE
[17:36:41.134] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:36:41.135] future_lapply() ...
[17:36:41.139] Number of chunks: 2
[17:36:41.140] getGlobalsAndPackagesXApply() ...
[17:36:41.140]  - future.globals: TRUE
[17:36:41.140] getGlobalsAndPackages() ...
[17:36:41.140] Searching for globals...
[17:36:41.141] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:41.141] Searching for globals ... DONE
[17:36:41.141] Resolving globals: FALSE
[17:36:41.142] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:41.142] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:41.142] - globals: [1] ‘FUN’
[17:36:41.142] 
[17:36:41.142] getGlobalsAndPackages() ... DONE
[17:36:41.143]  - globals found/used: [n=1] ‘FUN’
[17:36:41.143]  - needed namespaces: [n=0] 
[17:36:41.143] Finding globals ... DONE
[17:36:41.143]  - use_args: TRUE
[17:36:41.143]  - Getting '...' globals ...
[17:36:41.143] resolve() on list ...
[17:36:41.143]  recursive: 0
[17:36:41.144]  length: 1
[17:36:41.144]  elements: ‘...’
[17:36:41.144]  length: 0 (resolved future 1)
[17:36:41.144] resolve() on list ... DONE
[17:36:41.144]    - '...' content: [n=0] 
[17:36:41.144] List of 1
[17:36:41.144]  $ ...: list()
[17:36:41.144]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:41.144]  - attr(*, "where")=List of 1
[17:36:41.144]   ..$ ...:<environment: 0x5622fb3bb238> 
[17:36:41.144]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:41.144]  - attr(*, "resolved")= logi TRUE
[17:36:41.144]  - attr(*, "total_size")= num NA
[17:36:41.149]  - Getting '...' globals ... DONE
[17:36:41.149] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:41.149] List of 2
[17:36:41.149]  $ ...future.FUN:function (object, ...)  
[17:36:41.149]  $ ...          : list()
[17:36:41.149]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:41.149]  - attr(*, "where")=List of 2
[17:36:41.149]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:41.149]   ..$ ...          :<environment: 0x5622fb3bb238> 
[17:36:41.149]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:41.149]  - attr(*, "resolved")= logi FALSE
[17:36:41.149]  - attr(*, "total_size")= num 1240
[17:36:41.153] Packages to be attached in all futures: [n=0] 
[17:36:41.153] getGlobalsAndPackagesXApply() ... DONE
[17:36:41.153] Number of futures (= number of chunks): 2
[17:36:41.153] Launching 2 futures (chunks) ...
[17:36:41.153] Chunk #1 of 2 ...
[17:36:41.153]  - Finding globals in 'X' for chunk #1 ...
[17:36:41.154] getGlobalsAndPackages() ...
[17:36:41.154] Searching for globals...
[17:36:41.154] 
[17:36:41.154] Searching for globals ... DONE
[17:36:41.154] - globals: [0] <none>
[17:36:41.154] getGlobalsAndPackages() ... DONE
[17:36:41.155]    + additional globals found: [n=0] 
[17:36:41.155]    + additional namespaces needed: [n=0] 
[17:36:41.155]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:41.155]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:41.155]  - seeds: <none>
[17:36:41.155]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.155] getGlobalsAndPackages() ...
[17:36:41.155] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.155] Resolving globals: FALSE
[17:36:41.156] Tweak future expression to call with '...' arguments ...
[17:36:41.156] {
[17:36:41.156]     do.call(function(...) {
[17:36:41.156]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.156]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:41.156]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.156]             on.exit(options(oopts), add = TRUE)
[17:36:41.156]         }
[17:36:41.156]         {
[17:36:41.156]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:41.156]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.156]                 ...future.FUN(...future.X_jj, ...)
[17:36:41.156]             })
[17:36:41.156]         }
[17:36:41.156]     }, args = future.call.arguments)
[17:36:41.156] }
[17:36:41.156] Tweak future expression to call with '...' arguments ... DONE
[17:36:41.156] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.156] 
[17:36:41.157] getGlobalsAndPackages() ... DONE
[17:36:41.157] run() for ‘Future’ ...
[17:36:41.157] - state: ‘created’
[17:36:41.157] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:41.161] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:41.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:41.161]   - Field: ‘label’
[17:36:41.161]   - Field: ‘local’
[17:36:41.161]   - Field: ‘owner’
[17:36:41.161]   - Field: ‘envir’
[17:36:41.161]   - Field: ‘workers’
[17:36:41.162]   - Field: ‘packages’
[17:36:41.162]   - Field: ‘gc’
[17:36:41.162]   - Field: ‘job’
[17:36:41.162]   - Field: ‘conditions’
[17:36:41.162]   - Field: ‘expr’
[17:36:41.162]   - Field: ‘uuid’
[17:36:41.162]   - Field: ‘seed’
[17:36:41.162]   - Field: ‘version’
[17:36:41.162]   - Field: ‘result’
[17:36:41.162]   - Field: ‘asynchronous’
[17:36:41.162]   - Field: ‘calls’
[17:36:41.162]   - Field: ‘globals’
[17:36:41.163]   - Field: ‘stdout’
[17:36:41.163]   - Field: ‘earlySignal’
[17:36:41.163]   - Field: ‘lazy’
[17:36:41.163]   - Field: ‘state’
[17:36:41.163] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:41.163] - Launch lazy future ...
[17:36:41.163] Packages needed by the future expression (n = 0): <none>
[17:36:41.163] Packages needed by future strategies (n = 0): <none>
[17:36:41.164] {
[17:36:41.164]     {
[17:36:41.164]         {
[17:36:41.164]             ...future.startTime <- base::Sys.time()
[17:36:41.164]             {
[17:36:41.164]                 {
[17:36:41.164]                   {
[17:36:41.164]                     {
[17:36:41.164]                       base::local({
[17:36:41.164]                         has_future <- base::requireNamespace("future", 
[17:36:41.164]                           quietly = TRUE)
[17:36:41.164]                         if (has_future) {
[17:36:41.164]                           ns <- base::getNamespace("future")
[17:36:41.164]                           version <- ns[[".package"]][["version"]]
[17:36:41.164]                           if (is.null(version)) 
[17:36:41.164]                             version <- utils::packageVersion("future")
[17:36:41.164]                         }
[17:36:41.164]                         else {
[17:36:41.164]                           version <- NULL
[17:36:41.164]                         }
[17:36:41.164]                         if (!has_future || version < "1.8.0") {
[17:36:41.164]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:41.164]                             "", base::R.version$version.string), 
[17:36:41.164]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:41.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:41.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:41.164]                               "release", "version")], collapse = " "), 
[17:36:41.164]                             hostname = base::Sys.info()[["nodename"]])
[17:36:41.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:41.164]                             info)
[17:36:41.164]                           info <- base::paste(info, collapse = "; ")
[17:36:41.164]                           if (!has_future) {
[17:36:41.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:41.164]                               info)
[17:36:41.164]                           }
[17:36:41.164]                           else {
[17:36:41.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:41.164]                               info, version)
[17:36:41.164]                           }
[17:36:41.164]                           base::stop(msg)
[17:36:41.164]                         }
[17:36:41.164]                       })
[17:36:41.164]                     }
[17:36:41.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:41.164]                     base::options(mc.cores = 1L)
[17:36:41.164]                   }
[17:36:41.164]                   ...future.strategy.old <- future::plan("list")
[17:36:41.164]                   options(future.plan = NULL)
[17:36:41.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:41.164]                 }
[17:36:41.164]                 ...future.workdir <- getwd()
[17:36:41.164]             }
[17:36:41.164]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:41.164]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:41.164]         }
[17:36:41.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:41.164]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:41.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:41.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:41.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:41.164]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:41.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:41.164]             base::names(...future.oldOptions))
[17:36:41.164]     }
[17:36:41.164]     if (FALSE) {
[17:36:41.164]     }
[17:36:41.164]     else {
[17:36:41.164]         if (TRUE) {
[17:36:41.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:41.164]                 open = "w")
[17:36:41.164]         }
[17:36:41.164]         else {
[17:36:41.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:41.164]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:41.164]         }
[17:36:41.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:41.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:41.164]             base::sink(type = "output", split = FALSE)
[17:36:41.164]             base::close(...future.stdout)
[17:36:41.164]         }, add = TRUE)
[17:36:41.164]     }
[17:36:41.164]     ...future.frame <- base::sys.nframe()
[17:36:41.164]     ...future.conditions <- base::list()
[17:36:41.164]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:41.164]     if (FALSE) {
[17:36:41.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:41.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:41.164]     }
[17:36:41.164]     ...future.result <- base::tryCatch({
[17:36:41.164]         base::withCallingHandlers({
[17:36:41.164]             ...future.value <- base::withVisible(base::local({
[17:36:41.164]                 withCallingHandlers({
[17:36:41.164]                   {
[17:36:41.164]                     do.call(function(...) {
[17:36:41.164]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.164]                       if (!identical(...future.globals.maxSize.org, 
[17:36:41.164]                         ...future.globals.maxSize)) {
[17:36:41.164]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.164]                         on.exit(options(oopts), add = TRUE)
[17:36:41.164]                       }
[17:36:41.164]                       {
[17:36:41.164]                         lapply(seq_along(...future.elements_ii), 
[17:36:41.164]                           FUN = function(jj) {
[17:36:41.164]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.164]                             ...future.FUN(...future.X_jj, ...)
[17:36:41.164]                           })
[17:36:41.164]                       }
[17:36:41.164]                     }, args = future.call.arguments)
[17:36:41.164]                   }
[17:36:41.164]                 }, immediateCondition = function(cond) {
[17:36:41.164]                   save_rds <- function (object, pathname, ...) 
[17:36:41.164]                   {
[17:36:41.164]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:41.164]                     if (file_test("-f", pathname_tmp)) {
[17:36:41.164]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.164]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:41.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.164]                         fi_tmp[["mtime"]])
[17:36:41.164]                     }
[17:36:41.164]                     tryCatch({
[17:36:41.164]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:41.164]                     }, error = function(ex) {
[17:36:41.164]                       msg <- conditionMessage(ex)
[17:36:41.164]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.164]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:41.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.164]                         fi_tmp[["mtime"]], msg)
[17:36:41.164]                       ex$message <- msg
[17:36:41.164]                       stop(ex)
[17:36:41.164]                     })
[17:36:41.164]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:41.164]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:41.164]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:41.164]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.164]                       fi <- file.info(pathname)
[17:36:41.164]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:41.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.164]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:41.164]                         fi[["size"]], fi[["mtime"]])
[17:36:41.164]                       stop(msg)
[17:36:41.164]                     }
[17:36:41.164]                     invisible(pathname)
[17:36:41.164]                   }
[17:36:41.164]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:41.164]                     rootPath = tempdir()) 
[17:36:41.164]                   {
[17:36:41.164]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:41.164]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:41.164]                       tmpdir = path, fileext = ".rds")
[17:36:41.164]                     save_rds(obj, file)
[17:36:41.164]                   }
[17:36:41.164]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:41.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.164]                   {
[17:36:41.164]                     inherits <- base::inherits
[17:36:41.164]                     invokeRestart <- base::invokeRestart
[17:36:41.164]                     is.null <- base::is.null
[17:36:41.164]                     muffled <- FALSE
[17:36:41.164]                     if (inherits(cond, "message")) {
[17:36:41.164]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:41.164]                       if (muffled) 
[17:36:41.164]                         invokeRestart("muffleMessage")
[17:36:41.164]                     }
[17:36:41.164]                     else if (inherits(cond, "warning")) {
[17:36:41.164]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:41.164]                       if (muffled) 
[17:36:41.164]                         invokeRestart("muffleWarning")
[17:36:41.164]                     }
[17:36:41.164]                     else if (inherits(cond, "condition")) {
[17:36:41.164]                       if (!is.null(pattern)) {
[17:36:41.164]                         computeRestarts <- base::computeRestarts
[17:36:41.164]                         grepl <- base::grepl
[17:36:41.164]                         restarts <- computeRestarts(cond)
[17:36:41.164]                         for (restart in restarts) {
[17:36:41.164]                           name <- restart$name
[17:36:41.164]                           if (is.null(name)) 
[17:36:41.164]                             next
[17:36:41.164]                           if (!grepl(pattern, name)) 
[17:36:41.164]                             next
[17:36:41.164]                           invokeRestart(restart)
[17:36:41.164]                           muffled <- TRUE
[17:36:41.164]                           break
[17:36:41.164]                         }
[17:36:41.164]                       }
[17:36:41.164]                     }
[17:36:41.164]                     invisible(muffled)
[17:36:41.164]                   }
[17:36:41.164]                   muffleCondition(cond)
[17:36:41.164]                 })
[17:36:41.164]             }))
[17:36:41.164]             future::FutureResult(value = ...future.value$value, 
[17:36:41.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.164]                   ...future.rng), globalenv = if (FALSE) 
[17:36:41.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:41.164]                     ...future.globalenv.names))
[17:36:41.164]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:41.164]         }, condition = base::local({
[17:36:41.164]             c <- base::c
[17:36:41.164]             inherits <- base::inherits
[17:36:41.164]             invokeRestart <- base::invokeRestart
[17:36:41.164]             length <- base::length
[17:36:41.164]             list <- base::list
[17:36:41.164]             seq.int <- base::seq.int
[17:36:41.164]             signalCondition <- base::signalCondition
[17:36:41.164]             sys.calls <- base::sys.calls
[17:36:41.164]             `[[` <- base::`[[`
[17:36:41.164]             `+` <- base::`+`
[17:36:41.164]             `<<-` <- base::`<<-`
[17:36:41.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:41.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:41.164]                   3L)]
[17:36:41.164]             }
[17:36:41.164]             function(cond) {
[17:36:41.164]                 is_error <- inherits(cond, "error")
[17:36:41.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:41.164]                   NULL)
[17:36:41.164]                 if (is_error) {
[17:36:41.164]                   sessionInformation <- function() {
[17:36:41.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:41.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:41.164]                       search = base::search(), system = base::Sys.info())
[17:36:41.164]                   }
[17:36:41.164]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:41.164]                     cond$call), session = sessionInformation(), 
[17:36:41.164]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:41.164]                   signalCondition(cond)
[17:36:41.164]                 }
[17:36:41.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:41.164]                 "immediateCondition"))) {
[17:36:41.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:41.164]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:41.164]                   if (TRUE && !signal) {
[17:36:41.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.164]                     {
[17:36:41.164]                       inherits <- base::inherits
[17:36:41.164]                       invokeRestart <- base::invokeRestart
[17:36:41.164]                       is.null <- base::is.null
[17:36:41.164]                       muffled <- FALSE
[17:36:41.164]                       if (inherits(cond, "message")) {
[17:36:41.164]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.164]                         if (muffled) 
[17:36:41.164]                           invokeRestart("muffleMessage")
[17:36:41.164]                       }
[17:36:41.164]                       else if (inherits(cond, "warning")) {
[17:36:41.164]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.164]                         if (muffled) 
[17:36:41.164]                           invokeRestart("muffleWarning")
[17:36:41.164]                       }
[17:36:41.164]                       else if (inherits(cond, "condition")) {
[17:36:41.164]                         if (!is.null(pattern)) {
[17:36:41.164]                           computeRestarts <- base::computeRestarts
[17:36:41.164]                           grepl <- base::grepl
[17:36:41.164]                           restarts <- computeRestarts(cond)
[17:36:41.164]                           for (restart in restarts) {
[17:36:41.164]                             name <- restart$name
[17:36:41.164]                             if (is.null(name)) 
[17:36:41.164]                               next
[17:36:41.164]                             if (!grepl(pattern, name)) 
[17:36:41.164]                               next
[17:36:41.164]                             invokeRestart(restart)
[17:36:41.164]                             muffled <- TRUE
[17:36:41.164]                             break
[17:36:41.164]                           }
[17:36:41.164]                         }
[17:36:41.164]                       }
[17:36:41.164]                       invisible(muffled)
[17:36:41.164]                     }
[17:36:41.164]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.164]                   }
[17:36:41.164]                 }
[17:36:41.164]                 else {
[17:36:41.164]                   if (TRUE) {
[17:36:41.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.164]                     {
[17:36:41.164]                       inherits <- base::inherits
[17:36:41.164]                       invokeRestart <- base::invokeRestart
[17:36:41.164]                       is.null <- base::is.null
[17:36:41.164]                       muffled <- FALSE
[17:36:41.164]                       if (inherits(cond, "message")) {
[17:36:41.164]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.164]                         if (muffled) 
[17:36:41.164]                           invokeRestart("muffleMessage")
[17:36:41.164]                       }
[17:36:41.164]                       else if (inherits(cond, "warning")) {
[17:36:41.164]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.164]                         if (muffled) 
[17:36:41.164]                           invokeRestart("muffleWarning")
[17:36:41.164]                       }
[17:36:41.164]                       else if (inherits(cond, "condition")) {
[17:36:41.164]                         if (!is.null(pattern)) {
[17:36:41.164]                           computeRestarts <- base::computeRestarts
[17:36:41.164]                           grepl <- base::grepl
[17:36:41.164]                           restarts <- computeRestarts(cond)
[17:36:41.164]                           for (restart in restarts) {
[17:36:41.164]                             name <- restart$name
[17:36:41.164]                             if (is.null(name)) 
[17:36:41.164]                               next
[17:36:41.164]                             if (!grepl(pattern, name)) 
[17:36:41.164]                               next
[17:36:41.164]                             invokeRestart(restart)
[17:36:41.164]                             muffled <- TRUE
[17:36:41.164]                             break
[17:36:41.164]                           }
[17:36:41.164]                         }
[17:36:41.164]                       }
[17:36:41.164]                       invisible(muffled)
[17:36:41.164]                     }
[17:36:41.164]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.164]                   }
[17:36:41.164]                 }
[17:36:41.164]             }
[17:36:41.164]         }))
[17:36:41.164]     }, error = function(ex) {
[17:36:41.164]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:41.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.164]                 ...future.rng), started = ...future.startTime, 
[17:36:41.164]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:41.164]             version = "1.8"), class = "FutureResult")
[17:36:41.164]     }, finally = {
[17:36:41.164]         if (!identical(...future.workdir, getwd())) 
[17:36:41.164]             setwd(...future.workdir)
[17:36:41.164]         {
[17:36:41.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:41.164]                 ...future.oldOptions$nwarnings <- NULL
[17:36:41.164]             }
[17:36:41.164]             base::options(...future.oldOptions)
[17:36:41.164]             if (.Platform$OS.type == "windows") {
[17:36:41.164]                 old_names <- names(...future.oldEnvVars)
[17:36:41.164]                 envs <- base::Sys.getenv()
[17:36:41.164]                 names <- names(envs)
[17:36:41.164]                 common <- intersect(names, old_names)
[17:36:41.164]                 added <- setdiff(names, old_names)
[17:36:41.164]                 removed <- setdiff(old_names, names)
[17:36:41.164]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:41.164]                   envs[common]]
[17:36:41.164]                 NAMES <- toupper(changed)
[17:36:41.164]                 args <- list()
[17:36:41.164]                 for (kk in seq_along(NAMES)) {
[17:36:41.164]                   name <- changed[[kk]]
[17:36:41.164]                   NAME <- NAMES[[kk]]
[17:36:41.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.164]                     next
[17:36:41.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.164]                 }
[17:36:41.164]                 NAMES <- toupper(added)
[17:36:41.164]                 for (kk in seq_along(NAMES)) {
[17:36:41.164]                   name <- added[[kk]]
[17:36:41.164]                   NAME <- NAMES[[kk]]
[17:36:41.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.164]                     next
[17:36:41.164]                   args[[name]] <- ""
[17:36:41.164]                 }
[17:36:41.164]                 NAMES <- toupper(removed)
[17:36:41.164]                 for (kk in seq_along(NAMES)) {
[17:36:41.164]                   name <- removed[[kk]]
[17:36:41.164]                   NAME <- NAMES[[kk]]
[17:36:41.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.164]                     next
[17:36:41.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.164]                 }
[17:36:41.164]                 if (length(args) > 0) 
[17:36:41.164]                   base::do.call(base::Sys.setenv, args = args)
[17:36:41.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:41.164]             }
[17:36:41.164]             else {
[17:36:41.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:41.164]             }
[17:36:41.164]             {
[17:36:41.164]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:41.164]                   0L) {
[17:36:41.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:41.164]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:41.164]                   base::options(opts)
[17:36:41.164]                 }
[17:36:41.164]                 {
[17:36:41.164]                   {
[17:36:41.164]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:41.164]                     NULL
[17:36:41.164]                   }
[17:36:41.164]                   options(future.plan = NULL)
[17:36:41.164]                   if (is.na(NA_character_)) 
[17:36:41.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:41.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:41.164]                     .init = FALSE)
[17:36:41.164]                 }
[17:36:41.164]             }
[17:36:41.164]         }
[17:36:41.164]     })
[17:36:41.164]     if (TRUE) {
[17:36:41.164]         base::sink(type = "output", split = FALSE)
[17:36:41.164]         if (TRUE) {
[17:36:41.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:41.164]         }
[17:36:41.164]         else {
[17:36:41.164]             ...future.result["stdout"] <- base::list(NULL)
[17:36:41.164]         }
[17:36:41.164]         base::close(...future.stdout)
[17:36:41.164]         ...future.stdout <- NULL
[17:36:41.164]     }
[17:36:41.164]     ...future.result$conditions <- ...future.conditions
[17:36:41.164]     ...future.result$finished <- base::Sys.time()
[17:36:41.164]     ...future.result
[17:36:41.164] }
[17:36:41.166] assign_globals() ...
[17:36:41.167] List of 5
[17:36:41.167]  $ ...future.FUN            :function (object, ...)  
[17:36:41.167]  $ future.call.arguments    : list()
[17:36:41.167]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:41.167]  $ ...future.elements_ii    :List of 1
[17:36:41.167]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:41.167]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:36:41.167]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:41.167]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:41.167]  $ ...future.seeds_ii       : NULL
[17:36:41.167]  $ ...future.globals.maxSize: NULL
[17:36:41.167]  - attr(*, "where")=List of 5
[17:36:41.167]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:41.167]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:41.167]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:41.167]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:41.167]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:41.167]  - attr(*, "resolved")= logi FALSE
[17:36:41.167]  - attr(*, "total_size")= num 1240
[17:36:41.167]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:41.167]  - attr(*, "already-done")= logi TRUE
[17:36:41.175] - copied ‘...future.FUN’ to environment
[17:36:41.175] - copied ‘future.call.arguments’ to environment
[17:36:41.175] - copied ‘...future.elements_ii’ to environment
[17:36:41.175] - copied ‘...future.seeds_ii’ to environment
[17:36:41.175] - copied ‘...future.globals.maxSize’ to environment
[17:36:41.175] assign_globals() ... done
[17:36:41.176] requestCore(): workers = 2
[17:36:41.178] MulticoreFuture started
[17:36:41.179] - Launch lazy future ... done
[17:36:41.179] plan(): Setting new future strategy stack:
[17:36:41.179] run() for ‘MulticoreFuture’ ... done
[17:36:41.180] Created future:
[17:36:41.180] List of future strategies:
[17:36:41.180] 1. sequential:
[17:36:41.180]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:41.180]    - tweaked: FALSE
[17:36:41.180]    - call: NULL
[17:36:41.182] plan(): nbrOfWorkers() = 1
[17:36:41.187] plan(): Setting new future strategy stack:
[17:36:41.187] List of future strategies:
[17:36:41.187] 1. multicore:
[17:36:41.187]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:41.187]    - tweaked: FALSE
[17:36:41.187]    - call: plan(strategy)
[17:36:41.193] plan(): nbrOfWorkers() = 2
[17:36:41.181] MulticoreFuture:
[17:36:41.181] Label: ‘future_by-1’
[17:36:41.181] Expression:
[17:36:41.181] {
[17:36:41.181]     do.call(function(...) {
[17:36:41.181]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.181]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:41.181]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.181]             on.exit(options(oopts), add = TRUE)
[17:36:41.181]         }
[17:36:41.181]         {
[17:36:41.181]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:41.181]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.181]                 ...future.FUN(...future.X_jj, ...)
[17:36:41.181]             })
[17:36:41.181]         }
[17:36:41.181]     }, args = future.call.arguments)
[17:36:41.181] }
[17:36:41.181] Lazy evaluation: FALSE
[17:36:41.181] Asynchronous evaluation: TRUE
[17:36:41.181] Local evaluation: TRUE
[17:36:41.181] Environment: 0x5622fa0156a8
[17:36:41.181] Capture standard output: TRUE
[17:36:41.181] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:41.181] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:41.181] Packages: <none>
[17:36:41.181] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:41.181] Resolved: TRUE
[17:36:41.181] Value: <not collected>
[17:36:41.181] Conditions captured: <none>
[17:36:41.181] Early signaling: FALSE
[17:36:41.181] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:41.181] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:41.194] Chunk #1 of 2 ... DONE
[17:36:41.194] Chunk #2 of 2 ...
[17:36:41.195]  - Finding globals in 'X' for chunk #2 ...
[17:36:41.195] getGlobalsAndPackages() ...
[17:36:41.195] Searching for globals...
[17:36:41.196] 
[17:36:41.196] Searching for globals ... DONE
[17:36:41.196] - globals: [0] <none>
[17:36:41.196] getGlobalsAndPackages() ... DONE
[17:36:41.197]    + additional globals found: [n=0] 
[17:36:41.197]    + additional namespaces needed: [n=0] 
[17:36:41.197]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:41.197]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:41.197]  - seeds: <none>
[17:36:41.197]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.198] getGlobalsAndPackages() ...
[17:36:41.198] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.198] Resolving globals: FALSE
[17:36:41.198] Tweak future expression to call with '...' arguments ...
[17:36:41.198] {
[17:36:41.198]     do.call(function(...) {
[17:36:41.198]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.198]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:41.198]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.198]             on.exit(options(oopts), add = TRUE)
[17:36:41.198]         }
[17:36:41.198]         {
[17:36:41.198]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:41.198]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.198]                 ...future.FUN(...future.X_jj, ...)
[17:36:41.198]             })
[17:36:41.198]         }
[17:36:41.198]     }, args = future.call.arguments)
[17:36:41.198] }
[17:36:41.199] Tweak future expression to call with '...' arguments ... DONE
[17:36:41.200] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.200] 
[17:36:41.200] getGlobalsAndPackages() ... DONE
[17:36:41.200] run() for ‘Future’ ...
[17:36:41.201] - state: ‘created’
[17:36:41.201] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:36:41.206] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:41.206] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:36:41.206]   - Field: ‘label’
[17:36:41.206]   - Field: ‘local’
[17:36:41.206]   - Field: ‘owner’
[17:36:41.206]   - Field: ‘envir’
[17:36:41.207]   - Field: ‘workers’
[17:36:41.207]   - Field: ‘packages’
[17:36:41.207]   - Field: ‘gc’
[17:36:41.207]   - Field: ‘job’
[17:36:41.207]   - Field: ‘conditions’
[17:36:41.207]   - Field: ‘expr’
[17:36:41.207]   - Field: ‘uuid’
[17:36:41.207]   - Field: ‘seed’
[17:36:41.208]   - Field: ‘version’
[17:36:41.208]   - Field: ‘result’
[17:36:41.208]   - Field: ‘asynchronous’
[17:36:41.208]   - Field: ‘calls’
[17:36:41.208]   - Field: ‘globals’
[17:36:41.208]   - Field: ‘stdout’
[17:36:41.208]   - Field: ‘earlySignal’
[17:36:41.208]   - Field: ‘lazy’
[17:36:41.209]   - Field: ‘state’
[17:36:41.209] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:36:41.209] - Launch lazy future ...
[17:36:41.209] Packages needed by the future expression (n = 0): <none>
[17:36:41.209] Packages needed by future strategies (n = 0): <none>
[17:36:41.210] {
[17:36:41.210]     {
[17:36:41.210]         {
[17:36:41.210]             ...future.startTime <- base::Sys.time()
[17:36:41.210]             {
[17:36:41.210]                 {
[17:36:41.210]                   {
[17:36:41.210]                     {
[17:36:41.210]                       base::local({
[17:36:41.210]                         has_future <- base::requireNamespace("future", 
[17:36:41.210]                           quietly = TRUE)
[17:36:41.210]                         if (has_future) {
[17:36:41.210]                           ns <- base::getNamespace("future")
[17:36:41.210]                           version <- ns[[".package"]][["version"]]
[17:36:41.210]                           if (is.null(version)) 
[17:36:41.210]                             version <- utils::packageVersion("future")
[17:36:41.210]                         }
[17:36:41.210]                         else {
[17:36:41.210]                           version <- NULL
[17:36:41.210]                         }
[17:36:41.210]                         if (!has_future || version < "1.8.0") {
[17:36:41.210]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:41.210]                             "", base::R.version$version.string), 
[17:36:41.210]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:41.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:41.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:41.210]                               "release", "version")], collapse = " "), 
[17:36:41.210]                             hostname = base::Sys.info()[["nodename"]])
[17:36:41.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:41.210]                             info)
[17:36:41.210]                           info <- base::paste(info, collapse = "; ")
[17:36:41.210]                           if (!has_future) {
[17:36:41.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:41.210]                               info)
[17:36:41.210]                           }
[17:36:41.210]                           else {
[17:36:41.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:41.210]                               info, version)
[17:36:41.210]                           }
[17:36:41.210]                           base::stop(msg)
[17:36:41.210]                         }
[17:36:41.210]                       })
[17:36:41.210]                     }
[17:36:41.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:41.210]                     base::options(mc.cores = 1L)
[17:36:41.210]                   }
[17:36:41.210]                   ...future.strategy.old <- future::plan("list")
[17:36:41.210]                   options(future.plan = NULL)
[17:36:41.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:41.210]                 }
[17:36:41.210]                 ...future.workdir <- getwd()
[17:36:41.210]             }
[17:36:41.210]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:41.210]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:41.210]         }
[17:36:41.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:41.210]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:41.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:41.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:41.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:41.210]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:41.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:41.210]             base::names(...future.oldOptions))
[17:36:41.210]     }
[17:36:41.210]     if (FALSE) {
[17:36:41.210]     }
[17:36:41.210]     else {
[17:36:41.210]         if (TRUE) {
[17:36:41.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:41.210]                 open = "w")
[17:36:41.210]         }
[17:36:41.210]         else {
[17:36:41.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:41.210]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:41.210]         }
[17:36:41.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:41.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:41.210]             base::sink(type = "output", split = FALSE)
[17:36:41.210]             base::close(...future.stdout)
[17:36:41.210]         }, add = TRUE)
[17:36:41.210]     }
[17:36:41.210]     ...future.frame <- base::sys.nframe()
[17:36:41.210]     ...future.conditions <- base::list()
[17:36:41.210]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:41.210]     if (FALSE) {
[17:36:41.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:41.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:41.210]     }
[17:36:41.210]     ...future.result <- base::tryCatch({
[17:36:41.210]         base::withCallingHandlers({
[17:36:41.210]             ...future.value <- base::withVisible(base::local({
[17:36:41.210]                 withCallingHandlers({
[17:36:41.210]                   {
[17:36:41.210]                     do.call(function(...) {
[17:36:41.210]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.210]                       if (!identical(...future.globals.maxSize.org, 
[17:36:41.210]                         ...future.globals.maxSize)) {
[17:36:41.210]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.210]                         on.exit(options(oopts), add = TRUE)
[17:36:41.210]                       }
[17:36:41.210]                       {
[17:36:41.210]                         lapply(seq_along(...future.elements_ii), 
[17:36:41.210]                           FUN = function(jj) {
[17:36:41.210]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.210]                             ...future.FUN(...future.X_jj, ...)
[17:36:41.210]                           })
[17:36:41.210]                       }
[17:36:41.210]                     }, args = future.call.arguments)
[17:36:41.210]                   }
[17:36:41.210]                 }, immediateCondition = function(cond) {
[17:36:41.210]                   save_rds <- function (object, pathname, ...) 
[17:36:41.210]                   {
[17:36:41.210]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:36:41.210]                     if (file_test("-f", pathname_tmp)) {
[17:36:41.210]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.210]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:36:41.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.210]                         fi_tmp[["mtime"]])
[17:36:41.210]                     }
[17:36:41.210]                     tryCatch({
[17:36:41.210]                       saveRDS(object, file = pathname_tmp, ...)
[17:36:41.210]                     }, error = function(ex) {
[17:36:41.210]                       msg <- conditionMessage(ex)
[17:36:41.210]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.210]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:36:41.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.210]                         fi_tmp[["mtime"]], msg)
[17:36:41.210]                       ex$message <- msg
[17:36:41.210]                       stop(ex)
[17:36:41.210]                     })
[17:36:41.210]                     stopifnot(file_test("-f", pathname_tmp))
[17:36:41.210]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:36:41.210]                     if (!res || file_test("-f", pathname_tmp)) {
[17:36:41.210]                       fi_tmp <- file.info(pathname_tmp)
[17:36:41.210]                       fi <- file.info(pathname)
[17:36:41.210]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:36:41.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:36:41.210]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:36:41.210]                         fi[["size"]], fi[["mtime"]])
[17:36:41.210]                       stop(msg)
[17:36:41.210]                     }
[17:36:41.210]                     invisible(pathname)
[17:36:41.210]                   }
[17:36:41.210]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:36:41.210]                     rootPath = tempdir()) 
[17:36:41.210]                   {
[17:36:41.210]                     obj <- list(time = Sys.time(), condition = cond)
[17:36:41.210]                     file <- tempfile(pattern = class(cond)[1], 
[17:36:41.210]                       tmpdir = path, fileext = ".rds")
[17:36:41.210]                     save_rds(obj, file)
[17:36:41.210]                   }
[17:36:41.210]                   saveImmediateCondition(cond, path = "/tmp/RtmptHCFr5/.future/immediateConditions")
[17:36:41.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.210]                   {
[17:36:41.210]                     inherits <- base::inherits
[17:36:41.210]                     invokeRestart <- base::invokeRestart
[17:36:41.210]                     is.null <- base::is.null
[17:36:41.210]                     muffled <- FALSE
[17:36:41.210]                     if (inherits(cond, "message")) {
[17:36:41.210]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:41.210]                       if (muffled) 
[17:36:41.210]                         invokeRestart("muffleMessage")
[17:36:41.210]                     }
[17:36:41.210]                     else if (inherits(cond, "warning")) {
[17:36:41.210]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:41.210]                       if (muffled) 
[17:36:41.210]                         invokeRestart("muffleWarning")
[17:36:41.210]                     }
[17:36:41.210]                     else if (inherits(cond, "condition")) {
[17:36:41.210]                       if (!is.null(pattern)) {
[17:36:41.210]                         computeRestarts <- base::computeRestarts
[17:36:41.210]                         grepl <- base::grepl
[17:36:41.210]                         restarts <- computeRestarts(cond)
[17:36:41.210]                         for (restart in restarts) {
[17:36:41.210]                           name <- restart$name
[17:36:41.210]                           if (is.null(name)) 
[17:36:41.210]                             next
[17:36:41.210]                           if (!grepl(pattern, name)) 
[17:36:41.210]                             next
[17:36:41.210]                           invokeRestart(restart)
[17:36:41.210]                           muffled <- TRUE
[17:36:41.210]                           break
[17:36:41.210]                         }
[17:36:41.210]                       }
[17:36:41.210]                     }
[17:36:41.210]                     invisible(muffled)
[17:36:41.210]                   }
[17:36:41.210]                   muffleCondition(cond)
[17:36:41.210]                 })
[17:36:41.210]             }))
[17:36:41.210]             future::FutureResult(value = ...future.value$value, 
[17:36:41.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.210]                   ...future.rng), globalenv = if (FALSE) 
[17:36:41.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:41.210]                     ...future.globalenv.names))
[17:36:41.210]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:41.210]         }, condition = base::local({
[17:36:41.210]             c <- base::c
[17:36:41.210]             inherits <- base::inherits
[17:36:41.210]             invokeRestart <- base::invokeRestart
[17:36:41.210]             length <- base::length
[17:36:41.210]             list <- base::list
[17:36:41.210]             seq.int <- base::seq.int
[17:36:41.210]             signalCondition <- base::signalCondition
[17:36:41.210]             sys.calls <- base::sys.calls
[17:36:41.210]             `[[` <- base::`[[`
[17:36:41.210]             `+` <- base::`+`
[17:36:41.210]             `<<-` <- base::`<<-`
[17:36:41.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:41.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:41.210]                   3L)]
[17:36:41.210]             }
[17:36:41.210]             function(cond) {
[17:36:41.210]                 is_error <- inherits(cond, "error")
[17:36:41.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:41.210]                   NULL)
[17:36:41.210]                 if (is_error) {
[17:36:41.210]                   sessionInformation <- function() {
[17:36:41.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:41.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:41.210]                       search = base::search(), system = base::Sys.info())
[17:36:41.210]                   }
[17:36:41.210]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:41.210]                     cond$call), session = sessionInformation(), 
[17:36:41.210]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:41.210]                   signalCondition(cond)
[17:36:41.210]                 }
[17:36:41.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:41.210]                 "immediateCondition"))) {
[17:36:41.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:41.210]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:41.210]                   if (TRUE && !signal) {
[17:36:41.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.210]                     {
[17:36:41.210]                       inherits <- base::inherits
[17:36:41.210]                       invokeRestart <- base::invokeRestart
[17:36:41.210]                       is.null <- base::is.null
[17:36:41.210]                       muffled <- FALSE
[17:36:41.210]                       if (inherits(cond, "message")) {
[17:36:41.210]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.210]                         if (muffled) 
[17:36:41.210]                           invokeRestart("muffleMessage")
[17:36:41.210]                       }
[17:36:41.210]                       else if (inherits(cond, "warning")) {
[17:36:41.210]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.210]                         if (muffled) 
[17:36:41.210]                           invokeRestart("muffleWarning")
[17:36:41.210]                       }
[17:36:41.210]                       else if (inherits(cond, "condition")) {
[17:36:41.210]                         if (!is.null(pattern)) {
[17:36:41.210]                           computeRestarts <- base::computeRestarts
[17:36:41.210]                           grepl <- base::grepl
[17:36:41.210]                           restarts <- computeRestarts(cond)
[17:36:41.210]                           for (restart in restarts) {
[17:36:41.210]                             name <- restart$name
[17:36:41.210]                             if (is.null(name)) 
[17:36:41.210]                               next
[17:36:41.210]                             if (!grepl(pattern, name)) 
[17:36:41.210]                               next
[17:36:41.210]                             invokeRestart(restart)
[17:36:41.210]                             muffled <- TRUE
[17:36:41.210]                             break
[17:36:41.210]                           }
[17:36:41.210]                         }
[17:36:41.210]                       }
[17:36:41.210]                       invisible(muffled)
[17:36:41.210]                     }
[17:36:41.210]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.210]                   }
[17:36:41.210]                 }
[17:36:41.210]                 else {
[17:36:41.210]                   if (TRUE) {
[17:36:41.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.210]                     {
[17:36:41.210]                       inherits <- base::inherits
[17:36:41.210]                       invokeRestart <- base::invokeRestart
[17:36:41.210]                       is.null <- base::is.null
[17:36:41.210]                       muffled <- FALSE
[17:36:41.210]                       if (inherits(cond, "message")) {
[17:36:41.210]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.210]                         if (muffled) 
[17:36:41.210]                           invokeRestart("muffleMessage")
[17:36:41.210]                       }
[17:36:41.210]                       else if (inherits(cond, "warning")) {
[17:36:41.210]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.210]                         if (muffled) 
[17:36:41.210]                           invokeRestart("muffleWarning")
[17:36:41.210]                       }
[17:36:41.210]                       else if (inherits(cond, "condition")) {
[17:36:41.210]                         if (!is.null(pattern)) {
[17:36:41.210]                           computeRestarts <- base::computeRestarts
[17:36:41.210]                           grepl <- base::grepl
[17:36:41.210]                           restarts <- computeRestarts(cond)
[17:36:41.210]                           for (restart in restarts) {
[17:36:41.210]                             name <- restart$name
[17:36:41.210]                             if (is.null(name)) 
[17:36:41.210]                               next
[17:36:41.210]                             if (!grepl(pattern, name)) 
[17:36:41.210]                               next
[17:36:41.210]                             invokeRestart(restart)
[17:36:41.210]                             muffled <- TRUE
[17:36:41.210]                             break
[17:36:41.210]                           }
[17:36:41.210]                         }
[17:36:41.210]                       }
[17:36:41.210]                       invisible(muffled)
[17:36:41.210]                     }
[17:36:41.210]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.210]                   }
[17:36:41.210]                 }
[17:36:41.210]             }
[17:36:41.210]         }))
[17:36:41.210]     }, error = function(ex) {
[17:36:41.210]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:41.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.210]                 ...future.rng), started = ...future.startTime, 
[17:36:41.210]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:41.210]             version = "1.8"), class = "FutureResult")
[17:36:41.210]     }, finally = {
[17:36:41.210]         if (!identical(...future.workdir, getwd())) 
[17:36:41.210]             setwd(...future.workdir)
[17:36:41.210]         {
[17:36:41.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:41.210]                 ...future.oldOptions$nwarnings <- NULL
[17:36:41.210]             }
[17:36:41.210]             base::options(...future.oldOptions)
[17:36:41.210]             if (.Platform$OS.type == "windows") {
[17:36:41.210]                 old_names <- names(...future.oldEnvVars)
[17:36:41.210]                 envs <- base::Sys.getenv()
[17:36:41.210]                 names <- names(envs)
[17:36:41.210]                 common <- intersect(names, old_names)
[17:36:41.210]                 added <- setdiff(names, old_names)
[17:36:41.210]                 removed <- setdiff(old_names, names)
[17:36:41.210]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:41.210]                   envs[common]]
[17:36:41.210]                 NAMES <- toupper(changed)
[17:36:41.210]                 args <- list()
[17:36:41.210]                 for (kk in seq_along(NAMES)) {
[17:36:41.210]                   name <- changed[[kk]]
[17:36:41.210]                   NAME <- NAMES[[kk]]
[17:36:41.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.210]                     next
[17:36:41.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.210]                 }
[17:36:41.210]                 NAMES <- toupper(added)
[17:36:41.210]                 for (kk in seq_along(NAMES)) {
[17:36:41.210]                   name <- added[[kk]]
[17:36:41.210]                   NAME <- NAMES[[kk]]
[17:36:41.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.210]                     next
[17:36:41.210]                   args[[name]] <- ""
[17:36:41.210]                 }
[17:36:41.210]                 NAMES <- toupper(removed)
[17:36:41.210]                 for (kk in seq_along(NAMES)) {
[17:36:41.210]                   name <- removed[[kk]]
[17:36:41.210]                   NAME <- NAMES[[kk]]
[17:36:41.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.210]                     next
[17:36:41.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.210]                 }
[17:36:41.210]                 if (length(args) > 0) 
[17:36:41.210]                   base::do.call(base::Sys.setenv, args = args)
[17:36:41.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:41.210]             }
[17:36:41.210]             else {
[17:36:41.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:41.210]             }
[17:36:41.210]             {
[17:36:41.210]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:41.210]                   0L) {
[17:36:41.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:41.210]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:41.210]                   base::options(opts)
[17:36:41.210]                 }
[17:36:41.210]                 {
[17:36:41.210]                   {
[17:36:41.210]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:41.210]                     NULL
[17:36:41.210]                   }
[17:36:41.210]                   options(future.plan = NULL)
[17:36:41.210]                   if (is.na(NA_character_)) 
[17:36:41.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:41.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:41.210]                     .init = FALSE)
[17:36:41.210]                 }
[17:36:41.210]             }
[17:36:41.210]         }
[17:36:41.210]     })
[17:36:41.210]     if (TRUE) {
[17:36:41.210]         base::sink(type = "output", split = FALSE)
[17:36:41.210]         if (TRUE) {
[17:36:41.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:41.210]         }
[17:36:41.210]         else {
[17:36:41.210]             ...future.result["stdout"] <- base::list(NULL)
[17:36:41.210]         }
[17:36:41.210]         base::close(...future.stdout)
[17:36:41.210]         ...future.stdout <- NULL
[17:36:41.210]     }
[17:36:41.210]     ...future.result$conditions <- ...future.conditions
[17:36:41.210]     ...future.result$finished <- base::Sys.time()
[17:36:41.210]     ...future.result
[17:36:41.210] }
[17:36:41.213] assign_globals() ...
[17:36:41.213] List of 5
[17:36:41.213]  $ ...future.FUN            :function (object, ...)  
[17:36:41.213]  $ future.call.arguments    : list()
[17:36:41.213]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:41.213]  $ ...future.elements_ii    :List of 2
[17:36:41.213]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:41.213]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:36:41.213]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:41.213]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:36:41.213]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:36:41.213]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:36:41.213]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:36:41.213]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:36:41.213]  $ ...future.seeds_ii       : NULL
[17:36:41.213]  $ ...future.globals.maxSize: NULL
[17:36:41.213]  - attr(*, "where")=List of 5
[17:36:41.213]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:36:41.213]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:36:41.213]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:36:41.213]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:36:41.213]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:36:41.213]  - attr(*, "resolved")= logi FALSE
[17:36:41.213]  - attr(*, "total_size")= num 1240
[17:36:41.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:41.213]  - attr(*, "already-done")= logi TRUE
[17:36:41.225] - copied ‘...future.FUN’ to environment
[17:36:41.225] - copied ‘future.call.arguments’ to environment
[17:36:41.226] - copied ‘...future.elements_ii’ to environment
[17:36:41.226] - copied ‘...future.seeds_ii’ to environment
[17:36:41.226] - copied ‘...future.globals.maxSize’ to environment
[17:36:41.226] assign_globals() ... done
[17:36:41.226] requestCore(): workers = 2
[17:36:41.229] MulticoreFuture started
[17:36:41.230] - Launch lazy future ... done
[17:36:41.230] plan(): Setting new future strategy stack:
[17:36:41.230] run() for ‘MulticoreFuture’ ... done
[17:36:41.231] Created future:
[17:36:41.230] List of future strategies:
[17:36:41.230] 1. sequential:
[17:36:41.230]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:41.230]    - tweaked: FALSE
[17:36:41.230]    - call: NULL
[17:36:41.232] plan(): nbrOfWorkers() = 1
[17:36:41.238] plan(): Setting new future strategy stack:
[17:36:41.238] List of future strategies:
[17:36:41.238] 1. multicore:
[17:36:41.238]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:36:41.238]    - tweaked: FALSE
[17:36:41.238]    - call: plan(strategy)
[17:36:41.243] plan(): nbrOfWorkers() = 2
[17:36:41.231] MulticoreFuture:
[17:36:41.231] Label: ‘future_by-2’
[17:36:41.231] Expression:
[17:36:41.231] {
[17:36:41.231]     do.call(function(...) {
[17:36:41.231]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.231]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:41.231]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.231]             on.exit(options(oopts), add = TRUE)
[17:36:41.231]         }
[17:36:41.231]         {
[17:36:41.231]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:41.231]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.231]                 ...future.FUN(...future.X_jj, ...)
[17:36:41.231]             })
[17:36:41.231]         }
[17:36:41.231]     }, args = future.call.arguments)
[17:36:41.231] }
[17:36:41.231] Lazy evaluation: FALSE
[17:36:41.231] Asynchronous evaluation: TRUE
[17:36:41.231] Local evaluation: TRUE
[17:36:41.231] Environment: 0x5622fa0156a8
[17:36:41.231] Capture standard output: TRUE
[17:36:41.231] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:41.231] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:41.231] Packages: <none>
[17:36:41.231] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:41.231] Resolved: TRUE
[17:36:41.231] Value: <not collected>
[17:36:41.231] Conditions captured: <none>
[17:36:41.231] Early signaling: FALSE
[17:36:41.231] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:41.231] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:41.245] Chunk #2 of 2 ... DONE
[17:36:41.245] Launching 2 futures (chunks) ... DONE
[17:36:41.245] Resolving 2 futures (chunks) ...
[17:36:41.245] resolve() on list ...
[17:36:41.246]  recursive: 0
[17:36:41.246]  length: 2
[17:36:41.246] 
[17:36:41.246] Future #1
[17:36:41.247] result() for MulticoreFuture ...
[17:36:41.247] result() for MulticoreFuture ...
[17:36:41.247] result() for MulticoreFuture ... done
[17:36:41.248] result() for MulticoreFuture ... done
[17:36:41.248] result() for MulticoreFuture ...
[17:36:41.248] result() for MulticoreFuture ... done
[17:36:41.248] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:36:41.248] - nx: 2
[17:36:41.248] - relay: TRUE
[17:36:41.249] - stdout: TRUE
[17:36:41.249] - signal: TRUE
[17:36:41.249] - resignal: FALSE
[17:36:41.249] - force: TRUE
[17:36:41.249] - relayed: [n=2] FALSE, FALSE
[17:36:41.249] - queued futures: [n=2] FALSE, FALSE
[17:36:41.249]  - until=1
[17:36:41.250]  - relaying element #1
[17:36:41.250] result() for MulticoreFuture ...
[17:36:41.250] result() for MulticoreFuture ... done
[17:36:41.250] result() for MulticoreFuture ...
[17:36:41.250] result() for MulticoreFuture ... done
[17:36:41.250] result() for MulticoreFuture ...
[17:36:41.251] result() for MulticoreFuture ... done
[17:36:41.251] result() for MulticoreFuture ...
[17:36:41.251] result() for MulticoreFuture ... done
[17:36:41.251] - relayed: [n=2] TRUE, FALSE
[17:36:41.251] - queued futures: [n=2] TRUE, FALSE
[17:36:41.251] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:36:41.252]  length: 1 (resolved future 1)
[17:36:41.252] Future #2
[17:36:41.252] result() for MulticoreFuture ...
[17:36:41.253] result() for MulticoreFuture ...
[17:36:41.253] result() for MulticoreFuture ... done
[17:36:41.253] result() for MulticoreFuture ... done
[17:36:41.253] result() for MulticoreFuture ...
[17:36:41.253] result() for MulticoreFuture ... done
[17:36:41.254] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:36:41.254] - nx: 2
[17:36:41.254] - relay: TRUE
[17:36:41.254] - stdout: TRUE
[17:36:41.254] - signal: TRUE
[17:36:41.254] - resignal: FALSE
[17:36:41.254] - force: TRUE
[17:36:41.254] - relayed: [n=2] TRUE, FALSE
[17:36:41.254] - queued futures: [n=2] TRUE, FALSE
[17:36:41.254]  - until=2
[17:36:41.255]  - relaying element #2
[17:36:41.255] result() for MulticoreFuture ...
[17:36:41.255] result() for MulticoreFuture ... done
[17:36:41.255] result() for MulticoreFuture ...
[17:36:41.255] result() for MulticoreFuture ... done
[17:36:41.255] result() for MulticoreFuture ...
[17:36:41.255] result() for MulticoreFuture ... done
[17:36:41.255] result() for MulticoreFuture ...
[17:36:41.256] result() for MulticoreFuture ... done
[17:36:41.256] - relayed: [n=2] TRUE, TRUE
[17:36:41.256] - queued futures: [n=2] TRUE, TRUE
[17:36:41.256] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:36:41.256]  length: 0 (resolved future 2)
[17:36:41.256] Relaying remaining futures
[17:36:41.256] signalConditionsASAP(NULL, pos=0) ...
[17:36:41.256] - nx: 2
[17:36:41.257] - relay: TRUE
[17:36:41.257] - stdout: TRUE
[17:36:41.257] - signal: TRUE
[17:36:41.257] - resignal: FALSE
[17:36:41.257] - force: TRUE
[17:36:41.257] - relayed: [n=2] TRUE, TRUE
[17:36:41.257] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:41.257] - relayed: [n=2] TRUE, TRUE
[17:36:41.257] - queued futures: [n=2] TRUE, TRUE
[17:36:41.257] signalConditionsASAP(NULL, pos=0) ... done
[17:36:41.258] resolve() on list ... DONE
[17:36:41.258] result() for MulticoreFuture ...
[17:36:41.258] result() for MulticoreFuture ... done
[17:36:41.258] result() for MulticoreFuture ...
[17:36:41.258] result() for MulticoreFuture ... done
[17:36:41.258] result() for MulticoreFuture ...
[17:36:41.258] result() for MulticoreFuture ... done
[17:36:41.258] result() for MulticoreFuture ...
[17:36:41.258] result() for MulticoreFuture ... done
[17:36:41.259]  - Number of value chunks collected: 2
[17:36:41.259] Resolving 2 futures (chunks) ... DONE
[17:36:41.259] Reducing values from 2 chunks ...
[17:36:41.259]  - Number of values collected after concatenation: 3
[17:36:41.259]  - Number of values expected: 3
[17:36:41.259] Reducing values from 2 chunks ... DONE
[17:36:41.259] future_lapply() ... DONE
[17:36:41.259] future_by_internal() ... DONE
[17:36:41.260] future_by_internal() ...
- plan('multisession') ...
[17:36:41.261] plan(): Setting new future strategy stack:
[17:36:41.261] List of future strategies:
[17:36:41.261] 1. multisession:
[17:36:41.261]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:41.261]    - tweaked: FALSE
[17:36:41.261]    - call: plan(strategy)
[17:36:41.262] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:36:41.262] multisession:
[17:36:41.262] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:36:41.262] - tweaked: FALSE
[17:36:41.262] - call: plan(strategy)
[17:36:41.274] getGlobalsAndPackages() ...
[17:36:41.274] Not searching for globals
[17:36:41.274] - globals: [0] <none>
[17:36:41.274] getGlobalsAndPackages() ... DONE
[17:36:41.275] [local output] makeClusterPSOCK() ...
[17:36:41.326] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:36:41.328] [local output] Base port: 11979
[17:36:41.328] [local output] Getting setup options for 2 cluster nodes ...
[17:36:41.328] [local output]  - Node 1 of 2 ...
[17:36:41.328] [local output] localMachine=TRUE => revtunnel=FALSE

[17:36:41.329] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmptHCFr5/worker.rank=1.parallelly.parent=28744.704838c6a219.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmptHCFr5/worker.rank=1.parallelly.parent=28744.704838c6a219.pid")'’
[17:36:41.518] - Possible to infer worker's PID: TRUE
[17:36:41.519] [local output] Rscript port: 11979

[17:36:41.519] [local output]  - Node 2 of 2 ...
[17:36:41.519] [local output] localMachine=TRUE => revtunnel=FALSE

[17:36:41.520] [local output] Rscript port: 11979

[17:36:41.520] [local output] Getting setup options for 2 cluster nodes ... done
[17:36:41.521] [local output]  - Parallel setup requested for some PSOCK nodes
[17:36:41.521] [local output] Setting up PSOCK nodes in parallel
[17:36:41.521] List of 36
[17:36:41.521]  $ worker          : chr "localhost"
[17:36:41.521]   ..- attr(*, "localhost")= logi TRUE
[17:36:41.521]  $ master          : chr "localhost"
[17:36:41.521]  $ port            : int 11979
[17:36:41.521]  $ connectTimeout  : num 120
[17:36:41.521]  $ timeout         : num 2592000
[17:36:41.521]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:36:41.521]  $ homogeneous     : logi TRUE
[17:36:41.521]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:36:41.521]  $ rscript_envs    : NULL
[17:36:41.521]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:36:41.521]  $ rscript_startup : NULL
[17:36:41.521]  $ rscript_sh      : chr "sh"
[17:36:41.521]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:36:41.521]  $ methods         : logi TRUE
[17:36:41.521]  $ socketOptions   : chr "no-delay"
[17:36:41.521]  $ useXDR          : logi FALSE
[17:36:41.521]  $ outfile         : chr "/dev/null"
[17:36:41.521]  $ renice          : int NA
[17:36:41.521]  $ rshcmd          : NULL
[17:36:41.521]  $ user            : chr(0) 
[17:36:41.521]  $ revtunnel       : logi FALSE
[17:36:41.521]  $ rshlogfile      : NULL
[17:36:41.521]  $ rshopts         : chr(0) 
[17:36:41.521]  $ rank            : int 1
[17:36:41.521]  $ manual          : logi FALSE
[17:36:41.521]  $ dryrun          : logi FALSE
[17:36:41.521]  $ quiet           : logi FALSE
[17:36:41.521]  $ setup_strategy  : chr "parallel"
[17:36:41.521]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:36:41.521]  $ pidfile         : chr "/tmp/RtmptHCFr5/worker.rank=1.parallelly.parent=28744.704838c6a219.pid"
[17:36:41.521]  $ rshcmd_label    : NULL
[17:36:41.521]  $ rsh_call        : NULL
[17:36:41.521]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:36:41.521]  $ localMachine    : logi TRUE
[17:36:41.521]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:36:41.521]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:36:41.521]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:36:41.521]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:36:41.521]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:36:41.521]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:36:41.521]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:36:41.521]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:36:41.521]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:36:41.521]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:36:41.521]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:36:41.521]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:36:41.521]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:36:41.521]  $ arguments       :List of 28
[17:36:41.521]   ..$ worker          : chr "localhost"
[17:36:41.521]   ..$ master          : NULL
[17:36:41.521]   ..$ port            : int 11979
[17:36:41.521]   ..$ connectTimeout  : num 120
[17:36:41.521]   ..$ timeout         : num 2592000
[17:36:41.521]   ..$ rscript         : NULL
[17:36:41.521]   ..$ homogeneous     : NULL
[17:36:41.521]   ..$ rscript_args    : NULL
[17:36:41.521]   ..$ rscript_envs    : NULL
[17:36:41.521]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:36:41.521]   ..$ rscript_startup : NULL
[17:36:41.521]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:36:41.521]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:36:41.521]   ..$ methods         : logi TRUE
[17:36:41.521]   ..$ socketOptions   : chr "no-delay"
[17:36:41.521]   ..$ useXDR          : logi FALSE
[17:36:41.521]   ..$ outfile         : chr "/dev/null"
[17:36:41.521]   ..$ renice          : int NA
[17:36:41.521]   ..$ rshcmd          : NULL
[17:36:41.521]   ..$ user            : NULL
[17:36:41.521]   ..$ revtunnel       : logi NA
[17:36:41.521]   ..$ rshlogfile      : NULL
[17:36:41.521]   ..$ rshopts         : NULL
[17:36:41.521]   ..$ rank            : int 1
[17:36:41.521]   ..$ manual          : logi FALSE
[17:36:41.521]   ..$ dryrun          : logi FALSE
[17:36:41.521]   ..$ quiet           : logi FALSE
[17:36:41.521]   ..$ setup_strategy  : chr "parallel"
[17:36:41.521]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:36:41.538] [local output] System call to launch all workers:
[17:36:41.538] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmptHCFr5/worker.rank=1.parallelly.parent=28744.704838c6a219.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11979 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:36:41.538] [local output] Starting PSOCK main server
[17:36:41.544] [local output] Workers launched
[17:36:41.544] [local output] Waiting for workers to connect back
[17:36:41.544]  - [local output] 0 workers out of 2 ready
[17:36:41.794]  - [local output] 0 workers out of 2 ready
[17:36:41.794]  - [local output] 1 workers out of 2 ready
[17:36:41.796]  - [local output] 1 workers out of 2 ready
[17:36:41.797]  - [local output] 2 workers out of 2 ready
[17:36:41.797] [local output] Launching of workers completed
[17:36:41.797] [local output] Collecting session information from workers
[17:36:41.798] [local output]  - Worker #1 of 2
[17:36:41.798] [local output]  - Worker #2 of 2
[17:36:41.798] [local output] makeClusterPSOCK() ... done
[17:36:41.810] Packages needed by the future expression (n = 0): <none>
[17:36:41.810] Packages needed by future strategies (n = 0): <none>
[17:36:41.811] {
[17:36:41.811]     {
[17:36:41.811]         {
[17:36:41.811]             ...future.startTime <- base::Sys.time()
[17:36:41.811]             {
[17:36:41.811]                 {
[17:36:41.811]                   {
[17:36:41.811]                     {
[17:36:41.811]                       base::local({
[17:36:41.811]                         has_future <- base::requireNamespace("future", 
[17:36:41.811]                           quietly = TRUE)
[17:36:41.811]                         if (has_future) {
[17:36:41.811]                           ns <- base::getNamespace("future")
[17:36:41.811]                           version <- ns[[".package"]][["version"]]
[17:36:41.811]                           if (is.null(version)) 
[17:36:41.811]                             version <- utils::packageVersion("future")
[17:36:41.811]                         }
[17:36:41.811]                         else {
[17:36:41.811]                           version <- NULL
[17:36:41.811]                         }
[17:36:41.811]                         if (!has_future || version < "1.8.0") {
[17:36:41.811]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:41.811]                             "", base::R.version$version.string), 
[17:36:41.811]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:41.811]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:41.811]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:41.811]                               "release", "version")], collapse = " "), 
[17:36:41.811]                             hostname = base::Sys.info()[["nodename"]])
[17:36:41.811]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:41.811]                             info)
[17:36:41.811]                           info <- base::paste(info, collapse = "; ")
[17:36:41.811]                           if (!has_future) {
[17:36:41.811]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:41.811]                               info)
[17:36:41.811]                           }
[17:36:41.811]                           else {
[17:36:41.811]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:41.811]                               info, version)
[17:36:41.811]                           }
[17:36:41.811]                           base::stop(msg)
[17:36:41.811]                         }
[17:36:41.811]                       })
[17:36:41.811]                     }
[17:36:41.811]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:41.811]                     base::options(mc.cores = 1L)
[17:36:41.811]                   }
[17:36:41.811]                   ...future.strategy.old <- future::plan("list")
[17:36:41.811]                   options(future.plan = NULL)
[17:36:41.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:41.811]                 }
[17:36:41.811]                 ...future.workdir <- getwd()
[17:36:41.811]             }
[17:36:41.811]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:41.811]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:41.811]         }
[17:36:41.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:41.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:36:41.811]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:41.811]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:41.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:41.811]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:41.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:41.811]             base::names(...future.oldOptions))
[17:36:41.811]     }
[17:36:41.811]     if (FALSE) {
[17:36:41.811]     }
[17:36:41.811]     else {
[17:36:41.811]         if (TRUE) {
[17:36:41.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:41.811]                 open = "w")
[17:36:41.811]         }
[17:36:41.811]         else {
[17:36:41.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:41.811]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:41.811]         }
[17:36:41.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:41.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:41.811]             base::sink(type = "output", split = FALSE)
[17:36:41.811]             base::close(...future.stdout)
[17:36:41.811]         }, add = TRUE)
[17:36:41.811]     }
[17:36:41.811]     ...future.frame <- base::sys.nframe()
[17:36:41.811]     ...future.conditions <- base::list()
[17:36:41.811]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:41.811]     if (FALSE) {
[17:36:41.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:41.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:41.811]     }
[17:36:41.811]     ...future.result <- base::tryCatch({
[17:36:41.811]         base::withCallingHandlers({
[17:36:41.811]             ...future.value <- base::withVisible(base::local({
[17:36:41.811]                 ...future.makeSendCondition <- base::local({
[17:36:41.811]                   sendCondition <- NULL
[17:36:41.811]                   function(frame = 1L) {
[17:36:41.811]                     if (is.function(sendCondition)) 
[17:36:41.811]                       return(sendCondition)
[17:36:41.811]                     ns <- getNamespace("parallel")
[17:36:41.811]                     if (exists("sendData", mode = "function", 
[17:36:41.811]                       envir = ns)) {
[17:36:41.811]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:41.811]                         envir = ns)
[17:36:41.811]                       envir <- sys.frame(frame)
[17:36:41.811]                       master <- NULL
[17:36:41.811]                       while (!identical(envir, .GlobalEnv) && 
[17:36:41.811]                         !identical(envir, emptyenv())) {
[17:36:41.811]                         if (exists("master", mode = "list", envir = envir, 
[17:36:41.811]                           inherits = FALSE)) {
[17:36:41.811]                           master <- get("master", mode = "list", 
[17:36:41.811]                             envir = envir, inherits = FALSE)
[17:36:41.811]                           if (inherits(master, c("SOCKnode", 
[17:36:41.811]                             "SOCK0node"))) {
[17:36:41.811]                             sendCondition <<- function(cond) {
[17:36:41.811]                               data <- list(type = "VALUE", value = cond, 
[17:36:41.811]                                 success = TRUE)
[17:36:41.811]                               parallel_sendData(master, data)
[17:36:41.811]                             }
[17:36:41.811]                             return(sendCondition)
[17:36:41.811]                           }
[17:36:41.811]                         }
[17:36:41.811]                         frame <- frame + 1L
[17:36:41.811]                         envir <- sys.frame(frame)
[17:36:41.811]                       }
[17:36:41.811]                     }
[17:36:41.811]                     sendCondition <<- function(cond) NULL
[17:36:41.811]                   }
[17:36:41.811]                 })
[17:36:41.811]                 withCallingHandlers({
[17:36:41.811]                   NA
[17:36:41.811]                 }, immediateCondition = function(cond) {
[17:36:41.811]                   sendCondition <- ...future.makeSendCondition()
[17:36:41.811]                   sendCondition(cond)
[17:36:41.811]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.811]                   {
[17:36:41.811]                     inherits <- base::inherits
[17:36:41.811]                     invokeRestart <- base::invokeRestart
[17:36:41.811]                     is.null <- base::is.null
[17:36:41.811]                     muffled <- FALSE
[17:36:41.811]                     if (inherits(cond, "message")) {
[17:36:41.811]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:41.811]                       if (muffled) 
[17:36:41.811]                         invokeRestart("muffleMessage")
[17:36:41.811]                     }
[17:36:41.811]                     else if (inherits(cond, "warning")) {
[17:36:41.811]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:41.811]                       if (muffled) 
[17:36:41.811]                         invokeRestart("muffleWarning")
[17:36:41.811]                     }
[17:36:41.811]                     else if (inherits(cond, "condition")) {
[17:36:41.811]                       if (!is.null(pattern)) {
[17:36:41.811]                         computeRestarts <- base::computeRestarts
[17:36:41.811]                         grepl <- base::grepl
[17:36:41.811]                         restarts <- computeRestarts(cond)
[17:36:41.811]                         for (restart in restarts) {
[17:36:41.811]                           name <- restart$name
[17:36:41.811]                           if (is.null(name)) 
[17:36:41.811]                             next
[17:36:41.811]                           if (!grepl(pattern, name)) 
[17:36:41.811]                             next
[17:36:41.811]                           invokeRestart(restart)
[17:36:41.811]                           muffled <- TRUE
[17:36:41.811]                           break
[17:36:41.811]                         }
[17:36:41.811]                       }
[17:36:41.811]                     }
[17:36:41.811]                     invisible(muffled)
[17:36:41.811]                   }
[17:36:41.811]                   muffleCondition(cond)
[17:36:41.811]                 })
[17:36:41.811]             }))
[17:36:41.811]             future::FutureResult(value = ...future.value$value, 
[17:36:41.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.811]                   ...future.rng), globalenv = if (FALSE) 
[17:36:41.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:41.811]                     ...future.globalenv.names))
[17:36:41.811]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:41.811]         }, condition = base::local({
[17:36:41.811]             c <- base::c
[17:36:41.811]             inherits <- base::inherits
[17:36:41.811]             invokeRestart <- base::invokeRestart
[17:36:41.811]             length <- base::length
[17:36:41.811]             list <- base::list
[17:36:41.811]             seq.int <- base::seq.int
[17:36:41.811]             signalCondition <- base::signalCondition
[17:36:41.811]             sys.calls <- base::sys.calls
[17:36:41.811]             `[[` <- base::`[[`
[17:36:41.811]             `+` <- base::`+`
[17:36:41.811]             `<<-` <- base::`<<-`
[17:36:41.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:41.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:41.811]                   3L)]
[17:36:41.811]             }
[17:36:41.811]             function(cond) {
[17:36:41.811]                 is_error <- inherits(cond, "error")
[17:36:41.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:41.811]                   NULL)
[17:36:41.811]                 if (is_error) {
[17:36:41.811]                   sessionInformation <- function() {
[17:36:41.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:41.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:41.811]                       search = base::search(), system = base::Sys.info())
[17:36:41.811]                   }
[17:36:41.811]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:41.811]                     cond$call), session = sessionInformation(), 
[17:36:41.811]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:41.811]                   signalCondition(cond)
[17:36:41.811]                 }
[17:36:41.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:41.811]                 "immediateCondition"))) {
[17:36:41.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:41.811]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:41.811]                   if (TRUE && !signal) {
[17:36:41.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.811]                     {
[17:36:41.811]                       inherits <- base::inherits
[17:36:41.811]                       invokeRestart <- base::invokeRestart
[17:36:41.811]                       is.null <- base::is.null
[17:36:41.811]                       muffled <- FALSE
[17:36:41.811]                       if (inherits(cond, "message")) {
[17:36:41.811]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.811]                         if (muffled) 
[17:36:41.811]                           invokeRestart("muffleMessage")
[17:36:41.811]                       }
[17:36:41.811]                       else if (inherits(cond, "warning")) {
[17:36:41.811]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.811]                         if (muffled) 
[17:36:41.811]                           invokeRestart("muffleWarning")
[17:36:41.811]                       }
[17:36:41.811]                       else if (inherits(cond, "condition")) {
[17:36:41.811]                         if (!is.null(pattern)) {
[17:36:41.811]                           computeRestarts <- base::computeRestarts
[17:36:41.811]                           grepl <- base::grepl
[17:36:41.811]                           restarts <- computeRestarts(cond)
[17:36:41.811]                           for (restart in restarts) {
[17:36:41.811]                             name <- restart$name
[17:36:41.811]                             if (is.null(name)) 
[17:36:41.811]                               next
[17:36:41.811]                             if (!grepl(pattern, name)) 
[17:36:41.811]                               next
[17:36:41.811]                             invokeRestart(restart)
[17:36:41.811]                             muffled <- TRUE
[17:36:41.811]                             break
[17:36:41.811]                           }
[17:36:41.811]                         }
[17:36:41.811]                       }
[17:36:41.811]                       invisible(muffled)
[17:36:41.811]                     }
[17:36:41.811]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.811]                   }
[17:36:41.811]                 }
[17:36:41.811]                 else {
[17:36:41.811]                   if (TRUE) {
[17:36:41.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.811]                     {
[17:36:41.811]                       inherits <- base::inherits
[17:36:41.811]                       invokeRestart <- base::invokeRestart
[17:36:41.811]                       is.null <- base::is.null
[17:36:41.811]                       muffled <- FALSE
[17:36:41.811]                       if (inherits(cond, "message")) {
[17:36:41.811]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.811]                         if (muffled) 
[17:36:41.811]                           invokeRestart("muffleMessage")
[17:36:41.811]                       }
[17:36:41.811]                       else if (inherits(cond, "warning")) {
[17:36:41.811]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.811]                         if (muffled) 
[17:36:41.811]                           invokeRestart("muffleWarning")
[17:36:41.811]                       }
[17:36:41.811]                       else if (inherits(cond, "condition")) {
[17:36:41.811]                         if (!is.null(pattern)) {
[17:36:41.811]                           computeRestarts <- base::computeRestarts
[17:36:41.811]                           grepl <- base::grepl
[17:36:41.811]                           restarts <- computeRestarts(cond)
[17:36:41.811]                           for (restart in restarts) {
[17:36:41.811]                             name <- restart$name
[17:36:41.811]                             if (is.null(name)) 
[17:36:41.811]                               next
[17:36:41.811]                             if (!grepl(pattern, name)) 
[17:36:41.811]                               next
[17:36:41.811]                             invokeRestart(restart)
[17:36:41.811]                             muffled <- TRUE
[17:36:41.811]                             break
[17:36:41.811]                           }
[17:36:41.811]                         }
[17:36:41.811]                       }
[17:36:41.811]                       invisible(muffled)
[17:36:41.811]                     }
[17:36:41.811]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.811]                   }
[17:36:41.811]                 }
[17:36:41.811]             }
[17:36:41.811]         }))
[17:36:41.811]     }, error = function(ex) {
[17:36:41.811]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:41.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.811]                 ...future.rng), started = ...future.startTime, 
[17:36:41.811]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:41.811]             version = "1.8"), class = "FutureResult")
[17:36:41.811]     }, finally = {
[17:36:41.811]         if (!identical(...future.workdir, getwd())) 
[17:36:41.811]             setwd(...future.workdir)
[17:36:41.811]         {
[17:36:41.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:41.811]                 ...future.oldOptions$nwarnings <- NULL
[17:36:41.811]             }
[17:36:41.811]             base::options(...future.oldOptions)
[17:36:41.811]             if (.Platform$OS.type == "windows") {
[17:36:41.811]                 old_names <- names(...future.oldEnvVars)
[17:36:41.811]                 envs <- base::Sys.getenv()
[17:36:41.811]                 names <- names(envs)
[17:36:41.811]                 common <- intersect(names, old_names)
[17:36:41.811]                 added <- setdiff(names, old_names)
[17:36:41.811]                 removed <- setdiff(old_names, names)
[17:36:41.811]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:41.811]                   envs[common]]
[17:36:41.811]                 NAMES <- toupper(changed)
[17:36:41.811]                 args <- list()
[17:36:41.811]                 for (kk in seq_along(NAMES)) {
[17:36:41.811]                   name <- changed[[kk]]
[17:36:41.811]                   NAME <- NAMES[[kk]]
[17:36:41.811]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.811]                     next
[17:36:41.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.811]                 }
[17:36:41.811]                 NAMES <- toupper(added)
[17:36:41.811]                 for (kk in seq_along(NAMES)) {
[17:36:41.811]                   name <- added[[kk]]
[17:36:41.811]                   NAME <- NAMES[[kk]]
[17:36:41.811]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.811]                     next
[17:36:41.811]                   args[[name]] <- ""
[17:36:41.811]                 }
[17:36:41.811]                 NAMES <- toupper(removed)
[17:36:41.811]                 for (kk in seq_along(NAMES)) {
[17:36:41.811]                   name <- removed[[kk]]
[17:36:41.811]                   NAME <- NAMES[[kk]]
[17:36:41.811]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.811]                     next
[17:36:41.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.811]                 }
[17:36:41.811]                 if (length(args) > 0) 
[17:36:41.811]                   base::do.call(base::Sys.setenv, args = args)
[17:36:41.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:41.811]             }
[17:36:41.811]             else {
[17:36:41.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:41.811]             }
[17:36:41.811]             {
[17:36:41.811]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:41.811]                   0L) {
[17:36:41.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:41.811]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:41.811]                   base::options(opts)
[17:36:41.811]                 }
[17:36:41.811]                 {
[17:36:41.811]                   {
[17:36:41.811]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:41.811]                     NULL
[17:36:41.811]                   }
[17:36:41.811]                   options(future.plan = NULL)
[17:36:41.811]                   if (is.na(NA_character_)) 
[17:36:41.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:41.811]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:41.811]                     .init = FALSE)
[17:36:41.811]                 }
[17:36:41.811]             }
[17:36:41.811]         }
[17:36:41.811]     })
[17:36:41.811]     if (TRUE) {
[17:36:41.811]         base::sink(type = "output", split = FALSE)
[17:36:41.811]         if (TRUE) {
[17:36:41.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:41.811]         }
[17:36:41.811]         else {
[17:36:41.811]             ...future.result["stdout"] <- base::list(NULL)
[17:36:41.811]         }
[17:36:41.811]         base::close(...future.stdout)
[17:36:41.811]         ...future.stdout <- NULL
[17:36:41.811]     }
[17:36:41.811]     ...future.result$conditions <- ...future.conditions
[17:36:41.811]     ...future.result$finished <- base::Sys.time()
[17:36:41.811]     ...future.result
[17:36:41.811] }
[17:36:41.866] MultisessionFuture started
[17:36:41.866] result() for ClusterFuture ...
[17:36:41.867] receiveMessageFromWorker() for ClusterFuture ...
[17:36:41.867] - Validating connection of MultisessionFuture
[17:36:41.898] - received message: FutureResult
[17:36:41.899] - Received FutureResult
[17:36:41.899] - Erased future from FutureRegistry
[17:36:41.899] result() for ClusterFuture ...
[17:36:41.899] - result already collected: FutureResult
[17:36:41.899] result() for ClusterFuture ... done
[17:36:41.899] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:41.900] result() for ClusterFuture ... done
[17:36:41.900] result() for ClusterFuture ...
[17:36:41.900] - result already collected: FutureResult
[17:36:41.900] result() for ClusterFuture ... done
[17:36:41.900] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:36:41.904] plan(): nbrOfWorkers() = 2
[17:36:41.904] future_by_internal() ...
[17:36:41.904] future_lapply() ...
[17:36:41.908] Number of chunks: 2
[17:36:41.909] getGlobalsAndPackagesXApply() ...
[17:36:41.909]  - future.globals: TRUE
[17:36:41.909] getGlobalsAndPackages() ...
[17:36:41.909] Searching for globals...
[17:36:41.910] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:41.910] Searching for globals ... DONE
[17:36:41.911] Resolving globals: FALSE
[17:36:41.911] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:41.911] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:41.912] - globals: [1] ‘FUN’
[17:36:41.912] 
[17:36:41.912] getGlobalsAndPackages() ... DONE
[17:36:41.912]  - globals found/used: [n=1] ‘FUN’
[17:36:41.912]  - needed namespaces: [n=0] 
[17:36:41.912] Finding globals ... DONE
[17:36:41.912]  - use_args: TRUE
[17:36:41.912]  - Getting '...' globals ...
[17:36:41.913] resolve() on list ...
[17:36:41.913]  recursive: 0
[17:36:41.913]  length: 1
[17:36:41.913]  elements: ‘...’
[17:36:41.913]  length: 0 (resolved future 1)
[17:36:41.913] resolve() on list ... DONE
[17:36:41.914]    - '...' content: [n=0] 
[17:36:41.914] List of 1
[17:36:41.914]  $ ...: list()
[17:36:41.914]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:41.914]  - attr(*, "where")=List of 1
[17:36:41.914]   ..$ ...:<environment: 0x5622fd7194e0> 
[17:36:41.914]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:41.914]  - attr(*, "resolved")= logi TRUE
[17:36:41.914]  - attr(*, "total_size")= num NA
[17:36:41.917]  - Getting '...' globals ... DONE
[17:36:41.917] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:41.917] List of 2
[17:36:41.917]  $ ...future.FUN:function (object, ...)  
[17:36:41.917]  $ ...          : list()
[17:36:41.917]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:41.917]  - attr(*, "where")=List of 2
[17:36:41.917]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:41.917]   ..$ ...          :<environment: 0x5622fd7194e0> 
[17:36:41.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:41.917]  - attr(*, "resolved")= logi FALSE
[17:36:41.917]  - attr(*, "total_size")= num 1240
[17:36:41.920] Packages to be attached in all futures: [n=0] 
[17:36:41.920] getGlobalsAndPackagesXApply() ... DONE
[17:36:41.921] Number of futures (= number of chunks): 2
[17:36:41.921] Launching 2 futures (chunks) ...
[17:36:41.921] Chunk #1 of 2 ...
[17:36:41.921]  - Finding globals in 'X' for chunk #1 ...
[17:36:41.921] getGlobalsAndPackages() ...
[17:36:41.921] Searching for globals...
[17:36:41.922] 
[17:36:41.922] Searching for globals ... DONE
[17:36:41.922] - globals: [0] <none>
[17:36:41.922] getGlobalsAndPackages() ... DONE
[17:36:41.922]    + additional globals found: [n=0] 
[17:36:41.922]    + additional namespaces needed: [n=0] 
[17:36:41.922]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:41.923]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:41.923]  - seeds: <none>
[17:36:41.923]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.923] getGlobalsAndPackages() ...
[17:36:41.923] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.923] Resolving globals: FALSE
[17:36:41.923] Tweak future expression to call with '...' arguments ...
[17:36:41.923] {
[17:36:41.923]     do.call(function(...) {
[17:36:41.923]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.923]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:41.923]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.923]             on.exit(options(oopts), add = TRUE)
[17:36:41.923]         }
[17:36:41.923]         {
[17:36:41.923]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:41.923]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.923]                 ...future.FUN(...future.X_jj, ...)
[17:36:41.923]             })
[17:36:41.923]         }
[17:36:41.923]     }, args = future.call.arguments)
[17:36:41.923] }
[17:36:41.924] Tweak future expression to call with '...' arguments ... DONE
[17:36:41.924] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.924] 
[17:36:41.924] getGlobalsAndPackages() ... DONE
[17:36:41.925] run() for ‘Future’ ...
[17:36:41.925] - state: ‘created’
[17:36:41.925] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:41.940] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:41.940] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:41.940]   - Field: ‘node’
[17:36:41.940]   - Field: ‘label’
[17:36:41.940]   - Field: ‘local’
[17:36:41.940]   - Field: ‘owner’
[17:36:41.940]   - Field: ‘envir’
[17:36:41.940]   - Field: ‘workers’
[17:36:41.940]   - Field: ‘packages’
[17:36:41.941]   - Field: ‘gc’
[17:36:41.941]   - Field: ‘conditions’
[17:36:41.941]   - Field: ‘persistent’
[17:36:41.941]   - Field: ‘expr’
[17:36:41.941]   - Field: ‘uuid’
[17:36:41.941]   - Field: ‘seed’
[17:36:41.941]   - Field: ‘version’
[17:36:41.941]   - Field: ‘result’
[17:36:41.941]   - Field: ‘asynchronous’
[17:36:41.942]   - Field: ‘calls’
[17:36:41.942]   - Field: ‘globals’
[17:36:41.942]   - Field: ‘stdout’
[17:36:41.942]   - Field: ‘earlySignal’
[17:36:41.942]   - Field: ‘lazy’
[17:36:41.942]   - Field: ‘state’
[17:36:41.942] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:41.942] - Launch lazy future ...
[17:36:41.943] Packages needed by the future expression (n = 0): <none>
[17:36:41.943] Packages needed by future strategies (n = 0): <none>
[17:36:41.943] {
[17:36:41.943]     {
[17:36:41.943]         {
[17:36:41.943]             ...future.startTime <- base::Sys.time()
[17:36:41.943]             {
[17:36:41.943]                 {
[17:36:41.943]                   {
[17:36:41.943]                     {
[17:36:41.943]                       base::local({
[17:36:41.943]                         has_future <- base::requireNamespace("future", 
[17:36:41.943]                           quietly = TRUE)
[17:36:41.943]                         if (has_future) {
[17:36:41.943]                           ns <- base::getNamespace("future")
[17:36:41.943]                           version <- ns[[".package"]][["version"]]
[17:36:41.943]                           if (is.null(version)) 
[17:36:41.943]                             version <- utils::packageVersion("future")
[17:36:41.943]                         }
[17:36:41.943]                         else {
[17:36:41.943]                           version <- NULL
[17:36:41.943]                         }
[17:36:41.943]                         if (!has_future || version < "1.8.0") {
[17:36:41.943]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:41.943]                             "", base::R.version$version.string), 
[17:36:41.943]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:41.943]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:41.943]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:41.943]                               "release", "version")], collapse = " "), 
[17:36:41.943]                             hostname = base::Sys.info()[["nodename"]])
[17:36:41.943]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:41.943]                             info)
[17:36:41.943]                           info <- base::paste(info, collapse = "; ")
[17:36:41.943]                           if (!has_future) {
[17:36:41.943]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:41.943]                               info)
[17:36:41.943]                           }
[17:36:41.943]                           else {
[17:36:41.943]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:41.943]                               info, version)
[17:36:41.943]                           }
[17:36:41.943]                           base::stop(msg)
[17:36:41.943]                         }
[17:36:41.943]                       })
[17:36:41.943]                     }
[17:36:41.943]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:41.943]                     base::options(mc.cores = 1L)
[17:36:41.943]                   }
[17:36:41.943]                   ...future.strategy.old <- future::plan("list")
[17:36:41.943]                   options(future.plan = NULL)
[17:36:41.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:41.943]                 }
[17:36:41.943]                 ...future.workdir <- getwd()
[17:36:41.943]             }
[17:36:41.943]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:41.943]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:41.943]         }
[17:36:41.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:41.943]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:41.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:41.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:41.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:41.943]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:41.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:41.943]             base::names(...future.oldOptions))
[17:36:41.943]     }
[17:36:41.943]     if (FALSE) {
[17:36:41.943]     }
[17:36:41.943]     else {
[17:36:41.943]         if (TRUE) {
[17:36:41.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:41.943]                 open = "w")
[17:36:41.943]         }
[17:36:41.943]         else {
[17:36:41.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:41.943]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:41.943]         }
[17:36:41.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:41.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:41.943]             base::sink(type = "output", split = FALSE)
[17:36:41.943]             base::close(...future.stdout)
[17:36:41.943]         }, add = TRUE)
[17:36:41.943]     }
[17:36:41.943]     ...future.frame <- base::sys.nframe()
[17:36:41.943]     ...future.conditions <- base::list()
[17:36:41.943]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:41.943]     if (FALSE) {
[17:36:41.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:41.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:41.943]     }
[17:36:41.943]     ...future.result <- base::tryCatch({
[17:36:41.943]         base::withCallingHandlers({
[17:36:41.943]             ...future.value <- base::withVisible(base::local({
[17:36:41.943]                 ...future.makeSendCondition <- base::local({
[17:36:41.943]                   sendCondition <- NULL
[17:36:41.943]                   function(frame = 1L) {
[17:36:41.943]                     if (is.function(sendCondition)) 
[17:36:41.943]                       return(sendCondition)
[17:36:41.943]                     ns <- getNamespace("parallel")
[17:36:41.943]                     if (exists("sendData", mode = "function", 
[17:36:41.943]                       envir = ns)) {
[17:36:41.943]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:41.943]                         envir = ns)
[17:36:41.943]                       envir <- sys.frame(frame)
[17:36:41.943]                       master <- NULL
[17:36:41.943]                       while (!identical(envir, .GlobalEnv) && 
[17:36:41.943]                         !identical(envir, emptyenv())) {
[17:36:41.943]                         if (exists("master", mode = "list", envir = envir, 
[17:36:41.943]                           inherits = FALSE)) {
[17:36:41.943]                           master <- get("master", mode = "list", 
[17:36:41.943]                             envir = envir, inherits = FALSE)
[17:36:41.943]                           if (inherits(master, c("SOCKnode", 
[17:36:41.943]                             "SOCK0node"))) {
[17:36:41.943]                             sendCondition <<- function(cond) {
[17:36:41.943]                               data <- list(type = "VALUE", value = cond, 
[17:36:41.943]                                 success = TRUE)
[17:36:41.943]                               parallel_sendData(master, data)
[17:36:41.943]                             }
[17:36:41.943]                             return(sendCondition)
[17:36:41.943]                           }
[17:36:41.943]                         }
[17:36:41.943]                         frame <- frame + 1L
[17:36:41.943]                         envir <- sys.frame(frame)
[17:36:41.943]                       }
[17:36:41.943]                     }
[17:36:41.943]                     sendCondition <<- function(cond) NULL
[17:36:41.943]                   }
[17:36:41.943]                 })
[17:36:41.943]                 withCallingHandlers({
[17:36:41.943]                   {
[17:36:41.943]                     do.call(function(...) {
[17:36:41.943]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.943]                       if (!identical(...future.globals.maxSize.org, 
[17:36:41.943]                         ...future.globals.maxSize)) {
[17:36:41.943]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.943]                         on.exit(options(oopts), add = TRUE)
[17:36:41.943]                       }
[17:36:41.943]                       {
[17:36:41.943]                         lapply(seq_along(...future.elements_ii), 
[17:36:41.943]                           FUN = function(jj) {
[17:36:41.943]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.943]                             ...future.FUN(...future.X_jj, ...)
[17:36:41.943]                           })
[17:36:41.943]                       }
[17:36:41.943]                     }, args = future.call.arguments)
[17:36:41.943]                   }
[17:36:41.943]                 }, immediateCondition = function(cond) {
[17:36:41.943]                   sendCondition <- ...future.makeSendCondition()
[17:36:41.943]                   sendCondition(cond)
[17:36:41.943]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.943]                   {
[17:36:41.943]                     inherits <- base::inherits
[17:36:41.943]                     invokeRestart <- base::invokeRestart
[17:36:41.943]                     is.null <- base::is.null
[17:36:41.943]                     muffled <- FALSE
[17:36:41.943]                     if (inherits(cond, "message")) {
[17:36:41.943]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:41.943]                       if (muffled) 
[17:36:41.943]                         invokeRestart("muffleMessage")
[17:36:41.943]                     }
[17:36:41.943]                     else if (inherits(cond, "warning")) {
[17:36:41.943]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:41.943]                       if (muffled) 
[17:36:41.943]                         invokeRestart("muffleWarning")
[17:36:41.943]                     }
[17:36:41.943]                     else if (inherits(cond, "condition")) {
[17:36:41.943]                       if (!is.null(pattern)) {
[17:36:41.943]                         computeRestarts <- base::computeRestarts
[17:36:41.943]                         grepl <- base::grepl
[17:36:41.943]                         restarts <- computeRestarts(cond)
[17:36:41.943]                         for (restart in restarts) {
[17:36:41.943]                           name <- restart$name
[17:36:41.943]                           if (is.null(name)) 
[17:36:41.943]                             next
[17:36:41.943]                           if (!grepl(pattern, name)) 
[17:36:41.943]                             next
[17:36:41.943]                           invokeRestart(restart)
[17:36:41.943]                           muffled <- TRUE
[17:36:41.943]                           break
[17:36:41.943]                         }
[17:36:41.943]                       }
[17:36:41.943]                     }
[17:36:41.943]                     invisible(muffled)
[17:36:41.943]                   }
[17:36:41.943]                   muffleCondition(cond)
[17:36:41.943]                 })
[17:36:41.943]             }))
[17:36:41.943]             future::FutureResult(value = ...future.value$value, 
[17:36:41.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.943]                   ...future.rng), globalenv = if (FALSE) 
[17:36:41.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:41.943]                     ...future.globalenv.names))
[17:36:41.943]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:41.943]         }, condition = base::local({
[17:36:41.943]             c <- base::c
[17:36:41.943]             inherits <- base::inherits
[17:36:41.943]             invokeRestart <- base::invokeRestart
[17:36:41.943]             length <- base::length
[17:36:41.943]             list <- base::list
[17:36:41.943]             seq.int <- base::seq.int
[17:36:41.943]             signalCondition <- base::signalCondition
[17:36:41.943]             sys.calls <- base::sys.calls
[17:36:41.943]             `[[` <- base::`[[`
[17:36:41.943]             `+` <- base::`+`
[17:36:41.943]             `<<-` <- base::`<<-`
[17:36:41.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:41.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:41.943]                   3L)]
[17:36:41.943]             }
[17:36:41.943]             function(cond) {
[17:36:41.943]                 is_error <- inherits(cond, "error")
[17:36:41.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:41.943]                   NULL)
[17:36:41.943]                 if (is_error) {
[17:36:41.943]                   sessionInformation <- function() {
[17:36:41.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:41.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:41.943]                       search = base::search(), system = base::Sys.info())
[17:36:41.943]                   }
[17:36:41.943]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:41.943]                     cond$call), session = sessionInformation(), 
[17:36:41.943]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:41.943]                   signalCondition(cond)
[17:36:41.943]                 }
[17:36:41.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:41.943]                 "immediateCondition"))) {
[17:36:41.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:41.943]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:41.943]                   if (TRUE && !signal) {
[17:36:41.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.943]                     {
[17:36:41.943]                       inherits <- base::inherits
[17:36:41.943]                       invokeRestart <- base::invokeRestart
[17:36:41.943]                       is.null <- base::is.null
[17:36:41.943]                       muffled <- FALSE
[17:36:41.943]                       if (inherits(cond, "message")) {
[17:36:41.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.943]                         if (muffled) 
[17:36:41.943]                           invokeRestart("muffleMessage")
[17:36:41.943]                       }
[17:36:41.943]                       else if (inherits(cond, "warning")) {
[17:36:41.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.943]                         if (muffled) 
[17:36:41.943]                           invokeRestart("muffleWarning")
[17:36:41.943]                       }
[17:36:41.943]                       else if (inherits(cond, "condition")) {
[17:36:41.943]                         if (!is.null(pattern)) {
[17:36:41.943]                           computeRestarts <- base::computeRestarts
[17:36:41.943]                           grepl <- base::grepl
[17:36:41.943]                           restarts <- computeRestarts(cond)
[17:36:41.943]                           for (restart in restarts) {
[17:36:41.943]                             name <- restart$name
[17:36:41.943]                             if (is.null(name)) 
[17:36:41.943]                               next
[17:36:41.943]                             if (!grepl(pattern, name)) 
[17:36:41.943]                               next
[17:36:41.943]                             invokeRestart(restart)
[17:36:41.943]                             muffled <- TRUE
[17:36:41.943]                             break
[17:36:41.943]                           }
[17:36:41.943]                         }
[17:36:41.943]                       }
[17:36:41.943]                       invisible(muffled)
[17:36:41.943]                     }
[17:36:41.943]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.943]                   }
[17:36:41.943]                 }
[17:36:41.943]                 else {
[17:36:41.943]                   if (TRUE) {
[17:36:41.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.943]                     {
[17:36:41.943]                       inherits <- base::inherits
[17:36:41.943]                       invokeRestart <- base::invokeRestart
[17:36:41.943]                       is.null <- base::is.null
[17:36:41.943]                       muffled <- FALSE
[17:36:41.943]                       if (inherits(cond, "message")) {
[17:36:41.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.943]                         if (muffled) 
[17:36:41.943]                           invokeRestart("muffleMessage")
[17:36:41.943]                       }
[17:36:41.943]                       else if (inherits(cond, "warning")) {
[17:36:41.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.943]                         if (muffled) 
[17:36:41.943]                           invokeRestart("muffleWarning")
[17:36:41.943]                       }
[17:36:41.943]                       else if (inherits(cond, "condition")) {
[17:36:41.943]                         if (!is.null(pattern)) {
[17:36:41.943]                           computeRestarts <- base::computeRestarts
[17:36:41.943]                           grepl <- base::grepl
[17:36:41.943]                           restarts <- computeRestarts(cond)
[17:36:41.943]                           for (restart in restarts) {
[17:36:41.943]                             name <- restart$name
[17:36:41.943]                             if (is.null(name)) 
[17:36:41.943]                               next
[17:36:41.943]                             if (!grepl(pattern, name)) 
[17:36:41.943]                               next
[17:36:41.943]                             invokeRestart(restart)
[17:36:41.943]                             muffled <- TRUE
[17:36:41.943]                             break
[17:36:41.943]                           }
[17:36:41.943]                         }
[17:36:41.943]                       }
[17:36:41.943]                       invisible(muffled)
[17:36:41.943]                     }
[17:36:41.943]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.943]                   }
[17:36:41.943]                 }
[17:36:41.943]             }
[17:36:41.943]         }))
[17:36:41.943]     }, error = function(ex) {
[17:36:41.943]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:41.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.943]                 ...future.rng), started = ...future.startTime, 
[17:36:41.943]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:41.943]             version = "1.8"), class = "FutureResult")
[17:36:41.943]     }, finally = {
[17:36:41.943]         if (!identical(...future.workdir, getwd())) 
[17:36:41.943]             setwd(...future.workdir)
[17:36:41.943]         {
[17:36:41.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:41.943]                 ...future.oldOptions$nwarnings <- NULL
[17:36:41.943]             }
[17:36:41.943]             base::options(...future.oldOptions)
[17:36:41.943]             if (.Platform$OS.type == "windows") {
[17:36:41.943]                 old_names <- names(...future.oldEnvVars)
[17:36:41.943]                 envs <- base::Sys.getenv()
[17:36:41.943]                 names <- names(envs)
[17:36:41.943]                 common <- intersect(names, old_names)
[17:36:41.943]                 added <- setdiff(names, old_names)
[17:36:41.943]                 removed <- setdiff(old_names, names)
[17:36:41.943]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:41.943]                   envs[common]]
[17:36:41.943]                 NAMES <- toupper(changed)
[17:36:41.943]                 args <- list()
[17:36:41.943]                 for (kk in seq_along(NAMES)) {
[17:36:41.943]                   name <- changed[[kk]]
[17:36:41.943]                   NAME <- NAMES[[kk]]
[17:36:41.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.943]                     next
[17:36:41.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.943]                 }
[17:36:41.943]                 NAMES <- toupper(added)
[17:36:41.943]                 for (kk in seq_along(NAMES)) {
[17:36:41.943]                   name <- added[[kk]]
[17:36:41.943]                   NAME <- NAMES[[kk]]
[17:36:41.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.943]                     next
[17:36:41.943]                   args[[name]] <- ""
[17:36:41.943]                 }
[17:36:41.943]                 NAMES <- toupper(removed)
[17:36:41.943]                 for (kk in seq_along(NAMES)) {
[17:36:41.943]                   name <- removed[[kk]]
[17:36:41.943]                   NAME <- NAMES[[kk]]
[17:36:41.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.943]                     next
[17:36:41.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.943]                 }
[17:36:41.943]                 if (length(args) > 0) 
[17:36:41.943]                   base::do.call(base::Sys.setenv, args = args)
[17:36:41.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:41.943]             }
[17:36:41.943]             else {
[17:36:41.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:41.943]             }
[17:36:41.943]             {
[17:36:41.943]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:41.943]                   0L) {
[17:36:41.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:41.943]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:41.943]                   base::options(opts)
[17:36:41.943]                 }
[17:36:41.943]                 {
[17:36:41.943]                   {
[17:36:41.943]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:41.943]                     NULL
[17:36:41.943]                   }
[17:36:41.943]                   options(future.plan = NULL)
[17:36:41.943]                   if (is.na(NA_character_)) 
[17:36:41.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:41.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:41.943]                     .init = FALSE)
[17:36:41.943]                 }
[17:36:41.943]             }
[17:36:41.943]         }
[17:36:41.943]     })
[17:36:41.943]     if (TRUE) {
[17:36:41.943]         base::sink(type = "output", split = FALSE)
[17:36:41.943]         if (TRUE) {
[17:36:41.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:41.943]         }
[17:36:41.943]         else {
[17:36:41.943]             ...future.result["stdout"] <- base::list(NULL)
[17:36:41.943]         }
[17:36:41.943]         base::close(...future.stdout)
[17:36:41.943]         ...future.stdout <- NULL
[17:36:41.943]     }
[17:36:41.943]     ...future.result$conditions <- ...future.conditions
[17:36:41.943]     ...future.result$finished <- base::Sys.time()
[17:36:41.943]     ...future.result
[17:36:41.943] }
[17:36:41.946] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:36:41.946] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:36:41.947] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:36:41.947] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:41.948] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:41.948] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[17:36:41.948] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[17:36:41.949] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:41.949] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:41.949] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:36:41.950] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:36:41.950] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:36:41.950] MultisessionFuture started
[17:36:41.951] - Launch lazy future ... done
[17:36:41.951] run() for ‘MultisessionFuture’ ... done
[17:36:41.951] Created future:
[17:36:41.951] MultisessionFuture:
[17:36:41.951] Label: ‘future_by-1’
[17:36:41.951] Expression:
[17:36:41.951] {
[17:36:41.951]     do.call(function(...) {
[17:36:41.951]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.951]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:41.951]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.951]             on.exit(options(oopts), add = TRUE)
[17:36:41.951]         }
[17:36:41.951]         {
[17:36:41.951]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:41.951]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.951]                 ...future.FUN(...future.X_jj, ...)
[17:36:41.951]             })
[17:36:41.951]         }
[17:36:41.951]     }, args = future.call.arguments)
[17:36:41.951] }
[17:36:41.951] Lazy evaluation: FALSE
[17:36:41.951] Asynchronous evaluation: TRUE
[17:36:41.951] Local evaluation: TRUE
[17:36:41.951] Environment: R_GlobalEnv
[17:36:41.951] Capture standard output: TRUE
[17:36:41.951] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:41.951] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:41.951] Packages: <none>
[17:36:41.951] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:41.951] Resolved: FALSE
[17:36:41.951] Value: <not collected>
[17:36:41.951] Conditions captured: <none>
[17:36:41.951] Early signaling: FALSE
[17:36:41.951] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:41.951] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:41.963] Chunk #1 of 2 ... DONE
[17:36:41.963] Chunk #2 of 2 ...
[17:36:41.964]  - Finding globals in 'X' for chunk #2 ...
[17:36:41.964] getGlobalsAndPackages() ...
[17:36:41.964] Searching for globals...
[17:36:41.964] 
[17:36:41.965] Searching for globals ... DONE
[17:36:41.965] - globals: [0] <none>
[17:36:41.965] getGlobalsAndPackages() ... DONE
[17:36:41.965]    + additional globals found: [n=0] 
[17:36:41.965]    + additional namespaces needed: [n=0] 
[17:36:41.965]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:41.965]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:41.965]  - seeds: <none>
[17:36:41.965]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.966] getGlobalsAndPackages() ...
[17:36:41.966] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.966] Resolving globals: FALSE
[17:36:41.966] Tweak future expression to call with '...' arguments ...
[17:36:41.966] {
[17:36:41.966]     do.call(function(...) {
[17:36:41.966]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.966]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:41.966]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.966]             on.exit(options(oopts), add = TRUE)
[17:36:41.966]         }
[17:36:41.966]         {
[17:36:41.966]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:41.966]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.966]                 ...future.FUN(...future.X_jj, ...)
[17:36:41.966]             })
[17:36:41.966]         }
[17:36:41.966]     }, args = future.call.arguments)
[17:36:41.966] }
[17:36:41.966] Tweak future expression to call with '...' arguments ... DONE
[17:36:41.967] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:41.967] 
[17:36:41.967] getGlobalsAndPackages() ... DONE
[17:36:41.968] run() for ‘Future’ ...
[17:36:41.968] - state: ‘created’
[17:36:41.968] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:41.983] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:41.983] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:41.983]   - Field: ‘node’
[17:36:41.983]   - Field: ‘label’
[17:36:41.983]   - Field: ‘local’
[17:36:41.983]   - Field: ‘owner’
[17:36:41.983]   - Field: ‘envir’
[17:36:41.983]   - Field: ‘workers’
[17:36:41.983]   - Field: ‘packages’
[17:36:41.984]   - Field: ‘gc’
[17:36:41.984]   - Field: ‘conditions’
[17:36:41.984]   - Field: ‘persistent’
[17:36:41.984]   - Field: ‘expr’
[17:36:41.984]   - Field: ‘uuid’
[17:36:41.984]   - Field: ‘seed’
[17:36:41.984]   - Field: ‘version’
[17:36:41.984]   - Field: ‘result’
[17:36:41.985]   - Field: ‘asynchronous’
[17:36:41.985]   - Field: ‘calls’
[17:36:41.985]   - Field: ‘globals’
[17:36:41.985]   - Field: ‘stdout’
[17:36:41.985]   - Field: ‘earlySignal’
[17:36:41.985]   - Field: ‘lazy’
[17:36:41.985]   - Field: ‘state’
[17:36:41.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:41.985] - Launch lazy future ...
[17:36:41.986] Packages needed by the future expression (n = 0): <none>
[17:36:41.986] Packages needed by future strategies (n = 0): <none>
[17:36:41.986] {
[17:36:41.986]     {
[17:36:41.986]         {
[17:36:41.986]             ...future.startTime <- base::Sys.time()
[17:36:41.986]             {
[17:36:41.986]                 {
[17:36:41.986]                   {
[17:36:41.986]                     {
[17:36:41.986]                       base::local({
[17:36:41.986]                         has_future <- base::requireNamespace("future", 
[17:36:41.986]                           quietly = TRUE)
[17:36:41.986]                         if (has_future) {
[17:36:41.986]                           ns <- base::getNamespace("future")
[17:36:41.986]                           version <- ns[[".package"]][["version"]]
[17:36:41.986]                           if (is.null(version)) 
[17:36:41.986]                             version <- utils::packageVersion("future")
[17:36:41.986]                         }
[17:36:41.986]                         else {
[17:36:41.986]                           version <- NULL
[17:36:41.986]                         }
[17:36:41.986]                         if (!has_future || version < "1.8.0") {
[17:36:41.986]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:41.986]                             "", base::R.version$version.string), 
[17:36:41.986]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:41.986]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:41.986]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:41.986]                               "release", "version")], collapse = " "), 
[17:36:41.986]                             hostname = base::Sys.info()[["nodename"]])
[17:36:41.986]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:41.986]                             info)
[17:36:41.986]                           info <- base::paste(info, collapse = "; ")
[17:36:41.986]                           if (!has_future) {
[17:36:41.986]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:41.986]                               info)
[17:36:41.986]                           }
[17:36:41.986]                           else {
[17:36:41.986]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:41.986]                               info, version)
[17:36:41.986]                           }
[17:36:41.986]                           base::stop(msg)
[17:36:41.986]                         }
[17:36:41.986]                       })
[17:36:41.986]                     }
[17:36:41.986]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:41.986]                     base::options(mc.cores = 1L)
[17:36:41.986]                   }
[17:36:41.986]                   ...future.strategy.old <- future::plan("list")
[17:36:41.986]                   options(future.plan = NULL)
[17:36:41.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:41.986]                 }
[17:36:41.986]                 ...future.workdir <- getwd()
[17:36:41.986]             }
[17:36:41.986]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:41.986]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:41.986]         }
[17:36:41.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:41.986]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:41.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:41.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:41.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:41.986]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:41.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:41.986]             base::names(...future.oldOptions))
[17:36:41.986]     }
[17:36:41.986]     if (FALSE) {
[17:36:41.986]     }
[17:36:41.986]     else {
[17:36:41.986]         if (TRUE) {
[17:36:41.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:41.986]                 open = "w")
[17:36:41.986]         }
[17:36:41.986]         else {
[17:36:41.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:41.986]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:41.986]         }
[17:36:41.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:41.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:41.986]             base::sink(type = "output", split = FALSE)
[17:36:41.986]             base::close(...future.stdout)
[17:36:41.986]         }, add = TRUE)
[17:36:41.986]     }
[17:36:41.986]     ...future.frame <- base::sys.nframe()
[17:36:41.986]     ...future.conditions <- base::list()
[17:36:41.986]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:41.986]     if (FALSE) {
[17:36:41.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:41.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:41.986]     }
[17:36:41.986]     ...future.result <- base::tryCatch({
[17:36:41.986]         base::withCallingHandlers({
[17:36:41.986]             ...future.value <- base::withVisible(base::local({
[17:36:41.986]                 ...future.makeSendCondition <- base::local({
[17:36:41.986]                   sendCondition <- NULL
[17:36:41.986]                   function(frame = 1L) {
[17:36:41.986]                     if (is.function(sendCondition)) 
[17:36:41.986]                       return(sendCondition)
[17:36:41.986]                     ns <- getNamespace("parallel")
[17:36:41.986]                     if (exists("sendData", mode = "function", 
[17:36:41.986]                       envir = ns)) {
[17:36:41.986]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:41.986]                         envir = ns)
[17:36:41.986]                       envir <- sys.frame(frame)
[17:36:41.986]                       master <- NULL
[17:36:41.986]                       while (!identical(envir, .GlobalEnv) && 
[17:36:41.986]                         !identical(envir, emptyenv())) {
[17:36:41.986]                         if (exists("master", mode = "list", envir = envir, 
[17:36:41.986]                           inherits = FALSE)) {
[17:36:41.986]                           master <- get("master", mode = "list", 
[17:36:41.986]                             envir = envir, inherits = FALSE)
[17:36:41.986]                           if (inherits(master, c("SOCKnode", 
[17:36:41.986]                             "SOCK0node"))) {
[17:36:41.986]                             sendCondition <<- function(cond) {
[17:36:41.986]                               data <- list(type = "VALUE", value = cond, 
[17:36:41.986]                                 success = TRUE)
[17:36:41.986]                               parallel_sendData(master, data)
[17:36:41.986]                             }
[17:36:41.986]                             return(sendCondition)
[17:36:41.986]                           }
[17:36:41.986]                         }
[17:36:41.986]                         frame <- frame + 1L
[17:36:41.986]                         envir <- sys.frame(frame)
[17:36:41.986]                       }
[17:36:41.986]                     }
[17:36:41.986]                     sendCondition <<- function(cond) NULL
[17:36:41.986]                   }
[17:36:41.986]                 })
[17:36:41.986]                 withCallingHandlers({
[17:36:41.986]                   {
[17:36:41.986]                     do.call(function(...) {
[17:36:41.986]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:41.986]                       if (!identical(...future.globals.maxSize.org, 
[17:36:41.986]                         ...future.globals.maxSize)) {
[17:36:41.986]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:41.986]                         on.exit(options(oopts), add = TRUE)
[17:36:41.986]                       }
[17:36:41.986]                       {
[17:36:41.986]                         lapply(seq_along(...future.elements_ii), 
[17:36:41.986]                           FUN = function(jj) {
[17:36:41.986]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:41.986]                             ...future.FUN(...future.X_jj, ...)
[17:36:41.986]                           })
[17:36:41.986]                       }
[17:36:41.986]                     }, args = future.call.arguments)
[17:36:41.986]                   }
[17:36:41.986]                 }, immediateCondition = function(cond) {
[17:36:41.986]                   sendCondition <- ...future.makeSendCondition()
[17:36:41.986]                   sendCondition(cond)
[17:36:41.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.986]                   {
[17:36:41.986]                     inherits <- base::inherits
[17:36:41.986]                     invokeRestart <- base::invokeRestart
[17:36:41.986]                     is.null <- base::is.null
[17:36:41.986]                     muffled <- FALSE
[17:36:41.986]                     if (inherits(cond, "message")) {
[17:36:41.986]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:41.986]                       if (muffled) 
[17:36:41.986]                         invokeRestart("muffleMessage")
[17:36:41.986]                     }
[17:36:41.986]                     else if (inherits(cond, "warning")) {
[17:36:41.986]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:41.986]                       if (muffled) 
[17:36:41.986]                         invokeRestart("muffleWarning")
[17:36:41.986]                     }
[17:36:41.986]                     else if (inherits(cond, "condition")) {
[17:36:41.986]                       if (!is.null(pattern)) {
[17:36:41.986]                         computeRestarts <- base::computeRestarts
[17:36:41.986]                         grepl <- base::grepl
[17:36:41.986]                         restarts <- computeRestarts(cond)
[17:36:41.986]                         for (restart in restarts) {
[17:36:41.986]                           name <- restart$name
[17:36:41.986]                           if (is.null(name)) 
[17:36:41.986]                             next
[17:36:41.986]                           if (!grepl(pattern, name)) 
[17:36:41.986]                             next
[17:36:41.986]                           invokeRestart(restart)
[17:36:41.986]                           muffled <- TRUE
[17:36:41.986]                           break
[17:36:41.986]                         }
[17:36:41.986]                       }
[17:36:41.986]                     }
[17:36:41.986]                     invisible(muffled)
[17:36:41.986]                   }
[17:36:41.986]                   muffleCondition(cond)
[17:36:41.986]                 })
[17:36:41.986]             }))
[17:36:41.986]             future::FutureResult(value = ...future.value$value, 
[17:36:41.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.986]                   ...future.rng), globalenv = if (FALSE) 
[17:36:41.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:41.986]                     ...future.globalenv.names))
[17:36:41.986]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:41.986]         }, condition = base::local({
[17:36:41.986]             c <- base::c
[17:36:41.986]             inherits <- base::inherits
[17:36:41.986]             invokeRestart <- base::invokeRestart
[17:36:41.986]             length <- base::length
[17:36:41.986]             list <- base::list
[17:36:41.986]             seq.int <- base::seq.int
[17:36:41.986]             signalCondition <- base::signalCondition
[17:36:41.986]             sys.calls <- base::sys.calls
[17:36:41.986]             `[[` <- base::`[[`
[17:36:41.986]             `+` <- base::`+`
[17:36:41.986]             `<<-` <- base::`<<-`
[17:36:41.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:41.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:41.986]                   3L)]
[17:36:41.986]             }
[17:36:41.986]             function(cond) {
[17:36:41.986]                 is_error <- inherits(cond, "error")
[17:36:41.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:41.986]                   NULL)
[17:36:41.986]                 if (is_error) {
[17:36:41.986]                   sessionInformation <- function() {
[17:36:41.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:41.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:41.986]                       search = base::search(), system = base::Sys.info())
[17:36:41.986]                   }
[17:36:41.986]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:41.986]                     cond$call), session = sessionInformation(), 
[17:36:41.986]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:41.986]                   signalCondition(cond)
[17:36:41.986]                 }
[17:36:41.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:41.986]                 "immediateCondition"))) {
[17:36:41.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:41.986]                   ...future.conditions[[length(...future.conditions) + 
[17:36:41.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:41.986]                   if (TRUE && !signal) {
[17:36:41.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.986]                     {
[17:36:41.986]                       inherits <- base::inherits
[17:36:41.986]                       invokeRestart <- base::invokeRestart
[17:36:41.986]                       is.null <- base::is.null
[17:36:41.986]                       muffled <- FALSE
[17:36:41.986]                       if (inherits(cond, "message")) {
[17:36:41.986]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.986]                         if (muffled) 
[17:36:41.986]                           invokeRestart("muffleMessage")
[17:36:41.986]                       }
[17:36:41.986]                       else if (inherits(cond, "warning")) {
[17:36:41.986]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.986]                         if (muffled) 
[17:36:41.986]                           invokeRestart("muffleWarning")
[17:36:41.986]                       }
[17:36:41.986]                       else if (inherits(cond, "condition")) {
[17:36:41.986]                         if (!is.null(pattern)) {
[17:36:41.986]                           computeRestarts <- base::computeRestarts
[17:36:41.986]                           grepl <- base::grepl
[17:36:41.986]                           restarts <- computeRestarts(cond)
[17:36:41.986]                           for (restart in restarts) {
[17:36:41.986]                             name <- restart$name
[17:36:41.986]                             if (is.null(name)) 
[17:36:41.986]                               next
[17:36:41.986]                             if (!grepl(pattern, name)) 
[17:36:41.986]                               next
[17:36:41.986]                             invokeRestart(restart)
[17:36:41.986]                             muffled <- TRUE
[17:36:41.986]                             break
[17:36:41.986]                           }
[17:36:41.986]                         }
[17:36:41.986]                       }
[17:36:41.986]                       invisible(muffled)
[17:36:41.986]                     }
[17:36:41.986]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.986]                   }
[17:36:41.986]                 }
[17:36:41.986]                 else {
[17:36:41.986]                   if (TRUE) {
[17:36:41.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:41.986]                     {
[17:36:41.986]                       inherits <- base::inherits
[17:36:41.986]                       invokeRestart <- base::invokeRestart
[17:36:41.986]                       is.null <- base::is.null
[17:36:41.986]                       muffled <- FALSE
[17:36:41.986]                       if (inherits(cond, "message")) {
[17:36:41.986]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:41.986]                         if (muffled) 
[17:36:41.986]                           invokeRestart("muffleMessage")
[17:36:41.986]                       }
[17:36:41.986]                       else if (inherits(cond, "warning")) {
[17:36:41.986]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:41.986]                         if (muffled) 
[17:36:41.986]                           invokeRestart("muffleWarning")
[17:36:41.986]                       }
[17:36:41.986]                       else if (inherits(cond, "condition")) {
[17:36:41.986]                         if (!is.null(pattern)) {
[17:36:41.986]                           computeRestarts <- base::computeRestarts
[17:36:41.986]                           grepl <- base::grepl
[17:36:41.986]                           restarts <- computeRestarts(cond)
[17:36:41.986]                           for (restart in restarts) {
[17:36:41.986]                             name <- restart$name
[17:36:41.986]                             if (is.null(name)) 
[17:36:41.986]                               next
[17:36:41.986]                             if (!grepl(pattern, name)) 
[17:36:41.986]                               next
[17:36:41.986]                             invokeRestart(restart)
[17:36:41.986]                             muffled <- TRUE
[17:36:41.986]                             break
[17:36:41.986]                           }
[17:36:41.986]                         }
[17:36:41.986]                       }
[17:36:41.986]                       invisible(muffled)
[17:36:41.986]                     }
[17:36:41.986]                     muffleCondition(cond, pattern = "^muffle")
[17:36:41.986]                   }
[17:36:41.986]                 }
[17:36:41.986]             }
[17:36:41.986]         }))
[17:36:41.986]     }, error = function(ex) {
[17:36:41.986]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:41.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:41.986]                 ...future.rng), started = ...future.startTime, 
[17:36:41.986]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:41.986]             version = "1.8"), class = "FutureResult")
[17:36:41.986]     }, finally = {
[17:36:41.986]         if (!identical(...future.workdir, getwd())) 
[17:36:41.986]             setwd(...future.workdir)
[17:36:41.986]         {
[17:36:41.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:41.986]                 ...future.oldOptions$nwarnings <- NULL
[17:36:41.986]             }
[17:36:41.986]             base::options(...future.oldOptions)
[17:36:41.986]             if (.Platform$OS.type == "windows") {
[17:36:41.986]                 old_names <- names(...future.oldEnvVars)
[17:36:41.986]                 envs <- base::Sys.getenv()
[17:36:41.986]                 names <- names(envs)
[17:36:41.986]                 common <- intersect(names, old_names)
[17:36:41.986]                 added <- setdiff(names, old_names)
[17:36:41.986]                 removed <- setdiff(old_names, names)
[17:36:41.986]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:41.986]                   envs[common]]
[17:36:41.986]                 NAMES <- toupper(changed)
[17:36:41.986]                 args <- list()
[17:36:41.986]                 for (kk in seq_along(NAMES)) {
[17:36:41.986]                   name <- changed[[kk]]
[17:36:41.986]                   NAME <- NAMES[[kk]]
[17:36:41.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.986]                     next
[17:36:41.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.986]                 }
[17:36:41.986]                 NAMES <- toupper(added)
[17:36:41.986]                 for (kk in seq_along(NAMES)) {
[17:36:41.986]                   name <- added[[kk]]
[17:36:41.986]                   NAME <- NAMES[[kk]]
[17:36:41.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.986]                     next
[17:36:41.986]                   args[[name]] <- ""
[17:36:41.986]                 }
[17:36:41.986]                 NAMES <- toupper(removed)
[17:36:41.986]                 for (kk in seq_along(NAMES)) {
[17:36:41.986]                   name <- removed[[kk]]
[17:36:41.986]                   NAME <- NAMES[[kk]]
[17:36:41.986]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:41.986]                     next
[17:36:41.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:41.986]                 }
[17:36:41.986]                 if (length(args) > 0) 
[17:36:41.986]                   base::do.call(base::Sys.setenv, args = args)
[17:36:41.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:41.986]             }
[17:36:41.986]             else {
[17:36:41.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:41.986]             }
[17:36:41.986]             {
[17:36:41.986]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:41.986]                   0L) {
[17:36:41.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:41.986]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:41.986]                   base::options(opts)
[17:36:41.986]                 }
[17:36:41.986]                 {
[17:36:41.986]                   {
[17:36:41.986]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:41.986]                     NULL
[17:36:41.986]                   }
[17:36:41.986]                   options(future.plan = NULL)
[17:36:41.986]                   if (is.na(NA_character_)) 
[17:36:41.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:41.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:41.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:41.986]                     .init = FALSE)
[17:36:41.986]                 }
[17:36:41.986]             }
[17:36:41.986]         }
[17:36:41.986]     })
[17:36:41.986]     if (TRUE) {
[17:36:41.986]         base::sink(type = "output", split = FALSE)
[17:36:41.986]         if (TRUE) {
[17:36:41.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:41.986]         }
[17:36:41.986]         else {
[17:36:41.986]             ...future.result["stdout"] <- base::list(NULL)
[17:36:41.986]         }
[17:36:41.986]         base::close(...future.stdout)
[17:36:41.986]         ...future.stdout <- NULL
[17:36:41.986]     }
[17:36:41.986]     ...future.result$conditions <- ...future.conditions
[17:36:41.986]     ...future.result$finished <- base::Sys.time()
[17:36:41.986]     ...future.result
[17:36:41.986] }
[17:36:42.038] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:36:42.039] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:36:42.039] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:36:42.039] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:42.040] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.040] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[17:36:42.040] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[17:36:42.041] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:42.041] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.041] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:36:42.041] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.041] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:36:42.042] MultisessionFuture started
[17:36:42.042] - Launch lazy future ... done
[17:36:42.042] run() for ‘MultisessionFuture’ ... done
[17:36:42.042] Created future:
[17:36:42.043] MultisessionFuture:
[17:36:42.043] Label: ‘future_by-2’
[17:36:42.043] Expression:
[17:36:42.043] {
[17:36:42.043]     do.call(function(...) {
[17:36:42.043]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.043]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.043]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.043]             on.exit(options(oopts), add = TRUE)
[17:36:42.043]         }
[17:36:42.043]         {
[17:36:42.043]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.043]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.043]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.043]             })
[17:36:42.043]         }
[17:36:42.043]     }, args = future.call.arguments)
[17:36:42.043] }
[17:36:42.043] Lazy evaluation: FALSE
[17:36:42.043] Asynchronous evaluation: TRUE
[17:36:42.043] Local evaluation: TRUE
[17:36:42.043] Environment: R_GlobalEnv
[17:36:42.043] Capture standard output: TRUE
[17:36:42.043] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:42.043] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:42.043] Packages: <none>
[17:36:42.043] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:42.043] Resolved: FALSE
[17:36:42.043] Value: <not collected>
[17:36:42.043] Conditions captured: <none>
[17:36:42.043] Early signaling: FALSE
[17:36:42.043] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:42.043] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.055] Chunk #2 of 2 ... DONE
[17:36:42.055] Launching 2 futures (chunks) ... DONE
[17:36:42.055] Resolving 2 futures (chunks) ...
[17:36:42.055] resolve() on list ...
[17:36:42.055]  recursive: 0
[17:36:42.055]  length: 2
[17:36:42.055] 
[17:36:42.056] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.056] - Validating connection of MultisessionFuture
[17:36:42.056] - received message: FutureResult
[17:36:42.057] - Received FutureResult
[17:36:42.057] - Erased future from FutureRegistry
[17:36:42.057] result() for ClusterFuture ...
[17:36:42.057] - result already collected: FutureResult
[17:36:42.057] result() for ClusterFuture ... done
[17:36:42.057] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.057] Future #1
[17:36:42.057] result() for ClusterFuture ...
[17:36:42.057] - result already collected: FutureResult
[17:36:42.058] result() for ClusterFuture ... done
[17:36:42.058] result() for ClusterFuture ...
[17:36:42.058] - result already collected: FutureResult
[17:36:42.058] result() for ClusterFuture ... done
[17:36:42.058] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:42.058] - nx: 2
[17:36:42.058] - relay: TRUE
[17:36:42.058] - stdout: TRUE
[17:36:42.058] - signal: TRUE
[17:36:42.059] - resignal: FALSE
[17:36:42.059] - force: TRUE
[17:36:42.059] - relayed: [n=2] FALSE, FALSE
[17:36:42.059] - queued futures: [n=2] FALSE, FALSE
[17:36:42.059]  - until=1
[17:36:42.059]  - relaying element #1
[17:36:42.059] result() for ClusterFuture ...
[17:36:42.059] - result already collected: FutureResult
[17:36:42.059] result() for ClusterFuture ... done
[17:36:42.060] result() for ClusterFuture ...
[17:36:42.060] - result already collected: FutureResult
[17:36:42.060] result() for ClusterFuture ... done
[17:36:42.060] result() for ClusterFuture ...
[17:36:42.060] - result already collected: FutureResult
[17:36:42.060] result() for ClusterFuture ... done
[17:36:42.060] result() for ClusterFuture ...
[17:36:42.060] - result already collected: FutureResult
[17:36:42.060] result() for ClusterFuture ... done
[17:36:42.061] - relayed: [n=2] TRUE, FALSE
[17:36:42.061] - queued futures: [n=2] TRUE, FALSE
[17:36:42.061] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:42.061]  length: 1 (resolved future 1)
[17:36:42.124] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.125] - Validating connection of MultisessionFuture
[17:36:42.125] - received message: FutureResult
[17:36:42.125] - Received FutureResult
[17:36:42.125] - Erased future from FutureRegistry
[17:36:42.125] result() for ClusterFuture ...
[17:36:42.125] - result already collected: FutureResult
[17:36:42.126] result() for ClusterFuture ... done
[17:36:42.126] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.126] Future #2
[17:36:42.126] result() for ClusterFuture ...
[17:36:42.126] - result already collected: FutureResult
[17:36:42.126] result() for ClusterFuture ... done
[17:36:42.126] result() for ClusterFuture ...
[17:36:42.126] - result already collected: FutureResult
[17:36:42.126] result() for ClusterFuture ... done
[17:36:42.127] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:42.127] - nx: 2
[17:36:42.129] - relay: TRUE
[17:36:42.129] - stdout: TRUE
[17:36:42.129] - signal: TRUE
[17:36:42.129] - resignal: FALSE
[17:36:42.130] - force: TRUE
[17:36:42.130] - relayed: [n=2] TRUE, FALSE
[17:36:42.130] - queued futures: [n=2] TRUE, FALSE
[17:36:42.130]  - until=2
[17:36:42.130]  - relaying element #2
[17:36:42.130] result() for ClusterFuture ...
[17:36:42.130] - result already collected: FutureResult
[17:36:42.130] result() for ClusterFuture ... done
[17:36:42.130] result() for ClusterFuture ...
[17:36:42.130] - result already collected: FutureResult
[17:36:42.130] result() for ClusterFuture ... done
[17:36:42.131] result() for ClusterFuture ...
[17:36:42.131] - result already collected: FutureResult
[17:36:42.131] result() for ClusterFuture ... done
[17:36:42.131] result() for ClusterFuture ...
[17:36:42.131] - result already collected: FutureResult
[17:36:42.131] result() for ClusterFuture ... done
[17:36:42.131] - relayed: [n=2] TRUE, TRUE
[17:36:42.131] - queued futures: [n=2] TRUE, TRUE
[17:36:42.131] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:42.131]  length: 0 (resolved future 2)
[17:36:42.131] Relaying remaining futures
[17:36:42.131] signalConditionsASAP(NULL, pos=0) ...
[17:36:42.132] - nx: 2
[17:36:42.132] - relay: TRUE
[17:36:42.132] - stdout: TRUE
[17:36:42.132] - signal: TRUE
[17:36:42.132] - resignal: FALSE
[17:36:42.132] - force: TRUE
[17:36:42.132] - relayed: [n=2] TRUE, TRUE
[17:36:42.132] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:42.132] - relayed: [n=2] TRUE, TRUE
[17:36:42.132] - queued futures: [n=2] TRUE, TRUE
[17:36:42.132] signalConditionsASAP(NULL, pos=0) ... done
[17:36:42.133] resolve() on list ... DONE
[17:36:42.133] result() for ClusterFuture ...
[17:36:42.133] - result already collected: FutureResult
[17:36:42.133] result() for ClusterFuture ... done
[17:36:42.133] result() for ClusterFuture ...
[17:36:42.133] - result already collected: FutureResult
[17:36:42.133] result() for ClusterFuture ... done
[17:36:42.133] result() for ClusterFuture ...
[17:36:42.133] - result already collected: FutureResult
[17:36:42.133] result() for ClusterFuture ... done
[17:36:42.133] result() for ClusterFuture ...
[17:36:42.133] - result already collected: FutureResult
[17:36:42.133] result() for ClusterFuture ... done
[17:36:42.134]  - Number of value chunks collected: 2
[17:36:42.134] Resolving 2 futures (chunks) ... DONE
[17:36:42.134] Reducing values from 2 chunks ...
[17:36:42.134]  - Number of values collected after concatenation: 3
[17:36:42.134]  - Number of values expected: 3
[17:36:42.134] Reducing values from 2 chunks ... DONE
[17:36:42.134] future_lapply() ... DONE
[17:36:42.134] future_by_internal() ... DONE
[17:36:42.134] future_by_internal() ...
[17:36:42.135] future_lapply() ...
[17:36:42.139] Number of chunks: 2
[17:36:42.139] getGlobalsAndPackagesXApply() ...
[17:36:42.139]  - future.globals: TRUE
[17:36:42.139] getGlobalsAndPackages() ...
[17:36:42.139] Searching for globals...
[17:36:42.140] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:42.141] Searching for globals ... DONE
[17:36:42.141] Resolving globals: FALSE
[17:36:42.141] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:42.141] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:42.141] - globals: [1] ‘FUN’
[17:36:42.142] 
[17:36:42.142] getGlobalsAndPackages() ... DONE
[17:36:42.142]  - globals found/used: [n=1] ‘FUN’
[17:36:42.142]  - needed namespaces: [n=0] 
[17:36:42.142] Finding globals ... DONE
[17:36:42.142]  - use_args: TRUE
[17:36:42.142]  - Getting '...' globals ...
[17:36:42.142] resolve() on list ...
[17:36:42.143]  recursive: 0
[17:36:42.143]  length: 1
[17:36:42.143]  elements: ‘...’
[17:36:42.143]  length: 0 (resolved future 1)
[17:36:42.143] resolve() on list ... DONE
[17:36:42.143]    - '...' content: [n=1] ‘digits’
[17:36:42.143] List of 1
[17:36:42.143]  $ ...:List of 1
[17:36:42.143]   ..$ digits: int 2
[17:36:42.143]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:42.143]  - attr(*, "where")=List of 1
[17:36:42.143]   ..$ ...:<environment: 0x5622fc63e6c8> 
[17:36:42.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:42.143]  - attr(*, "resolved")= logi TRUE
[17:36:42.143]  - attr(*, "total_size")= num NA
[17:36:42.146]  - Getting '...' globals ... DONE
[17:36:42.146] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:42.146] List of 2
[17:36:42.146]  $ ...future.FUN:function (object, ...)  
[17:36:42.146]  $ ...          :List of 1
[17:36:42.146]   ..$ digits: int 2
[17:36:42.146]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:42.146]  - attr(*, "where")=List of 2
[17:36:42.146]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:42.146]   ..$ ...          :<environment: 0x5622fc63e6c8> 
[17:36:42.146]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:42.146]  - attr(*, "resolved")= logi FALSE
[17:36:42.146]  - attr(*, "total_size")= num 1296
[17:36:42.149] Packages to be attached in all futures: [n=0] 
[17:36:42.149] getGlobalsAndPackagesXApply() ... DONE
[17:36:42.150] Number of futures (= number of chunks): 2
[17:36:42.150] Launching 2 futures (chunks) ...
[17:36:42.150] Chunk #1 of 2 ...
[17:36:42.150]  - Finding globals in 'X' for chunk #1 ...
[17:36:42.150] getGlobalsAndPackages() ...
[17:36:42.150] Searching for globals...
[17:36:42.150] 
[17:36:42.150] Searching for globals ... DONE
[17:36:42.151] - globals: [0] <none>
[17:36:42.151] getGlobalsAndPackages() ... DONE
[17:36:42.151]    + additional globals found: [n=0] 
[17:36:42.151]    + additional namespaces needed: [n=0] 
[17:36:42.151]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:42.151]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:42.151]  - seeds: <none>
[17:36:42.151]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.151] getGlobalsAndPackages() ...
[17:36:42.151] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.151] Resolving globals: FALSE
[17:36:42.152] Tweak future expression to call with '...' arguments ...
[17:36:42.152] {
[17:36:42.152]     do.call(function(...) {
[17:36:42.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.152]             on.exit(options(oopts), add = TRUE)
[17:36:42.152]         }
[17:36:42.152]         {
[17:36:42.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.152]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.152]             })
[17:36:42.152]         }
[17:36:42.152]     }, args = future.call.arguments)
[17:36:42.152] }
[17:36:42.152] Tweak future expression to call with '...' arguments ... DONE
[17:36:42.152] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.152] 
[17:36:42.153] getGlobalsAndPackages() ... DONE
[17:36:42.153] run() for ‘Future’ ...
[17:36:42.153] - state: ‘created’
[17:36:42.153] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:42.167] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.167] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:42.167]   - Field: ‘node’
[17:36:42.168]   - Field: ‘label’
[17:36:42.168]   - Field: ‘local’
[17:36:42.168]   - Field: ‘owner’
[17:36:42.168]   - Field: ‘envir’
[17:36:42.168]   - Field: ‘workers’
[17:36:42.168]   - Field: ‘packages’
[17:36:42.168]   - Field: ‘gc’
[17:36:42.168]   - Field: ‘conditions’
[17:36:42.168]   - Field: ‘persistent’
[17:36:42.168]   - Field: ‘expr’
[17:36:42.169]   - Field: ‘uuid’
[17:36:42.169]   - Field: ‘seed’
[17:36:42.169]   - Field: ‘version’
[17:36:42.169]   - Field: ‘result’
[17:36:42.169]   - Field: ‘asynchronous’
[17:36:42.169]   - Field: ‘calls’
[17:36:42.169]   - Field: ‘globals’
[17:36:42.169]   - Field: ‘stdout’
[17:36:42.169]   - Field: ‘earlySignal’
[17:36:42.169]   - Field: ‘lazy’
[17:36:42.169]   - Field: ‘state’
[17:36:42.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:42.170] - Launch lazy future ...
[17:36:42.170] Packages needed by the future expression (n = 0): <none>
[17:36:42.170] Packages needed by future strategies (n = 0): <none>
[17:36:42.170] {
[17:36:42.170]     {
[17:36:42.170]         {
[17:36:42.170]             ...future.startTime <- base::Sys.time()
[17:36:42.170]             {
[17:36:42.170]                 {
[17:36:42.170]                   {
[17:36:42.170]                     {
[17:36:42.170]                       base::local({
[17:36:42.170]                         has_future <- base::requireNamespace("future", 
[17:36:42.170]                           quietly = TRUE)
[17:36:42.170]                         if (has_future) {
[17:36:42.170]                           ns <- base::getNamespace("future")
[17:36:42.170]                           version <- ns[[".package"]][["version"]]
[17:36:42.170]                           if (is.null(version)) 
[17:36:42.170]                             version <- utils::packageVersion("future")
[17:36:42.170]                         }
[17:36:42.170]                         else {
[17:36:42.170]                           version <- NULL
[17:36:42.170]                         }
[17:36:42.170]                         if (!has_future || version < "1.8.0") {
[17:36:42.170]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:42.170]                             "", base::R.version$version.string), 
[17:36:42.170]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:42.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:42.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:42.170]                               "release", "version")], collapse = " "), 
[17:36:42.170]                             hostname = base::Sys.info()[["nodename"]])
[17:36:42.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:42.170]                             info)
[17:36:42.170]                           info <- base::paste(info, collapse = "; ")
[17:36:42.170]                           if (!has_future) {
[17:36:42.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:42.170]                               info)
[17:36:42.170]                           }
[17:36:42.170]                           else {
[17:36:42.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:42.170]                               info, version)
[17:36:42.170]                           }
[17:36:42.170]                           base::stop(msg)
[17:36:42.170]                         }
[17:36:42.170]                       })
[17:36:42.170]                     }
[17:36:42.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:42.170]                     base::options(mc.cores = 1L)
[17:36:42.170]                   }
[17:36:42.170]                   ...future.strategy.old <- future::plan("list")
[17:36:42.170]                   options(future.plan = NULL)
[17:36:42.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:42.170]                 }
[17:36:42.170]                 ...future.workdir <- getwd()
[17:36:42.170]             }
[17:36:42.170]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:42.170]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:42.170]         }
[17:36:42.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:42.170]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:42.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:42.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:42.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:42.170]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:42.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:42.170]             base::names(...future.oldOptions))
[17:36:42.170]     }
[17:36:42.170]     if (FALSE) {
[17:36:42.170]     }
[17:36:42.170]     else {
[17:36:42.170]         if (TRUE) {
[17:36:42.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:42.170]                 open = "w")
[17:36:42.170]         }
[17:36:42.170]         else {
[17:36:42.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:42.170]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:42.170]         }
[17:36:42.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:42.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:42.170]             base::sink(type = "output", split = FALSE)
[17:36:42.170]             base::close(...future.stdout)
[17:36:42.170]         }, add = TRUE)
[17:36:42.170]     }
[17:36:42.170]     ...future.frame <- base::sys.nframe()
[17:36:42.170]     ...future.conditions <- base::list()
[17:36:42.170]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:42.170]     if (FALSE) {
[17:36:42.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:42.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:42.170]     }
[17:36:42.170]     ...future.result <- base::tryCatch({
[17:36:42.170]         base::withCallingHandlers({
[17:36:42.170]             ...future.value <- base::withVisible(base::local({
[17:36:42.170]                 ...future.makeSendCondition <- base::local({
[17:36:42.170]                   sendCondition <- NULL
[17:36:42.170]                   function(frame = 1L) {
[17:36:42.170]                     if (is.function(sendCondition)) 
[17:36:42.170]                       return(sendCondition)
[17:36:42.170]                     ns <- getNamespace("parallel")
[17:36:42.170]                     if (exists("sendData", mode = "function", 
[17:36:42.170]                       envir = ns)) {
[17:36:42.170]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:42.170]                         envir = ns)
[17:36:42.170]                       envir <- sys.frame(frame)
[17:36:42.170]                       master <- NULL
[17:36:42.170]                       while (!identical(envir, .GlobalEnv) && 
[17:36:42.170]                         !identical(envir, emptyenv())) {
[17:36:42.170]                         if (exists("master", mode = "list", envir = envir, 
[17:36:42.170]                           inherits = FALSE)) {
[17:36:42.170]                           master <- get("master", mode = "list", 
[17:36:42.170]                             envir = envir, inherits = FALSE)
[17:36:42.170]                           if (inherits(master, c("SOCKnode", 
[17:36:42.170]                             "SOCK0node"))) {
[17:36:42.170]                             sendCondition <<- function(cond) {
[17:36:42.170]                               data <- list(type = "VALUE", value = cond, 
[17:36:42.170]                                 success = TRUE)
[17:36:42.170]                               parallel_sendData(master, data)
[17:36:42.170]                             }
[17:36:42.170]                             return(sendCondition)
[17:36:42.170]                           }
[17:36:42.170]                         }
[17:36:42.170]                         frame <- frame + 1L
[17:36:42.170]                         envir <- sys.frame(frame)
[17:36:42.170]                       }
[17:36:42.170]                     }
[17:36:42.170]                     sendCondition <<- function(cond) NULL
[17:36:42.170]                   }
[17:36:42.170]                 })
[17:36:42.170]                 withCallingHandlers({
[17:36:42.170]                   {
[17:36:42.170]                     do.call(function(...) {
[17:36:42.170]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.170]                       if (!identical(...future.globals.maxSize.org, 
[17:36:42.170]                         ...future.globals.maxSize)) {
[17:36:42.170]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.170]                         on.exit(options(oopts), add = TRUE)
[17:36:42.170]                       }
[17:36:42.170]                       {
[17:36:42.170]                         lapply(seq_along(...future.elements_ii), 
[17:36:42.170]                           FUN = function(jj) {
[17:36:42.170]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.170]                             ...future.FUN(...future.X_jj, ...)
[17:36:42.170]                           })
[17:36:42.170]                       }
[17:36:42.170]                     }, args = future.call.arguments)
[17:36:42.170]                   }
[17:36:42.170]                 }, immediateCondition = function(cond) {
[17:36:42.170]                   sendCondition <- ...future.makeSendCondition()
[17:36:42.170]                   sendCondition(cond)
[17:36:42.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.170]                   {
[17:36:42.170]                     inherits <- base::inherits
[17:36:42.170]                     invokeRestart <- base::invokeRestart
[17:36:42.170]                     is.null <- base::is.null
[17:36:42.170]                     muffled <- FALSE
[17:36:42.170]                     if (inherits(cond, "message")) {
[17:36:42.170]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:42.170]                       if (muffled) 
[17:36:42.170]                         invokeRestart("muffleMessage")
[17:36:42.170]                     }
[17:36:42.170]                     else if (inherits(cond, "warning")) {
[17:36:42.170]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:42.170]                       if (muffled) 
[17:36:42.170]                         invokeRestart("muffleWarning")
[17:36:42.170]                     }
[17:36:42.170]                     else if (inherits(cond, "condition")) {
[17:36:42.170]                       if (!is.null(pattern)) {
[17:36:42.170]                         computeRestarts <- base::computeRestarts
[17:36:42.170]                         grepl <- base::grepl
[17:36:42.170]                         restarts <- computeRestarts(cond)
[17:36:42.170]                         for (restart in restarts) {
[17:36:42.170]                           name <- restart$name
[17:36:42.170]                           if (is.null(name)) 
[17:36:42.170]                             next
[17:36:42.170]                           if (!grepl(pattern, name)) 
[17:36:42.170]                             next
[17:36:42.170]                           invokeRestart(restart)
[17:36:42.170]                           muffled <- TRUE
[17:36:42.170]                           break
[17:36:42.170]                         }
[17:36:42.170]                       }
[17:36:42.170]                     }
[17:36:42.170]                     invisible(muffled)
[17:36:42.170]                   }
[17:36:42.170]                   muffleCondition(cond)
[17:36:42.170]                 })
[17:36:42.170]             }))
[17:36:42.170]             future::FutureResult(value = ...future.value$value, 
[17:36:42.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.170]                   ...future.rng), globalenv = if (FALSE) 
[17:36:42.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:42.170]                     ...future.globalenv.names))
[17:36:42.170]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:42.170]         }, condition = base::local({
[17:36:42.170]             c <- base::c
[17:36:42.170]             inherits <- base::inherits
[17:36:42.170]             invokeRestart <- base::invokeRestart
[17:36:42.170]             length <- base::length
[17:36:42.170]             list <- base::list
[17:36:42.170]             seq.int <- base::seq.int
[17:36:42.170]             signalCondition <- base::signalCondition
[17:36:42.170]             sys.calls <- base::sys.calls
[17:36:42.170]             `[[` <- base::`[[`
[17:36:42.170]             `+` <- base::`+`
[17:36:42.170]             `<<-` <- base::`<<-`
[17:36:42.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:42.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:42.170]                   3L)]
[17:36:42.170]             }
[17:36:42.170]             function(cond) {
[17:36:42.170]                 is_error <- inherits(cond, "error")
[17:36:42.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:42.170]                   NULL)
[17:36:42.170]                 if (is_error) {
[17:36:42.170]                   sessionInformation <- function() {
[17:36:42.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:42.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:42.170]                       search = base::search(), system = base::Sys.info())
[17:36:42.170]                   }
[17:36:42.170]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:42.170]                     cond$call), session = sessionInformation(), 
[17:36:42.170]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:42.170]                   signalCondition(cond)
[17:36:42.170]                 }
[17:36:42.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:42.170]                 "immediateCondition"))) {
[17:36:42.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:42.170]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:42.170]                   if (TRUE && !signal) {
[17:36:42.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.170]                     {
[17:36:42.170]                       inherits <- base::inherits
[17:36:42.170]                       invokeRestart <- base::invokeRestart
[17:36:42.170]                       is.null <- base::is.null
[17:36:42.170]                       muffled <- FALSE
[17:36:42.170]                       if (inherits(cond, "message")) {
[17:36:42.170]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.170]                         if (muffled) 
[17:36:42.170]                           invokeRestart("muffleMessage")
[17:36:42.170]                       }
[17:36:42.170]                       else if (inherits(cond, "warning")) {
[17:36:42.170]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.170]                         if (muffled) 
[17:36:42.170]                           invokeRestart("muffleWarning")
[17:36:42.170]                       }
[17:36:42.170]                       else if (inherits(cond, "condition")) {
[17:36:42.170]                         if (!is.null(pattern)) {
[17:36:42.170]                           computeRestarts <- base::computeRestarts
[17:36:42.170]                           grepl <- base::grepl
[17:36:42.170]                           restarts <- computeRestarts(cond)
[17:36:42.170]                           for (restart in restarts) {
[17:36:42.170]                             name <- restart$name
[17:36:42.170]                             if (is.null(name)) 
[17:36:42.170]                               next
[17:36:42.170]                             if (!grepl(pattern, name)) 
[17:36:42.170]                               next
[17:36:42.170]                             invokeRestart(restart)
[17:36:42.170]                             muffled <- TRUE
[17:36:42.170]                             break
[17:36:42.170]                           }
[17:36:42.170]                         }
[17:36:42.170]                       }
[17:36:42.170]                       invisible(muffled)
[17:36:42.170]                     }
[17:36:42.170]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.170]                   }
[17:36:42.170]                 }
[17:36:42.170]                 else {
[17:36:42.170]                   if (TRUE) {
[17:36:42.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.170]                     {
[17:36:42.170]                       inherits <- base::inherits
[17:36:42.170]                       invokeRestart <- base::invokeRestart
[17:36:42.170]                       is.null <- base::is.null
[17:36:42.170]                       muffled <- FALSE
[17:36:42.170]                       if (inherits(cond, "message")) {
[17:36:42.170]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.170]                         if (muffled) 
[17:36:42.170]                           invokeRestart("muffleMessage")
[17:36:42.170]                       }
[17:36:42.170]                       else if (inherits(cond, "warning")) {
[17:36:42.170]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.170]                         if (muffled) 
[17:36:42.170]                           invokeRestart("muffleWarning")
[17:36:42.170]                       }
[17:36:42.170]                       else if (inherits(cond, "condition")) {
[17:36:42.170]                         if (!is.null(pattern)) {
[17:36:42.170]                           computeRestarts <- base::computeRestarts
[17:36:42.170]                           grepl <- base::grepl
[17:36:42.170]                           restarts <- computeRestarts(cond)
[17:36:42.170]                           for (restart in restarts) {
[17:36:42.170]                             name <- restart$name
[17:36:42.170]                             if (is.null(name)) 
[17:36:42.170]                               next
[17:36:42.170]                             if (!grepl(pattern, name)) 
[17:36:42.170]                               next
[17:36:42.170]                             invokeRestart(restart)
[17:36:42.170]                             muffled <- TRUE
[17:36:42.170]                             break
[17:36:42.170]                           }
[17:36:42.170]                         }
[17:36:42.170]                       }
[17:36:42.170]                       invisible(muffled)
[17:36:42.170]                     }
[17:36:42.170]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.170]                   }
[17:36:42.170]                 }
[17:36:42.170]             }
[17:36:42.170]         }))
[17:36:42.170]     }, error = function(ex) {
[17:36:42.170]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:42.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.170]                 ...future.rng), started = ...future.startTime, 
[17:36:42.170]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:42.170]             version = "1.8"), class = "FutureResult")
[17:36:42.170]     }, finally = {
[17:36:42.170]         if (!identical(...future.workdir, getwd())) 
[17:36:42.170]             setwd(...future.workdir)
[17:36:42.170]         {
[17:36:42.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:42.170]                 ...future.oldOptions$nwarnings <- NULL
[17:36:42.170]             }
[17:36:42.170]             base::options(...future.oldOptions)
[17:36:42.170]             if (.Platform$OS.type == "windows") {
[17:36:42.170]                 old_names <- names(...future.oldEnvVars)
[17:36:42.170]                 envs <- base::Sys.getenv()
[17:36:42.170]                 names <- names(envs)
[17:36:42.170]                 common <- intersect(names, old_names)
[17:36:42.170]                 added <- setdiff(names, old_names)
[17:36:42.170]                 removed <- setdiff(old_names, names)
[17:36:42.170]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:42.170]                   envs[common]]
[17:36:42.170]                 NAMES <- toupper(changed)
[17:36:42.170]                 args <- list()
[17:36:42.170]                 for (kk in seq_along(NAMES)) {
[17:36:42.170]                   name <- changed[[kk]]
[17:36:42.170]                   NAME <- NAMES[[kk]]
[17:36:42.170]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.170]                     next
[17:36:42.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.170]                 }
[17:36:42.170]                 NAMES <- toupper(added)
[17:36:42.170]                 for (kk in seq_along(NAMES)) {
[17:36:42.170]                   name <- added[[kk]]
[17:36:42.170]                   NAME <- NAMES[[kk]]
[17:36:42.170]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.170]                     next
[17:36:42.170]                   args[[name]] <- ""
[17:36:42.170]                 }
[17:36:42.170]                 NAMES <- toupper(removed)
[17:36:42.170]                 for (kk in seq_along(NAMES)) {
[17:36:42.170]                   name <- removed[[kk]]
[17:36:42.170]                   NAME <- NAMES[[kk]]
[17:36:42.170]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.170]                     next
[17:36:42.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.170]                 }
[17:36:42.170]                 if (length(args) > 0) 
[17:36:42.170]                   base::do.call(base::Sys.setenv, args = args)
[17:36:42.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:42.170]             }
[17:36:42.170]             else {
[17:36:42.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:42.170]             }
[17:36:42.170]             {
[17:36:42.170]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:42.170]                   0L) {
[17:36:42.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:42.170]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:42.170]                   base::options(opts)
[17:36:42.170]                 }
[17:36:42.170]                 {
[17:36:42.170]                   {
[17:36:42.170]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:42.170]                     NULL
[17:36:42.170]                   }
[17:36:42.170]                   options(future.plan = NULL)
[17:36:42.170]                   if (is.na(NA_character_)) 
[17:36:42.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:42.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:42.170]                     .init = FALSE)
[17:36:42.170]                 }
[17:36:42.170]             }
[17:36:42.170]         }
[17:36:42.170]     })
[17:36:42.170]     if (TRUE) {
[17:36:42.170]         base::sink(type = "output", split = FALSE)
[17:36:42.170]         if (TRUE) {
[17:36:42.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:42.170]         }
[17:36:42.170]         else {
[17:36:42.170]             ...future.result["stdout"] <- base::list(NULL)
[17:36:42.170]         }
[17:36:42.170]         base::close(...future.stdout)
[17:36:42.170]         ...future.stdout <- NULL
[17:36:42.170]     }
[17:36:42.170]     ...future.result$conditions <- ...future.conditions
[17:36:42.170]     ...future.result$finished <- base::Sys.time()
[17:36:42.170]     ...future.result
[17:36:42.170] }
[17:36:42.173] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[17:36:42.173] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:36:42.174] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:36:42.174] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:36:42.174] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:36:42.174] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[17:36:42.175] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[17:36:42.175] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:42.175] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.175] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:36:42.176] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.176] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[17:36:42.177] MultisessionFuture started
[17:36:42.177] - Launch lazy future ... done
[17:36:42.177] run() for ‘MultisessionFuture’ ... done
[17:36:42.177] Created future:
[17:36:42.177] MultisessionFuture:
[17:36:42.177] Label: ‘future_by-1’
[17:36:42.177] Expression:
[17:36:42.177] {
[17:36:42.177]     do.call(function(...) {
[17:36:42.177]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.177]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.177]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.177]             on.exit(options(oopts), add = TRUE)
[17:36:42.177]         }
[17:36:42.177]         {
[17:36:42.177]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.177]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.177]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.177]             })
[17:36:42.177]         }
[17:36:42.177]     }, args = future.call.arguments)
[17:36:42.177] }
[17:36:42.177] Lazy evaluation: FALSE
[17:36:42.177] Asynchronous evaluation: TRUE
[17:36:42.177] Local evaluation: TRUE
[17:36:42.177] Environment: R_GlobalEnv
[17:36:42.177] Capture standard output: TRUE
[17:36:42.177] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:42.177] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:42.177] Packages: <none>
[17:36:42.177] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:42.177] Resolved: FALSE
[17:36:42.177] Value: <not collected>
[17:36:42.177] Conditions captured: <none>
[17:36:42.177] Early signaling: FALSE
[17:36:42.177] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:42.177] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.189] Chunk #1 of 2 ... DONE
[17:36:42.189] Chunk #2 of 2 ...
[17:36:42.189]  - Finding globals in 'X' for chunk #2 ...
[17:36:42.189] getGlobalsAndPackages() ...
[17:36:42.189] Searching for globals...
[17:36:42.189] 
[17:36:42.190] Searching for globals ... DONE
[17:36:42.190] - globals: [0] <none>
[17:36:42.190] getGlobalsAndPackages() ... DONE
[17:36:42.190]    + additional globals found: [n=0] 
[17:36:42.190]    + additional namespaces needed: [n=0] 
[17:36:42.190]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:42.190]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:42.190]  - seeds: <none>
[17:36:42.190]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.190] getGlobalsAndPackages() ...
[17:36:42.190] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.191] Resolving globals: FALSE
[17:36:42.191] Tweak future expression to call with '...' arguments ...
[17:36:42.191] {
[17:36:42.191]     do.call(function(...) {
[17:36:42.191]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.191]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.191]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.191]             on.exit(options(oopts), add = TRUE)
[17:36:42.191]         }
[17:36:42.191]         {
[17:36:42.191]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.191]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.191]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.191]             })
[17:36:42.191]         }
[17:36:42.191]     }, args = future.call.arguments)
[17:36:42.191] }
[17:36:42.191] Tweak future expression to call with '...' arguments ... DONE
[17:36:42.191] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.192] 
[17:36:42.192] getGlobalsAndPackages() ... DONE
[17:36:42.192] run() for ‘Future’ ...
[17:36:42.192] - state: ‘created’
[17:36:42.192] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:42.206] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:42.207]   - Field: ‘node’
[17:36:42.207]   - Field: ‘label’
[17:36:42.207]   - Field: ‘local’
[17:36:42.207]   - Field: ‘owner’
[17:36:42.207]   - Field: ‘envir’
[17:36:42.207]   - Field: ‘workers’
[17:36:42.207]   - Field: ‘packages’
[17:36:42.207]   - Field: ‘gc’
[17:36:42.207]   - Field: ‘conditions’
[17:36:42.208]   - Field: ‘persistent’
[17:36:42.208]   - Field: ‘expr’
[17:36:42.208]   - Field: ‘uuid’
[17:36:42.208]   - Field: ‘seed’
[17:36:42.208]   - Field: ‘version’
[17:36:42.208]   - Field: ‘result’
[17:36:42.208]   - Field: ‘asynchronous’
[17:36:42.208]   - Field: ‘calls’
[17:36:42.208]   - Field: ‘globals’
[17:36:42.208]   - Field: ‘stdout’
[17:36:42.208]   - Field: ‘earlySignal’
[17:36:42.209]   - Field: ‘lazy’
[17:36:42.209]   - Field: ‘state’
[17:36:42.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:42.209] - Launch lazy future ...
[17:36:42.209] Packages needed by the future expression (n = 0): <none>
[17:36:42.209] Packages needed by future strategies (n = 0): <none>
[17:36:42.210] {
[17:36:42.210]     {
[17:36:42.210]         {
[17:36:42.210]             ...future.startTime <- base::Sys.time()
[17:36:42.210]             {
[17:36:42.210]                 {
[17:36:42.210]                   {
[17:36:42.210]                     {
[17:36:42.210]                       base::local({
[17:36:42.210]                         has_future <- base::requireNamespace("future", 
[17:36:42.210]                           quietly = TRUE)
[17:36:42.210]                         if (has_future) {
[17:36:42.210]                           ns <- base::getNamespace("future")
[17:36:42.210]                           version <- ns[[".package"]][["version"]]
[17:36:42.210]                           if (is.null(version)) 
[17:36:42.210]                             version <- utils::packageVersion("future")
[17:36:42.210]                         }
[17:36:42.210]                         else {
[17:36:42.210]                           version <- NULL
[17:36:42.210]                         }
[17:36:42.210]                         if (!has_future || version < "1.8.0") {
[17:36:42.210]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:42.210]                             "", base::R.version$version.string), 
[17:36:42.210]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:42.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:42.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:42.210]                               "release", "version")], collapse = " "), 
[17:36:42.210]                             hostname = base::Sys.info()[["nodename"]])
[17:36:42.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:42.210]                             info)
[17:36:42.210]                           info <- base::paste(info, collapse = "; ")
[17:36:42.210]                           if (!has_future) {
[17:36:42.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:42.210]                               info)
[17:36:42.210]                           }
[17:36:42.210]                           else {
[17:36:42.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:42.210]                               info, version)
[17:36:42.210]                           }
[17:36:42.210]                           base::stop(msg)
[17:36:42.210]                         }
[17:36:42.210]                       })
[17:36:42.210]                     }
[17:36:42.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:42.210]                     base::options(mc.cores = 1L)
[17:36:42.210]                   }
[17:36:42.210]                   ...future.strategy.old <- future::plan("list")
[17:36:42.210]                   options(future.plan = NULL)
[17:36:42.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:42.210]                 }
[17:36:42.210]                 ...future.workdir <- getwd()
[17:36:42.210]             }
[17:36:42.210]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:42.210]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:42.210]         }
[17:36:42.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:42.210]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:42.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:42.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:42.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:42.210]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:42.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:42.210]             base::names(...future.oldOptions))
[17:36:42.210]     }
[17:36:42.210]     if (FALSE) {
[17:36:42.210]     }
[17:36:42.210]     else {
[17:36:42.210]         if (TRUE) {
[17:36:42.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:42.210]                 open = "w")
[17:36:42.210]         }
[17:36:42.210]         else {
[17:36:42.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:42.210]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:42.210]         }
[17:36:42.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:42.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:42.210]             base::sink(type = "output", split = FALSE)
[17:36:42.210]             base::close(...future.stdout)
[17:36:42.210]         }, add = TRUE)
[17:36:42.210]     }
[17:36:42.210]     ...future.frame <- base::sys.nframe()
[17:36:42.210]     ...future.conditions <- base::list()
[17:36:42.210]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:42.210]     if (FALSE) {
[17:36:42.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:42.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:42.210]     }
[17:36:42.210]     ...future.result <- base::tryCatch({
[17:36:42.210]         base::withCallingHandlers({
[17:36:42.210]             ...future.value <- base::withVisible(base::local({
[17:36:42.210]                 ...future.makeSendCondition <- base::local({
[17:36:42.210]                   sendCondition <- NULL
[17:36:42.210]                   function(frame = 1L) {
[17:36:42.210]                     if (is.function(sendCondition)) 
[17:36:42.210]                       return(sendCondition)
[17:36:42.210]                     ns <- getNamespace("parallel")
[17:36:42.210]                     if (exists("sendData", mode = "function", 
[17:36:42.210]                       envir = ns)) {
[17:36:42.210]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:42.210]                         envir = ns)
[17:36:42.210]                       envir <- sys.frame(frame)
[17:36:42.210]                       master <- NULL
[17:36:42.210]                       while (!identical(envir, .GlobalEnv) && 
[17:36:42.210]                         !identical(envir, emptyenv())) {
[17:36:42.210]                         if (exists("master", mode = "list", envir = envir, 
[17:36:42.210]                           inherits = FALSE)) {
[17:36:42.210]                           master <- get("master", mode = "list", 
[17:36:42.210]                             envir = envir, inherits = FALSE)
[17:36:42.210]                           if (inherits(master, c("SOCKnode", 
[17:36:42.210]                             "SOCK0node"))) {
[17:36:42.210]                             sendCondition <<- function(cond) {
[17:36:42.210]                               data <- list(type = "VALUE", value = cond, 
[17:36:42.210]                                 success = TRUE)
[17:36:42.210]                               parallel_sendData(master, data)
[17:36:42.210]                             }
[17:36:42.210]                             return(sendCondition)
[17:36:42.210]                           }
[17:36:42.210]                         }
[17:36:42.210]                         frame <- frame + 1L
[17:36:42.210]                         envir <- sys.frame(frame)
[17:36:42.210]                       }
[17:36:42.210]                     }
[17:36:42.210]                     sendCondition <<- function(cond) NULL
[17:36:42.210]                   }
[17:36:42.210]                 })
[17:36:42.210]                 withCallingHandlers({
[17:36:42.210]                   {
[17:36:42.210]                     do.call(function(...) {
[17:36:42.210]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.210]                       if (!identical(...future.globals.maxSize.org, 
[17:36:42.210]                         ...future.globals.maxSize)) {
[17:36:42.210]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.210]                         on.exit(options(oopts), add = TRUE)
[17:36:42.210]                       }
[17:36:42.210]                       {
[17:36:42.210]                         lapply(seq_along(...future.elements_ii), 
[17:36:42.210]                           FUN = function(jj) {
[17:36:42.210]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.210]                             ...future.FUN(...future.X_jj, ...)
[17:36:42.210]                           })
[17:36:42.210]                       }
[17:36:42.210]                     }, args = future.call.arguments)
[17:36:42.210]                   }
[17:36:42.210]                 }, immediateCondition = function(cond) {
[17:36:42.210]                   sendCondition <- ...future.makeSendCondition()
[17:36:42.210]                   sendCondition(cond)
[17:36:42.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.210]                   {
[17:36:42.210]                     inherits <- base::inherits
[17:36:42.210]                     invokeRestart <- base::invokeRestart
[17:36:42.210]                     is.null <- base::is.null
[17:36:42.210]                     muffled <- FALSE
[17:36:42.210]                     if (inherits(cond, "message")) {
[17:36:42.210]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:42.210]                       if (muffled) 
[17:36:42.210]                         invokeRestart("muffleMessage")
[17:36:42.210]                     }
[17:36:42.210]                     else if (inherits(cond, "warning")) {
[17:36:42.210]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:42.210]                       if (muffled) 
[17:36:42.210]                         invokeRestart("muffleWarning")
[17:36:42.210]                     }
[17:36:42.210]                     else if (inherits(cond, "condition")) {
[17:36:42.210]                       if (!is.null(pattern)) {
[17:36:42.210]                         computeRestarts <- base::computeRestarts
[17:36:42.210]                         grepl <- base::grepl
[17:36:42.210]                         restarts <- computeRestarts(cond)
[17:36:42.210]                         for (restart in restarts) {
[17:36:42.210]                           name <- restart$name
[17:36:42.210]                           if (is.null(name)) 
[17:36:42.210]                             next
[17:36:42.210]                           if (!grepl(pattern, name)) 
[17:36:42.210]                             next
[17:36:42.210]                           invokeRestart(restart)
[17:36:42.210]                           muffled <- TRUE
[17:36:42.210]                           break
[17:36:42.210]                         }
[17:36:42.210]                       }
[17:36:42.210]                     }
[17:36:42.210]                     invisible(muffled)
[17:36:42.210]                   }
[17:36:42.210]                   muffleCondition(cond)
[17:36:42.210]                 })
[17:36:42.210]             }))
[17:36:42.210]             future::FutureResult(value = ...future.value$value, 
[17:36:42.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.210]                   ...future.rng), globalenv = if (FALSE) 
[17:36:42.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:42.210]                     ...future.globalenv.names))
[17:36:42.210]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:42.210]         }, condition = base::local({
[17:36:42.210]             c <- base::c
[17:36:42.210]             inherits <- base::inherits
[17:36:42.210]             invokeRestart <- base::invokeRestart
[17:36:42.210]             length <- base::length
[17:36:42.210]             list <- base::list
[17:36:42.210]             seq.int <- base::seq.int
[17:36:42.210]             signalCondition <- base::signalCondition
[17:36:42.210]             sys.calls <- base::sys.calls
[17:36:42.210]             `[[` <- base::`[[`
[17:36:42.210]             `+` <- base::`+`
[17:36:42.210]             `<<-` <- base::`<<-`
[17:36:42.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:42.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:42.210]                   3L)]
[17:36:42.210]             }
[17:36:42.210]             function(cond) {
[17:36:42.210]                 is_error <- inherits(cond, "error")
[17:36:42.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:42.210]                   NULL)
[17:36:42.210]                 if (is_error) {
[17:36:42.210]                   sessionInformation <- function() {
[17:36:42.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:42.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:42.210]                       search = base::search(), system = base::Sys.info())
[17:36:42.210]                   }
[17:36:42.210]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:42.210]                     cond$call), session = sessionInformation(), 
[17:36:42.210]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:42.210]                   signalCondition(cond)
[17:36:42.210]                 }
[17:36:42.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:42.210]                 "immediateCondition"))) {
[17:36:42.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:42.210]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:42.210]                   if (TRUE && !signal) {
[17:36:42.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.210]                     {
[17:36:42.210]                       inherits <- base::inherits
[17:36:42.210]                       invokeRestart <- base::invokeRestart
[17:36:42.210]                       is.null <- base::is.null
[17:36:42.210]                       muffled <- FALSE
[17:36:42.210]                       if (inherits(cond, "message")) {
[17:36:42.210]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.210]                         if (muffled) 
[17:36:42.210]                           invokeRestart("muffleMessage")
[17:36:42.210]                       }
[17:36:42.210]                       else if (inherits(cond, "warning")) {
[17:36:42.210]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.210]                         if (muffled) 
[17:36:42.210]                           invokeRestart("muffleWarning")
[17:36:42.210]                       }
[17:36:42.210]                       else if (inherits(cond, "condition")) {
[17:36:42.210]                         if (!is.null(pattern)) {
[17:36:42.210]                           computeRestarts <- base::computeRestarts
[17:36:42.210]                           grepl <- base::grepl
[17:36:42.210]                           restarts <- computeRestarts(cond)
[17:36:42.210]                           for (restart in restarts) {
[17:36:42.210]                             name <- restart$name
[17:36:42.210]                             if (is.null(name)) 
[17:36:42.210]                               next
[17:36:42.210]                             if (!grepl(pattern, name)) 
[17:36:42.210]                               next
[17:36:42.210]                             invokeRestart(restart)
[17:36:42.210]                             muffled <- TRUE
[17:36:42.210]                             break
[17:36:42.210]                           }
[17:36:42.210]                         }
[17:36:42.210]                       }
[17:36:42.210]                       invisible(muffled)
[17:36:42.210]                     }
[17:36:42.210]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.210]                   }
[17:36:42.210]                 }
[17:36:42.210]                 else {
[17:36:42.210]                   if (TRUE) {
[17:36:42.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.210]                     {
[17:36:42.210]                       inherits <- base::inherits
[17:36:42.210]                       invokeRestart <- base::invokeRestart
[17:36:42.210]                       is.null <- base::is.null
[17:36:42.210]                       muffled <- FALSE
[17:36:42.210]                       if (inherits(cond, "message")) {
[17:36:42.210]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.210]                         if (muffled) 
[17:36:42.210]                           invokeRestart("muffleMessage")
[17:36:42.210]                       }
[17:36:42.210]                       else if (inherits(cond, "warning")) {
[17:36:42.210]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.210]                         if (muffled) 
[17:36:42.210]                           invokeRestart("muffleWarning")
[17:36:42.210]                       }
[17:36:42.210]                       else if (inherits(cond, "condition")) {
[17:36:42.210]                         if (!is.null(pattern)) {
[17:36:42.210]                           computeRestarts <- base::computeRestarts
[17:36:42.210]                           grepl <- base::grepl
[17:36:42.210]                           restarts <- computeRestarts(cond)
[17:36:42.210]                           for (restart in restarts) {
[17:36:42.210]                             name <- restart$name
[17:36:42.210]                             if (is.null(name)) 
[17:36:42.210]                               next
[17:36:42.210]                             if (!grepl(pattern, name)) 
[17:36:42.210]                               next
[17:36:42.210]                             invokeRestart(restart)
[17:36:42.210]                             muffled <- TRUE
[17:36:42.210]                             break
[17:36:42.210]                           }
[17:36:42.210]                         }
[17:36:42.210]                       }
[17:36:42.210]                       invisible(muffled)
[17:36:42.210]                     }
[17:36:42.210]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.210]                   }
[17:36:42.210]                 }
[17:36:42.210]             }
[17:36:42.210]         }))
[17:36:42.210]     }, error = function(ex) {
[17:36:42.210]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:42.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.210]                 ...future.rng), started = ...future.startTime, 
[17:36:42.210]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:42.210]             version = "1.8"), class = "FutureResult")
[17:36:42.210]     }, finally = {
[17:36:42.210]         if (!identical(...future.workdir, getwd())) 
[17:36:42.210]             setwd(...future.workdir)
[17:36:42.210]         {
[17:36:42.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:42.210]                 ...future.oldOptions$nwarnings <- NULL
[17:36:42.210]             }
[17:36:42.210]             base::options(...future.oldOptions)
[17:36:42.210]             if (.Platform$OS.type == "windows") {
[17:36:42.210]                 old_names <- names(...future.oldEnvVars)
[17:36:42.210]                 envs <- base::Sys.getenv()
[17:36:42.210]                 names <- names(envs)
[17:36:42.210]                 common <- intersect(names, old_names)
[17:36:42.210]                 added <- setdiff(names, old_names)
[17:36:42.210]                 removed <- setdiff(old_names, names)
[17:36:42.210]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:42.210]                   envs[common]]
[17:36:42.210]                 NAMES <- toupper(changed)
[17:36:42.210]                 args <- list()
[17:36:42.210]                 for (kk in seq_along(NAMES)) {
[17:36:42.210]                   name <- changed[[kk]]
[17:36:42.210]                   NAME <- NAMES[[kk]]
[17:36:42.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.210]                     next
[17:36:42.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.210]                 }
[17:36:42.210]                 NAMES <- toupper(added)
[17:36:42.210]                 for (kk in seq_along(NAMES)) {
[17:36:42.210]                   name <- added[[kk]]
[17:36:42.210]                   NAME <- NAMES[[kk]]
[17:36:42.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.210]                     next
[17:36:42.210]                   args[[name]] <- ""
[17:36:42.210]                 }
[17:36:42.210]                 NAMES <- toupper(removed)
[17:36:42.210]                 for (kk in seq_along(NAMES)) {
[17:36:42.210]                   name <- removed[[kk]]
[17:36:42.210]                   NAME <- NAMES[[kk]]
[17:36:42.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.210]                     next
[17:36:42.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.210]                 }
[17:36:42.210]                 if (length(args) > 0) 
[17:36:42.210]                   base::do.call(base::Sys.setenv, args = args)
[17:36:42.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:42.210]             }
[17:36:42.210]             else {
[17:36:42.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:42.210]             }
[17:36:42.210]             {
[17:36:42.210]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:42.210]                   0L) {
[17:36:42.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:42.210]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:42.210]                   base::options(opts)
[17:36:42.210]                 }
[17:36:42.210]                 {
[17:36:42.210]                   {
[17:36:42.210]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:42.210]                     NULL
[17:36:42.210]                   }
[17:36:42.210]                   options(future.plan = NULL)
[17:36:42.210]                   if (is.na(NA_character_)) 
[17:36:42.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:42.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:42.210]                     .init = FALSE)
[17:36:42.210]                 }
[17:36:42.210]             }
[17:36:42.210]         }
[17:36:42.210]     })
[17:36:42.210]     if (TRUE) {
[17:36:42.210]         base::sink(type = "output", split = FALSE)
[17:36:42.210]         if (TRUE) {
[17:36:42.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:42.210]         }
[17:36:42.210]         else {
[17:36:42.210]             ...future.result["stdout"] <- base::list(NULL)
[17:36:42.210]         }
[17:36:42.210]         base::close(...future.stdout)
[17:36:42.210]         ...future.stdout <- NULL
[17:36:42.210]     }
[17:36:42.210]     ...future.result$conditions <- ...future.conditions
[17:36:42.210]     ...future.result$finished <- base::Sys.time()
[17:36:42.210]     ...future.result
[17:36:42.210] }
[17:36:42.213] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[17:36:42.213] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:36:42.213] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:36:42.213] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[17:36:42.214] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[17:36:42.214] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[17:36:42.214] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[17:36:42.214] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:42.215] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.215] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:36:42.215] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.215] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[17:36:42.216] MultisessionFuture started
[17:36:42.216] - Launch lazy future ... done
[17:36:42.216] run() for ‘MultisessionFuture’ ... done
[17:36:42.216] Created future:
[17:36:42.217] MultisessionFuture:
[17:36:42.217] Label: ‘future_by-2’
[17:36:42.217] Expression:
[17:36:42.217] {
[17:36:42.217]     do.call(function(...) {
[17:36:42.217]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.217]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.217]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.217]             on.exit(options(oopts), add = TRUE)
[17:36:42.217]         }
[17:36:42.217]         {
[17:36:42.217]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.217]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.217]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.217]             })
[17:36:42.217]         }
[17:36:42.217]     }, args = future.call.arguments)
[17:36:42.217] }
[17:36:42.217] Lazy evaluation: FALSE
[17:36:42.217] Asynchronous evaluation: TRUE
[17:36:42.217] Local evaluation: TRUE
[17:36:42.217] Environment: R_GlobalEnv
[17:36:42.217] Capture standard output: TRUE
[17:36:42.217] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:42.217] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:42.217] Packages: <none>
[17:36:42.217] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:42.217] Resolved: FALSE
[17:36:42.217] Value: <not collected>
[17:36:42.217] Conditions captured: <none>
[17:36:42.217] Early signaling: FALSE
[17:36:42.217] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:42.217] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.228] Chunk #2 of 2 ... DONE
[17:36:42.228] Launching 2 futures (chunks) ... DONE
[17:36:42.228] Resolving 2 futures (chunks) ...
[17:36:42.229] resolve() on list ...
[17:36:42.229]  recursive: 0
[17:36:42.229]  length: 2
[17:36:42.229] 
[17:36:42.229] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.229] - Validating connection of MultisessionFuture
[17:36:42.230] - received message: FutureResult
[17:36:42.230] - Received FutureResult
[17:36:42.230] - Erased future from FutureRegistry
[17:36:42.230] result() for ClusterFuture ...
[17:36:42.230] - result already collected: FutureResult
[17:36:42.230] result() for ClusterFuture ... done
[17:36:42.230] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.230] Future #1
[17:36:42.230] result() for ClusterFuture ...
[17:36:42.231] - result already collected: FutureResult
[17:36:42.231] result() for ClusterFuture ... done
[17:36:42.231] result() for ClusterFuture ...
[17:36:42.231] - result already collected: FutureResult
[17:36:42.231] result() for ClusterFuture ... done
[17:36:42.231] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:42.231] - nx: 2
[17:36:42.231] - relay: TRUE
[17:36:42.231] - stdout: TRUE
[17:36:42.231] - signal: TRUE
[17:36:42.231] - resignal: FALSE
[17:36:42.231] - force: TRUE
[17:36:42.232] - relayed: [n=2] FALSE, FALSE
[17:36:42.232] - queued futures: [n=2] FALSE, FALSE
[17:36:42.232]  - until=1
[17:36:42.232]  - relaying element #1
[17:36:42.232] result() for ClusterFuture ...
[17:36:42.232] - result already collected: FutureResult
[17:36:42.232] result() for ClusterFuture ... done
[17:36:42.232] result() for ClusterFuture ...
[17:36:42.232] - result already collected: FutureResult
[17:36:42.232] result() for ClusterFuture ... done
[17:36:42.232] result() for ClusterFuture ...
[17:36:42.233] - result already collected: FutureResult
[17:36:42.233] result() for ClusterFuture ... done
[17:36:42.233] result() for ClusterFuture ...
[17:36:42.233] - result already collected: FutureResult
[17:36:42.233] result() for ClusterFuture ... done
[17:36:42.233] - relayed: [n=2] TRUE, FALSE
[17:36:42.233] - queued futures: [n=2] TRUE, FALSE
[17:36:42.233] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:42.233]  length: 1 (resolved future 1)
[17:36:42.258] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.258] - Validating connection of MultisessionFuture
[17:36:42.259] - received message: FutureResult
[17:36:42.259] - Received FutureResult
[17:36:42.259] - Erased future from FutureRegistry
[17:36:42.259] result() for ClusterFuture ...
[17:36:42.259] - result already collected: FutureResult
[17:36:42.259] result() for ClusterFuture ... done
[17:36:42.259] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.259] Future #2
[17:36:42.259] result() for ClusterFuture ...
[17:36:42.259] - result already collected: FutureResult
[17:36:42.260] result() for ClusterFuture ... done
[17:36:42.260] result() for ClusterFuture ...
[17:36:42.260] - result already collected: FutureResult
[17:36:42.260] result() for ClusterFuture ... done
[17:36:42.260] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:42.260] - nx: 2
[17:36:42.260] - relay: TRUE
[17:36:42.260] - stdout: TRUE
[17:36:42.260] - signal: TRUE
[17:36:42.260] - resignal: FALSE
[17:36:42.261] - force: TRUE
[17:36:42.261] - relayed: [n=2] TRUE, FALSE
[17:36:42.261] - queued futures: [n=2] TRUE, FALSE
[17:36:42.261]  - until=2
[17:36:42.261]  - relaying element #2
[17:36:42.261] result() for ClusterFuture ...
[17:36:42.261] - result already collected: FutureResult
[17:36:42.261] result() for ClusterFuture ... done
[17:36:42.261] result() for ClusterFuture ...
[17:36:42.261] - result already collected: FutureResult
[17:36:42.261] result() for ClusterFuture ... done
[17:36:42.262] result() for ClusterFuture ...
[17:36:42.262] - result already collected: FutureResult
[17:36:42.262] result() for ClusterFuture ... done
[17:36:42.262] result() for ClusterFuture ...
[17:36:42.262] - result already collected: FutureResult
[17:36:42.262] result() for ClusterFuture ... done
[17:36:42.262] - relayed: [n=2] TRUE, TRUE
[17:36:42.262] - queued futures: [n=2] TRUE, TRUE
[17:36:42.262] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:42.262]  length: 0 (resolved future 2)
[17:36:42.262] Relaying remaining futures
[17:36:42.262] signalConditionsASAP(NULL, pos=0) ...
[17:36:42.263] - nx: 2
[17:36:42.263] - relay: TRUE
[17:36:42.263] - stdout: TRUE
[17:36:42.263] - signal: TRUE
[17:36:42.263] - resignal: FALSE
[17:36:42.263] - force: TRUE
[17:36:42.263] - relayed: [n=2] TRUE, TRUE
[17:36:42.263] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:42.263] - relayed: [n=2] TRUE, TRUE
[17:36:42.263] - queued futures: [n=2] TRUE, TRUE
[17:36:42.263] signalConditionsASAP(NULL, pos=0) ... done
[17:36:42.263] resolve() on list ... DONE
[17:36:42.264] result() for ClusterFuture ...
[17:36:42.264] - result already collected: FutureResult
[17:36:42.264] result() for ClusterFuture ... done
[17:36:42.264] result() for ClusterFuture ...
[17:36:42.264] - result already collected: FutureResult
[17:36:42.264] result() for ClusterFuture ... done
[17:36:42.264] result() for ClusterFuture ...
[17:36:42.264] - result already collected: FutureResult
[17:36:42.264] result() for ClusterFuture ... done
[17:36:42.264] result() for ClusterFuture ...
[17:36:42.264] - result already collected: FutureResult
[17:36:42.265] result() for ClusterFuture ... done
[17:36:42.265]  - Number of value chunks collected: 2
[17:36:42.265] Resolving 2 futures (chunks) ... DONE
[17:36:42.265] Reducing values from 2 chunks ...
[17:36:42.265]  - Number of values collected after concatenation: 6
[17:36:42.265]  - Number of values expected: 6
[17:36:42.265] Reducing values from 2 chunks ... DONE
[17:36:42.265] future_lapply() ... DONE
[17:36:42.265] future_by_internal() ... DONE
[17:36:42.266] future_by_internal() ...
[17:36:42.267] future_lapply() ...
[17:36:42.271] Number of chunks: 2
[17:36:42.271] getGlobalsAndPackagesXApply() ...
[17:36:42.271]  - future.globals: TRUE
[17:36:42.271] getGlobalsAndPackages() ...
[17:36:42.271] Searching for globals...
[17:36:42.273] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:42.273] Searching for globals ... DONE
[17:36:42.273] Resolving globals: FALSE
[17:36:42.274] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:36:42.274] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:36:42.274] - globals: [1] ‘FUN’
[17:36:42.274] - packages: [1] ‘stats’
[17:36:42.274] getGlobalsAndPackages() ... DONE
[17:36:42.274]  - globals found/used: [n=1] ‘FUN’
[17:36:42.275]  - needed namespaces: [n=1] ‘stats’
[17:36:42.275] Finding globals ... DONE
[17:36:42.275]  - use_args: TRUE
[17:36:42.275]  - Getting '...' globals ...
[17:36:42.275] resolve() on list ...
[17:36:42.275]  recursive: 0
[17:36:42.275]  length: 1
[17:36:42.275]  elements: ‘...’
[17:36:42.275]  length: 0 (resolved future 1)
[17:36:42.276] resolve() on list ... DONE
[17:36:42.276]    - '...' content: [n=1] ‘singular.ok’
[17:36:42.276] List of 1
[17:36:42.276]  $ ...:List of 1
[17:36:42.276]   ..$ singular.ok: logi FALSE
[17:36:42.276]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:42.276]  - attr(*, "where")=List of 1
[17:36:42.276]   ..$ ...:<environment: 0x5622fe3e4cb0> 
[17:36:42.276]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:42.276]  - attr(*, "resolved")= logi TRUE
[17:36:42.276]  - attr(*, "total_size")= num NA
[17:36:42.279]  - Getting '...' globals ... DONE
[17:36:42.279] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:42.279] List of 2
[17:36:42.279]  $ ...future.FUN:function (x, ...)  
[17:36:42.279]  $ ...          :List of 1
[17:36:42.279]   ..$ singular.ok: logi FALSE
[17:36:42.279]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:42.279]  - attr(*, "where")=List of 2
[17:36:42.279]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:42.279]   ..$ ...          :<environment: 0x5622fe3e4cb0> 
[17:36:42.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:42.279]  - attr(*, "resolved")= logi FALSE
[17:36:42.279]  - attr(*, "total_size")= num 5384
[17:36:42.282] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:42.282] getGlobalsAndPackagesXApply() ... DONE
[17:36:42.282] Number of futures (= number of chunks): 2
[17:36:42.282] Launching 2 futures (chunks) ...
[17:36:42.282] Chunk #1 of 2 ...
[17:36:42.282]  - Finding globals in 'X' for chunk #1 ...
[17:36:42.283] getGlobalsAndPackages() ...
[17:36:42.283] Searching for globals...
[17:36:42.283] 
[17:36:42.283] Searching for globals ... DONE
[17:36:42.283] - globals: [0] <none>
[17:36:42.283] getGlobalsAndPackages() ... DONE
[17:36:42.283]    + additional globals found: [n=0] 
[17:36:42.283]    + additional namespaces needed: [n=0] 
[17:36:42.284]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:42.284]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:42.284]  - seeds: <none>
[17:36:42.284]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.284] getGlobalsAndPackages() ...
[17:36:42.284] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.284] Resolving globals: FALSE
[17:36:42.284] Tweak future expression to call with '...' arguments ...
[17:36:42.284] {
[17:36:42.284]     do.call(function(...) {
[17:36:42.284]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.284]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.284]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.284]             on.exit(options(oopts), add = TRUE)
[17:36:42.284]         }
[17:36:42.284]         {
[17:36:42.284]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.284]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.284]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.284]             })
[17:36:42.284]         }
[17:36:42.284]     }, args = future.call.arguments)
[17:36:42.284] }
[17:36:42.285] Tweak future expression to call with '...' arguments ... DONE
[17:36:42.285] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.285] 
[17:36:42.285] getGlobalsAndPackages() ... DONE
[17:36:42.285] run() for ‘Future’ ...
[17:36:42.286] - state: ‘created’
[17:36:42.286] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:42.301] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:42.302]   - Field: ‘node’
[17:36:42.302]   - Field: ‘label’
[17:36:42.302]   - Field: ‘local’
[17:36:42.302]   - Field: ‘owner’
[17:36:42.302]   - Field: ‘envir’
[17:36:42.302]   - Field: ‘workers’
[17:36:42.302]   - Field: ‘packages’
[17:36:42.302]   - Field: ‘gc’
[17:36:42.302]   - Field: ‘conditions’
[17:36:42.302]   - Field: ‘persistent’
[17:36:42.303]   - Field: ‘expr’
[17:36:42.303]   - Field: ‘uuid’
[17:36:42.303]   - Field: ‘seed’
[17:36:42.303]   - Field: ‘version’
[17:36:42.303]   - Field: ‘result’
[17:36:42.303]   - Field: ‘asynchronous’
[17:36:42.303]   - Field: ‘calls’
[17:36:42.303]   - Field: ‘globals’
[17:36:42.303]   - Field: ‘stdout’
[17:36:42.303]   - Field: ‘earlySignal’
[17:36:42.303]   - Field: ‘lazy’
[17:36:42.303]   - Field: ‘state’
[17:36:42.304] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:42.304] - Launch lazy future ...
[17:36:42.304] Packages needed by the future expression (n = 1): ‘stats’
[17:36:42.304] Packages needed by future strategies (n = 0): <none>
[17:36:42.305] {
[17:36:42.305]     {
[17:36:42.305]         {
[17:36:42.305]             ...future.startTime <- base::Sys.time()
[17:36:42.305]             {
[17:36:42.305]                 {
[17:36:42.305]                   {
[17:36:42.305]                     {
[17:36:42.305]                       {
[17:36:42.305]                         base::local({
[17:36:42.305]                           has_future <- base::requireNamespace("future", 
[17:36:42.305]                             quietly = TRUE)
[17:36:42.305]                           if (has_future) {
[17:36:42.305]                             ns <- base::getNamespace("future")
[17:36:42.305]                             version <- ns[[".package"]][["version"]]
[17:36:42.305]                             if (is.null(version)) 
[17:36:42.305]                               version <- utils::packageVersion("future")
[17:36:42.305]                           }
[17:36:42.305]                           else {
[17:36:42.305]                             version <- NULL
[17:36:42.305]                           }
[17:36:42.305]                           if (!has_future || version < "1.8.0") {
[17:36:42.305]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:42.305]                               "", base::R.version$version.string), 
[17:36:42.305]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:42.305]                                 base::R.version$platform, 8 * 
[17:36:42.305]                                   base::.Machine$sizeof.pointer), 
[17:36:42.305]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:42.305]                                 "release", "version")], collapse = " "), 
[17:36:42.305]                               hostname = base::Sys.info()[["nodename"]])
[17:36:42.305]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:42.305]                               info)
[17:36:42.305]                             info <- base::paste(info, collapse = "; ")
[17:36:42.305]                             if (!has_future) {
[17:36:42.305]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:42.305]                                 info)
[17:36:42.305]                             }
[17:36:42.305]                             else {
[17:36:42.305]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:42.305]                                 info, version)
[17:36:42.305]                             }
[17:36:42.305]                             base::stop(msg)
[17:36:42.305]                           }
[17:36:42.305]                         })
[17:36:42.305]                       }
[17:36:42.305]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:42.305]                       base::options(mc.cores = 1L)
[17:36:42.305]                     }
[17:36:42.305]                     base::local({
[17:36:42.305]                       for (pkg in "stats") {
[17:36:42.305]                         base::loadNamespace(pkg)
[17:36:42.305]                         base::library(pkg, character.only = TRUE)
[17:36:42.305]                       }
[17:36:42.305]                     })
[17:36:42.305]                   }
[17:36:42.305]                   ...future.strategy.old <- future::plan("list")
[17:36:42.305]                   options(future.plan = NULL)
[17:36:42.305]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.305]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:42.305]                 }
[17:36:42.305]                 ...future.workdir <- getwd()
[17:36:42.305]             }
[17:36:42.305]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:42.305]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:42.305]         }
[17:36:42.305]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:42.305]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:42.305]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:42.305]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:42.305]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:42.305]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:42.305]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:42.305]             base::names(...future.oldOptions))
[17:36:42.305]     }
[17:36:42.305]     if (FALSE) {
[17:36:42.305]     }
[17:36:42.305]     else {
[17:36:42.305]         if (TRUE) {
[17:36:42.305]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:42.305]                 open = "w")
[17:36:42.305]         }
[17:36:42.305]         else {
[17:36:42.305]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:42.305]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:42.305]         }
[17:36:42.305]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:42.305]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:42.305]             base::sink(type = "output", split = FALSE)
[17:36:42.305]             base::close(...future.stdout)
[17:36:42.305]         }, add = TRUE)
[17:36:42.305]     }
[17:36:42.305]     ...future.frame <- base::sys.nframe()
[17:36:42.305]     ...future.conditions <- base::list()
[17:36:42.305]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:42.305]     if (FALSE) {
[17:36:42.305]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:42.305]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:42.305]     }
[17:36:42.305]     ...future.result <- base::tryCatch({
[17:36:42.305]         base::withCallingHandlers({
[17:36:42.305]             ...future.value <- base::withVisible(base::local({
[17:36:42.305]                 ...future.makeSendCondition <- base::local({
[17:36:42.305]                   sendCondition <- NULL
[17:36:42.305]                   function(frame = 1L) {
[17:36:42.305]                     if (is.function(sendCondition)) 
[17:36:42.305]                       return(sendCondition)
[17:36:42.305]                     ns <- getNamespace("parallel")
[17:36:42.305]                     if (exists("sendData", mode = "function", 
[17:36:42.305]                       envir = ns)) {
[17:36:42.305]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:42.305]                         envir = ns)
[17:36:42.305]                       envir <- sys.frame(frame)
[17:36:42.305]                       master <- NULL
[17:36:42.305]                       while (!identical(envir, .GlobalEnv) && 
[17:36:42.305]                         !identical(envir, emptyenv())) {
[17:36:42.305]                         if (exists("master", mode = "list", envir = envir, 
[17:36:42.305]                           inherits = FALSE)) {
[17:36:42.305]                           master <- get("master", mode = "list", 
[17:36:42.305]                             envir = envir, inherits = FALSE)
[17:36:42.305]                           if (inherits(master, c("SOCKnode", 
[17:36:42.305]                             "SOCK0node"))) {
[17:36:42.305]                             sendCondition <<- function(cond) {
[17:36:42.305]                               data <- list(type = "VALUE", value = cond, 
[17:36:42.305]                                 success = TRUE)
[17:36:42.305]                               parallel_sendData(master, data)
[17:36:42.305]                             }
[17:36:42.305]                             return(sendCondition)
[17:36:42.305]                           }
[17:36:42.305]                         }
[17:36:42.305]                         frame <- frame + 1L
[17:36:42.305]                         envir <- sys.frame(frame)
[17:36:42.305]                       }
[17:36:42.305]                     }
[17:36:42.305]                     sendCondition <<- function(cond) NULL
[17:36:42.305]                   }
[17:36:42.305]                 })
[17:36:42.305]                 withCallingHandlers({
[17:36:42.305]                   {
[17:36:42.305]                     do.call(function(...) {
[17:36:42.305]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.305]                       if (!identical(...future.globals.maxSize.org, 
[17:36:42.305]                         ...future.globals.maxSize)) {
[17:36:42.305]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.305]                         on.exit(options(oopts), add = TRUE)
[17:36:42.305]                       }
[17:36:42.305]                       {
[17:36:42.305]                         lapply(seq_along(...future.elements_ii), 
[17:36:42.305]                           FUN = function(jj) {
[17:36:42.305]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.305]                             ...future.FUN(...future.X_jj, ...)
[17:36:42.305]                           })
[17:36:42.305]                       }
[17:36:42.305]                     }, args = future.call.arguments)
[17:36:42.305]                   }
[17:36:42.305]                 }, immediateCondition = function(cond) {
[17:36:42.305]                   sendCondition <- ...future.makeSendCondition()
[17:36:42.305]                   sendCondition(cond)
[17:36:42.305]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.305]                   {
[17:36:42.305]                     inherits <- base::inherits
[17:36:42.305]                     invokeRestart <- base::invokeRestart
[17:36:42.305]                     is.null <- base::is.null
[17:36:42.305]                     muffled <- FALSE
[17:36:42.305]                     if (inherits(cond, "message")) {
[17:36:42.305]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:42.305]                       if (muffled) 
[17:36:42.305]                         invokeRestart("muffleMessage")
[17:36:42.305]                     }
[17:36:42.305]                     else if (inherits(cond, "warning")) {
[17:36:42.305]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:42.305]                       if (muffled) 
[17:36:42.305]                         invokeRestart("muffleWarning")
[17:36:42.305]                     }
[17:36:42.305]                     else if (inherits(cond, "condition")) {
[17:36:42.305]                       if (!is.null(pattern)) {
[17:36:42.305]                         computeRestarts <- base::computeRestarts
[17:36:42.305]                         grepl <- base::grepl
[17:36:42.305]                         restarts <- computeRestarts(cond)
[17:36:42.305]                         for (restart in restarts) {
[17:36:42.305]                           name <- restart$name
[17:36:42.305]                           if (is.null(name)) 
[17:36:42.305]                             next
[17:36:42.305]                           if (!grepl(pattern, name)) 
[17:36:42.305]                             next
[17:36:42.305]                           invokeRestart(restart)
[17:36:42.305]                           muffled <- TRUE
[17:36:42.305]                           break
[17:36:42.305]                         }
[17:36:42.305]                       }
[17:36:42.305]                     }
[17:36:42.305]                     invisible(muffled)
[17:36:42.305]                   }
[17:36:42.305]                   muffleCondition(cond)
[17:36:42.305]                 })
[17:36:42.305]             }))
[17:36:42.305]             future::FutureResult(value = ...future.value$value, 
[17:36:42.305]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.305]                   ...future.rng), globalenv = if (FALSE) 
[17:36:42.305]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:42.305]                     ...future.globalenv.names))
[17:36:42.305]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:42.305]         }, condition = base::local({
[17:36:42.305]             c <- base::c
[17:36:42.305]             inherits <- base::inherits
[17:36:42.305]             invokeRestart <- base::invokeRestart
[17:36:42.305]             length <- base::length
[17:36:42.305]             list <- base::list
[17:36:42.305]             seq.int <- base::seq.int
[17:36:42.305]             signalCondition <- base::signalCondition
[17:36:42.305]             sys.calls <- base::sys.calls
[17:36:42.305]             `[[` <- base::`[[`
[17:36:42.305]             `+` <- base::`+`
[17:36:42.305]             `<<-` <- base::`<<-`
[17:36:42.305]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:42.305]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:42.305]                   3L)]
[17:36:42.305]             }
[17:36:42.305]             function(cond) {
[17:36:42.305]                 is_error <- inherits(cond, "error")
[17:36:42.305]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:42.305]                   NULL)
[17:36:42.305]                 if (is_error) {
[17:36:42.305]                   sessionInformation <- function() {
[17:36:42.305]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:42.305]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:42.305]                       search = base::search(), system = base::Sys.info())
[17:36:42.305]                   }
[17:36:42.305]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.305]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:42.305]                     cond$call), session = sessionInformation(), 
[17:36:42.305]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:42.305]                   signalCondition(cond)
[17:36:42.305]                 }
[17:36:42.305]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:42.305]                 "immediateCondition"))) {
[17:36:42.305]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:42.305]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.305]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:42.305]                   if (TRUE && !signal) {
[17:36:42.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.305]                     {
[17:36:42.305]                       inherits <- base::inherits
[17:36:42.305]                       invokeRestart <- base::invokeRestart
[17:36:42.305]                       is.null <- base::is.null
[17:36:42.305]                       muffled <- FALSE
[17:36:42.305]                       if (inherits(cond, "message")) {
[17:36:42.305]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.305]                         if (muffled) 
[17:36:42.305]                           invokeRestart("muffleMessage")
[17:36:42.305]                       }
[17:36:42.305]                       else if (inherits(cond, "warning")) {
[17:36:42.305]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.305]                         if (muffled) 
[17:36:42.305]                           invokeRestart("muffleWarning")
[17:36:42.305]                       }
[17:36:42.305]                       else if (inherits(cond, "condition")) {
[17:36:42.305]                         if (!is.null(pattern)) {
[17:36:42.305]                           computeRestarts <- base::computeRestarts
[17:36:42.305]                           grepl <- base::grepl
[17:36:42.305]                           restarts <- computeRestarts(cond)
[17:36:42.305]                           for (restart in restarts) {
[17:36:42.305]                             name <- restart$name
[17:36:42.305]                             if (is.null(name)) 
[17:36:42.305]                               next
[17:36:42.305]                             if (!grepl(pattern, name)) 
[17:36:42.305]                               next
[17:36:42.305]                             invokeRestart(restart)
[17:36:42.305]                             muffled <- TRUE
[17:36:42.305]                             break
[17:36:42.305]                           }
[17:36:42.305]                         }
[17:36:42.305]                       }
[17:36:42.305]                       invisible(muffled)
[17:36:42.305]                     }
[17:36:42.305]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.305]                   }
[17:36:42.305]                 }
[17:36:42.305]                 else {
[17:36:42.305]                   if (TRUE) {
[17:36:42.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.305]                     {
[17:36:42.305]                       inherits <- base::inherits
[17:36:42.305]                       invokeRestart <- base::invokeRestart
[17:36:42.305]                       is.null <- base::is.null
[17:36:42.305]                       muffled <- FALSE
[17:36:42.305]                       if (inherits(cond, "message")) {
[17:36:42.305]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.305]                         if (muffled) 
[17:36:42.305]                           invokeRestart("muffleMessage")
[17:36:42.305]                       }
[17:36:42.305]                       else if (inherits(cond, "warning")) {
[17:36:42.305]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.305]                         if (muffled) 
[17:36:42.305]                           invokeRestart("muffleWarning")
[17:36:42.305]                       }
[17:36:42.305]                       else if (inherits(cond, "condition")) {
[17:36:42.305]                         if (!is.null(pattern)) {
[17:36:42.305]                           computeRestarts <- base::computeRestarts
[17:36:42.305]                           grepl <- base::grepl
[17:36:42.305]                           restarts <- computeRestarts(cond)
[17:36:42.305]                           for (restart in restarts) {
[17:36:42.305]                             name <- restart$name
[17:36:42.305]                             if (is.null(name)) 
[17:36:42.305]                               next
[17:36:42.305]                             if (!grepl(pattern, name)) 
[17:36:42.305]                               next
[17:36:42.305]                             invokeRestart(restart)
[17:36:42.305]                             muffled <- TRUE
[17:36:42.305]                             break
[17:36:42.305]                           }
[17:36:42.305]                         }
[17:36:42.305]                       }
[17:36:42.305]                       invisible(muffled)
[17:36:42.305]                     }
[17:36:42.305]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.305]                   }
[17:36:42.305]                 }
[17:36:42.305]             }
[17:36:42.305]         }))
[17:36:42.305]     }, error = function(ex) {
[17:36:42.305]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:42.305]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.305]                 ...future.rng), started = ...future.startTime, 
[17:36:42.305]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:42.305]             version = "1.8"), class = "FutureResult")
[17:36:42.305]     }, finally = {
[17:36:42.305]         if (!identical(...future.workdir, getwd())) 
[17:36:42.305]             setwd(...future.workdir)
[17:36:42.305]         {
[17:36:42.305]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:42.305]                 ...future.oldOptions$nwarnings <- NULL
[17:36:42.305]             }
[17:36:42.305]             base::options(...future.oldOptions)
[17:36:42.305]             if (.Platform$OS.type == "windows") {
[17:36:42.305]                 old_names <- names(...future.oldEnvVars)
[17:36:42.305]                 envs <- base::Sys.getenv()
[17:36:42.305]                 names <- names(envs)
[17:36:42.305]                 common <- intersect(names, old_names)
[17:36:42.305]                 added <- setdiff(names, old_names)
[17:36:42.305]                 removed <- setdiff(old_names, names)
[17:36:42.305]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:42.305]                   envs[common]]
[17:36:42.305]                 NAMES <- toupper(changed)
[17:36:42.305]                 args <- list()
[17:36:42.305]                 for (kk in seq_along(NAMES)) {
[17:36:42.305]                   name <- changed[[kk]]
[17:36:42.305]                   NAME <- NAMES[[kk]]
[17:36:42.305]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.305]                     next
[17:36:42.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.305]                 }
[17:36:42.305]                 NAMES <- toupper(added)
[17:36:42.305]                 for (kk in seq_along(NAMES)) {
[17:36:42.305]                   name <- added[[kk]]
[17:36:42.305]                   NAME <- NAMES[[kk]]
[17:36:42.305]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.305]                     next
[17:36:42.305]                   args[[name]] <- ""
[17:36:42.305]                 }
[17:36:42.305]                 NAMES <- toupper(removed)
[17:36:42.305]                 for (kk in seq_along(NAMES)) {
[17:36:42.305]                   name <- removed[[kk]]
[17:36:42.305]                   NAME <- NAMES[[kk]]
[17:36:42.305]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.305]                     next
[17:36:42.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.305]                 }
[17:36:42.305]                 if (length(args) > 0) 
[17:36:42.305]                   base::do.call(base::Sys.setenv, args = args)
[17:36:42.305]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:42.305]             }
[17:36:42.305]             else {
[17:36:42.305]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:42.305]             }
[17:36:42.305]             {
[17:36:42.305]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:42.305]                   0L) {
[17:36:42.305]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:42.305]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:42.305]                   base::options(opts)
[17:36:42.305]                 }
[17:36:42.305]                 {
[17:36:42.305]                   {
[17:36:42.305]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:42.305]                     NULL
[17:36:42.305]                   }
[17:36:42.305]                   options(future.plan = NULL)
[17:36:42.305]                   if (is.na(NA_character_)) 
[17:36:42.305]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.305]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:42.305]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:42.305]                     .init = FALSE)
[17:36:42.305]                 }
[17:36:42.305]             }
[17:36:42.305]         }
[17:36:42.305]     })
[17:36:42.305]     if (TRUE) {
[17:36:42.305]         base::sink(type = "output", split = FALSE)
[17:36:42.305]         if (TRUE) {
[17:36:42.305]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:42.305]         }
[17:36:42.305]         else {
[17:36:42.305]             ...future.result["stdout"] <- base::list(NULL)
[17:36:42.305]         }
[17:36:42.305]         base::close(...future.stdout)
[17:36:42.305]         ...future.stdout <- NULL
[17:36:42.305]     }
[17:36:42.305]     ...future.result$conditions <- ...future.conditions
[17:36:42.305]     ...future.result$finished <- base::Sys.time()
[17:36:42.305]     ...future.result
[17:36:42.305] }
[17:36:42.307] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[17:36:42.307] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[17:36:42.308] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[17:36:42.308] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:36:42.308] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:36:42.309] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:36:42.309] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:36:42.309] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:42.309] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.309] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:36:42.310] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.310] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[17:36:42.310] MultisessionFuture started
[17:36:42.310] - Launch lazy future ... done
[17:36:42.310] run() for ‘MultisessionFuture’ ... done
[17:36:42.311] Created future:
[17:36:42.311] MultisessionFuture:
[17:36:42.311] Label: ‘future_by-1’
[17:36:42.311] Expression:
[17:36:42.311] {
[17:36:42.311]     do.call(function(...) {
[17:36:42.311]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.311]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.311]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.311]             on.exit(options(oopts), add = TRUE)
[17:36:42.311]         }
[17:36:42.311]         {
[17:36:42.311]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.311]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.311]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.311]             })
[17:36:42.311]         }
[17:36:42.311]     }, args = future.call.arguments)
[17:36:42.311] }
[17:36:42.311] Lazy evaluation: FALSE
[17:36:42.311] Asynchronous evaluation: TRUE
[17:36:42.311] Local evaluation: TRUE
[17:36:42.311] Environment: R_GlobalEnv
[17:36:42.311] Capture standard output: TRUE
[17:36:42.311] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:42.311] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:42.311] Packages: 1 packages (‘stats’)
[17:36:42.311] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:42.311] Resolved: FALSE
[17:36:42.311] Value: <not collected>
[17:36:42.311] Conditions captured: <none>
[17:36:42.311] Early signaling: FALSE
[17:36:42.311] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:42.311] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.322] Chunk #1 of 2 ... DONE
[17:36:42.322] Chunk #2 of 2 ...
[17:36:42.322]  - Finding globals in 'X' for chunk #2 ...
[17:36:42.322] getGlobalsAndPackages() ...
[17:36:42.323] Searching for globals...
[17:36:42.323] 
[17:36:42.323] Searching for globals ... DONE
[17:36:42.323] - globals: [0] <none>
[17:36:42.323] getGlobalsAndPackages() ... DONE
[17:36:42.323]    + additional globals found: [n=0] 
[17:36:42.323]    + additional namespaces needed: [n=0] 
[17:36:42.324]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:42.324]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:42.324]  - seeds: <none>
[17:36:42.324]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.324] getGlobalsAndPackages() ...
[17:36:42.324] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.324] Resolving globals: FALSE
[17:36:42.324] Tweak future expression to call with '...' arguments ...
[17:36:42.324] {
[17:36:42.324]     do.call(function(...) {
[17:36:42.324]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.324]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.324]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.324]             on.exit(options(oopts), add = TRUE)
[17:36:42.324]         }
[17:36:42.324]         {
[17:36:42.324]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.324]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.324]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.324]             })
[17:36:42.324]         }
[17:36:42.324]     }, args = future.call.arguments)
[17:36:42.324] }
[17:36:42.325] Tweak future expression to call with '...' arguments ... DONE
[17:36:42.325] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.325] 
[17:36:42.325] getGlobalsAndPackages() ... DONE
[17:36:42.326] run() for ‘Future’ ...
[17:36:42.326] - state: ‘created’
[17:36:42.326] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:42.340] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.340] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:42.340]   - Field: ‘node’
[17:36:42.340]   - Field: ‘label’
[17:36:42.340]   - Field: ‘local’
[17:36:42.340]   - Field: ‘owner’
[17:36:42.340]   - Field: ‘envir’
[17:36:42.341]   - Field: ‘workers’
[17:36:42.341]   - Field: ‘packages’
[17:36:42.341]   - Field: ‘gc’
[17:36:42.341]   - Field: ‘conditions’
[17:36:42.341]   - Field: ‘persistent’
[17:36:42.341]   - Field: ‘expr’
[17:36:42.341]   - Field: ‘uuid’
[17:36:42.341]   - Field: ‘seed’
[17:36:42.341]   - Field: ‘version’
[17:36:42.341]   - Field: ‘result’
[17:36:42.341]   - Field: ‘asynchronous’
[17:36:42.342]   - Field: ‘calls’
[17:36:42.342]   - Field: ‘globals’
[17:36:42.342]   - Field: ‘stdout’
[17:36:42.342]   - Field: ‘earlySignal’
[17:36:42.342]   - Field: ‘lazy’
[17:36:42.342]   - Field: ‘state’
[17:36:42.342] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:42.342] - Launch lazy future ...
[17:36:42.342] Packages needed by the future expression (n = 1): ‘stats’
[17:36:42.343] Packages needed by future strategies (n = 0): <none>
[17:36:42.343] {
[17:36:42.343]     {
[17:36:42.343]         {
[17:36:42.343]             ...future.startTime <- base::Sys.time()
[17:36:42.343]             {
[17:36:42.343]                 {
[17:36:42.343]                   {
[17:36:42.343]                     {
[17:36:42.343]                       {
[17:36:42.343]                         base::local({
[17:36:42.343]                           has_future <- base::requireNamespace("future", 
[17:36:42.343]                             quietly = TRUE)
[17:36:42.343]                           if (has_future) {
[17:36:42.343]                             ns <- base::getNamespace("future")
[17:36:42.343]                             version <- ns[[".package"]][["version"]]
[17:36:42.343]                             if (is.null(version)) 
[17:36:42.343]                               version <- utils::packageVersion("future")
[17:36:42.343]                           }
[17:36:42.343]                           else {
[17:36:42.343]                             version <- NULL
[17:36:42.343]                           }
[17:36:42.343]                           if (!has_future || version < "1.8.0") {
[17:36:42.343]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:42.343]                               "", base::R.version$version.string), 
[17:36:42.343]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:42.343]                                 base::R.version$platform, 8 * 
[17:36:42.343]                                   base::.Machine$sizeof.pointer), 
[17:36:42.343]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:42.343]                                 "release", "version")], collapse = " "), 
[17:36:42.343]                               hostname = base::Sys.info()[["nodename"]])
[17:36:42.343]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:42.343]                               info)
[17:36:42.343]                             info <- base::paste(info, collapse = "; ")
[17:36:42.343]                             if (!has_future) {
[17:36:42.343]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:42.343]                                 info)
[17:36:42.343]                             }
[17:36:42.343]                             else {
[17:36:42.343]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:42.343]                                 info, version)
[17:36:42.343]                             }
[17:36:42.343]                             base::stop(msg)
[17:36:42.343]                           }
[17:36:42.343]                         })
[17:36:42.343]                       }
[17:36:42.343]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:42.343]                       base::options(mc.cores = 1L)
[17:36:42.343]                     }
[17:36:42.343]                     base::local({
[17:36:42.343]                       for (pkg in "stats") {
[17:36:42.343]                         base::loadNamespace(pkg)
[17:36:42.343]                         base::library(pkg, character.only = TRUE)
[17:36:42.343]                       }
[17:36:42.343]                     })
[17:36:42.343]                   }
[17:36:42.343]                   ...future.strategy.old <- future::plan("list")
[17:36:42.343]                   options(future.plan = NULL)
[17:36:42.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:42.343]                 }
[17:36:42.343]                 ...future.workdir <- getwd()
[17:36:42.343]             }
[17:36:42.343]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:42.343]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:42.343]         }
[17:36:42.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:42.343]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:42.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:42.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:42.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:42.343]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:42.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:42.343]             base::names(...future.oldOptions))
[17:36:42.343]     }
[17:36:42.343]     if (FALSE) {
[17:36:42.343]     }
[17:36:42.343]     else {
[17:36:42.343]         if (TRUE) {
[17:36:42.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:42.343]                 open = "w")
[17:36:42.343]         }
[17:36:42.343]         else {
[17:36:42.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:42.343]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:42.343]         }
[17:36:42.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:42.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:42.343]             base::sink(type = "output", split = FALSE)
[17:36:42.343]             base::close(...future.stdout)
[17:36:42.343]         }, add = TRUE)
[17:36:42.343]     }
[17:36:42.343]     ...future.frame <- base::sys.nframe()
[17:36:42.343]     ...future.conditions <- base::list()
[17:36:42.343]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:42.343]     if (FALSE) {
[17:36:42.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:42.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:42.343]     }
[17:36:42.343]     ...future.result <- base::tryCatch({
[17:36:42.343]         base::withCallingHandlers({
[17:36:42.343]             ...future.value <- base::withVisible(base::local({
[17:36:42.343]                 ...future.makeSendCondition <- base::local({
[17:36:42.343]                   sendCondition <- NULL
[17:36:42.343]                   function(frame = 1L) {
[17:36:42.343]                     if (is.function(sendCondition)) 
[17:36:42.343]                       return(sendCondition)
[17:36:42.343]                     ns <- getNamespace("parallel")
[17:36:42.343]                     if (exists("sendData", mode = "function", 
[17:36:42.343]                       envir = ns)) {
[17:36:42.343]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:42.343]                         envir = ns)
[17:36:42.343]                       envir <- sys.frame(frame)
[17:36:42.343]                       master <- NULL
[17:36:42.343]                       while (!identical(envir, .GlobalEnv) && 
[17:36:42.343]                         !identical(envir, emptyenv())) {
[17:36:42.343]                         if (exists("master", mode = "list", envir = envir, 
[17:36:42.343]                           inherits = FALSE)) {
[17:36:42.343]                           master <- get("master", mode = "list", 
[17:36:42.343]                             envir = envir, inherits = FALSE)
[17:36:42.343]                           if (inherits(master, c("SOCKnode", 
[17:36:42.343]                             "SOCK0node"))) {
[17:36:42.343]                             sendCondition <<- function(cond) {
[17:36:42.343]                               data <- list(type = "VALUE", value = cond, 
[17:36:42.343]                                 success = TRUE)
[17:36:42.343]                               parallel_sendData(master, data)
[17:36:42.343]                             }
[17:36:42.343]                             return(sendCondition)
[17:36:42.343]                           }
[17:36:42.343]                         }
[17:36:42.343]                         frame <- frame + 1L
[17:36:42.343]                         envir <- sys.frame(frame)
[17:36:42.343]                       }
[17:36:42.343]                     }
[17:36:42.343]                     sendCondition <<- function(cond) NULL
[17:36:42.343]                   }
[17:36:42.343]                 })
[17:36:42.343]                 withCallingHandlers({
[17:36:42.343]                   {
[17:36:42.343]                     do.call(function(...) {
[17:36:42.343]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.343]                       if (!identical(...future.globals.maxSize.org, 
[17:36:42.343]                         ...future.globals.maxSize)) {
[17:36:42.343]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.343]                         on.exit(options(oopts), add = TRUE)
[17:36:42.343]                       }
[17:36:42.343]                       {
[17:36:42.343]                         lapply(seq_along(...future.elements_ii), 
[17:36:42.343]                           FUN = function(jj) {
[17:36:42.343]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.343]                             ...future.FUN(...future.X_jj, ...)
[17:36:42.343]                           })
[17:36:42.343]                       }
[17:36:42.343]                     }, args = future.call.arguments)
[17:36:42.343]                   }
[17:36:42.343]                 }, immediateCondition = function(cond) {
[17:36:42.343]                   sendCondition <- ...future.makeSendCondition()
[17:36:42.343]                   sendCondition(cond)
[17:36:42.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.343]                   {
[17:36:42.343]                     inherits <- base::inherits
[17:36:42.343]                     invokeRestart <- base::invokeRestart
[17:36:42.343]                     is.null <- base::is.null
[17:36:42.343]                     muffled <- FALSE
[17:36:42.343]                     if (inherits(cond, "message")) {
[17:36:42.343]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:42.343]                       if (muffled) 
[17:36:42.343]                         invokeRestart("muffleMessage")
[17:36:42.343]                     }
[17:36:42.343]                     else if (inherits(cond, "warning")) {
[17:36:42.343]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:42.343]                       if (muffled) 
[17:36:42.343]                         invokeRestart("muffleWarning")
[17:36:42.343]                     }
[17:36:42.343]                     else if (inherits(cond, "condition")) {
[17:36:42.343]                       if (!is.null(pattern)) {
[17:36:42.343]                         computeRestarts <- base::computeRestarts
[17:36:42.343]                         grepl <- base::grepl
[17:36:42.343]                         restarts <- computeRestarts(cond)
[17:36:42.343]                         for (restart in restarts) {
[17:36:42.343]                           name <- restart$name
[17:36:42.343]                           if (is.null(name)) 
[17:36:42.343]                             next
[17:36:42.343]                           if (!grepl(pattern, name)) 
[17:36:42.343]                             next
[17:36:42.343]                           invokeRestart(restart)
[17:36:42.343]                           muffled <- TRUE
[17:36:42.343]                           break
[17:36:42.343]                         }
[17:36:42.343]                       }
[17:36:42.343]                     }
[17:36:42.343]                     invisible(muffled)
[17:36:42.343]                   }
[17:36:42.343]                   muffleCondition(cond)
[17:36:42.343]                 })
[17:36:42.343]             }))
[17:36:42.343]             future::FutureResult(value = ...future.value$value, 
[17:36:42.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.343]                   ...future.rng), globalenv = if (FALSE) 
[17:36:42.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:42.343]                     ...future.globalenv.names))
[17:36:42.343]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:42.343]         }, condition = base::local({
[17:36:42.343]             c <- base::c
[17:36:42.343]             inherits <- base::inherits
[17:36:42.343]             invokeRestart <- base::invokeRestart
[17:36:42.343]             length <- base::length
[17:36:42.343]             list <- base::list
[17:36:42.343]             seq.int <- base::seq.int
[17:36:42.343]             signalCondition <- base::signalCondition
[17:36:42.343]             sys.calls <- base::sys.calls
[17:36:42.343]             `[[` <- base::`[[`
[17:36:42.343]             `+` <- base::`+`
[17:36:42.343]             `<<-` <- base::`<<-`
[17:36:42.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:42.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:42.343]                   3L)]
[17:36:42.343]             }
[17:36:42.343]             function(cond) {
[17:36:42.343]                 is_error <- inherits(cond, "error")
[17:36:42.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:42.343]                   NULL)
[17:36:42.343]                 if (is_error) {
[17:36:42.343]                   sessionInformation <- function() {
[17:36:42.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:42.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:42.343]                       search = base::search(), system = base::Sys.info())
[17:36:42.343]                   }
[17:36:42.343]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:42.343]                     cond$call), session = sessionInformation(), 
[17:36:42.343]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:42.343]                   signalCondition(cond)
[17:36:42.343]                 }
[17:36:42.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:42.343]                 "immediateCondition"))) {
[17:36:42.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:42.343]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:42.343]                   if (TRUE && !signal) {
[17:36:42.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.343]                     {
[17:36:42.343]                       inherits <- base::inherits
[17:36:42.343]                       invokeRestart <- base::invokeRestart
[17:36:42.343]                       is.null <- base::is.null
[17:36:42.343]                       muffled <- FALSE
[17:36:42.343]                       if (inherits(cond, "message")) {
[17:36:42.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.343]                         if (muffled) 
[17:36:42.343]                           invokeRestart("muffleMessage")
[17:36:42.343]                       }
[17:36:42.343]                       else if (inherits(cond, "warning")) {
[17:36:42.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.343]                         if (muffled) 
[17:36:42.343]                           invokeRestart("muffleWarning")
[17:36:42.343]                       }
[17:36:42.343]                       else if (inherits(cond, "condition")) {
[17:36:42.343]                         if (!is.null(pattern)) {
[17:36:42.343]                           computeRestarts <- base::computeRestarts
[17:36:42.343]                           grepl <- base::grepl
[17:36:42.343]                           restarts <- computeRestarts(cond)
[17:36:42.343]                           for (restart in restarts) {
[17:36:42.343]                             name <- restart$name
[17:36:42.343]                             if (is.null(name)) 
[17:36:42.343]                               next
[17:36:42.343]                             if (!grepl(pattern, name)) 
[17:36:42.343]                               next
[17:36:42.343]                             invokeRestart(restart)
[17:36:42.343]                             muffled <- TRUE
[17:36:42.343]                             break
[17:36:42.343]                           }
[17:36:42.343]                         }
[17:36:42.343]                       }
[17:36:42.343]                       invisible(muffled)
[17:36:42.343]                     }
[17:36:42.343]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.343]                   }
[17:36:42.343]                 }
[17:36:42.343]                 else {
[17:36:42.343]                   if (TRUE) {
[17:36:42.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.343]                     {
[17:36:42.343]                       inherits <- base::inherits
[17:36:42.343]                       invokeRestart <- base::invokeRestart
[17:36:42.343]                       is.null <- base::is.null
[17:36:42.343]                       muffled <- FALSE
[17:36:42.343]                       if (inherits(cond, "message")) {
[17:36:42.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.343]                         if (muffled) 
[17:36:42.343]                           invokeRestart("muffleMessage")
[17:36:42.343]                       }
[17:36:42.343]                       else if (inherits(cond, "warning")) {
[17:36:42.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.343]                         if (muffled) 
[17:36:42.343]                           invokeRestart("muffleWarning")
[17:36:42.343]                       }
[17:36:42.343]                       else if (inherits(cond, "condition")) {
[17:36:42.343]                         if (!is.null(pattern)) {
[17:36:42.343]                           computeRestarts <- base::computeRestarts
[17:36:42.343]                           grepl <- base::grepl
[17:36:42.343]                           restarts <- computeRestarts(cond)
[17:36:42.343]                           for (restart in restarts) {
[17:36:42.343]                             name <- restart$name
[17:36:42.343]                             if (is.null(name)) 
[17:36:42.343]                               next
[17:36:42.343]                             if (!grepl(pattern, name)) 
[17:36:42.343]                               next
[17:36:42.343]                             invokeRestart(restart)
[17:36:42.343]                             muffled <- TRUE
[17:36:42.343]                             break
[17:36:42.343]                           }
[17:36:42.343]                         }
[17:36:42.343]                       }
[17:36:42.343]                       invisible(muffled)
[17:36:42.343]                     }
[17:36:42.343]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.343]                   }
[17:36:42.343]                 }
[17:36:42.343]             }
[17:36:42.343]         }))
[17:36:42.343]     }, error = function(ex) {
[17:36:42.343]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:42.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.343]                 ...future.rng), started = ...future.startTime, 
[17:36:42.343]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:42.343]             version = "1.8"), class = "FutureResult")
[17:36:42.343]     }, finally = {
[17:36:42.343]         if (!identical(...future.workdir, getwd())) 
[17:36:42.343]             setwd(...future.workdir)
[17:36:42.343]         {
[17:36:42.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:42.343]                 ...future.oldOptions$nwarnings <- NULL
[17:36:42.343]             }
[17:36:42.343]             base::options(...future.oldOptions)
[17:36:42.343]             if (.Platform$OS.type == "windows") {
[17:36:42.343]                 old_names <- names(...future.oldEnvVars)
[17:36:42.343]                 envs <- base::Sys.getenv()
[17:36:42.343]                 names <- names(envs)
[17:36:42.343]                 common <- intersect(names, old_names)
[17:36:42.343]                 added <- setdiff(names, old_names)
[17:36:42.343]                 removed <- setdiff(old_names, names)
[17:36:42.343]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:42.343]                   envs[common]]
[17:36:42.343]                 NAMES <- toupper(changed)
[17:36:42.343]                 args <- list()
[17:36:42.343]                 for (kk in seq_along(NAMES)) {
[17:36:42.343]                   name <- changed[[kk]]
[17:36:42.343]                   NAME <- NAMES[[kk]]
[17:36:42.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.343]                     next
[17:36:42.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.343]                 }
[17:36:42.343]                 NAMES <- toupper(added)
[17:36:42.343]                 for (kk in seq_along(NAMES)) {
[17:36:42.343]                   name <- added[[kk]]
[17:36:42.343]                   NAME <- NAMES[[kk]]
[17:36:42.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.343]                     next
[17:36:42.343]                   args[[name]] <- ""
[17:36:42.343]                 }
[17:36:42.343]                 NAMES <- toupper(removed)
[17:36:42.343]                 for (kk in seq_along(NAMES)) {
[17:36:42.343]                   name <- removed[[kk]]
[17:36:42.343]                   NAME <- NAMES[[kk]]
[17:36:42.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.343]                     next
[17:36:42.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.343]                 }
[17:36:42.343]                 if (length(args) > 0) 
[17:36:42.343]                   base::do.call(base::Sys.setenv, args = args)
[17:36:42.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:42.343]             }
[17:36:42.343]             else {
[17:36:42.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:42.343]             }
[17:36:42.343]             {
[17:36:42.343]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:42.343]                   0L) {
[17:36:42.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:42.343]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:42.343]                   base::options(opts)
[17:36:42.343]                 }
[17:36:42.343]                 {
[17:36:42.343]                   {
[17:36:42.343]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:42.343]                     NULL
[17:36:42.343]                   }
[17:36:42.343]                   options(future.plan = NULL)
[17:36:42.343]                   if (is.na(NA_character_)) 
[17:36:42.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:42.343]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:42.343]                     .init = FALSE)
[17:36:42.343]                 }
[17:36:42.343]             }
[17:36:42.343]         }
[17:36:42.343]     })
[17:36:42.343]     if (TRUE) {
[17:36:42.343]         base::sink(type = "output", split = FALSE)
[17:36:42.343]         if (TRUE) {
[17:36:42.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:42.343]         }
[17:36:42.343]         else {
[17:36:42.343]             ...future.result["stdout"] <- base::list(NULL)
[17:36:42.343]         }
[17:36:42.343]         base::close(...future.stdout)
[17:36:42.343]         ...future.stdout <- NULL
[17:36:42.343]     }
[17:36:42.343]     ...future.result$conditions <- ...future.conditions
[17:36:42.343]     ...future.result$finished <- base::Sys.time()
[17:36:42.343]     ...future.result
[17:36:42.343] }
[17:36:42.346] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[17:36:42.346] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[17:36:42.346] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[17:36:42.347] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[17:36:42.347] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[17:36:42.347] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:36:42.348] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:36:42.348] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:42.348] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.348] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:36:42.349] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.349] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[17:36:42.349] MultisessionFuture started
[17:36:42.349] - Launch lazy future ... done
[17:36:42.350] run() for ‘MultisessionFuture’ ... done
[17:36:42.350] Created future:
[17:36:42.350] MultisessionFuture:
[17:36:42.350] Label: ‘future_by-2’
[17:36:42.350] Expression:
[17:36:42.350] {
[17:36:42.350]     do.call(function(...) {
[17:36:42.350]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.350]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.350]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.350]             on.exit(options(oopts), add = TRUE)
[17:36:42.350]         }
[17:36:42.350]         {
[17:36:42.350]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.350]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.350]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.350]             })
[17:36:42.350]         }
[17:36:42.350]     }, args = future.call.arguments)
[17:36:42.350] }
[17:36:42.350] Lazy evaluation: FALSE
[17:36:42.350] Asynchronous evaluation: TRUE
[17:36:42.350] Local evaluation: TRUE
[17:36:42.350] Environment: R_GlobalEnv
[17:36:42.350] Capture standard output: TRUE
[17:36:42.350] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:42.350] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:42.350] Packages: 1 packages (‘stats’)
[17:36:42.350] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:42.350] Resolved: FALSE
[17:36:42.350] Value: <not collected>
[17:36:42.350] Conditions captured: <none>
[17:36:42.350] Early signaling: FALSE
[17:36:42.350] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:42.350] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.361] Chunk #2 of 2 ... DONE
[17:36:42.362] Launching 2 futures (chunks) ... DONE
[17:36:42.362] Resolving 2 futures (chunks) ...
[17:36:42.362] resolve() on list ...
[17:36:42.362]  recursive: 0
[17:36:42.362]  length: 2
[17:36:42.362] 
[17:36:42.362] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.363] - Validating connection of MultisessionFuture
[17:36:42.363] - received message: FutureResult
[17:36:42.363] - Received FutureResult
[17:36:42.363] - Erased future from FutureRegistry
[17:36:42.363] result() for ClusterFuture ...
[17:36:42.363] - result already collected: FutureResult
[17:36:42.363] result() for ClusterFuture ... done
[17:36:42.363] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.364] Future #1
[17:36:42.364] result() for ClusterFuture ...
[17:36:42.364] - result already collected: FutureResult
[17:36:42.364] result() for ClusterFuture ... done
[17:36:42.364] result() for ClusterFuture ...
[17:36:42.364] - result already collected: FutureResult
[17:36:42.364] result() for ClusterFuture ... done
[17:36:42.364] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:42.364] - nx: 2
[17:36:42.364] - relay: TRUE
[17:36:42.364] - stdout: TRUE
[17:36:42.365] - signal: TRUE
[17:36:42.365] - resignal: FALSE
[17:36:42.365] - force: TRUE
[17:36:42.365] - relayed: [n=2] FALSE, FALSE
[17:36:42.365] - queued futures: [n=2] FALSE, FALSE
[17:36:42.365]  - until=1
[17:36:42.365]  - relaying element #1
[17:36:42.365] result() for ClusterFuture ...
[17:36:42.365] - result already collected: FutureResult
[17:36:42.365] result() for ClusterFuture ... done
[17:36:42.365] result() for ClusterFuture ...
[17:36:42.365] - result already collected: FutureResult
[17:36:42.366] result() for ClusterFuture ... done
[17:36:42.366] result() for ClusterFuture ...
[17:36:42.366] - result already collected: FutureResult
[17:36:42.366] result() for ClusterFuture ... done
[17:36:42.366] result() for ClusterFuture ...
[17:36:42.366] - result already collected: FutureResult
[17:36:42.366] result() for ClusterFuture ... done
[17:36:42.366] - relayed: [n=2] TRUE, FALSE
[17:36:42.366] - queued futures: [n=2] TRUE, FALSE
[17:36:42.366] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:42.366]  length: 1 (resolved future 1)
[17:36:42.408] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.408] - Validating connection of MultisessionFuture
[17:36:42.409] - received message: FutureResult
[17:36:42.409] - Received FutureResult
[17:36:42.409] - Erased future from FutureRegistry
[17:36:42.409] result() for ClusterFuture ...
[17:36:42.409] - result already collected: FutureResult
[17:36:42.409] result() for ClusterFuture ... done
[17:36:42.409] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.409] Future #2
[17:36:42.410] result() for ClusterFuture ...
[17:36:42.410] - result already collected: FutureResult
[17:36:42.410] result() for ClusterFuture ... done
[17:36:42.410] result() for ClusterFuture ...
[17:36:42.410] - result already collected: FutureResult
[17:36:42.410] result() for ClusterFuture ... done
[17:36:42.410] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:42.410] - nx: 2
[17:36:42.410] - relay: TRUE
[17:36:42.410] - stdout: TRUE
[17:36:42.410] - signal: TRUE
[17:36:42.410] - resignal: FALSE
[17:36:42.411] - force: TRUE
[17:36:42.411] - relayed: [n=2] TRUE, FALSE
[17:36:42.411] - queued futures: [n=2] TRUE, FALSE
[17:36:42.411]  - until=2
[17:36:42.411]  - relaying element #2
[17:36:42.411] result() for ClusterFuture ...
[17:36:42.411] - result already collected: FutureResult
[17:36:42.411] result() for ClusterFuture ... done
[17:36:42.411] result() for ClusterFuture ...
[17:36:42.411] - result already collected: FutureResult
[17:36:42.411] result() for ClusterFuture ... done
[17:36:42.412] result() for ClusterFuture ...
[17:36:42.412] - result already collected: FutureResult
[17:36:42.412] result() for ClusterFuture ... done
[17:36:42.412] result() for ClusterFuture ...
[17:36:42.412] - result already collected: FutureResult
[17:36:42.412] result() for ClusterFuture ... done
[17:36:42.412] - relayed: [n=2] TRUE, TRUE
[17:36:42.412] - queued futures: [n=2] TRUE, TRUE
[17:36:42.412] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:42.412]  length: 0 (resolved future 2)
[17:36:42.412] Relaying remaining futures
[17:36:42.413] signalConditionsASAP(NULL, pos=0) ...
[17:36:42.413] - nx: 2
[17:36:42.413] - relay: TRUE
[17:36:42.413] - stdout: TRUE
[17:36:42.413] - signal: TRUE
[17:36:42.413] - resignal: FALSE
[17:36:42.413] - force: TRUE
[17:36:42.413] - relayed: [n=2] TRUE, TRUE
[17:36:42.413] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:42.413] - relayed: [n=2] TRUE, TRUE
[17:36:42.413] - queued futures: [n=2] TRUE, TRUE
[17:36:42.414] signalConditionsASAP(NULL, pos=0) ... done
[17:36:42.414] resolve() on list ... DONE
[17:36:42.414] result() for ClusterFuture ...
[17:36:42.414] - result already collected: FutureResult
[17:36:42.414] result() for ClusterFuture ... done
[17:36:42.414] result() for ClusterFuture ...
[17:36:42.414] - result already collected: FutureResult
[17:36:42.414] result() for ClusterFuture ... done
[17:36:42.414] result() for ClusterFuture ...
[17:36:42.414] - result already collected: FutureResult
[17:36:42.414] result() for ClusterFuture ... done
[17:36:42.415] result() for ClusterFuture ...
[17:36:42.415] - result already collected: FutureResult
[17:36:42.415] result() for ClusterFuture ... done
[17:36:42.415]  - Number of value chunks collected: 2
[17:36:42.415] Resolving 2 futures (chunks) ... DONE
[17:36:42.415] Reducing values from 2 chunks ...
[17:36:42.415]  - Number of values collected after concatenation: 3
[17:36:42.415]  - Number of values expected: 3
[17:36:42.415] Reducing values from 2 chunks ... DONE
[17:36:42.415] future_lapply() ... DONE
[17:36:42.415] future_by_internal() ... DONE
[17:36:42.419] future_by_internal() ...
[17:36:42.420] future_lapply() ...
[17:36:42.424] Number of chunks: 2
[17:36:42.424] getGlobalsAndPackagesXApply() ...
[17:36:42.424]  - future.globals: TRUE
[17:36:42.425] getGlobalsAndPackages() ...
[17:36:42.425] Searching for globals...
[17:36:42.426] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:36:42.426] Searching for globals ... DONE
[17:36:42.427] Resolving globals: FALSE
[17:36:42.427] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:36:42.428] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:36:42.428] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:42.428] - packages: [1] ‘stats’
[17:36:42.428] getGlobalsAndPackages() ... DONE
[17:36:42.428]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:36:42.428]  - needed namespaces: [n=1] ‘stats’
[17:36:42.428] Finding globals ... DONE
[17:36:42.428]  - use_args: TRUE
[17:36:42.428]  - Getting '...' globals ...
[17:36:42.429] resolve() on list ...
[17:36:42.429]  recursive: 0
[17:36:42.429]  length: 1
[17:36:42.429]  elements: ‘...’
[17:36:42.429]  length: 0 (resolved future 1)
[17:36:42.429] resolve() on list ... DONE
[17:36:42.429]    - '...' content: [n=0] 
[17:36:42.429] List of 1
[17:36:42.429]  $ ...: list()
[17:36:42.429]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:42.429]  - attr(*, "where")=List of 1
[17:36:42.429]   ..$ ...:<environment: 0x5622fda6e218> 
[17:36:42.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:42.429]  - attr(*, "resolved")= logi TRUE
[17:36:42.429]  - attr(*, "total_size")= num NA
[17:36:42.432]  - Getting '...' globals ... DONE
[17:36:42.432] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:36:42.432] List of 4
[17:36:42.432]  $ ...future.FUN:function (x)  
[17:36:42.432]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:36:42.432]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:36:42.432]  $ ...          : list()
[17:36:42.432]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:42.432]  - attr(*, "where")=List of 4
[17:36:42.432]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:42.432]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:36:42.432]   ..$ wool         :<environment: R_EmptyEnv> 
[17:36:42.432]   ..$ ...          :<environment: 0x5622fda6e218> 
[17:36:42.432]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:42.432]  - attr(*, "resolved")= logi FALSE
[17:36:42.432]  - attr(*, "total_size")= num 2320
[17:36:42.436] Packages to be attached in all futures: [n=1] ‘stats’
[17:36:42.436] getGlobalsAndPackagesXApply() ... DONE
[17:36:42.436] Number of futures (= number of chunks): 2
[17:36:42.436] Launching 2 futures (chunks) ...
[17:36:42.436] Chunk #1 of 2 ...
[17:36:42.437]  - Finding globals in 'X' for chunk #1 ...
[17:36:42.437] getGlobalsAndPackages() ...
[17:36:42.437] Searching for globals...
[17:36:42.437] 
[17:36:42.437] Searching for globals ... DONE
[17:36:42.437] - globals: [0] <none>
[17:36:42.437] getGlobalsAndPackages() ... DONE
[17:36:42.437]    + additional globals found: [n=0] 
[17:36:42.438]    + additional namespaces needed: [n=0] 
[17:36:42.438]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:42.438]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:42.438]  - seeds: <none>
[17:36:42.438]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.438] getGlobalsAndPackages() ...
[17:36:42.438] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.438] Resolving globals: FALSE
[17:36:42.438] Tweak future expression to call with '...' arguments ...
[17:36:42.438] {
[17:36:42.438]     do.call(function(...) {
[17:36:42.438]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.438]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.438]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.438]             on.exit(options(oopts), add = TRUE)
[17:36:42.438]         }
[17:36:42.438]         {
[17:36:42.438]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.438]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.438]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.438]             })
[17:36:42.438]         }
[17:36:42.438]     }, args = future.call.arguments)
[17:36:42.438] }
[17:36:42.439] Tweak future expression to call with '...' arguments ... DONE
[17:36:42.439] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.439] 
[17:36:42.439] getGlobalsAndPackages() ... DONE
[17:36:42.440] run() for ‘Future’ ...
[17:36:42.440] - state: ‘created’
[17:36:42.440] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:42.454] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:42.455]   - Field: ‘node’
[17:36:42.455]   - Field: ‘label’
[17:36:42.455]   - Field: ‘local’
[17:36:42.455]   - Field: ‘owner’
[17:36:42.455]   - Field: ‘envir’
[17:36:42.455]   - Field: ‘workers’
[17:36:42.455]   - Field: ‘packages’
[17:36:42.455]   - Field: ‘gc’
[17:36:42.455]   - Field: ‘conditions’
[17:36:42.456]   - Field: ‘persistent’
[17:36:42.456]   - Field: ‘expr’
[17:36:42.456]   - Field: ‘uuid’
[17:36:42.456]   - Field: ‘seed’
[17:36:42.456]   - Field: ‘version’
[17:36:42.456]   - Field: ‘result’
[17:36:42.456]   - Field: ‘asynchronous’
[17:36:42.456]   - Field: ‘calls’
[17:36:42.456]   - Field: ‘globals’
[17:36:42.456]   - Field: ‘stdout’
[17:36:42.456]   - Field: ‘earlySignal’
[17:36:42.457]   - Field: ‘lazy’
[17:36:42.457]   - Field: ‘state’
[17:36:42.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:42.457] - Launch lazy future ...
[17:36:42.457] Packages needed by the future expression (n = 1): ‘stats’
[17:36:42.457] Packages needed by future strategies (n = 0): <none>
[17:36:42.458] {
[17:36:42.458]     {
[17:36:42.458]         {
[17:36:42.458]             ...future.startTime <- base::Sys.time()
[17:36:42.458]             {
[17:36:42.458]                 {
[17:36:42.458]                   {
[17:36:42.458]                     {
[17:36:42.458]                       {
[17:36:42.458]                         base::local({
[17:36:42.458]                           has_future <- base::requireNamespace("future", 
[17:36:42.458]                             quietly = TRUE)
[17:36:42.458]                           if (has_future) {
[17:36:42.458]                             ns <- base::getNamespace("future")
[17:36:42.458]                             version <- ns[[".package"]][["version"]]
[17:36:42.458]                             if (is.null(version)) 
[17:36:42.458]                               version <- utils::packageVersion("future")
[17:36:42.458]                           }
[17:36:42.458]                           else {
[17:36:42.458]                             version <- NULL
[17:36:42.458]                           }
[17:36:42.458]                           if (!has_future || version < "1.8.0") {
[17:36:42.458]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:42.458]                               "", base::R.version$version.string), 
[17:36:42.458]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:42.458]                                 base::R.version$platform, 8 * 
[17:36:42.458]                                   base::.Machine$sizeof.pointer), 
[17:36:42.458]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:42.458]                                 "release", "version")], collapse = " "), 
[17:36:42.458]                               hostname = base::Sys.info()[["nodename"]])
[17:36:42.458]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:42.458]                               info)
[17:36:42.458]                             info <- base::paste(info, collapse = "; ")
[17:36:42.458]                             if (!has_future) {
[17:36:42.458]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:42.458]                                 info)
[17:36:42.458]                             }
[17:36:42.458]                             else {
[17:36:42.458]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:42.458]                                 info, version)
[17:36:42.458]                             }
[17:36:42.458]                             base::stop(msg)
[17:36:42.458]                           }
[17:36:42.458]                         })
[17:36:42.458]                       }
[17:36:42.458]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:42.458]                       base::options(mc.cores = 1L)
[17:36:42.458]                     }
[17:36:42.458]                     base::local({
[17:36:42.458]                       for (pkg in "stats") {
[17:36:42.458]                         base::loadNamespace(pkg)
[17:36:42.458]                         base::library(pkg, character.only = TRUE)
[17:36:42.458]                       }
[17:36:42.458]                     })
[17:36:42.458]                   }
[17:36:42.458]                   ...future.strategy.old <- future::plan("list")
[17:36:42.458]                   options(future.plan = NULL)
[17:36:42.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:42.458]                 }
[17:36:42.458]                 ...future.workdir <- getwd()
[17:36:42.458]             }
[17:36:42.458]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:42.458]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:42.458]         }
[17:36:42.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:42.458]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:42.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:42.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:42.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:42.458]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:42.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:42.458]             base::names(...future.oldOptions))
[17:36:42.458]     }
[17:36:42.458]     if (FALSE) {
[17:36:42.458]     }
[17:36:42.458]     else {
[17:36:42.458]         if (TRUE) {
[17:36:42.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:42.458]                 open = "w")
[17:36:42.458]         }
[17:36:42.458]         else {
[17:36:42.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:42.458]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:42.458]         }
[17:36:42.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:42.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:42.458]             base::sink(type = "output", split = FALSE)
[17:36:42.458]             base::close(...future.stdout)
[17:36:42.458]         }, add = TRUE)
[17:36:42.458]     }
[17:36:42.458]     ...future.frame <- base::sys.nframe()
[17:36:42.458]     ...future.conditions <- base::list()
[17:36:42.458]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:42.458]     if (FALSE) {
[17:36:42.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:42.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:42.458]     }
[17:36:42.458]     ...future.result <- base::tryCatch({
[17:36:42.458]         base::withCallingHandlers({
[17:36:42.458]             ...future.value <- base::withVisible(base::local({
[17:36:42.458]                 ...future.makeSendCondition <- base::local({
[17:36:42.458]                   sendCondition <- NULL
[17:36:42.458]                   function(frame = 1L) {
[17:36:42.458]                     if (is.function(sendCondition)) 
[17:36:42.458]                       return(sendCondition)
[17:36:42.458]                     ns <- getNamespace("parallel")
[17:36:42.458]                     if (exists("sendData", mode = "function", 
[17:36:42.458]                       envir = ns)) {
[17:36:42.458]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:42.458]                         envir = ns)
[17:36:42.458]                       envir <- sys.frame(frame)
[17:36:42.458]                       master <- NULL
[17:36:42.458]                       while (!identical(envir, .GlobalEnv) && 
[17:36:42.458]                         !identical(envir, emptyenv())) {
[17:36:42.458]                         if (exists("master", mode = "list", envir = envir, 
[17:36:42.458]                           inherits = FALSE)) {
[17:36:42.458]                           master <- get("master", mode = "list", 
[17:36:42.458]                             envir = envir, inherits = FALSE)
[17:36:42.458]                           if (inherits(master, c("SOCKnode", 
[17:36:42.458]                             "SOCK0node"))) {
[17:36:42.458]                             sendCondition <<- function(cond) {
[17:36:42.458]                               data <- list(type = "VALUE", value = cond, 
[17:36:42.458]                                 success = TRUE)
[17:36:42.458]                               parallel_sendData(master, data)
[17:36:42.458]                             }
[17:36:42.458]                             return(sendCondition)
[17:36:42.458]                           }
[17:36:42.458]                         }
[17:36:42.458]                         frame <- frame + 1L
[17:36:42.458]                         envir <- sys.frame(frame)
[17:36:42.458]                       }
[17:36:42.458]                     }
[17:36:42.458]                     sendCondition <<- function(cond) NULL
[17:36:42.458]                   }
[17:36:42.458]                 })
[17:36:42.458]                 withCallingHandlers({
[17:36:42.458]                   {
[17:36:42.458]                     do.call(function(...) {
[17:36:42.458]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.458]                       if (!identical(...future.globals.maxSize.org, 
[17:36:42.458]                         ...future.globals.maxSize)) {
[17:36:42.458]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.458]                         on.exit(options(oopts), add = TRUE)
[17:36:42.458]                       }
[17:36:42.458]                       {
[17:36:42.458]                         lapply(seq_along(...future.elements_ii), 
[17:36:42.458]                           FUN = function(jj) {
[17:36:42.458]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.458]                             ...future.FUN(...future.X_jj, ...)
[17:36:42.458]                           })
[17:36:42.458]                       }
[17:36:42.458]                     }, args = future.call.arguments)
[17:36:42.458]                   }
[17:36:42.458]                 }, immediateCondition = function(cond) {
[17:36:42.458]                   sendCondition <- ...future.makeSendCondition()
[17:36:42.458]                   sendCondition(cond)
[17:36:42.458]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.458]                   {
[17:36:42.458]                     inherits <- base::inherits
[17:36:42.458]                     invokeRestart <- base::invokeRestart
[17:36:42.458]                     is.null <- base::is.null
[17:36:42.458]                     muffled <- FALSE
[17:36:42.458]                     if (inherits(cond, "message")) {
[17:36:42.458]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:42.458]                       if (muffled) 
[17:36:42.458]                         invokeRestart("muffleMessage")
[17:36:42.458]                     }
[17:36:42.458]                     else if (inherits(cond, "warning")) {
[17:36:42.458]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:42.458]                       if (muffled) 
[17:36:42.458]                         invokeRestart("muffleWarning")
[17:36:42.458]                     }
[17:36:42.458]                     else if (inherits(cond, "condition")) {
[17:36:42.458]                       if (!is.null(pattern)) {
[17:36:42.458]                         computeRestarts <- base::computeRestarts
[17:36:42.458]                         grepl <- base::grepl
[17:36:42.458]                         restarts <- computeRestarts(cond)
[17:36:42.458]                         for (restart in restarts) {
[17:36:42.458]                           name <- restart$name
[17:36:42.458]                           if (is.null(name)) 
[17:36:42.458]                             next
[17:36:42.458]                           if (!grepl(pattern, name)) 
[17:36:42.458]                             next
[17:36:42.458]                           invokeRestart(restart)
[17:36:42.458]                           muffled <- TRUE
[17:36:42.458]                           break
[17:36:42.458]                         }
[17:36:42.458]                       }
[17:36:42.458]                     }
[17:36:42.458]                     invisible(muffled)
[17:36:42.458]                   }
[17:36:42.458]                   muffleCondition(cond)
[17:36:42.458]                 })
[17:36:42.458]             }))
[17:36:42.458]             future::FutureResult(value = ...future.value$value, 
[17:36:42.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.458]                   ...future.rng), globalenv = if (FALSE) 
[17:36:42.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:42.458]                     ...future.globalenv.names))
[17:36:42.458]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:42.458]         }, condition = base::local({
[17:36:42.458]             c <- base::c
[17:36:42.458]             inherits <- base::inherits
[17:36:42.458]             invokeRestart <- base::invokeRestart
[17:36:42.458]             length <- base::length
[17:36:42.458]             list <- base::list
[17:36:42.458]             seq.int <- base::seq.int
[17:36:42.458]             signalCondition <- base::signalCondition
[17:36:42.458]             sys.calls <- base::sys.calls
[17:36:42.458]             `[[` <- base::`[[`
[17:36:42.458]             `+` <- base::`+`
[17:36:42.458]             `<<-` <- base::`<<-`
[17:36:42.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:42.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:42.458]                   3L)]
[17:36:42.458]             }
[17:36:42.458]             function(cond) {
[17:36:42.458]                 is_error <- inherits(cond, "error")
[17:36:42.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:42.458]                   NULL)
[17:36:42.458]                 if (is_error) {
[17:36:42.458]                   sessionInformation <- function() {
[17:36:42.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:42.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:42.458]                       search = base::search(), system = base::Sys.info())
[17:36:42.458]                   }
[17:36:42.458]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:42.458]                     cond$call), session = sessionInformation(), 
[17:36:42.458]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:42.458]                   signalCondition(cond)
[17:36:42.458]                 }
[17:36:42.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:42.458]                 "immediateCondition"))) {
[17:36:42.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:42.458]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:42.458]                   if (TRUE && !signal) {
[17:36:42.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.458]                     {
[17:36:42.458]                       inherits <- base::inherits
[17:36:42.458]                       invokeRestart <- base::invokeRestart
[17:36:42.458]                       is.null <- base::is.null
[17:36:42.458]                       muffled <- FALSE
[17:36:42.458]                       if (inherits(cond, "message")) {
[17:36:42.458]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.458]                         if (muffled) 
[17:36:42.458]                           invokeRestart("muffleMessage")
[17:36:42.458]                       }
[17:36:42.458]                       else if (inherits(cond, "warning")) {
[17:36:42.458]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.458]                         if (muffled) 
[17:36:42.458]                           invokeRestart("muffleWarning")
[17:36:42.458]                       }
[17:36:42.458]                       else if (inherits(cond, "condition")) {
[17:36:42.458]                         if (!is.null(pattern)) {
[17:36:42.458]                           computeRestarts <- base::computeRestarts
[17:36:42.458]                           grepl <- base::grepl
[17:36:42.458]                           restarts <- computeRestarts(cond)
[17:36:42.458]                           for (restart in restarts) {
[17:36:42.458]                             name <- restart$name
[17:36:42.458]                             if (is.null(name)) 
[17:36:42.458]                               next
[17:36:42.458]                             if (!grepl(pattern, name)) 
[17:36:42.458]                               next
[17:36:42.458]                             invokeRestart(restart)
[17:36:42.458]                             muffled <- TRUE
[17:36:42.458]                             break
[17:36:42.458]                           }
[17:36:42.458]                         }
[17:36:42.458]                       }
[17:36:42.458]                       invisible(muffled)
[17:36:42.458]                     }
[17:36:42.458]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.458]                   }
[17:36:42.458]                 }
[17:36:42.458]                 else {
[17:36:42.458]                   if (TRUE) {
[17:36:42.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.458]                     {
[17:36:42.458]                       inherits <- base::inherits
[17:36:42.458]                       invokeRestart <- base::invokeRestart
[17:36:42.458]                       is.null <- base::is.null
[17:36:42.458]                       muffled <- FALSE
[17:36:42.458]                       if (inherits(cond, "message")) {
[17:36:42.458]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.458]                         if (muffled) 
[17:36:42.458]                           invokeRestart("muffleMessage")
[17:36:42.458]                       }
[17:36:42.458]                       else if (inherits(cond, "warning")) {
[17:36:42.458]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.458]                         if (muffled) 
[17:36:42.458]                           invokeRestart("muffleWarning")
[17:36:42.458]                       }
[17:36:42.458]                       else if (inherits(cond, "condition")) {
[17:36:42.458]                         if (!is.null(pattern)) {
[17:36:42.458]                           computeRestarts <- base::computeRestarts
[17:36:42.458]                           grepl <- base::grepl
[17:36:42.458]                           restarts <- computeRestarts(cond)
[17:36:42.458]                           for (restart in restarts) {
[17:36:42.458]                             name <- restart$name
[17:36:42.458]                             if (is.null(name)) 
[17:36:42.458]                               next
[17:36:42.458]                             if (!grepl(pattern, name)) 
[17:36:42.458]                               next
[17:36:42.458]                             invokeRestart(restart)
[17:36:42.458]                             muffled <- TRUE
[17:36:42.458]                             break
[17:36:42.458]                           }
[17:36:42.458]                         }
[17:36:42.458]                       }
[17:36:42.458]                       invisible(muffled)
[17:36:42.458]                     }
[17:36:42.458]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.458]                   }
[17:36:42.458]                 }
[17:36:42.458]             }
[17:36:42.458]         }))
[17:36:42.458]     }, error = function(ex) {
[17:36:42.458]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:42.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.458]                 ...future.rng), started = ...future.startTime, 
[17:36:42.458]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:42.458]             version = "1.8"), class = "FutureResult")
[17:36:42.458]     }, finally = {
[17:36:42.458]         if (!identical(...future.workdir, getwd())) 
[17:36:42.458]             setwd(...future.workdir)
[17:36:42.458]         {
[17:36:42.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:42.458]                 ...future.oldOptions$nwarnings <- NULL
[17:36:42.458]             }
[17:36:42.458]             base::options(...future.oldOptions)
[17:36:42.458]             if (.Platform$OS.type == "windows") {
[17:36:42.458]                 old_names <- names(...future.oldEnvVars)
[17:36:42.458]                 envs <- base::Sys.getenv()
[17:36:42.458]                 names <- names(envs)
[17:36:42.458]                 common <- intersect(names, old_names)
[17:36:42.458]                 added <- setdiff(names, old_names)
[17:36:42.458]                 removed <- setdiff(old_names, names)
[17:36:42.458]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:42.458]                   envs[common]]
[17:36:42.458]                 NAMES <- toupper(changed)
[17:36:42.458]                 args <- list()
[17:36:42.458]                 for (kk in seq_along(NAMES)) {
[17:36:42.458]                   name <- changed[[kk]]
[17:36:42.458]                   NAME <- NAMES[[kk]]
[17:36:42.458]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.458]                     next
[17:36:42.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.458]                 }
[17:36:42.458]                 NAMES <- toupper(added)
[17:36:42.458]                 for (kk in seq_along(NAMES)) {
[17:36:42.458]                   name <- added[[kk]]
[17:36:42.458]                   NAME <- NAMES[[kk]]
[17:36:42.458]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.458]                     next
[17:36:42.458]                   args[[name]] <- ""
[17:36:42.458]                 }
[17:36:42.458]                 NAMES <- toupper(removed)
[17:36:42.458]                 for (kk in seq_along(NAMES)) {
[17:36:42.458]                   name <- removed[[kk]]
[17:36:42.458]                   NAME <- NAMES[[kk]]
[17:36:42.458]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.458]                     next
[17:36:42.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.458]                 }
[17:36:42.458]                 if (length(args) > 0) 
[17:36:42.458]                   base::do.call(base::Sys.setenv, args = args)
[17:36:42.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:42.458]             }
[17:36:42.458]             else {
[17:36:42.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:42.458]             }
[17:36:42.458]             {
[17:36:42.458]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:42.458]                   0L) {
[17:36:42.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:42.458]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:42.458]                   base::options(opts)
[17:36:42.458]                 }
[17:36:42.458]                 {
[17:36:42.458]                   {
[17:36:42.458]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:42.458]                     NULL
[17:36:42.458]                   }
[17:36:42.458]                   options(future.plan = NULL)
[17:36:42.458]                   if (is.na(NA_character_)) 
[17:36:42.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:42.458]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:42.458]                     .init = FALSE)
[17:36:42.458]                 }
[17:36:42.458]             }
[17:36:42.458]         }
[17:36:42.458]     })
[17:36:42.458]     if (TRUE) {
[17:36:42.458]         base::sink(type = "output", split = FALSE)
[17:36:42.458]         if (TRUE) {
[17:36:42.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:42.458]         }
[17:36:42.458]         else {
[17:36:42.458]             ...future.result["stdout"] <- base::list(NULL)
[17:36:42.458]         }
[17:36:42.458]         base::close(...future.stdout)
[17:36:42.458]         ...future.stdout <- NULL
[17:36:42.458]     }
[17:36:42.458]     ...future.result$conditions <- ...future.conditions
[17:36:42.458]     ...future.result$finished <- base::Sys.time()
[17:36:42.458]     ...future.result
[17:36:42.458] }
[17:36:42.461] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[17:36:42.461] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[17:36:42.461] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[17:36:42.461] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[17:36:42.462] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[17:36:42.462] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[17:36:42.462] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[17:36:42.462] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:42.463] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.463] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:36:42.463] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:36:42.463] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:42.464] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.464] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:36:42.464] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.464] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[17:36:42.465] MultisessionFuture started
[17:36:42.465] - Launch lazy future ... done
[17:36:42.465] run() for ‘MultisessionFuture’ ... done
[17:36:42.465] Created future:
[17:36:42.466] MultisessionFuture:
[17:36:42.466] Label: ‘future_by-1’
[17:36:42.466] Expression:
[17:36:42.466] {
[17:36:42.466]     do.call(function(...) {
[17:36:42.466]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.466]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.466]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.466]             on.exit(options(oopts), add = TRUE)
[17:36:42.466]         }
[17:36:42.466]         {
[17:36:42.466]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.466]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.466]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.466]             })
[17:36:42.466]         }
[17:36:42.466]     }, args = future.call.arguments)
[17:36:42.466] }
[17:36:42.466] Lazy evaluation: FALSE
[17:36:42.466] Asynchronous evaluation: TRUE
[17:36:42.466] Local evaluation: TRUE
[17:36:42.466] Environment: 0x5622fda43c18
[17:36:42.466] Capture standard output: TRUE
[17:36:42.466] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:42.466] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[17:36:42.466] Packages: 1 packages (‘stats’)
[17:36:42.466] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:42.466] Resolved: FALSE
[17:36:42.466] Value: <not collected>
[17:36:42.466] Conditions captured: <none>
[17:36:42.466] Early signaling: FALSE
[17:36:42.466] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:42.466] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.477] Chunk #1 of 2 ... DONE
[17:36:42.477] Chunk #2 of 2 ...
[17:36:42.477]  - Finding globals in 'X' for chunk #2 ...
[17:36:42.478] getGlobalsAndPackages() ...
[17:36:42.478] Searching for globals...
[17:36:42.478] 
[17:36:42.478] Searching for globals ... DONE
[17:36:42.478] - globals: [0] <none>
[17:36:42.478] getGlobalsAndPackages() ... DONE
[17:36:42.478]    + additional globals found: [n=0] 
[17:36:42.479]    + additional namespaces needed: [n=0] 
[17:36:42.479]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:42.479]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:42.479]  - seeds: <none>
[17:36:42.479]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.479] getGlobalsAndPackages() ...
[17:36:42.479] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.479] Resolving globals: FALSE
[17:36:42.479] Tweak future expression to call with '...' arguments ...
[17:36:42.479] {
[17:36:42.479]     do.call(function(...) {
[17:36:42.479]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.479]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.479]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.479]             on.exit(options(oopts), add = TRUE)
[17:36:42.479]         }
[17:36:42.479]         {
[17:36:42.479]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.479]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.479]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.479]             })
[17:36:42.479]         }
[17:36:42.479]     }, args = future.call.arguments)
[17:36:42.479] }
[17:36:42.480] Tweak future expression to call with '...' arguments ... DONE
[17:36:42.480] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.480] 
[17:36:42.480] getGlobalsAndPackages() ... DONE
[17:36:42.481] run() for ‘Future’ ...
[17:36:42.481] - state: ‘created’
[17:36:42.481] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:42.495] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:42.495]   - Field: ‘node’
[17:36:42.495]   - Field: ‘label’
[17:36:42.495]   - Field: ‘local’
[17:36:42.495]   - Field: ‘owner’
[17:36:42.496]   - Field: ‘envir’
[17:36:42.496]   - Field: ‘workers’
[17:36:42.496]   - Field: ‘packages’
[17:36:42.496]   - Field: ‘gc’
[17:36:42.496]   - Field: ‘conditions’
[17:36:42.496]   - Field: ‘persistent’
[17:36:42.496]   - Field: ‘expr’
[17:36:42.496]   - Field: ‘uuid’
[17:36:42.496]   - Field: ‘seed’
[17:36:42.499]   - Field: ‘version’
[17:36:42.499]   - Field: ‘result’
[17:36:42.499]   - Field: ‘asynchronous’
[17:36:42.499]   - Field: ‘calls’
[17:36:42.499]   - Field: ‘globals’
[17:36:42.499]   - Field: ‘stdout’
[17:36:42.499]   - Field: ‘earlySignal’
[17:36:42.499]   - Field: ‘lazy’
[17:36:42.499]   - Field: ‘state’
[17:36:42.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:42.500] - Launch lazy future ...
[17:36:42.500] Packages needed by the future expression (n = 1): ‘stats’
[17:36:42.500] Packages needed by future strategies (n = 0): <none>
[17:36:42.500] {
[17:36:42.500]     {
[17:36:42.500]         {
[17:36:42.500]             ...future.startTime <- base::Sys.time()
[17:36:42.500]             {
[17:36:42.500]                 {
[17:36:42.500]                   {
[17:36:42.500]                     {
[17:36:42.500]                       {
[17:36:42.500]                         base::local({
[17:36:42.500]                           has_future <- base::requireNamespace("future", 
[17:36:42.500]                             quietly = TRUE)
[17:36:42.500]                           if (has_future) {
[17:36:42.500]                             ns <- base::getNamespace("future")
[17:36:42.500]                             version <- ns[[".package"]][["version"]]
[17:36:42.500]                             if (is.null(version)) 
[17:36:42.500]                               version <- utils::packageVersion("future")
[17:36:42.500]                           }
[17:36:42.500]                           else {
[17:36:42.500]                             version <- NULL
[17:36:42.500]                           }
[17:36:42.500]                           if (!has_future || version < "1.8.0") {
[17:36:42.500]                             info <- base::c(r_version = base::gsub("R version ", 
[17:36:42.500]                               "", base::R.version$version.string), 
[17:36:42.500]                               platform = base::sprintf("%s (%s-bit)", 
[17:36:42.500]                                 base::R.version$platform, 8 * 
[17:36:42.500]                                   base::.Machine$sizeof.pointer), 
[17:36:42.500]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:42.500]                                 "release", "version")], collapse = " "), 
[17:36:42.500]                               hostname = base::Sys.info()[["nodename"]])
[17:36:42.500]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:36:42.500]                               info)
[17:36:42.500]                             info <- base::paste(info, collapse = "; ")
[17:36:42.500]                             if (!has_future) {
[17:36:42.500]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:42.500]                                 info)
[17:36:42.500]                             }
[17:36:42.500]                             else {
[17:36:42.500]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:42.500]                                 info, version)
[17:36:42.500]                             }
[17:36:42.500]                             base::stop(msg)
[17:36:42.500]                           }
[17:36:42.500]                         })
[17:36:42.500]                       }
[17:36:42.500]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:42.500]                       base::options(mc.cores = 1L)
[17:36:42.500]                     }
[17:36:42.500]                     base::local({
[17:36:42.500]                       for (pkg in "stats") {
[17:36:42.500]                         base::loadNamespace(pkg)
[17:36:42.500]                         base::library(pkg, character.only = TRUE)
[17:36:42.500]                       }
[17:36:42.500]                     })
[17:36:42.500]                   }
[17:36:42.500]                   ...future.strategy.old <- future::plan("list")
[17:36:42.500]                   options(future.plan = NULL)
[17:36:42.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:42.500]                 }
[17:36:42.500]                 ...future.workdir <- getwd()
[17:36:42.500]             }
[17:36:42.500]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:42.500]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:42.500]         }
[17:36:42.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:42.500]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:42.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:42.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:42.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:42.500]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:42.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:42.500]             base::names(...future.oldOptions))
[17:36:42.500]     }
[17:36:42.500]     if (FALSE) {
[17:36:42.500]     }
[17:36:42.500]     else {
[17:36:42.500]         if (TRUE) {
[17:36:42.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:42.500]                 open = "w")
[17:36:42.500]         }
[17:36:42.500]         else {
[17:36:42.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:42.500]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:42.500]         }
[17:36:42.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:42.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:42.500]             base::sink(type = "output", split = FALSE)
[17:36:42.500]             base::close(...future.stdout)
[17:36:42.500]         }, add = TRUE)
[17:36:42.500]     }
[17:36:42.500]     ...future.frame <- base::sys.nframe()
[17:36:42.500]     ...future.conditions <- base::list()
[17:36:42.500]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:42.500]     if (FALSE) {
[17:36:42.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:42.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:42.500]     }
[17:36:42.500]     ...future.result <- base::tryCatch({
[17:36:42.500]         base::withCallingHandlers({
[17:36:42.500]             ...future.value <- base::withVisible(base::local({
[17:36:42.500]                 ...future.makeSendCondition <- base::local({
[17:36:42.500]                   sendCondition <- NULL
[17:36:42.500]                   function(frame = 1L) {
[17:36:42.500]                     if (is.function(sendCondition)) 
[17:36:42.500]                       return(sendCondition)
[17:36:42.500]                     ns <- getNamespace("parallel")
[17:36:42.500]                     if (exists("sendData", mode = "function", 
[17:36:42.500]                       envir = ns)) {
[17:36:42.500]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:42.500]                         envir = ns)
[17:36:42.500]                       envir <- sys.frame(frame)
[17:36:42.500]                       master <- NULL
[17:36:42.500]                       while (!identical(envir, .GlobalEnv) && 
[17:36:42.500]                         !identical(envir, emptyenv())) {
[17:36:42.500]                         if (exists("master", mode = "list", envir = envir, 
[17:36:42.500]                           inherits = FALSE)) {
[17:36:42.500]                           master <- get("master", mode = "list", 
[17:36:42.500]                             envir = envir, inherits = FALSE)
[17:36:42.500]                           if (inherits(master, c("SOCKnode", 
[17:36:42.500]                             "SOCK0node"))) {
[17:36:42.500]                             sendCondition <<- function(cond) {
[17:36:42.500]                               data <- list(type = "VALUE", value = cond, 
[17:36:42.500]                                 success = TRUE)
[17:36:42.500]                               parallel_sendData(master, data)
[17:36:42.500]                             }
[17:36:42.500]                             return(sendCondition)
[17:36:42.500]                           }
[17:36:42.500]                         }
[17:36:42.500]                         frame <- frame + 1L
[17:36:42.500]                         envir <- sys.frame(frame)
[17:36:42.500]                       }
[17:36:42.500]                     }
[17:36:42.500]                     sendCondition <<- function(cond) NULL
[17:36:42.500]                   }
[17:36:42.500]                 })
[17:36:42.500]                 withCallingHandlers({
[17:36:42.500]                   {
[17:36:42.500]                     do.call(function(...) {
[17:36:42.500]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.500]                       if (!identical(...future.globals.maxSize.org, 
[17:36:42.500]                         ...future.globals.maxSize)) {
[17:36:42.500]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.500]                         on.exit(options(oopts), add = TRUE)
[17:36:42.500]                       }
[17:36:42.500]                       {
[17:36:42.500]                         lapply(seq_along(...future.elements_ii), 
[17:36:42.500]                           FUN = function(jj) {
[17:36:42.500]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.500]                             ...future.FUN(...future.X_jj, ...)
[17:36:42.500]                           })
[17:36:42.500]                       }
[17:36:42.500]                     }, args = future.call.arguments)
[17:36:42.500]                   }
[17:36:42.500]                 }, immediateCondition = function(cond) {
[17:36:42.500]                   sendCondition <- ...future.makeSendCondition()
[17:36:42.500]                   sendCondition(cond)
[17:36:42.500]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.500]                   {
[17:36:42.500]                     inherits <- base::inherits
[17:36:42.500]                     invokeRestart <- base::invokeRestart
[17:36:42.500]                     is.null <- base::is.null
[17:36:42.500]                     muffled <- FALSE
[17:36:42.500]                     if (inherits(cond, "message")) {
[17:36:42.500]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:42.500]                       if (muffled) 
[17:36:42.500]                         invokeRestart("muffleMessage")
[17:36:42.500]                     }
[17:36:42.500]                     else if (inherits(cond, "warning")) {
[17:36:42.500]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:42.500]                       if (muffled) 
[17:36:42.500]                         invokeRestart("muffleWarning")
[17:36:42.500]                     }
[17:36:42.500]                     else if (inherits(cond, "condition")) {
[17:36:42.500]                       if (!is.null(pattern)) {
[17:36:42.500]                         computeRestarts <- base::computeRestarts
[17:36:42.500]                         grepl <- base::grepl
[17:36:42.500]                         restarts <- computeRestarts(cond)
[17:36:42.500]                         for (restart in restarts) {
[17:36:42.500]                           name <- restart$name
[17:36:42.500]                           if (is.null(name)) 
[17:36:42.500]                             next
[17:36:42.500]                           if (!grepl(pattern, name)) 
[17:36:42.500]                             next
[17:36:42.500]                           invokeRestart(restart)
[17:36:42.500]                           muffled <- TRUE
[17:36:42.500]                           break
[17:36:42.500]                         }
[17:36:42.500]                       }
[17:36:42.500]                     }
[17:36:42.500]                     invisible(muffled)
[17:36:42.500]                   }
[17:36:42.500]                   muffleCondition(cond)
[17:36:42.500]                 })
[17:36:42.500]             }))
[17:36:42.500]             future::FutureResult(value = ...future.value$value, 
[17:36:42.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.500]                   ...future.rng), globalenv = if (FALSE) 
[17:36:42.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:42.500]                     ...future.globalenv.names))
[17:36:42.500]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:42.500]         }, condition = base::local({
[17:36:42.500]             c <- base::c
[17:36:42.500]             inherits <- base::inherits
[17:36:42.500]             invokeRestart <- base::invokeRestart
[17:36:42.500]             length <- base::length
[17:36:42.500]             list <- base::list
[17:36:42.500]             seq.int <- base::seq.int
[17:36:42.500]             signalCondition <- base::signalCondition
[17:36:42.500]             sys.calls <- base::sys.calls
[17:36:42.500]             `[[` <- base::`[[`
[17:36:42.500]             `+` <- base::`+`
[17:36:42.500]             `<<-` <- base::`<<-`
[17:36:42.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:42.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:42.500]                   3L)]
[17:36:42.500]             }
[17:36:42.500]             function(cond) {
[17:36:42.500]                 is_error <- inherits(cond, "error")
[17:36:42.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:42.500]                   NULL)
[17:36:42.500]                 if (is_error) {
[17:36:42.500]                   sessionInformation <- function() {
[17:36:42.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:42.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:42.500]                       search = base::search(), system = base::Sys.info())
[17:36:42.500]                   }
[17:36:42.500]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:42.500]                     cond$call), session = sessionInformation(), 
[17:36:42.500]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:42.500]                   signalCondition(cond)
[17:36:42.500]                 }
[17:36:42.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:42.500]                 "immediateCondition"))) {
[17:36:42.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:42.500]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:42.500]                   if (TRUE && !signal) {
[17:36:42.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.500]                     {
[17:36:42.500]                       inherits <- base::inherits
[17:36:42.500]                       invokeRestart <- base::invokeRestart
[17:36:42.500]                       is.null <- base::is.null
[17:36:42.500]                       muffled <- FALSE
[17:36:42.500]                       if (inherits(cond, "message")) {
[17:36:42.500]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.500]                         if (muffled) 
[17:36:42.500]                           invokeRestart("muffleMessage")
[17:36:42.500]                       }
[17:36:42.500]                       else if (inherits(cond, "warning")) {
[17:36:42.500]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.500]                         if (muffled) 
[17:36:42.500]                           invokeRestart("muffleWarning")
[17:36:42.500]                       }
[17:36:42.500]                       else if (inherits(cond, "condition")) {
[17:36:42.500]                         if (!is.null(pattern)) {
[17:36:42.500]                           computeRestarts <- base::computeRestarts
[17:36:42.500]                           grepl <- base::grepl
[17:36:42.500]                           restarts <- computeRestarts(cond)
[17:36:42.500]                           for (restart in restarts) {
[17:36:42.500]                             name <- restart$name
[17:36:42.500]                             if (is.null(name)) 
[17:36:42.500]                               next
[17:36:42.500]                             if (!grepl(pattern, name)) 
[17:36:42.500]                               next
[17:36:42.500]                             invokeRestart(restart)
[17:36:42.500]                             muffled <- TRUE
[17:36:42.500]                             break
[17:36:42.500]                           }
[17:36:42.500]                         }
[17:36:42.500]                       }
[17:36:42.500]                       invisible(muffled)
[17:36:42.500]                     }
[17:36:42.500]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.500]                   }
[17:36:42.500]                 }
[17:36:42.500]                 else {
[17:36:42.500]                   if (TRUE) {
[17:36:42.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.500]                     {
[17:36:42.500]                       inherits <- base::inherits
[17:36:42.500]                       invokeRestart <- base::invokeRestart
[17:36:42.500]                       is.null <- base::is.null
[17:36:42.500]                       muffled <- FALSE
[17:36:42.500]                       if (inherits(cond, "message")) {
[17:36:42.500]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.500]                         if (muffled) 
[17:36:42.500]                           invokeRestart("muffleMessage")
[17:36:42.500]                       }
[17:36:42.500]                       else if (inherits(cond, "warning")) {
[17:36:42.500]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.500]                         if (muffled) 
[17:36:42.500]                           invokeRestart("muffleWarning")
[17:36:42.500]                       }
[17:36:42.500]                       else if (inherits(cond, "condition")) {
[17:36:42.500]                         if (!is.null(pattern)) {
[17:36:42.500]                           computeRestarts <- base::computeRestarts
[17:36:42.500]                           grepl <- base::grepl
[17:36:42.500]                           restarts <- computeRestarts(cond)
[17:36:42.500]                           for (restart in restarts) {
[17:36:42.500]                             name <- restart$name
[17:36:42.500]                             if (is.null(name)) 
[17:36:42.500]                               next
[17:36:42.500]                             if (!grepl(pattern, name)) 
[17:36:42.500]                               next
[17:36:42.500]                             invokeRestart(restart)
[17:36:42.500]                             muffled <- TRUE
[17:36:42.500]                             break
[17:36:42.500]                           }
[17:36:42.500]                         }
[17:36:42.500]                       }
[17:36:42.500]                       invisible(muffled)
[17:36:42.500]                     }
[17:36:42.500]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.500]                   }
[17:36:42.500]                 }
[17:36:42.500]             }
[17:36:42.500]         }))
[17:36:42.500]     }, error = function(ex) {
[17:36:42.500]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:42.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.500]                 ...future.rng), started = ...future.startTime, 
[17:36:42.500]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:42.500]             version = "1.8"), class = "FutureResult")
[17:36:42.500]     }, finally = {
[17:36:42.500]         if (!identical(...future.workdir, getwd())) 
[17:36:42.500]             setwd(...future.workdir)
[17:36:42.500]         {
[17:36:42.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:42.500]                 ...future.oldOptions$nwarnings <- NULL
[17:36:42.500]             }
[17:36:42.500]             base::options(...future.oldOptions)
[17:36:42.500]             if (.Platform$OS.type == "windows") {
[17:36:42.500]                 old_names <- names(...future.oldEnvVars)
[17:36:42.500]                 envs <- base::Sys.getenv()
[17:36:42.500]                 names <- names(envs)
[17:36:42.500]                 common <- intersect(names, old_names)
[17:36:42.500]                 added <- setdiff(names, old_names)
[17:36:42.500]                 removed <- setdiff(old_names, names)
[17:36:42.500]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:42.500]                   envs[common]]
[17:36:42.500]                 NAMES <- toupper(changed)
[17:36:42.500]                 args <- list()
[17:36:42.500]                 for (kk in seq_along(NAMES)) {
[17:36:42.500]                   name <- changed[[kk]]
[17:36:42.500]                   NAME <- NAMES[[kk]]
[17:36:42.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.500]                     next
[17:36:42.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.500]                 }
[17:36:42.500]                 NAMES <- toupper(added)
[17:36:42.500]                 for (kk in seq_along(NAMES)) {
[17:36:42.500]                   name <- added[[kk]]
[17:36:42.500]                   NAME <- NAMES[[kk]]
[17:36:42.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.500]                     next
[17:36:42.500]                   args[[name]] <- ""
[17:36:42.500]                 }
[17:36:42.500]                 NAMES <- toupper(removed)
[17:36:42.500]                 for (kk in seq_along(NAMES)) {
[17:36:42.500]                   name <- removed[[kk]]
[17:36:42.500]                   NAME <- NAMES[[kk]]
[17:36:42.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.500]                     next
[17:36:42.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.500]                 }
[17:36:42.500]                 if (length(args) > 0) 
[17:36:42.500]                   base::do.call(base::Sys.setenv, args = args)
[17:36:42.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:42.500]             }
[17:36:42.500]             else {
[17:36:42.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:42.500]             }
[17:36:42.500]             {
[17:36:42.500]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:42.500]                   0L) {
[17:36:42.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:42.500]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:42.500]                   base::options(opts)
[17:36:42.500]                 }
[17:36:42.500]                 {
[17:36:42.500]                   {
[17:36:42.500]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:42.500]                     NULL
[17:36:42.500]                   }
[17:36:42.500]                   options(future.plan = NULL)
[17:36:42.500]                   if (is.na(NA_character_)) 
[17:36:42.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:42.500]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:42.500]                     .init = FALSE)
[17:36:42.500]                 }
[17:36:42.500]             }
[17:36:42.500]         }
[17:36:42.500]     })
[17:36:42.500]     if (TRUE) {
[17:36:42.500]         base::sink(type = "output", split = FALSE)
[17:36:42.500]         if (TRUE) {
[17:36:42.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:42.500]         }
[17:36:42.500]         else {
[17:36:42.500]             ...future.result["stdout"] <- base::list(NULL)
[17:36:42.500]         }
[17:36:42.500]         base::close(...future.stdout)
[17:36:42.500]         ...future.stdout <- NULL
[17:36:42.500]     }
[17:36:42.500]     ...future.result$conditions <- ...future.conditions
[17:36:42.500]     ...future.result$finished <- base::Sys.time()
[17:36:42.500]     ...future.result
[17:36:42.500] }
[17:36:42.503] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[17:36:42.503] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[17:36:42.504] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[17:36:42.504] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[17:36:42.504] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[17:36:42.504] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[17:36:42.505] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[17:36:42.505] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:42.505] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.505] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:36:42.506] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:36:42.506] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:42.506] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.506] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:36:42.506] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.507] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[17:36:42.507] MultisessionFuture started
[17:36:42.507] - Launch lazy future ... done
[17:36:42.507] run() for ‘MultisessionFuture’ ... done
[17:36:42.507] Created future:
[17:36:42.507] MultisessionFuture:
[17:36:42.507] Label: ‘future_by-2’
[17:36:42.507] Expression:
[17:36:42.507] {
[17:36:42.507]     do.call(function(...) {
[17:36:42.507]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.507]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.507]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.507]             on.exit(options(oopts), add = TRUE)
[17:36:42.507]         }
[17:36:42.507]         {
[17:36:42.507]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.507]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.507]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.507]             })
[17:36:42.507]         }
[17:36:42.507]     }, args = future.call.arguments)
[17:36:42.507] }
[17:36:42.507] Lazy evaluation: FALSE
[17:36:42.507] Asynchronous evaluation: TRUE
[17:36:42.507] Local evaluation: TRUE
[17:36:42.507] Environment: 0x5622fda43c18
[17:36:42.507] Capture standard output: TRUE
[17:36:42.507] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:42.507] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[17:36:42.507] Packages: 1 packages (‘stats’)
[17:36:42.507] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:42.507] Resolved: FALSE
[17:36:42.507] Value: <not collected>
[17:36:42.507] Conditions captured: <none>
[17:36:42.507] Early signaling: FALSE
[17:36:42.507] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:42.507] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.519] Chunk #2 of 2 ... DONE
[17:36:42.520] Launching 2 futures (chunks) ... DONE
[17:36:42.520] Resolving 2 futures (chunks) ...
[17:36:42.520] resolve() on list ...
[17:36:42.520]  recursive: 0
[17:36:42.520]  length: 2
[17:36:42.520] 
[17:36:42.521] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.521] - Validating connection of MultisessionFuture
[17:36:42.521] - received message: FutureResult
[17:36:42.521] - Received FutureResult
[17:36:42.521] - Erased future from FutureRegistry
[17:36:42.521] result() for ClusterFuture ...
[17:36:42.522] - result already collected: FutureResult
[17:36:42.522] result() for ClusterFuture ... done
[17:36:42.522] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.522] Future #1
[17:36:42.522] result() for ClusterFuture ...
[17:36:42.522] - result already collected: FutureResult
[17:36:42.522] result() for ClusterFuture ... done
[17:36:42.522] result() for ClusterFuture ...
[17:36:42.522] - result already collected: FutureResult
[17:36:42.522] result() for ClusterFuture ... done
[17:36:42.522] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:42.523] - nx: 2
[17:36:42.523] - relay: TRUE
[17:36:42.523] - stdout: TRUE
[17:36:42.523] - signal: TRUE
[17:36:42.523] - resignal: FALSE
[17:36:42.523] - force: TRUE
[17:36:42.523] - relayed: [n=2] FALSE, FALSE
[17:36:42.523] - queued futures: [n=2] FALSE, FALSE
[17:36:42.523]  - until=1
[17:36:42.523]  - relaying element #1
[17:36:42.523] result() for ClusterFuture ...
[17:36:42.523] - result already collected: FutureResult
[17:36:42.524] result() for ClusterFuture ... done
[17:36:42.524] result() for ClusterFuture ...
[17:36:42.524] - result already collected: FutureResult
[17:36:42.524] result() for ClusterFuture ... done
[17:36:42.524] result() for ClusterFuture ...
[17:36:42.524] - result already collected: FutureResult
[17:36:42.524] result() for ClusterFuture ... done
[17:36:42.524] result() for ClusterFuture ...
[17:36:42.524] - result already collected: FutureResult
[17:36:42.524] result() for ClusterFuture ... done
[17:36:42.524] - relayed: [n=2] TRUE, FALSE
[17:36:42.525] - queued futures: [n=2] TRUE, FALSE
[17:36:42.525] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:42.525]  length: 1 (resolved future 1)
[17:36:42.552] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.552] - Validating connection of MultisessionFuture
[17:36:42.552] - received message: FutureResult
[17:36:42.552] - Received FutureResult
[17:36:42.553] - Erased future from FutureRegistry
[17:36:42.553] result() for ClusterFuture ...
[17:36:42.553] - result already collected: FutureResult
[17:36:42.553] result() for ClusterFuture ... done
[17:36:42.553] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.553] Future #2
[17:36:42.553] result() for ClusterFuture ...
[17:36:42.553] - result already collected: FutureResult
[17:36:42.553] result() for ClusterFuture ... done
[17:36:42.553] result() for ClusterFuture ...
[17:36:42.554] - result already collected: FutureResult
[17:36:42.554] result() for ClusterFuture ... done
[17:36:42.554] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:42.554] - nx: 2
[17:36:42.554] - relay: TRUE
[17:36:42.554] - stdout: TRUE
[17:36:42.554] - signal: TRUE
[17:36:42.554] - resignal: FALSE
[17:36:42.554] - force: TRUE
[17:36:42.554] - relayed: [n=2] TRUE, FALSE
[17:36:42.554] - queued futures: [n=2] TRUE, FALSE
[17:36:42.555]  - until=2
[17:36:42.555]  - relaying element #2
[17:36:42.555] result() for ClusterFuture ...
[17:36:42.555] - result already collected: FutureResult
[17:36:42.555] result() for ClusterFuture ... done
[17:36:42.555] result() for ClusterFuture ...
[17:36:42.555] - result already collected: FutureResult
[17:36:42.555] result() for ClusterFuture ... done
[17:36:42.555] result() for ClusterFuture ...
[17:36:42.555] - result already collected: FutureResult
[17:36:42.555] result() for ClusterFuture ... done
[17:36:42.556] result() for ClusterFuture ...
[17:36:42.556] - result already collected: FutureResult
[17:36:42.556] result() for ClusterFuture ... done
[17:36:42.556] - relayed: [n=2] TRUE, TRUE
[17:36:42.556] - queued futures: [n=2] TRUE, TRUE
[17:36:42.556] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:42.556]  length: 0 (resolved future 2)
[17:36:42.556] Relaying remaining futures
[17:36:42.556] signalConditionsASAP(NULL, pos=0) ...
[17:36:42.556] - nx: 2
[17:36:42.556] - relay: TRUE
[17:36:42.557] - stdout: TRUE
[17:36:42.557] - signal: TRUE
[17:36:42.557] - resignal: FALSE
[17:36:42.557] - force: TRUE
[17:36:42.557] - relayed: [n=2] TRUE, TRUE
[17:36:42.557] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:42.557] - relayed: [n=2] TRUE, TRUE
[17:36:42.557] - queued futures: [n=2] TRUE, TRUE
[17:36:42.557] signalConditionsASAP(NULL, pos=0) ... done
[17:36:42.557] resolve() on list ... DONE
[17:36:42.557] result() for ClusterFuture ...
[17:36:42.558] - result already collected: FutureResult
[17:36:42.558] result() for ClusterFuture ... done
[17:36:42.558] result() for ClusterFuture ...
[17:36:42.558] - result already collected: FutureResult
[17:36:42.558] result() for ClusterFuture ... done
[17:36:42.558] result() for ClusterFuture ...
[17:36:42.558] - result already collected: FutureResult
[17:36:42.558] result() for ClusterFuture ... done
[17:36:42.558] result() for ClusterFuture ...
[17:36:42.558] - result already collected: FutureResult
[17:36:42.558] result() for ClusterFuture ... done
[17:36:42.559]  - Number of value chunks collected: 2
[17:36:42.559] Resolving 2 futures (chunks) ... DONE
[17:36:42.559] Reducing values from 2 chunks ...
[17:36:42.559]  - Number of values collected after concatenation: 3
[17:36:42.559]  - Number of values expected: 3
[17:36:42.559] Reducing values from 2 chunks ... DONE
[17:36:42.559] future_lapply() ... DONE
[17:36:42.559] future_by_internal() ... DONE
[17:36:42.560] future_by_internal() ...
[17:36:42.560] future_lapply() ...
[17:36:42.564] Number of chunks: 2
[17:36:42.564] getGlobalsAndPackagesXApply() ...
[17:36:42.564]  - future.globals: TRUE
[17:36:42.565] getGlobalsAndPackages() ...
[17:36:42.565] Searching for globals...
[17:36:42.566] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:42.566] Searching for globals ... DONE
[17:36:42.566] Resolving globals: FALSE
[17:36:42.566] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:42.567] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:42.567] - globals: [1] ‘FUN’
[17:36:42.567] 
[17:36:42.567] getGlobalsAndPackages() ... DONE
[17:36:42.567]  - globals found/used: [n=1] ‘FUN’
[17:36:42.567]  - needed namespaces: [n=0] 
[17:36:42.567] Finding globals ... DONE
[17:36:42.567]  - use_args: TRUE
[17:36:42.567]  - Getting '...' globals ...
[17:36:42.568] resolve() on list ...
[17:36:42.568]  recursive: 0
[17:36:42.568]  length: 1
[17:36:42.568]  elements: ‘...’
[17:36:42.568]  length: 0 (resolved future 1)
[17:36:42.568] resolve() on list ... DONE
[17:36:42.568]    - '...' content: [n=0] 
[17:36:42.569] List of 1
[17:36:42.569]  $ ...: list()
[17:36:42.569]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:42.569]  - attr(*, "where")=List of 1
[17:36:42.569]   ..$ ...:<environment: 0x5622fb577018> 
[17:36:42.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:42.569]  - attr(*, "resolved")= logi TRUE
[17:36:42.569]  - attr(*, "total_size")= num NA
[17:36:42.571]  - Getting '...' globals ... DONE
[17:36:42.571] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:42.571] List of 2
[17:36:42.571]  $ ...future.FUN:function (object, ...)  
[17:36:42.571]  $ ...          : list()
[17:36:42.571]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:42.571]  - attr(*, "where")=List of 2
[17:36:42.571]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:42.571]   ..$ ...          :<environment: 0x5622fb577018> 
[17:36:42.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:42.571]  - attr(*, "resolved")= logi FALSE
[17:36:42.571]  - attr(*, "total_size")= num 1240
[17:36:42.574] Packages to be attached in all futures: [n=0] 
[17:36:42.574] getGlobalsAndPackagesXApply() ... DONE
[17:36:42.574] Number of futures (= number of chunks): 2
[17:36:42.574] Launching 2 futures (chunks) ...
[17:36:42.575] Chunk #1 of 2 ...
[17:36:42.575]  - Finding globals in 'X' for chunk #1 ...
[17:36:42.575] getGlobalsAndPackages() ...
[17:36:42.575] Searching for globals...
[17:36:42.575] 
[17:36:42.575] Searching for globals ... DONE
[17:36:42.575] - globals: [0] <none>
[17:36:42.575] getGlobalsAndPackages() ... DONE
[17:36:42.576]    + additional globals found: [n=0] 
[17:36:42.576]    + additional namespaces needed: [n=0] 
[17:36:42.576]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:42.576]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:42.576]  - seeds: <none>
[17:36:42.576]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.576] getGlobalsAndPackages() ...
[17:36:42.576] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.576] Resolving globals: FALSE
[17:36:42.576] Tweak future expression to call with '...' arguments ...
[17:36:42.577] {
[17:36:42.577]     do.call(function(...) {
[17:36:42.577]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.577]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.577]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.577]             on.exit(options(oopts), add = TRUE)
[17:36:42.577]         }
[17:36:42.577]         {
[17:36:42.577]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.577]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.577]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.577]             })
[17:36:42.577]         }
[17:36:42.577]     }, args = future.call.arguments)
[17:36:42.577] }
[17:36:42.577] Tweak future expression to call with '...' arguments ... DONE
[17:36:42.577] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.577] 
[17:36:42.577] getGlobalsAndPackages() ... DONE
[17:36:42.578] run() for ‘Future’ ...
[17:36:42.578] - state: ‘created’
[17:36:42.578] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:42.592] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.592] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:42.592]   - Field: ‘node’
[17:36:42.593]   - Field: ‘label’
[17:36:42.593]   - Field: ‘local’
[17:36:42.593]   - Field: ‘owner’
[17:36:42.593]   - Field: ‘envir’
[17:36:42.593]   - Field: ‘workers’
[17:36:42.593]   - Field: ‘packages’
[17:36:42.593]   - Field: ‘gc’
[17:36:42.593]   - Field: ‘conditions’
[17:36:42.593]   - Field: ‘persistent’
[17:36:42.593]   - Field: ‘expr’
[17:36:42.593]   - Field: ‘uuid’
[17:36:42.593]   - Field: ‘seed’
[17:36:42.594]   - Field: ‘version’
[17:36:42.594]   - Field: ‘result’
[17:36:42.594]   - Field: ‘asynchronous’
[17:36:42.594]   - Field: ‘calls’
[17:36:42.594]   - Field: ‘globals’
[17:36:42.594]   - Field: ‘stdout’
[17:36:42.594]   - Field: ‘earlySignal’
[17:36:42.594]   - Field: ‘lazy’
[17:36:42.594]   - Field: ‘state’
[17:36:42.594] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:42.594] - Launch lazy future ...
[17:36:42.595] Packages needed by the future expression (n = 0): <none>
[17:36:42.595] Packages needed by future strategies (n = 0): <none>
[17:36:42.595] {
[17:36:42.595]     {
[17:36:42.595]         {
[17:36:42.595]             ...future.startTime <- base::Sys.time()
[17:36:42.595]             {
[17:36:42.595]                 {
[17:36:42.595]                   {
[17:36:42.595]                     {
[17:36:42.595]                       base::local({
[17:36:42.595]                         has_future <- base::requireNamespace("future", 
[17:36:42.595]                           quietly = TRUE)
[17:36:42.595]                         if (has_future) {
[17:36:42.595]                           ns <- base::getNamespace("future")
[17:36:42.595]                           version <- ns[[".package"]][["version"]]
[17:36:42.595]                           if (is.null(version)) 
[17:36:42.595]                             version <- utils::packageVersion("future")
[17:36:42.595]                         }
[17:36:42.595]                         else {
[17:36:42.595]                           version <- NULL
[17:36:42.595]                         }
[17:36:42.595]                         if (!has_future || version < "1.8.0") {
[17:36:42.595]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:42.595]                             "", base::R.version$version.string), 
[17:36:42.595]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:42.595]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:42.595]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:42.595]                               "release", "version")], collapse = " "), 
[17:36:42.595]                             hostname = base::Sys.info()[["nodename"]])
[17:36:42.595]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:42.595]                             info)
[17:36:42.595]                           info <- base::paste(info, collapse = "; ")
[17:36:42.595]                           if (!has_future) {
[17:36:42.595]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:42.595]                               info)
[17:36:42.595]                           }
[17:36:42.595]                           else {
[17:36:42.595]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:42.595]                               info, version)
[17:36:42.595]                           }
[17:36:42.595]                           base::stop(msg)
[17:36:42.595]                         }
[17:36:42.595]                       })
[17:36:42.595]                     }
[17:36:42.595]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:42.595]                     base::options(mc.cores = 1L)
[17:36:42.595]                   }
[17:36:42.595]                   ...future.strategy.old <- future::plan("list")
[17:36:42.595]                   options(future.plan = NULL)
[17:36:42.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:42.595]                 }
[17:36:42.595]                 ...future.workdir <- getwd()
[17:36:42.595]             }
[17:36:42.595]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:42.595]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:42.595]         }
[17:36:42.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:42.595]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:42.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:42.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:42.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:42.595]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:42.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:42.595]             base::names(...future.oldOptions))
[17:36:42.595]     }
[17:36:42.595]     if (FALSE) {
[17:36:42.595]     }
[17:36:42.595]     else {
[17:36:42.595]         if (TRUE) {
[17:36:42.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:42.595]                 open = "w")
[17:36:42.595]         }
[17:36:42.595]         else {
[17:36:42.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:42.595]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:42.595]         }
[17:36:42.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:42.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:42.595]             base::sink(type = "output", split = FALSE)
[17:36:42.595]             base::close(...future.stdout)
[17:36:42.595]         }, add = TRUE)
[17:36:42.595]     }
[17:36:42.595]     ...future.frame <- base::sys.nframe()
[17:36:42.595]     ...future.conditions <- base::list()
[17:36:42.595]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:42.595]     if (FALSE) {
[17:36:42.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:42.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:42.595]     }
[17:36:42.595]     ...future.result <- base::tryCatch({
[17:36:42.595]         base::withCallingHandlers({
[17:36:42.595]             ...future.value <- base::withVisible(base::local({
[17:36:42.595]                 ...future.makeSendCondition <- base::local({
[17:36:42.595]                   sendCondition <- NULL
[17:36:42.595]                   function(frame = 1L) {
[17:36:42.595]                     if (is.function(sendCondition)) 
[17:36:42.595]                       return(sendCondition)
[17:36:42.595]                     ns <- getNamespace("parallel")
[17:36:42.595]                     if (exists("sendData", mode = "function", 
[17:36:42.595]                       envir = ns)) {
[17:36:42.595]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:42.595]                         envir = ns)
[17:36:42.595]                       envir <- sys.frame(frame)
[17:36:42.595]                       master <- NULL
[17:36:42.595]                       while (!identical(envir, .GlobalEnv) && 
[17:36:42.595]                         !identical(envir, emptyenv())) {
[17:36:42.595]                         if (exists("master", mode = "list", envir = envir, 
[17:36:42.595]                           inherits = FALSE)) {
[17:36:42.595]                           master <- get("master", mode = "list", 
[17:36:42.595]                             envir = envir, inherits = FALSE)
[17:36:42.595]                           if (inherits(master, c("SOCKnode", 
[17:36:42.595]                             "SOCK0node"))) {
[17:36:42.595]                             sendCondition <<- function(cond) {
[17:36:42.595]                               data <- list(type = "VALUE", value = cond, 
[17:36:42.595]                                 success = TRUE)
[17:36:42.595]                               parallel_sendData(master, data)
[17:36:42.595]                             }
[17:36:42.595]                             return(sendCondition)
[17:36:42.595]                           }
[17:36:42.595]                         }
[17:36:42.595]                         frame <- frame + 1L
[17:36:42.595]                         envir <- sys.frame(frame)
[17:36:42.595]                       }
[17:36:42.595]                     }
[17:36:42.595]                     sendCondition <<- function(cond) NULL
[17:36:42.595]                   }
[17:36:42.595]                 })
[17:36:42.595]                 withCallingHandlers({
[17:36:42.595]                   {
[17:36:42.595]                     do.call(function(...) {
[17:36:42.595]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.595]                       if (!identical(...future.globals.maxSize.org, 
[17:36:42.595]                         ...future.globals.maxSize)) {
[17:36:42.595]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.595]                         on.exit(options(oopts), add = TRUE)
[17:36:42.595]                       }
[17:36:42.595]                       {
[17:36:42.595]                         lapply(seq_along(...future.elements_ii), 
[17:36:42.595]                           FUN = function(jj) {
[17:36:42.595]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.595]                             ...future.FUN(...future.X_jj, ...)
[17:36:42.595]                           })
[17:36:42.595]                       }
[17:36:42.595]                     }, args = future.call.arguments)
[17:36:42.595]                   }
[17:36:42.595]                 }, immediateCondition = function(cond) {
[17:36:42.595]                   sendCondition <- ...future.makeSendCondition()
[17:36:42.595]                   sendCondition(cond)
[17:36:42.595]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.595]                   {
[17:36:42.595]                     inherits <- base::inherits
[17:36:42.595]                     invokeRestart <- base::invokeRestart
[17:36:42.595]                     is.null <- base::is.null
[17:36:42.595]                     muffled <- FALSE
[17:36:42.595]                     if (inherits(cond, "message")) {
[17:36:42.595]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:42.595]                       if (muffled) 
[17:36:42.595]                         invokeRestart("muffleMessage")
[17:36:42.595]                     }
[17:36:42.595]                     else if (inherits(cond, "warning")) {
[17:36:42.595]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:42.595]                       if (muffled) 
[17:36:42.595]                         invokeRestart("muffleWarning")
[17:36:42.595]                     }
[17:36:42.595]                     else if (inherits(cond, "condition")) {
[17:36:42.595]                       if (!is.null(pattern)) {
[17:36:42.595]                         computeRestarts <- base::computeRestarts
[17:36:42.595]                         grepl <- base::grepl
[17:36:42.595]                         restarts <- computeRestarts(cond)
[17:36:42.595]                         for (restart in restarts) {
[17:36:42.595]                           name <- restart$name
[17:36:42.595]                           if (is.null(name)) 
[17:36:42.595]                             next
[17:36:42.595]                           if (!grepl(pattern, name)) 
[17:36:42.595]                             next
[17:36:42.595]                           invokeRestart(restart)
[17:36:42.595]                           muffled <- TRUE
[17:36:42.595]                           break
[17:36:42.595]                         }
[17:36:42.595]                       }
[17:36:42.595]                     }
[17:36:42.595]                     invisible(muffled)
[17:36:42.595]                   }
[17:36:42.595]                   muffleCondition(cond)
[17:36:42.595]                 })
[17:36:42.595]             }))
[17:36:42.595]             future::FutureResult(value = ...future.value$value, 
[17:36:42.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.595]                   ...future.rng), globalenv = if (FALSE) 
[17:36:42.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:42.595]                     ...future.globalenv.names))
[17:36:42.595]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:42.595]         }, condition = base::local({
[17:36:42.595]             c <- base::c
[17:36:42.595]             inherits <- base::inherits
[17:36:42.595]             invokeRestart <- base::invokeRestart
[17:36:42.595]             length <- base::length
[17:36:42.595]             list <- base::list
[17:36:42.595]             seq.int <- base::seq.int
[17:36:42.595]             signalCondition <- base::signalCondition
[17:36:42.595]             sys.calls <- base::sys.calls
[17:36:42.595]             `[[` <- base::`[[`
[17:36:42.595]             `+` <- base::`+`
[17:36:42.595]             `<<-` <- base::`<<-`
[17:36:42.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:42.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:42.595]                   3L)]
[17:36:42.595]             }
[17:36:42.595]             function(cond) {
[17:36:42.595]                 is_error <- inherits(cond, "error")
[17:36:42.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:42.595]                   NULL)
[17:36:42.595]                 if (is_error) {
[17:36:42.595]                   sessionInformation <- function() {
[17:36:42.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:42.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:42.595]                       search = base::search(), system = base::Sys.info())
[17:36:42.595]                   }
[17:36:42.595]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:42.595]                     cond$call), session = sessionInformation(), 
[17:36:42.595]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:42.595]                   signalCondition(cond)
[17:36:42.595]                 }
[17:36:42.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:42.595]                 "immediateCondition"))) {
[17:36:42.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:42.595]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:42.595]                   if (TRUE && !signal) {
[17:36:42.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.595]                     {
[17:36:42.595]                       inherits <- base::inherits
[17:36:42.595]                       invokeRestart <- base::invokeRestart
[17:36:42.595]                       is.null <- base::is.null
[17:36:42.595]                       muffled <- FALSE
[17:36:42.595]                       if (inherits(cond, "message")) {
[17:36:42.595]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.595]                         if (muffled) 
[17:36:42.595]                           invokeRestart("muffleMessage")
[17:36:42.595]                       }
[17:36:42.595]                       else if (inherits(cond, "warning")) {
[17:36:42.595]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.595]                         if (muffled) 
[17:36:42.595]                           invokeRestart("muffleWarning")
[17:36:42.595]                       }
[17:36:42.595]                       else if (inherits(cond, "condition")) {
[17:36:42.595]                         if (!is.null(pattern)) {
[17:36:42.595]                           computeRestarts <- base::computeRestarts
[17:36:42.595]                           grepl <- base::grepl
[17:36:42.595]                           restarts <- computeRestarts(cond)
[17:36:42.595]                           for (restart in restarts) {
[17:36:42.595]                             name <- restart$name
[17:36:42.595]                             if (is.null(name)) 
[17:36:42.595]                               next
[17:36:42.595]                             if (!grepl(pattern, name)) 
[17:36:42.595]                               next
[17:36:42.595]                             invokeRestart(restart)
[17:36:42.595]                             muffled <- TRUE
[17:36:42.595]                             break
[17:36:42.595]                           }
[17:36:42.595]                         }
[17:36:42.595]                       }
[17:36:42.595]                       invisible(muffled)
[17:36:42.595]                     }
[17:36:42.595]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.595]                   }
[17:36:42.595]                 }
[17:36:42.595]                 else {
[17:36:42.595]                   if (TRUE) {
[17:36:42.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.595]                     {
[17:36:42.595]                       inherits <- base::inherits
[17:36:42.595]                       invokeRestart <- base::invokeRestart
[17:36:42.595]                       is.null <- base::is.null
[17:36:42.595]                       muffled <- FALSE
[17:36:42.595]                       if (inherits(cond, "message")) {
[17:36:42.595]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.595]                         if (muffled) 
[17:36:42.595]                           invokeRestart("muffleMessage")
[17:36:42.595]                       }
[17:36:42.595]                       else if (inherits(cond, "warning")) {
[17:36:42.595]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.595]                         if (muffled) 
[17:36:42.595]                           invokeRestart("muffleWarning")
[17:36:42.595]                       }
[17:36:42.595]                       else if (inherits(cond, "condition")) {
[17:36:42.595]                         if (!is.null(pattern)) {
[17:36:42.595]                           computeRestarts <- base::computeRestarts
[17:36:42.595]                           grepl <- base::grepl
[17:36:42.595]                           restarts <- computeRestarts(cond)
[17:36:42.595]                           for (restart in restarts) {
[17:36:42.595]                             name <- restart$name
[17:36:42.595]                             if (is.null(name)) 
[17:36:42.595]                               next
[17:36:42.595]                             if (!grepl(pattern, name)) 
[17:36:42.595]                               next
[17:36:42.595]                             invokeRestart(restart)
[17:36:42.595]                             muffled <- TRUE
[17:36:42.595]                             break
[17:36:42.595]                           }
[17:36:42.595]                         }
[17:36:42.595]                       }
[17:36:42.595]                       invisible(muffled)
[17:36:42.595]                     }
[17:36:42.595]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.595]                   }
[17:36:42.595]                 }
[17:36:42.595]             }
[17:36:42.595]         }))
[17:36:42.595]     }, error = function(ex) {
[17:36:42.595]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:42.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.595]                 ...future.rng), started = ...future.startTime, 
[17:36:42.595]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:42.595]             version = "1.8"), class = "FutureResult")
[17:36:42.595]     }, finally = {
[17:36:42.595]         if (!identical(...future.workdir, getwd())) 
[17:36:42.595]             setwd(...future.workdir)
[17:36:42.595]         {
[17:36:42.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:42.595]                 ...future.oldOptions$nwarnings <- NULL
[17:36:42.595]             }
[17:36:42.595]             base::options(...future.oldOptions)
[17:36:42.595]             if (.Platform$OS.type == "windows") {
[17:36:42.595]                 old_names <- names(...future.oldEnvVars)
[17:36:42.595]                 envs <- base::Sys.getenv()
[17:36:42.595]                 names <- names(envs)
[17:36:42.595]                 common <- intersect(names, old_names)
[17:36:42.595]                 added <- setdiff(names, old_names)
[17:36:42.595]                 removed <- setdiff(old_names, names)
[17:36:42.595]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:42.595]                   envs[common]]
[17:36:42.595]                 NAMES <- toupper(changed)
[17:36:42.595]                 args <- list()
[17:36:42.595]                 for (kk in seq_along(NAMES)) {
[17:36:42.595]                   name <- changed[[kk]]
[17:36:42.595]                   NAME <- NAMES[[kk]]
[17:36:42.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.595]                     next
[17:36:42.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.595]                 }
[17:36:42.595]                 NAMES <- toupper(added)
[17:36:42.595]                 for (kk in seq_along(NAMES)) {
[17:36:42.595]                   name <- added[[kk]]
[17:36:42.595]                   NAME <- NAMES[[kk]]
[17:36:42.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.595]                     next
[17:36:42.595]                   args[[name]] <- ""
[17:36:42.595]                 }
[17:36:42.595]                 NAMES <- toupper(removed)
[17:36:42.595]                 for (kk in seq_along(NAMES)) {
[17:36:42.595]                   name <- removed[[kk]]
[17:36:42.595]                   NAME <- NAMES[[kk]]
[17:36:42.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.595]                     next
[17:36:42.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.595]                 }
[17:36:42.595]                 if (length(args) > 0) 
[17:36:42.595]                   base::do.call(base::Sys.setenv, args = args)
[17:36:42.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:42.595]             }
[17:36:42.595]             else {
[17:36:42.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:42.595]             }
[17:36:42.595]             {
[17:36:42.595]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:42.595]                   0L) {
[17:36:42.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:42.595]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:42.595]                   base::options(opts)
[17:36:42.595]                 }
[17:36:42.595]                 {
[17:36:42.595]                   {
[17:36:42.595]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:42.595]                     NULL
[17:36:42.595]                   }
[17:36:42.595]                   options(future.plan = NULL)
[17:36:42.595]                   if (is.na(NA_character_)) 
[17:36:42.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:42.595]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:42.595]                     .init = FALSE)
[17:36:42.595]                 }
[17:36:42.595]             }
[17:36:42.595]         }
[17:36:42.595]     })
[17:36:42.595]     if (TRUE) {
[17:36:42.595]         base::sink(type = "output", split = FALSE)
[17:36:42.595]         if (TRUE) {
[17:36:42.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:42.595]         }
[17:36:42.595]         else {
[17:36:42.595]             ...future.result["stdout"] <- base::list(NULL)
[17:36:42.595]         }
[17:36:42.595]         base::close(...future.stdout)
[17:36:42.595]         ...future.stdout <- NULL
[17:36:42.595]     }
[17:36:42.595]     ...future.result$conditions <- ...future.conditions
[17:36:42.595]     ...future.result$finished <- base::Sys.time()
[17:36:42.595]     ...future.result
[17:36:42.595] }
[17:36:42.598] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:36:42.598] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:36:42.599] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:36:42.599] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:42.599] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.599] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:36:42.600] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:36:42.600] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:42.600] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.600] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:36:42.601] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.601] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:36:42.601] MultisessionFuture started
[17:36:42.601] - Launch lazy future ... done
[17:36:42.601] run() for ‘MultisessionFuture’ ... done
[17:36:42.601] Created future:
[17:36:42.602] MultisessionFuture:
[17:36:42.602] Label: ‘future_by-1’
[17:36:42.602] Expression:
[17:36:42.602] {
[17:36:42.602]     do.call(function(...) {
[17:36:42.602]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.602]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.602]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.602]             on.exit(options(oopts), add = TRUE)
[17:36:42.602]         }
[17:36:42.602]         {
[17:36:42.602]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.602]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.602]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.602]             })
[17:36:42.602]         }
[17:36:42.602]     }, args = future.call.arguments)
[17:36:42.602] }
[17:36:42.602] Lazy evaluation: FALSE
[17:36:42.602] Asynchronous evaluation: TRUE
[17:36:42.602] Local evaluation: TRUE
[17:36:42.602] Environment: 0x5622fb5bef58
[17:36:42.602] Capture standard output: TRUE
[17:36:42.602] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:42.602] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:42.602] Packages: <none>
[17:36:42.602] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:42.602] Resolved: FALSE
[17:36:42.602] Value: <not collected>
[17:36:42.602] Conditions captured: <none>
[17:36:42.602] Early signaling: FALSE
[17:36:42.602] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:42.602] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.613] Chunk #1 of 2 ... DONE
[17:36:42.613] Chunk #2 of 2 ...
[17:36:42.613]  - Finding globals in 'X' for chunk #2 ...
[17:36:42.614] getGlobalsAndPackages() ...
[17:36:42.614] Searching for globals...
[17:36:42.614] 
[17:36:42.614] Searching for globals ... DONE
[17:36:42.614] - globals: [0] <none>
[17:36:42.614] getGlobalsAndPackages() ... DONE
[17:36:42.614]    + additional globals found: [n=0] 
[17:36:42.615]    + additional namespaces needed: [n=0] 
[17:36:42.615]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:42.615]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:42.615]  - seeds: <none>
[17:36:42.615]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.615] getGlobalsAndPackages() ...
[17:36:42.615] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.615] Resolving globals: FALSE
[17:36:42.615] Tweak future expression to call with '...' arguments ...
[17:36:42.615] {
[17:36:42.615]     do.call(function(...) {
[17:36:42.615]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.615]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.615]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.615]             on.exit(options(oopts), add = TRUE)
[17:36:42.615]         }
[17:36:42.615]         {
[17:36:42.615]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.615]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.615]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.615]             })
[17:36:42.615]         }
[17:36:42.615]     }, args = future.call.arguments)
[17:36:42.615] }
[17:36:42.616] Tweak future expression to call with '...' arguments ... DONE
[17:36:42.616] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.616] 
[17:36:42.616] getGlobalsAndPackages() ... DONE
[17:36:42.616] run() for ‘Future’ ...
[17:36:42.617] - state: ‘created’
[17:36:42.617] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:42.631] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:42.631]   - Field: ‘node’
[17:36:42.631]   - Field: ‘label’
[17:36:42.631]   - Field: ‘local’
[17:36:42.631]   - Field: ‘owner’
[17:36:42.631]   - Field: ‘envir’
[17:36:42.631]   - Field: ‘workers’
[17:36:42.631]   - Field: ‘packages’
[17:36:42.631]   - Field: ‘gc’
[17:36:42.632]   - Field: ‘conditions’
[17:36:42.632]   - Field: ‘persistent’
[17:36:42.632]   - Field: ‘expr’
[17:36:42.632]   - Field: ‘uuid’
[17:36:42.632]   - Field: ‘seed’
[17:36:42.632]   - Field: ‘version’
[17:36:42.632]   - Field: ‘result’
[17:36:42.632]   - Field: ‘asynchronous’
[17:36:42.632]   - Field: ‘calls’
[17:36:42.632]   - Field: ‘globals’
[17:36:42.632]   - Field: ‘stdout’
[17:36:42.633]   - Field: ‘earlySignal’
[17:36:42.633]   - Field: ‘lazy’
[17:36:42.633]   - Field: ‘state’
[17:36:42.633] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:42.633] - Launch lazy future ...
[17:36:42.633] Packages needed by the future expression (n = 0): <none>
[17:36:42.633] Packages needed by future strategies (n = 0): <none>
[17:36:42.634] {
[17:36:42.634]     {
[17:36:42.634]         {
[17:36:42.634]             ...future.startTime <- base::Sys.time()
[17:36:42.634]             {
[17:36:42.634]                 {
[17:36:42.634]                   {
[17:36:42.634]                     {
[17:36:42.634]                       base::local({
[17:36:42.634]                         has_future <- base::requireNamespace("future", 
[17:36:42.634]                           quietly = TRUE)
[17:36:42.634]                         if (has_future) {
[17:36:42.634]                           ns <- base::getNamespace("future")
[17:36:42.634]                           version <- ns[[".package"]][["version"]]
[17:36:42.634]                           if (is.null(version)) 
[17:36:42.634]                             version <- utils::packageVersion("future")
[17:36:42.634]                         }
[17:36:42.634]                         else {
[17:36:42.634]                           version <- NULL
[17:36:42.634]                         }
[17:36:42.634]                         if (!has_future || version < "1.8.0") {
[17:36:42.634]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:42.634]                             "", base::R.version$version.string), 
[17:36:42.634]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:42.634]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:42.634]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:42.634]                               "release", "version")], collapse = " "), 
[17:36:42.634]                             hostname = base::Sys.info()[["nodename"]])
[17:36:42.634]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:42.634]                             info)
[17:36:42.634]                           info <- base::paste(info, collapse = "; ")
[17:36:42.634]                           if (!has_future) {
[17:36:42.634]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:42.634]                               info)
[17:36:42.634]                           }
[17:36:42.634]                           else {
[17:36:42.634]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:42.634]                               info, version)
[17:36:42.634]                           }
[17:36:42.634]                           base::stop(msg)
[17:36:42.634]                         }
[17:36:42.634]                       })
[17:36:42.634]                     }
[17:36:42.634]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:42.634]                     base::options(mc.cores = 1L)
[17:36:42.634]                   }
[17:36:42.634]                   ...future.strategy.old <- future::plan("list")
[17:36:42.634]                   options(future.plan = NULL)
[17:36:42.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:42.634]                 }
[17:36:42.634]                 ...future.workdir <- getwd()
[17:36:42.634]             }
[17:36:42.634]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:42.634]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:42.634]         }
[17:36:42.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:42.634]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:42.634]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:42.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:42.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:42.634]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:42.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:42.634]             base::names(...future.oldOptions))
[17:36:42.634]     }
[17:36:42.634]     if (FALSE) {
[17:36:42.634]     }
[17:36:42.634]     else {
[17:36:42.634]         if (TRUE) {
[17:36:42.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:42.634]                 open = "w")
[17:36:42.634]         }
[17:36:42.634]         else {
[17:36:42.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:42.634]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:42.634]         }
[17:36:42.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:42.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:42.634]             base::sink(type = "output", split = FALSE)
[17:36:42.634]             base::close(...future.stdout)
[17:36:42.634]         }, add = TRUE)
[17:36:42.634]     }
[17:36:42.634]     ...future.frame <- base::sys.nframe()
[17:36:42.634]     ...future.conditions <- base::list()
[17:36:42.634]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:42.634]     if (FALSE) {
[17:36:42.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:42.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:42.634]     }
[17:36:42.634]     ...future.result <- base::tryCatch({
[17:36:42.634]         base::withCallingHandlers({
[17:36:42.634]             ...future.value <- base::withVisible(base::local({
[17:36:42.634]                 ...future.makeSendCondition <- base::local({
[17:36:42.634]                   sendCondition <- NULL
[17:36:42.634]                   function(frame = 1L) {
[17:36:42.634]                     if (is.function(sendCondition)) 
[17:36:42.634]                       return(sendCondition)
[17:36:42.634]                     ns <- getNamespace("parallel")
[17:36:42.634]                     if (exists("sendData", mode = "function", 
[17:36:42.634]                       envir = ns)) {
[17:36:42.634]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:42.634]                         envir = ns)
[17:36:42.634]                       envir <- sys.frame(frame)
[17:36:42.634]                       master <- NULL
[17:36:42.634]                       while (!identical(envir, .GlobalEnv) && 
[17:36:42.634]                         !identical(envir, emptyenv())) {
[17:36:42.634]                         if (exists("master", mode = "list", envir = envir, 
[17:36:42.634]                           inherits = FALSE)) {
[17:36:42.634]                           master <- get("master", mode = "list", 
[17:36:42.634]                             envir = envir, inherits = FALSE)
[17:36:42.634]                           if (inherits(master, c("SOCKnode", 
[17:36:42.634]                             "SOCK0node"))) {
[17:36:42.634]                             sendCondition <<- function(cond) {
[17:36:42.634]                               data <- list(type = "VALUE", value = cond, 
[17:36:42.634]                                 success = TRUE)
[17:36:42.634]                               parallel_sendData(master, data)
[17:36:42.634]                             }
[17:36:42.634]                             return(sendCondition)
[17:36:42.634]                           }
[17:36:42.634]                         }
[17:36:42.634]                         frame <- frame + 1L
[17:36:42.634]                         envir <- sys.frame(frame)
[17:36:42.634]                       }
[17:36:42.634]                     }
[17:36:42.634]                     sendCondition <<- function(cond) NULL
[17:36:42.634]                   }
[17:36:42.634]                 })
[17:36:42.634]                 withCallingHandlers({
[17:36:42.634]                   {
[17:36:42.634]                     do.call(function(...) {
[17:36:42.634]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.634]                       if (!identical(...future.globals.maxSize.org, 
[17:36:42.634]                         ...future.globals.maxSize)) {
[17:36:42.634]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.634]                         on.exit(options(oopts), add = TRUE)
[17:36:42.634]                       }
[17:36:42.634]                       {
[17:36:42.634]                         lapply(seq_along(...future.elements_ii), 
[17:36:42.634]                           FUN = function(jj) {
[17:36:42.634]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.634]                             ...future.FUN(...future.X_jj, ...)
[17:36:42.634]                           })
[17:36:42.634]                       }
[17:36:42.634]                     }, args = future.call.arguments)
[17:36:42.634]                   }
[17:36:42.634]                 }, immediateCondition = function(cond) {
[17:36:42.634]                   sendCondition <- ...future.makeSendCondition()
[17:36:42.634]                   sendCondition(cond)
[17:36:42.634]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.634]                   {
[17:36:42.634]                     inherits <- base::inherits
[17:36:42.634]                     invokeRestart <- base::invokeRestart
[17:36:42.634]                     is.null <- base::is.null
[17:36:42.634]                     muffled <- FALSE
[17:36:42.634]                     if (inherits(cond, "message")) {
[17:36:42.634]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:42.634]                       if (muffled) 
[17:36:42.634]                         invokeRestart("muffleMessage")
[17:36:42.634]                     }
[17:36:42.634]                     else if (inherits(cond, "warning")) {
[17:36:42.634]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:42.634]                       if (muffled) 
[17:36:42.634]                         invokeRestart("muffleWarning")
[17:36:42.634]                     }
[17:36:42.634]                     else if (inherits(cond, "condition")) {
[17:36:42.634]                       if (!is.null(pattern)) {
[17:36:42.634]                         computeRestarts <- base::computeRestarts
[17:36:42.634]                         grepl <- base::grepl
[17:36:42.634]                         restarts <- computeRestarts(cond)
[17:36:42.634]                         for (restart in restarts) {
[17:36:42.634]                           name <- restart$name
[17:36:42.634]                           if (is.null(name)) 
[17:36:42.634]                             next
[17:36:42.634]                           if (!grepl(pattern, name)) 
[17:36:42.634]                             next
[17:36:42.634]                           invokeRestart(restart)
[17:36:42.634]                           muffled <- TRUE
[17:36:42.634]                           break
[17:36:42.634]                         }
[17:36:42.634]                       }
[17:36:42.634]                     }
[17:36:42.634]                     invisible(muffled)
[17:36:42.634]                   }
[17:36:42.634]                   muffleCondition(cond)
[17:36:42.634]                 })
[17:36:42.634]             }))
[17:36:42.634]             future::FutureResult(value = ...future.value$value, 
[17:36:42.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.634]                   ...future.rng), globalenv = if (FALSE) 
[17:36:42.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:42.634]                     ...future.globalenv.names))
[17:36:42.634]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:42.634]         }, condition = base::local({
[17:36:42.634]             c <- base::c
[17:36:42.634]             inherits <- base::inherits
[17:36:42.634]             invokeRestart <- base::invokeRestart
[17:36:42.634]             length <- base::length
[17:36:42.634]             list <- base::list
[17:36:42.634]             seq.int <- base::seq.int
[17:36:42.634]             signalCondition <- base::signalCondition
[17:36:42.634]             sys.calls <- base::sys.calls
[17:36:42.634]             `[[` <- base::`[[`
[17:36:42.634]             `+` <- base::`+`
[17:36:42.634]             `<<-` <- base::`<<-`
[17:36:42.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:42.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:42.634]                   3L)]
[17:36:42.634]             }
[17:36:42.634]             function(cond) {
[17:36:42.634]                 is_error <- inherits(cond, "error")
[17:36:42.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:42.634]                   NULL)
[17:36:42.634]                 if (is_error) {
[17:36:42.634]                   sessionInformation <- function() {
[17:36:42.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:42.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:42.634]                       search = base::search(), system = base::Sys.info())
[17:36:42.634]                   }
[17:36:42.634]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:42.634]                     cond$call), session = sessionInformation(), 
[17:36:42.634]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:42.634]                   signalCondition(cond)
[17:36:42.634]                 }
[17:36:42.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:42.634]                 "immediateCondition"))) {
[17:36:42.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:42.634]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:42.634]                   if (TRUE && !signal) {
[17:36:42.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.634]                     {
[17:36:42.634]                       inherits <- base::inherits
[17:36:42.634]                       invokeRestart <- base::invokeRestart
[17:36:42.634]                       is.null <- base::is.null
[17:36:42.634]                       muffled <- FALSE
[17:36:42.634]                       if (inherits(cond, "message")) {
[17:36:42.634]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.634]                         if (muffled) 
[17:36:42.634]                           invokeRestart("muffleMessage")
[17:36:42.634]                       }
[17:36:42.634]                       else if (inherits(cond, "warning")) {
[17:36:42.634]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.634]                         if (muffled) 
[17:36:42.634]                           invokeRestart("muffleWarning")
[17:36:42.634]                       }
[17:36:42.634]                       else if (inherits(cond, "condition")) {
[17:36:42.634]                         if (!is.null(pattern)) {
[17:36:42.634]                           computeRestarts <- base::computeRestarts
[17:36:42.634]                           grepl <- base::grepl
[17:36:42.634]                           restarts <- computeRestarts(cond)
[17:36:42.634]                           for (restart in restarts) {
[17:36:42.634]                             name <- restart$name
[17:36:42.634]                             if (is.null(name)) 
[17:36:42.634]                               next
[17:36:42.634]                             if (!grepl(pattern, name)) 
[17:36:42.634]                               next
[17:36:42.634]                             invokeRestart(restart)
[17:36:42.634]                             muffled <- TRUE
[17:36:42.634]                             break
[17:36:42.634]                           }
[17:36:42.634]                         }
[17:36:42.634]                       }
[17:36:42.634]                       invisible(muffled)
[17:36:42.634]                     }
[17:36:42.634]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.634]                   }
[17:36:42.634]                 }
[17:36:42.634]                 else {
[17:36:42.634]                   if (TRUE) {
[17:36:42.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.634]                     {
[17:36:42.634]                       inherits <- base::inherits
[17:36:42.634]                       invokeRestart <- base::invokeRestart
[17:36:42.634]                       is.null <- base::is.null
[17:36:42.634]                       muffled <- FALSE
[17:36:42.634]                       if (inherits(cond, "message")) {
[17:36:42.634]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.634]                         if (muffled) 
[17:36:42.634]                           invokeRestart("muffleMessage")
[17:36:42.634]                       }
[17:36:42.634]                       else if (inherits(cond, "warning")) {
[17:36:42.634]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.634]                         if (muffled) 
[17:36:42.634]                           invokeRestart("muffleWarning")
[17:36:42.634]                       }
[17:36:42.634]                       else if (inherits(cond, "condition")) {
[17:36:42.634]                         if (!is.null(pattern)) {
[17:36:42.634]                           computeRestarts <- base::computeRestarts
[17:36:42.634]                           grepl <- base::grepl
[17:36:42.634]                           restarts <- computeRestarts(cond)
[17:36:42.634]                           for (restart in restarts) {
[17:36:42.634]                             name <- restart$name
[17:36:42.634]                             if (is.null(name)) 
[17:36:42.634]                               next
[17:36:42.634]                             if (!grepl(pattern, name)) 
[17:36:42.634]                               next
[17:36:42.634]                             invokeRestart(restart)
[17:36:42.634]                             muffled <- TRUE
[17:36:42.634]                             break
[17:36:42.634]                           }
[17:36:42.634]                         }
[17:36:42.634]                       }
[17:36:42.634]                       invisible(muffled)
[17:36:42.634]                     }
[17:36:42.634]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.634]                   }
[17:36:42.634]                 }
[17:36:42.634]             }
[17:36:42.634]         }))
[17:36:42.634]     }, error = function(ex) {
[17:36:42.634]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:42.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.634]                 ...future.rng), started = ...future.startTime, 
[17:36:42.634]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:42.634]             version = "1.8"), class = "FutureResult")
[17:36:42.634]     }, finally = {
[17:36:42.634]         if (!identical(...future.workdir, getwd())) 
[17:36:42.634]             setwd(...future.workdir)
[17:36:42.634]         {
[17:36:42.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:42.634]                 ...future.oldOptions$nwarnings <- NULL
[17:36:42.634]             }
[17:36:42.634]             base::options(...future.oldOptions)
[17:36:42.634]             if (.Platform$OS.type == "windows") {
[17:36:42.634]                 old_names <- names(...future.oldEnvVars)
[17:36:42.634]                 envs <- base::Sys.getenv()
[17:36:42.634]                 names <- names(envs)
[17:36:42.634]                 common <- intersect(names, old_names)
[17:36:42.634]                 added <- setdiff(names, old_names)
[17:36:42.634]                 removed <- setdiff(old_names, names)
[17:36:42.634]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:42.634]                   envs[common]]
[17:36:42.634]                 NAMES <- toupper(changed)
[17:36:42.634]                 args <- list()
[17:36:42.634]                 for (kk in seq_along(NAMES)) {
[17:36:42.634]                   name <- changed[[kk]]
[17:36:42.634]                   NAME <- NAMES[[kk]]
[17:36:42.634]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.634]                     next
[17:36:42.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.634]                 }
[17:36:42.634]                 NAMES <- toupper(added)
[17:36:42.634]                 for (kk in seq_along(NAMES)) {
[17:36:42.634]                   name <- added[[kk]]
[17:36:42.634]                   NAME <- NAMES[[kk]]
[17:36:42.634]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.634]                     next
[17:36:42.634]                   args[[name]] <- ""
[17:36:42.634]                 }
[17:36:42.634]                 NAMES <- toupper(removed)
[17:36:42.634]                 for (kk in seq_along(NAMES)) {
[17:36:42.634]                   name <- removed[[kk]]
[17:36:42.634]                   NAME <- NAMES[[kk]]
[17:36:42.634]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.634]                     next
[17:36:42.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.634]                 }
[17:36:42.634]                 if (length(args) > 0) 
[17:36:42.634]                   base::do.call(base::Sys.setenv, args = args)
[17:36:42.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:42.634]             }
[17:36:42.634]             else {
[17:36:42.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:42.634]             }
[17:36:42.634]             {
[17:36:42.634]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:42.634]                   0L) {
[17:36:42.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:42.634]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:42.634]                   base::options(opts)
[17:36:42.634]                 }
[17:36:42.634]                 {
[17:36:42.634]                   {
[17:36:42.634]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:42.634]                     NULL
[17:36:42.634]                   }
[17:36:42.634]                   options(future.plan = NULL)
[17:36:42.634]                   if (is.na(NA_character_)) 
[17:36:42.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:42.634]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:42.634]                     .init = FALSE)
[17:36:42.634]                 }
[17:36:42.634]             }
[17:36:42.634]         }
[17:36:42.634]     })
[17:36:42.634]     if (TRUE) {
[17:36:42.634]         base::sink(type = "output", split = FALSE)
[17:36:42.634]         if (TRUE) {
[17:36:42.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:42.634]         }
[17:36:42.634]         else {
[17:36:42.634]             ...future.result["stdout"] <- base::list(NULL)
[17:36:42.634]         }
[17:36:42.634]         base::close(...future.stdout)
[17:36:42.634]         ...future.stdout <- NULL
[17:36:42.634]     }
[17:36:42.634]     ...future.result$conditions <- ...future.conditions
[17:36:42.634]     ...future.result$finished <- base::Sys.time()
[17:36:42.634]     ...future.result
[17:36:42.634] }
[17:36:42.636] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:36:42.636] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:36:42.637] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:36:42.637] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:42.637] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.638] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:36:42.638] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:36:42.638] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:42.638] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.639] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:36:42.639] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.639] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:36:42.639] MultisessionFuture started
[17:36:42.639] - Launch lazy future ... done
[17:36:42.640] run() for ‘MultisessionFuture’ ... done
[17:36:42.640] Created future:
[17:36:42.640] MultisessionFuture:
[17:36:42.640] Label: ‘future_by-2’
[17:36:42.640] Expression:
[17:36:42.640] {
[17:36:42.640]     do.call(function(...) {
[17:36:42.640]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.640]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.640]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.640]             on.exit(options(oopts), add = TRUE)
[17:36:42.640]         }
[17:36:42.640]         {
[17:36:42.640]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.640]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.640]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.640]             })
[17:36:42.640]         }
[17:36:42.640]     }, args = future.call.arguments)
[17:36:42.640] }
[17:36:42.640] Lazy evaluation: FALSE
[17:36:42.640] Asynchronous evaluation: TRUE
[17:36:42.640] Local evaluation: TRUE
[17:36:42.640] Environment: 0x5622fb5bef58
[17:36:42.640] Capture standard output: TRUE
[17:36:42.640] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:42.640] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:42.640] Packages: <none>
[17:36:42.640] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:42.640] Resolved: FALSE
[17:36:42.640] Value: <not collected>
[17:36:42.640] Conditions captured: <none>
[17:36:42.640] Early signaling: FALSE
[17:36:42.640] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:42.640] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.652] Chunk #2 of 2 ... DONE
[17:36:42.652] Launching 2 futures (chunks) ... DONE
[17:36:42.652] Resolving 2 futures (chunks) ...
[17:36:42.652] resolve() on list ...
[17:36:42.652]  recursive: 0
[17:36:42.652]  length: 2
[17:36:42.652] 
[17:36:42.653] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.653] - Validating connection of MultisessionFuture
[17:36:42.653] - received message: FutureResult
[17:36:42.653] - Received FutureResult
[17:36:42.653] - Erased future from FutureRegistry
[17:36:42.653] result() for ClusterFuture ...
[17:36:42.653] - result already collected: FutureResult
[17:36:42.654] result() for ClusterFuture ... done
[17:36:42.654] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.654] Future #1
[17:36:42.654] result() for ClusterFuture ...
[17:36:42.654] - result already collected: FutureResult
[17:36:42.654] result() for ClusterFuture ... done
[17:36:42.654] result() for ClusterFuture ...
[17:36:42.654] - result already collected: FutureResult
[17:36:42.654] result() for ClusterFuture ... done
[17:36:42.654] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:42.654] - nx: 2
[17:36:42.655] - relay: TRUE
[17:36:42.655] - stdout: TRUE
[17:36:42.655] - signal: TRUE
[17:36:42.655] - resignal: FALSE
[17:36:42.655] - force: TRUE
[17:36:42.655] - relayed: [n=2] FALSE, FALSE
[17:36:42.655] - queued futures: [n=2] FALSE, FALSE
[17:36:42.655]  - until=1
[17:36:42.655]  - relaying element #1
[17:36:42.655] result() for ClusterFuture ...
[17:36:42.655] - result already collected: FutureResult
[17:36:42.655] result() for ClusterFuture ... done
[17:36:42.656] result() for ClusterFuture ...
[17:36:42.656] - result already collected: FutureResult
[17:36:42.656] result() for ClusterFuture ... done
[17:36:42.656] result() for ClusterFuture ...
[17:36:42.656] - result already collected: FutureResult
[17:36:42.656] result() for ClusterFuture ... done
[17:36:42.656] result() for ClusterFuture ...
[17:36:42.656] - result already collected: FutureResult
[17:36:42.656] result() for ClusterFuture ... done
[17:36:42.656] - relayed: [n=2] TRUE, FALSE
[17:36:42.656] - queued futures: [n=2] TRUE, FALSE
[17:36:42.657] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:42.657]  length: 1 (resolved future 1)
[17:36:42.683] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.683] - Validating connection of MultisessionFuture
[17:36:42.683] - received message: FutureResult
[17:36:42.684] - Received FutureResult
[17:36:42.684] - Erased future from FutureRegistry
[17:36:42.684] result() for ClusterFuture ...
[17:36:42.684] - result already collected: FutureResult
[17:36:42.684] result() for ClusterFuture ... done
[17:36:42.684] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.684] Future #2
[17:36:42.684] result() for ClusterFuture ...
[17:36:42.684] - result already collected: FutureResult
[17:36:42.684] result() for ClusterFuture ... done
[17:36:42.684] result() for ClusterFuture ...
[17:36:42.685] - result already collected: FutureResult
[17:36:42.685] result() for ClusterFuture ... done
[17:36:42.685] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:42.685] - nx: 2
[17:36:42.685] - relay: TRUE
[17:36:42.685] - stdout: TRUE
[17:36:42.685] - signal: TRUE
[17:36:42.685] - resignal: FALSE
[17:36:42.685] - force: TRUE
[17:36:42.685] - relayed: [n=2] TRUE, FALSE
[17:36:42.685] - queued futures: [n=2] TRUE, FALSE
[17:36:42.685]  - until=2
[17:36:42.686]  - relaying element #2
[17:36:42.686] result() for ClusterFuture ...
[17:36:42.686] - result already collected: FutureResult
[17:36:42.686] result() for ClusterFuture ... done
[17:36:42.686] result() for ClusterFuture ...
[17:36:42.686] - result already collected: FutureResult
[17:36:42.686] result() for ClusterFuture ... done
[17:36:42.686] result() for ClusterFuture ...
[17:36:42.686] - result already collected: FutureResult
[17:36:42.686] result() for ClusterFuture ... done
[17:36:42.686] result() for ClusterFuture ...
[17:36:42.687] - result already collected: FutureResult
[17:36:42.687] result() for ClusterFuture ... done
[17:36:42.687] - relayed: [n=2] TRUE, TRUE
[17:36:42.687] - queued futures: [n=2] TRUE, TRUE
[17:36:42.687] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:42.687]  length: 0 (resolved future 2)
[17:36:42.687] Relaying remaining futures
[17:36:42.687] signalConditionsASAP(NULL, pos=0) ...
[17:36:42.687] - nx: 2
[17:36:42.687] - relay: TRUE
[17:36:42.687] - stdout: TRUE
[17:36:42.687] - signal: TRUE
[17:36:42.688] - resignal: FALSE
[17:36:42.688] - force: TRUE
[17:36:42.688] - relayed: [n=2] TRUE, TRUE
[17:36:42.688] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:42.688] - relayed: [n=2] TRUE, TRUE
[17:36:42.688] - queued futures: [n=2] TRUE, TRUE
[17:36:42.688] signalConditionsASAP(NULL, pos=0) ... done
[17:36:42.688] resolve() on list ... DONE
[17:36:42.688] result() for ClusterFuture ...
[17:36:42.688] - result already collected: FutureResult
[17:36:42.688] result() for ClusterFuture ... done
[17:36:42.689] result() for ClusterFuture ...
[17:36:42.689] - result already collected: FutureResult
[17:36:42.689] result() for ClusterFuture ... done
[17:36:42.689] result() for ClusterFuture ...
[17:36:42.689] - result already collected: FutureResult
[17:36:42.689] result() for ClusterFuture ... done
[17:36:42.689] result() for ClusterFuture ...
[17:36:42.689] - result already collected: FutureResult
[17:36:42.689] result() for ClusterFuture ... done
[17:36:42.689]  - Number of value chunks collected: 2
[17:36:42.689] Resolving 2 futures (chunks) ... DONE
[17:36:42.690] Reducing values from 2 chunks ...
[17:36:42.690]  - Number of values collected after concatenation: 3
[17:36:42.690]  - Number of values expected: 3
[17:36:42.690] Reducing values from 2 chunks ... DONE
[17:36:42.690] future_lapply() ... DONE
[17:36:42.690] future_by_internal() ... DONE
[17:36:42.691] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:36:42.691] future_lapply() ...
[17:36:42.696] Number of chunks: 2
[17:36:42.696] getGlobalsAndPackagesXApply() ...
[17:36:42.696]  - future.globals: TRUE
[17:36:42.696] getGlobalsAndPackages() ...
[17:36:42.696] Searching for globals...
[17:36:42.697] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:36:42.697] Searching for globals ... DONE
[17:36:42.697] Resolving globals: FALSE
[17:36:42.700] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:36:42.700] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:36:42.701] - globals: [1] ‘FUN’
[17:36:42.701] 
[17:36:42.701] getGlobalsAndPackages() ... DONE
[17:36:42.701]  - globals found/used: [n=1] ‘FUN’
[17:36:42.701]  - needed namespaces: [n=0] 
[17:36:42.701] Finding globals ... DONE
[17:36:42.701]  - use_args: TRUE
[17:36:42.701]  - Getting '...' globals ...
[17:36:42.702] resolve() on list ...
[17:36:42.702]  recursive: 0
[17:36:42.702]  length: 1
[17:36:42.702]  elements: ‘...’
[17:36:42.702]  length: 0 (resolved future 1)
[17:36:42.702] resolve() on list ... DONE
[17:36:42.702]    - '...' content: [n=0] 
[17:36:42.702] List of 1
[17:36:42.702]  $ ...: list()
[17:36:42.702]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:42.702]  - attr(*, "where")=List of 1
[17:36:42.702]   ..$ ...:<environment: 0x5622feb964f8> 
[17:36:42.702]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:42.702]  - attr(*, "resolved")= logi TRUE
[17:36:42.702]  - attr(*, "total_size")= num NA
[17:36:42.705]  - Getting '...' globals ... DONE
[17:36:42.705] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:36:42.705] List of 2
[17:36:42.705]  $ ...future.FUN:function (object, ...)  
[17:36:42.705]  $ ...          : list()
[17:36:42.705]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:36:42.705]  - attr(*, "where")=List of 2
[17:36:42.705]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:36:42.705]   ..$ ...          :<environment: 0x5622feb964f8> 
[17:36:42.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:36:42.705]  - attr(*, "resolved")= logi FALSE
[17:36:42.705]  - attr(*, "total_size")= num 1240
[17:36:42.708] Packages to be attached in all futures: [n=0] 
[17:36:42.708] getGlobalsAndPackagesXApply() ... DONE
[17:36:42.708] Number of futures (= number of chunks): 2
[17:36:42.708] Launching 2 futures (chunks) ...
[17:36:42.708] Chunk #1 of 2 ...
[17:36:42.708]  - Finding globals in 'X' for chunk #1 ...
[17:36:42.708] getGlobalsAndPackages() ...
[17:36:42.708] Searching for globals...
[17:36:42.709] 
[17:36:42.709] Searching for globals ... DONE
[17:36:42.709] - globals: [0] <none>
[17:36:42.709] getGlobalsAndPackages() ... DONE
[17:36:42.709]    + additional globals found: [n=0] 
[17:36:42.709]    + additional namespaces needed: [n=0] 
[17:36:42.709]  - Finding globals in 'X' for chunk #1 ... DONE
[17:36:42.709]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:42.710]  - seeds: <none>
[17:36:42.710]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.710] getGlobalsAndPackages() ...
[17:36:42.710] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.710] Resolving globals: FALSE
[17:36:42.710] Tweak future expression to call with '...' arguments ...
[17:36:42.710] {
[17:36:42.710]     do.call(function(...) {
[17:36:42.710]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.710]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.710]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.710]             on.exit(options(oopts), add = TRUE)
[17:36:42.710]         }
[17:36:42.710]         {
[17:36:42.710]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.710]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.710]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.710]             })
[17:36:42.710]         }
[17:36:42.710]     }, args = future.call.arguments)
[17:36:42.710] }
[17:36:42.710] Tweak future expression to call with '...' arguments ... DONE
[17:36:42.711] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.711] 
[17:36:42.711] getGlobalsAndPackages() ... DONE
[17:36:42.711] run() for ‘Future’ ...
[17:36:42.711] - state: ‘created’
[17:36:42.711] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:42.726] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:42.726]   - Field: ‘node’
[17:36:42.726]   - Field: ‘label’
[17:36:42.726]   - Field: ‘local’
[17:36:42.726]   - Field: ‘owner’
[17:36:42.727]   - Field: ‘envir’
[17:36:42.727]   - Field: ‘workers’
[17:36:42.727]   - Field: ‘packages’
[17:36:42.727]   - Field: ‘gc’
[17:36:42.727]   - Field: ‘conditions’
[17:36:42.727]   - Field: ‘persistent’
[17:36:42.727]   - Field: ‘expr’
[17:36:42.727]   - Field: ‘uuid’
[17:36:42.727]   - Field: ‘seed’
[17:36:42.727]   - Field: ‘version’
[17:36:42.727]   - Field: ‘result’
[17:36:42.728]   - Field: ‘asynchronous’
[17:36:42.728]   - Field: ‘calls’
[17:36:42.728]   - Field: ‘globals’
[17:36:42.728]   - Field: ‘stdout’
[17:36:42.728]   - Field: ‘earlySignal’
[17:36:42.728]   - Field: ‘lazy’
[17:36:42.728]   - Field: ‘state’
[17:36:42.728] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:42.728] - Launch lazy future ...
[17:36:42.729] Packages needed by the future expression (n = 0): <none>
[17:36:42.729] Packages needed by future strategies (n = 0): <none>
[17:36:42.729] {
[17:36:42.729]     {
[17:36:42.729]         {
[17:36:42.729]             ...future.startTime <- base::Sys.time()
[17:36:42.729]             {
[17:36:42.729]                 {
[17:36:42.729]                   {
[17:36:42.729]                     {
[17:36:42.729]                       base::local({
[17:36:42.729]                         has_future <- base::requireNamespace("future", 
[17:36:42.729]                           quietly = TRUE)
[17:36:42.729]                         if (has_future) {
[17:36:42.729]                           ns <- base::getNamespace("future")
[17:36:42.729]                           version <- ns[[".package"]][["version"]]
[17:36:42.729]                           if (is.null(version)) 
[17:36:42.729]                             version <- utils::packageVersion("future")
[17:36:42.729]                         }
[17:36:42.729]                         else {
[17:36:42.729]                           version <- NULL
[17:36:42.729]                         }
[17:36:42.729]                         if (!has_future || version < "1.8.0") {
[17:36:42.729]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:42.729]                             "", base::R.version$version.string), 
[17:36:42.729]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:42.729]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:42.729]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:42.729]                               "release", "version")], collapse = " "), 
[17:36:42.729]                             hostname = base::Sys.info()[["nodename"]])
[17:36:42.729]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:42.729]                             info)
[17:36:42.729]                           info <- base::paste(info, collapse = "; ")
[17:36:42.729]                           if (!has_future) {
[17:36:42.729]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:42.729]                               info)
[17:36:42.729]                           }
[17:36:42.729]                           else {
[17:36:42.729]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:42.729]                               info, version)
[17:36:42.729]                           }
[17:36:42.729]                           base::stop(msg)
[17:36:42.729]                         }
[17:36:42.729]                       })
[17:36:42.729]                     }
[17:36:42.729]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:42.729]                     base::options(mc.cores = 1L)
[17:36:42.729]                   }
[17:36:42.729]                   ...future.strategy.old <- future::plan("list")
[17:36:42.729]                   options(future.plan = NULL)
[17:36:42.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:42.729]                 }
[17:36:42.729]                 ...future.workdir <- getwd()
[17:36:42.729]             }
[17:36:42.729]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:42.729]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:42.729]         }
[17:36:42.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:42.729]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:42.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:42.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:42.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:42.729]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:42.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:42.729]             base::names(...future.oldOptions))
[17:36:42.729]     }
[17:36:42.729]     if (FALSE) {
[17:36:42.729]     }
[17:36:42.729]     else {
[17:36:42.729]         if (TRUE) {
[17:36:42.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:42.729]                 open = "w")
[17:36:42.729]         }
[17:36:42.729]         else {
[17:36:42.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:42.729]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:42.729]         }
[17:36:42.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:42.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:42.729]             base::sink(type = "output", split = FALSE)
[17:36:42.729]             base::close(...future.stdout)
[17:36:42.729]         }, add = TRUE)
[17:36:42.729]     }
[17:36:42.729]     ...future.frame <- base::sys.nframe()
[17:36:42.729]     ...future.conditions <- base::list()
[17:36:42.729]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:42.729]     if (FALSE) {
[17:36:42.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:42.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:42.729]     }
[17:36:42.729]     ...future.result <- base::tryCatch({
[17:36:42.729]         base::withCallingHandlers({
[17:36:42.729]             ...future.value <- base::withVisible(base::local({
[17:36:42.729]                 ...future.makeSendCondition <- base::local({
[17:36:42.729]                   sendCondition <- NULL
[17:36:42.729]                   function(frame = 1L) {
[17:36:42.729]                     if (is.function(sendCondition)) 
[17:36:42.729]                       return(sendCondition)
[17:36:42.729]                     ns <- getNamespace("parallel")
[17:36:42.729]                     if (exists("sendData", mode = "function", 
[17:36:42.729]                       envir = ns)) {
[17:36:42.729]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:42.729]                         envir = ns)
[17:36:42.729]                       envir <- sys.frame(frame)
[17:36:42.729]                       master <- NULL
[17:36:42.729]                       while (!identical(envir, .GlobalEnv) && 
[17:36:42.729]                         !identical(envir, emptyenv())) {
[17:36:42.729]                         if (exists("master", mode = "list", envir = envir, 
[17:36:42.729]                           inherits = FALSE)) {
[17:36:42.729]                           master <- get("master", mode = "list", 
[17:36:42.729]                             envir = envir, inherits = FALSE)
[17:36:42.729]                           if (inherits(master, c("SOCKnode", 
[17:36:42.729]                             "SOCK0node"))) {
[17:36:42.729]                             sendCondition <<- function(cond) {
[17:36:42.729]                               data <- list(type = "VALUE", value = cond, 
[17:36:42.729]                                 success = TRUE)
[17:36:42.729]                               parallel_sendData(master, data)
[17:36:42.729]                             }
[17:36:42.729]                             return(sendCondition)
[17:36:42.729]                           }
[17:36:42.729]                         }
[17:36:42.729]                         frame <- frame + 1L
[17:36:42.729]                         envir <- sys.frame(frame)
[17:36:42.729]                       }
[17:36:42.729]                     }
[17:36:42.729]                     sendCondition <<- function(cond) NULL
[17:36:42.729]                   }
[17:36:42.729]                 })
[17:36:42.729]                 withCallingHandlers({
[17:36:42.729]                   {
[17:36:42.729]                     do.call(function(...) {
[17:36:42.729]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.729]                       if (!identical(...future.globals.maxSize.org, 
[17:36:42.729]                         ...future.globals.maxSize)) {
[17:36:42.729]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.729]                         on.exit(options(oopts), add = TRUE)
[17:36:42.729]                       }
[17:36:42.729]                       {
[17:36:42.729]                         lapply(seq_along(...future.elements_ii), 
[17:36:42.729]                           FUN = function(jj) {
[17:36:42.729]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.729]                             ...future.FUN(...future.X_jj, ...)
[17:36:42.729]                           })
[17:36:42.729]                       }
[17:36:42.729]                     }, args = future.call.arguments)
[17:36:42.729]                   }
[17:36:42.729]                 }, immediateCondition = function(cond) {
[17:36:42.729]                   sendCondition <- ...future.makeSendCondition()
[17:36:42.729]                   sendCondition(cond)
[17:36:42.729]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.729]                   {
[17:36:42.729]                     inherits <- base::inherits
[17:36:42.729]                     invokeRestart <- base::invokeRestart
[17:36:42.729]                     is.null <- base::is.null
[17:36:42.729]                     muffled <- FALSE
[17:36:42.729]                     if (inherits(cond, "message")) {
[17:36:42.729]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:42.729]                       if (muffled) 
[17:36:42.729]                         invokeRestart("muffleMessage")
[17:36:42.729]                     }
[17:36:42.729]                     else if (inherits(cond, "warning")) {
[17:36:42.729]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:42.729]                       if (muffled) 
[17:36:42.729]                         invokeRestart("muffleWarning")
[17:36:42.729]                     }
[17:36:42.729]                     else if (inherits(cond, "condition")) {
[17:36:42.729]                       if (!is.null(pattern)) {
[17:36:42.729]                         computeRestarts <- base::computeRestarts
[17:36:42.729]                         grepl <- base::grepl
[17:36:42.729]                         restarts <- computeRestarts(cond)
[17:36:42.729]                         for (restart in restarts) {
[17:36:42.729]                           name <- restart$name
[17:36:42.729]                           if (is.null(name)) 
[17:36:42.729]                             next
[17:36:42.729]                           if (!grepl(pattern, name)) 
[17:36:42.729]                             next
[17:36:42.729]                           invokeRestart(restart)
[17:36:42.729]                           muffled <- TRUE
[17:36:42.729]                           break
[17:36:42.729]                         }
[17:36:42.729]                       }
[17:36:42.729]                     }
[17:36:42.729]                     invisible(muffled)
[17:36:42.729]                   }
[17:36:42.729]                   muffleCondition(cond)
[17:36:42.729]                 })
[17:36:42.729]             }))
[17:36:42.729]             future::FutureResult(value = ...future.value$value, 
[17:36:42.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.729]                   ...future.rng), globalenv = if (FALSE) 
[17:36:42.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:42.729]                     ...future.globalenv.names))
[17:36:42.729]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:42.729]         }, condition = base::local({
[17:36:42.729]             c <- base::c
[17:36:42.729]             inherits <- base::inherits
[17:36:42.729]             invokeRestart <- base::invokeRestart
[17:36:42.729]             length <- base::length
[17:36:42.729]             list <- base::list
[17:36:42.729]             seq.int <- base::seq.int
[17:36:42.729]             signalCondition <- base::signalCondition
[17:36:42.729]             sys.calls <- base::sys.calls
[17:36:42.729]             `[[` <- base::`[[`
[17:36:42.729]             `+` <- base::`+`
[17:36:42.729]             `<<-` <- base::`<<-`
[17:36:42.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:42.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:42.729]                   3L)]
[17:36:42.729]             }
[17:36:42.729]             function(cond) {
[17:36:42.729]                 is_error <- inherits(cond, "error")
[17:36:42.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:42.729]                   NULL)
[17:36:42.729]                 if (is_error) {
[17:36:42.729]                   sessionInformation <- function() {
[17:36:42.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:42.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:42.729]                       search = base::search(), system = base::Sys.info())
[17:36:42.729]                   }
[17:36:42.729]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:42.729]                     cond$call), session = sessionInformation(), 
[17:36:42.729]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:42.729]                   signalCondition(cond)
[17:36:42.729]                 }
[17:36:42.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:42.729]                 "immediateCondition"))) {
[17:36:42.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:42.729]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:42.729]                   if (TRUE && !signal) {
[17:36:42.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.729]                     {
[17:36:42.729]                       inherits <- base::inherits
[17:36:42.729]                       invokeRestart <- base::invokeRestart
[17:36:42.729]                       is.null <- base::is.null
[17:36:42.729]                       muffled <- FALSE
[17:36:42.729]                       if (inherits(cond, "message")) {
[17:36:42.729]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.729]                         if (muffled) 
[17:36:42.729]                           invokeRestart("muffleMessage")
[17:36:42.729]                       }
[17:36:42.729]                       else if (inherits(cond, "warning")) {
[17:36:42.729]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.729]                         if (muffled) 
[17:36:42.729]                           invokeRestart("muffleWarning")
[17:36:42.729]                       }
[17:36:42.729]                       else if (inherits(cond, "condition")) {
[17:36:42.729]                         if (!is.null(pattern)) {
[17:36:42.729]                           computeRestarts <- base::computeRestarts
[17:36:42.729]                           grepl <- base::grepl
[17:36:42.729]                           restarts <- computeRestarts(cond)
[17:36:42.729]                           for (restart in restarts) {
[17:36:42.729]                             name <- restart$name
[17:36:42.729]                             if (is.null(name)) 
[17:36:42.729]                               next
[17:36:42.729]                             if (!grepl(pattern, name)) 
[17:36:42.729]                               next
[17:36:42.729]                             invokeRestart(restart)
[17:36:42.729]                             muffled <- TRUE
[17:36:42.729]                             break
[17:36:42.729]                           }
[17:36:42.729]                         }
[17:36:42.729]                       }
[17:36:42.729]                       invisible(muffled)
[17:36:42.729]                     }
[17:36:42.729]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.729]                   }
[17:36:42.729]                 }
[17:36:42.729]                 else {
[17:36:42.729]                   if (TRUE) {
[17:36:42.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.729]                     {
[17:36:42.729]                       inherits <- base::inherits
[17:36:42.729]                       invokeRestart <- base::invokeRestart
[17:36:42.729]                       is.null <- base::is.null
[17:36:42.729]                       muffled <- FALSE
[17:36:42.729]                       if (inherits(cond, "message")) {
[17:36:42.729]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.729]                         if (muffled) 
[17:36:42.729]                           invokeRestart("muffleMessage")
[17:36:42.729]                       }
[17:36:42.729]                       else if (inherits(cond, "warning")) {
[17:36:42.729]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.729]                         if (muffled) 
[17:36:42.729]                           invokeRestart("muffleWarning")
[17:36:42.729]                       }
[17:36:42.729]                       else if (inherits(cond, "condition")) {
[17:36:42.729]                         if (!is.null(pattern)) {
[17:36:42.729]                           computeRestarts <- base::computeRestarts
[17:36:42.729]                           grepl <- base::grepl
[17:36:42.729]                           restarts <- computeRestarts(cond)
[17:36:42.729]                           for (restart in restarts) {
[17:36:42.729]                             name <- restart$name
[17:36:42.729]                             if (is.null(name)) 
[17:36:42.729]                               next
[17:36:42.729]                             if (!grepl(pattern, name)) 
[17:36:42.729]                               next
[17:36:42.729]                             invokeRestart(restart)
[17:36:42.729]                             muffled <- TRUE
[17:36:42.729]                             break
[17:36:42.729]                           }
[17:36:42.729]                         }
[17:36:42.729]                       }
[17:36:42.729]                       invisible(muffled)
[17:36:42.729]                     }
[17:36:42.729]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.729]                   }
[17:36:42.729]                 }
[17:36:42.729]             }
[17:36:42.729]         }))
[17:36:42.729]     }, error = function(ex) {
[17:36:42.729]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:42.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.729]                 ...future.rng), started = ...future.startTime, 
[17:36:42.729]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:42.729]             version = "1.8"), class = "FutureResult")
[17:36:42.729]     }, finally = {
[17:36:42.729]         if (!identical(...future.workdir, getwd())) 
[17:36:42.729]             setwd(...future.workdir)
[17:36:42.729]         {
[17:36:42.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:42.729]                 ...future.oldOptions$nwarnings <- NULL
[17:36:42.729]             }
[17:36:42.729]             base::options(...future.oldOptions)
[17:36:42.729]             if (.Platform$OS.type == "windows") {
[17:36:42.729]                 old_names <- names(...future.oldEnvVars)
[17:36:42.729]                 envs <- base::Sys.getenv()
[17:36:42.729]                 names <- names(envs)
[17:36:42.729]                 common <- intersect(names, old_names)
[17:36:42.729]                 added <- setdiff(names, old_names)
[17:36:42.729]                 removed <- setdiff(old_names, names)
[17:36:42.729]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:42.729]                   envs[common]]
[17:36:42.729]                 NAMES <- toupper(changed)
[17:36:42.729]                 args <- list()
[17:36:42.729]                 for (kk in seq_along(NAMES)) {
[17:36:42.729]                   name <- changed[[kk]]
[17:36:42.729]                   NAME <- NAMES[[kk]]
[17:36:42.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.729]                     next
[17:36:42.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.729]                 }
[17:36:42.729]                 NAMES <- toupper(added)
[17:36:42.729]                 for (kk in seq_along(NAMES)) {
[17:36:42.729]                   name <- added[[kk]]
[17:36:42.729]                   NAME <- NAMES[[kk]]
[17:36:42.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.729]                     next
[17:36:42.729]                   args[[name]] <- ""
[17:36:42.729]                 }
[17:36:42.729]                 NAMES <- toupper(removed)
[17:36:42.729]                 for (kk in seq_along(NAMES)) {
[17:36:42.729]                   name <- removed[[kk]]
[17:36:42.729]                   NAME <- NAMES[[kk]]
[17:36:42.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.729]                     next
[17:36:42.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.729]                 }
[17:36:42.729]                 if (length(args) > 0) 
[17:36:42.729]                   base::do.call(base::Sys.setenv, args = args)
[17:36:42.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:42.729]             }
[17:36:42.729]             else {
[17:36:42.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:42.729]             }
[17:36:42.729]             {
[17:36:42.729]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:42.729]                   0L) {
[17:36:42.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:42.729]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:42.729]                   base::options(opts)
[17:36:42.729]                 }
[17:36:42.729]                 {
[17:36:42.729]                   {
[17:36:42.729]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:42.729]                     NULL
[17:36:42.729]                   }
[17:36:42.729]                   options(future.plan = NULL)
[17:36:42.729]                   if (is.na(NA_character_)) 
[17:36:42.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:42.729]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:42.729]                     .init = FALSE)
[17:36:42.729]                 }
[17:36:42.729]             }
[17:36:42.729]         }
[17:36:42.729]     })
[17:36:42.729]     if (TRUE) {
[17:36:42.729]         base::sink(type = "output", split = FALSE)
[17:36:42.729]         if (TRUE) {
[17:36:42.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:42.729]         }
[17:36:42.729]         else {
[17:36:42.729]             ...future.result["stdout"] <- base::list(NULL)
[17:36:42.729]         }
[17:36:42.729]         base::close(...future.stdout)
[17:36:42.729]         ...future.stdout <- NULL
[17:36:42.729]     }
[17:36:42.729]     ...future.result$conditions <- ...future.conditions
[17:36:42.729]     ...future.result$finished <- base::Sys.time()
[17:36:42.729]     ...future.result
[17:36:42.729] }
[17:36:42.732] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:36:42.732] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:36:42.732] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:36:42.733] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:36:42.733] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.733] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:36:42.734] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:36:42.734] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:36:42.734] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.734] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:36:42.735] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:36:42.735] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:36:42.735] MultisessionFuture started
[17:36:42.736] - Launch lazy future ... done
[17:36:42.736] run() for ‘MultisessionFuture’ ... done
[17:36:42.736] Created future:
[17:36:42.736] MultisessionFuture:
[17:36:42.736] Label: ‘future_by-1’
[17:36:42.736] Expression:
[17:36:42.736] {
[17:36:42.736]     do.call(function(...) {
[17:36:42.736]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.736]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.736]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.736]             on.exit(options(oopts), add = TRUE)
[17:36:42.736]         }
[17:36:42.736]         {
[17:36:42.736]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.736]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.736]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.736]             })
[17:36:42.736]         }
[17:36:42.736]     }, args = future.call.arguments)
[17:36:42.736] }
[17:36:42.736] Lazy evaluation: FALSE
[17:36:42.736] Asynchronous evaluation: TRUE
[17:36:42.736] Local evaluation: TRUE
[17:36:42.736] Environment: 0x5622feb64638
[17:36:42.736] Capture standard output: TRUE
[17:36:42.736] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:42.736] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:42.736] Packages: <none>
[17:36:42.736] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:42.736] Resolved: FALSE
[17:36:42.736] Value: <not collected>
[17:36:42.736] Conditions captured: <none>
[17:36:42.736] Early signaling: FALSE
[17:36:42.736] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:42.736] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.748] Chunk #1 of 2 ... DONE
[17:36:42.748] Chunk #2 of 2 ...
[17:36:42.748]  - Finding globals in 'X' for chunk #2 ...
[17:36:42.748] getGlobalsAndPackages() ...
[17:36:42.748] Searching for globals...
[17:36:42.749] 
[17:36:42.749] Searching for globals ... DONE
[17:36:42.749] - globals: [0] <none>
[17:36:42.749] getGlobalsAndPackages() ... DONE
[17:36:42.749]    + additional globals found: [n=0] 
[17:36:42.749]    + additional namespaces needed: [n=0] 
[17:36:42.749]  - Finding globals in 'X' for chunk #2 ... DONE
[17:36:42.749]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:36:42.749]  - seeds: <none>
[17:36:42.749]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.750] getGlobalsAndPackages() ...
[17:36:42.750] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.750] Resolving globals: FALSE
[17:36:42.750] Tweak future expression to call with '...' arguments ...
[17:36:42.750] {
[17:36:42.750]     do.call(function(...) {
[17:36:42.750]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.750]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.750]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.750]             on.exit(options(oopts), add = TRUE)
[17:36:42.750]         }
[17:36:42.750]         {
[17:36:42.750]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.750]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.750]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.750]             })
[17:36:42.750]         }
[17:36:42.750]     }, args = future.call.arguments)
[17:36:42.750] }
[17:36:42.750] Tweak future expression to call with '...' arguments ... DONE
[17:36:42.751] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:36:42.751] 
[17:36:42.751] getGlobalsAndPackages() ... DONE
[17:36:42.751] run() for ‘Future’ ...
[17:36:42.751] - state: ‘created’
[17:36:42.751] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:36:42.766] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:36:42.766]   - Field: ‘node’
[17:36:42.766]   - Field: ‘label’
[17:36:42.766]   - Field: ‘local’
[17:36:42.766]   - Field: ‘owner’
[17:36:42.766]   - Field: ‘envir’
[17:36:42.766]   - Field: ‘workers’
[17:36:42.767]   - Field: ‘packages’
[17:36:42.767]   - Field: ‘gc’
[17:36:42.767]   - Field: ‘conditions’
[17:36:42.767]   - Field: ‘persistent’
[17:36:42.767]   - Field: ‘expr’
[17:36:42.767]   - Field: ‘uuid’
[17:36:42.767]   - Field: ‘seed’
[17:36:42.767]   - Field: ‘version’
[17:36:42.767]   - Field: ‘result’
[17:36:42.767]   - Field: ‘asynchronous’
[17:36:42.768]   - Field: ‘calls’
[17:36:42.768]   - Field: ‘globals’
[17:36:42.768]   - Field: ‘stdout’
[17:36:42.768]   - Field: ‘earlySignal’
[17:36:42.768]   - Field: ‘lazy’
[17:36:42.768]   - Field: ‘state’
[17:36:42.768] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:36:42.768] - Launch lazy future ...
[17:36:42.768] Packages needed by the future expression (n = 0): <none>
[17:36:42.769] Packages needed by future strategies (n = 0): <none>
[17:36:42.769] {
[17:36:42.769]     {
[17:36:42.769]         {
[17:36:42.769]             ...future.startTime <- base::Sys.time()
[17:36:42.769]             {
[17:36:42.769]                 {
[17:36:42.769]                   {
[17:36:42.769]                     {
[17:36:42.769]                       base::local({
[17:36:42.769]                         has_future <- base::requireNamespace("future", 
[17:36:42.769]                           quietly = TRUE)
[17:36:42.769]                         if (has_future) {
[17:36:42.769]                           ns <- base::getNamespace("future")
[17:36:42.769]                           version <- ns[[".package"]][["version"]]
[17:36:42.769]                           if (is.null(version)) 
[17:36:42.769]                             version <- utils::packageVersion("future")
[17:36:42.769]                         }
[17:36:42.769]                         else {
[17:36:42.769]                           version <- NULL
[17:36:42.769]                         }
[17:36:42.769]                         if (!has_future || version < "1.8.0") {
[17:36:42.769]                           info <- base::c(r_version = base::gsub("R version ", 
[17:36:42.769]                             "", base::R.version$version.string), 
[17:36:42.769]                             platform = base::sprintf("%s (%s-bit)", 
[17:36:42.769]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:36:42.769]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:36:42.769]                               "release", "version")], collapse = " "), 
[17:36:42.769]                             hostname = base::Sys.info()[["nodename"]])
[17:36:42.769]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:36:42.769]                             info)
[17:36:42.769]                           info <- base::paste(info, collapse = "; ")
[17:36:42.769]                           if (!has_future) {
[17:36:42.769]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:36:42.769]                               info)
[17:36:42.769]                           }
[17:36:42.769]                           else {
[17:36:42.769]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:36:42.769]                               info, version)
[17:36:42.769]                           }
[17:36:42.769]                           base::stop(msg)
[17:36:42.769]                         }
[17:36:42.769]                       })
[17:36:42.769]                     }
[17:36:42.769]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:36:42.769]                     base::options(mc.cores = 1L)
[17:36:42.769]                   }
[17:36:42.769]                   ...future.strategy.old <- future::plan("list")
[17:36:42.769]                   options(future.plan = NULL)
[17:36:42.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.769]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:36:42.769]                 }
[17:36:42.769]                 ...future.workdir <- getwd()
[17:36:42.769]             }
[17:36:42.769]             ...future.oldOptions <- base::as.list(base::.Options)
[17:36:42.769]             ...future.oldEnvVars <- base::Sys.getenv()
[17:36:42.769]         }
[17:36:42.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:36:42.769]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:36:42.769]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:36:42.769]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:36:42.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:36:42.769]             future.stdout.windows.reencode = NULL, width = 80L)
[17:36:42.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:36:42.769]             base::names(...future.oldOptions))
[17:36:42.769]     }
[17:36:42.769]     if (FALSE) {
[17:36:42.769]     }
[17:36:42.769]     else {
[17:36:42.769]         if (TRUE) {
[17:36:42.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:36:42.769]                 open = "w")
[17:36:42.769]         }
[17:36:42.769]         else {
[17:36:42.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:36:42.769]                 windows = "NUL", "/dev/null"), open = "w")
[17:36:42.769]         }
[17:36:42.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:36:42.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:36:42.769]             base::sink(type = "output", split = FALSE)
[17:36:42.769]             base::close(...future.stdout)
[17:36:42.769]         }, add = TRUE)
[17:36:42.769]     }
[17:36:42.769]     ...future.frame <- base::sys.nframe()
[17:36:42.769]     ...future.conditions <- base::list()
[17:36:42.769]     ...future.rng <- base::globalenv()$.Random.seed
[17:36:42.769]     if (FALSE) {
[17:36:42.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:36:42.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:36:42.769]     }
[17:36:42.769]     ...future.result <- base::tryCatch({
[17:36:42.769]         base::withCallingHandlers({
[17:36:42.769]             ...future.value <- base::withVisible(base::local({
[17:36:42.769]                 ...future.makeSendCondition <- base::local({
[17:36:42.769]                   sendCondition <- NULL
[17:36:42.769]                   function(frame = 1L) {
[17:36:42.769]                     if (is.function(sendCondition)) 
[17:36:42.769]                       return(sendCondition)
[17:36:42.769]                     ns <- getNamespace("parallel")
[17:36:42.769]                     if (exists("sendData", mode = "function", 
[17:36:42.769]                       envir = ns)) {
[17:36:42.769]                       parallel_sendData <- get("sendData", mode = "function", 
[17:36:42.769]                         envir = ns)
[17:36:42.769]                       envir <- sys.frame(frame)
[17:36:42.769]                       master <- NULL
[17:36:42.769]                       while (!identical(envir, .GlobalEnv) && 
[17:36:42.769]                         !identical(envir, emptyenv())) {
[17:36:42.769]                         if (exists("master", mode = "list", envir = envir, 
[17:36:42.769]                           inherits = FALSE)) {
[17:36:42.769]                           master <- get("master", mode = "list", 
[17:36:42.769]                             envir = envir, inherits = FALSE)
[17:36:42.769]                           if (inherits(master, c("SOCKnode", 
[17:36:42.769]                             "SOCK0node"))) {
[17:36:42.769]                             sendCondition <<- function(cond) {
[17:36:42.769]                               data <- list(type = "VALUE", value = cond, 
[17:36:42.769]                                 success = TRUE)
[17:36:42.769]                               parallel_sendData(master, data)
[17:36:42.769]                             }
[17:36:42.769]                             return(sendCondition)
[17:36:42.769]                           }
[17:36:42.769]                         }
[17:36:42.769]                         frame <- frame + 1L
[17:36:42.769]                         envir <- sys.frame(frame)
[17:36:42.769]                       }
[17:36:42.769]                     }
[17:36:42.769]                     sendCondition <<- function(cond) NULL
[17:36:42.769]                   }
[17:36:42.769]                 })
[17:36:42.769]                 withCallingHandlers({
[17:36:42.769]                   {
[17:36:42.769]                     do.call(function(...) {
[17:36:42.769]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.769]                       if (!identical(...future.globals.maxSize.org, 
[17:36:42.769]                         ...future.globals.maxSize)) {
[17:36:42.769]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.769]                         on.exit(options(oopts), add = TRUE)
[17:36:42.769]                       }
[17:36:42.769]                       {
[17:36:42.769]                         lapply(seq_along(...future.elements_ii), 
[17:36:42.769]                           FUN = function(jj) {
[17:36:42.769]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.769]                             ...future.FUN(...future.X_jj, ...)
[17:36:42.769]                           })
[17:36:42.769]                       }
[17:36:42.769]                     }, args = future.call.arguments)
[17:36:42.769]                   }
[17:36:42.769]                 }, immediateCondition = function(cond) {
[17:36:42.769]                   sendCondition <- ...future.makeSendCondition()
[17:36:42.769]                   sendCondition(cond)
[17:36:42.769]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.769]                   {
[17:36:42.769]                     inherits <- base::inherits
[17:36:42.769]                     invokeRestart <- base::invokeRestart
[17:36:42.769]                     is.null <- base::is.null
[17:36:42.769]                     muffled <- FALSE
[17:36:42.769]                     if (inherits(cond, "message")) {
[17:36:42.769]                       muffled <- grepl(pattern, "muffleMessage")
[17:36:42.769]                       if (muffled) 
[17:36:42.769]                         invokeRestart("muffleMessage")
[17:36:42.769]                     }
[17:36:42.769]                     else if (inherits(cond, "warning")) {
[17:36:42.769]                       muffled <- grepl(pattern, "muffleWarning")
[17:36:42.769]                       if (muffled) 
[17:36:42.769]                         invokeRestart("muffleWarning")
[17:36:42.769]                     }
[17:36:42.769]                     else if (inherits(cond, "condition")) {
[17:36:42.769]                       if (!is.null(pattern)) {
[17:36:42.769]                         computeRestarts <- base::computeRestarts
[17:36:42.769]                         grepl <- base::grepl
[17:36:42.769]                         restarts <- computeRestarts(cond)
[17:36:42.769]                         for (restart in restarts) {
[17:36:42.769]                           name <- restart$name
[17:36:42.769]                           if (is.null(name)) 
[17:36:42.769]                             next
[17:36:42.769]                           if (!grepl(pattern, name)) 
[17:36:42.769]                             next
[17:36:42.769]                           invokeRestart(restart)
[17:36:42.769]                           muffled <- TRUE
[17:36:42.769]                           break
[17:36:42.769]                         }
[17:36:42.769]                       }
[17:36:42.769]                     }
[17:36:42.769]                     invisible(muffled)
[17:36:42.769]                   }
[17:36:42.769]                   muffleCondition(cond)
[17:36:42.769]                 })
[17:36:42.769]             }))
[17:36:42.769]             future::FutureResult(value = ...future.value$value, 
[17:36:42.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.769]                   ...future.rng), globalenv = if (FALSE) 
[17:36:42.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:36:42.769]                     ...future.globalenv.names))
[17:36:42.769]                 else NULL, started = ...future.startTime, version = "1.8")
[17:36:42.769]         }, condition = base::local({
[17:36:42.769]             c <- base::c
[17:36:42.769]             inherits <- base::inherits
[17:36:42.769]             invokeRestart <- base::invokeRestart
[17:36:42.769]             length <- base::length
[17:36:42.769]             list <- base::list
[17:36:42.769]             seq.int <- base::seq.int
[17:36:42.769]             signalCondition <- base::signalCondition
[17:36:42.769]             sys.calls <- base::sys.calls
[17:36:42.769]             `[[` <- base::`[[`
[17:36:42.769]             `+` <- base::`+`
[17:36:42.769]             `<<-` <- base::`<<-`
[17:36:42.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:36:42.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:36:42.769]                   3L)]
[17:36:42.769]             }
[17:36:42.769]             function(cond) {
[17:36:42.769]                 is_error <- inherits(cond, "error")
[17:36:42.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:36:42.769]                   NULL)
[17:36:42.769]                 if (is_error) {
[17:36:42.769]                   sessionInformation <- function() {
[17:36:42.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:36:42.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:36:42.769]                       search = base::search(), system = base::Sys.info())
[17:36:42.769]                   }
[17:36:42.769]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:36:42.769]                     cond$call), session = sessionInformation(), 
[17:36:42.769]                     timestamp = base::Sys.time(), signaled = 0L)
[17:36:42.769]                   signalCondition(cond)
[17:36:42.769]                 }
[17:36:42.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:36:42.769]                 "immediateCondition"))) {
[17:36:42.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:36:42.769]                   ...future.conditions[[length(...future.conditions) + 
[17:36:42.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:36:42.769]                   if (TRUE && !signal) {
[17:36:42.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.769]                     {
[17:36:42.769]                       inherits <- base::inherits
[17:36:42.769]                       invokeRestart <- base::invokeRestart
[17:36:42.769]                       is.null <- base::is.null
[17:36:42.769]                       muffled <- FALSE
[17:36:42.769]                       if (inherits(cond, "message")) {
[17:36:42.769]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.769]                         if (muffled) 
[17:36:42.769]                           invokeRestart("muffleMessage")
[17:36:42.769]                       }
[17:36:42.769]                       else if (inherits(cond, "warning")) {
[17:36:42.769]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.769]                         if (muffled) 
[17:36:42.769]                           invokeRestart("muffleWarning")
[17:36:42.769]                       }
[17:36:42.769]                       else if (inherits(cond, "condition")) {
[17:36:42.769]                         if (!is.null(pattern)) {
[17:36:42.769]                           computeRestarts <- base::computeRestarts
[17:36:42.769]                           grepl <- base::grepl
[17:36:42.769]                           restarts <- computeRestarts(cond)
[17:36:42.769]                           for (restart in restarts) {
[17:36:42.769]                             name <- restart$name
[17:36:42.769]                             if (is.null(name)) 
[17:36:42.769]                               next
[17:36:42.769]                             if (!grepl(pattern, name)) 
[17:36:42.769]                               next
[17:36:42.769]                             invokeRestart(restart)
[17:36:42.769]                             muffled <- TRUE
[17:36:42.769]                             break
[17:36:42.769]                           }
[17:36:42.769]                         }
[17:36:42.769]                       }
[17:36:42.769]                       invisible(muffled)
[17:36:42.769]                     }
[17:36:42.769]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.769]                   }
[17:36:42.769]                 }
[17:36:42.769]                 else {
[17:36:42.769]                   if (TRUE) {
[17:36:42.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:36:42.769]                     {
[17:36:42.769]                       inherits <- base::inherits
[17:36:42.769]                       invokeRestart <- base::invokeRestart
[17:36:42.769]                       is.null <- base::is.null
[17:36:42.769]                       muffled <- FALSE
[17:36:42.769]                       if (inherits(cond, "message")) {
[17:36:42.769]                         muffled <- grepl(pattern, "muffleMessage")
[17:36:42.769]                         if (muffled) 
[17:36:42.769]                           invokeRestart("muffleMessage")
[17:36:42.769]                       }
[17:36:42.769]                       else if (inherits(cond, "warning")) {
[17:36:42.769]                         muffled <- grepl(pattern, "muffleWarning")
[17:36:42.769]                         if (muffled) 
[17:36:42.769]                           invokeRestart("muffleWarning")
[17:36:42.769]                       }
[17:36:42.769]                       else if (inherits(cond, "condition")) {
[17:36:42.769]                         if (!is.null(pattern)) {
[17:36:42.769]                           computeRestarts <- base::computeRestarts
[17:36:42.769]                           grepl <- base::grepl
[17:36:42.769]                           restarts <- computeRestarts(cond)
[17:36:42.769]                           for (restart in restarts) {
[17:36:42.769]                             name <- restart$name
[17:36:42.769]                             if (is.null(name)) 
[17:36:42.769]                               next
[17:36:42.769]                             if (!grepl(pattern, name)) 
[17:36:42.769]                               next
[17:36:42.769]                             invokeRestart(restart)
[17:36:42.769]                             muffled <- TRUE
[17:36:42.769]                             break
[17:36:42.769]                           }
[17:36:42.769]                         }
[17:36:42.769]                       }
[17:36:42.769]                       invisible(muffled)
[17:36:42.769]                     }
[17:36:42.769]                     muffleCondition(cond, pattern = "^muffle")
[17:36:42.769]                   }
[17:36:42.769]                 }
[17:36:42.769]             }
[17:36:42.769]         }))
[17:36:42.769]     }, error = function(ex) {
[17:36:42.769]         base::structure(base::list(value = NULL, visible = NULL, 
[17:36:42.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:36:42.769]                 ...future.rng), started = ...future.startTime, 
[17:36:42.769]             finished = Sys.time(), session_uuid = NA_character_, 
[17:36:42.769]             version = "1.8"), class = "FutureResult")
[17:36:42.769]     }, finally = {
[17:36:42.769]         if (!identical(...future.workdir, getwd())) 
[17:36:42.769]             setwd(...future.workdir)
[17:36:42.769]         {
[17:36:42.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:36:42.769]                 ...future.oldOptions$nwarnings <- NULL
[17:36:42.769]             }
[17:36:42.769]             base::options(...future.oldOptions)
[17:36:42.769]             if (.Platform$OS.type == "windows") {
[17:36:42.769]                 old_names <- names(...future.oldEnvVars)
[17:36:42.769]                 envs <- base::Sys.getenv()
[17:36:42.769]                 names <- names(envs)
[17:36:42.769]                 common <- intersect(names, old_names)
[17:36:42.769]                 added <- setdiff(names, old_names)
[17:36:42.769]                 removed <- setdiff(old_names, names)
[17:36:42.769]                 changed <- common[...future.oldEnvVars[common] != 
[17:36:42.769]                   envs[common]]
[17:36:42.769]                 NAMES <- toupper(changed)
[17:36:42.769]                 args <- list()
[17:36:42.769]                 for (kk in seq_along(NAMES)) {
[17:36:42.769]                   name <- changed[[kk]]
[17:36:42.769]                   NAME <- NAMES[[kk]]
[17:36:42.769]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.769]                     next
[17:36:42.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.769]                 }
[17:36:42.769]                 NAMES <- toupper(added)
[17:36:42.769]                 for (kk in seq_along(NAMES)) {
[17:36:42.769]                   name <- added[[kk]]
[17:36:42.769]                   NAME <- NAMES[[kk]]
[17:36:42.769]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.769]                     next
[17:36:42.769]                   args[[name]] <- ""
[17:36:42.769]                 }
[17:36:42.769]                 NAMES <- toupper(removed)
[17:36:42.769]                 for (kk in seq_along(NAMES)) {
[17:36:42.769]                   name <- removed[[kk]]
[17:36:42.769]                   NAME <- NAMES[[kk]]
[17:36:42.769]                   if (name != NAME && is.element(NAME, old_names)) 
[17:36:42.769]                     next
[17:36:42.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:36:42.769]                 }
[17:36:42.769]                 if (length(args) > 0) 
[17:36:42.769]                   base::do.call(base::Sys.setenv, args = args)
[17:36:42.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:36:42.769]             }
[17:36:42.769]             else {
[17:36:42.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:36:42.769]             }
[17:36:42.769]             {
[17:36:42.769]                 if (base::length(...future.futureOptionsAdded) > 
[17:36:42.769]                   0L) {
[17:36:42.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:36:42.769]                   base::names(opts) <- ...future.futureOptionsAdded
[17:36:42.769]                   base::options(opts)
[17:36:42.769]                 }
[17:36:42.769]                 {
[17:36:42.769]                   {
[17:36:42.769]                     base::options(mc.cores = ...future.mc.cores.old)
[17:36:42.769]                     NULL
[17:36:42.769]                   }
[17:36:42.769]                   options(future.plan = NULL)
[17:36:42.769]                   if (is.na(NA_character_)) 
[17:36:42.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:36:42.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:36:42.769]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:36:42.769]                     .init = FALSE)
[17:36:42.769]                 }
[17:36:42.769]             }
[17:36:42.769]         }
[17:36:42.769]     })
[17:36:42.769]     if (TRUE) {
[17:36:42.769]         base::sink(type = "output", split = FALSE)
[17:36:42.769]         if (TRUE) {
[17:36:42.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:36:42.769]         }
[17:36:42.769]         else {
[17:36:42.769]             ...future.result["stdout"] <- base::list(NULL)
[17:36:42.769]         }
[17:36:42.769]         base::close(...future.stdout)
[17:36:42.769]         ...future.stdout <- NULL
[17:36:42.769]     }
[17:36:42.769]     ...future.result$conditions <- ...future.conditions
[17:36:42.769]     ...future.result$finished <- base::Sys.time()
[17:36:42.769]     ...future.result
[17:36:42.769] }
[17:36:42.772] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:36:42.772] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:36:42.772] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:36:42.773] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:36:42.773] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.773] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:36:42.773] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:36:42.774] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:36:42.774] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.774] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:36:42.774] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:36:42.774] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:36:42.775] MultisessionFuture started
[17:36:42.775] - Launch lazy future ... done
[17:36:42.775] run() for ‘MultisessionFuture’ ... done
[17:36:42.775] Created future:
[17:36:42.775] MultisessionFuture:
[17:36:42.775] Label: ‘future_by-2’
[17:36:42.775] Expression:
[17:36:42.775] {
[17:36:42.775]     do.call(function(...) {
[17:36:42.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:36:42.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:36:42.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:36:42.775]             on.exit(options(oopts), add = TRUE)
[17:36:42.775]         }
[17:36:42.775]         {
[17:36:42.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:36:42.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:36:42.775]                 ...future.FUN(...future.X_jj, ...)
[17:36:42.775]             })
[17:36:42.775]         }
[17:36:42.775]     }, args = future.call.arguments)
[17:36:42.775] }
[17:36:42.775] Lazy evaluation: FALSE
[17:36:42.775] Asynchronous evaluation: TRUE
[17:36:42.775] Local evaluation: TRUE
[17:36:42.775] Environment: 0x5622feb64638
[17:36:42.775] Capture standard output: TRUE
[17:36:42.775] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:36:42.775] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:36:42.775] Packages: <none>
[17:36:42.775] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:36:42.775] Resolved: FALSE
[17:36:42.775] Value: <not collected>
[17:36:42.775] Conditions captured: <none>
[17:36:42.775] Early signaling: FALSE
[17:36:42.775] Owner process: 30e46338-6fd1-e71b-68e5-66aea67701d1
[17:36:42.775] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:36:42.787] Chunk #2 of 2 ... DONE
[17:36:42.787] Launching 2 futures (chunks) ... DONE
[17:36:42.787] Resolving 2 futures (chunks) ...
[17:36:42.788] resolve() on list ...
[17:36:42.788]  recursive: 0
[17:36:42.788]  length: 2
[17:36:42.788] 
[17:36:42.788] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.789] - Validating connection of MultisessionFuture
[17:36:42.789] - received message: FutureResult
[17:36:42.789] - Received FutureResult
[17:36:42.789] - Erased future from FutureRegistry
[17:36:42.789] result() for ClusterFuture ...
[17:36:42.789] - result already collected: FutureResult
[17:36:42.789] result() for ClusterFuture ... done
[17:36:42.789] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.789] Future #1
[17:36:42.789] result() for ClusterFuture ...
[17:36:42.790] - result already collected: FutureResult
[17:36:42.790] result() for ClusterFuture ... done
[17:36:42.790] result() for ClusterFuture ...
[17:36:42.790] - result already collected: FutureResult
[17:36:42.790] result() for ClusterFuture ... done
[17:36:42.790] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:36:42.790] - nx: 2
[17:36:42.790] - relay: TRUE
[17:36:42.790] - stdout: TRUE
[17:36:42.790] - signal: TRUE
[17:36:42.790] - resignal: FALSE
[17:36:42.791] - force: TRUE
[17:36:42.791] - relayed: [n=2] FALSE, FALSE
[17:36:42.791] - queued futures: [n=2] FALSE, FALSE
[17:36:42.791]  - until=1
[17:36:42.791]  - relaying element #1
[17:36:42.791] result() for ClusterFuture ...
[17:36:42.791] - result already collected: FutureResult
[17:36:42.791] result() for ClusterFuture ... done
[17:36:42.791] result() for ClusterFuture ...
[17:36:42.791] - result already collected: FutureResult
[17:36:42.791] result() for ClusterFuture ... done
[17:36:42.792] result() for ClusterFuture ...
[17:36:42.792] - result already collected: FutureResult
[17:36:42.792] result() for ClusterFuture ... done
[17:36:42.792] result() for ClusterFuture ...
[17:36:42.792] - result already collected: FutureResult
[17:36:42.792] result() for ClusterFuture ... done
[17:36:42.792] - relayed: [n=2] TRUE, FALSE
[17:36:42.792] - queued futures: [n=2] TRUE, FALSE
[17:36:42.792] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:36:42.792]  length: 1 (resolved future 1)
[17:36:42.819] receiveMessageFromWorker() for ClusterFuture ...
[17:36:42.819] - Validating connection of MultisessionFuture
[17:36:42.819] - received message: FutureResult
[17:36:42.819] - Received FutureResult
[17:36:42.820] - Erased future from FutureRegistry
[17:36:42.820] result() for ClusterFuture ...
[17:36:42.820] - result already collected: FutureResult
[17:36:42.820] result() for ClusterFuture ... done
[17:36:42.820] receiveMessageFromWorker() for ClusterFuture ... done
[17:36:42.820] Future #2
[17:36:42.820] result() for ClusterFuture ...
[17:36:42.820] - result already collected: FutureResult
[17:36:42.820] result() for ClusterFuture ... done
[17:36:42.820] result() for ClusterFuture ...
[17:36:42.821] - result already collected: FutureResult
[17:36:42.821] result() for ClusterFuture ... done
[17:36:42.821] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:36:42.821] - nx: 2
[17:36:42.821] - relay: TRUE
[17:36:42.821] - stdout: TRUE
[17:36:42.821] - signal: TRUE
[17:36:42.821] - resignal: FALSE
[17:36:42.821] - force: TRUE
[17:36:42.821] - relayed: [n=2] TRUE, FALSE
[17:36:42.821] - queued futures: [n=2] TRUE, FALSE
[17:36:42.822]  - until=2
[17:36:42.822]  - relaying element #2
[17:36:42.822] result() for ClusterFuture ...
[17:36:42.822] - result already collected: FutureResult
[17:36:42.822] result() for ClusterFuture ... done
[17:36:42.822] result() for ClusterFuture ...
[17:36:42.822] - result already collected: FutureResult
[17:36:42.822] result() for ClusterFuture ... done
[17:36:42.822] result() for ClusterFuture ...
[17:36:42.822] - result already collected: FutureResult
[17:36:42.822] result() for ClusterFuture ... done
[17:36:42.823] result() for ClusterFuture ...
[17:36:42.823] - result already collected: FutureResult
[17:36:42.823] result() for ClusterFuture ... done
[17:36:42.823] - relayed: [n=2] TRUE, TRUE
[17:36:42.823] - queued futures: [n=2] TRUE, TRUE
[17:36:42.823] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:36:42.823]  length: 0 (resolved future 2)
[17:36:42.823] Relaying remaining futures
[17:36:42.823] signalConditionsASAP(NULL, pos=0) ...
[17:36:42.823] - nx: 2
[17:36:42.823] - relay: TRUE
[17:36:42.823] - stdout: TRUE
[17:36:42.824] - signal: TRUE
[17:36:42.824] - resignal: FALSE
[17:36:42.824] - force: TRUE
[17:36:42.824] - relayed: [n=2] TRUE, TRUE
[17:36:42.824] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:36:42.824] - relayed: [n=2] TRUE, TRUE
[17:36:42.824] - queued futures: [n=2] TRUE, TRUE
[17:36:42.824] signalConditionsASAP(NULL, pos=0) ... done
[17:36:42.824] resolve() on list ... DONE
[17:36:42.824] result() for ClusterFuture ...
[17:36:42.824] - result already collected: FutureResult
[17:36:42.825] result() for ClusterFuture ... done
[17:36:42.825] result() for ClusterFuture ...
[17:36:42.825] - result already collected: FutureResult
[17:36:42.825] result() for ClusterFuture ... done
[17:36:42.825] result() for ClusterFuture ...
[17:36:42.825] - result already collected: FutureResult
[17:36:42.825] result() for ClusterFuture ... done
[17:36:42.825] result() for ClusterFuture ...
[17:36:42.825] - result already collected: FutureResult
[17:36:42.825] result() for ClusterFuture ... done
[17:36:42.825]  - Number of value chunks collected: 2
[17:36:42.825] Resolving 2 futures (chunks) ... DONE
[17:36:42.826] Reducing values from 2 chunks ...
[17:36:42.826]  - Number of values collected after concatenation: 3
[17:36:42.826]  - Number of values expected: 3
[17:36:42.826] Reducing values from 2 chunks ... DONE
[17:36:42.826] future_lapply() ... DONE
[17:36:42.826] future_by_internal() ... DONE
[17:36:42.827] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[17:36:42.828] plan(): Setting new future strategy stack:
[17:36:42.828] List of future strategies:
[17:36:42.828] 1. FutureStrategy:
[17:36:42.828]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:36:42.828]    - tweaked: FALSE
[17:36:42.828]    - call: future::plan(oplan)
[17:36:42.829] plan(): nbrOfWorkers() = 1
> 
