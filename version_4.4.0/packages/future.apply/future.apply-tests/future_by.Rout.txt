
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[09:28:21.832] plan(): Setting new future strategy stack:
[09:28:21.832] List of future strategies:
[09:28:21.832] 1. sequential:
[09:28:21.832]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:21.832]    - tweaked: FALSE
[09:28:21.832]    - call: future::plan("sequential")
[09:28:21.845] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[09:28:21.898] plan(): Setting new future strategy stack:
[09:28:21.898] List of future strategies:
[09:28:21.898] 1. sequential:
[09:28:21.898]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:21.898]    - tweaked: FALSE
[09:28:21.898]    - call: plan(strategy)
[09:28:21.910] plan(): nbrOfWorkers() = 1
[09:28:21.910] future_by_internal() ...
[09:28:21.910] future_lapply() ...
[09:28:21.914] Number of chunks: 1
[09:28:21.914] getGlobalsAndPackagesXApply() ...
[09:28:21.915]  - future.globals: TRUE
[09:28:21.915] getGlobalsAndPackages() ...
[09:28:21.915] Searching for globals...
[09:28:21.917] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:21.917] Searching for globals ... DONE
[09:28:21.918] Resolving globals: FALSE
[09:28:21.918] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:21.919] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:21.919] - globals: [1] ‘FUN’
[09:28:21.919] 
[09:28:21.919] getGlobalsAndPackages() ... DONE
[09:28:21.919]  - globals found/used: [n=1] ‘FUN’
[09:28:21.919]  - needed namespaces: [n=0] 
[09:28:21.919] Finding globals ... DONE
[09:28:21.920]  - use_args: TRUE
[09:28:21.920]  - Getting '...' globals ...
[09:28:21.920] resolve() on list ...
[09:28:21.920]  recursive: 0
[09:28:21.921]  length: 1
[09:28:21.921]  elements: ‘...’
[09:28:21.921]  length: 0 (resolved future 1)
[09:28:21.921] resolve() on list ... DONE
[09:28:21.921]    - '...' content: [n=0] 
[09:28:21.921] List of 1
[09:28:21.921]  $ ...: list()
[09:28:21.921]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.921]  - attr(*, "where")=List of 1
[09:28:21.921]   ..$ ...:<environment: 0x555b08dd69e0> 
[09:28:21.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.921]  - attr(*, "resolved")= logi TRUE
[09:28:21.921]  - attr(*, "total_size")= num NA
[09:28:21.925]  - Getting '...' globals ... DONE
[09:28:21.925] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:21.925] List of 2
[09:28:21.925]  $ ...future.FUN:function (object, ...)  
[09:28:21.925]  $ ...          : list()
[09:28:21.925]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.925]  - attr(*, "where")=List of 2
[09:28:21.925]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:21.925]   ..$ ...          :<environment: 0x555b08dd69e0> 
[09:28:21.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.925]  - attr(*, "resolved")= logi FALSE
[09:28:21.925]  - attr(*, "total_size")= num 1240
[09:28:21.928] Packages to be attached in all futures: [n=0] 
[09:28:21.928] getGlobalsAndPackagesXApply() ... DONE
[09:28:21.928] Number of futures (= number of chunks): 1
[09:28:21.929] Launching 1 futures (chunks) ...
[09:28:21.929] Chunk #1 of 1 ...
[09:28:21.929]  - Finding globals in 'X' for chunk #1 ...
[09:28:21.929] getGlobalsAndPackages() ...
[09:28:21.929] Searching for globals...
[09:28:21.930] 
[09:28:21.930] Searching for globals ... DONE
[09:28:21.930] - globals: [0] <none>
[09:28:21.930] getGlobalsAndPackages() ... DONE
[09:28:21.930]    + additional globals found: [n=0] 
[09:28:21.930]    + additional namespaces needed: [n=0] 
[09:28:21.930]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:21.930]  - seeds: <none>
[09:28:21.930]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.930] getGlobalsAndPackages() ...
[09:28:21.930] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.931] Resolving globals: FALSE
[09:28:21.931] Tweak future expression to call with '...' arguments ...
[09:28:21.931] {
[09:28:21.931]     do.call(function(...) {
[09:28:21.931]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.931]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.931]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.931]             on.exit(options(oopts), add = TRUE)
[09:28:21.931]         }
[09:28:21.931]         {
[09:28:21.931]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.931]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.931]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.931]             })
[09:28:21.931]         }
[09:28:21.931]     }, args = future.call.arguments)
[09:28:21.931] }
[09:28:21.931] Tweak future expression to call with '...' arguments ... DONE
[09:28:21.931] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.931] 
[09:28:21.932] getGlobalsAndPackages() ... DONE
[09:28:21.932] run() for ‘Future’ ...
[09:28:21.932] - state: ‘created’
[09:28:21.933] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:21.933] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:21.933] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:21.933]   - Field: ‘label’
[09:28:21.933]   - Field: ‘local’
[09:28:21.933]   - Field: ‘owner’
[09:28:21.933]   - Field: ‘envir’
[09:28:21.933]   - Field: ‘packages’
[09:28:21.934]   - Field: ‘gc’
[09:28:21.934]   - Field: ‘conditions’
[09:28:21.934]   - Field: ‘expr’
[09:28:21.934]   - Field: ‘uuid’
[09:28:21.934]   - Field: ‘seed’
[09:28:21.934]   - Field: ‘version’
[09:28:21.934]   - Field: ‘result’
[09:28:21.934]   - Field: ‘asynchronous’
[09:28:21.934]   - Field: ‘calls’
[09:28:21.934]   - Field: ‘globals’
[09:28:21.934]   - Field: ‘stdout’
[09:28:21.934]   - Field: ‘earlySignal’
[09:28:21.935]   - Field: ‘lazy’
[09:28:21.935]   - Field: ‘state’
[09:28:21.935] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:21.935] - Launch lazy future ...
[09:28:21.936] Packages needed by the future expression (n = 0): <none>
[09:28:21.936] Packages needed by future strategies (n = 0): <none>
[09:28:21.936] {
[09:28:21.936]     {
[09:28:21.936]         {
[09:28:21.936]             ...future.startTime <- base::Sys.time()
[09:28:21.936]             {
[09:28:21.936]                 {
[09:28:21.936]                   {
[09:28:21.936]                     base::local({
[09:28:21.936]                       has_future <- base::requireNamespace("future", 
[09:28:21.936]                         quietly = TRUE)
[09:28:21.936]                       if (has_future) {
[09:28:21.936]                         ns <- base::getNamespace("future")
[09:28:21.936]                         version <- ns[[".package"]][["version"]]
[09:28:21.936]                         if (is.null(version)) 
[09:28:21.936]                           version <- utils::packageVersion("future")
[09:28:21.936]                       }
[09:28:21.936]                       else {
[09:28:21.936]                         version <- NULL
[09:28:21.936]                       }
[09:28:21.936]                       if (!has_future || version < "1.8.0") {
[09:28:21.936]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:21.936]                           "", base::R.version$version.string), 
[09:28:21.936]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:21.936]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:21.936]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:21.936]                             "release", "version")], collapse = " "), 
[09:28:21.936]                           hostname = base::Sys.info()[["nodename"]])
[09:28:21.936]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:21.936]                           info)
[09:28:21.936]                         info <- base::paste(info, collapse = "; ")
[09:28:21.936]                         if (!has_future) {
[09:28:21.936]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:21.936]                             info)
[09:28:21.936]                         }
[09:28:21.936]                         else {
[09:28:21.936]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:21.936]                             info, version)
[09:28:21.936]                         }
[09:28:21.936]                         base::stop(msg)
[09:28:21.936]                       }
[09:28:21.936]                     })
[09:28:21.936]                   }
[09:28:21.936]                   ...future.strategy.old <- future::plan("list")
[09:28:21.936]                   options(future.plan = NULL)
[09:28:21.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:21.936]                 }
[09:28:21.936]                 ...future.workdir <- getwd()
[09:28:21.936]             }
[09:28:21.936]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:21.936]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:21.936]         }
[09:28:21.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:21.936]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:21.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:21.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:21.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:21.936]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:21.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:21.936]             base::names(...future.oldOptions))
[09:28:21.936]     }
[09:28:21.936]     if (FALSE) {
[09:28:21.936]     }
[09:28:21.936]     else {
[09:28:21.936]         if (TRUE) {
[09:28:21.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:21.936]                 open = "w")
[09:28:21.936]         }
[09:28:21.936]         else {
[09:28:21.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:21.936]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:21.936]         }
[09:28:21.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:21.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:21.936]             base::sink(type = "output", split = FALSE)
[09:28:21.936]             base::close(...future.stdout)
[09:28:21.936]         }, add = TRUE)
[09:28:21.936]     }
[09:28:21.936]     ...future.frame <- base::sys.nframe()
[09:28:21.936]     ...future.conditions <- base::list()
[09:28:21.936]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:21.936]     if (FALSE) {
[09:28:21.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:21.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:21.936]     }
[09:28:21.936]     ...future.result <- base::tryCatch({
[09:28:21.936]         base::withCallingHandlers({
[09:28:21.936]             ...future.value <- base::withVisible(base::local({
[09:28:21.936]                 do.call(function(...) {
[09:28:21.936]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.936]                   if (!identical(...future.globals.maxSize.org, 
[09:28:21.936]                     ...future.globals.maxSize)) {
[09:28:21.936]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.936]                     on.exit(options(oopts), add = TRUE)
[09:28:21.936]                   }
[09:28:21.936]                   {
[09:28:21.936]                     lapply(seq_along(...future.elements_ii), 
[09:28:21.936]                       FUN = function(jj) {
[09:28:21.936]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.936]                         ...future.FUN(...future.X_jj, ...)
[09:28:21.936]                       })
[09:28:21.936]                   }
[09:28:21.936]                 }, args = future.call.arguments)
[09:28:21.936]             }))
[09:28:21.936]             future::FutureResult(value = ...future.value$value, 
[09:28:21.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.936]                   ...future.rng), globalenv = if (FALSE) 
[09:28:21.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:21.936]                     ...future.globalenv.names))
[09:28:21.936]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:21.936]         }, condition = base::local({
[09:28:21.936]             c <- base::c
[09:28:21.936]             inherits <- base::inherits
[09:28:21.936]             invokeRestart <- base::invokeRestart
[09:28:21.936]             length <- base::length
[09:28:21.936]             list <- base::list
[09:28:21.936]             seq.int <- base::seq.int
[09:28:21.936]             signalCondition <- base::signalCondition
[09:28:21.936]             sys.calls <- base::sys.calls
[09:28:21.936]             `[[` <- base::`[[`
[09:28:21.936]             `+` <- base::`+`
[09:28:21.936]             `<<-` <- base::`<<-`
[09:28:21.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:21.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:21.936]                   3L)]
[09:28:21.936]             }
[09:28:21.936]             function(cond) {
[09:28:21.936]                 is_error <- inherits(cond, "error")
[09:28:21.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:21.936]                   NULL)
[09:28:21.936]                 if (is_error) {
[09:28:21.936]                   sessionInformation <- function() {
[09:28:21.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:21.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:21.936]                       search = base::search(), system = base::Sys.info())
[09:28:21.936]                   }
[09:28:21.936]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:21.936]                     cond$call), session = sessionInformation(), 
[09:28:21.936]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:21.936]                   signalCondition(cond)
[09:28:21.936]                 }
[09:28:21.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:21.936]                 "immediateCondition"))) {
[09:28:21.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:21.936]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:21.936]                   if (TRUE && !signal) {
[09:28:21.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.936]                     {
[09:28:21.936]                       inherits <- base::inherits
[09:28:21.936]                       invokeRestart <- base::invokeRestart
[09:28:21.936]                       is.null <- base::is.null
[09:28:21.936]                       muffled <- FALSE
[09:28:21.936]                       if (inherits(cond, "message")) {
[09:28:21.936]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.936]                         if (muffled) 
[09:28:21.936]                           invokeRestart("muffleMessage")
[09:28:21.936]                       }
[09:28:21.936]                       else if (inherits(cond, "warning")) {
[09:28:21.936]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.936]                         if (muffled) 
[09:28:21.936]                           invokeRestart("muffleWarning")
[09:28:21.936]                       }
[09:28:21.936]                       else if (inherits(cond, "condition")) {
[09:28:21.936]                         if (!is.null(pattern)) {
[09:28:21.936]                           computeRestarts <- base::computeRestarts
[09:28:21.936]                           grepl <- base::grepl
[09:28:21.936]                           restarts <- computeRestarts(cond)
[09:28:21.936]                           for (restart in restarts) {
[09:28:21.936]                             name <- restart$name
[09:28:21.936]                             if (is.null(name)) 
[09:28:21.936]                               next
[09:28:21.936]                             if (!grepl(pattern, name)) 
[09:28:21.936]                               next
[09:28:21.936]                             invokeRestart(restart)
[09:28:21.936]                             muffled <- TRUE
[09:28:21.936]                             break
[09:28:21.936]                           }
[09:28:21.936]                         }
[09:28:21.936]                       }
[09:28:21.936]                       invisible(muffled)
[09:28:21.936]                     }
[09:28:21.936]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.936]                   }
[09:28:21.936]                 }
[09:28:21.936]                 else {
[09:28:21.936]                   if (TRUE) {
[09:28:21.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.936]                     {
[09:28:21.936]                       inherits <- base::inherits
[09:28:21.936]                       invokeRestart <- base::invokeRestart
[09:28:21.936]                       is.null <- base::is.null
[09:28:21.936]                       muffled <- FALSE
[09:28:21.936]                       if (inherits(cond, "message")) {
[09:28:21.936]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.936]                         if (muffled) 
[09:28:21.936]                           invokeRestart("muffleMessage")
[09:28:21.936]                       }
[09:28:21.936]                       else if (inherits(cond, "warning")) {
[09:28:21.936]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.936]                         if (muffled) 
[09:28:21.936]                           invokeRestart("muffleWarning")
[09:28:21.936]                       }
[09:28:21.936]                       else if (inherits(cond, "condition")) {
[09:28:21.936]                         if (!is.null(pattern)) {
[09:28:21.936]                           computeRestarts <- base::computeRestarts
[09:28:21.936]                           grepl <- base::grepl
[09:28:21.936]                           restarts <- computeRestarts(cond)
[09:28:21.936]                           for (restart in restarts) {
[09:28:21.936]                             name <- restart$name
[09:28:21.936]                             if (is.null(name)) 
[09:28:21.936]                               next
[09:28:21.936]                             if (!grepl(pattern, name)) 
[09:28:21.936]                               next
[09:28:21.936]                             invokeRestart(restart)
[09:28:21.936]                             muffled <- TRUE
[09:28:21.936]                             break
[09:28:21.936]                           }
[09:28:21.936]                         }
[09:28:21.936]                       }
[09:28:21.936]                       invisible(muffled)
[09:28:21.936]                     }
[09:28:21.936]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.936]                   }
[09:28:21.936]                 }
[09:28:21.936]             }
[09:28:21.936]         }))
[09:28:21.936]     }, error = function(ex) {
[09:28:21.936]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:21.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.936]                 ...future.rng), started = ...future.startTime, 
[09:28:21.936]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:21.936]             version = "1.8"), class = "FutureResult")
[09:28:21.936]     }, finally = {
[09:28:21.936]         if (!identical(...future.workdir, getwd())) 
[09:28:21.936]             setwd(...future.workdir)
[09:28:21.936]         {
[09:28:21.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:21.936]                 ...future.oldOptions$nwarnings <- NULL
[09:28:21.936]             }
[09:28:21.936]             base::options(...future.oldOptions)
[09:28:21.936]             if (.Platform$OS.type == "windows") {
[09:28:21.936]                 old_names <- names(...future.oldEnvVars)
[09:28:21.936]                 envs <- base::Sys.getenv()
[09:28:21.936]                 names <- names(envs)
[09:28:21.936]                 common <- intersect(names, old_names)
[09:28:21.936]                 added <- setdiff(names, old_names)
[09:28:21.936]                 removed <- setdiff(old_names, names)
[09:28:21.936]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:21.936]                   envs[common]]
[09:28:21.936]                 NAMES <- toupper(changed)
[09:28:21.936]                 args <- list()
[09:28:21.936]                 for (kk in seq_along(NAMES)) {
[09:28:21.936]                   name <- changed[[kk]]
[09:28:21.936]                   NAME <- NAMES[[kk]]
[09:28:21.936]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.936]                     next
[09:28:21.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.936]                 }
[09:28:21.936]                 NAMES <- toupper(added)
[09:28:21.936]                 for (kk in seq_along(NAMES)) {
[09:28:21.936]                   name <- added[[kk]]
[09:28:21.936]                   NAME <- NAMES[[kk]]
[09:28:21.936]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.936]                     next
[09:28:21.936]                   args[[name]] <- ""
[09:28:21.936]                 }
[09:28:21.936]                 NAMES <- toupper(removed)
[09:28:21.936]                 for (kk in seq_along(NAMES)) {
[09:28:21.936]                   name <- removed[[kk]]
[09:28:21.936]                   NAME <- NAMES[[kk]]
[09:28:21.936]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.936]                     next
[09:28:21.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.936]                 }
[09:28:21.936]                 if (length(args) > 0) 
[09:28:21.936]                   base::do.call(base::Sys.setenv, args = args)
[09:28:21.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:21.936]             }
[09:28:21.936]             else {
[09:28:21.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:21.936]             }
[09:28:21.936]             {
[09:28:21.936]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:21.936]                   0L) {
[09:28:21.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:21.936]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:21.936]                   base::options(opts)
[09:28:21.936]                 }
[09:28:21.936]                 {
[09:28:21.936]                   {
[09:28:21.936]                     NULL
[09:28:21.936]                     RNGkind("Mersenne-Twister")
[09:28:21.936]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:21.936]                       inherits = FALSE)
[09:28:21.936]                   }
[09:28:21.936]                   options(future.plan = NULL)
[09:28:21.936]                   if (is.na(NA_character_)) 
[09:28:21.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:21.936]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:21.936]                     .init = FALSE)
[09:28:21.936]                 }
[09:28:21.936]             }
[09:28:21.936]         }
[09:28:21.936]     })
[09:28:21.936]     if (TRUE) {
[09:28:21.936]         base::sink(type = "output", split = FALSE)
[09:28:21.936]         if (TRUE) {
[09:28:21.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:21.936]         }
[09:28:21.936]         else {
[09:28:21.936]             ...future.result["stdout"] <- base::list(NULL)
[09:28:21.936]         }
[09:28:21.936]         base::close(...future.stdout)
[09:28:21.936]         ...future.stdout <- NULL
[09:28:21.936]     }
[09:28:21.936]     ...future.result$conditions <- ...future.conditions
[09:28:21.936]     ...future.result$finished <- base::Sys.time()
[09:28:21.936]     ...future.result
[09:28:21.936] }
[09:28:21.938] assign_globals() ...
[09:28:21.939] List of 5
[09:28:21.939]  $ ...future.FUN            :function (object, ...)  
[09:28:21.939]  $ future.call.arguments    : list()
[09:28:21.939]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.939]  $ ...future.elements_ii    :List of 3
[09:28:21.939]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:21.939]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:21.939]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:21.939]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:21.939]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:21.939]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:21.939]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:21.939]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:21.939]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:21.939]  $ ...future.seeds_ii       : NULL
[09:28:21.939]  $ ...future.globals.maxSize: NULL
[09:28:21.939]  - attr(*, "where")=List of 5
[09:28:21.939]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:21.939]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:21.939]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:21.939]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:21.939]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:21.939]  - attr(*, "resolved")= logi FALSE
[09:28:21.939]  - attr(*, "total_size")= num 1240
[09:28:21.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.939]  - attr(*, "already-done")= logi TRUE
[09:28:21.948] - copied ‘...future.FUN’ to environment
[09:28:21.948] - copied ‘future.call.arguments’ to environment
[09:28:21.948] - copied ‘...future.elements_ii’ to environment
[09:28:21.948] - copied ‘...future.seeds_ii’ to environment
[09:28:21.948] - copied ‘...future.globals.maxSize’ to environment
[09:28:21.948] assign_globals() ... done
[09:28:21.949] plan(): Setting new future strategy stack:
[09:28:21.949] List of future strategies:
[09:28:21.949] 1. sequential:
[09:28:21.949]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:21.949]    - tweaked: FALSE
[09:28:21.949]    - call: NULL
[09:28:21.949] plan(): nbrOfWorkers() = 1
[09:28:21.951] plan(): Setting new future strategy stack:
[09:28:21.951] List of future strategies:
[09:28:21.951] 1. sequential:
[09:28:21.951]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:21.951]    - tweaked: FALSE
[09:28:21.951]    - call: plan(strategy)
[09:28:21.952] plan(): nbrOfWorkers() = 1
[09:28:21.952] SequentialFuture started (and completed)
[09:28:21.952] - Launch lazy future ... done
[09:28:21.952] run() for ‘SequentialFuture’ ... done
[09:28:21.953] Created future:
[09:28:21.953] SequentialFuture:
[09:28:21.953] Label: ‘future_by-1’
[09:28:21.953] Expression:
[09:28:21.953] {
[09:28:21.953]     do.call(function(...) {
[09:28:21.953]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.953]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.953]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.953]             on.exit(options(oopts), add = TRUE)
[09:28:21.953]         }
[09:28:21.953]         {
[09:28:21.953]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.953]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.953]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.953]             })
[09:28:21.953]         }
[09:28:21.953]     }, args = future.call.arguments)
[09:28:21.953] }
[09:28:21.953] Lazy evaluation: FALSE
[09:28:21.953] Asynchronous evaluation: FALSE
[09:28:21.953] Local evaluation: TRUE
[09:28:21.953] Environment: R_GlobalEnv
[09:28:21.953] Capture standard output: TRUE
[09:28:21.953] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:21.953] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:21.953] Packages: <none>
[09:28:21.953] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:21.953] Resolved: TRUE
[09:28:21.953] Value: 4.62 KiB of class ‘list’
[09:28:21.953] Early signaling: FALSE
[09:28:21.953] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:21.953] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:21.954] Chunk #1 of 1 ... DONE
[09:28:21.954] Launching 1 futures (chunks) ... DONE
[09:28:21.954] Resolving 1 futures (chunks) ...
[09:28:21.954] resolve() on list ...
[09:28:21.955]  recursive: 0
[09:28:21.955]  length: 1
[09:28:21.955] 
[09:28:21.955] resolved() for ‘SequentialFuture’ ...
[09:28:21.955] - state: ‘finished’
[09:28:21.955] - run: TRUE
[09:28:21.955] - result: ‘FutureResult’
[09:28:21.955] resolved() for ‘SequentialFuture’ ... done
[09:28:21.955] Future #1
[09:28:21.956] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:21.956] - nx: 1
[09:28:21.956] - relay: TRUE
[09:28:21.956] - stdout: TRUE
[09:28:21.956] - signal: TRUE
[09:28:21.956] - resignal: FALSE
[09:28:21.956] - force: TRUE
[09:28:21.956] - relayed: [n=1] FALSE
[09:28:21.956] - queued futures: [n=1] FALSE
[09:28:21.956]  - until=1
[09:28:21.957]  - relaying element #1
[09:28:21.957] - relayed: [n=1] TRUE
[09:28:21.957] - queued futures: [n=1] TRUE
[09:28:21.957] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:21.957]  length: 0 (resolved future 1)
[09:28:21.957] Relaying remaining futures
[09:28:21.957] signalConditionsASAP(NULL, pos=0) ...
[09:28:21.957] - nx: 1
[09:28:21.957] - relay: TRUE
[09:28:21.957] - stdout: TRUE
[09:28:21.958] - signal: TRUE
[09:28:21.958] - resignal: FALSE
[09:28:21.958] - force: TRUE
[09:28:21.958] - relayed: [n=1] TRUE
[09:28:21.958] - queued futures: [n=1] TRUE
 - flush all
[09:28:21.958] - relayed: [n=1] TRUE
[09:28:21.958] - queued futures: [n=1] TRUE
[09:28:21.958] signalConditionsASAP(NULL, pos=0) ... done
[09:28:21.958] resolve() on list ... DONE
[09:28:21.958]  - Number of value chunks collected: 1
[09:28:21.958] Resolving 1 futures (chunks) ... DONE
[09:28:21.959] Reducing values from 1 chunks ...
[09:28:21.959]  - Number of values collected after concatenation: 3
[09:28:21.959]  - Number of values expected: 3
[09:28:21.959] Reducing values from 1 chunks ... DONE
[09:28:21.959] future_lapply() ... DONE
[09:28:21.959] future_by_internal() ... DONE
[09:28:21.960] future_by_internal() ...
[09:28:21.960] future_lapply() ...
[09:28:21.960] Number of chunks: 1
[09:28:21.961] getGlobalsAndPackagesXApply() ...
[09:28:21.961]  - future.globals: TRUE
[09:28:21.961] getGlobalsAndPackages() ...
[09:28:21.961] Searching for globals...
[09:28:21.962] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:21.962] Searching for globals ... DONE
[09:28:21.962] Resolving globals: FALSE
[09:28:21.962] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:21.963] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:21.963] - globals: [1] ‘FUN’
[09:28:21.963] 
[09:28:21.963] getGlobalsAndPackages() ... DONE
[09:28:21.963]  - globals found/used: [n=1] ‘FUN’
[09:28:21.963]  - needed namespaces: [n=0] 
[09:28:21.963] Finding globals ... DONE
[09:28:21.963]  - use_args: TRUE
[09:28:21.963]  - Getting '...' globals ...
[09:28:21.964] resolve() on list ...
[09:28:21.964]  recursive: 0
[09:28:21.964]  length: 1
[09:28:21.964]  elements: ‘...’
[09:28:21.964]  length: 0 (resolved future 1)
[09:28:21.964] resolve() on list ... DONE
[09:28:21.964]    - '...' content: [n=1] ‘digits’
[09:28:21.964] List of 1
[09:28:21.964]  $ ...:List of 1
[09:28:21.964]   ..$ digits: int 2
[09:28:21.964]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.964]  - attr(*, "where")=List of 1
[09:28:21.964]   ..$ ...:<environment: 0x555b0a7082e8> 
[09:28:21.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.964]  - attr(*, "resolved")= logi TRUE
[09:28:21.964]  - attr(*, "total_size")= num NA
[09:28:21.968]  - Getting '...' globals ... DONE
[09:28:21.968] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:21.968] List of 2
[09:28:21.968]  $ ...future.FUN:function (object, ...)  
[09:28:21.968]  $ ...          :List of 1
[09:28:21.968]   ..$ digits: int 2
[09:28:21.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.968]  - attr(*, "where")=List of 2
[09:28:21.968]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:21.968]   ..$ ...          :<environment: 0x555b0a7082e8> 
[09:28:21.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.968]  - attr(*, "resolved")= logi FALSE
[09:28:21.968]  - attr(*, "total_size")= num 1296
[09:28:21.971] Packages to be attached in all futures: [n=0] 
[09:28:21.971] getGlobalsAndPackagesXApply() ... DONE
[09:28:21.971] Number of futures (= number of chunks): 1
[09:28:21.971] Launching 1 futures (chunks) ...
[09:28:21.972] Chunk #1 of 1 ...
[09:28:21.972]  - Finding globals in 'X' for chunk #1 ...
[09:28:21.972] getGlobalsAndPackages() ...
[09:28:21.972] Searching for globals...
[09:28:21.972] 
[09:28:21.972] Searching for globals ... DONE
[09:28:21.972] - globals: [0] <none>
[09:28:21.972] getGlobalsAndPackages() ... DONE
[09:28:21.972]    + additional globals found: [n=0] 
[09:28:21.973]    + additional namespaces needed: [n=0] 
[09:28:21.973]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:21.973]  - seeds: <none>
[09:28:21.973]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.973] getGlobalsAndPackages() ...
[09:28:21.973] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.973] Resolving globals: FALSE
[09:28:21.973] Tweak future expression to call with '...' arguments ...
[09:28:21.973] {
[09:28:21.973]     do.call(function(...) {
[09:28:21.973]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.973]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.973]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.973]             on.exit(options(oopts), add = TRUE)
[09:28:21.973]         }
[09:28:21.973]         {
[09:28:21.973]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.973]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.973]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.973]             })
[09:28:21.973]         }
[09:28:21.973]     }, args = future.call.arguments)
[09:28:21.973] }
[09:28:21.974] Tweak future expression to call with '...' arguments ... DONE
[09:28:21.974] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:21.974] 
[09:28:21.974] getGlobalsAndPackages() ... DONE
[09:28:21.974] run() for ‘Future’ ...
[09:28:21.974] - state: ‘created’
[09:28:21.974] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:21.975] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:21.975] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:21.975]   - Field: ‘label’
[09:28:21.975]   - Field: ‘local’
[09:28:21.975]   - Field: ‘owner’
[09:28:21.975]   - Field: ‘envir’
[09:28:21.975]   - Field: ‘packages’
[09:28:21.975]   - Field: ‘gc’
[09:28:21.975]   - Field: ‘conditions’
[09:28:21.976]   - Field: ‘expr’
[09:28:21.976]   - Field: ‘uuid’
[09:28:21.976]   - Field: ‘seed’
[09:28:21.976]   - Field: ‘version’
[09:28:21.976]   - Field: ‘result’
[09:28:21.976]   - Field: ‘asynchronous’
[09:28:21.976]   - Field: ‘calls’
[09:28:21.976]   - Field: ‘globals’
[09:28:21.976]   - Field: ‘stdout’
[09:28:21.976]   - Field: ‘earlySignal’
[09:28:21.976]   - Field: ‘lazy’
[09:28:21.976]   - Field: ‘state’
[09:28:21.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:21.977] - Launch lazy future ...
[09:28:21.977] Packages needed by the future expression (n = 0): <none>
[09:28:21.977] Packages needed by future strategies (n = 0): <none>
[09:28:21.977] {
[09:28:21.977]     {
[09:28:21.977]         {
[09:28:21.977]             ...future.startTime <- base::Sys.time()
[09:28:21.977]             {
[09:28:21.977]                 {
[09:28:21.977]                   {
[09:28:21.977]                     base::local({
[09:28:21.977]                       has_future <- base::requireNamespace("future", 
[09:28:21.977]                         quietly = TRUE)
[09:28:21.977]                       if (has_future) {
[09:28:21.977]                         ns <- base::getNamespace("future")
[09:28:21.977]                         version <- ns[[".package"]][["version"]]
[09:28:21.977]                         if (is.null(version)) 
[09:28:21.977]                           version <- utils::packageVersion("future")
[09:28:21.977]                       }
[09:28:21.977]                       else {
[09:28:21.977]                         version <- NULL
[09:28:21.977]                       }
[09:28:21.977]                       if (!has_future || version < "1.8.0") {
[09:28:21.977]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:21.977]                           "", base::R.version$version.string), 
[09:28:21.977]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:21.977]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:21.977]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:21.977]                             "release", "version")], collapse = " "), 
[09:28:21.977]                           hostname = base::Sys.info()[["nodename"]])
[09:28:21.977]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:21.977]                           info)
[09:28:21.977]                         info <- base::paste(info, collapse = "; ")
[09:28:21.977]                         if (!has_future) {
[09:28:21.977]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:21.977]                             info)
[09:28:21.977]                         }
[09:28:21.977]                         else {
[09:28:21.977]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:21.977]                             info, version)
[09:28:21.977]                         }
[09:28:21.977]                         base::stop(msg)
[09:28:21.977]                       }
[09:28:21.977]                     })
[09:28:21.977]                   }
[09:28:21.977]                   ...future.strategy.old <- future::plan("list")
[09:28:21.977]                   options(future.plan = NULL)
[09:28:21.977]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.977]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:21.977]                 }
[09:28:21.977]                 ...future.workdir <- getwd()
[09:28:21.977]             }
[09:28:21.977]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:21.977]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:21.977]         }
[09:28:21.977]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:21.977]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:21.977]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:21.977]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:21.977]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:21.977]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:21.977]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:21.977]             base::names(...future.oldOptions))
[09:28:21.977]     }
[09:28:21.977]     if (FALSE) {
[09:28:21.977]     }
[09:28:21.977]     else {
[09:28:21.977]         if (TRUE) {
[09:28:21.977]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:21.977]                 open = "w")
[09:28:21.977]         }
[09:28:21.977]         else {
[09:28:21.977]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:21.977]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:21.977]         }
[09:28:21.977]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:21.977]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:21.977]             base::sink(type = "output", split = FALSE)
[09:28:21.977]             base::close(...future.stdout)
[09:28:21.977]         }, add = TRUE)
[09:28:21.977]     }
[09:28:21.977]     ...future.frame <- base::sys.nframe()
[09:28:21.977]     ...future.conditions <- base::list()
[09:28:21.977]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:21.977]     if (FALSE) {
[09:28:21.977]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:21.977]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:21.977]     }
[09:28:21.977]     ...future.result <- base::tryCatch({
[09:28:21.977]         base::withCallingHandlers({
[09:28:21.977]             ...future.value <- base::withVisible(base::local({
[09:28:21.977]                 do.call(function(...) {
[09:28:21.977]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.977]                   if (!identical(...future.globals.maxSize.org, 
[09:28:21.977]                     ...future.globals.maxSize)) {
[09:28:21.977]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.977]                     on.exit(options(oopts), add = TRUE)
[09:28:21.977]                   }
[09:28:21.977]                   {
[09:28:21.977]                     lapply(seq_along(...future.elements_ii), 
[09:28:21.977]                       FUN = function(jj) {
[09:28:21.977]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.977]                         ...future.FUN(...future.X_jj, ...)
[09:28:21.977]                       })
[09:28:21.977]                   }
[09:28:21.977]                 }, args = future.call.arguments)
[09:28:21.977]             }))
[09:28:21.977]             future::FutureResult(value = ...future.value$value, 
[09:28:21.977]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.977]                   ...future.rng), globalenv = if (FALSE) 
[09:28:21.977]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:21.977]                     ...future.globalenv.names))
[09:28:21.977]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:21.977]         }, condition = base::local({
[09:28:21.977]             c <- base::c
[09:28:21.977]             inherits <- base::inherits
[09:28:21.977]             invokeRestart <- base::invokeRestart
[09:28:21.977]             length <- base::length
[09:28:21.977]             list <- base::list
[09:28:21.977]             seq.int <- base::seq.int
[09:28:21.977]             signalCondition <- base::signalCondition
[09:28:21.977]             sys.calls <- base::sys.calls
[09:28:21.977]             `[[` <- base::`[[`
[09:28:21.977]             `+` <- base::`+`
[09:28:21.977]             `<<-` <- base::`<<-`
[09:28:21.977]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:21.977]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:21.977]                   3L)]
[09:28:21.977]             }
[09:28:21.977]             function(cond) {
[09:28:21.977]                 is_error <- inherits(cond, "error")
[09:28:21.977]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:21.977]                   NULL)
[09:28:21.977]                 if (is_error) {
[09:28:21.977]                   sessionInformation <- function() {
[09:28:21.977]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:21.977]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:21.977]                       search = base::search(), system = base::Sys.info())
[09:28:21.977]                   }
[09:28:21.977]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.977]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:21.977]                     cond$call), session = sessionInformation(), 
[09:28:21.977]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:21.977]                   signalCondition(cond)
[09:28:21.977]                 }
[09:28:21.977]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:21.977]                 "immediateCondition"))) {
[09:28:21.977]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:21.977]                   ...future.conditions[[length(...future.conditions) + 
[09:28:21.977]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:21.977]                   if (TRUE && !signal) {
[09:28:21.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.977]                     {
[09:28:21.977]                       inherits <- base::inherits
[09:28:21.977]                       invokeRestart <- base::invokeRestart
[09:28:21.977]                       is.null <- base::is.null
[09:28:21.977]                       muffled <- FALSE
[09:28:21.977]                       if (inherits(cond, "message")) {
[09:28:21.977]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.977]                         if (muffled) 
[09:28:21.977]                           invokeRestart("muffleMessage")
[09:28:21.977]                       }
[09:28:21.977]                       else if (inherits(cond, "warning")) {
[09:28:21.977]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.977]                         if (muffled) 
[09:28:21.977]                           invokeRestart("muffleWarning")
[09:28:21.977]                       }
[09:28:21.977]                       else if (inherits(cond, "condition")) {
[09:28:21.977]                         if (!is.null(pattern)) {
[09:28:21.977]                           computeRestarts <- base::computeRestarts
[09:28:21.977]                           grepl <- base::grepl
[09:28:21.977]                           restarts <- computeRestarts(cond)
[09:28:21.977]                           for (restart in restarts) {
[09:28:21.977]                             name <- restart$name
[09:28:21.977]                             if (is.null(name)) 
[09:28:21.977]                               next
[09:28:21.977]                             if (!grepl(pattern, name)) 
[09:28:21.977]                               next
[09:28:21.977]                             invokeRestart(restart)
[09:28:21.977]                             muffled <- TRUE
[09:28:21.977]                             break
[09:28:21.977]                           }
[09:28:21.977]                         }
[09:28:21.977]                       }
[09:28:21.977]                       invisible(muffled)
[09:28:21.977]                     }
[09:28:21.977]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.977]                   }
[09:28:21.977]                 }
[09:28:21.977]                 else {
[09:28:21.977]                   if (TRUE) {
[09:28:21.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:21.977]                     {
[09:28:21.977]                       inherits <- base::inherits
[09:28:21.977]                       invokeRestart <- base::invokeRestart
[09:28:21.977]                       is.null <- base::is.null
[09:28:21.977]                       muffled <- FALSE
[09:28:21.977]                       if (inherits(cond, "message")) {
[09:28:21.977]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:21.977]                         if (muffled) 
[09:28:21.977]                           invokeRestart("muffleMessage")
[09:28:21.977]                       }
[09:28:21.977]                       else if (inherits(cond, "warning")) {
[09:28:21.977]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:21.977]                         if (muffled) 
[09:28:21.977]                           invokeRestart("muffleWarning")
[09:28:21.977]                       }
[09:28:21.977]                       else if (inherits(cond, "condition")) {
[09:28:21.977]                         if (!is.null(pattern)) {
[09:28:21.977]                           computeRestarts <- base::computeRestarts
[09:28:21.977]                           grepl <- base::grepl
[09:28:21.977]                           restarts <- computeRestarts(cond)
[09:28:21.977]                           for (restart in restarts) {
[09:28:21.977]                             name <- restart$name
[09:28:21.977]                             if (is.null(name)) 
[09:28:21.977]                               next
[09:28:21.977]                             if (!grepl(pattern, name)) 
[09:28:21.977]                               next
[09:28:21.977]                             invokeRestart(restart)
[09:28:21.977]                             muffled <- TRUE
[09:28:21.977]                             break
[09:28:21.977]                           }
[09:28:21.977]                         }
[09:28:21.977]                       }
[09:28:21.977]                       invisible(muffled)
[09:28:21.977]                     }
[09:28:21.977]                     muffleCondition(cond, pattern = "^muffle")
[09:28:21.977]                   }
[09:28:21.977]                 }
[09:28:21.977]             }
[09:28:21.977]         }))
[09:28:21.977]     }, error = function(ex) {
[09:28:21.977]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:21.977]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:21.977]                 ...future.rng), started = ...future.startTime, 
[09:28:21.977]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:21.977]             version = "1.8"), class = "FutureResult")
[09:28:21.977]     }, finally = {
[09:28:21.977]         if (!identical(...future.workdir, getwd())) 
[09:28:21.977]             setwd(...future.workdir)
[09:28:21.977]         {
[09:28:21.977]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:21.977]                 ...future.oldOptions$nwarnings <- NULL
[09:28:21.977]             }
[09:28:21.977]             base::options(...future.oldOptions)
[09:28:21.977]             if (.Platform$OS.type == "windows") {
[09:28:21.977]                 old_names <- names(...future.oldEnvVars)
[09:28:21.977]                 envs <- base::Sys.getenv()
[09:28:21.977]                 names <- names(envs)
[09:28:21.977]                 common <- intersect(names, old_names)
[09:28:21.977]                 added <- setdiff(names, old_names)
[09:28:21.977]                 removed <- setdiff(old_names, names)
[09:28:21.977]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:21.977]                   envs[common]]
[09:28:21.977]                 NAMES <- toupper(changed)
[09:28:21.977]                 args <- list()
[09:28:21.977]                 for (kk in seq_along(NAMES)) {
[09:28:21.977]                   name <- changed[[kk]]
[09:28:21.977]                   NAME <- NAMES[[kk]]
[09:28:21.977]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.977]                     next
[09:28:21.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.977]                 }
[09:28:21.977]                 NAMES <- toupper(added)
[09:28:21.977]                 for (kk in seq_along(NAMES)) {
[09:28:21.977]                   name <- added[[kk]]
[09:28:21.977]                   NAME <- NAMES[[kk]]
[09:28:21.977]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.977]                     next
[09:28:21.977]                   args[[name]] <- ""
[09:28:21.977]                 }
[09:28:21.977]                 NAMES <- toupper(removed)
[09:28:21.977]                 for (kk in seq_along(NAMES)) {
[09:28:21.977]                   name <- removed[[kk]]
[09:28:21.977]                   NAME <- NAMES[[kk]]
[09:28:21.977]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:21.977]                     next
[09:28:21.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:21.977]                 }
[09:28:21.977]                 if (length(args) > 0) 
[09:28:21.977]                   base::do.call(base::Sys.setenv, args = args)
[09:28:21.977]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:21.977]             }
[09:28:21.977]             else {
[09:28:21.977]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:21.977]             }
[09:28:21.977]             {
[09:28:21.977]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:21.977]                   0L) {
[09:28:21.977]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:21.977]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:21.977]                   base::options(opts)
[09:28:21.977]                 }
[09:28:21.977]                 {
[09:28:21.977]                   {
[09:28:21.977]                     NULL
[09:28:21.977]                     RNGkind("Mersenne-Twister")
[09:28:21.977]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:21.977]                       inherits = FALSE)
[09:28:21.977]                   }
[09:28:21.977]                   options(future.plan = NULL)
[09:28:21.977]                   if (is.na(NA_character_)) 
[09:28:21.977]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:21.977]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:21.977]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:21.977]                     .init = FALSE)
[09:28:21.977]                 }
[09:28:21.977]             }
[09:28:21.977]         }
[09:28:21.977]     })
[09:28:21.977]     if (TRUE) {
[09:28:21.977]         base::sink(type = "output", split = FALSE)
[09:28:21.977]         if (TRUE) {
[09:28:21.977]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:21.977]         }
[09:28:21.977]         else {
[09:28:21.977]             ...future.result["stdout"] <- base::list(NULL)
[09:28:21.977]         }
[09:28:21.977]         base::close(...future.stdout)
[09:28:21.977]         ...future.stdout <- NULL
[09:28:21.977]     }
[09:28:21.977]     ...future.result$conditions <- ...future.conditions
[09:28:21.977]     ...future.result$finished <- base::Sys.time()
[09:28:21.977]     ...future.result
[09:28:21.977] }
[09:28:21.979] assign_globals() ...
[09:28:21.979] List of 5
[09:28:21.979]  $ ...future.FUN            :function (object, ...)  
[09:28:21.979]  $ future.call.arguments    :List of 1
[09:28:21.979]   ..$ digits: int 2
[09:28:21.979]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:21.979]  $ ...future.elements_ii    :List of 6
[09:28:21.979]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[09:28:21.979]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[09:28:21.979]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[09:28:21.979]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[09:28:21.979]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[09:28:21.979]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[09:28:21.979]  $ ...future.seeds_ii       : NULL
[09:28:21.979]  $ ...future.globals.maxSize: NULL
[09:28:21.979]  - attr(*, "where")=List of 5
[09:28:21.979]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:21.979]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:21.979]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:21.979]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:21.979]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:21.979]  - attr(*, "resolved")= logi FALSE
[09:28:21.979]  - attr(*, "total_size")= num 1296
[09:28:21.979]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:21.979]  - attr(*, "already-done")= logi TRUE
[09:28:21.985] - copied ‘...future.FUN’ to environment
[09:28:21.985] - copied ‘future.call.arguments’ to environment
[09:28:21.985] - copied ‘...future.elements_ii’ to environment
[09:28:21.985] - copied ‘...future.seeds_ii’ to environment
[09:28:21.985] - copied ‘...future.globals.maxSize’ to environment
[09:28:21.985] assign_globals() ... done
[09:28:21.986] plan(): Setting new future strategy stack:
[09:28:21.986] List of future strategies:
[09:28:21.986] 1. sequential:
[09:28:21.986]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:21.986]    - tweaked: FALSE
[09:28:21.986]    - call: NULL
[09:28:21.986] plan(): nbrOfWorkers() = 1
[09:28:21.988] plan(): Setting new future strategy stack:
[09:28:21.988] List of future strategies:
[09:28:21.988] 1. sequential:
[09:28:21.988]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:21.988]    - tweaked: FALSE
[09:28:21.988]    - call: plan(strategy)
[09:28:21.989] plan(): nbrOfWorkers() = 1
[09:28:21.989] SequentialFuture started (and completed)
[09:28:21.989] - Launch lazy future ... done
[09:28:21.989] run() for ‘SequentialFuture’ ... done
[09:28:21.989] Created future:
[09:28:21.989] SequentialFuture:
[09:28:21.989] Label: ‘future_by-1’
[09:28:21.989] Expression:
[09:28:21.989] {
[09:28:21.989]     do.call(function(...) {
[09:28:21.989]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:21.989]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:21.989]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:21.989]             on.exit(options(oopts), add = TRUE)
[09:28:21.989]         }
[09:28:21.989]         {
[09:28:21.989]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:21.989]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:21.989]                 ...future.FUN(...future.X_jj, ...)
[09:28:21.989]             })
[09:28:21.989]         }
[09:28:21.989]     }, args = future.call.arguments)
[09:28:21.989] }
[09:28:21.989] Lazy evaluation: FALSE
[09:28:21.989] Asynchronous evaluation: FALSE
[09:28:21.989] Local evaluation: TRUE
[09:28:21.989] Environment: R_GlobalEnv
[09:28:21.989] Capture standard output: TRUE
[09:28:21.989] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:21.989] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:21.989] Packages: <none>
[09:28:21.989] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:21.989] Resolved: TRUE
[09:28:21.989] Value: 5.48 KiB of class ‘list’
[09:28:21.989] Early signaling: FALSE
[09:28:21.989] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:21.989] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:21.990] Chunk #1 of 1 ... DONE
[09:28:21.990] Launching 1 futures (chunks) ... DONE
[09:28:21.991] Resolving 1 futures (chunks) ...
[09:28:21.991] resolve() on list ...
[09:28:21.991]  recursive: 0
[09:28:21.991]  length: 1
[09:28:21.991] 
[09:28:21.991] resolved() for ‘SequentialFuture’ ...
[09:28:21.991] - state: ‘finished’
[09:28:21.991] - run: TRUE
[09:28:21.991] - result: ‘FutureResult’
[09:28:21.991] resolved() for ‘SequentialFuture’ ... done
[09:28:21.991] Future #1
[09:28:21.992] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:21.992] - nx: 1
[09:28:21.992] - relay: TRUE
[09:28:21.992] - stdout: TRUE
[09:28:21.992] - signal: TRUE
[09:28:21.992] - resignal: FALSE
[09:28:21.992] - force: TRUE
[09:28:21.992] - relayed: [n=1] FALSE
[09:28:21.992] - queued futures: [n=1] FALSE
[09:28:21.992]  - until=1
[09:28:21.992]  - relaying element #1
[09:28:21.993] - relayed: [n=1] TRUE
[09:28:21.993] - queued futures: [n=1] TRUE
[09:28:21.993] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:21.993]  length: 0 (resolved future 1)
[09:28:21.993] Relaying remaining futures
[09:28:21.993] signalConditionsASAP(NULL, pos=0) ...
[09:28:21.993] - nx: 1
[09:28:21.993] - relay: TRUE
[09:28:21.993] - stdout: TRUE
[09:28:21.993] - signal: TRUE
[09:28:21.993] - resignal: FALSE
[09:28:21.993] - force: TRUE
[09:28:21.993] - relayed: [n=1] TRUE
[09:28:21.994] - queued futures: [n=1] TRUE
 - flush all
[09:28:21.994] - relayed: [n=1] TRUE
[09:28:21.994] - queued futures: [n=1] TRUE
[09:28:21.994] signalConditionsASAP(NULL, pos=0) ... done
[09:28:21.994] resolve() on list ... DONE
[09:28:21.994]  - Number of value chunks collected: 1
[09:28:21.994] Resolving 1 futures (chunks) ... DONE
[09:28:21.994] Reducing values from 1 chunks ...
[09:28:21.994]  - Number of values collected after concatenation: 6
[09:28:21.994]  - Number of values expected: 6
[09:28:21.994] Reducing values from 1 chunks ... DONE
[09:28:21.995] future_lapply() ... DONE
[09:28:21.995] future_by_internal() ... DONE
[09:28:21.998] future_by_internal() ...
[09:28:21.998] future_lapply() ...
[09:28:21.999] Number of chunks: 1
[09:28:21.999] getGlobalsAndPackagesXApply() ...
[09:28:21.999]  - future.globals: TRUE
[09:28:21.999] getGlobalsAndPackages() ...
[09:28:21.999] Searching for globals...
[09:28:22.000] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:22.000] Searching for globals ... DONE
[09:28:22.001] Resolving globals: FALSE
[09:28:22.001] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[09:28:22.001] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[09:28:22.001] - globals: [1] ‘FUN’
[09:28:22.002] - packages: [1] ‘stats’
[09:28:22.002] getGlobalsAndPackages() ... DONE
[09:28:22.002]  - globals found/used: [n=1] ‘FUN’
[09:28:22.002]  - needed namespaces: [n=1] ‘stats’
[09:28:22.002] Finding globals ... DONE
[09:28:22.002]  - use_args: TRUE
[09:28:22.002]  - Getting '...' globals ...
[09:28:22.002] resolve() on list ...
[09:28:22.002]  recursive: 0
[09:28:22.003]  length: 1
[09:28:22.003]  elements: ‘...’
[09:28:22.003]  length: 0 (resolved future 1)
[09:28:22.003] resolve() on list ... DONE
[09:28:22.003]    - '...' content: [n=1] ‘singular.ok’
[09:28:22.003] List of 1
[09:28:22.003]  $ ...:List of 1
[09:28:22.003]   ..$ singular.ok: logi FALSE
[09:28:22.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.003]  - attr(*, "where")=List of 1
[09:28:22.003]   ..$ ...:<environment: 0x555b0a3d08f0> 
[09:28:22.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.003]  - attr(*, "resolved")= logi TRUE
[09:28:22.003]  - attr(*, "total_size")= num NA
[09:28:22.006]  - Getting '...' globals ... DONE
[09:28:22.006] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.006] List of 2
[09:28:22.006]  $ ...future.FUN:function (x, ...)  
[09:28:22.006]  $ ...          :List of 1
[09:28:22.006]   ..$ singular.ok: logi FALSE
[09:28:22.006]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.006]  - attr(*, "where")=List of 2
[09:28:22.006]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.006]   ..$ ...          :<environment: 0x555b0a3d08f0> 
[09:28:22.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.006]  - attr(*, "resolved")= logi FALSE
[09:28:22.006]  - attr(*, "total_size")= num 5384
[09:28:22.010] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:22.010] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.010] Number of futures (= number of chunks): 1
[09:28:22.011] Launching 1 futures (chunks) ...
[09:28:22.011] Chunk #1 of 1 ...
[09:28:22.011]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.011] getGlobalsAndPackages() ...
[09:28:22.011] Searching for globals...
[09:28:22.011] 
[09:28:22.011] Searching for globals ... DONE
[09:28:22.012] - globals: [0] <none>
[09:28:22.012] getGlobalsAndPackages() ... DONE
[09:28:22.012]    + additional globals found: [n=0] 
[09:28:22.012]    + additional namespaces needed: [n=0] 
[09:28:22.012]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.012]  - seeds: <none>
[09:28:22.012]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.012] getGlobalsAndPackages() ...
[09:28:22.012] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.012] Resolving globals: FALSE
[09:28:22.012] Tweak future expression to call with '...' arguments ...
[09:28:22.013] {
[09:28:22.013]     do.call(function(...) {
[09:28:22.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.013]             on.exit(options(oopts), add = TRUE)
[09:28:22.013]         }
[09:28:22.013]         {
[09:28:22.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.013]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.013]             })
[09:28:22.013]         }
[09:28:22.013]     }, args = future.call.arguments)
[09:28:22.013] }
[09:28:22.013] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.013] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.013] 
[09:28:22.013] getGlobalsAndPackages() ... DONE
[09:28:22.014] run() for ‘Future’ ...
[09:28:22.014] - state: ‘created’
[09:28:22.014] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:22.014] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.014]   - Field: ‘label’
[09:28:22.014]   - Field: ‘local’
[09:28:22.014]   - Field: ‘owner’
[09:28:22.014]   - Field: ‘envir’
[09:28:22.015]   - Field: ‘packages’
[09:28:22.015]   - Field: ‘gc’
[09:28:22.015]   - Field: ‘conditions’
[09:28:22.015]   - Field: ‘expr’
[09:28:22.015]   - Field: ‘uuid’
[09:28:22.015]   - Field: ‘seed’
[09:28:22.015]   - Field: ‘version’
[09:28:22.015]   - Field: ‘result’
[09:28:22.015]   - Field: ‘asynchronous’
[09:28:22.015]   - Field: ‘calls’
[09:28:22.015]   - Field: ‘globals’
[09:28:22.015]   - Field: ‘stdout’
[09:28:22.016]   - Field: ‘earlySignal’
[09:28:22.016]   - Field: ‘lazy’
[09:28:22.016]   - Field: ‘state’
[09:28:22.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.016] - Launch lazy future ...
[09:28:22.016] Packages needed by the future expression (n = 1): ‘stats’
[09:28:22.016] Packages needed by future strategies (n = 0): <none>
[09:28:22.017] {
[09:28:22.017]     {
[09:28:22.017]         {
[09:28:22.017]             ...future.startTime <- base::Sys.time()
[09:28:22.017]             {
[09:28:22.017]                 {
[09:28:22.017]                   {
[09:28:22.017]                     {
[09:28:22.017]                       base::local({
[09:28:22.017]                         has_future <- base::requireNamespace("future", 
[09:28:22.017]                           quietly = TRUE)
[09:28:22.017]                         if (has_future) {
[09:28:22.017]                           ns <- base::getNamespace("future")
[09:28:22.017]                           version <- ns[[".package"]][["version"]]
[09:28:22.017]                           if (is.null(version)) 
[09:28:22.017]                             version <- utils::packageVersion("future")
[09:28:22.017]                         }
[09:28:22.017]                         else {
[09:28:22.017]                           version <- NULL
[09:28:22.017]                         }
[09:28:22.017]                         if (!has_future || version < "1.8.0") {
[09:28:22.017]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.017]                             "", base::R.version$version.string), 
[09:28:22.017]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:22.017]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.017]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.017]                               "release", "version")], collapse = " "), 
[09:28:22.017]                             hostname = base::Sys.info()[["nodename"]])
[09:28:22.017]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.017]                             info)
[09:28:22.017]                           info <- base::paste(info, collapse = "; ")
[09:28:22.017]                           if (!has_future) {
[09:28:22.017]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.017]                               info)
[09:28:22.017]                           }
[09:28:22.017]                           else {
[09:28:22.017]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.017]                               info, version)
[09:28:22.017]                           }
[09:28:22.017]                           base::stop(msg)
[09:28:22.017]                         }
[09:28:22.017]                       })
[09:28:22.017]                     }
[09:28:22.017]                     base::local({
[09:28:22.017]                       for (pkg in "stats") {
[09:28:22.017]                         base::loadNamespace(pkg)
[09:28:22.017]                         base::library(pkg, character.only = TRUE)
[09:28:22.017]                       }
[09:28:22.017]                     })
[09:28:22.017]                   }
[09:28:22.017]                   ...future.strategy.old <- future::plan("list")
[09:28:22.017]                   options(future.plan = NULL)
[09:28:22.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.017]                 }
[09:28:22.017]                 ...future.workdir <- getwd()
[09:28:22.017]             }
[09:28:22.017]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.017]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.017]         }
[09:28:22.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.017]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.017]             base::names(...future.oldOptions))
[09:28:22.017]     }
[09:28:22.017]     if (FALSE) {
[09:28:22.017]     }
[09:28:22.017]     else {
[09:28:22.017]         if (TRUE) {
[09:28:22.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.017]                 open = "w")
[09:28:22.017]         }
[09:28:22.017]         else {
[09:28:22.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.017]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.017]         }
[09:28:22.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.017]             base::sink(type = "output", split = FALSE)
[09:28:22.017]             base::close(...future.stdout)
[09:28:22.017]         }, add = TRUE)
[09:28:22.017]     }
[09:28:22.017]     ...future.frame <- base::sys.nframe()
[09:28:22.017]     ...future.conditions <- base::list()
[09:28:22.017]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.017]     if (FALSE) {
[09:28:22.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.017]     }
[09:28:22.017]     ...future.result <- base::tryCatch({
[09:28:22.017]         base::withCallingHandlers({
[09:28:22.017]             ...future.value <- base::withVisible(base::local({
[09:28:22.017]                 do.call(function(...) {
[09:28:22.017]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.017]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.017]                     ...future.globals.maxSize)) {
[09:28:22.017]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.017]                     on.exit(options(oopts), add = TRUE)
[09:28:22.017]                   }
[09:28:22.017]                   {
[09:28:22.017]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.017]                       FUN = function(jj) {
[09:28:22.017]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.017]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.017]                       })
[09:28:22.017]                   }
[09:28:22.017]                 }, args = future.call.arguments)
[09:28:22.017]             }))
[09:28:22.017]             future::FutureResult(value = ...future.value$value, 
[09:28:22.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.017]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.017]                     ...future.globalenv.names))
[09:28:22.017]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.017]         }, condition = base::local({
[09:28:22.017]             c <- base::c
[09:28:22.017]             inherits <- base::inherits
[09:28:22.017]             invokeRestart <- base::invokeRestart
[09:28:22.017]             length <- base::length
[09:28:22.017]             list <- base::list
[09:28:22.017]             seq.int <- base::seq.int
[09:28:22.017]             signalCondition <- base::signalCondition
[09:28:22.017]             sys.calls <- base::sys.calls
[09:28:22.017]             `[[` <- base::`[[`
[09:28:22.017]             `+` <- base::`+`
[09:28:22.017]             `<<-` <- base::`<<-`
[09:28:22.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.017]                   3L)]
[09:28:22.017]             }
[09:28:22.017]             function(cond) {
[09:28:22.017]                 is_error <- inherits(cond, "error")
[09:28:22.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.017]                   NULL)
[09:28:22.017]                 if (is_error) {
[09:28:22.017]                   sessionInformation <- function() {
[09:28:22.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.017]                       search = base::search(), system = base::Sys.info())
[09:28:22.017]                   }
[09:28:22.017]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.017]                     cond$call), session = sessionInformation(), 
[09:28:22.017]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.017]                   signalCondition(cond)
[09:28:22.017]                 }
[09:28:22.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.017]                 "immediateCondition"))) {
[09:28:22.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.017]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.017]                   if (TRUE && !signal) {
[09:28:22.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.017]                     {
[09:28:22.017]                       inherits <- base::inherits
[09:28:22.017]                       invokeRestart <- base::invokeRestart
[09:28:22.017]                       is.null <- base::is.null
[09:28:22.017]                       muffled <- FALSE
[09:28:22.017]                       if (inherits(cond, "message")) {
[09:28:22.017]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.017]                         if (muffled) 
[09:28:22.017]                           invokeRestart("muffleMessage")
[09:28:22.017]                       }
[09:28:22.017]                       else if (inherits(cond, "warning")) {
[09:28:22.017]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.017]                         if (muffled) 
[09:28:22.017]                           invokeRestart("muffleWarning")
[09:28:22.017]                       }
[09:28:22.017]                       else if (inherits(cond, "condition")) {
[09:28:22.017]                         if (!is.null(pattern)) {
[09:28:22.017]                           computeRestarts <- base::computeRestarts
[09:28:22.017]                           grepl <- base::grepl
[09:28:22.017]                           restarts <- computeRestarts(cond)
[09:28:22.017]                           for (restart in restarts) {
[09:28:22.017]                             name <- restart$name
[09:28:22.017]                             if (is.null(name)) 
[09:28:22.017]                               next
[09:28:22.017]                             if (!grepl(pattern, name)) 
[09:28:22.017]                               next
[09:28:22.017]                             invokeRestart(restart)
[09:28:22.017]                             muffled <- TRUE
[09:28:22.017]                             break
[09:28:22.017]                           }
[09:28:22.017]                         }
[09:28:22.017]                       }
[09:28:22.017]                       invisible(muffled)
[09:28:22.017]                     }
[09:28:22.017]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.017]                   }
[09:28:22.017]                 }
[09:28:22.017]                 else {
[09:28:22.017]                   if (TRUE) {
[09:28:22.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.017]                     {
[09:28:22.017]                       inherits <- base::inherits
[09:28:22.017]                       invokeRestart <- base::invokeRestart
[09:28:22.017]                       is.null <- base::is.null
[09:28:22.017]                       muffled <- FALSE
[09:28:22.017]                       if (inherits(cond, "message")) {
[09:28:22.017]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.017]                         if (muffled) 
[09:28:22.017]                           invokeRestart("muffleMessage")
[09:28:22.017]                       }
[09:28:22.017]                       else if (inherits(cond, "warning")) {
[09:28:22.017]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.017]                         if (muffled) 
[09:28:22.017]                           invokeRestart("muffleWarning")
[09:28:22.017]                       }
[09:28:22.017]                       else if (inherits(cond, "condition")) {
[09:28:22.017]                         if (!is.null(pattern)) {
[09:28:22.017]                           computeRestarts <- base::computeRestarts
[09:28:22.017]                           grepl <- base::grepl
[09:28:22.017]                           restarts <- computeRestarts(cond)
[09:28:22.017]                           for (restart in restarts) {
[09:28:22.017]                             name <- restart$name
[09:28:22.017]                             if (is.null(name)) 
[09:28:22.017]                               next
[09:28:22.017]                             if (!grepl(pattern, name)) 
[09:28:22.017]                               next
[09:28:22.017]                             invokeRestart(restart)
[09:28:22.017]                             muffled <- TRUE
[09:28:22.017]                             break
[09:28:22.017]                           }
[09:28:22.017]                         }
[09:28:22.017]                       }
[09:28:22.017]                       invisible(muffled)
[09:28:22.017]                     }
[09:28:22.017]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.017]                   }
[09:28:22.017]                 }
[09:28:22.017]             }
[09:28:22.017]         }))
[09:28:22.017]     }, error = function(ex) {
[09:28:22.017]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.017]                 ...future.rng), started = ...future.startTime, 
[09:28:22.017]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.017]             version = "1.8"), class = "FutureResult")
[09:28:22.017]     }, finally = {
[09:28:22.017]         if (!identical(...future.workdir, getwd())) 
[09:28:22.017]             setwd(...future.workdir)
[09:28:22.017]         {
[09:28:22.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.017]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.017]             }
[09:28:22.017]             base::options(...future.oldOptions)
[09:28:22.017]             if (.Platform$OS.type == "windows") {
[09:28:22.017]                 old_names <- names(...future.oldEnvVars)
[09:28:22.017]                 envs <- base::Sys.getenv()
[09:28:22.017]                 names <- names(envs)
[09:28:22.017]                 common <- intersect(names, old_names)
[09:28:22.017]                 added <- setdiff(names, old_names)
[09:28:22.017]                 removed <- setdiff(old_names, names)
[09:28:22.017]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.017]                   envs[common]]
[09:28:22.017]                 NAMES <- toupper(changed)
[09:28:22.017]                 args <- list()
[09:28:22.017]                 for (kk in seq_along(NAMES)) {
[09:28:22.017]                   name <- changed[[kk]]
[09:28:22.017]                   NAME <- NAMES[[kk]]
[09:28:22.017]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.017]                     next
[09:28:22.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.017]                 }
[09:28:22.017]                 NAMES <- toupper(added)
[09:28:22.017]                 for (kk in seq_along(NAMES)) {
[09:28:22.017]                   name <- added[[kk]]
[09:28:22.017]                   NAME <- NAMES[[kk]]
[09:28:22.017]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.017]                     next
[09:28:22.017]                   args[[name]] <- ""
[09:28:22.017]                 }
[09:28:22.017]                 NAMES <- toupper(removed)
[09:28:22.017]                 for (kk in seq_along(NAMES)) {
[09:28:22.017]                   name <- removed[[kk]]
[09:28:22.017]                   NAME <- NAMES[[kk]]
[09:28:22.017]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.017]                     next
[09:28:22.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.017]                 }
[09:28:22.017]                 if (length(args) > 0) 
[09:28:22.017]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.017]             }
[09:28:22.017]             else {
[09:28:22.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.017]             }
[09:28:22.017]             {
[09:28:22.017]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.017]                   0L) {
[09:28:22.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.017]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.017]                   base::options(opts)
[09:28:22.017]                 }
[09:28:22.017]                 {
[09:28:22.017]                   {
[09:28:22.017]                     NULL
[09:28:22.017]                     RNGkind("Mersenne-Twister")
[09:28:22.017]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.017]                       inherits = FALSE)
[09:28:22.017]                   }
[09:28:22.017]                   options(future.plan = NULL)
[09:28:22.017]                   if (is.na(NA_character_)) 
[09:28:22.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.017]                     .init = FALSE)
[09:28:22.017]                 }
[09:28:22.017]             }
[09:28:22.017]         }
[09:28:22.017]     })
[09:28:22.017]     if (TRUE) {
[09:28:22.017]         base::sink(type = "output", split = FALSE)
[09:28:22.017]         if (TRUE) {
[09:28:22.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.017]         }
[09:28:22.017]         else {
[09:28:22.017]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.017]         }
[09:28:22.017]         base::close(...future.stdout)
[09:28:22.017]         ...future.stdout <- NULL
[09:28:22.017]     }
[09:28:22.017]     ...future.result$conditions <- ...future.conditions
[09:28:22.017]     ...future.result$finished <- base::Sys.time()
[09:28:22.017]     ...future.result
[09:28:22.017] }
[09:28:22.018] assign_globals() ...
[09:28:22.018] List of 5
[09:28:22.018]  $ ...future.FUN            :function (x, ...)  
[09:28:22.018]  $ future.call.arguments    :List of 1
[09:28:22.018]   ..$ singular.ok: logi FALSE
[09:28:22.018]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.018]  $ ...future.elements_ii    :List of 3
[09:28:22.018]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.018]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.018]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.018]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.018]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.018]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.018]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.018]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.018]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.018]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.018]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.018]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.018]  $ ...future.seeds_ii       : NULL
[09:28:22.018]  $ ...future.globals.maxSize: NULL
[09:28:22.018]  - attr(*, "where")=List of 5
[09:28:22.018]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.018]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.018]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.018]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.018]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.018]  - attr(*, "resolved")= logi FALSE
[09:28:22.018]  - attr(*, "total_size")= num 5384
[09:28:22.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.018]  - attr(*, "already-done")= logi TRUE
[09:28:22.026] - reassign environment for ‘...future.FUN’
[09:28:22.026] - copied ‘...future.FUN’ to environment
[09:28:22.027] - copied ‘future.call.arguments’ to environment
[09:28:22.027] - copied ‘...future.elements_ii’ to environment
[09:28:22.027] - copied ‘...future.seeds_ii’ to environment
[09:28:22.027] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.027] assign_globals() ... done
[09:28:22.027] plan(): Setting new future strategy stack:
[09:28:22.027] List of future strategies:
[09:28:22.027] 1. sequential:
[09:28:22.027]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.027]    - tweaked: FALSE
[09:28:22.027]    - call: NULL
[09:28:22.028] plan(): nbrOfWorkers() = 1
[09:28:22.031] plan(): Setting new future strategy stack:
[09:28:22.031] List of future strategies:
[09:28:22.031] 1. sequential:
[09:28:22.031]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.031]    - tweaked: FALSE
[09:28:22.031]    - call: plan(strategy)
[09:28:22.032] plan(): nbrOfWorkers() = 1
[09:28:22.032] SequentialFuture started (and completed)
[09:28:22.032] - Launch lazy future ... done
[09:28:22.032] run() for ‘SequentialFuture’ ... done
[09:28:22.032] Created future:
[09:28:22.032] SequentialFuture:
[09:28:22.032] Label: ‘future_by-1’
[09:28:22.032] Expression:
[09:28:22.032] {
[09:28:22.032]     do.call(function(...) {
[09:28:22.032]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.032]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.032]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.032]             on.exit(options(oopts), add = TRUE)
[09:28:22.032]         }
[09:28:22.032]         {
[09:28:22.032]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.032]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.032]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.032]             })
[09:28:22.032]         }
[09:28:22.032]     }, args = future.call.arguments)
[09:28:22.032] }
[09:28:22.032] Lazy evaluation: FALSE
[09:28:22.032] Asynchronous evaluation: FALSE
[09:28:22.032] Local evaluation: TRUE
[09:28:22.032] Environment: R_GlobalEnv
[09:28:22.032] Capture standard output: TRUE
[09:28:22.032] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.032] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.032] Packages: 1 packages (‘stats’)
[09:28:22.032] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.032] Resolved: TRUE
[09:28:22.032] Value: 26.06 KiB of class ‘list’
[09:28:22.032] Early signaling: FALSE
[09:28:22.032] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.032] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.034] Chunk #1 of 1 ... DONE
[09:28:22.034] Launching 1 futures (chunks) ... DONE
[09:28:22.034] Resolving 1 futures (chunks) ...
[09:28:22.034] resolve() on list ...
[09:28:22.034]  recursive: 0
[09:28:22.034]  length: 1
[09:28:22.034] 
[09:28:22.034] resolved() for ‘SequentialFuture’ ...
[09:28:22.034] - state: ‘finished’
[09:28:22.034] - run: TRUE
[09:28:22.035] - result: ‘FutureResult’
[09:28:22.035] resolved() for ‘SequentialFuture’ ... done
[09:28:22.035] Future #1
[09:28:22.035] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.035] - nx: 1
[09:28:22.035] - relay: TRUE
[09:28:22.035] - stdout: TRUE
[09:28:22.035] - signal: TRUE
[09:28:22.035] - resignal: FALSE
[09:28:22.035] - force: TRUE
[09:28:22.035] - relayed: [n=1] FALSE
[09:28:22.035] - queued futures: [n=1] FALSE
[09:28:22.036]  - until=1
[09:28:22.036]  - relaying element #1
[09:28:22.036] - relayed: [n=1] TRUE
[09:28:22.036] - queued futures: [n=1] TRUE
[09:28:22.036] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.036]  length: 0 (resolved future 1)
[09:28:22.036] Relaying remaining futures
[09:28:22.036] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.036] - nx: 1
[09:28:22.036] - relay: TRUE
[09:28:22.037] - stdout: TRUE
[09:28:22.037] - signal: TRUE
[09:28:22.037] - resignal: FALSE
[09:28:22.037] - force: TRUE
[09:28:22.037] - relayed: [n=1] TRUE
[09:28:22.037] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.037] - relayed: [n=1] TRUE
[09:28:22.037] - queued futures: [n=1] TRUE
[09:28:22.037] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.037] resolve() on list ... DONE
[09:28:22.037]  - Number of value chunks collected: 1
[09:28:22.038] Resolving 1 futures (chunks) ... DONE
[09:28:22.038] Reducing values from 1 chunks ...
[09:28:22.038]  - Number of values collected after concatenation: 3
[09:28:22.038]  - Number of values expected: 3
[09:28:22.038] Reducing values from 1 chunks ... DONE
[09:28:22.038] future_lapply() ... DONE
[09:28:22.038] future_by_internal() ... DONE
[09:28:22.042] future_by_internal() ...
[09:28:22.042] future_lapply() ...
[09:28:22.043] Number of chunks: 1
[09:28:22.043] getGlobalsAndPackagesXApply() ...
[09:28:22.043]  - future.globals: TRUE
[09:28:22.043] getGlobalsAndPackages() ...
[09:28:22.043] Searching for globals...
[09:28:22.045] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:22.045] Searching for globals ... DONE
[09:28:22.045] Resolving globals: FALSE
[09:28:22.045] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[09:28:22.046] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[09:28:22.046] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:22.046] - packages: [1] ‘stats’
[09:28:22.046] getGlobalsAndPackages() ... DONE
[09:28:22.046]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:22.046]  - needed namespaces: [n=1] ‘stats’
[09:28:22.046] Finding globals ... DONE
[09:28:22.046]  - use_args: TRUE
[09:28:22.046]  - Getting '...' globals ...
[09:28:22.048] resolve() on list ...
[09:28:22.048]  recursive: 0
[09:28:22.048]  length: 1
[09:28:22.048]  elements: ‘...’
[09:28:22.048]  length: 0 (resolved future 1)
[09:28:22.048] resolve() on list ... DONE
[09:28:22.048]    - '...' content: [n=0] 
[09:28:22.048] List of 1
[09:28:22.048]  $ ...: list()
[09:28:22.048]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.048]  - attr(*, "where")=List of 1
[09:28:22.048]   ..$ ...:<environment: 0x555b0a685450> 
[09:28:22.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.048]  - attr(*, "resolved")= logi TRUE
[09:28:22.048]  - attr(*, "total_size")= num NA
[09:28:22.051]  - Getting '...' globals ... DONE
[09:28:22.051] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[09:28:22.051] List of 4
[09:28:22.051]  $ ...future.FUN:function (x)  
[09:28:22.051]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:22.051]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.051]  $ ...          : list()
[09:28:22.051]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.051]  - attr(*, "where")=List of 4
[09:28:22.051]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.051]   ..$ breaks       :<environment: R_EmptyEnv> 
[09:28:22.051]   ..$ wool         :<environment: R_EmptyEnv> 
[09:28:22.051]   ..$ ...          :<environment: 0x555b0a685450> 
[09:28:22.051]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.051]  - attr(*, "resolved")= logi FALSE
[09:28:22.051]  - attr(*, "total_size")= num 2320
[09:28:22.054] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:22.054] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.055] Number of futures (= number of chunks): 1
[09:28:22.055] Launching 1 futures (chunks) ...
[09:28:22.055] Chunk #1 of 1 ...
[09:28:22.055]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.055] getGlobalsAndPackages() ...
[09:28:22.055] Searching for globals...
[09:28:22.055] 
[09:28:22.056] Searching for globals ... DONE
[09:28:22.056] - globals: [0] <none>
[09:28:22.056] getGlobalsAndPackages() ... DONE
[09:28:22.056]    + additional globals found: [n=0] 
[09:28:22.056]    + additional namespaces needed: [n=0] 
[09:28:22.056]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.056]  - seeds: <none>
[09:28:22.056]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.056] getGlobalsAndPackages() ...
[09:28:22.056] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.057] Resolving globals: FALSE
[09:28:22.057] Tweak future expression to call with '...' arguments ...
[09:28:22.057] {
[09:28:22.057]     do.call(function(...) {
[09:28:22.057]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.057]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.057]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.057]             on.exit(options(oopts), add = TRUE)
[09:28:22.057]         }
[09:28:22.057]         {
[09:28:22.057]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.057]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.057]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.057]             })
[09:28:22.057]         }
[09:28:22.057]     }, args = future.call.arguments)
[09:28:22.057] }
[09:28:22.057] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.057] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.057] 
[09:28:22.058] getGlobalsAndPackages() ... DONE
[09:28:22.058] run() for ‘Future’ ...
[09:28:22.058] - state: ‘created’
[09:28:22.058] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:22.058] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.058] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.058]   - Field: ‘label’
[09:28:22.059]   - Field: ‘local’
[09:28:22.059]   - Field: ‘owner’
[09:28:22.059]   - Field: ‘envir’
[09:28:22.059]   - Field: ‘packages’
[09:28:22.059]   - Field: ‘gc’
[09:28:22.059]   - Field: ‘conditions’
[09:28:22.059]   - Field: ‘expr’
[09:28:22.059]   - Field: ‘uuid’
[09:28:22.059]   - Field: ‘seed’
[09:28:22.059]   - Field: ‘version’
[09:28:22.059]   - Field: ‘result’
[09:28:22.059]   - Field: ‘asynchronous’
[09:28:22.060]   - Field: ‘calls’
[09:28:22.060]   - Field: ‘globals’
[09:28:22.060]   - Field: ‘stdout’
[09:28:22.060]   - Field: ‘earlySignal’
[09:28:22.060]   - Field: ‘lazy’
[09:28:22.060]   - Field: ‘state’
[09:28:22.060] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.060] - Launch lazy future ...
[09:28:22.060] Packages needed by the future expression (n = 1): ‘stats’
[09:28:22.060] Packages needed by future strategies (n = 0): <none>
[09:28:22.061] {
[09:28:22.061]     {
[09:28:22.061]         {
[09:28:22.061]             ...future.startTime <- base::Sys.time()
[09:28:22.061]             {
[09:28:22.061]                 {
[09:28:22.061]                   {
[09:28:22.061]                     {
[09:28:22.061]                       base::local({
[09:28:22.061]                         has_future <- base::requireNamespace("future", 
[09:28:22.061]                           quietly = TRUE)
[09:28:22.061]                         if (has_future) {
[09:28:22.061]                           ns <- base::getNamespace("future")
[09:28:22.061]                           version <- ns[[".package"]][["version"]]
[09:28:22.061]                           if (is.null(version)) 
[09:28:22.061]                             version <- utils::packageVersion("future")
[09:28:22.061]                         }
[09:28:22.061]                         else {
[09:28:22.061]                           version <- NULL
[09:28:22.061]                         }
[09:28:22.061]                         if (!has_future || version < "1.8.0") {
[09:28:22.061]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.061]                             "", base::R.version$version.string), 
[09:28:22.061]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:22.061]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.061]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.061]                               "release", "version")], collapse = " "), 
[09:28:22.061]                             hostname = base::Sys.info()[["nodename"]])
[09:28:22.061]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.061]                             info)
[09:28:22.061]                           info <- base::paste(info, collapse = "; ")
[09:28:22.061]                           if (!has_future) {
[09:28:22.061]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.061]                               info)
[09:28:22.061]                           }
[09:28:22.061]                           else {
[09:28:22.061]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.061]                               info, version)
[09:28:22.061]                           }
[09:28:22.061]                           base::stop(msg)
[09:28:22.061]                         }
[09:28:22.061]                       })
[09:28:22.061]                     }
[09:28:22.061]                     base::local({
[09:28:22.061]                       for (pkg in "stats") {
[09:28:22.061]                         base::loadNamespace(pkg)
[09:28:22.061]                         base::library(pkg, character.only = TRUE)
[09:28:22.061]                       }
[09:28:22.061]                     })
[09:28:22.061]                   }
[09:28:22.061]                   ...future.strategy.old <- future::plan("list")
[09:28:22.061]                   options(future.plan = NULL)
[09:28:22.061]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.061]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.061]                 }
[09:28:22.061]                 ...future.workdir <- getwd()
[09:28:22.061]             }
[09:28:22.061]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.061]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.061]         }
[09:28:22.061]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.061]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.061]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.061]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.061]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.061]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.061]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.061]             base::names(...future.oldOptions))
[09:28:22.061]     }
[09:28:22.061]     if (FALSE) {
[09:28:22.061]     }
[09:28:22.061]     else {
[09:28:22.061]         if (TRUE) {
[09:28:22.061]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.061]                 open = "w")
[09:28:22.061]         }
[09:28:22.061]         else {
[09:28:22.061]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.061]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.061]         }
[09:28:22.061]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.061]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.061]             base::sink(type = "output", split = FALSE)
[09:28:22.061]             base::close(...future.stdout)
[09:28:22.061]         }, add = TRUE)
[09:28:22.061]     }
[09:28:22.061]     ...future.frame <- base::sys.nframe()
[09:28:22.061]     ...future.conditions <- base::list()
[09:28:22.061]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.061]     if (FALSE) {
[09:28:22.061]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.061]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.061]     }
[09:28:22.061]     ...future.result <- base::tryCatch({
[09:28:22.061]         base::withCallingHandlers({
[09:28:22.061]             ...future.value <- base::withVisible(base::local({
[09:28:22.061]                 do.call(function(...) {
[09:28:22.061]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.061]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.061]                     ...future.globals.maxSize)) {
[09:28:22.061]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.061]                     on.exit(options(oopts), add = TRUE)
[09:28:22.061]                   }
[09:28:22.061]                   {
[09:28:22.061]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.061]                       FUN = function(jj) {
[09:28:22.061]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.061]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.061]                       })
[09:28:22.061]                   }
[09:28:22.061]                 }, args = future.call.arguments)
[09:28:22.061]             }))
[09:28:22.061]             future::FutureResult(value = ...future.value$value, 
[09:28:22.061]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.061]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.061]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.061]                     ...future.globalenv.names))
[09:28:22.061]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.061]         }, condition = base::local({
[09:28:22.061]             c <- base::c
[09:28:22.061]             inherits <- base::inherits
[09:28:22.061]             invokeRestart <- base::invokeRestart
[09:28:22.061]             length <- base::length
[09:28:22.061]             list <- base::list
[09:28:22.061]             seq.int <- base::seq.int
[09:28:22.061]             signalCondition <- base::signalCondition
[09:28:22.061]             sys.calls <- base::sys.calls
[09:28:22.061]             `[[` <- base::`[[`
[09:28:22.061]             `+` <- base::`+`
[09:28:22.061]             `<<-` <- base::`<<-`
[09:28:22.061]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.061]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.061]                   3L)]
[09:28:22.061]             }
[09:28:22.061]             function(cond) {
[09:28:22.061]                 is_error <- inherits(cond, "error")
[09:28:22.061]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.061]                   NULL)
[09:28:22.061]                 if (is_error) {
[09:28:22.061]                   sessionInformation <- function() {
[09:28:22.061]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.061]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.061]                       search = base::search(), system = base::Sys.info())
[09:28:22.061]                   }
[09:28:22.061]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.061]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.061]                     cond$call), session = sessionInformation(), 
[09:28:22.061]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.061]                   signalCondition(cond)
[09:28:22.061]                 }
[09:28:22.061]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.061]                 "immediateCondition"))) {
[09:28:22.061]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.061]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.061]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.061]                   if (TRUE && !signal) {
[09:28:22.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.061]                     {
[09:28:22.061]                       inherits <- base::inherits
[09:28:22.061]                       invokeRestart <- base::invokeRestart
[09:28:22.061]                       is.null <- base::is.null
[09:28:22.061]                       muffled <- FALSE
[09:28:22.061]                       if (inherits(cond, "message")) {
[09:28:22.061]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.061]                         if (muffled) 
[09:28:22.061]                           invokeRestart("muffleMessage")
[09:28:22.061]                       }
[09:28:22.061]                       else if (inherits(cond, "warning")) {
[09:28:22.061]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.061]                         if (muffled) 
[09:28:22.061]                           invokeRestart("muffleWarning")
[09:28:22.061]                       }
[09:28:22.061]                       else if (inherits(cond, "condition")) {
[09:28:22.061]                         if (!is.null(pattern)) {
[09:28:22.061]                           computeRestarts <- base::computeRestarts
[09:28:22.061]                           grepl <- base::grepl
[09:28:22.061]                           restarts <- computeRestarts(cond)
[09:28:22.061]                           for (restart in restarts) {
[09:28:22.061]                             name <- restart$name
[09:28:22.061]                             if (is.null(name)) 
[09:28:22.061]                               next
[09:28:22.061]                             if (!grepl(pattern, name)) 
[09:28:22.061]                               next
[09:28:22.061]                             invokeRestart(restart)
[09:28:22.061]                             muffled <- TRUE
[09:28:22.061]                             break
[09:28:22.061]                           }
[09:28:22.061]                         }
[09:28:22.061]                       }
[09:28:22.061]                       invisible(muffled)
[09:28:22.061]                     }
[09:28:22.061]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.061]                   }
[09:28:22.061]                 }
[09:28:22.061]                 else {
[09:28:22.061]                   if (TRUE) {
[09:28:22.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.061]                     {
[09:28:22.061]                       inherits <- base::inherits
[09:28:22.061]                       invokeRestart <- base::invokeRestart
[09:28:22.061]                       is.null <- base::is.null
[09:28:22.061]                       muffled <- FALSE
[09:28:22.061]                       if (inherits(cond, "message")) {
[09:28:22.061]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.061]                         if (muffled) 
[09:28:22.061]                           invokeRestart("muffleMessage")
[09:28:22.061]                       }
[09:28:22.061]                       else if (inherits(cond, "warning")) {
[09:28:22.061]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.061]                         if (muffled) 
[09:28:22.061]                           invokeRestart("muffleWarning")
[09:28:22.061]                       }
[09:28:22.061]                       else if (inherits(cond, "condition")) {
[09:28:22.061]                         if (!is.null(pattern)) {
[09:28:22.061]                           computeRestarts <- base::computeRestarts
[09:28:22.061]                           grepl <- base::grepl
[09:28:22.061]                           restarts <- computeRestarts(cond)
[09:28:22.061]                           for (restart in restarts) {
[09:28:22.061]                             name <- restart$name
[09:28:22.061]                             if (is.null(name)) 
[09:28:22.061]                               next
[09:28:22.061]                             if (!grepl(pattern, name)) 
[09:28:22.061]                               next
[09:28:22.061]                             invokeRestart(restart)
[09:28:22.061]                             muffled <- TRUE
[09:28:22.061]                             break
[09:28:22.061]                           }
[09:28:22.061]                         }
[09:28:22.061]                       }
[09:28:22.061]                       invisible(muffled)
[09:28:22.061]                     }
[09:28:22.061]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.061]                   }
[09:28:22.061]                 }
[09:28:22.061]             }
[09:28:22.061]         }))
[09:28:22.061]     }, error = function(ex) {
[09:28:22.061]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.061]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.061]                 ...future.rng), started = ...future.startTime, 
[09:28:22.061]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.061]             version = "1.8"), class = "FutureResult")
[09:28:22.061]     }, finally = {
[09:28:22.061]         if (!identical(...future.workdir, getwd())) 
[09:28:22.061]             setwd(...future.workdir)
[09:28:22.061]         {
[09:28:22.061]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.061]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.061]             }
[09:28:22.061]             base::options(...future.oldOptions)
[09:28:22.061]             if (.Platform$OS.type == "windows") {
[09:28:22.061]                 old_names <- names(...future.oldEnvVars)
[09:28:22.061]                 envs <- base::Sys.getenv()
[09:28:22.061]                 names <- names(envs)
[09:28:22.061]                 common <- intersect(names, old_names)
[09:28:22.061]                 added <- setdiff(names, old_names)
[09:28:22.061]                 removed <- setdiff(old_names, names)
[09:28:22.061]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.061]                   envs[common]]
[09:28:22.061]                 NAMES <- toupper(changed)
[09:28:22.061]                 args <- list()
[09:28:22.061]                 for (kk in seq_along(NAMES)) {
[09:28:22.061]                   name <- changed[[kk]]
[09:28:22.061]                   NAME <- NAMES[[kk]]
[09:28:22.061]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.061]                     next
[09:28:22.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.061]                 }
[09:28:22.061]                 NAMES <- toupper(added)
[09:28:22.061]                 for (kk in seq_along(NAMES)) {
[09:28:22.061]                   name <- added[[kk]]
[09:28:22.061]                   NAME <- NAMES[[kk]]
[09:28:22.061]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.061]                     next
[09:28:22.061]                   args[[name]] <- ""
[09:28:22.061]                 }
[09:28:22.061]                 NAMES <- toupper(removed)
[09:28:22.061]                 for (kk in seq_along(NAMES)) {
[09:28:22.061]                   name <- removed[[kk]]
[09:28:22.061]                   NAME <- NAMES[[kk]]
[09:28:22.061]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.061]                     next
[09:28:22.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.061]                 }
[09:28:22.061]                 if (length(args) > 0) 
[09:28:22.061]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.061]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.061]             }
[09:28:22.061]             else {
[09:28:22.061]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.061]             }
[09:28:22.061]             {
[09:28:22.061]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.061]                   0L) {
[09:28:22.061]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.061]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.061]                   base::options(opts)
[09:28:22.061]                 }
[09:28:22.061]                 {
[09:28:22.061]                   {
[09:28:22.061]                     NULL
[09:28:22.061]                     RNGkind("Mersenne-Twister")
[09:28:22.061]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.061]                       inherits = FALSE)
[09:28:22.061]                   }
[09:28:22.061]                   options(future.plan = NULL)
[09:28:22.061]                   if (is.na(NA_character_)) 
[09:28:22.061]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.061]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.061]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.061]                     .init = FALSE)
[09:28:22.061]                 }
[09:28:22.061]             }
[09:28:22.061]         }
[09:28:22.061]     })
[09:28:22.061]     if (TRUE) {
[09:28:22.061]         base::sink(type = "output", split = FALSE)
[09:28:22.061]         if (TRUE) {
[09:28:22.061]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.061]         }
[09:28:22.061]         else {
[09:28:22.061]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.061]         }
[09:28:22.061]         base::close(...future.stdout)
[09:28:22.061]         ...future.stdout <- NULL
[09:28:22.061]     }
[09:28:22.061]     ...future.result$conditions <- ...future.conditions
[09:28:22.061]     ...future.result$finished <- base::Sys.time()
[09:28:22.061]     ...future.result
[09:28:22.061] }
[09:28:22.063] assign_globals() ...
[09:28:22.063] List of 7
[09:28:22.063]  $ ...future.FUN            :function (x)  
[09:28:22.063]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:22.063]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.063]  $ future.call.arguments    : list()
[09:28:22.063]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.063]  $ ...future.elements_ii    :List of 3
[09:28:22.063]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.063]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.063]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.063]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.063]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.063]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.063]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.063]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.063]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.063]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.063]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.063]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.063]  $ ...future.seeds_ii       : NULL
[09:28:22.063]  $ ...future.globals.maxSize: NULL
[09:28:22.063]  - attr(*, "where")=List of 7
[09:28:22.063]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.063]   ..$ breaks                   :<environment: R_EmptyEnv> 
[09:28:22.063]   ..$ wool                     :<environment: R_EmptyEnv> 
[09:28:22.063]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.063]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.063]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.063]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.063]  - attr(*, "resolved")= logi FALSE
[09:28:22.063]  - attr(*, "total_size")= num 2320
[09:28:22.063]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.063]  - attr(*, "already-done")= logi TRUE
[09:28:22.072] - reassign environment for ‘...future.FUN’
[09:28:22.072] - copied ‘...future.FUN’ to environment
[09:28:22.073] - copied ‘breaks’ to environment
[09:28:22.073] - copied ‘wool’ to environment
[09:28:22.073] - copied ‘future.call.arguments’ to environment
[09:28:22.073] - copied ‘...future.elements_ii’ to environment
[09:28:22.073] - copied ‘...future.seeds_ii’ to environment
[09:28:22.073] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.073] assign_globals() ... done
[09:28:22.073] plan(): Setting new future strategy stack:
[09:28:22.074] List of future strategies:
[09:28:22.074] 1. sequential:
[09:28:22.074]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.074]    - tweaked: FALSE
[09:28:22.074]    - call: NULL
[09:28:22.074] plan(): nbrOfWorkers() = 1
[09:28:22.076] plan(): Setting new future strategy stack:
[09:28:22.077] List of future strategies:
[09:28:22.077] 1. sequential:
[09:28:22.077]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.077]    - tweaked: FALSE
[09:28:22.077]    - call: plan(strategy)
[09:28:22.077] plan(): nbrOfWorkers() = 1
[09:28:22.077] SequentialFuture started (and completed)
[09:28:22.077] - Launch lazy future ... done
[09:28:22.077] run() for ‘SequentialFuture’ ... done
[09:28:22.077] Created future:
[09:28:22.077] SequentialFuture:
[09:28:22.077] Label: ‘future_by-1’
[09:28:22.077] Expression:
[09:28:22.077] {
[09:28:22.077]     do.call(function(...) {
[09:28:22.077]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.077]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.077]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.077]             on.exit(options(oopts), add = TRUE)
[09:28:22.077]         }
[09:28:22.077]         {
[09:28:22.077]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.077]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.077]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.077]             })
[09:28:22.077]         }
[09:28:22.077]     }, args = future.call.arguments)
[09:28:22.077] }
[09:28:22.077] Lazy evaluation: FALSE
[09:28:22.077] Asynchronous evaluation: FALSE
[09:28:22.077] Local evaluation: TRUE
[09:28:22.077] Environment: 0x555b0a647358
[09:28:22.077] Capture standard output: TRUE
[09:28:22.077] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.077] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[09:28:22.077] Packages: 1 packages (‘stats’)
[09:28:22.077] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.077] Resolved: TRUE
[09:28:22.077] Value: 25.57 KiB of class ‘list’
[09:28:22.077] Early signaling: FALSE
[09:28:22.077] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.077] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.079] Chunk #1 of 1 ... DONE
[09:28:22.079] Launching 1 futures (chunks) ... DONE
[09:28:22.079] Resolving 1 futures (chunks) ...
[09:28:22.079] resolve() on list ...
[09:28:22.079]  recursive: 0
[09:28:22.079]  length: 1
[09:28:22.079] 
[09:28:22.080] resolved() for ‘SequentialFuture’ ...
[09:28:22.080] - state: ‘finished’
[09:28:22.080] - run: TRUE
[09:28:22.080] - result: ‘FutureResult’
[09:28:22.080] resolved() for ‘SequentialFuture’ ... done
[09:28:22.080] Future #1
[09:28:22.080] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.080] - nx: 1
[09:28:22.080] - relay: TRUE
[09:28:22.080] - stdout: TRUE
[09:28:22.080] - signal: TRUE
[09:28:22.081] - resignal: FALSE
[09:28:22.081] - force: TRUE
[09:28:22.081] - relayed: [n=1] FALSE
[09:28:22.081] - queued futures: [n=1] FALSE
[09:28:22.081]  - until=1
[09:28:22.081]  - relaying element #1
[09:28:22.081] - relayed: [n=1] TRUE
[09:28:22.081] - queued futures: [n=1] TRUE
[09:28:22.081] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.081]  length: 0 (resolved future 1)
[09:28:22.081] Relaying remaining futures
[09:28:22.082] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.082] - nx: 1
[09:28:22.082] - relay: TRUE
[09:28:22.082] - stdout: TRUE
[09:28:22.082] - signal: TRUE
[09:28:22.082] - resignal: FALSE
[09:28:22.082] - force: TRUE
[09:28:22.082] - relayed: [n=1] TRUE
[09:28:22.082] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.082] - relayed: [n=1] TRUE
[09:28:22.082] - queued futures: [n=1] TRUE
[09:28:22.082] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.083] resolve() on list ... DONE
[09:28:22.083]  - Number of value chunks collected: 1
[09:28:22.083] Resolving 1 futures (chunks) ... DONE
[09:28:22.083] Reducing values from 1 chunks ...
[09:28:22.083]  - Number of values collected after concatenation: 3
[09:28:22.083]  - Number of values expected: 3
[09:28:22.083] Reducing values from 1 chunks ... DONE
[09:28:22.083] future_lapply() ... DONE
[09:28:22.083] future_by_internal() ... DONE
[09:28:22.084] future_by_internal() ...
[09:28:22.084] future_lapply() ...
[09:28:22.084] Number of chunks: 1
[09:28:22.084] getGlobalsAndPackagesXApply() ...
[09:28:22.085]  - future.globals: TRUE
[09:28:22.085] getGlobalsAndPackages() ...
[09:28:22.085] Searching for globals...
[09:28:22.086] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.086] Searching for globals ... DONE
[09:28:22.086] Resolving globals: FALSE
[09:28:22.086] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.087] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.087] - globals: [1] ‘FUN’
[09:28:22.087] 
[09:28:22.088] getGlobalsAndPackages() ... DONE
[09:28:22.088]  - globals found/used: [n=1] ‘FUN’
[09:28:22.088]  - needed namespaces: [n=0] 
[09:28:22.088] Finding globals ... DONE
[09:28:22.088]  - use_args: TRUE
[09:28:22.088]  - Getting '...' globals ...
[09:28:22.088] resolve() on list ...
[09:28:22.088]  recursive: 0
[09:28:22.089]  length: 1
[09:28:22.089]  elements: ‘...’
[09:28:22.089]  length: 0 (resolved future 1)
[09:28:22.089] resolve() on list ... DONE
[09:28:22.089]    - '...' content: [n=0] 
[09:28:22.089] List of 1
[09:28:22.089]  $ ...: list()
[09:28:22.089]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.089]  - attr(*, "where")=List of 1
[09:28:22.089]   ..$ ...:<environment: 0x555b0a82ba40> 
[09:28:22.089]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.089]  - attr(*, "resolved")= logi TRUE
[09:28:22.089]  - attr(*, "total_size")= num NA
[09:28:22.091]  - Getting '...' globals ... DONE
[09:28:22.091] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.092] List of 2
[09:28:22.092]  $ ...future.FUN:function (object, ...)  
[09:28:22.092]  $ ...          : list()
[09:28:22.092]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.092]  - attr(*, "where")=List of 2
[09:28:22.092]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.092]   ..$ ...          :<environment: 0x555b0a82ba40> 
[09:28:22.092]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.092]  - attr(*, "resolved")= logi FALSE
[09:28:22.092]  - attr(*, "total_size")= num 1240
[09:28:22.094] Packages to be attached in all futures: [n=0] 
[09:28:22.094] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.094] Number of futures (= number of chunks): 1
[09:28:22.094] Launching 1 futures (chunks) ...
[09:28:22.094] Chunk #1 of 1 ...
[09:28:22.095]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.095] getGlobalsAndPackages() ...
[09:28:22.095] Searching for globals...
[09:28:22.095] 
[09:28:22.095] Searching for globals ... DONE
[09:28:22.095] - globals: [0] <none>
[09:28:22.095] getGlobalsAndPackages() ... DONE
[09:28:22.096]    + additional globals found: [n=0] 
[09:28:22.096]    + additional namespaces needed: [n=0] 
[09:28:22.096]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.096]  - seeds: <none>
[09:28:22.096]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.096] getGlobalsAndPackages() ...
[09:28:22.096] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.096] Resolving globals: FALSE
[09:28:22.096] Tweak future expression to call with '...' arguments ...
[09:28:22.096] {
[09:28:22.096]     do.call(function(...) {
[09:28:22.096]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.096]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.096]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.096]             on.exit(options(oopts), add = TRUE)
[09:28:22.096]         }
[09:28:22.096]         {
[09:28:22.096]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.096]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.096]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.096]             })
[09:28:22.096]         }
[09:28:22.096]     }, args = future.call.arguments)
[09:28:22.096] }
[09:28:22.097] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.097] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.097] 
[09:28:22.097] getGlobalsAndPackages() ... DONE
[09:28:22.097] run() for ‘Future’ ...
[09:28:22.097] - state: ‘created’
[09:28:22.098] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:22.098] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.098] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.098]   - Field: ‘label’
[09:28:22.098]   - Field: ‘local’
[09:28:22.098]   - Field: ‘owner’
[09:28:22.098]   - Field: ‘envir’
[09:28:22.098]   - Field: ‘packages’
[09:28:22.098]   - Field: ‘gc’
[09:28:22.099]   - Field: ‘conditions’
[09:28:22.099]   - Field: ‘expr’
[09:28:22.099]   - Field: ‘uuid’
[09:28:22.099]   - Field: ‘seed’
[09:28:22.099]   - Field: ‘version’
[09:28:22.099]   - Field: ‘result’
[09:28:22.099]   - Field: ‘asynchronous’
[09:28:22.099]   - Field: ‘calls’
[09:28:22.099]   - Field: ‘globals’
[09:28:22.099]   - Field: ‘stdout’
[09:28:22.099]   - Field: ‘earlySignal’
[09:28:22.099]   - Field: ‘lazy’
[09:28:22.100]   - Field: ‘state’
[09:28:22.100] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.100] - Launch lazy future ...
[09:28:22.100] Packages needed by the future expression (n = 0): <none>
[09:28:22.100] Packages needed by future strategies (n = 0): <none>
[09:28:22.100] {
[09:28:22.100]     {
[09:28:22.100]         {
[09:28:22.100]             ...future.startTime <- base::Sys.time()
[09:28:22.100]             {
[09:28:22.100]                 {
[09:28:22.100]                   {
[09:28:22.100]                     base::local({
[09:28:22.100]                       has_future <- base::requireNamespace("future", 
[09:28:22.100]                         quietly = TRUE)
[09:28:22.100]                       if (has_future) {
[09:28:22.100]                         ns <- base::getNamespace("future")
[09:28:22.100]                         version <- ns[[".package"]][["version"]]
[09:28:22.100]                         if (is.null(version)) 
[09:28:22.100]                           version <- utils::packageVersion("future")
[09:28:22.100]                       }
[09:28:22.100]                       else {
[09:28:22.100]                         version <- NULL
[09:28:22.100]                       }
[09:28:22.100]                       if (!has_future || version < "1.8.0") {
[09:28:22.100]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.100]                           "", base::R.version$version.string), 
[09:28:22.100]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.100]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.100]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.100]                             "release", "version")], collapse = " "), 
[09:28:22.100]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.100]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.100]                           info)
[09:28:22.100]                         info <- base::paste(info, collapse = "; ")
[09:28:22.100]                         if (!has_future) {
[09:28:22.100]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.100]                             info)
[09:28:22.100]                         }
[09:28:22.100]                         else {
[09:28:22.100]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.100]                             info, version)
[09:28:22.100]                         }
[09:28:22.100]                         base::stop(msg)
[09:28:22.100]                       }
[09:28:22.100]                     })
[09:28:22.100]                   }
[09:28:22.100]                   ...future.strategy.old <- future::plan("list")
[09:28:22.100]                   options(future.plan = NULL)
[09:28:22.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.100]                 }
[09:28:22.100]                 ...future.workdir <- getwd()
[09:28:22.100]             }
[09:28:22.100]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.100]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.100]         }
[09:28:22.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.100]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.100]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.100]             base::names(...future.oldOptions))
[09:28:22.100]     }
[09:28:22.100]     if (FALSE) {
[09:28:22.100]     }
[09:28:22.100]     else {
[09:28:22.100]         if (TRUE) {
[09:28:22.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.100]                 open = "w")
[09:28:22.100]         }
[09:28:22.100]         else {
[09:28:22.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.100]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.100]         }
[09:28:22.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.100]             base::sink(type = "output", split = FALSE)
[09:28:22.100]             base::close(...future.stdout)
[09:28:22.100]         }, add = TRUE)
[09:28:22.100]     }
[09:28:22.100]     ...future.frame <- base::sys.nframe()
[09:28:22.100]     ...future.conditions <- base::list()
[09:28:22.100]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.100]     if (FALSE) {
[09:28:22.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.100]     }
[09:28:22.100]     ...future.result <- base::tryCatch({
[09:28:22.100]         base::withCallingHandlers({
[09:28:22.100]             ...future.value <- base::withVisible(base::local({
[09:28:22.100]                 do.call(function(...) {
[09:28:22.100]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.100]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.100]                     ...future.globals.maxSize)) {
[09:28:22.100]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.100]                     on.exit(options(oopts), add = TRUE)
[09:28:22.100]                   }
[09:28:22.100]                   {
[09:28:22.100]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.100]                       FUN = function(jj) {
[09:28:22.100]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.100]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.100]                       })
[09:28:22.100]                   }
[09:28:22.100]                 }, args = future.call.arguments)
[09:28:22.100]             }))
[09:28:22.100]             future::FutureResult(value = ...future.value$value, 
[09:28:22.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.100]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.100]                     ...future.globalenv.names))
[09:28:22.100]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.100]         }, condition = base::local({
[09:28:22.100]             c <- base::c
[09:28:22.100]             inherits <- base::inherits
[09:28:22.100]             invokeRestart <- base::invokeRestart
[09:28:22.100]             length <- base::length
[09:28:22.100]             list <- base::list
[09:28:22.100]             seq.int <- base::seq.int
[09:28:22.100]             signalCondition <- base::signalCondition
[09:28:22.100]             sys.calls <- base::sys.calls
[09:28:22.100]             `[[` <- base::`[[`
[09:28:22.100]             `+` <- base::`+`
[09:28:22.100]             `<<-` <- base::`<<-`
[09:28:22.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.100]                   3L)]
[09:28:22.100]             }
[09:28:22.100]             function(cond) {
[09:28:22.100]                 is_error <- inherits(cond, "error")
[09:28:22.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.100]                   NULL)
[09:28:22.100]                 if (is_error) {
[09:28:22.100]                   sessionInformation <- function() {
[09:28:22.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.100]                       search = base::search(), system = base::Sys.info())
[09:28:22.100]                   }
[09:28:22.100]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.100]                     cond$call), session = sessionInformation(), 
[09:28:22.100]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.100]                   signalCondition(cond)
[09:28:22.100]                 }
[09:28:22.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.100]                 "immediateCondition"))) {
[09:28:22.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.100]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.100]                   if (TRUE && !signal) {
[09:28:22.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.100]                     {
[09:28:22.100]                       inherits <- base::inherits
[09:28:22.100]                       invokeRestart <- base::invokeRestart
[09:28:22.100]                       is.null <- base::is.null
[09:28:22.100]                       muffled <- FALSE
[09:28:22.100]                       if (inherits(cond, "message")) {
[09:28:22.100]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.100]                         if (muffled) 
[09:28:22.100]                           invokeRestart("muffleMessage")
[09:28:22.100]                       }
[09:28:22.100]                       else if (inherits(cond, "warning")) {
[09:28:22.100]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.100]                         if (muffled) 
[09:28:22.100]                           invokeRestart("muffleWarning")
[09:28:22.100]                       }
[09:28:22.100]                       else if (inherits(cond, "condition")) {
[09:28:22.100]                         if (!is.null(pattern)) {
[09:28:22.100]                           computeRestarts <- base::computeRestarts
[09:28:22.100]                           grepl <- base::grepl
[09:28:22.100]                           restarts <- computeRestarts(cond)
[09:28:22.100]                           for (restart in restarts) {
[09:28:22.100]                             name <- restart$name
[09:28:22.100]                             if (is.null(name)) 
[09:28:22.100]                               next
[09:28:22.100]                             if (!grepl(pattern, name)) 
[09:28:22.100]                               next
[09:28:22.100]                             invokeRestart(restart)
[09:28:22.100]                             muffled <- TRUE
[09:28:22.100]                             break
[09:28:22.100]                           }
[09:28:22.100]                         }
[09:28:22.100]                       }
[09:28:22.100]                       invisible(muffled)
[09:28:22.100]                     }
[09:28:22.100]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.100]                   }
[09:28:22.100]                 }
[09:28:22.100]                 else {
[09:28:22.100]                   if (TRUE) {
[09:28:22.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.100]                     {
[09:28:22.100]                       inherits <- base::inherits
[09:28:22.100]                       invokeRestart <- base::invokeRestart
[09:28:22.100]                       is.null <- base::is.null
[09:28:22.100]                       muffled <- FALSE
[09:28:22.100]                       if (inherits(cond, "message")) {
[09:28:22.100]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.100]                         if (muffled) 
[09:28:22.100]                           invokeRestart("muffleMessage")
[09:28:22.100]                       }
[09:28:22.100]                       else if (inherits(cond, "warning")) {
[09:28:22.100]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.100]                         if (muffled) 
[09:28:22.100]                           invokeRestart("muffleWarning")
[09:28:22.100]                       }
[09:28:22.100]                       else if (inherits(cond, "condition")) {
[09:28:22.100]                         if (!is.null(pattern)) {
[09:28:22.100]                           computeRestarts <- base::computeRestarts
[09:28:22.100]                           grepl <- base::grepl
[09:28:22.100]                           restarts <- computeRestarts(cond)
[09:28:22.100]                           for (restart in restarts) {
[09:28:22.100]                             name <- restart$name
[09:28:22.100]                             if (is.null(name)) 
[09:28:22.100]                               next
[09:28:22.100]                             if (!grepl(pattern, name)) 
[09:28:22.100]                               next
[09:28:22.100]                             invokeRestart(restart)
[09:28:22.100]                             muffled <- TRUE
[09:28:22.100]                             break
[09:28:22.100]                           }
[09:28:22.100]                         }
[09:28:22.100]                       }
[09:28:22.100]                       invisible(muffled)
[09:28:22.100]                     }
[09:28:22.100]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.100]                   }
[09:28:22.100]                 }
[09:28:22.100]             }
[09:28:22.100]         }))
[09:28:22.100]     }, error = function(ex) {
[09:28:22.100]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.100]                 ...future.rng), started = ...future.startTime, 
[09:28:22.100]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.100]             version = "1.8"), class = "FutureResult")
[09:28:22.100]     }, finally = {
[09:28:22.100]         if (!identical(...future.workdir, getwd())) 
[09:28:22.100]             setwd(...future.workdir)
[09:28:22.100]         {
[09:28:22.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.100]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.100]             }
[09:28:22.100]             base::options(...future.oldOptions)
[09:28:22.100]             if (.Platform$OS.type == "windows") {
[09:28:22.100]                 old_names <- names(...future.oldEnvVars)
[09:28:22.100]                 envs <- base::Sys.getenv()
[09:28:22.100]                 names <- names(envs)
[09:28:22.100]                 common <- intersect(names, old_names)
[09:28:22.100]                 added <- setdiff(names, old_names)
[09:28:22.100]                 removed <- setdiff(old_names, names)
[09:28:22.100]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.100]                   envs[common]]
[09:28:22.100]                 NAMES <- toupper(changed)
[09:28:22.100]                 args <- list()
[09:28:22.100]                 for (kk in seq_along(NAMES)) {
[09:28:22.100]                   name <- changed[[kk]]
[09:28:22.100]                   NAME <- NAMES[[kk]]
[09:28:22.100]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.100]                     next
[09:28:22.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.100]                 }
[09:28:22.100]                 NAMES <- toupper(added)
[09:28:22.100]                 for (kk in seq_along(NAMES)) {
[09:28:22.100]                   name <- added[[kk]]
[09:28:22.100]                   NAME <- NAMES[[kk]]
[09:28:22.100]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.100]                     next
[09:28:22.100]                   args[[name]] <- ""
[09:28:22.100]                 }
[09:28:22.100]                 NAMES <- toupper(removed)
[09:28:22.100]                 for (kk in seq_along(NAMES)) {
[09:28:22.100]                   name <- removed[[kk]]
[09:28:22.100]                   NAME <- NAMES[[kk]]
[09:28:22.100]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.100]                     next
[09:28:22.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.100]                 }
[09:28:22.100]                 if (length(args) > 0) 
[09:28:22.100]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.100]             }
[09:28:22.100]             else {
[09:28:22.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.100]             }
[09:28:22.100]             {
[09:28:22.100]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.100]                   0L) {
[09:28:22.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.100]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.100]                   base::options(opts)
[09:28:22.100]                 }
[09:28:22.100]                 {
[09:28:22.100]                   {
[09:28:22.100]                     NULL
[09:28:22.100]                     RNGkind("Mersenne-Twister")
[09:28:22.100]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.100]                       inherits = FALSE)
[09:28:22.100]                   }
[09:28:22.100]                   options(future.plan = NULL)
[09:28:22.100]                   if (is.na(NA_character_)) 
[09:28:22.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.100]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.100]                     .init = FALSE)
[09:28:22.100]                 }
[09:28:22.100]             }
[09:28:22.100]         }
[09:28:22.100]     })
[09:28:22.100]     if (TRUE) {
[09:28:22.100]         base::sink(type = "output", split = FALSE)
[09:28:22.100]         if (TRUE) {
[09:28:22.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.100]         }
[09:28:22.100]         else {
[09:28:22.100]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.100]         }
[09:28:22.100]         base::close(...future.stdout)
[09:28:22.100]         ...future.stdout <- NULL
[09:28:22.100]     }
[09:28:22.100]     ...future.result$conditions <- ...future.conditions
[09:28:22.100]     ...future.result$finished <- base::Sys.time()
[09:28:22.100]     ...future.result
[09:28:22.100] }
[09:28:22.102] assign_globals() ...
[09:28:22.102] List of 5
[09:28:22.102]  $ ...future.FUN            :function (object, ...)  
[09:28:22.102]  $ future.call.arguments    : list()
[09:28:22.102]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.102]  $ ...future.elements_ii    :List of 3
[09:28:22.102]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.102]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.102]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.102]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.102]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.102]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.102]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.102]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.102]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.102]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.102]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.102]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.102]  $ ...future.seeds_ii       : NULL
[09:28:22.102]  $ ...future.globals.maxSize: NULL
[09:28:22.102]  - attr(*, "where")=List of 5
[09:28:22.102]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.102]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.102]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.102]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.102]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.102]  - attr(*, "resolved")= logi FALSE
[09:28:22.102]  - attr(*, "total_size")= num 1240
[09:28:22.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.102]  - attr(*, "already-done")= logi TRUE
[09:28:22.111] - copied ‘...future.FUN’ to environment
[09:28:22.111] - copied ‘future.call.arguments’ to environment
[09:28:22.111] - copied ‘...future.elements_ii’ to environment
[09:28:22.111] - copied ‘...future.seeds_ii’ to environment
[09:28:22.111] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.111] assign_globals() ... done
[09:28:22.112] plan(): Setting new future strategy stack:
[09:28:22.112] List of future strategies:
[09:28:22.112] 1. sequential:
[09:28:22.112]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.112]    - tweaked: FALSE
[09:28:22.112]    - call: NULL
[09:28:22.112] plan(): nbrOfWorkers() = 1
[09:28:22.114] plan(): Setting new future strategy stack:
[09:28:22.114] List of future strategies:
[09:28:22.114] 1. sequential:
[09:28:22.114]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.114]    - tweaked: FALSE
[09:28:22.114]    - call: plan(strategy)
[09:28:22.115] plan(): nbrOfWorkers() = 1
[09:28:22.115] SequentialFuture started (and completed)
[09:28:22.115] - Launch lazy future ... done
[09:28:22.115] run() for ‘SequentialFuture’ ... done
[09:28:22.115] Created future:
[09:28:22.115] SequentialFuture:
[09:28:22.115] Label: ‘future_by-1’
[09:28:22.115] Expression:
[09:28:22.115] {
[09:28:22.115]     do.call(function(...) {
[09:28:22.115]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.115]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.115]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.115]             on.exit(options(oopts), add = TRUE)
[09:28:22.115]         }
[09:28:22.115]         {
[09:28:22.115]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.115]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.115]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.115]             })
[09:28:22.115]         }
[09:28:22.115]     }, args = future.call.arguments)
[09:28:22.115] }
[09:28:22.115] Lazy evaluation: FALSE
[09:28:22.115] Asynchronous evaluation: FALSE
[09:28:22.115] Local evaluation: TRUE
[09:28:22.115] Environment: 0x555b0a7c1088
[09:28:22.115] Capture standard output: TRUE
[09:28:22.115] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.115] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.115] Packages: <none>
[09:28:22.115] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.115] Resolved: TRUE
[09:28:22.115] Value: 5.37 KiB of class ‘list’
[09:28:22.115] Early signaling: FALSE
[09:28:22.115] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.115] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.116] Chunk #1 of 1 ... DONE
[09:28:22.116] Launching 1 futures (chunks) ... DONE
[09:28:22.117] Resolving 1 futures (chunks) ...
[09:28:22.117] resolve() on list ...
[09:28:22.117]  recursive: 0
[09:28:22.117]  length: 1
[09:28:22.117] 
[09:28:22.117] resolved() for ‘SequentialFuture’ ...
[09:28:22.117] - state: ‘finished’
[09:28:22.117] - run: TRUE
[09:28:22.117] - result: ‘FutureResult’
[09:28:22.117] resolved() for ‘SequentialFuture’ ... done
[09:28:22.117] Future #1
[09:28:22.118] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.118] - nx: 1
[09:28:22.118] - relay: TRUE
[09:28:22.118] - stdout: TRUE
[09:28:22.118] - signal: TRUE
[09:28:22.118] - resignal: FALSE
[09:28:22.118] - force: TRUE
[09:28:22.118] - relayed: [n=1] FALSE
[09:28:22.118] - queued futures: [n=1] FALSE
[09:28:22.118]  - until=1
[09:28:22.118]  - relaying element #1
[09:28:22.119] - relayed: [n=1] TRUE
[09:28:22.119] - queued futures: [n=1] TRUE
[09:28:22.119] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.119]  length: 0 (resolved future 1)
[09:28:22.119] Relaying remaining futures
[09:28:22.119] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.119] - nx: 1
[09:28:22.119] - relay: TRUE
[09:28:22.119] - stdout: TRUE
[09:28:22.119] - signal: TRUE
[09:28:22.119] - resignal: FALSE
[09:28:22.119] - force: TRUE
[09:28:22.119] - relayed: [n=1] TRUE
[09:28:22.120] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.120] - relayed: [n=1] TRUE
[09:28:22.120] - queued futures: [n=1] TRUE
[09:28:22.120] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.120] resolve() on list ... DONE
[09:28:22.120]  - Number of value chunks collected: 1
[09:28:22.120] Resolving 1 futures (chunks) ... DONE
[09:28:22.120] Reducing values from 1 chunks ...
[09:28:22.120]  - Number of values collected after concatenation: 3
[09:28:22.120]  - Number of values expected: 3
[09:28:22.120] Reducing values from 1 chunks ... DONE
[09:28:22.121] future_lapply() ... DONE
[09:28:22.121] future_by_internal() ... DONE
[09:28:22.122] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[09:28:22.123] future_lapply() ...
[09:28:22.123] Number of chunks: 1
[09:28:22.123] getGlobalsAndPackagesXApply() ...
[09:28:22.124]  - future.globals: TRUE
[09:28:22.124] getGlobalsAndPackages() ...
[09:28:22.124] Searching for globals...
[09:28:22.125] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.125] Searching for globals ... DONE
[09:28:22.125] Resolving globals: FALSE
[09:28:22.125] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.125] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.126] - globals: [1] ‘FUN’
[09:28:22.126] 
[09:28:22.126] getGlobalsAndPackages() ... DONE
[09:28:22.126]  - globals found/used: [n=1] ‘FUN’
[09:28:22.126]  - needed namespaces: [n=0] 
[09:28:22.126] Finding globals ... DONE
[09:28:22.126]  - use_args: TRUE
[09:28:22.126]  - Getting '...' globals ...
[09:28:22.127] resolve() on list ...
[09:28:22.127]  recursive: 0
[09:28:22.127]  length: 1
[09:28:22.128]  elements: ‘...’
[09:28:22.128]  length: 0 (resolved future 1)
[09:28:22.128] resolve() on list ... DONE
[09:28:22.128]    - '...' content: [n=0] 
[09:28:22.128] List of 1
[09:28:22.128]  $ ...: list()
[09:28:22.128]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.128]  - attr(*, "where")=List of 1
[09:28:22.128]   ..$ ...:<environment: 0x555b0a785e68> 
[09:28:22.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.128]  - attr(*, "resolved")= logi TRUE
[09:28:22.128]  - attr(*, "total_size")= num NA
[09:28:22.130]  - Getting '...' globals ... DONE
[09:28:22.130] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.131] List of 2
[09:28:22.131]  $ ...future.FUN:function (object, ...)  
[09:28:22.131]  $ ...          : list()
[09:28:22.131]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.131]  - attr(*, "where")=List of 2
[09:28:22.131]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.131]   ..$ ...          :<environment: 0x555b0a785e68> 
[09:28:22.131]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.131]  - attr(*, "resolved")= logi FALSE
[09:28:22.131]  - attr(*, "total_size")= num 1240
[09:28:22.133] Packages to be attached in all futures: [n=0] 
[09:28:22.133] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.133] Number of futures (= number of chunks): 1
[09:28:22.133] Launching 1 futures (chunks) ...
[09:28:22.133] Chunk #1 of 1 ...
[09:28:22.134]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.134] getGlobalsAndPackages() ...
[09:28:22.134] Searching for globals...
[09:28:22.134] 
[09:28:22.134] Searching for globals ... DONE
[09:28:22.134] - globals: [0] <none>
[09:28:22.134] getGlobalsAndPackages() ... DONE
[09:28:22.134]    + additional globals found: [n=0] 
[09:28:22.135]    + additional namespaces needed: [n=0] 
[09:28:22.135]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.135]  - seeds: <none>
[09:28:22.135]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.135] getGlobalsAndPackages() ...
[09:28:22.135] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.135] Resolving globals: FALSE
[09:28:22.135] Tweak future expression to call with '...' arguments ...
[09:28:22.135] {
[09:28:22.135]     do.call(function(...) {
[09:28:22.135]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.135]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.135]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.135]             on.exit(options(oopts), add = TRUE)
[09:28:22.135]         }
[09:28:22.135]         {
[09:28:22.135]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.135]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.135]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.135]             })
[09:28:22.135]         }
[09:28:22.135]     }, args = future.call.arguments)
[09:28:22.135] }
[09:28:22.135] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.136] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.136] 
[09:28:22.136] getGlobalsAndPackages() ... DONE
[09:28:22.136] run() for ‘Future’ ...
[09:28:22.136] - state: ‘created’
[09:28:22.136] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:22.137] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.137]   - Field: ‘label’
[09:28:22.137]   - Field: ‘local’
[09:28:22.137]   - Field: ‘owner’
[09:28:22.137]   - Field: ‘envir’
[09:28:22.137]   - Field: ‘packages’
[09:28:22.137]   - Field: ‘gc’
[09:28:22.137]   - Field: ‘conditions’
[09:28:22.138]   - Field: ‘expr’
[09:28:22.138]   - Field: ‘uuid’
[09:28:22.138]   - Field: ‘seed’
[09:28:22.138]   - Field: ‘version’
[09:28:22.138]   - Field: ‘result’
[09:28:22.138]   - Field: ‘asynchronous’
[09:28:22.138]   - Field: ‘calls’
[09:28:22.138]   - Field: ‘globals’
[09:28:22.138]   - Field: ‘stdout’
[09:28:22.138]   - Field: ‘earlySignal’
[09:28:22.138]   - Field: ‘lazy’
[09:28:22.138]   - Field: ‘state’
[09:28:22.139] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.139] - Launch lazy future ...
[09:28:22.139] Packages needed by the future expression (n = 0): <none>
[09:28:22.139] Packages needed by future strategies (n = 0): <none>
[09:28:22.139] {
[09:28:22.139]     {
[09:28:22.139]         {
[09:28:22.139]             ...future.startTime <- base::Sys.time()
[09:28:22.139]             {
[09:28:22.139]                 {
[09:28:22.139]                   {
[09:28:22.139]                     base::local({
[09:28:22.139]                       has_future <- base::requireNamespace("future", 
[09:28:22.139]                         quietly = TRUE)
[09:28:22.139]                       if (has_future) {
[09:28:22.139]                         ns <- base::getNamespace("future")
[09:28:22.139]                         version <- ns[[".package"]][["version"]]
[09:28:22.139]                         if (is.null(version)) 
[09:28:22.139]                           version <- utils::packageVersion("future")
[09:28:22.139]                       }
[09:28:22.139]                       else {
[09:28:22.139]                         version <- NULL
[09:28:22.139]                       }
[09:28:22.139]                       if (!has_future || version < "1.8.0") {
[09:28:22.139]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.139]                           "", base::R.version$version.string), 
[09:28:22.139]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.139]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.139]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.139]                             "release", "version")], collapse = " "), 
[09:28:22.139]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.139]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.139]                           info)
[09:28:22.139]                         info <- base::paste(info, collapse = "; ")
[09:28:22.139]                         if (!has_future) {
[09:28:22.139]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.139]                             info)
[09:28:22.139]                         }
[09:28:22.139]                         else {
[09:28:22.139]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.139]                             info, version)
[09:28:22.139]                         }
[09:28:22.139]                         base::stop(msg)
[09:28:22.139]                       }
[09:28:22.139]                     })
[09:28:22.139]                   }
[09:28:22.139]                   ...future.strategy.old <- future::plan("list")
[09:28:22.139]                   options(future.plan = NULL)
[09:28:22.139]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.139]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.139]                 }
[09:28:22.139]                 ...future.workdir <- getwd()
[09:28:22.139]             }
[09:28:22.139]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.139]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.139]         }
[09:28:22.139]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.139]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.139]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.139]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.139]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.139]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.139]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.139]             base::names(...future.oldOptions))
[09:28:22.139]     }
[09:28:22.139]     if (FALSE) {
[09:28:22.139]     }
[09:28:22.139]     else {
[09:28:22.139]         if (TRUE) {
[09:28:22.139]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.139]                 open = "w")
[09:28:22.139]         }
[09:28:22.139]         else {
[09:28:22.139]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.139]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.139]         }
[09:28:22.139]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.139]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.139]             base::sink(type = "output", split = FALSE)
[09:28:22.139]             base::close(...future.stdout)
[09:28:22.139]         }, add = TRUE)
[09:28:22.139]     }
[09:28:22.139]     ...future.frame <- base::sys.nframe()
[09:28:22.139]     ...future.conditions <- base::list()
[09:28:22.139]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.139]     if (FALSE) {
[09:28:22.139]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.139]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.139]     }
[09:28:22.139]     ...future.result <- base::tryCatch({
[09:28:22.139]         base::withCallingHandlers({
[09:28:22.139]             ...future.value <- base::withVisible(base::local({
[09:28:22.139]                 do.call(function(...) {
[09:28:22.139]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.139]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.139]                     ...future.globals.maxSize)) {
[09:28:22.139]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.139]                     on.exit(options(oopts), add = TRUE)
[09:28:22.139]                   }
[09:28:22.139]                   {
[09:28:22.139]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.139]                       FUN = function(jj) {
[09:28:22.139]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.139]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.139]                       })
[09:28:22.139]                   }
[09:28:22.139]                 }, args = future.call.arguments)
[09:28:22.139]             }))
[09:28:22.139]             future::FutureResult(value = ...future.value$value, 
[09:28:22.139]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.139]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.139]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.139]                     ...future.globalenv.names))
[09:28:22.139]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.139]         }, condition = base::local({
[09:28:22.139]             c <- base::c
[09:28:22.139]             inherits <- base::inherits
[09:28:22.139]             invokeRestart <- base::invokeRestart
[09:28:22.139]             length <- base::length
[09:28:22.139]             list <- base::list
[09:28:22.139]             seq.int <- base::seq.int
[09:28:22.139]             signalCondition <- base::signalCondition
[09:28:22.139]             sys.calls <- base::sys.calls
[09:28:22.139]             `[[` <- base::`[[`
[09:28:22.139]             `+` <- base::`+`
[09:28:22.139]             `<<-` <- base::`<<-`
[09:28:22.139]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.139]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.139]                   3L)]
[09:28:22.139]             }
[09:28:22.139]             function(cond) {
[09:28:22.139]                 is_error <- inherits(cond, "error")
[09:28:22.139]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.139]                   NULL)
[09:28:22.139]                 if (is_error) {
[09:28:22.139]                   sessionInformation <- function() {
[09:28:22.139]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.139]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.139]                       search = base::search(), system = base::Sys.info())
[09:28:22.139]                   }
[09:28:22.139]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.139]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.139]                     cond$call), session = sessionInformation(), 
[09:28:22.139]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.139]                   signalCondition(cond)
[09:28:22.139]                 }
[09:28:22.139]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.139]                 "immediateCondition"))) {
[09:28:22.139]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.139]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.139]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.139]                   if (TRUE && !signal) {
[09:28:22.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.139]                     {
[09:28:22.139]                       inherits <- base::inherits
[09:28:22.139]                       invokeRestart <- base::invokeRestart
[09:28:22.139]                       is.null <- base::is.null
[09:28:22.139]                       muffled <- FALSE
[09:28:22.139]                       if (inherits(cond, "message")) {
[09:28:22.139]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.139]                         if (muffled) 
[09:28:22.139]                           invokeRestart("muffleMessage")
[09:28:22.139]                       }
[09:28:22.139]                       else if (inherits(cond, "warning")) {
[09:28:22.139]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.139]                         if (muffled) 
[09:28:22.139]                           invokeRestart("muffleWarning")
[09:28:22.139]                       }
[09:28:22.139]                       else if (inherits(cond, "condition")) {
[09:28:22.139]                         if (!is.null(pattern)) {
[09:28:22.139]                           computeRestarts <- base::computeRestarts
[09:28:22.139]                           grepl <- base::grepl
[09:28:22.139]                           restarts <- computeRestarts(cond)
[09:28:22.139]                           for (restart in restarts) {
[09:28:22.139]                             name <- restart$name
[09:28:22.139]                             if (is.null(name)) 
[09:28:22.139]                               next
[09:28:22.139]                             if (!grepl(pattern, name)) 
[09:28:22.139]                               next
[09:28:22.139]                             invokeRestart(restart)
[09:28:22.139]                             muffled <- TRUE
[09:28:22.139]                             break
[09:28:22.139]                           }
[09:28:22.139]                         }
[09:28:22.139]                       }
[09:28:22.139]                       invisible(muffled)
[09:28:22.139]                     }
[09:28:22.139]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.139]                   }
[09:28:22.139]                 }
[09:28:22.139]                 else {
[09:28:22.139]                   if (TRUE) {
[09:28:22.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.139]                     {
[09:28:22.139]                       inherits <- base::inherits
[09:28:22.139]                       invokeRestart <- base::invokeRestart
[09:28:22.139]                       is.null <- base::is.null
[09:28:22.139]                       muffled <- FALSE
[09:28:22.139]                       if (inherits(cond, "message")) {
[09:28:22.139]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.139]                         if (muffled) 
[09:28:22.139]                           invokeRestart("muffleMessage")
[09:28:22.139]                       }
[09:28:22.139]                       else if (inherits(cond, "warning")) {
[09:28:22.139]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.139]                         if (muffled) 
[09:28:22.139]                           invokeRestart("muffleWarning")
[09:28:22.139]                       }
[09:28:22.139]                       else if (inherits(cond, "condition")) {
[09:28:22.139]                         if (!is.null(pattern)) {
[09:28:22.139]                           computeRestarts <- base::computeRestarts
[09:28:22.139]                           grepl <- base::grepl
[09:28:22.139]                           restarts <- computeRestarts(cond)
[09:28:22.139]                           for (restart in restarts) {
[09:28:22.139]                             name <- restart$name
[09:28:22.139]                             if (is.null(name)) 
[09:28:22.139]                               next
[09:28:22.139]                             if (!grepl(pattern, name)) 
[09:28:22.139]                               next
[09:28:22.139]                             invokeRestart(restart)
[09:28:22.139]                             muffled <- TRUE
[09:28:22.139]                             break
[09:28:22.139]                           }
[09:28:22.139]                         }
[09:28:22.139]                       }
[09:28:22.139]                       invisible(muffled)
[09:28:22.139]                     }
[09:28:22.139]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.139]                   }
[09:28:22.139]                 }
[09:28:22.139]             }
[09:28:22.139]         }))
[09:28:22.139]     }, error = function(ex) {
[09:28:22.139]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.139]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.139]                 ...future.rng), started = ...future.startTime, 
[09:28:22.139]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.139]             version = "1.8"), class = "FutureResult")
[09:28:22.139]     }, finally = {
[09:28:22.139]         if (!identical(...future.workdir, getwd())) 
[09:28:22.139]             setwd(...future.workdir)
[09:28:22.139]         {
[09:28:22.139]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.139]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.139]             }
[09:28:22.139]             base::options(...future.oldOptions)
[09:28:22.139]             if (.Platform$OS.type == "windows") {
[09:28:22.139]                 old_names <- names(...future.oldEnvVars)
[09:28:22.139]                 envs <- base::Sys.getenv()
[09:28:22.139]                 names <- names(envs)
[09:28:22.139]                 common <- intersect(names, old_names)
[09:28:22.139]                 added <- setdiff(names, old_names)
[09:28:22.139]                 removed <- setdiff(old_names, names)
[09:28:22.139]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.139]                   envs[common]]
[09:28:22.139]                 NAMES <- toupper(changed)
[09:28:22.139]                 args <- list()
[09:28:22.139]                 for (kk in seq_along(NAMES)) {
[09:28:22.139]                   name <- changed[[kk]]
[09:28:22.139]                   NAME <- NAMES[[kk]]
[09:28:22.139]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.139]                     next
[09:28:22.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.139]                 }
[09:28:22.139]                 NAMES <- toupper(added)
[09:28:22.139]                 for (kk in seq_along(NAMES)) {
[09:28:22.139]                   name <- added[[kk]]
[09:28:22.139]                   NAME <- NAMES[[kk]]
[09:28:22.139]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.139]                     next
[09:28:22.139]                   args[[name]] <- ""
[09:28:22.139]                 }
[09:28:22.139]                 NAMES <- toupper(removed)
[09:28:22.139]                 for (kk in seq_along(NAMES)) {
[09:28:22.139]                   name <- removed[[kk]]
[09:28:22.139]                   NAME <- NAMES[[kk]]
[09:28:22.139]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.139]                     next
[09:28:22.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.139]                 }
[09:28:22.139]                 if (length(args) > 0) 
[09:28:22.139]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.139]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.139]             }
[09:28:22.139]             else {
[09:28:22.139]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.139]             }
[09:28:22.139]             {
[09:28:22.139]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.139]                   0L) {
[09:28:22.139]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.139]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.139]                   base::options(opts)
[09:28:22.139]                 }
[09:28:22.139]                 {
[09:28:22.139]                   {
[09:28:22.139]                     NULL
[09:28:22.139]                     RNGkind("Mersenne-Twister")
[09:28:22.139]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.139]                       inherits = FALSE)
[09:28:22.139]                   }
[09:28:22.139]                   options(future.plan = NULL)
[09:28:22.139]                   if (is.na(NA_character_)) 
[09:28:22.139]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.139]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.139]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.139]                     .init = FALSE)
[09:28:22.139]                 }
[09:28:22.139]             }
[09:28:22.139]         }
[09:28:22.139]     })
[09:28:22.139]     if (TRUE) {
[09:28:22.139]         base::sink(type = "output", split = FALSE)
[09:28:22.139]         if (TRUE) {
[09:28:22.139]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.139]         }
[09:28:22.139]         else {
[09:28:22.139]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.139]         }
[09:28:22.139]         base::close(...future.stdout)
[09:28:22.139]         ...future.stdout <- NULL
[09:28:22.139]     }
[09:28:22.139]     ...future.result$conditions <- ...future.conditions
[09:28:22.139]     ...future.result$finished <- base::Sys.time()
[09:28:22.139]     ...future.result
[09:28:22.139] }
[09:28:22.141] assign_globals() ...
[09:28:22.141] List of 5
[09:28:22.141]  $ ...future.FUN            :function (object, ...)  
[09:28:22.141]  $ future.call.arguments    : list()
[09:28:22.141]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.141]  $ ...future.elements_ii    :List of 3
[09:28:22.141]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.141]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.141]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.141]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.141]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.141]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.141]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.141]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.141]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.141]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.141]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.141]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.141]  $ ...future.seeds_ii       : NULL
[09:28:22.141]  $ ...future.globals.maxSize: NULL
[09:28:22.141]  - attr(*, "where")=List of 5
[09:28:22.141]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.141]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.141]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.141]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.141]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.141]  - attr(*, "resolved")= logi FALSE
[09:28:22.141]  - attr(*, "total_size")= num 1240
[09:28:22.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.141]  - attr(*, "already-done")= logi TRUE
[09:28:22.150] - copied ‘...future.FUN’ to environment
[09:28:22.150] - copied ‘future.call.arguments’ to environment
[09:28:22.150] - copied ‘...future.elements_ii’ to environment
[09:28:22.150] - copied ‘...future.seeds_ii’ to environment
[09:28:22.150] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.150] assign_globals() ... done
[09:28:22.150] plan(): Setting new future strategy stack:
[09:28:22.150] List of future strategies:
[09:28:22.150] 1. sequential:
[09:28:22.150]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.150]    - tweaked: FALSE
[09:28:22.150]    - call: NULL
[09:28:22.151] plan(): nbrOfWorkers() = 1
[09:28:22.153] plan(): Setting new future strategy stack:
[09:28:22.153] List of future strategies:
[09:28:22.153] 1. sequential:
[09:28:22.153]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.153]    - tweaked: FALSE
[09:28:22.153]    - call: plan(strategy)
[09:28:22.153] plan(): nbrOfWorkers() = 1
[09:28:22.153] SequentialFuture started (and completed)
[09:28:22.153] - Launch lazy future ... done
[09:28:22.154] run() for ‘SequentialFuture’ ... done
[09:28:22.154] Created future:
[09:28:22.154] SequentialFuture:
[09:28:22.154] Label: ‘future_by-1’
[09:28:22.154] Expression:
[09:28:22.154] {
[09:28:22.154]     do.call(function(...) {
[09:28:22.154]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.154]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.154]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.154]             on.exit(options(oopts), add = TRUE)
[09:28:22.154]         }
[09:28:22.154]         {
[09:28:22.154]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.154]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.154]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.154]             })
[09:28:22.154]         }
[09:28:22.154]     }, args = future.call.arguments)
[09:28:22.154] }
[09:28:22.154] Lazy evaluation: FALSE
[09:28:22.154] Asynchronous evaluation: FALSE
[09:28:22.154] Local evaluation: TRUE
[09:28:22.154] Environment: 0x555b0a62fb00
[09:28:22.154] Capture standard output: TRUE
[09:28:22.154] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.154] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.154] Packages: <none>
[09:28:22.154] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.154] Resolved: TRUE
[09:28:22.154] Value: 5.37 KiB of class ‘list’
[09:28:22.154] Early signaling: FALSE
[09:28:22.154] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.154] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.155] Chunk #1 of 1 ... DONE
[09:28:22.155] Launching 1 futures (chunks) ... DONE
[09:28:22.155] Resolving 1 futures (chunks) ...
[09:28:22.155] resolve() on list ...
[09:28:22.155]  recursive: 0
[09:28:22.155]  length: 1
[09:28:22.155] 
[09:28:22.155] resolved() for ‘SequentialFuture’ ...
[09:28:22.156] - state: ‘finished’
[09:28:22.156] - run: TRUE
[09:28:22.156] - result: ‘FutureResult’
[09:28:22.156] resolved() for ‘SequentialFuture’ ... done
[09:28:22.156] Future #1
[09:28:22.156] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.156] - nx: 1
[09:28:22.156] - relay: TRUE
[09:28:22.156] - stdout: TRUE
[09:28:22.156] - signal: TRUE
[09:28:22.156] - resignal: FALSE
[09:28:22.156] - force: TRUE
[09:28:22.157] - relayed: [n=1] FALSE
[09:28:22.157] - queued futures: [n=1] FALSE
[09:28:22.157]  - until=1
[09:28:22.157]  - relaying element #1
[09:28:22.157] - relayed: [n=1] TRUE
[09:28:22.157] - queued futures: [n=1] TRUE
[09:28:22.157] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.157]  length: 0 (resolved future 1)
[09:28:22.157] Relaying remaining futures
[09:28:22.157] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.157] - nx: 1
[09:28:22.158] - relay: TRUE
[09:28:22.158] - stdout: TRUE
[09:28:22.158] - signal: TRUE
[09:28:22.158] - resignal: FALSE
[09:28:22.158] - force: TRUE
[09:28:22.158] - relayed: [n=1] TRUE
[09:28:22.158] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.158] - relayed: [n=1] TRUE
[09:28:22.158] - queued futures: [n=1] TRUE
[09:28:22.158] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.158] resolve() on list ... DONE
[09:28:22.159]  - Number of value chunks collected: 1
[09:28:22.159] Resolving 1 futures (chunks) ... DONE
[09:28:22.159] Reducing values from 1 chunks ...
[09:28:22.159]  - Number of values collected after concatenation: 3
[09:28:22.159]  - Number of values expected: 3
[09:28:22.159] Reducing values from 1 chunks ... DONE
[09:28:22.159] future_lapply() ... DONE
[09:28:22.159] future_by_internal() ... DONE
[09:28:22.160] future_by_internal() ...
- plan('multicore') ...
[09:28:22.160] plan(): Setting new future strategy stack:
[09:28:22.160] List of future strategies:
[09:28:22.160] 1. multicore:
[09:28:22.160]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:22.160]    - tweaked: FALSE
[09:28:22.160]    - call: plan(strategy)
[09:28:22.164] plan(): nbrOfWorkers() = 1
[09:28:22.164] future_by_internal() ...
[09:28:22.165] future_lapply() ...
[09:28:22.168] Number of chunks: 1
[09:28:22.168] getGlobalsAndPackagesXApply() ...
[09:28:22.168]  - future.globals: TRUE
[09:28:22.168] getGlobalsAndPackages() ...
[09:28:22.169] Searching for globals...
[09:28:22.169] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.170] Searching for globals ... DONE
[09:28:22.170] Resolving globals: FALSE
[09:28:22.171] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.171] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.171] - globals: [1] ‘FUN’
[09:28:22.171] 
[09:28:22.172] getGlobalsAndPackages() ... DONE
[09:28:22.172]  - globals found/used: [n=1] ‘FUN’
[09:28:22.172]  - needed namespaces: [n=0] 
[09:28:22.172] Finding globals ... DONE
[09:28:22.172]  - use_args: TRUE
[09:28:22.172]  - Getting '...' globals ...
[09:28:22.172] resolve() on list ...
[09:28:22.172]  recursive: 0
[09:28:22.172]  length: 1
[09:28:22.173]  elements: ‘...’
[09:28:22.173]  length: 0 (resolved future 1)
[09:28:22.173] resolve() on list ... DONE
[09:28:22.173]    - '...' content: [n=0] 
[09:28:22.173] List of 1
[09:28:22.173]  $ ...: list()
[09:28:22.173]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.173]  - attr(*, "where")=List of 1
[09:28:22.173]   ..$ ...:<environment: 0x555b0a79f378> 
[09:28:22.173]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.173]  - attr(*, "resolved")= logi TRUE
[09:28:22.173]  - attr(*, "total_size")= num NA
[09:28:22.175]  - Getting '...' globals ... DONE
[09:28:22.175] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.175] List of 2
[09:28:22.175]  $ ...future.FUN:function (object, ...)  
[09:28:22.175]  $ ...          : list()
[09:28:22.175]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.175]  - attr(*, "where")=List of 2
[09:28:22.175]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.175]   ..$ ...          :<environment: 0x555b0a79f378> 
[09:28:22.175]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.175]  - attr(*, "resolved")= logi FALSE
[09:28:22.175]  - attr(*, "total_size")= num 1240
[09:28:22.178] Packages to be attached in all futures: [n=0] 
[09:28:22.178] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.178] Number of futures (= number of chunks): 1
[09:28:22.178] Launching 1 futures (chunks) ...
[09:28:22.178] Chunk #1 of 1 ...
[09:28:22.178]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.179] getGlobalsAndPackages() ...
[09:28:22.179] Searching for globals...
[09:28:22.179] 
[09:28:22.179] Searching for globals ... DONE
[09:28:22.179] - globals: [0] <none>
[09:28:22.179] getGlobalsAndPackages() ... DONE
[09:28:22.179]    + additional globals found: [n=0] 
[09:28:22.180]    + additional namespaces needed: [n=0] 
[09:28:22.180]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.180]  - seeds: <none>
[09:28:22.180]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.180] getGlobalsAndPackages() ...
[09:28:22.180] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.180] Resolving globals: FALSE
[09:28:22.180] Tweak future expression to call with '...' arguments ...
[09:28:22.180] {
[09:28:22.180]     do.call(function(...) {
[09:28:22.180]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.180]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.180]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.180]             on.exit(options(oopts), add = TRUE)
[09:28:22.180]         }
[09:28:22.180]         {
[09:28:22.180]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.180]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.180]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.180]             })
[09:28:22.180]         }
[09:28:22.180]     }, args = future.call.arguments)
[09:28:22.180] }
[09:28:22.181] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.181] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.181] 
[09:28:22.181] getGlobalsAndPackages() ... DONE
[09:28:22.181] run() for ‘Future’ ...
[09:28:22.181] - state: ‘created’
[09:28:22.181] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.185] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.185] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.185]   - Field: ‘label’
[09:28:22.185]   - Field: ‘local’
[09:28:22.185]   - Field: ‘owner’
[09:28:22.185]   - Field: ‘envir’
[09:28:22.185]   - Field: ‘packages’
[09:28:22.185]   - Field: ‘gc’
[09:28:22.186]   - Field: ‘conditions’
[09:28:22.186]   - Field: ‘expr’
[09:28:22.186]   - Field: ‘uuid’
[09:28:22.186]   - Field: ‘seed’
[09:28:22.186]   - Field: ‘version’
[09:28:22.186]   - Field: ‘result’
[09:28:22.186]   - Field: ‘asynchronous’
[09:28:22.186]   - Field: ‘calls’
[09:28:22.186]   - Field: ‘globals’
[09:28:22.186]   - Field: ‘stdout’
[09:28:22.186]   - Field: ‘earlySignal’
[09:28:22.186]   - Field: ‘lazy’
[09:28:22.187]   - Field: ‘state’
[09:28:22.187] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.187] - Launch lazy future ...
[09:28:22.187] Packages needed by the future expression (n = 0): <none>
[09:28:22.187] Packages needed by future strategies (n = 0): <none>
[09:28:22.187] {
[09:28:22.187]     {
[09:28:22.187]         {
[09:28:22.187]             ...future.startTime <- base::Sys.time()
[09:28:22.187]             {
[09:28:22.187]                 {
[09:28:22.187]                   {
[09:28:22.187]                     base::local({
[09:28:22.187]                       has_future <- base::requireNamespace("future", 
[09:28:22.187]                         quietly = TRUE)
[09:28:22.187]                       if (has_future) {
[09:28:22.187]                         ns <- base::getNamespace("future")
[09:28:22.187]                         version <- ns[[".package"]][["version"]]
[09:28:22.187]                         if (is.null(version)) 
[09:28:22.187]                           version <- utils::packageVersion("future")
[09:28:22.187]                       }
[09:28:22.187]                       else {
[09:28:22.187]                         version <- NULL
[09:28:22.187]                       }
[09:28:22.187]                       if (!has_future || version < "1.8.0") {
[09:28:22.187]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.187]                           "", base::R.version$version.string), 
[09:28:22.187]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.187]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.187]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.187]                             "release", "version")], collapse = " "), 
[09:28:22.187]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.187]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.187]                           info)
[09:28:22.187]                         info <- base::paste(info, collapse = "; ")
[09:28:22.187]                         if (!has_future) {
[09:28:22.187]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.187]                             info)
[09:28:22.187]                         }
[09:28:22.187]                         else {
[09:28:22.187]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.187]                             info, version)
[09:28:22.187]                         }
[09:28:22.187]                         base::stop(msg)
[09:28:22.187]                       }
[09:28:22.187]                     })
[09:28:22.187]                   }
[09:28:22.187]                   ...future.strategy.old <- future::plan("list")
[09:28:22.187]                   options(future.plan = NULL)
[09:28:22.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.187]                 }
[09:28:22.187]                 ...future.workdir <- getwd()
[09:28:22.187]             }
[09:28:22.187]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.187]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.187]         }
[09:28:22.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.187]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.187]             base::names(...future.oldOptions))
[09:28:22.187]     }
[09:28:22.187]     if (FALSE) {
[09:28:22.187]     }
[09:28:22.187]     else {
[09:28:22.187]         if (TRUE) {
[09:28:22.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.187]                 open = "w")
[09:28:22.187]         }
[09:28:22.187]         else {
[09:28:22.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.187]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.187]         }
[09:28:22.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.187]             base::sink(type = "output", split = FALSE)
[09:28:22.187]             base::close(...future.stdout)
[09:28:22.187]         }, add = TRUE)
[09:28:22.187]     }
[09:28:22.187]     ...future.frame <- base::sys.nframe()
[09:28:22.187]     ...future.conditions <- base::list()
[09:28:22.187]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.187]     if (FALSE) {
[09:28:22.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.187]     }
[09:28:22.187]     ...future.result <- base::tryCatch({
[09:28:22.187]         base::withCallingHandlers({
[09:28:22.187]             ...future.value <- base::withVisible(base::local({
[09:28:22.187]                 do.call(function(...) {
[09:28:22.187]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.187]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.187]                     ...future.globals.maxSize)) {
[09:28:22.187]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.187]                     on.exit(options(oopts), add = TRUE)
[09:28:22.187]                   }
[09:28:22.187]                   {
[09:28:22.187]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.187]                       FUN = function(jj) {
[09:28:22.187]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.187]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.187]                       })
[09:28:22.187]                   }
[09:28:22.187]                 }, args = future.call.arguments)
[09:28:22.187]             }))
[09:28:22.187]             future::FutureResult(value = ...future.value$value, 
[09:28:22.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.187]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.187]                     ...future.globalenv.names))
[09:28:22.187]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.187]         }, condition = base::local({
[09:28:22.187]             c <- base::c
[09:28:22.187]             inherits <- base::inherits
[09:28:22.187]             invokeRestart <- base::invokeRestart
[09:28:22.187]             length <- base::length
[09:28:22.187]             list <- base::list
[09:28:22.187]             seq.int <- base::seq.int
[09:28:22.187]             signalCondition <- base::signalCondition
[09:28:22.187]             sys.calls <- base::sys.calls
[09:28:22.187]             `[[` <- base::`[[`
[09:28:22.187]             `+` <- base::`+`
[09:28:22.187]             `<<-` <- base::`<<-`
[09:28:22.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.187]                   3L)]
[09:28:22.187]             }
[09:28:22.187]             function(cond) {
[09:28:22.187]                 is_error <- inherits(cond, "error")
[09:28:22.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.187]                   NULL)
[09:28:22.187]                 if (is_error) {
[09:28:22.187]                   sessionInformation <- function() {
[09:28:22.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.187]                       search = base::search(), system = base::Sys.info())
[09:28:22.187]                   }
[09:28:22.187]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.187]                     cond$call), session = sessionInformation(), 
[09:28:22.187]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.187]                   signalCondition(cond)
[09:28:22.187]                 }
[09:28:22.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.187]                 "immediateCondition"))) {
[09:28:22.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.187]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.187]                   if (TRUE && !signal) {
[09:28:22.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.187]                     {
[09:28:22.187]                       inherits <- base::inherits
[09:28:22.187]                       invokeRestart <- base::invokeRestart
[09:28:22.187]                       is.null <- base::is.null
[09:28:22.187]                       muffled <- FALSE
[09:28:22.187]                       if (inherits(cond, "message")) {
[09:28:22.187]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.187]                         if (muffled) 
[09:28:22.187]                           invokeRestart("muffleMessage")
[09:28:22.187]                       }
[09:28:22.187]                       else if (inherits(cond, "warning")) {
[09:28:22.187]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.187]                         if (muffled) 
[09:28:22.187]                           invokeRestart("muffleWarning")
[09:28:22.187]                       }
[09:28:22.187]                       else if (inherits(cond, "condition")) {
[09:28:22.187]                         if (!is.null(pattern)) {
[09:28:22.187]                           computeRestarts <- base::computeRestarts
[09:28:22.187]                           grepl <- base::grepl
[09:28:22.187]                           restarts <- computeRestarts(cond)
[09:28:22.187]                           for (restart in restarts) {
[09:28:22.187]                             name <- restart$name
[09:28:22.187]                             if (is.null(name)) 
[09:28:22.187]                               next
[09:28:22.187]                             if (!grepl(pattern, name)) 
[09:28:22.187]                               next
[09:28:22.187]                             invokeRestart(restart)
[09:28:22.187]                             muffled <- TRUE
[09:28:22.187]                             break
[09:28:22.187]                           }
[09:28:22.187]                         }
[09:28:22.187]                       }
[09:28:22.187]                       invisible(muffled)
[09:28:22.187]                     }
[09:28:22.187]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.187]                   }
[09:28:22.187]                 }
[09:28:22.187]                 else {
[09:28:22.187]                   if (TRUE) {
[09:28:22.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.187]                     {
[09:28:22.187]                       inherits <- base::inherits
[09:28:22.187]                       invokeRestart <- base::invokeRestart
[09:28:22.187]                       is.null <- base::is.null
[09:28:22.187]                       muffled <- FALSE
[09:28:22.187]                       if (inherits(cond, "message")) {
[09:28:22.187]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.187]                         if (muffled) 
[09:28:22.187]                           invokeRestart("muffleMessage")
[09:28:22.187]                       }
[09:28:22.187]                       else if (inherits(cond, "warning")) {
[09:28:22.187]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.187]                         if (muffled) 
[09:28:22.187]                           invokeRestart("muffleWarning")
[09:28:22.187]                       }
[09:28:22.187]                       else if (inherits(cond, "condition")) {
[09:28:22.187]                         if (!is.null(pattern)) {
[09:28:22.187]                           computeRestarts <- base::computeRestarts
[09:28:22.187]                           grepl <- base::grepl
[09:28:22.187]                           restarts <- computeRestarts(cond)
[09:28:22.187]                           for (restart in restarts) {
[09:28:22.187]                             name <- restart$name
[09:28:22.187]                             if (is.null(name)) 
[09:28:22.187]                               next
[09:28:22.187]                             if (!grepl(pattern, name)) 
[09:28:22.187]                               next
[09:28:22.187]                             invokeRestart(restart)
[09:28:22.187]                             muffled <- TRUE
[09:28:22.187]                             break
[09:28:22.187]                           }
[09:28:22.187]                         }
[09:28:22.187]                       }
[09:28:22.187]                       invisible(muffled)
[09:28:22.187]                     }
[09:28:22.187]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.187]                   }
[09:28:22.187]                 }
[09:28:22.187]             }
[09:28:22.187]         }))
[09:28:22.187]     }, error = function(ex) {
[09:28:22.187]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.187]                 ...future.rng), started = ...future.startTime, 
[09:28:22.187]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.187]             version = "1.8"), class = "FutureResult")
[09:28:22.187]     }, finally = {
[09:28:22.187]         if (!identical(...future.workdir, getwd())) 
[09:28:22.187]             setwd(...future.workdir)
[09:28:22.187]         {
[09:28:22.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.187]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.187]             }
[09:28:22.187]             base::options(...future.oldOptions)
[09:28:22.187]             if (.Platform$OS.type == "windows") {
[09:28:22.187]                 old_names <- names(...future.oldEnvVars)
[09:28:22.187]                 envs <- base::Sys.getenv()
[09:28:22.187]                 names <- names(envs)
[09:28:22.187]                 common <- intersect(names, old_names)
[09:28:22.187]                 added <- setdiff(names, old_names)
[09:28:22.187]                 removed <- setdiff(old_names, names)
[09:28:22.187]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.187]                   envs[common]]
[09:28:22.187]                 NAMES <- toupper(changed)
[09:28:22.187]                 args <- list()
[09:28:22.187]                 for (kk in seq_along(NAMES)) {
[09:28:22.187]                   name <- changed[[kk]]
[09:28:22.187]                   NAME <- NAMES[[kk]]
[09:28:22.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.187]                     next
[09:28:22.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.187]                 }
[09:28:22.187]                 NAMES <- toupper(added)
[09:28:22.187]                 for (kk in seq_along(NAMES)) {
[09:28:22.187]                   name <- added[[kk]]
[09:28:22.187]                   NAME <- NAMES[[kk]]
[09:28:22.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.187]                     next
[09:28:22.187]                   args[[name]] <- ""
[09:28:22.187]                 }
[09:28:22.187]                 NAMES <- toupper(removed)
[09:28:22.187]                 for (kk in seq_along(NAMES)) {
[09:28:22.187]                   name <- removed[[kk]]
[09:28:22.187]                   NAME <- NAMES[[kk]]
[09:28:22.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.187]                     next
[09:28:22.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.187]                 }
[09:28:22.187]                 if (length(args) > 0) 
[09:28:22.187]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.187]             }
[09:28:22.187]             else {
[09:28:22.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.187]             }
[09:28:22.187]             {
[09:28:22.187]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.187]                   0L) {
[09:28:22.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.187]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.187]                   base::options(opts)
[09:28:22.187]                 }
[09:28:22.187]                 {
[09:28:22.187]                   {
[09:28:22.187]                     NULL
[09:28:22.187]                     RNGkind("Mersenne-Twister")
[09:28:22.187]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.187]                       inherits = FALSE)
[09:28:22.187]                   }
[09:28:22.187]                   options(future.plan = NULL)
[09:28:22.187]                   if (is.na(NA_character_)) 
[09:28:22.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.187]                     .init = FALSE)
[09:28:22.187]                 }
[09:28:22.187]             }
[09:28:22.187]         }
[09:28:22.187]     })
[09:28:22.187]     if (TRUE) {
[09:28:22.187]         base::sink(type = "output", split = FALSE)
[09:28:22.187]         if (TRUE) {
[09:28:22.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.187]         }
[09:28:22.187]         else {
[09:28:22.187]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.187]         }
[09:28:22.187]         base::close(...future.stdout)
[09:28:22.187]         ...future.stdout <- NULL
[09:28:22.187]     }
[09:28:22.187]     ...future.result$conditions <- ...future.conditions
[09:28:22.187]     ...future.result$finished <- base::Sys.time()
[09:28:22.187]     ...future.result
[09:28:22.187] }
[09:28:22.189] assign_globals() ...
[09:28:22.189] List of 5
[09:28:22.189]  $ ...future.FUN            :function (object, ...)  
[09:28:22.189]  $ future.call.arguments    : list()
[09:28:22.189]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.189]  $ ...future.elements_ii    :List of 3
[09:28:22.189]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:22.189]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.189]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.189]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:22.189]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.189]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.189]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:22.189]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.189]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.189]  $ ...future.seeds_ii       : NULL
[09:28:22.189]  $ ...future.globals.maxSize: NULL
[09:28:22.189]  - attr(*, "where")=List of 5
[09:28:22.189]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.189]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.189]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.189]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.189]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.189]  - attr(*, "resolved")= logi FALSE
[09:28:22.189]  - attr(*, "total_size")= num 1240
[09:28:22.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.189]  - attr(*, "already-done")= logi TRUE
[09:28:22.197] - copied ‘...future.FUN’ to environment
[09:28:22.197] - copied ‘future.call.arguments’ to environment
[09:28:22.197] - copied ‘...future.elements_ii’ to environment
[09:28:22.197] - copied ‘...future.seeds_ii’ to environment
[09:28:22.197] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.197] assign_globals() ... done
[09:28:22.198] plan(): Setting new future strategy stack:
[09:28:22.198] List of future strategies:
[09:28:22.198] 1. sequential:
[09:28:22.198]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.198]    - tweaked: FALSE
[09:28:22.198]    - call: NULL
[09:28:22.198] plan(): nbrOfWorkers() = 1
[09:28:22.200] plan(): Setting new future strategy stack:
[09:28:22.200] List of future strategies:
[09:28:22.200] 1. multicore:
[09:28:22.200]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:22.200]    - tweaked: FALSE
[09:28:22.200]    - call: plan(strategy)
[09:28:22.203] plan(): nbrOfWorkers() = 1
[09:28:22.203] SequentialFuture started (and completed)
[09:28:22.203] - Launch lazy future ... done
[09:28:22.203] run() for ‘SequentialFuture’ ... done
[09:28:22.204] Created future:
[09:28:22.204] SequentialFuture:
[09:28:22.204] Label: ‘future_by-1’
[09:28:22.204] Expression:
[09:28:22.204] {
[09:28:22.204]     do.call(function(...) {
[09:28:22.204]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.204]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.204]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.204]             on.exit(options(oopts), add = TRUE)
[09:28:22.204]         }
[09:28:22.204]         {
[09:28:22.204]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.204]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.204]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.204]             })
[09:28:22.204]         }
[09:28:22.204]     }, args = future.call.arguments)
[09:28:22.204] }
[09:28:22.204] Lazy evaluation: FALSE
[09:28:22.204] Asynchronous evaluation: FALSE
[09:28:22.204] Local evaluation: TRUE
[09:28:22.204] Environment: R_GlobalEnv
[09:28:22.204] Capture standard output: TRUE
[09:28:22.204] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.204] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.204] Packages: <none>
[09:28:22.204] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.204] Resolved: TRUE
[09:28:22.204] Value: 4.62 KiB of class ‘list’
[09:28:22.204] Early signaling: FALSE
[09:28:22.204] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.204] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.205] Chunk #1 of 1 ... DONE
[09:28:22.205] Launching 1 futures (chunks) ... DONE
[09:28:22.205] Resolving 1 futures (chunks) ...
[09:28:22.205] resolve() on list ...
[09:28:22.205]  recursive: 0
[09:28:22.205]  length: 1
[09:28:22.205] 
[09:28:22.205] resolved() for ‘SequentialFuture’ ...
[09:28:22.205] - state: ‘finished’
[09:28:22.205] - run: TRUE
[09:28:22.206] - result: ‘FutureResult’
[09:28:22.206] resolved() for ‘SequentialFuture’ ... done
[09:28:22.206] Future #1
[09:28:22.206] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.206] - nx: 1
[09:28:22.206] - relay: TRUE
[09:28:22.206] - stdout: TRUE
[09:28:22.206] - signal: TRUE
[09:28:22.206] - resignal: FALSE
[09:28:22.206] - force: TRUE
[09:28:22.206] - relayed: [n=1] FALSE
[09:28:22.206] - queued futures: [n=1] FALSE
[09:28:22.207]  - until=1
[09:28:22.207]  - relaying element #1
[09:28:22.207] - relayed: [n=1] TRUE
[09:28:22.207] - queued futures: [n=1] TRUE
[09:28:22.207] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.207]  length: 0 (resolved future 1)
[09:28:22.207] Relaying remaining futures
[09:28:22.207] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.207] - nx: 1
[09:28:22.207] - relay: TRUE
[09:28:22.207] - stdout: TRUE
[09:28:22.208] - signal: TRUE
[09:28:22.208] - resignal: FALSE
[09:28:22.208] - force: TRUE
[09:28:22.208] - relayed: [n=1] TRUE
[09:28:22.208] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.208] - relayed: [n=1] TRUE
[09:28:22.208] - queued futures: [n=1] TRUE
[09:28:22.208] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.208] resolve() on list ... DONE
[09:28:22.208]  - Number of value chunks collected: 1
[09:28:22.208] Resolving 1 futures (chunks) ... DONE
[09:28:22.209] Reducing values from 1 chunks ...
[09:28:22.209]  - Number of values collected after concatenation: 3
[09:28:22.209]  - Number of values expected: 3
[09:28:22.209] Reducing values from 1 chunks ... DONE
[09:28:22.209] future_lapply() ... DONE
[09:28:22.209] future_by_internal() ... DONE
[09:28:22.209] future_by_internal() ...
[09:28:22.209] future_lapply() ...
[09:28:22.213] Number of chunks: 1
[09:28:22.213] getGlobalsAndPackagesXApply() ...
[09:28:22.213]  - future.globals: TRUE
[09:28:22.213] getGlobalsAndPackages() ...
[09:28:22.213] Searching for globals...
[09:28:22.214] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.214] Searching for globals ... DONE
[09:28:22.214] Resolving globals: FALSE
[09:28:22.215] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.215] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.215] - globals: [1] ‘FUN’
[09:28:22.215] 
[09:28:22.216] getGlobalsAndPackages() ... DONE
[09:28:22.216]  - globals found/used: [n=1] ‘FUN’
[09:28:22.216]  - needed namespaces: [n=0] 
[09:28:22.217] Finding globals ... DONE
[09:28:22.217]  - use_args: TRUE
[09:28:22.217]  - Getting '...' globals ...
[09:28:22.217] resolve() on list ...
[09:28:22.217]  recursive: 0
[09:28:22.217]  length: 1
[09:28:22.217]  elements: ‘...’
[09:28:22.217]  length: 0 (resolved future 1)
[09:28:22.217] resolve() on list ... DONE
[09:28:22.218]    - '...' content: [n=1] ‘digits’
[09:28:22.218] List of 1
[09:28:22.218]  $ ...:List of 1
[09:28:22.218]   ..$ digits: int 2
[09:28:22.218]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.218]  - attr(*, "where")=List of 1
[09:28:22.218]   ..$ ...:<environment: 0x555b0a731500> 
[09:28:22.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.218]  - attr(*, "resolved")= logi TRUE
[09:28:22.218]  - attr(*, "total_size")= num NA
[09:28:22.220]  - Getting '...' globals ... DONE
[09:28:22.220] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.221] List of 2
[09:28:22.221]  $ ...future.FUN:function (object, ...)  
[09:28:22.221]  $ ...          :List of 1
[09:28:22.221]   ..$ digits: int 2
[09:28:22.221]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.221]  - attr(*, "where")=List of 2
[09:28:22.221]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.221]   ..$ ...          :<environment: 0x555b0a731500> 
[09:28:22.221]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.221]  - attr(*, "resolved")= logi FALSE
[09:28:22.221]  - attr(*, "total_size")= num 1296
[09:28:22.223] Packages to be attached in all futures: [n=0] 
[09:28:22.223] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.224] Number of futures (= number of chunks): 1
[09:28:22.224] Launching 1 futures (chunks) ...
[09:28:22.224] Chunk #1 of 1 ...
[09:28:22.224]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.224] getGlobalsAndPackages() ...
[09:28:22.224] Searching for globals...
[09:28:22.224] 
[09:28:22.224] Searching for globals ... DONE
[09:28:22.224] - globals: [0] <none>
[09:28:22.225] getGlobalsAndPackages() ... DONE
[09:28:22.225]    + additional globals found: [n=0] 
[09:28:22.225]    + additional namespaces needed: [n=0] 
[09:28:22.225]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.225]  - seeds: <none>
[09:28:22.225]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.225] getGlobalsAndPackages() ...
[09:28:22.225] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.225] Resolving globals: FALSE
[09:28:22.225] Tweak future expression to call with '...' arguments ...
[09:28:22.225] {
[09:28:22.225]     do.call(function(...) {
[09:28:22.225]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.225]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.225]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.225]             on.exit(options(oopts), add = TRUE)
[09:28:22.225]         }
[09:28:22.225]         {
[09:28:22.225]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.225]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.225]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.225]             })
[09:28:22.225]         }
[09:28:22.225]     }, args = future.call.arguments)
[09:28:22.225] }
[09:28:22.226] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.226] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.226] 
[09:28:22.226] getGlobalsAndPackages() ... DONE
[09:28:22.226] run() for ‘Future’ ...
[09:28:22.226] - state: ‘created’
[09:28:22.227] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.230] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.230] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.230]   - Field: ‘label’
[09:28:22.230]   - Field: ‘local’
[09:28:22.230]   - Field: ‘owner’
[09:28:22.230]   - Field: ‘envir’
[09:28:22.230]   - Field: ‘packages’
[09:28:22.231]   - Field: ‘gc’
[09:28:22.231]   - Field: ‘conditions’
[09:28:22.231]   - Field: ‘expr’
[09:28:22.231]   - Field: ‘uuid’
[09:28:22.231]   - Field: ‘seed’
[09:28:22.231]   - Field: ‘version’
[09:28:22.231]   - Field: ‘result’
[09:28:22.231]   - Field: ‘asynchronous’
[09:28:22.231]   - Field: ‘calls’
[09:28:22.231]   - Field: ‘globals’
[09:28:22.231]   - Field: ‘stdout’
[09:28:22.232]   - Field: ‘earlySignal’
[09:28:22.232]   - Field: ‘lazy’
[09:28:22.232]   - Field: ‘state’
[09:28:22.232] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.232] - Launch lazy future ...
[09:28:22.232] Packages needed by the future expression (n = 0): <none>
[09:28:22.232] Packages needed by future strategies (n = 0): <none>
[09:28:22.233] {
[09:28:22.233]     {
[09:28:22.233]         {
[09:28:22.233]             ...future.startTime <- base::Sys.time()
[09:28:22.233]             {
[09:28:22.233]                 {
[09:28:22.233]                   {
[09:28:22.233]                     base::local({
[09:28:22.233]                       has_future <- base::requireNamespace("future", 
[09:28:22.233]                         quietly = TRUE)
[09:28:22.233]                       if (has_future) {
[09:28:22.233]                         ns <- base::getNamespace("future")
[09:28:22.233]                         version <- ns[[".package"]][["version"]]
[09:28:22.233]                         if (is.null(version)) 
[09:28:22.233]                           version <- utils::packageVersion("future")
[09:28:22.233]                       }
[09:28:22.233]                       else {
[09:28:22.233]                         version <- NULL
[09:28:22.233]                       }
[09:28:22.233]                       if (!has_future || version < "1.8.0") {
[09:28:22.233]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.233]                           "", base::R.version$version.string), 
[09:28:22.233]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.233]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.233]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.233]                             "release", "version")], collapse = " "), 
[09:28:22.233]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.233]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.233]                           info)
[09:28:22.233]                         info <- base::paste(info, collapse = "; ")
[09:28:22.233]                         if (!has_future) {
[09:28:22.233]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.233]                             info)
[09:28:22.233]                         }
[09:28:22.233]                         else {
[09:28:22.233]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.233]                             info, version)
[09:28:22.233]                         }
[09:28:22.233]                         base::stop(msg)
[09:28:22.233]                       }
[09:28:22.233]                     })
[09:28:22.233]                   }
[09:28:22.233]                   ...future.strategy.old <- future::plan("list")
[09:28:22.233]                   options(future.plan = NULL)
[09:28:22.233]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.233]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.233]                 }
[09:28:22.233]                 ...future.workdir <- getwd()
[09:28:22.233]             }
[09:28:22.233]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.233]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.233]         }
[09:28:22.233]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.233]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.233]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.233]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.233]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.233]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.233]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.233]             base::names(...future.oldOptions))
[09:28:22.233]     }
[09:28:22.233]     if (FALSE) {
[09:28:22.233]     }
[09:28:22.233]     else {
[09:28:22.233]         if (TRUE) {
[09:28:22.233]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.233]                 open = "w")
[09:28:22.233]         }
[09:28:22.233]         else {
[09:28:22.233]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.233]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.233]         }
[09:28:22.233]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.233]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.233]             base::sink(type = "output", split = FALSE)
[09:28:22.233]             base::close(...future.stdout)
[09:28:22.233]         }, add = TRUE)
[09:28:22.233]     }
[09:28:22.233]     ...future.frame <- base::sys.nframe()
[09:28:22.233]     ...future.conditions <- base::list()
[09:28:22.233]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.233]     if (FALSE) {
[09:28:22.233]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.233]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.233]     }
[09:28:22.233]     ...future.result <- base::tryCatch({
[09:28:22.233]         base::withCallingHandlers({
[09:28:22.233]             ...future.value <- base::withVisible(base::local({
[09:28:22.233]                 do.call(function(...) {
[09:28:22.233]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.233]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.233]                     ...future.globals.maxSize)) {
[09:28:22.233]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.233]                     on.exit(options(oopts), add = TRUE)
[09:28:22.233]                   }
[09:28:22.233]                   {
[09:28:22.233]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.233]                       FUN = function(jj) {
[09:28:22.233]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.233]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.233]                       })
[09:28:22.233]                   }
[09:28:22.233]                 }, args = future.call.arguments)
[09:28:22.233]             }))
[09:28:22.233]             future::FutureResult(value = ...future.value$value, 
[09:28:22.233]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.233]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.233]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.233]                     ...future.globalenv.names))
[09:28:22.233]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.233]         }, condition = base::local({
[09:28:22.233]             c <- base::c
[09:28:22.233]             inherits <- base::inherits
[09:28:22.233]             invokeRestart <- base::invokeRestart
[09:28:22.233]             length <- base::length
[09:28:22.233]             list <- base::list
[09:28:22.233]             seq.int <- base::seq.int
[09:28:22.233]             signalCondition <- base::signalCondition
[09:28:22.233]             sys.calls <- base::sys.calls
[09:28:22.233]             `[[` <- base::`[[`
[09:28:22.233]             `+` <- base::`+`
[09:28:22.233]             `<<-` <- base::`<<-`
[09:28:22.233]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.233]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.233]                   3L)]
[09:28:22.233]             }
[09:28:22.233]             function(cond) {
[09:28:22.233]                 is_error <- inherits(cond, "error")
[09:28:22.233]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.233]                   NULL)
[09:28:22.233]                 if (is_error) {
[09:28:22.233]                   sessionInformation <- function() {
[09:28:22.233]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.233]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.233]                       search = base::search(), system = base::Sys.info())
[09:28:22.233]                   }
[09:28:22.233]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.233]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.233]                     cond$call), session = sessionInformation(), 
[09:28:22.233]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.233]                   signalCondition(cond)
[09:28:22.233]                 }
[09:28:22.233]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.233]                 "immediateCondition"))) {
[09:28:22.233]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.233]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.233]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.233]                   if (TRUE && !signal) {
[09:28:22.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.233]                     {
[09:28:22.233]                       inherits <- base::inherits
[09:28:22.233]                       invokeRestart <- base::invokeRestart
[09:28:22.233]                       is.null <- base::is.null
[09:28:22.233]                       muffled <- FALSE
[09:28:22.233]                       if (inherits(cond, "message")) {
[09:28:22.233]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.233]                         if (muffled) 
[09:28:22.233]                           invokeRestart("muffleMessage")
[09:28:22.233]                       }
[09:28:22.233]                       else if (inherits(cond, "warning")) {
[09:28:22.233]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.233]                         if (muffled) 
[09:28:22.233]                           invokeRestart("muffleWarning")
[09:28:22.233]                       }
[09:28:22.233]                       else if (inherits(cond, "condition")) {
[09:28:22.233]                         if (!is.null(pattern)) {
[09:28:22.233]                           computeRestarts <- base::computeRestarts
[09:28:22.233]                           grepl <- base::grepl
[09:28:22.233]                           restarts <- computeRestarts(cond)
[09:28:22.233]                           for (restart in restarts) {
[09:28:22.233]                             name <- restart$name
[09:28:22.233]                             if (is.null(name)) 
[09:28:22.233]                               next
[09:28:22.233]                             if (!grepl(pattern, name)) 
[09:28:22.233]                               next
[09:28:22.233]                             invokeRestart(restart)
[09:28:22.233]                             muffled <- TRUE
[09:28:22.233]                             break
[09:28:22.233]                           }
[09:28:22.233]                         }
[09:28:22.233]                       }
[09:28:22.233]                       invisible(muffled)
[09:28:22.233]                     }
[09:28:22.233]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.233]                   }
[09:28:22.233]                 }
[09:28:22.233]                 else {
[09:28:22.233]                   if (TRUE) {
[09:28:22.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.233]                     {
[09:28:22.233]                       inherits <- base::inherits
[09:28:22.233]                       invokeRestart <- base::invokeRestart
[09:28:22.233]                       is.null <- base::is.null
[09:28:22.233]                       muffled <- FALSE
[09:28:22.233]                       if (inherits(cond, "message")) {
[09:28:22.233]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.233]                         if (muffled) 
[09:28:22.233]                           invokeRestart("muffleMessage")
[09:28:22.233]                       }
[09:28:22.233]                       else if (inherits(cond, "warning")) {
[09:28:22.233]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.233]                         if (muffled) 
[09:28:22.233]                           invokeRestart("muffleWarning")
[09:28:22.233]                       }
[09:28:22.233]                       else if (inherits(cond, "condition")) {
[09:28:22.233]                         if (!is.null(pattern)) {
[09:28:22.233]                           computeRestarts <- base::computeRestarts
[09:28:22.233]                           grepl <- base::grepl
[09:28:22.233]                           restarts <- computeRestarts(cond)
[09:28:22.233]                           for (restart in restarts) {
[09:28:22.233]                             name <- restart$name
[09:28:22.233]                             if (is.null(name)) 
[09:28:22.233]                               next
[09:28:22.233]                             if (!grepl(pattern, name)) 
[09:28:22.233]                               next
[09:28:22.233]                             invokeRestart(restart)
[09:28:22.233]                             muffled <- TRUE
[09:28:22.233]                             break
[09:28:22.233]                           }
[09:28:22.233]                         }
[09:28:22.233]                       }
[09:28:22.233]                       invisible(muffled)
[09:28:22.233]                     }
[09:28:22.233]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.233]                   }
[09:28:22.233]                 }
[09:28:22.233]             }
[09:28:22.233]         }))
[09:28:22.233]     }, error = function(ex) {
[09:28:22.233]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.233]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.233]                 ...future.rng), started = ...future.startTime, 
[09:28:22.233]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.233]             version = "1.8"), class = "FutureResult")
[09:28:22.233]     }, finally = {
[09:28:22.233]         if (!identical(...future.workdir, getwd())) 
[09:28:22.233]             setwd(...future.workdir)
[09:28:22.233]         {
[09:28:22.233]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.233]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.233]             }
[09:28:22.233]             base::options(...future.oldOptions)
[09:28:22.233]             if (.Platform$OS.type == "windows") {
[09:28:22.233]                 old_names <- names(...future.oldEnvVars)
[09:28:22.233]                 envs <- base::Sys.getenv()
[09:28:22.233]                 names <- names(envs)
[09:28:22.233]                 common <- intersect(names, old_names)
[09:28:22.233]                 added <- setdiff(names, old_names)
[09:28:22.233]                 removed <- setdiff(old_names, names)
[09:28:22.233]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.233]                   envs[common]]
[09:28:22.233]                 NAMES <- toupper(changed)
[09:28:22.233]                 args <- list()
[09:28:22.233]                 for (kk in seq_along(NAMES)) {
[09:28:22.233]                   name <- changed[[kk]]
[09:28:22.233]                   NAME <- NAMES[[kk]]
[09:28:22.233]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.233]                     next
[09:28:22.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.233]                 }
[09:28:22.233]                 NAMES <- toupper(added)
[09:28:22.233]                 for (kk in seq_along(NAMES)) {
[09:28:22.233]                   name <- added[[kk]]
[09:28:22.233]                   NAME <- NAMES[[kk]]
[09:28:22.233]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.233]                     next
[09:28:22.233]                   args[[name]] <- ""
[09:28:22.233]                 }
[09:28:22.233]                 NAMES <- toupper(removed)
[09:28:22.233]                 for (kk in seq_along(NAMES)) {
[09:28:22.233]                   name <- removed[[kk]]
[09:28:22.233]                   NAME <- NAMES[[kk]]
[09:28:22.233]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.233]                     next
[09:28:22.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.233]                 }
[09:28:22.233]                 if (length(args) > 0) 
[09:28:22.233]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.233]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.233]             }
[09:28:22.233]             else {
[09:28:22.233]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.233]             }
[09:28:22.233]             {
[09:28:22.233]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.233]                   0L) {
[09:28:22.233]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.233]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.233]                   base::options(opts)
[09:28:22.233]                 }
[09:28:22.233]                 {
[09:28:22.233]                   {
[09:28:22.233]                     NULL
[09:28:22.233]                     RNGkind("Mersenne-Twister")
[09:28:22.233]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.233]                       inherits = FALSE)
[09:28:22.233]                   }
[09:28:22.233]                   options(future.plan = NULL)
[09:28:22.233]                   if (is.na(NA_character_)) 
[09:28:22.233]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.233]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.233]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.233]                     .init = FALSE)
[09:28:22.233]                 }
[09:28:22.233]             }
[09:28:22.233]         }
[09:28:22.233]     })
[09:28:22.233]     if (TRUE) {
[09:28:22.233]         base::sink(type = "output", split = FALSE)
[09:28:22.233]         if (TRUE) {
[09:28:22.233]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.233]         }
[09:28:22.233]         else {
[09:28:22.233]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.233]         }
[09:28:22.233]         base::close(...future.stdout)
[09:28:22.233]         ...future.stdout <- NULL
[09:28:22.233]     }
[09:28:22.233]     ...future.result$conditions <- ...future.conditions
[09:28:22.233]     ...future.result$finished <- base::Sys.time()
[09:28:22.233]     ...future.result
[09:28:22.233] }
[09:28:22.234] assign_globals() ...
[09:28:22.234] List of 5
[09:28:22.234]  $ ...future.FUN            :function (object, ...)  
[09:28:22.234]  $ future.call.arguments    :List of 1
[09:28:22.234]   ..$ digits: int 2
[09:28:22.234]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.234]  $ ...future.elements_ii    :List of 6
[09:28:22.234]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[09:28:22.234]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[09:28:22.234]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[09:28:22.234]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[09:28:22.234]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[09:28:22.234]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[09:28:22.234]  $ ...future.seeds_ii       : NULL
[09:28:22.234]  $ ...future.globals.maxSize: NULL
[09:28:22.234]  - attr(*, "where")=List of 5
[09:28:22.234]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.234]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.234]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.234]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.234]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.234]  - attr(*, "resolved")= logi FALSE
[09:28:22.234]  - attr(*, "total_size")= num 1296
[09:28:22.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.234]  - attr(*, "already-done")= logi TRUE
[09:28:22.241] - copied ‘...future.FUN’ to environment
[09:28:22.241] - copied ‘future.call.arguments’ to environment
[09:28:22.241] - copied ‘...future.elements_ii’ to environment
[09:28:22.241] - copied ‘...future.seeds_ii’ to environment
[09:28:22.242] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.242] assign_globals() ... done
[09:28:22.242] plan(): Setting new future strategy stack:
[09:28:22.242] List of future strategies:
[09:28:22.242] 1. sequential:
[09:28:22.242]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.242]    - tweaked: FALSE
[09:28:22.242]    - call: NULL
[09:28:22.242] plan(): nbrOfWorkers() = 1
[09:28:22.244] plan(): Setting new future strategy stack:
[09:28:22.244] List of future strategies:
[09:28:22.244] 1. multicore:
[09:28:22.244]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:22.244]    - tweaked: FALSE
[09:28:22.244]    - call: plan(strategy)
[09:28:22.247] plan(): nbrOfWorkers() = 1
[09:28:22.247] SequentialFuture started (and completed)
[09:28:22.247] - Launch lazy future ... done
[09:28:22.247] run() for ‘SequentialFuture’ ... done
[09:28:22.247] Created future:
[09:28:22.247] SequentialFuture:
[09:28:22.247] Label: ‘future_by-1’
[09:28:22.247] Expression:
[09:28:22.247] {
[09:28:22.247]     do.call(function(...) {
[09:28:22.247]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.247]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.247]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.247]             on.exit(options(oopts), add = TRUE)
[09:28:22.247]         }
[09:28:22.247]         {
[09:28:22.247]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.247]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.247]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.247]             })
[09:28:22.247]         }
[09:28:22.247]     }, args = future.call.arguments)
[09:28:22.247] }
[09:28:22.247] Lazy evaluation: FALSE
[09:28:22.247] Asynchronous evaluation: FALSE
[09:28:22.247] Local evaluation: TRUE
[09:28:22.247] Environment: R_GlobalEnv
[09:28:22.247] Capture standard output: TRUE
[09:28:22.247] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.247] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.247] Packages: <none>
[09:28:22.247] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.247] Resolved: TRUE
[09:28:22.247] Value: 5.48 KiB of class ‘list’
[09:28:22.247] Early signaling: FALSE
[09:28:22.247] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.247] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.248] Chunk #1 of 1 ... DONE
[09:28:22.249] Launching 1 futures (chunks) ... DONE
[09:28:22.249] Resolving 1 futures (chunks) ...
[09:28:22.249] resolve() on list ...
[09:28:22.249]  recursive: 0
[09:28:22.249]  length: 1
[09:28:22.249] 
[09:28:22.249] resolved() for ‘SequentialFuture’ ...
[09:28:22.249] - state: ‘finished’
[09:28:22.249] - run: TRUE
[09:28:22.249] - result: ‘FutureResult’
[09:28:22.249] resolved() for ‘SequentialFuture’ ... done
[09:28:22.250] Future #1
[09:28:22.250] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.250] - nx: 1
[09:28:22.250] - relay: TRUE
[09:28:22.250] - stdout: TRUE
[09:28:22.250] - signal: TRUE
[09:28:22.250] - resignal: FALSE
[09:28:22.250] - force: TRUE
[09:28:22.250] - relayed: [n=1] FALSE
[09:28:22.250] - queued futures: [n=1] FALSE
[09:28:22.250]  - until=1
[09:28:22.250]  - relaying element #1
[09:28:22.251] - relayed: [n=1] TRUE
[09:28:22.251] - queued futures: [n=1] TRUE
[09:28:22.251] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.251]  length: 0 (resolved future 1)
[09:28:22.251] Relaying remaining futures
[09:28:22.251] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.251] - nx: 1
[09:28:22.251] - relay: TRUE
[09:28:22.251] - stdout: TRUE
[09:28:22.251] - signal: TRUE
[09:28:22.251] - resignal: FALSE
[09:28:22.251] - force: TRUE
[09:28:22.252] - relayed: [n=1] TRUE
[09:28:22.252] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.252] - relayed: [n=1] TRUE
[09:28:22.252] - queued futures: [n=1] TRUE
[09:28:22.252] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.252] resolve() on list ... DONE
[09:28:22.252]  - Number of value chunks collected: 1
[09:28:22.252] Resolving 1 futures (chunks) ... DONE
[09:28:22.252] Reducing values from 1 chunks ...
[09:28:22.252]  - Number of values collected after concatenation: 6
[09:28:22.252]  - Number of values expected: 6
[09:28:22.253] Reducing values from 1 chunks ... DONE
[09:28:22.253] future_lapply() ... DONE
[09:28:22.253] future_by_internal() ... DONE
[09:28:22.254] future_by_internal() ...
[09:28:22.254] future_lapply() ...
[09:28:22.258] Number of chunks: 1
[09:28:22.258] getGlobalsAndPackagesXApply() ...
[09:28:22.258]  - future.globals: TRUE
[09:28:22.258] getGlobalsAndPackages() ...
[09:28:22.258] Searching for globals...
[09:28:22.260] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:22.260] Searching for globals ... DONE
[09:28:22.260] Resolving globals: FALSE
[09:28:22.261] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[09:28:22.261] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[09:28:22.261] - globals: [1] ‘FUN’
[09:28:22.261] - packages: [1] ‘stats’
[09:28:22.262] getGlobalsAndPackages() ... DONE
[09:28:22.262]  - globals found/used: [n=1] ‘FUN’
[09:28:22.262]  - needed namespaces: [n=1] ‘stats’
[09:28:22.262] Finding globals ... DONE
[09:28:22.262]  - use_args: TRUE
[09:28:22.262]  - Getting '...' globals ...
[09:28:22.262] resolve() on list ...
[09:28:22.262]  recursive: 0
[09:28:22.262]  length: 1
[09:28:22.263]  elements: ‘...’
[09:28:22.263]  length: 0 (resolved future 1)
[09:28:22.263] resolve() on list ... DONE
[09:28:22.263]    - '...' content: [n=1] ‘singular.ok’
[09:28:22.263] List of 1
[09:28:22.263]  $ ...:List of 1
[09:28:22.263]   ..$ singular.ok: logi FALSE
[09:28:22.263]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.263]  - attr(*, "where")=List of 1
[09:28:22.263]   ..$ ...:<environment: 0x555b0a762df0> 
[09:28:22.263]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.263]  - attr(*, "resolved")= logi TRUE
[09:28:22.263]  - attr(*, "total_size")= num NA
[09:28:22.266]  - Getting '...' globals ... DONE
[09:28:22.266] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.266] List of 2
[09:28:22.266]  $ ...future.FUN:function (x, ...)  
[09:28:22.266]  $ ...          :List of 1
[09:28:22.266]   ..$ singular.ok: logi FALSE
[09:28:22.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.266]  - attr(*, "where")=List of 2
[09:28:22.266]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.266]   ..$ ...          :<environment: 0x555b0a762df0> 
[09:28:22.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.266]  - attr(*, "resolved")= logi FALSE
[09:28:22.266]  - attr(*, "total_size")= num 5384
[09:28:22.269] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:22.269] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.269] Number of futures (= number of chunks): 1
[09:28:22.269] Launching 1 futures (chunks) ...
[09:28:22.269] Chunk #1 of 1 ...
[09:28:22.269]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.270] getGlobalsAndPackages() ...
[09:28:22.270] Searching for globals...
[09:28:22.270] 
[09:28:22.270] Searching for globals ... DONE
[09:28:22.270] - globals: [0] <none>
[09:28:22.270] getGlobalsAndPackages() ... DONE
[09:28:22.270]    + additional globals found: [n=0] 
[09:28:22.271]    + additional namespaces needed: [n=0] 
[09:28:22.271]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.271]  - seeds: <none>
[09:28:22.271]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.271] getGlobalsAndPackages() ...
[09:28:22.271] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.271] Resolving globals: FALSE
[09:28:22.271] Tweak future expression to call with '...' arguments ...
[09:28:22.271] {
[09:28:22.271]     do.call(function(...) {
[09:28:22.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.271]             on.exit(options(oopts), add = TRUE)
[09:28:22.271]         }
[09:28:22.271]         {
[09:28:22.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.271]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.271]             })
[09:28:22.271]         }
[09:28:22.271]     }, args = future.call.arguments)
[09:28:22.271] }
[09:28:22.272] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.272] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.272] 
[09:28:22.272] getGlobalsAndPackages() ... DONE
[09:28:22.272] run() for ‘Future’ ...
[09:28:22.273] - state: ‘created’
[09:28:22.273] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.276] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.276] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.276]   - Field: ‘label’
[09:28:22.276]   - Field: ‘local’
[09:28:22.276]   - Field: ‘owner’
[09:28:22.277]   - Field: ‘envir’
[09:28:22.277]   - Field: ‘packages’
[09:28:22.277]   - Field: ‘gc’
[09:28:22.277]   - Field: ‘conditions’
[09:28:22.277]   - Field: ‘expr’
[09:28:22.277]   - Field: ‘uuid’
[09:28:22.277]   - Field: ‘seed’
[09:28:22.277]   - Field: ‘version’
[09:28:22.277]   - Field: ‘result’
[09:28:22.277]   - Field: ‘asynchronous’
[09:28:22.277]   - Field: ‘calls’
[09:28:22.278]   - Field: ‘globals’
[09:28:22.278]   - Field: ‘stdout’
[09:28:22.278]   - Field: ‘earlySignal’
[09:28:22.278]   - Field: ‘lazy’
[09:28:22.278]   - Field: ‘state’
[09:28:22.278] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.278] - Launch lazy future ...
[09:28:22.278] Packages needed by the future expression (n = 1): ‘stats’
[09:28:22.278] Packages needed by future strategies (n = 0): <none>
[09:28:22.279] {
[09:28:22.279]     {
[09:28:22.279]         {
[09:28:22.279]             ...future.startTime <- base::Sys.time()
[09:28:22.279]             {
[09:28:22.279]                 {
[09:28:22.279]                   {
[09:28:22.279]                     {
[09:28:22.279]                       base::local({
[09:28:22.279]                         has_future <- base::requireNamespace("future", 
[09:28:22.279]                           quietly = TRUE)
[09:28:22.279]                         if (has_future) {
[09:28:22.279]                           ns <- base::getNamespace("future")
[09:28:22.279]                           version <- ns[[".package"]][["version"]]
[09:28:22.279]                           if (is.null(version)) 
[09:28:22.279]                             version <- utils::packageVersion("future")
[09:28:22.279]                         }
[09:28:22.279]                         else {
[09:28:22.279]                           version <- NULL
[09:28:22.279]                         }
[09:28:22.279]                         if (!has_future || version < "1.8.0") {
[09:28:22.279]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.279]                             "", base::R.version$version.string), 
[09:28:22.279]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:22.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.279]                               "release", "version")], collapse = " "), 
[09:28:22.279]                             hostname = base::Sys.info()[["nodename"]])
[09:28:22.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.279]                             info)
[09:28:22.279]                           info <- base::paste(info, collapse = "; ")
[09:28:22.279]                           if (!has_future) {
[09:28:22.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.279]                               info)
[09:28:22.279]                           }
[09:28:22.279]                           else {
[09:28:22.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.279]                               info, version)
[09:28:22.279]                           }
[09:28:22.279]                           base::stop(msg)
[09:28:22.279]                         }
[09:28:22.279]                       })
[09:28:22.279]                     }
[09:28:22.279]                     base::local({
[09:28:22.279]                       for (pkg in "stats") {
[09:28:22.279]                         base::loadNamespace(pkg)
[09:28:22.279]                         base::library(pkg, character.only = TRUE)
[09:28:22.279]                       }
[09:28:22.279]                     })
[09:28:22.279]                   }
[09:28:22.279]                   ...future.strategy.old <- future::plan("list")
[09:28:22.279]                   options(future.plan = NULL)
[09:28:22.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.279]                 }
[09:28:22.279]                 ...future.workdir <- getwd()
[09:28:22.279]             }
[09:28:22.279]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.279]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.279]         }
[09:28:22.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.279]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.279]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.279]             base::names(...future.oldOptions))
[09:28:22.279]     }
[09:28:22.279]     if (FALSE) {
[09:28:22.279]     }
[09:28:22.279]     else {
[09:28:22.279]         if (TRUE) {
[09:28:22.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.279]                 open = "w")
[09:28:22.279]         }
[09:28:22.279]         else {
[09:28:22.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.279]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.279]         }
[09:28:22.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.279]             base::sink(type = "output", split = FALSE)
[09:28:22.279]             base::close(...future.stdout)
[09:28:22.279]         }, add = TRUE)
[09:28:22.279]     }
[09:28:22.279]     ...future.frame <- base::sys.nframe()
[09:28:22.279]     ...future.conditions <- base::list()
[09:28:22.279]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.279]     if (FALSE) {
[09:28:22.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.279]     }
[09:28:22.279]     ...future.result <- base::tryCatch({
[09:28:22.279]         base::withCallingHandlers({
[09:28:22.279]             ...future.value <- base::withVisible(base::local({
[09:28:22.279]                 do.call(function(...) {
[09:28:22.279]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.279]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.279]                     ...future.globals.maxSize)) {
[09:28:22.279]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.279]                     on.exit(options(oopts), add = TRUE)
[09:28:22.279]                   }
[09:28:22.279]                   {
[09:28:22.279]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.279]                       FUN = function(jj) {
[09:28:22.279]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.279]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.279]                       })
[09:28:22.279]                   }
[09:28:22.279]                 }, args = future.call.arguments)
[09:28:22.279]             }))
[09:28:22.279]             future::FutureResult(value = ...future.value$value, 
[09:28:22.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.279]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.279]                     ...future.globalenv.names))
[09:28:22.279]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.279]         }, condition = base::local({
[09:28:22.279]             c <- base::c
[09:28:22.279]             inherits <- base::inherits
[09:28:22.279]             invokeRestart <- base::invokeRestart
[09:28:22.279]             length <- base::length
[09:28:22.279]             list <- base::list
[09:28:22.279]             seq.int <- base::seq.int
[09:28:22.279]             signalCondition <- base::signalCondition
[09:28:22.279]             sys.calls <- base::sys.calls
[09:28:22.279]             `[[` <- base::`[[`
[09:28:22.279]             `+` <- base::`+`
[09:28:22.279]             `<<-` <- base::`<<-`
[09:28:22.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.279]                   3L)]
[09:28:22.279]             }
[09:28:22.279]             function(cond) {
[09:28:22.279]                 is_error <- inherits(cond, "error")
[09:28:22.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.279]                   NULL)
[09:28:22.279]                 if (is_error) {
[09:28:22.279]                   sessionInformation <- function() {
[09:28:22.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.279]                       search = base::search(), system = base::Sys.info())
[09:28:22.279]                   }
[09:28:22.279]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.279]                     cond$call), session = sessionInformation(), 
[09:28:22.279]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.279]                   signalCondition(cond)
[09:28:22.279]                 }
[09:28:22.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.279]                 "immediateCondition"))) {
[09:28:22.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.279]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.279]                   if (TRUE && !signal) {
[09:28:22.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.279]                     {
[09:28:22.279]                       inherits <- base::inherits
[09:28:22.279]                       invokeRestart <- base::invokeRestart
[09:28:22.279]                       is.null <- base::is.null
[09:28:22.279]                       muffled <- FALSE
[09:28:22.279]                       if (inherits(cond, "message")) {
[09:28:22.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.279]                         if (muffled) 
[09:28:22.279]                           invokeRestart("muffleMessage")
[09:28:22.279]                       }
[09:28:22.279]                       else if (inherits(cond, "warning")) {
[09:28:22.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.279]                         if (muffled) 
[09:28:22.279]                           invokeRestart("muffleWarning")
[09:28:22.279]                       }
[09:28:22.279]                       else if (inherits(cond, "condition")) {
[09:28:22.279]                         if (!is.null(pattern)) {
[09:28:22.279]                           computeRestarts <- base::computeRestarts
[09:28:22.279]                           grepl <- base::grepl
[09:28:22.279]                           restarts <- computeRestarts(cond)
[09:28:22.279]                           for (restart in restarts) {
[09:28:22.279]                             name <- restart$name
[09:28:22.279]                             if (is.null(name)) 
[09:28:22.279]                               next
[09:28:22.279]                             if (!grepl(pattern, name)) 
[09:28:22.279]                               next
[09:28:22.279]                             invokeRestart(restart)
[09:28:22.279]                             muffled <- TRUE
[09:28:22.279]                             break
[09:28:22.279]                           }
[09:28:22.279]                         }
[09:28:22.279]                       }
[09:28:22.279]                       invisible(muffled)
[09:28:22.279]                     }
[09:28:22.279]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.279]                   }
[09:28:22.279]                 }
[09:28:22.279]                 else {
[09:28:22.279]                   if (TRUE) {
[09:28:22.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.279]                     {
[09:28:22.279]                       inherits <- base::inherits
[09:28:22.279]                       invokeRestart <- base::invokeRestart
[09:28:22.279]                       is.null <- base::is.null
[09:28:22.279]                       muffled <- FALSE
[09:28:22.279]                       if (inherits(cond, "message")) {
[09:28:22.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.279]                         if (muffled) 
[09:28:22.279]                           invokeRestart("muffleMessage")
[09:28:22.279]                       }
[09:28:22.279]                       else if (inherits(cond, "warning")) {
[09:28:22.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.279]                         if (muffled) 
[09:28:22.279]                           invokeRestart("muffleWarning")
[09:28:22.279]                       }
[09:28:22.279]                       else if (inherits(cond, "condition")) {
[09:28:22.279]                         if (!is.null(pattern)) {
[09:28:22.279]                           computeRestarts <- base::computeRestarts
[09:28:22.279]                           grepl <- base::grepl
[09:28:22.279]                           restarts <- computeRestarts(cond)
[09:28:22.279]                           for (restart in restarts) {
[09:28:22.279]                             name <- restart$name
[09:28:22.279]                             if (is.null(name)) 
[09:28:22.279]                               next
[09:28:22.279]                             if (!grepl(pattern, name)) 
[09:28:22.279]                               next
[09:28:22.279]                             invokeRestart(restart)
[09:28:22.279]                             muffled <- TRUE
[09:28:22.279]                             break
[09:28:22.279]                           }
[09:28:22.279]                         }
[09:28:22.279]                       }
[09:28:22.279]                       invisible(muffled)
[09:28:22.279]                     }
[09:28:22.279]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.279]                   }
[09:28:22.279]                 }
[09:28:22.279]             }
[09:28:22.279]         }))
[09:28:22.279]     }, error = function(ex) {
[09:28:22.279]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.279]                 ...future.rng), started = ...future.startTime, 
[09:28:22.279]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.279]             version = "1.8"), class = "FutureResult")
[09:28:22.279]     }, finally = {
[09:28:22.279]         if (!identical(...future.workdir, getwd())) 
[09:28:22.279]             setwd(...future.workdir)
[09:28:22.279]         {
[09:28:22.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.279]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.279]             }
[09:28:22.279]             base::options(...future.oldOptions)
[09:28:22.279]             if (.Platform$OS.type == "windows") {
[09:28:22.279]                 old_names <- names(...future.oldEnvVars)
[09:28:22.279]                 envs <- base::Sys.getenv()
[09:28:22.279]                 names <- names(envs)
[09:28:22.279]                 common <- intersect(names, old_names)
[09:28:22.279]                 added <- setdiff(names, old_names)
[09:28:22.279]                 removed <- setdiff(old_names, names)
[09:28:22.279]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.279]                   envs[common]]
[09:28:22.279]                 NAMES <- toupper(changed)
[09:28:22.279]                 args <- list()
[09:28:22.279]                 for (kk in seq_along(NAMES)) {
[09:28:22.279]                   name <- changed[[kk]]
[09:28:22.279]                   NAME <- NAMES[[kk]]
[09:28:22.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.279]                     next
[09:28:22.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.279]                 }
[09:28:22.279]                 NAMES <- toupper(added)
[09:28:22.279]                 for (kk in seq_along(NAMES)) {
[09:28:22.279]                   name <- added[[kk]]
[09:28:22.279]                   NAME <- NAMES[[kk]]
[09:28:22.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.279]                     next
[09:28:22.279]                   args[[name]] <- ""
[09:28:22.279]                 }
[09:28:22.279]                 NAMES <- toupper(removed)
[09:28:22.279]                 for (kk in seq_along(NAMES)) {
[09:28:22.279]                   name <- removed[[kk]]
[09:28:22.279]                   NAME <- NAMES[[kk]]
[09:28:22.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.279]                     next
[09:28:22.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.279]                 }
[09:28:22.279]                 if (length(args) > 0) 
[09:28:22.279]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.279]             }
[09:28:22.279]             else {
[09:28:22.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.279]             }
[09:28:22.279]             {
[09:28:22.279]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.279]                   0L) {
[09:28:22.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.279]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.279]                   base::options(opts)
[09:28:22.279]                 }
[09:28:22.279]                 {
[09:28:22.279]                   {
[09:28:22.279]                     NULL
[09:28:22.279]                     RNGkind("Mersenne-Twister")
[09:28:22.279]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.279]                       inherits = FALSE)
[09:28:22.279]                   }
[09:28:22.279]                   options(future.plan = NULL)
[09:28:22.279]                   if (is.na(NA_character_)) 
[09:28:22.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.279]                     .init = FALSE)
[09:28:22.279]                 }
[09:28:22.279]             }
[09:28:22.279]         }
[09:28:22.279]     })
[09:28:22.279]     if (TRUE) {
[09:28:22.279]         base::sink(type = "output", split = FALSE)
[09:28:22.279]         if (TRUE) {
[09:28:22.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.279]         }
[09:28:22.279]         else {
[09:28:22.279]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.279]         }
[09:28:22.279]         base::close(...future.stdout)
[09:28:22.279]         ...future.stdout <- NULL
[09:28:22.279]     }
[09:28:22.279]     ...future.result$conditions <- ...future.conditions
[09:28:22.279]     ...future.result$finished <- base::Sys.time()
[09:28:22.279]     ...future.result
[09:28:22.279] }
[09:28:22.281] assign_globals() ...
[09:28:22.281] List of 5
[09:28:22.281]  $ ...future.FUN            :function (x, ...)  
[09:28:22.281]  $ future.call.arguments    :List of 1
[09:28:22.281]   ..$ singular.ok: logi FALSE
[09:28:22.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.281]  $ ...future.elements_ii    :List of 3
[09:28:22.281]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.281]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.281]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.281]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.281]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.281]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.281]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.281]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.281]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.281]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.281]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.281]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.281]  $ ...future.seeds_ii       : NULL
[09:28:22.281]  $ ...future.globals.maxSize: NULL
[09:28:22.281]  - attr(*, "where")=List of 5
[09:28:22.281]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.281]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.281]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.281]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.281]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.281]  - attr(*, "resolved")= logi FALSE
[09:28:22.281]  - attr(*, "total_size")= num 5384
[09:28:22.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.281]  - attr(*, "already-done")= logi TRUE
[09:28:22.317] - reassign environment for ‘...future.FUN’
[09:28:22.317] - copied ‘...future.FUN’ to environment
[09:28:22.317] - copied ‘future.call.arguments’ to environment
[09:28:22.317] - copied ‘...future.elements_ii’ to environment
[09:28:22.317] - copied ‘...future.seeds_ii’ to environment
[09:28:22.317] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.317] assign_globals() ... done
[09:28:22.318] plan(): Setting new future strategy stack:
[09:28:22.318] List of future strategies:
[09:28:22.318] 1. sequential:
[09:28:22.318]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.318]    - tweaked: FALSE
[09:28:22.318]    - call: NULL
[09:28:22.318] plan(): nbrOfWorkers() = 1
[09:28:22.321] plan(): Setting new future strategy stack:
[09:28:22.321] List of future strategies:
[09:28:22.321] 1. multicore:
[09:28:22.321]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:22.321]    - tweaked: FALSE
[09:28:22.321]    - call: plan(strategy)
[09:28:22.325] plan(): nbrOfWorkers() = 1
[09:28:22.325] SequentialFuture started (and completed)
[09:28:22.325] - Launch lazy future ... done
[09:28:22.325] run() for ‘SequentialFuture’ ... done
[09:28:22.325] Created future:
[09:28:22.325] SequentialFuture:
[09:28:22.325] Label: ‘future_by-1’
[09:28:22.325] Expression:
[09:28:22.325] {
[09:28:22.325]     do.call(function(...) {
[09:28:22.325]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.325]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.325]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.325]             on.exit(options(oopts), add = TRUE)
[09:28:22.325]         }
[09:28:22.325]         {
[09:28:22.325]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.325]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.325]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.325]             })
[09:28:22.325]         }
[09:28:22.325]     }, args = future.call.arguments)
[09:28:22.325] }
[09:28:22.325] Lazy evaluation: FALSE
[09:28:22.325] Asynchronous evaluation: FALSE
[09:28:22.325] Local evaluation: TRUE
[09:28:22.325] Environment: R_GlobalEnv
[09:28:22.325] Capture standard output: TRUE
[09:28:22.325] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.325] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.325] Packages: 1 packages (‘stats’)
[09:28:22.325] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.325] Resolved: TRUE
[09:28:22.325] Value: 26.06 KiB of class ‘list’
[09:28:22.325] Early signaling: FALSE
[09:28:22.325] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.325] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.327] Chunk #1 of 1 ... DONE
[09:28:22.327] Launching 1 futures (chunks) ... DONE
[09:28:22.327] Resolving 1 futures (chunks) ...
[09:28:22.327] resolve() on list ...
[09:28:22.327]  recursive: 0
[09:28:22.327]  length: 1
[09:28:22.327] 
[09:28:22.327] resolved() for ‘SequentialFuture’ ...
[09:28:22.327] - state: ‘finished’
[09:28:22.327] - run: TRUE
[09:28:22.328] - result: ‘FutureResult’
[09:28:22.328] resolved() for ‘SequentialFuture’ ... done
[09:28:22.328] Future #1
[09:28:22.328] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.328] - nx: 1
[09:28:22.328] - relay: TRUE
[09:28:22.328] - stdout: TRUE
[09:28:22.328] - signal: TRUE
[09:28:22.328] - resignal: FALSE
[09:28:22.328] - force: TRUE
[09:28:22.328] - relayed: [n=1] FALSE
[09:28:22.329] - queued futures: [n=1] FALSE
[09:28:22.329]  - until=1
[09:28:22.329]  - relaying element #1
[09:28:22.329] - relayed: [n=1] TRUE
[09:28:22.329] - queued futures: [n=1] TRUE
[09:28:22.329] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.329]  length: 0 (resolved future 1)
[09:28:22.329] Relaying remaining futures
[09:28:22.329] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.329] - nx: 1
[09:28:22.329] - relay: TRUE
[09:28:22.330] - stdout: TRUE
[09:28:22.330] - signal: TRUE
[09:28:22.330] - resignal: FALSE
[09:28:22.330] - force: TRUE
[09:28:22.330] - relayed: [n=1] TRUE
[09:28:22.330] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.330] - relayed: [n=1] TRUE
[09:28:22.330] - queued futures: [n=1] TRUE
[09:28:22.330] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.330] resolve() on list ... DONE
[09:28:22.331]  - Number of value chunks collected: 1
[09:28:22.331] Resolving 1 futures (chunks) ... DONE
[09:28:22.331] Reducing values from 1 chunks ...
[09:28:22.331]  - Number of values collected after concatenation: 3
[09:28:22.331]  - Number of values expected: 3
[09:28:22.331] Reducing values from 1 chunks ... DONE
[09:28:22.331] future_lapply() ... DONE
[09:28:22.331] future_by_internal() ... DONE
[09:28:22.336] future_by_internal() ...
[09:28:22.336] future_lapply() ...
[09:28:22.340] Number of chunks: 1
[09:28:22.340] getGlobalsAndPackagesXApply() ...
[09:28:22.340]  - future.globals: TRUE
[09:28:22.340] getGlobalsAndPackages() ...
[09:28:22.340] Searching for globals...
[09:28:22.342] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:22.342] Searching for globals ... DONE
[09:28:22.342] Resolving globals: FALSE
[09:28:22.342] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[09:28:22.343] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[09:28:22.343] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:22.343] - packages: [1] ‘stats’
[09:28:22.343] getGlobalsAndPackages() ... DONE
[09:28:22.343]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:22.343]  - needed namespaces: [n=1] ‘stats’
[09:28:22.343] Finding globals ... DONE
[09:28:22.343]  - use_args: TRUE
[09:28:22.343]  - Getting '...' globals ...
[09:28:22.344] resolve() on list ...
[09:28:22.344]  recursive: 0
[09:28:22.344]  length: 1
[09:28:22.344]  elements: ‘...’
[09:28:22.344]  length: 0 (resolved future 1)
[09:28:22.344] resolve() on list ... DONE
[09:28:22.344]    - '...' content: [n=0] 
[09:28:22.344] List of 1
[09:28:22.344]  $ ...: list()
[09:28:22.344]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.344]  - attr(*, "where")=List of 1
[09:28:22.344]   ..$ ...:<environment: 0x555b08f6f8b8> 
[09:28:22.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.344]  - attr(*, "resolved")= logi TRUE
[09:28:22.344]  - attr(*, "total_size")= num NA
[09:28:22.347]  - Getting '...' globals ... DONE
[09:28:22.347] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[09:28:22.347] List of 4
[09:28:22.347]  $ ...future.FUN:function (x)  
[09:28:22.347]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:22.347]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.347]  $ ...          : list()
[09:28:22.347]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.347]  - attr(*, "where")=List of 4
[09:28:22.347]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.347]   ..$ breaks       :<environment: R_EmptyEnv> 
[09:28:22.347]   ..$ wool         :<environment: R_EmptyEnv> 
[09:28:22.347]   ..$ ...          :<environment: 0x555b08f6f8b8> 
[09:28:22.347]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.347]  - attr(*, "resolved")= logi FALSE
[09:28:22.347]  - attr(*, "total_size")= num 2320
[09:28:22.351] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:22.351] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.351] Number of futures (= number of chunks): 1
[09:28:22.351] Launching 1 futures (chunks) ...
[09:28:22.351] Chunk #1 of 1 ...
[09:28:22.351]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.351] getGlobalsAndPackages() ...
[09:28:22.351] Searching for globals...
[09:28:22.352] 
[09:28:22.352] Searching for globals ... DONE
[09:28:22.352] - globals: [0] <none>
[09:28:22.352] getGlobalsAndPackages() ... DONE
[09:28:22.352]    + additional globals found: [n=0] 
[09:28:22.352]    + additional namespaces needed: [n=0] 
[09:28:22.352]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.352]  - seeds: <none>
[09:28:22.352]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.353] getGlobalsAndPackages() ...
[09:28:22.353] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.353] Resolving globals: FALSE
[09:28:22.353] Tweak future expression to call with '...' arguments ...
[09:28:22.353] {
[09:28:22.353]     do.call(function(...) {
[09:28:22.353]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.353]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.353]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.353]             on.exit(options(oopts), add = TRUE)
[09:28:22.353]         }
[09:28:22.353]         {
[09:28:22.353]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.353]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.353]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.353]             })
[09:28:22.353]         }
[09:28:22.353]     }, args = future.call.arguments)
[09:28:22.353] }
[09:28:22.353] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.354] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.354] 
[09:28:22.354] getGlobalsAndPackages() ... DONE
[09:28:22.355] run() for ‘Future’ ...
[09:28:22.355] - state: ‘created’
[09:28:22.355] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.358] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.359]   - Field: ‘label’
[09:28:22.359]   - Field: ‘local’
[09:28:22.359]   - Field: ‘owner’
[09:28:22.359]   - Field: ‘envir’
[09:28:22.359]   - Field: ‘packages’
[09:28:22.359]   - Field: ‘gc’
[09:28:22.359]   - Field: ‘conditions’
[09:28:22.359]   - Field: ‘expr’
[09:28:22.359]   - Field: ‘uuid’
[09:28:22.360]   - Field: ‘seed’
[09:28:22.360]   - Field: ‘version’
[09:28:22.360]   - Field: ‘result’
[09:28:22.360]   - Field: ‘asynchronous’
[09:28:22.360]   - Field: ‘calls’
[09:28:22.360]   - Field: ‘globals’
[09:28:22.360]   - Field: ‘stdout’
[09:28:22.360]   - Field: ‘earlySignal’
[09:28:22.360]   - Field: ‘lazy’
[09:28:22.360]   - Field: ‘state’
[09:28:22.360] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.361] - Launch lazy future ...
[09:28:22.361] Packages needed by the future expression (n = 1): ‘stats’
[09:28:22.361] Packages needed by future strategies (n = 0): <none>
[09:28:22.361] {
[09:28:22.361]     {
[09:28:22.361]         {
[09:28:22.361]             ...future.startTime <- base::Sys.time()
[09:28:22.361]             {
[09:28:22.361]                 {
[09:28:22.361]                   {
[09:28:22.361]                     {
[09:28:22.361]                       base::local({
[09:28:22.361]                         has_future <- base::requireNamespace("future", 
[09:28:22.361]                           quietly = TRUE)
[09:28:22.361]                         if (has_future) {
[09:28:22.361]                           ns <- base::getNamespace("future")
[09:28:22.361]                           version <- ns[[".package"]][["version"]]
[09:28:22.361]                           if (is.null(version)) 
[09:28:22.361]                             version <- utils::packageVersion("future")
[09:28:22.361]                         }
[09:28:22.361]                         else {
[09:28:22.361]                           version <- NULL
[09:28:22.361]                         }
[09:28:22.361]                         if (!has_future || version < "1.8.0") {
[09:28:22.361]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.361]                             "", base::R.version$version.string), 
[09:28:22.361]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:22.361]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.361]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.361]                               "release", "version")], collapse = " "), 
[09:28:22.361]                             hostname = base::Sys.info()[["nodename"]])
[09:28:22.361]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.361]                             info)
[09:28:22.361]                           info <- base::paste(info, collapse = "; ")
[09:28:22.361]                           if (!has_future) {
[09:28:22.361]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.361]                               info)
[09:28:22.361]                           }
[09:28:22.361]                           else {
[09:28:22.361]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.361]                               info, version)
[09:28:22.361]                           }
[09:28:22.361]                           base::stop(msg)
[09:28:22.361]                         }
[09:28:22.361]                       })
[09:28:22.361]                     }
[09:28:22.361]                     base::local({
[09:28:22.361]                       for (pkg in "stats") {
[09:28:22.361]                         base::loadNamespace(pkg)
[09:28:22.361]                         base::library(pkg, character.only = TRUE)
[09:28:22.361]                       }
[09:28:22.361]                     })
[09:28:22.361]                   }
[09:28:22.361]                   ...future.strategy.old <- future::plan("list")
[09:28:22.361]                   options(future.plan = NULL)
[09:28:22.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.361]                 }
[09:28:22.361]                 ...future.workdir <- getwd()
[09:28:22.361]             }
[09:28:22.361]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.361]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.361]         }
[09:28:22.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.361]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.361]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.361]             base::names(...future.oldOptions))
[09:28:22.361]     }
[09:28:22.361]     if (FALSE) {
[09:28:22.361]     }
[09:28:22.361]     else {
[09:28:22.361]         if (TRUE) {
[09:28:22.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.361]                 open = "w")
[09:28:22.361]         }
[09:28:22.361]         else {
[09:28:22.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.361]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.361]         }
[09:28:22.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.361]             base::sink(type = "output", split = FALSE)
[09:28:22.361]             base::close(...future.stdout)
[09:28:22.361]         }, add = TRUE)
[09:28:22.361]     }
[09:28:22.361]     ...future.frame <- base::sys.nframe()
[09:28:22.361]     ...future.conditions <- base::list()
[09:28:22.361]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.361]     if (FALSE) {
[09:28:22.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.361]     }
[09:28:22.361]     ...future.result <- base::tryCatch({
[09:28:22.361]         base::withCallingHandlers({
[09:28:22.361]             ...future.value <- base::withVisible(base::local({
[09:28:22.361]                 do.call(function(...) {
[09:28:22.361]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.361]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.361]                     ...future.globals.maxSize)) {
[09:28:22.361]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.361]                     on.exit(options(oopts), add = TRUE)
[09:28:22.361]                   }
[09:28:22.361]                   {
[09:28:22.361]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.361]                       FUN = function(jj) {
[09:28:22.361]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.361]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.361]                       })
[09:28:22.361]                   }
[09:28:22.361]                 }, args = future.call.arguments)
[09:28:22.361]             }))
[09:28:22.361]             future::FutureResult(value = ...future.value$value, 
[09:28:22.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.361]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.361]                     ...future.globalenv.names))
[09:28:22.361]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.361]         }, condition = base::local({
[09:28:22.361]             c <- base::c
[09:28:22.361]             inherits <- base::inherits
[09:28:22.361]             invokeRestart <- base::invokeRestart
[09:28:22.361]             length <- base::length
[09:28:22.361]             list <- base::list
[09:28:22.361]             seq.int <- base::seq.int
[09:28:22.361]             signalCondition <- base::signalCondition
[09:28:22.361]             sys.calls <- base::sys.calls
[09:28:22.361]             `[[` <- base::`[[`
[09:28:22.361]             `+` <- base::`+`
[09:28:22.361]             `<<-` <- base::`<<-`
[09:28:22.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.361]                   3L)]
[09:28:22.361]             }
[09:28:22.361]             function(cond) {
[09:28:22.361]                 is_error <- inherits(cond, "error")
[09:28:22.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.361]                   NULL)
[09:28:22.361]                 if (is_error) {
[09:28:22.361]                   sessionInformation <- function() {
[09:28:22.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.361]                       search = base::search(), system = base::Sys.info())
[09:28:22.361]                   }
[09:28:22.361]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.361]                     cond$call), session = sessionInformation(), 
[09:28:22.361]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.361]                   signalCondition(cond)
[09:28:22.361]                 }
[09:28:22.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.361]                 "immediateCondition"))) {
[09:28:22.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.361]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.361]                   if (TRUE && !signal) {
[09:28:22.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.361]                     {
[09:28:22.361]                       inherits <- base::inherits
[09:28:22.361]                       invokeRestart <- base::invokeRestart
[09:28:22.361]                       is.null <- base::is.null
[09:28:22.361]                       muffled <- FALSE
[09:28:22.361]                       if (inherits(cond, "message")) {
[09:28:22.361]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.361]                         if (muffled) 
[09:28:22.361]                           invokeRestart("muffleMessage")
[09:28:22.361]                       }
[09:28:22.361]                       else if (inherits(cond, "warning")) {
[09:28:22.361]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.361]                         if (muffled) 
[09:28:22.361]                           invokeRestart("muffleWarning")
[09:28:22.361]                       }
[09:28:22.361]                       else if (inherits(cond, "condition")) {
[09:28:22.361]                         if (!is.null(pattern)) {
[09:28:22.361]                           computeRestarts <- base::computeRestarts
[09:28:22.361]                           grepl <- base::grepl
[09:28:22.361]                           restarts <- computeRestarts(cond)
[09:28:22.361]                           for (restart in restarts) {
[09:28:22.361]                             name <- restart$name
[09:28:22.361]                             if (is.null(name)) 
[09:28:22.361]                               next
[09:28:22.361]                             if (!grepl(pattern, name)) 
[09:28:22.361]                               next
[09:28:22.361]                             invokeRestart(restart)
[09:28:22.361]                             muffled <- TRUE
[09:28:22.361]                             break
[09:28:22.361]                           }
[09:28:22.361]                         }
[09:28:22.361]                       }
[09:28:22.361]                       invisible(muffled)
[09:28:22.361]                     }
[09:28:22.361]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.361]                   }
[09:28:22.361]                 }
[09:28:22.361]                 else {
[09:28:22.361]                   if (TRUE) {
[09:28:22.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.361]                     {
[09:28:22.361]                       inherits <- base::inherits
[09:28:22.361]                       invokeRestart <- base::invokeRestart
[09:28:22.361]                       is.null <- base::is.null
[09:28:22.361]                       muffled <- FALSE
[09:28:22.361]                       if (inherits(cond, "message")) {
[09:28:22.361]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.361]                         if (muffled) 
[09:28:22.361]                           invokeRestart("muffleMessage")
[09:28:22.361]                       }
[09:28:22.361]                       else if (inherits(cond, "warning")) {
[09:28:22.361]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.361]                         if (muffled) 
[09:28:22.361]                           invokeRestart("muffleWarning")
[09:28:22.361]                       }
[09:28:22.361]                       else if (inherits(cond, "condition")) {
[09:28:22.361]                         if (!is.null(pattern)) {
[09:28:22.361]                           computeRestarts <- base::computeRestarts
[09:28:22.361]                           grepl <- base::grepl
[09:28:22.361]                           restarts <- computeRestarts(cond)
[09:28:22.361]                           for (restart in restarts) {
[09:28:22.361]                             name <- restart$name
[09:28:22.361]                             if (is.null(name)) 
[09:28:22.361]                               next
[09:28:22.361]                             if (!grepl(pattern, name)) 
[09:28:22.361]                               next
[09:28:22.361]                             invokeRestart(restart)
[09:28:22.361]                             muffled <- TRUE
[09:28:22.361]                             break
[09:28:22.361]                           }
[09:28:22.361]                         }
[09:28:22.361]                       }
[09:28:22.361]                       invisible(muffled)
[09:28:22.361]                     }
[09:28:22.361]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.361]                   }
[09:28:22.361]                 }
[09:28:22.361]             }
[09:28:22.361]         }))
[09:28:22.361]     }, error = function(ex) {
[09:28:22.361]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.361]                 ...future.rng), started = ...future.startTime, 
[09:28:22.361]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.361]             version = "1.8"), class = "FutureResult")
[09:28:22.361]     }, finally = {
[09:28:22.361]         if (!identical(...future.workdir, getwd())) 
[09:28:22.361]             setwd(...future.workdir)
[09:28:22.361]         {
[09:28:22.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.361]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.361]             }
[09:28:22.361]             base::options(...future.oldOptions)
[09:28:22.361]             if (.Platform$OS.type == "windows") {
[09:28:22.361]                 old_names <- names(...future.oldEnvVars)
[09:28:22.361]                 envs <- base::Sys.getenv()
[09:28:22.361]                 names <- names(envs)
[09:28:22.361]                 common <- intersect(names, old_names)
[09:28:22.361]                 added <- setdiff(names, old_names)
[09:28:22.361]                 removed <- setdiff(old_names, names)
[09:28:22.361]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.361]                   envs[common]]
[09:28:22.361]                 NAMES <- toupper(changed)
[09:28:22.361]                 args <- list()
[09:28:22.361]                 for (kk in seq_along(NAMES)) {
[09:28:22.361]                   name <- changed[[kk]]
[09:28:22.361]                   NAME <- NAMES[[kk]]
[09:28:22.361]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.361]                     next
[09:28:22.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.361]                 }
[09:28:22.361]                 NAMES <- toupper(added)
[09:28:22.361]                 for (kk in seq_along(NAMES)) {
[09:28:22.361]                   name <- added[[kk]]
[09:28:22.361]                   NAME <- NAMES[[kk]]
[09:28:22.361]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.361]                     next
[09:28:22.361]                   args[[name]] <- ""
[09:28:22.361]                 }
[09:28:22.361]                 NAMES <- toupper(removed)
[09:28:22.361]                 for (kk in seq_along(NAMES)) {
[09:28:22.361]                   name <- removed[[kk]]
[09:28:22.361]                   NAME <- NAMES[[kk]]
[09:28:22.361]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.361]                     next
[09:28:22.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.361]                 }
[09:28:22.361]                 if (length(args) > 0) 
[09:28:22.361]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.361]             }
[09:28:22.361]             else {
[09:28:22.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.361]             }
[09:28:22.361]             {
[09:28:22.361]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.361]                   0L) {
[09:28:22.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.361]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.361]                   base::options(opts)
[09:28:22.361]                 }
[09:28:22.361]                 {
[09:28:22.361]                   {
[09:28:22.361]                     NULL
[09:28:22.361]                     RNGkind("Mersenne-Twister")
[09:28:22.361]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.361]                       inherits = FALSE)
[09:28:22.361]                   }
[09:28:22.361]                   options(future.plan = NULL)
[09:28:22.361]                   if (is.na(NA_character_)) 
[09:28:22.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.361]                     .init = FALSE)
[09:28:22.361]                 }
[09:28:22.361]             }
[09:28:22.361]         }
[09:28:22.361]     })
[09:28:22.361]     if (TRUE) {
[09:28:22.361]         base::sink(type = "output", split = FALSE)
[09:28:22.361]         if (TRUE) {
[09:28:22.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.361]         }
[09:28:22.361]         else {
[09:28:22.361]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.361]         }
[09:28:22.361]         base::close(...future.stdout)
[09:28:22.361]         ...future.stdout <- NULL
[09:28:22.361]     }
[09:28:22.361]     ...future.result$conditions <- ...future.conditions
[09:28:22.361]     ...future.result$finished <- base::Sys.time()
[09:28:22.361]     ...future.result
[09:28:22.361] }
[09:28:22.363] assign_globals() ...
[09:28:22.363] List of 7
[09:28:22.363]  $ ...future.FUN            :function (x)  
[09:28:22.363]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:22.363]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.363]  $ future.call.arguments    : list()
[09:28:22.363]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.363]  $ ...future.elements_ii    :List of 3
[09:28:22.363]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.363]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.363]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.363]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.363]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.363]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.363]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.363]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.363]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.363]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.363]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.363]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.363]  $ ...future.seeds_ii       : NULL
[09:28:22.363]  $ ...future.globals.maxSize: NULL
[09:28:22.363]  - attr(*, "where")=List of 7
[09:28:22.363]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.363]   ..$ breaks                   :<environment: R_EmptyEnv> 
[09:28:22.363]   ..$ wool                     :<environment: R_EmptyEnv> 
[09:28:22.363]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.363]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.363]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.363]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.363]  - attr(*, "resolved")= logi FALSE
[09:28:22.363]  - attr(*, "total_size")= num 2320
[09:28:22.363]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.363]  - attr(*, "already-done")= logi TRUE
[09:28:22.372] - reassign environment for ‘...future.FUN’
[09:28:22.372] - copied ‘...future.FUN’ to environment
[09:28:22.372] - copied ‘breaks’ to environment
[09:28:22.372] - copied ‘wool’ to environment
[09:28:22.372] - copied ‘future.call.arguments’ to environment
[09:28:22.372] - copied ‘...future.elements_ii’ to environment
[09:28:22.373] - copied ‘...future.seeds_ii’ to environment
[09:28:22.373] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.373] assign_globals() ... done
[09:28:22.373] plan(): Setting new future strategy stack:
[09:28:22.373] List of future strategies:
[09:28:22.373] 1. sequential:
[09:28:22.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.373]    - tweaked: FALSE
[09:28:22.373]    - call: NULL
[09:28:22.374] plan(): nbrOfWorkers() = 1
[09:28:22.376] plan(): Setting new future strategy stack:
[09:28:22.376] List of future strategies:
[09:28:22.376] 1. multicore:
[09:28:22.376]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:22.376]    - tweaked: FALSE
[09:28:22.376]    - call: plan(strategy)
[09:28:22.379] plan(): nbrOfWorkers() = 1
[09:28:22.380] SequentialFuture started (and completed)
[09:28:22.380] - Launch lazy future ... done
[09:28:22.380] run() for ‘SequentialFuture’ ... done
[09:28:22.380] Created future:
[09:28:22.380] SequentialFuture:
[09:28:22.380] Label: ‘future_by-1’
[09:28:22.380] Expression:
[09:28:22.380] {
[09:28:22.380]     do.call(function(...) {
[09:28:22.380]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.380]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.380]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.380]             on.exit(options(oopts), add = TRUE)
[09:28:22.380]         }
[09:28:22.380]         {
[09:28:22.380]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.380]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.380]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.380]             })
[09:28:22.380]         }
[09:28:22.380]     }, args = future.call.arguments)
[09:28:22.380] }
[09:28:22.380] Lazy evaluation: FALSE
[09:28:22.380] Asynchronous evaluation: FALSE
[09:28:22.380] Local evaluation: TRUE
[09:28:22.380] Environment: 0x555b0917eab0
[09:28:22.380] Capture standard output: TRUE
[09:28:22.380] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.380] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[09:28:22.380] Packages: 1 packages (‘stats’)
[09:28:22.380] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.380] Resolved: TRUE
[09:28:22.380] Value: 25.57 KiB of class ‘list’
[09:28:22.380] Early signaling: FALSE
[09:28:22.380] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.380] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.383] Chunk #1 of 1 ... DONE
[09:28:22.383] Launching 1 futures (chunks) ... DONE
[09:28:22.383] Resolving 1 futures (chunks) ...
[09:28:22.383] resolve() on list ...
[09:28:22.383]  recursive: 0
[09:28:22.383]  length: 1
[09:28:22.383] 
[09:28:22.383] resolved() for ‘SequentialFuture’ ...
[09:28:22.383] - state: ‘finished’
[09:28:22.383] - run: TRUE
[09:28:22.383] - result: ‘FutureResult’
[09:28:22.384] resolved() for ‘SequentialFuture’ ... done
[09:28:22.384] Future #1
[09:28:22.384] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.384] - nx: 1
[09:28:22.384] - relay: TRUE
[09:28:22.384] - stdout: TRUE
[09:28:22.384] - signal: TRUE
[09:28:22.384] - resignal: FALSE
[09:28:22.384] - force: TRUE
[09:28:22.384] - relayed: [n=1] FALSE
[09:28:22.384] - queued futures: [n=1] FALSE
[09:28:22.385]  - until=1
[09:28:22.385]  - relaying element #1
[09:28:22.385] - relayed: [n=1] TRUE
[09:28:22.385] - queued futures: [n=1] TRUE
[09:28:22.385] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.385]  length: 0 (resolved future 1)
[09:28:22.385] Relaying remaining futures
[09:28:22.385] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.385] - nx: 1
[09:28:22.385] - relay: TRUE
[09:28:22.385] - stdout: TRUE
[09:28:22.386] - signal: TRUE
[09:28:22.386] - resignal: FALSE
[09:28:22.386] - force: TRUE
[09:28:22.386] - relayed: [n=1] TRUE
[09:28:22.386] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.386] - relayed: [n=1] TRUE
[09:28:22.386] - queued futures: [n=1] TRUE
[09:28:22.386] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.386] resolve() on list ... DONE
[09:28:22.386]  - Number of value chunks collected: 1
[09:28:22.386] Resolving 1 futures (chunks) ... DONE
[09:28:22.387] Reducing values from 1 chunks ...
[09:28:22.387]  - Number of values collected after concatenation: 3
[09:28:22.387]  - Number of values expected: 3
[09:28:22.387] Reducing values from 1 chunks ... DONE
[09:28:22.387] future_lapply() ... DONE
[09:28:22.387] future_by_internal() ... DONE
[09:28:22.387] future_by_internal() ...
[09:28:22.388] future_lapply() ...
[09:28:22.391] Number of chunks: 1
[09:28:22.391] getGlobalsAndPackagesXApply() ...
[09:28:22.391]  - future.globals: TRUE
[09:28:22.391] getGlobalsAndPackages() ...
[09:28:22.391] Searching for globals...
[09:28:22.392] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.392] Searching for globals ... DONE
[09:28:22.393] Resolving globals: FALSE
[09:28:22.393] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.393] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.393] - globals: [1] ‘FUN’
[09:28:22.393] 
[09:28:22.393] getGlobalsAndPackages() ... DONE
[09:28:22.394]  - globals found/used: [n=1] ‘FUN’
[09:28:22.394]  - needed namespaces: [n=0] 
[09:28:22.394] Finding globals ... DONE
[09:28:22.394]  - use_args: TRUE
[09:28:22.394]  - Getting '...' globals ...
[09:28:22.394] resolve() on list ...
[09:28:22.394]  recursive: 0
[09:28:22.394]  length: 1
[09:28:22.394]  elements: ‘...’
[09:28:22.395]  length: 0 (resolved future 1)
[09:28:22.395] resolve() on list ... DONE
[09:28:22.395]    - '...' content: [n=0] 
[09:28:22.395] List of 1
[09:28:22.395]  $ ...: list()
[09:28:22.395]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.395]  - attr(*, "where")=List of 1
[09:28:22.395]   ..$ ...:<environment: 0x555b08522618> 
[09:28:22.395]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.395]  - attr(*, "resolved")= logi TRUE
[09:28:22.395]  - attr(*, "total_size")= num NA
[09:28:22.397]  - Getting '...' globals ... DONE
[09:28:22.397] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.397] List of 2
[09:28:22.397]  $ ...future.FUN:function (object, ...)  
[09:28:22.397]  $ ...          : list()
[09:28:22.397]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.397]  - attr(*, "where")=List of 2
[09:28:22.397]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.397]   ..$ ...          :<environment: 0x555b08522618> 
[09:28:22.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.397]  - attr(*, "resolved")= logi FALSE
[09:28:22.397]  - attr(*, "total_size")= num 1240
[09:28:22.400] Packages to be attached in all futures: [n=0] 
[09:28:22.400] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.400] Number of futures (= number of chunks): 1
[09:28:22.400] Launching 1 futures (chunks) ...
[09:28:22.400] Chunk #1 of 1 ...
[09:28:22.400]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.401] getGlobalsAndPackages() ...
[09:28:22.401] Searching for globals...
[09:28:22.401] 
[09:28:22.401] Searching for globals ... DONE
[09:28:22.401] - globals: [0] <none>
[09:28:22.401] getGlobalsAndPackages() ... DONE
[09:28:22.401]    + additional globals found: [n=0] 
[09:28:22.401]    + additional namespaces needed: [n=0] 
[09:28:22.402]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.402]  - seeds: <none>
[09:28:22.402]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.402] getGlobalsAndPackages() ...
[09:28:22.402] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.402] Resolving globals: FALSE
[09:28:22.402] Tweak future expression to call with '...' arguments ...
[09:28:22.402] {
[09:28:22.402]     do.call(function(...) {
[09:28:22.402]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.402]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.402]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.402]             on.exit(options(oopts), add = TRUE)
[09:28:22.402]         }
[09:28:22.402]         {
[09:28:22.402]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.402]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.402]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.402]             })
[09:28:22.402]         }
[09:28:22.402]     }, args = future.call.arguments)
[09:28:22.402] }
[09:28:22.402] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.403] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.403] 
[09:28:22.403] getGlobalsAndPackages() ... DONE
[09:28:22.403] run() for ‘Future’ ...
[09:28:22.403] - state: ‘created’
[09:28:22.403] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.408] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.408]   - Field: ‘label’
[09:28:22.408]   - Field: ‘local’
[09:28:22.408]   - Field: ‘owner’
[09:28:22.408]   - Field: ‘envir’
[09:28:22.408]   - Field: ‘packages’
[09:28:22.408]   - Field: ‘gc’
[09:28:22.409]   - Field: ‘conditions’
[09:28:22.409]   - Field: ‘expr’
[09:28:22.409]   - Field: ‘uuid’
[09:28:22.409]   - Field: ‘seed’
[09:28:22.409]   - Field: ‘version’
[09:28:22.409]   - Field: ‘result’
[09:28:22.409]   - Field: ‘asynchronous’
[09:28:22.409]   - Field: ‘calls’
[09:28:22.409]   - Field: ‘globals’
[09:28:22.409]   - Field: ‘stdout’
[09:28:22.409]   - Field: ‘earlySignal’
[09:28:22.409]   - Field: ‘lazy’
[09:28:22.410]   - Field: ‘state’
[09:28:22.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.410] - Launch lazy future ...
[09:28:22.410] Packages needed by the future expression (n = 0): <none>
[09:28:22.410] Packages needed by future strategies (n = 0): <none>
[09:28:22.410] {
[09:28:22.410]     {
[09:28:22.410]         {
[09:28:22.410]             ...future.startTime <- base::Sys.time()
[09:28:22.410]             {
[09:28:22.410]                 {
[09:28:22.410]                   {
[09:28:22.410]                     base::local({
[09:28:22.410]                       has_future <- base::requireNamespace("future", 
[09:28:22.410]                         quietly = TRUE)
[09:28:22.410]                       if (has_future) {
[09:28:22.410]                         ns <- base::getNamespace("future")
[09:28:22.410]                         version <- ns[[".package"]][["version"]]
[09:28:22.410]                         if (is.null(version)) 
[09:28:22.410]                           version <- utils::packageVersion("future")
[09:28:22.410]                       }
[09:28:22.410]                       else {
[09:28:22.410]                         version <- NULL
[09:28:22.410]                       }
[09:28:22.410]                       if (!has_future || version < "1.8.0") {
[09:28:22.410]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.410]                           "", base::R.version$version.string), 
[09:28:22.410]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.410]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.410]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.410]                             "release", "version")], collapse = " "), 
[09:28:22.410]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.410]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.410]                           info)
[09:28:22.410]                         info <- base::paste(info, collapse = "; ")
[09:28:22.410]                         if (!has_future) {
[09:28:22.410]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.410]                             info)
[09:28:22.410]                         }
[09:28:22.410]                         else {
[09:28:22.410]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.410]                             info, version)
[09:28:22.410]                         }
[09:28:22.410]                         base::stop(msg)
[09:28:22.410]                       }
[09:28:22.410]                     })
[09:28:22.410]                   }
[09:28:22.410]                   ...future.strategy.old <- future::plan("list")
[09:28:22.410]                   options(future.plan = NULL)
[09:28:22.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.410]                 }
[09:28:22.410]                 ...future.workdir <- getwd()
[09:28:22.410]             }
[09:28:22.410]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.410]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.410]         }
[09:28:22.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.410]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.410]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.410]             base::names(...future.oldOptions))
[09:28:22.410]     }
[09:28:22.410]     if (FALSE) {
[09:28:22.410]     }
[09:28:22.410]     else {
[09:28:22.410]         if (TRUE) {
[09:28:22.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.410]                 open = "w")
[09:28:22.410]         }
[09:28:22.410]         else {
[09:28:22.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.410]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.410]         }
[09:28:22.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.410]             base::sink(type = "output", split = FALSE)
[09:28:22.410]             base::close(...future.stdout)
[09:28:22.410]         }, add = TRUE)
[09:28:22.410]     }
[09:28:22.410]     ...future.frame <- base::sys.nframe()
[09:28:22.410]     ...future.conditions <- base::list()
[09:28:22.410]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.410]     if (FALSE) {
[09:28:22.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.410]     }
[09:28:22.410]     ...future.result <- base::tryCatch({
[09:28:22.410]         base::withCallingHandlers({
[09:28:22.410]             ...future.value <- base::withVisible(base::local({
[09:28:22.410]                 do.call(function(...) {
[09:28:22.410]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.410]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.410]                     ...future.globals.maxSize)) {
[09:28:22.410]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.410]                     on.exit(options(oopts), add = TRUE)
[09:28:22.410]                   }
[09:28:22.410]                   {
[09:28:22.410]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.410]                       FUN = function(jj) {
[09:28:22.410]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.410]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.410]                       })
[09:28:22.410]                   }
[09:28:22.410]                 }, args = future.call.arguments)
[09:28:22.410]             }))
[09:28:22.410]             future::FutureResult(value = ...future.value$value, 
[09:28:22.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.410]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.410]                     ...future.globalenv.names))
[09:28:22.410]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.410]         }, condition = base::local({
[09:28:22.410]             c <- base::c
[09:28:22.410]             inherits <- base::inherits
[09:28:22.410]             invokeRestart <- base::invokeRestart
[09:28:22.410]             length <- base::length
[09:28:22.410]             list <- base::list
[09:28:22.410]             seq.int <- base::seq.int
[09:28:22.410]             signalCondition <- base::signalCondition
[09:28:22.410]             sys.calls <- base::sys.calls
[09:28:22.410]             `[[` <- base::`[[`
[09:28:22.410]             `+` <- base::`+`
[09:28:22.410]             `<<-` <- base::`<<-`
[09:28:22.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.410]                   3L)]
[09:28:22.410]             }
[09:28:22.410]             function(cond) {
[09:28:22.410]                 is_error <- inherits(cond, "error")
[09:28:22.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.410]                   NULL)
[09:28:22.410]                 if (is_error) {
[09:28:22.410]                   sessionInformation <- function() {
[09:28:22.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.410]                       search = base::search(), system = base::Sys.info())
[09:28:22.410]                   }
[09:28:22.410]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.410]                     cond$call), session = sessionInformation(), 
[09:28:22.410]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.410]                   signalCondition(cond)
[09:28:22.410]                 }
[09:28:22.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.410]                 "immediateCondition"))) {
[09:28:22.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.410]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.410]                   if (TRUE && !signal) {
[09:28:22.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.410]                     {
[09:28:22.410]                       inherits <- base::inherits
[09:28:22.410]                       invokeRestart <- base::invokeRestart
[09:28:22.410]                       is.null <- base::is.null
[09:28:22.410]                       muffled <- FALSE
[09:28:22.410]                       if (inherits(cond, "message")) {
[09:28:22.410]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.410]                         if (muffled) 
[09:28:22.410]                           invokeRestart("muffleMessage")
[09:28:22.410]                       }
[09:28:22.410]                       else if (inherits(cond, "warning")) {
[09:28:22.410]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.410]                         if (muffled) 
[09:28:22.410]                           invokeRestart("muffleWarning")
[09:28:22.410]                       }
[09:28:22.410]                       else if (inherits(cond, "condition")) {
[09:28:22.410]                         if (!is.null(pattern)) {
[09:28:22.410]                           computeRestarts <- base::computeRestarts
[09:28:22.410]                           grepl <- base::grepl
[09:28:22.410]                           restarts <- computeRestarts(cond)
[09:28:22.410]                           for (restart in restarts) {
[09:28:22.410]                             name <- restart$name
[09:28:22.410]                             if (is.null(name)) 
[09:28:22.410]                               next
[09:28:22.410]                             if (!grepl(pattern, name)) 
[09:28:22.410]                               next
[09:28:22.410]                             invokeRestart(restart)
[09:28:22.410]                             muffled <- TRUE
[09:28:22.410]                             break
[09:28:22.410]                           }
[09:28:22.410]                         }
[09:28:22.410]                       }
[09:28:22.410]                       invisible(muffled)
[09:28:22.410]                     }
[09:28:22.410]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.410]                   }
[09:28:22.410]                 }
[09:28:22.410]                 else {
[09:28:22.410]                   if (TRUE) {
[09:28:22.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.410]                     {
[09:28:22.410]                       inherits <- base::inherits
[09:28:22.410]                       invokeRestart <- base::invokeRestart
[09:28:22.410]                       is.null <- base::is.null
[09:28:22.410]                       muffled <- FALSE
[09:28:22.410]                       if (inherits(cond, "message")) {
[09:28:22.410]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.410]                         if (muffled) 
[09:28:22.410]                           invokeRestart("muffleMessage")
[09:28:22.410]                       }
[09:28:22.410]                       else if (inherits(cond, "warning")) {
[09:28:22.410]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.410]                         if (muffled) 
[09:28:22.410]                           invokeRestart("muffleWarning")
[09:28:22.410]                       }
[09:28:22.410]                       else if (inherits(cond, "condition")) {
[09:28:22.410]                         if (!is.null(pattern)) {
[09:28:22.410]                           computeRestarts <- base::computeRestarts
[09:28:22.410]                           grepl <- base::grepl
[09:28:22.410]                           restarts <- computeRestarts(cond)
[09:28:22.410]                           for (restart in restarts) {
[09:28:22.410]                             name <- restart$name
[09:28:22.410]                             if (is.null(name)) 
[09:28:22.410]                               next
[09:28:22.410]                             if (!grepl(pattern, name)) 
[09:28:22.410]                               next
[09:28:22.410]                             invokeRestart(restart)
[09:28:22.410]                             muffled <- TRUE
[09:28:22.410]                             break
[09:28:22.410]                           }
[09:28:22.410]                         }
[09:28:22.410]                       }
[09:28:22.410]                       invisible(muffled)
[09:28:22.410]                     }
[09:28:22.410]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.410]                   }
[09:28:22.410]                 }
[09:28:22.410]             }
[09:28:22.410]         }))
[09:28:22.410]     }, error = function(ex) {
[09:28:22.410]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.410]                 ...future.rng), started = ...future.startTime, 
[09:28:22.410]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.410]             version = "1.8"), class = "FutureResult")
[09:28:22.410]     }, finally = {
[09:28:22.410]         if (!identical(...future.workdir, getwd())) 
[09:28:22.410]             setwd(...future.workdir)
[09:28:22.410]         {
[09:28:22.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.410]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.410]             }
[09:28:22.410]             base::options(...future.oldOptions)
[09:28:22.410]             if (.Platform$OS.type == "windows") {
[09:28:22.410]                 old_names <- names(...future.oldEnvVars)
[09:28:22.410]                 envs <- base::Sys.getenv()
[09:28:22.410]                 names <- names(envs)
[09:28:22.410]                 common <- intersect(names, old_names)
[09:28:22.410]                 added <- setdiff(names, old_names)
[09:28:22.410]                 removed <- setdiff(old_names, names)
[09:28:22.410]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.410]                   envs[common]]
[09:28:22.410]                 NAMES <- toupper(changed)
[09:28:22.410]                 args <- list()
[09:28:22.410]                 for (kk in seq_along(NAMES)) {
[09:28:22.410]                   name <- changed[[kk]]
[09:28:22.410]                   NAME <- NAMES[[kk]]
[09:28:22.410]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.410]                     next
[09:28:22.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.410]                 }
[09:28:22.410]                 NAMES <- toupper(added)
[09:28:22.410]                 for (kk in seq_along(NAMES)) {
[09:28:22.410]                   name <- added[[kk]]
[09:28:22.410]                   NAME <- NAMES[[kk]]
[09:28:22.410]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.410]                     next
[09:28:22.410]                   args[[name]] <- ""
[09:28:22.410]                 }
[09:28:22.410]                 NAMES <- toupper(removed)
[09:28:22.410]                 for (kk in seq_along(NAMES)) {
[09:28:22.410]                   name <- removed[[kk]]
[09:28:22.410]                   NAME <- NAMES[[kk]]
[09:28:22.410]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.410]                     next
[09:28:22.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.410]                 }
[09:28:22.410]                 if (length(args) > 0) 
[09:28:22.410]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.410]             }
[09:28:22.410]             else {
[09:28:22.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.410]             }
[09:28:22.410]             {
[09:28:22.410]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.410]                   0L) {
[09:28:22.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.410]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.410]                   base::options(opts)
[09:28:22.410]                 }
[09:28:22.410]                 {
[09:28:22.410]                   {
[09:28:22.410]                     NULL
[09:28:22.410]                     RNGkind("Mersenne-Twister")
[09:28:22.410]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.410]                       inherits = FALSE)
[09:28:22.410]                   }
[09:28:22.410]                   options(future.plan = NULL)
[09:28:22.410]                   if (is.na(NA_character_)) 
[09:28:22.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.410]                     .init = FALSE)
[09:28:22.410]                 }
[09:28:22.410]             }
[09:28:22.410]         }
[09:28:22.410]     })
[09:28:22.410]     if (TRUE) {
[09:28:22.410]         base::sink(type = "output", split = FALSE)
[09:28:22.410]         if (TRUE) {
[09:28:22.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.410]         }
[09:28:22.410]         else {
[09:28:22.410]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.410]         }
[09:28:22.410]         base::close(...future.stdout)
[09:28:22.410]         ...future.stdout <- NULL
[09:28:22.410]     }
[09:28:22.410]     ...future.result$conditions <- ...future.conditions
[09:28:22.410]     ...future.result$finished <- base::Sys.time()
[09:28:22.410]     ...future.result
[09:28:22.410] }
[09:28:22.412] assign_globals() ...
[09:28:22.412] List of 5
[09:28:22.412]  $ ...future.FUN            :function (object, ...)  
[09:28:22.412]  $ future.call.arguments    : list()
[09:28:22.412]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.412]  $ ...future.elements_ii    :List of 3
[09:28:22.412]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.412]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.412]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.412]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.412]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.412]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.412]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.412]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.412]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.412]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.412]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.412]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.412]  $ ...future.seeds_ii       : NULL
[09:28:22.412]  $ ...future.globals.maxSize: NULL
[09:28:22.412]  - attr(*, "where")=List of 5
[09:28:22.412]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.412]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.412]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.412]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.412]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.412]  - attr(*, "resolved")= logi FALSE
[09:28:22.412]  - attr(*, "total_size")= num 1240
[09:28:22.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.412]  - attr(*, "already-done")= logi TRUE
[09:28:22.420] - copied ‘...future.FUN’ to environment
[09:28:22.420] - copied ‘future.call.arguments’ to environment
[09:28:22.420] - copied ‘...future.elements_ii’ to environment
[09:28:22.420] - copied ‘...future.seeds_ii’ to environment
[09:28:22.420] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.421] assign_globals() ... done
[09:28:22.421] plan(): Setting new future strategy stack:
[09:28:22.421] List of future strategies:
[09:28:22.421] 1. sequential:
[09:28:22.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.421]    - tweaked: FALSE
[09:28:22.421]    - call: NULL
[09:28:22.421] plan(): nbrOfWorkers() = 1
[09:28:22.423] plan(): Setting new future strategy stack:
[09:28:22.423] List of future strategies:
[09:28:22.423] 1. multicore:
[09:28:22.423]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:22.423]    - tweaked: FALSE
[09:28:22.423]    - call: plan(strategy)
[09:28:22.427] plan(): nbrOfWorkers() = 1
[09:28:22.427] SequentialFuture started (and completed)
[09:28:22.427] - Launch lazy future ... done
[09:28:22.427] run() for ‘SequentialFuture’ ... done
[09:28:22.427] Created future:
[09:28:22.427] SequentialFuture:
[09:28:22.427] Label: ‘future_by-1’
[09:28:22.427] Expression:
[09:28:22.427] {
[09:28:22.427]     do.call(function(...) {
[09:28:22.427]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.427]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.427]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.427]             on.exit(options(oopts), add = TRUE)
[09:28:22.427]         }
[09:28:22.427]         {
[09:28:22.427]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.427]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.427]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.427]             })
[09:28:22.427]         }
[09:28:22.427]     }, args = future.call.arguments)
[09:28:22.427] }
[09:28:22.427] Lazy evaluation: FALSE
[09:28:22.427] Asynchronous evaluation: FALSE
[09:28:22.427] Local evaluation: TRUE
[09:28:22.427] Environment: 0x555b0832f708
[09:28:22.427] Capture standard output: TRUE
[09:28:22.427] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.427] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.427] Packages: <none>
[09:28:22.427] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.427] Resolved: TRUE
[09:28:22.427] Value: 5.37 KiB of class ‘list’
[09:28:22.427] Early signaling: FALSE
[09:28:22.427] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.427] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.429] Chunk #1 of 1 ... DONE
[09:28:22.429] Launching 1 futures (chunks) ... DONE
[09:28:22.429] Resolving 1 futures (chunks) ...
[09:28:22.429] resolve() on list ...
[09:28:22.429]  recursive: 0
[09:28:22.429]  length: 1
[09:28:22.429] 
[09:28:22.429] resolved() for ‘SequentialFuture’ ...
[09:28:22.429] - state: ‘finished’
[09:28:22.429] - run: TRUE
[09:28:22.430] - result: ‘FutureResult’
[09:28:22.430] resolved() for ‘SequentialFuture’ ... done
[09:28:22.430] Future #1
[09:28:22.430] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.430] - nx: 1
[09:28:22.430] - relay: TRUE
[09:28:22.430] - stdout: TRUE
[09:28:22.430] - signal: TRUE
[09:28:22.430] - resignal: FALSE
[09:28:22.430] - force: TRUE
[09:28:22.430] - relayed: [n=1] FALSE
[09:28:22.430] - queued futures: [n=1] FALSE
[09:28:22.431]  - until=1
[09:28:22.431]  - relaying element #1
[09:28:22.431] - relayed: [n=1] TRUE
[09:28:22.431] - queued futures: [n=1] TRUE
[09:28:22.431] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.431]  length: 0 (resolved future 1)
[09:28:22.432] Relaying remaining futures
[09:28:22.432] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.432] - nx: 1
[09:28:22.432] - relay: TRUE
[09:28:22.432] - stdout: TRUE
[09:28:22.433] - signal: TRUE
[09:28:22.433] - resignal: FALSE
[09:28:22.433] - force: TRUE
[09:28:22.433] - relayed: [n=1] TRUE
[09:28:22.433] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.433] - relayed: [n=1] TRUE
[09:28:22.433] - queued futures: [n=1] TRUE
[09:28:22.433] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.433] resolve() on list ... DONE
[09:28:22.433]  - Number of value chunks collected: 1
[09:28:22.433] Resolving 1 futures (chunks) ... DONE
[09:28:22.434] Reducing values from 1 chunks ...
[09:28:22.434]  - Number of values collected after concatenation: 3
[09:28:22.434]  - Number of values expected: 3
[09:28:22.434] Reducing values from 1 chunks ... DONE
[09:28:22.434] future_lapply() ... DONE
[09:28:22.434] future_by_internal() ... DONE
[09:28:22.435] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[09:28:22.435] future_lapply() ...
[09:28:22.439] Number of chunks: 1
[09:28:22.439] getGlobalsAndPackagesXApply() ...
[09:28:22.439]  - future.globals: TRUE
[09:28:22.439] getGlobalsAndPackages() ...
[09:28:22.439] Searching for globals...
[09:28:22.440] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.440] Searching for globals ... DONE
[09:28:22.440] Resolving globals: FALSE
[09:28:22.440] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.441] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.441] - globals: [1] ‘FUN’
[09:28:22.441] 
[09:28:22.441] getGlobalsAndPackages() ... DONE
[09:28:22.441]  - globals found/used: [n=1] ‘FUN’
[09:28:22.441]  - needed namespaces: [n=0] 
[09:28:22.441] Finding globals ... DONE
[09:28:22.441]  - use_args: TRUE
[09:28:22.442]  - Getting '...' globals ...
[09:28:22.442] resolve() on list ...
[09:28:22.442]  recursive: 0
[09:28:22.442]  length: 1
[09:28:22.442]  elements: ‘...’
[09:28:22.442]  length: 0 (resolved future 1)
[09:28:22.442] resolve() on list ... DONE
[09:28:22.442]    - '...' content: [n=0] 
[09:28:22.442] List of 1
[09:28:22.442]  $ ...: list()
[09:28:22.442]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.442]  - attr(*, "where")=List of 1
[09:28:22.442]   ..$ ...:<environment: 0x555b098972b0> 
[09:28:22.442]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.442]  - attr(*, "resolved")= logi TRUE
[09:28:22.442]  - attr(*, "total_size")= num NA
[09:28:22.445]  - Getting '...' globals ... DONE
[09:28:22.445] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.445] List of 2
[09:28:22.445]  $ ...future.FUN:function (object, ...)  
[09:28:22.445]  $ ...          : list()
[09:28:22.445]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.445]  - attr(*, "where")=List of 2
[09:28:22.445]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.445]   ..$ ...          :<environment: 0x555b098972b0> 
[09:28:22.445]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.445]  - attr(*, "resolved")= logi FALSE
[09:28:22.445]  - attr(*, "total_size")= num 1240
[09:28:22.447] Packages to be attached in all futures: [n=0] 
[09:28:22.448] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.448] Number of futures (= number of chunks): 1
[09:28:22.448] Launching 1 futures (chunks) ...
[09:28:22.448] Chunk #1 of 1 ...
[09:28:22.448]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.448] getGlobalsAndPackages() ...
[09:28:22.448] Searching for globals...
[09:28:22.449] 
[09:28:22.449] Searching for globals ... DONE
[09:28:22.449] - globals: [0] <none>
[09:28:22.449] getGlobalsAndPackages() ... DONE
[09:28:22.449]    + additional globals found: [n=0] 
[09:28:22.449]    + additional namespaces needed: [n=0] 
[09:28:22.449]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.449]  - seeds: <none>
[09:28:22.449]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.449] getGlobalsAndPackages() ...
[09:28:22.450] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.450] Resolving globals: FALSE
[09:28:22.450] Tweak future expression to call with '...' arguments ...
[09:28:22.450] {
[09:28:22.450]     do.call(function(...) {
[09:28:22.450]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.450]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.450]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.450]             on.exit(options(oopts), add = TRUE)
[09:28:22.450]         }
[09:28:22.450]         {
[09:28:22.450]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.450]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.450]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.450]             })
[09:28:22.450]         }
[09:28:22.450]     }, args = future.call.arguments)
[09:28:22.450] }
[09:28:22.450] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.450] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.450] 
[09:28:22.451] getGlobalsAndPackages() ... DONE
[09:28:22.451] run() for ‘Future’ ...
[09:28:22.451] - state: ‘created’
[09:28:22.451] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.454] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.455]   - Field: ‘label’
[09:28:22.455]   - Field: ‘local’
[09:28:22.455]   - Field: ‘owner’
[09:28:22.455]   - Field: ‘envir’
[09:28:22.455]   - Field: ‘packages’
[09:28:22.455]   - Field: ‘gc’
[09:28:22.455]   - Field: ‘conditions’
[09:28:22.455]   - Field: ‘expr’
[09:28:22.455]   - Field: ‘uuid’
[09:28:22.455]   - Field: ‘seed’
[09:28:22.455]   - Field: ‘version’
[09:28:22.456]   - Field: ‘result’
[09:28:22.456]   - Field: ‘asynchronous’
[09:28:22.456]   - Field: ‘calls’
[09:28:22.456]   - Field: ‘globals’
[09:28:22.456]   - Field: ‘stdout’
[09:28:22.456]   - Field: ‘earlySignal’
[09:28:22.456]   - Field: ‘lazy’
[09:28:22.456]   - Field: ‘state’
[09:28:22.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.457] - Launch lazy future ...
[09:28:22.458] Packages needed by the future expression (n = 0): <none>
[09:28:22.458] Packages needed by future strategies (n = 0): <none>
[09:28:22.458] {
[09:28:22.458]     {
[09:28:22.458]         {
[09:28:22.458]             ...future.startTime <- base::Sys.time()
[09:28:22.458]             {
[09:28:22.458]                 {
[09:28:22.458]                   {
[09:28:22.458]                     base::local({
[09:28:22.458]                       has_future <- base::requireNamespace("future", 
[09:28:22.458]                         quietly = TRUE)
[09:28:22.458]                       if (has_future) {
[09:28:22.458]                         ns <- base::getNamespace("future")
[09:28:22.458]                         version <- ns[[".package"]][["version"]]
[09:28:22.458]                         if (is.null(version)) 
[09:28:22.458]                           version <- utils::packageVersion("future")
[09:28:22.458]                       }
[09:28:22.458]                       else {
[09:28:22.458]                         version <- NULL
[09:28:22.458]                       }
[09:28:22.458]                       if (!has_future || version < "1.8.0") {
[09:28:22.458]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.458]                           "", base::R.version$version.string), 
[09:28:22.458]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.458]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.458]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.458]                             "release", "version")], collapse = " "), 
[09:28:22.458]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.458]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.458]                           info)
[09:28:22.458]                         info <- base::paste(info, collapse = "; ")
[09:28:22.458]                         if (!has_future) {
[09:28:22.458]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.458]                             info)
[09:28:22.458]                         }
[09:28:22.458]                         else {
[09:28:22.458]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.458]                             info, version)
[09:28:22.458]                         }
[09:28:22.458]                         base::stop(msg)
[09:28:22.458]                       }
[09:28:22.458]                     })
[09:28:22.458]                   }
[09:28:22.458]                   ...future.strategy.old <- future::plan("list")
[09:28:22.458]                   options(future.plan = NULL)
[09:28:22.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.458]                 }
[09:28:22.458]                 ...future.workdir <- getwd()
[09:28:22.458]             }
[09:28:22.458]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.458]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.458]         }
[09:28:22.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.458]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.458]             base::names(...future.oldOptions))
[09:28:22.458]     }
[09:28:22.458]     if (FALSE) {
[09:28:22.458]     }
[09:28:22.458]     else {
[09:28:22.458]         if (TRUE) {
[09:28:22.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.458]                 open = "w")
[09:28:22.458]         }
[09:28:22.458]         else {
[09:28:22.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.458]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.458]         }
[09:28:22.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.458]             base::sink(type = "output", split = FALSE)
[09:28:22.458]             base::close(...future.stdout)
[09:28:22.458]         }, add = TRUE)
[09:28:22.458]     }
[09:28:22.458]     ...future.frame <- base::sys.nframe()
[09:28:22.458]     ...future.conditions <- base::list()
[09:28:22.458]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.458]     if (FALSE) {
[09:28:22.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.458]     }
[09:28:22.458]     ...future.result <- base::tryCatch({
[09:28:22.458]         base::withCallingHandlers({
[09:28:22.458]             ...future.value <- base::withVisible(base::local({
[09:28:22.458]                 do.call(function(...) {
[09:28:22.458]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.458]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.458]                     ...future.globals.maxSize)) {
[09:28:22.458]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.458]                     on.exit(options(oopts), add = TRUE)
[09:28:22.458]                   }
[09:28:22.458]                   {
[09:28:22.458]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.458]                       FUN = function(jj) {
[09:28:22.458]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.458]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.458]                       })
[09:28:22.458]                   }
[09:28:22.458]                 }, args = future.call.arguments)
[09:28:22.458]             }))
[09:28:22.458]             future::FutureResult(value = ...future.value$value, 
[09:28:22.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.458]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.458]                     ...future.globalenv.names))
[09:28:22.458]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.458]         }, condition = base::local({
[09:28:22.458]             c <- base::c
[09:28:22.458]             inherits <- base::inherits
[09:28:22.458]             invokeRestart <- base::invokeRestart
[09:28:22.458]             length <- base::length
[09:28:22.458]             list <- base::list
[09:28:22.458]             seq.int <- base::seq.int
[09:28:22.458]             signalCondition <- base::signalCondition
[09:28:22.458]             sys.calls <- base::sys.calls
[09:28:22.458]             `[[` <- base::`[[`
[09:28:22.458]             `+` <- base::`+`
[09:28:22.458]             `<<-` <- base::`<<-`
[09:28:22.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.458]                   3L)]
[09:28:22.458]             }
[09:28:22.458]             function(cond) {
[09:28:22.458]                 is_error <- inherits(cond, "error")
[09:28:22.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.458]                   NULL)
[09:28:22.458]                 if (is_error) {
[09:28:22.458]                   sessionInformation <- function() {
[09:28:22.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.458]                       search = base::search(), system = base::Sys.info())
[09:28:22.458]                   }
[09:28:22.458]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.458]                     cond$call), session = sessionInformation(), 
[09:28:22.458]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.458]                   signalCondition(cond)
[09:28:22.458]                 }
[09:28:22.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.458]                 "immediateCondition"))) {
[09:28:22.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.458]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.458]                   if (TRUE && !signal) {
[09:28:22.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.458]                     {
[09:28:22.458]                       inherits <- base::inherits
[09:28:22.458]                       invokeRestart <- base::invokeRestart
[09:28:22.458]                       is.null <- base::is.null
[09:28:22.458]                       muffled <- FALSE
[09:28:22.458]                       if (inherits(cond, "message")) {
[09:28:22.458]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.458]                         if (muffled) 
[09:28:22.458]                           invokeRestart("muffleMessage")
[09:28:22.458]                       }
[09:28:22.458]                       else if (inherits(cond, "warning")) {
[09:28:22.458]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.458]                         if (muffled) 
[09:28:22.458]                           invokeRestart("muffleWarning")
[09:28:22.458]                       }
[09:28:22.458]                       else if (inherits(cond, "condition")) {
[09:28:22.458]                         if (!is.null(pattern)) {
[09:28:22.458]                           computeRestarts <- base::computeRestarts
[09:28:22.458]                           grepl <- base::grepl
[09:28:22.458]                           restarts <- computeRestarts(cond)
[09:28:22.458]                           for (restart in restarts) {
[09:28:22.458]                             name <- restart$name
[09:28:22.458]                             if (is.null(name)) 
[09:28:22.458]                               next
[09:28:22.458]                             if (!grepl(pattern, name)) 
[09:28:22.458]                               next
[09:28:22.458]                             invokeRestart(restart)
[09:28:22.458]                             muffled <- TRUE
[09:28:22.458]                             break
[09:28:22.458]                           }
[09:28:22.458]                         }
[09:28:22.458]                       }
[09:28:22.458]                       invisible(muffled)
[09:28:22.458]                     }
[09:28:22.458]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.458]                   }
[09:28:22.458]                 }
[09:28:22.458]                 else {
[09:28:22.458]                   if (TRUE) {
[09:28:22.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.458]                     {
[09:28:22.458]                       inherits <- base::inherits
[09:28:22.458]                       invokeRestart <- base::invokeRestart
[09:28:22.458]                       is.null <- base::is.null
[09:28:22.458]                       muffled <- FALSE
[09:28:22.458]                       if (inherits(cond, "message")) {
[09:28:22.458]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.458]                         if (muffled) 
[09:28:22.458]                           invokeRestart("muffleMessage")
[09:28:22.458]                       }
[09:28:22.458]                       else if (inherits(cond, "warning")) {
[09:28:22.458]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.458]                         if (muffled) 
[09:28:22.458]                           invokeRestart("muffleWarning")
[09:28:22.458]                       }
[09:28:22.458]                       else if (inherits(cond, "condition")) {
[09:28:22.458]                         if (!is.null(pattern)) {
[09:28:22.458]                           computeRestarts <- base::computeRestarts
[09:28:22.458]                           grepl <- base::grepl
[09:28:22.458]                           restarts <- computeRestarts(cond)
[09:28:22.458]                           for (restart in restarts) {
[09:28:22.458]                             name <- restart$name
[09:28:22.458]                             if (is.null(name)) 
[09:28:22.458]                               next
[09:28:22.458]                             if (!grepl(pattern, name)) 
[09:28:22.458]                               next
[09:28:22.458]                             invokeRestart(restart)
[09:28:22.458]                             muffled <- TRUE
[09:28:22.458]                             break
[09:28:22.458]                           }
[09:28:22.458]                         }
[09:28:22.458]                       }
[09:28:22.458]                       invisible(muffled)
[09:28:22.458]                     }
[09:28:22.458]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.458]                   }
[09:28:22.458]                 }
[09:28:22.458]             }
[09:28:22.458]         }))
[09:28:22.458]     }, error = function(ex) {
[09:28:22.458]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.458]                 ...future.rng), started = ...future.startTime, 
[09:28:22.458]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.458]             version = "1.8"), class = "FutureResult")
[09:28:22.458]     }, finally = {
[09:28:22.458]         if (!identical(...future.workdir, getwd())) 
[09:28:22.458]             setwd(...future.workdir)
[09:28:22.458]         {
[09:28:22.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.458]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.458]             }
[09:28:22.458]             base::options(...future.oldOptions)
[09:28:22.458]             if (.Platform$OS.type == "windows") {
[09:28:22.458]                 old_names <- names(...future.oldEnvVars)
[09:28:22.458]                 envs <- base::Sys.getenv()
[09:28:22.458]                 names <- names(envs)
[09:28:22.458]                 common <- intersect(names, old_names)
[09:28:22.458]                 added <- setdiff(names, old_names)
[09:28:22.458]                 removed <- setdiff(old_names, names)
[09:28:22.458]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.458]                   envs[common]]
[09:28:22.458]                 NAMES <- toupper(changed)
[09:28:22.458]                 args <- list()
[09:28:22.458]                 for (kk in seq_along(NAMES)) {
[09:28:22.458]                   name <- changed[[kk]]
[09:28:22.458]                   NAME <- NAMES[[kk]]
[09:28:22.458]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.458]                     next
[09:28:22.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.458]                 }
[09:28:22.458]                 NAMES <- toupper(added)
[09:28:22.458]                 for (kk in seq_along(NAMES)) {
[09:28:22.458]                   name <- added[[kk]]
[09:28:22.458]                   NAME <- NAMES[[kk]]
[09:28:22.458]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.458]                     next
[09:28:22.458]                   args[[name]] <- ""
[09:28:22.458]                 }
[09:28:22.458]                 NAMES <- toupper(removed)
[09:28:22.458]                 for (kk in seq_along(NAMES)) {
[09:28:22.458]                   name <- removed[[kk]]
[09:28:22.458]                   NAME <- NAMES[[kk]]
[09:28:22.458]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.458]                     next
[09:28:22.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.458]                 }
[09:28:22.458]                 if (length(args) > 0) 
[09:28:22.458]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.458]             }
[09:28:22.458]             else {
[09:28:22.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.458]             }
[09:28:22.458]             {
[09:28:22.458]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.458]                   0L) {
[09:28:22.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.458]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.458]                   base::options(opts)
[09:28:22.458]                 }
[09:28:22.458]                 {
[09:28:22.458]                   {
[09:28:22.458]                     NULL
[09:28:22.458]                     RNGkind("Mersenne-Twister")
[09:28:22.458]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.458]                       inherits = FALSE)
[09:28:22.458]                   }
[09:28:22.458]                   options(future.plan = NULL)
[09:28:22.458]                   if (is.na(NA_character_)) 
[09:28:22.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.458]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.458]                     .init = FALSE)
[09:28:22.458]                 }
[09:28:22.458]             }
[09:28:22.458]         }
[09:28:22.458]     })
[09:28:22.458]     if (TRUE) {
[09:28:22.458]         base::sink(type = "output", split = FALSE)
[09:28:22.458]         if (TRUE) {
[09:28:22.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.458]         }
[09:28:22.458]         else {
[09:28:22.458]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.458]         }
[09:28:22.458]         base::close(...future.stdout)
[09:28:22.458]         ...future.stdout <- NULL
[09:28:22.458]     }
[09:28:22.458]     ...future.result$conditions <- ...future.conditions
[09:28:22.458]     ...future.result$finished <- base::Sys.time()
[09:28:22.458]     ...future.result
[09:28:22.458] }
[09:28:22.460] assign_globals() ...
[09:28:22.460] List of 5
[09:28:22.460]  $ ...future.FUN            :function (object, ...)  
[09:28:22.460]  $ future.call.arguments    : list()
[09:28:22.460]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.460]  $ ...future.elements_ii    :List of 3
[09:28:22.460]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.460]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.460]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.460]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.460]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.460]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.460]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.460]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.460]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.460]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.460]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.460]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.460]  $ ...future.seeds_ii       : NULL
[09:28:22.460]  $ ...future.globals.maxSize: NULL
[09:28:22.460]  - attr(*, "where")=List of 5
[09:28:22.460]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.460]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.460]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.460]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.460]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.460]  - attr(*, "resolved")= logi FALSE
[09:28:22.460]  - attr(*, "total_size")= num 1240
[09:28:22.460]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.460]  - attr(*, "already-done")= logi TRUE
[09:28:22.468] - copied ‘...future.FUN’ to environment
[09:28:22.468] - copied ‘future.call.arguments’ to environment
[09:28:22.468] - copied ‘...future.elements_ii’ to environment
[09:28:22.468] - copied ‘...future.seeds_ii’ to environment
[09:28:22.468] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.468] assign_globals() ... done
[09:28:22.469] plan(): Setting new future strategy stack:
[09:28:22.469] List of future strategies:
[09:28:22.469] 1. sequential:
[09:28:22.469]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.469]    - tweaked: FALSE
[09:28:22.469]    - call: NULL
[09:28:22.469] plan(): nbrOfWorkers() = 1
[09:28:22.471] plan(): Setting new future strategy stack:
[09:28:22.471] List of future strategies:
[09:28:22.471] 1. multicore:
[09:28:22.471]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:22.471]    - tweaked: FALSE
[09:28:22.471]    - call: plan(strategy)
[09:28:22.475] plan(): nbrOfWorkers() = 1
[09:28:22.475] SequentialFuture started (and completed)
[09:28:22.475] - Launch lazy future ... done
[09:28:22.475] run() for ‘SequentialFuture’ ... done
[09:28:22.475] Created future:
[09:28:22.475] SequentialFuture:
[09:28:22.475] Label: ‘future_by-1’
[09:28:22.475] Expression:
[09:28:22.475] {
[09:28:22.475]     do.call(function(...) {
[09:28:22.475]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.475]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.475]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.475]             on.exit(options(oopts), add = TRUE)
[09:28:22.475]         }
[09:28:22.475]         {
[09:28:22.475]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.475]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.475]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.475]             })
[09:28:22.475]         }
[09:28:22.475]     }, args = future.call.arguments)
[09:28:22.475] }
[09:28:22.475] Lazy evaluation: FALSE
[09:28:22.475] Asynchronous evaluation: FALSE
[09:28:22.475] Local evaluation: TRUE
[09:28:22.475] Environment: 0x555b098fb908
[09:28:22.475] Capture standard output: TRUE
[09:28:22.475] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.475] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.475] Packages: <none>
[09:28:22.475] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.475] Resolved: TRUE
[09:28:22.475] Value: 5.37 KiB of class ‘list’
[09:28:22.475] Early signaling: FALSE
[09:28:22.475] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.475] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.476] Chunk #1 of 1 ... DONE
[09:28:22.476] Launching 1 futures (chunks) ... DONE
[09:28:22.477] Resolving 1 futures (chunks) ...
[09:28:22.477] resolve() on list ...
[09:28:22.477]  recursive: 0
[09:28:22.477]  length: 1
[09:28:22.477] 
[09:28:22.477] resolved() for ‘SequentialFuture’ ...
[09:28:22.477] - state: ‘finished’
[09:28:22.477] - run: TRUE
[09:28:22.477] - result: ‘FutureResult’
[09:28:22.477] resolved() for ‘SequentialFuture’ ... done
[09:28:22.477] Future #1
[09:28:22.478] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.478] - nx: 1
[09:28:22.478] - relay: TRUE
[09:28:22.478] - stdout: TRUE
[09:28:22.478] - signal: TRUE
[09:28:22.478] - resignal: FALSE
[09:28:22.478] - force: TRUE
[09:28:22.478] - relayed: [n=1] FALSE
[09:28:22.478] - queued futures: [n=1] FALSE
[09:28:22.478]  - until=1
[09:28:22.478]  - relaying element #1
[09:28:22.479] - relayed: [n=1] TRUE
[09:28:22.479] - queued futures: [n=1] TRUE
[09:28:22.479] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.479]  length: 0 (resolved future 1)
[09:28:22.479] Relaying remaining futures
[09:28:22.479] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.479] - nx: 1
[09:28:22.479] - relay: TRUE
[09:28:22.479] - stdout: TRUE
[09:28:22.479] - signal: TRUE
[09:28:22.479] - resignal: FALSE
[09:28:22.479] - force: TRUE
[09:28:22.479] - relayed: [n=1] TRUE
[09:28:22.480] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.480] - relayed: [n=1] TRUE
[09:28:22.480] - queued futures: [n=1] TRUE
[09:28:22.480] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.480] resolve() on list ... DONE
[09:28:22.480]  - Number of value chunks collected: 1
[09:28:22.480] Resolving 1 futures (chunks) ... DONE
[09:28:22.480] Reducing values from 1 chunks ...
[09:28:22.480]  - Number of values collected after concatenation: 3
[09:28:22.480]  - Number of values expected: 3
[09:28:22.481] Reducing values from 1 chunks ... DONE
[09:28:22.481] future_lapply() ... DONE
[09:28:22.481] future_by_internal() ... DONE
[09:28:22.482] future_by_internal() ...
- plan('multisession') ...
[09:28:22.483] plan(): Setting new future strategy stack:
[09:28:22.483] List of future strategies:
[09:28:22.483] 1. multisession:
[09:28:22.483]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:22.483]    - tweaked: FALSE
[09:28:22.483]    - call: plan(strategy)
[09:28:22.483] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:28:22.484] multisession:
[09:28:22.484] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:22.484] - tweaked: FALSE
[09:28:22.484] - call: plan(strategy)
[09:28:22.487] getGlobalsAndPackages() ...
[09:28:22.487] Not searching for globals
[09:28:22.487] - globals: [0] <none>
[09:28:22.487] getGlobalsAndPackages() ... DONE
[09:28:22.488] Packages needed by the future expression (n = 0): <none>
[09:28:22.488] Packages needed by future strategies (n = 0): <none>
[09:28:22.488] {
[09:28:22.488]     {
[09:28:22.488]         {
[09:28:22.488]             ...future.startTime <- base::Sys.time()
[09:28:22.488]             {
[09:28:22.488]                 {
[09:28:22.488]                   {
[09:28:22.488]                     base::local({
[09:28:22.488]                       has_future <- base::requireNamespace("future", 
[09:28:22.488]                         quietly = TRUE)
[09:28:22.488]                       if (has_future) {
[09:28:22.488]                         ns <- base::getNamespace("future")
[09:28:22.488]                         version <- ns[[".package"]][["version"]]
[09:28:22.488]                         if (is.null(version)) 
[09:28:22.488]                           version <- utils::packageVersion("future")
[09:28:22.488]                       }
[09:28:22.488]                       else {
[09:28:22.488]                         version <- NULL
[09:28:22.488]                       }
[09:28:22.488]                       if (!has_future || version < "1.8.0") {
[09:28:22.488]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.488]                           "", base::R.version$version.string), 
[09:28:22.488]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.488]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.488]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.488]                             "release", "version")], collapse = " "), 
[09:28:22.488]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.488]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.488]                           info)
[09:28:22.488]                         info <- base::paste(info, collapse = "; ")
[09:28:22.488]                         if (!has_future) {
[09:28:22.488]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.488]                             info)
[09:28:22.488]                         }
[09:28:22.488]                         else {
[09:28:22.488]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.488]                             info, version)
[09:28:22.488]                         }
[09:28:22.488]                         base::stop(msg)
[09:28:22.488]                       }
[09:28:22.488]                     })
[09:28:22.488]                   }
[09:28:22.488]                   ...future.strategy.old <- future::plan("list")
[09:28:22.488]                   options(future.plan = NULL)
[09:28:22.488]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.488]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.488]                 }
[09:28:22.488]                 ...future.workdir <- getwd()
[09:28:22.488]             }
[09:28:22.488]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.488]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.488]         }
[09:28:22.488]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.488]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.488]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.488]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.488]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.488]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.488]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.488]             base::names(...future.oldOptions))
[09:28:22.488]     }
[09:28:22.488]     if (FALSE) {
[09:28:22.488]     }
[09:28:22.488]     else {
[09:28:22.488]         if (TRUE) {
[09:28:22.488]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.488]                 open = "w")
[09:28:22.488]         }
[09:28:22.488]         else {
[09:28:22.488]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.488]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.488]         }
[09:28:22.488]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.488]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.488]             base::sink(type = "output", split = FALSE)
[09:28:22.488]             base::close(...future.stdout)
[09:28:22.488]         }, add = TRUE)
[09:28:22.488]     }
[09:28:22.488]     ...future.frame <- base::sys.nframe()
[09:28:22.488]     ...future.conditions <- base::list()
[09:28:22.488]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.488]     if (FALSE) {
[09:28:22.488]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.488]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.488]     }
[09:28:22.488]     ...future.result <- base::tryCatch({
[09:28:22.488]         base::withCallingHandlers({
[09:28:22.488]             ...future.value <- base::withVisible(base::local(NA))
[09:28:22.488]             future::FutureResult(value = ...future.value$value, 
[09:28:22.488]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.488]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.488]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.488]                     ...future.globalenv.names))
[09:28:22.488]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.488]         }, condition = base::local({
[09:28:22.488]             c <- base::c
[09:28:22.488]             inherits <- base::inherits
[09:28:22.488]             invokeRestart <- base::invokeRestart
[09:28:22.488]             length <- base::length
[09:28:22.488]             list <- base::list
[09:28:22.488]             seq.int <- base::seq.int
[09:28:22.488]             signalCondition <- base::signalCondition
[09:28:22.488]             sys.calls <- base::sys.calls
[09:28:22.488]             `[[` <- base::`[[`
[09:28:22.488]             `+` <- base::`+`
[09:28:22.488]             `<<-` <- base::`<<-`
[09:28:22.488]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.488]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.488]                   3L)]
[09:28:22.488]             }
[09:28:22.488]             function(cond) {
[09:28:22.488]                 is_error <- inherits(cond, "error")
[09:28:22.488]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.488]                   NULL)
[09:28:22.488]                 if (is_error) {
[09:28:22.488]                   sessionInformation <- function() {
[09:28:22.488]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.488]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.488]                       search = base::search(), system = base::Sys.info())
[09:28:22.488]                   }
[09:28:22.488]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.488]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.488]                     cond$call), session = sessionInformation(), 
[09:28:22.488]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.488]                   signalCondition(cond)
[09:28:22.488]                 }
[09:28:22.488]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.488]                 "immediateCondition"))) {
[09:28:22.488]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.488]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.488]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.488]                   if (TRUE && !signal) {
[09:28:22.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.488]                     {
[09:28:22.488]                       inherits <- base::inherits
[09:28:22.488]                       invokeRestart <- base::invokeRestart
[09:28:22.488]                       is.null <- base::is.null
[09:28:22.488]                       muffled <- FALSE
[09:28:22.488]                       if (inherits(cond, "message")) {
[09:28:22.488]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.488]                         if (muffled) 
[09:28:22.488]                           invokeRestart("muffleMessage")
[09:28:22.488]                       }
[09:28:22.488]                       else if (inherits(cond, "warning")) {
[09:28:22.488]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.488]                         if (muffled) 
[09:28:22.488]                           invokeRestart("muffleWarning")
[09:28:22.488]                       }
[09:28:22.488]                       else if (inherits(cond, "condition")) {
[09:28:22.488]                         if (!is.null(pattern)) {
[09:28:22.488]                           computeRestarts <- base::computeRestarts
[09:28:22.488]                           grepl <- base::grepl
[09:28:22.488]                           restarts <- computeRestarts(cond)
[09:28:22.488]                           for (restart in restarts) {
[09:28:22.488]                             name <- restart$name
[09:28:22.488]                             if (is.null(name)) 
[09:28:22.488]                               next
[09:28:22.488]                             if (!grepl(pattern, name)) 
[09:28:22.488]                               next
[09:28:22.488]                             invokeRestart(restart)
[09:28:22.488]                             muffled <- TRUE
[09:28:22.488]                             break
[09:28:22.488]                           }
[09:28:22.488]                         }
[09:28:22.488]                       }
[09:28:22.488]                       invisible(muffled)
[09:28:22.488]                     }
[09:28:22.488]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.488]                   }
[09:28:22.488]                 }
[09:28:22.488]                 else {
[09:28:22.488]                   if (TRUE) {
[09:28:22.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.488]                     {
[09:28:22.488]                       inherits <- base::inherits
[09:28:22.488]                       invokeRestart <- base::invokeRestart
[09:28:22.488]                       is.null <- base::is.null
[09:28:22.488]                       muffled <- FALSE
[09:28:22.488]                       if (inherits(cond, "message")) {
[09:28:22.488]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.488]                         if (muffled) 
[09:28:22.488]                           invokeRestart("muffleMessage")
[09:28:22.488]                       }
[09:28:22.488]                       else if (inherits(cond, "warning")) {
[09:28:22.488]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.488]                         if (muffled) 
[09:28:22.488]                           invokeRestart("muffleWarning")
[09:28:22.488]                       }
[09:28:22.488]                       else if (inherits(cond, "condition")) {
[09:28:22.488]                         if (!is.null(pattern)) {
[09:28:22.488]                           computeRestarts <- base::computeRestarts
[09:28:22.488]                           grepl <- base::grepl
[09:28:22.488]                           restarts <- computeRestarts(cond)
[09:28:22.488]                           for (restart in restarts) {
[09:28:22.488]                             name <- restart$name
[09:28:22.488]                             if (is.null(name)) 
[09:28:22.488]                               next
[09:28:22.488]                             if (!grepl(pattern, name)) 
[09:28:22.488]                               next
[09:28:22.488]                             invokeRestart(restart)
[09:28:22.488]                             muffled <- TRUE
[09:28:22.488]                             break
[09:28:22.488]                           }
[09:28:22.488]                         }
[09:28:22.488]                       }
[09:28:22.488]                       invisible(muffled)
[09:28:22.488]                     }
[09:28:22.488]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.488]                   }
[09:28:22.488]                 }
[09:28:22.488]             }
[09:28:22.488]         }))
[09:28:22.488]     }, error = function(ex) {
[09:28:22.488]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.488]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.488]                 ...future.rng), started = ...future.startTime, 
[09:28:22.488]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.488]             version = "1.8"), class = "FutureResult")
[09:28:22.488]     }, finally = {
[09:28:22.488]         if (!identical(...future.workdir, getwd())) 
[09:28:22.488]             setwd(...future.workdir)
[09:28:22.488]         {
[09:28:22.488]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.488]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.488]             }
[09:28:22.488]             base::options(...future.oldOptions)
[09:28:22.488]             if (.Platform$OS.type == "windows") {
[09:28:22.488]                 old_names <- names(...future.oldEnvVars)
[09:28:22.488]                 envs <- base::Sys.getenv()
[09:28:22.488]                 names <- names(envs)
[09:28:22.488]                 common <- intersect(names, old_names)
[09:28:22.488]                 added <- setdiff(names, old_names)
[09:28:22.488]                 removed <- setdiff(old_names, names)
[09:28:22.488]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.488]                   envs[common]]
[09:28:22.488]                 NAMES <- toupper(changed)
[09:28:22.488]                 args <- list()
[09:28:22.488]                 for (kk in seq_along(NAMES)) {
[09:28:22.488]                   name <- changed[[kk]]
[09:28:22.488]                   NAME <- NAMES[[kk]]
[09:28:22.488]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.488]                     next
[09:28:22.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.488]                 }
[09:28:22.488]                 NAMES <- toupper(added)
[09:28:22.488]                 for (kk in seq_along(NAMES)) {
[09:28:22.488]                   name <- added[[kk]]
[09:28:22.488]                   NAME <- NAMES[[kk]]
[09:28:22.488]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.488]                     next
[09:28:22.488]                   args[[name]] <- ""
[09:28:22.488]                 }
[09:28:22.488]                 NAMES <- toupper(removed)
[09:28:22.488]                 for (kk in seq_along(NAMES)) {
[09:28:22.488]                   name <- removed[[kk]]
[09:28:22.488]                   NAME <- NAMES[[kk]]
[09:28:22.488]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.488]                     next
[09:28:22.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.488]                 }
[09:28:22.488]                 if (length(args) > 0) 
[09:28:22.488]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.488]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.488]             }
[09:28:22.488]             else {
[09:28:22.488]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.488]             }
[09:28:22.488]             {
[09:28:22.488]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.488]                   0L) {
[09:28:22.488]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.488]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.488]                   base::options(opts)
[09:28:22.488]                 }
[09:28:22.488]                 {
[09:28:22.488]                   {
[09:28:22.488]                     NULL
[09:28:22.488]                     RNGkind("Mersenne-Twister")
[09:28:22.488]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.488]                       inherits = FALSE)
[09:28:22.488]                   }
[09:28:22.488]                   options(future.plan = NULL)
[09:28:22.488]                   if (is.na(NA_character_)) 
[09:28:22.488]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.488]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.488]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.488]                     .init = FALSE)
[09:28:22.488]                 }
[09:28:22.488]             }
[09:28:22.488]         }
[09:28:22.488]     })
[09:28:22.488]     if (TRUE) {
[09:28:22.488]         base::sink(type = "output", split = FALSE)
[09:28:22.488]         if (TRUE) {
[09:28:22.488]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.488]         }
[09:28:22.488]         else {
[09:28:22.488]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.488]         }
[09:28:22.488]         base::close(...future.stdout)
[09:28:22.488]         ...future.stdout <- NULL
[09:28:22.488]     }
[09:28:22.488]     ...future.result$conditions <- ...future.conditions
[09:28:22.488]     ...future.result$finished <- base::Sys.time()
[09:28:22.488]     ...future.result
[09:28:22.488] }
[09:28:22.490] plan(): Setting new future strategy stack:
[09:28:22.490] List of future strategies:
[09:28:22.490] 1. sequential:
[09:28:22.490]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.490]    - tweaked: FALSE
[09:28:22.490]    - call: NULL
[09:28:22.490] plan(): nbrOfWorkers() = 1
[09:28:22.491] plan(): Setting new future strategy stack:
[09:28:22.491] List of future strategies:
[09:28:22.491] 1. multisession:
[09:28:22.491]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:22.491]    - tweaked: FALSE
[09:28:22.491]    - call: plan(strategy)
[09:28:22.494] plan(): nbrOfWorkers() = 1
[09:28:22.495] SequentialFuture started (and completed)
[09:28:22.495] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:28:22.498] plan(): nbrOfWorkers() = 1
[09:28:22.498] future_by_internal() ...
[09:28:22.498] future_lapply() ...
[09:28:22.501] Number of chunks: 1
[09:28:22.502] getGlobalsAndPackagesXApply() ...
[09:28:22.502]  - future.globals: TRUE
[09:28:22.502] getGlobalsAndPackages() ...
[09:28:22.502] Searching for globals...
[09:28:22.503] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.503] Searching for globals ... DONE
[09:28:22.503] Resolving globals: FALSE
[09:28:22.503] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.504] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.504] - globals: [1] ‘FUN’
[09:28:22.504] 
[09:28:22.504] getGlobalsAndPackages() ... DONE
[09:28:22.504]  - globals found/used: [n=1] ‘FUN’
[09:28:22.504]  - needed namespaces: [n=0] 
[09:28:22.504] Finding globals ... DONE
[09:28:22.504]  - use_args: TRUE
[09:28:22.504]  - Getting '...' globals ...
[09:28:22.505] resolve() on list ...
[09:28:22.505]  recursive: 0
[09:28:22.505]  length: 1
[09:28:22.505]  elements: ‘...’
[09:28:22.505]  length: 0 (resolved future 1)
[09:28:22.505] resolve() on list ... DONE
[09:28:22.505]    - '...' content: [n=0] 
[09:28:22.505] List of 1
[09:28:22.505]  $ ...: list()
[09:28:22.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.505]  - attr(*, "where")=List of 1
[09:28:22.505]   ..$ ...:<environment: 0x555b09ba4690> 
[09:28:22.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.505]  - attr(*, "resolved")= logi TRUE
[09:28:22.505]  - attr(*, "total_size")= num NA
[09:28:22.508]  - Getting '...' globals ... DONE
[09:28:22.508] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.508] List of 2
[09:28:22.508]  $ ...future.FUN:function (object, ...)  
[09:28:22.508]  $ ...          : list()
[09:28:22.508]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.508]  - attr(*, "where")=List of 2
[09:28:22.508]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.508]   ..$ ...          :<environment: 0x555b09ba4690> 
[09:28:22.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.508]  - attr(*, "resolved")= logi FALSE
[09:28:22.508]  - attr(*, "total_size")= num 1240
[09:28:22.510] Packages to be attached in all futures: [n=0] 
[09:28:22.511] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.511] Number of futures (= number of chunks): 1
[09:28:22.511] Launching 1 futures (chunks) ...
[09:28:22.511] Chunk #1 of 1 ...
[09:28:22.511]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.511] getGlobalsAndPackages() ...
[09:28:22.511] Searching for globals...
[09:28:22.512] 
[09:28:22.512] Searching for globals ... DONE
[09:28:22.512] - globals: [0] <none>
[09:28:22.512] getGlobalsAndPackages() ... DONE
[09:28:22.512]    + additional globals found: [n=0] 
[09:28:22.512]    + additional namespaces needed: [n=0] 
[09:28:22.512]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.513]  - seeds: <none>
[09:28:22.513]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.514] getGlobalsAndPackages() ...
[09:28:22.514] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.514] Resolving globals: FALSE
[09:28:22.514] Tweak future expression to call with '...' arguments ...
[09:28:22.514] {
[09:28:22.514]     do.call(function(...) {
[09:28:22.514]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.514]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.514]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.514]             on.exit(options(oopts), add = TRUE)
[09:28:22.514]         }
[09:28:22.514]         {
[09:28:22.514]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.514]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.514]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.514]             })
[09:28:22.514]         }
[09:28:22.514]     }, args = future.call.arguments)
[09:28:22.514] }
[09:28:22.514] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.515] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.515] 
[09:28:22.515] getGlobalsAndPackages() ... DONE
[09:28:22.515] run() for ‘Future’ ...
[09:28:22.515] - state: ‘created’
[09:28:22.515] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.518] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.519]   - Field: ‘label’
[09:28:22.519]   - Field: ‘local’
[09:28:22.519]   - Field: ‘owner’
[09:28:22.519]   - Field: ‘envir’
[09:28:22.519]   - Field: ‘packages’
[09:28:22.519]   - Field: ‘gc’
[09:28:22.519]   - Field: ‘conditions’
[09:28:22.519]   - Field: ‘expr’
[09:28:22.519]   - Field: ‘uuid’
[09:28:22.520]   - Field: ‘seed’
[09:28:22.520]   - Field: ‘version’
[09:28:22.520]   - Field: ‘result’
[09:28:22.520]   - Field: ‘asynchronous’
[09:28:22.520]   - Field: ‘calls’
[09:28:22.520]   - Field: ‘globals’
[09:28:22.520]   - Field: ‘stdout’
[09:28:22.520]   - Field: ‘earlySignal’
[09:28:22.520]   - Field: ‘lazy’
[09:28:22.520]   - Field: ‘state’
[09:28:22.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.521] - Launch lazy future ...
[09:28:22.521] Packages needed by the future expression (n = 0): <none>
[09:28:22.521] Packages needed by future strategies (n = 0): <none>
[09:28:22.521] {
[09:28:22.521]     {
[09:28:22.521]         {
[09:28:22.521]             ...future.startTime <- base::Sys.time()
[09:28:22.521]             {
[09:28:22.521]                 {
[09:28:22.521]                   {
[09:28:22.521]                     base::local({
[09:28:22.521]                       has_future <- base::requireNamespace("future", 
[09:28:22.521]                         quietly = TRUE)
[09:28:22.521]                       if (has_future) {
[09:28:22.521]                         ns <- base::getNamespace("future")
[09:28:22.521]                         version <- ns[[".package"]][["version"]]
[09:28:22.521]                         if (is.null(version)) 
[09:28:22.521]                           version <- utils::packageVersion("future")
[09:28:22.521]                       }
[09:28:22.521]                       else {
[09:28:22.521]                         version <- NULL
[09:28:22.521]                       }
[09:28:22.521]                       if (!has_future || version < "1.8.0") {
[09:28:22.521]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.521]                           "", base::R.version$version.string), 
[09:28:22.521]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.521]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.521]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.521]                             "release", "version")], collapse = " "), 
[09:28:22.521]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.521]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.521]                           info)
[09:28:22.521]                         info <- base::paste(info, collapse = "; ")
[09:28:22.521]                         if (!has_future) {
[09:28:22.521]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.521]                             info)
[09:28:22.521]                         }
[09:28:22.521]                         else {
[09:28:22.521]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.521]                             info, version)
[09:28:22.521]                         }
[09:28:22.521]                         base::stop(msg)
[09:28:22.521]                       }
[09:28:22.521]                     })
[09:28:22.521]                   }
[09:28:22.521]                   ...future.strategy.old <- future::plan("list")
[09:28:22.521]                   options(future.plan = NULL)
[09:28:22.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.521]                 }
[09:28:22.521]                 ...future.workdir <- getwd()
[09:28:22.521]             }
[09:28:22.521]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.521]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.521]         }
[09:28:22.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.521]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.521]             base::names(...future.oldOptions))
[09:28:22.521]     }
[09:28:22.521]     if (FALSE) {
[09:28:22.521]     }
[09:28:22.521]     else {
[09:28:22.521]         if (TRUE) {
[09:28:22.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.521]                 open = "w")
[09:28:22.521]         }
[09:28:22.521]         else {
[09:28:22.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.521]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.521]         }
[09:28:22.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.521]             base::sink(type = "output", split = FALSE)
[09:28:22.521]             base::close(...future.stdout)
[09:28:22.521]         }, add = TRUE)
[09:28:22.521]     }
[09:28:22.521]     ...future.frame <- base::sys.nframe()
[09:28:22.521]     ...future.conditions <- base::list()
[09:28:22.521]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.521]     if (FALSE) {
[09:28:22.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.521]     }
[09:28:22.521]     ...future.result <- base::tryCatch({
[09:28:22.521]         base::withCallingHandlers({
[09:28:22.521]             ...future.value <- base::withVisible(base::local({
[09:28:22.521]                 do.call(function(...) {
[09:28:22.521]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.521]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.521]                     ...future.globals.maxSize)) {
[09:28:22.521]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.521]                     on.exit(options(oopts), add = TRUE)
[09:28:22.521]                   }
[09:28:22.521]                   {
[09:28:22.521]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.521]                       FUN = function(jj) {
[09:28:22.521]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.521]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.521]                       })
[09:28:22.521]                   }
[09:28:22.521]                 }, args = future.call.arguments)
[09:28:22.521]             }))
[09:28:22.521]             future::FutureResult(value = ...future.value$value, 
[09:28:22.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.521]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.521]                     ...future.globalenv.names))
[09:28:22.521]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.521]         }, condition = base::local({
[09:28:22.521]             c <- base::c
[09:28:22.521]             inherits <- base::inherits
[09:28:22.521]             invokeRestart <- base::invokeRestart
[09:28:22.521]             length <- base::length
[09:28:22.521]             list <- base::list
[09:28:22.521]             seq.int <- base::seq.int
[09:28:22.521]             signalCondition <- base::signalCondition
[09:28:22.521]             sys.calls <- base::sys.calls
[09:28:22.521]             `[[` <- base::`[[`
[09:28:22.521]             `+` <- base::`+`
[09:28:22.521]             `<<-` <- base::`<<-`
[09:28:22.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.521]                   3L)]
[09:28:22.521]             }
[09:28:22.521]             function(cond) {
[09:28:22.521]                 is_error <- inherits(cond, "error")
[09:28:22.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.521]                   NULL)
[09:28:22.521]                 if (is_error) {
[09:28:22.521]                   sessionInformation <- function() {
[09:28:22.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.521]                       search = base::search(), system = base::Sys.info())
[09:28:22.521]                   }
[09:28:22.521]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.521]                     cond$call), session = sessionInformation(), 
[09:28:22.521]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.521]                   signalCondition(cond)
[09:28:22.521]                 }
[09:28:22.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.521]                 "immediateCondition"))) {
[09:28:22.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.521]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.521]                   if (TRUE && !signal) {
[09:28:22.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.521]                     {
[09:28:22.521]                       inherits <- base::inherits
[09:28:22.521]                       invokeRestart <- base::invokeRestart
[09:28:22.521]                       is.null <- base::is.null
[09:28:22.521]                       muffled <- FALSE
[09:28:22.521]                       if (inherits(cond, "message")) {
[09:28:22.521]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.521]                         if (muffled) 
[09:28:22.521]                           invokeRestart("muffleMessage")
[09:28:22.521]                       }
[09:28:22.521]                       else if (inherits(cond, "warning")) {
[09:28:22.521]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.521]                         if (muffled) 
[09:28:22.521]                           invokeRestart("muffleWarning")
[09:28:22.521]                       }
[09:28:22.521]                       else if (inherits(cond, "condition")) {
[09:28:22.521]                         if (!is.null(pattern)) {
[09:28:22.521]                           computeRestarts <- base::computeRestarts
[09:28:22.521]                           grepl <- base::grepl
[09:28:22.521]                           restarts <- computeRestarts(cond)
[09:28:22.521]                           for (restart in restarts) {
[09:28:22.521]                             name <- restart$name
[09:28:22.521]                             if (is.null(name)) 
[09:28:22.521]                               next
[09:28:22.521]                             if (!grepl(pattern, name)) 
[09:28:22.521]                               next
[09:28:22.521]                             invokeRestart(restart)
[09:28:22.521]                             muffled <- TRUE
[09:28:22.521]                             break
[09:28:22.521]                           }
[09:28:22.521]                         }
[09:28:22.521]                       }
[09:28:22.521]                       invisible(muffled)
[09:28:22.521]                     }
[09:28:22.521]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.521]                   }
[09:28:22.521]                 }
[09:28:22.521]                 else {
[09:28:22.521]                   if (TRUE) {
[09:28:22.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.521]                     {
[09:28:22.521]                       inherits <- base::inherits
[09:28:22.521]                       invokeRestart <- base::invokeRestart
[09:28:22.521]                       is.null <- base::is.null
[09:28:22.521]                       muffled <- FALSE
[09:28:22.521]                       if (inherits(cond, "message")) {
[09:28:22.521]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.521]                         if (muffled) 
[09:28:22.521]                           invokeRestart("muffleMessage")
[09:28:22.521]                       }
[09:28:22.521]                       else if (inherits(cond, "warning")) {
[09:28:22.521]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.521]                         if (muffled) 
[09:28:22.521]                           invokeRestart("muffleWarning")
[09:28:22.521]                       }
[09:28:22.521]                       else if (inherits(cond, "condition")) {
[09:28:22.521]                         if (!is.null(pattern)) {
[09:28:22.521]                           computeRestarts <- base::computeRestarts
[09:28:22.521]                           grepl <- base::grepl
[09:28:22.521]                           restarts <- computeRestarts(cond)
[09:28:22.521]                           for (restart in restarts) {
[09:28:22.521]                             name <- restart$name
[09:28:22.521]                             if (is.null(name)) 
[09:28:22.521]                               next
[09:28:22.521]                             if (!grepl(pattern, name)) 
[09:28:22.521]                               next
[09:28:22.521]                             invokeRestart(restart)
[09:28:22.521]                             muffled <- TRUE
[09:28:22.521]                             break
[09:28:22.521]                           }
[09:28:22.521]                         }
[09:28:22.521]                       }
[09:28:22.521]                       invisible(muffled)
[09:28:22.521]                     }
[09:28:22.521]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.521]                   }
[09:28:22.521]                 }
[09:28:22.521]             }
[09:28:22.521]         }))
[09:28:22.521]     }, error = function(ex) {
[09:28:22.521]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.521]                 ...future.rng), started = ...future.startTime, 
[09:28:22.521]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.521]             version = "1.8"), class = "FutureResult")
[09:28:22.521]     }, finally = {
[09:28:22.521]         if (!identical(...future.workdir, getwd())) 
[09:28:22.521]             setwd(...future.workdir)
[09:28:22.521]         {
[09:28:22.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.521]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.521]             }
[09:28:22.521]             base::options(...future.oldOptions)
[09:28:22.521]             if (.Platform$OS.type == "windows") {
[09:28:22.521]                 old_names <- names(...future.oldEnvVars)
[09:28:22.521]                 envs <- base::Sys.getenv()
[09:28:22.521]                 names <- names(envs)
[09:28:22.521]                 common <- intersect(names, old_names)
[09:28:22.521]                 added <- setdiff(names, old_names)
[09:28:22.521]                 removed <- setdiff(old_names, names)
[09:28:22.521]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.521]                   envs[common]]
[09:28:22.521]                 NAMES <- toupper(changed)
[09:28:22.521]                 args <- list()
[09:28:22.521]                 for (kk in seq_along(NAMES)) {
[09:28:22.521]                   name <- changed[[kk]]
[09:28:22.521]                   NAME <- NAMES[[kk]]
[09:28:22.521]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.521]                     next
[09:28:22.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.521]                 }
[09:28:22.521]                 NAMES <- toupper(added)
[09:28:22.521]                 for (kk in seq_along(NAMES)) {
[09:28:22.521]                   name <- added[[kk]]
[09:28:22.521]                   NAME <- NAMES[[kk]]
[09:28:22.521]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.521]                     next
[09:28:22.521]                   args[[name]] <- ""
[09:28:22.521]                 }
[09:28:22.521]                 NAMES <- toupper(removed)
[09:28:22.521]                 for (kk in seq_along(NAMES)) {
[09:28:22.521]                   name <- removed[[kk]]
[09:28:22.521]                   NAME <- NAMES[[kk]]
[09:28:22.521]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.521]                     next
[09:28:22.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.521]                 }
[09:28:22.521]                 if (length(args) > 0) 
[09:28:22.521]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.521]             }
[09:28:22.521]             else {
[09:28:22.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.521]             }
[09:28:22.521]             {
[09:28:22.521]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.521]                   0L) {
[09:28:22.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.521]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.521]                   base::options(opts)
[09:28:22.521]                 }
[09:28:22.521]                 {
[09:28:22.521]                   {
[09:28:22.521]                     NULL
[09:28:22.521]                     RNGkind("Mersenne-Twister")
[09:28:22.521]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.521]                       inherits = FALSE)
[09:28:22.521]                   }
[09:28:22.521]                   options(future.plan = NULL)
[09:28:22.521]                   if (is.na(NA_character_)) 
[09:28:22.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.521]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.521]                     .init = FALSE)
[09:28:22.521]                 }
[09:28:22.521]             }
[09:28:22.521]         }
[09:28:22.521]     })
[09:28:22.521]     if (TRUE) {
[09:28:22.521]         base::sink(type = "output", split = FALSE)
[09:28:22.521]         if (TRUE) {
[09:28:22.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.521]         }
[09:28:22.521]         else {
[09:28:22.521]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.521]         }
[09:28:22.521]         base::close(...future.stdout)
[09:28:22.521]         ...future.stdout <- NULL
[09:28:22.521]     }
[09:28:22.521]     ...future.result$conditions <- ...future.conditions
[09:28:22.521]     ...future.result$finished <- base::Sys.time()
[09:28:22.521]     ...future.result
[09:28:22.521] }
[09:28:22.523] assign_globals() ...
[09:28:22.523] List of 5
[09:28:22.523]  $ ...future.FUN            :function (object, ...)  
[09:28:22.523]  $ future.call.arguments    : list()
[09:28:22.523]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.523]  $ ...future.elements_ii    :List of 3
[09:28:22.523]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:22.523]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.523]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.523]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:22.523]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.523]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.523]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:22.523]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.523]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.523]  $ ...future.seeds_ii       : NULL
[09:28:22.523]  $ ...future.globals.maxSize: NULL
[09:28:22.523]  - attr(*, "where")=List of 5
[09:28:22.523]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.523]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.523]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.523]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.523]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.523]  - attr(*, "resolved")= logi FALSE
[09:28:22.523]  - attr(*, "total_size")= num 1240
[09:28:22.523]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.523]  - attr(*, "already-done")= logi TRUE
[09:28:22.530] - copied ‘...future.FUN’ to environment
[09:28:22.530] - copied ‘future.call.arguments’ to environment
[09:28:22.530] - copied ‘...future.elements_ii’ to environment
[09:28:22.530] - copied ‘...future.seeds_ii’ to environment
[09:28:22.530] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.530] assign_globals() ... done
[09:28:22.530] plan(): Setting new future strategy stack:
[09:28:22.531] List of future strategies:
[09:28:22.531] 1. sequential:
[09:28:22.531]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.531]    - tweaked: FALSE
[09:28:22.531]    - call: NULL
[09:28:22.531] plan(): nbrOfWorkers() = 1
[09:28:22.533] plan(): Setting new future strategy stack:
[09:28:22.533] List of future strategies:
[09:28:22.533] 1. multisession:
[09:28:22.533]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:22.533]    - tweaked: FALSE
[09:28:22.533]    - call: plan(strategy)
[09:28:22.536] plan(): nbrOfWorkers() = 1
[09:28:22.536] SequentialFuture started (and completed)
[09:28:22.536] - Launch lazy future ... done
[09:28:22.536] run() for ‘SequentialFuture’ ... done
[09:28:22.536] Created future:
[09:28:22.537] SequentialFuture:
[09:28:22.537] Label: ‘future_by-1’
[09:28:22.537] Expression:
[09:28:22.537] {
[09:28:22.537]     do.call(function(...) {
[09:28:22.537]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.537]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.537]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.537]             on.exit(options(oopts), add = TRUE)
[09:28:22.537]         }
[09:28:22.537]         {
[09:28:22.537]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.537]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.537]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.537]             })
[09:28:22.537]         }
[09:28:22.537]     }, args = future.call.arguments)
[09:28:22.537] }
[09:28:22.537] Lazy evaluation: FALSE
[09:28:22.537] Asynchronous evaluation: FALSE
[09:28:22.537] Local evaluation: TRUE
[09:28:22.537] Environment: R_GlobalEnv
[09:28:22.537] Capture standard output: TRUE
[09:28:22.537] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.537] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.537] Packages: <none>
[09:28:22.537] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.537] Resolved: TRUE
[09:28:22.537] Value: 4.62 KiB of class ‘list’
[09:28:22.537] Early signaling: FALSE
[09:28:22.537] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.537] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.538] Chunk #1 of 1 ... DONE
[09:28:22.538] Launching 1 futures (chunks) ... DONE
[09:28:22.538] Resolving 1 futures (chunks) ...
[09:28:22.538] resolve() on list ...
[09:28:22.538]  recursive: 0
[09:28:22.538]  length: 1
[09:28:22.538] 
[09:28:22.538] resolved() for ‘SequentialFuture’ ...
[09:28:22.538] - state: ‘finished’
[09:28:22.538] - run: TRUE
[09:28:22.538] - result: ‘FutureResult’
[09:28:22.539] resolved() for ‘SequentialFuture’ ... done
[09:28:22.539] Future #1
[09:28:22.539] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.539] - nx: 1
[09:28:22.540] - relay: TRUE
[09:28:22.540] - stdout: TRUE
[09:28:22.540] - signal: TRUE
[09:28:22.540] - resignal: FALSE
[09:28:22.540] - force: TRUE
[09:28:22.540] - relayed: [n=1] FALSE
[09:28:22.540] - queued futures: [n=1] FALSE
[09:28:22.541]  - until=1
[09:28:22.541]  - relaying element #1
[09:28:22.541] - relayed: [n=1] TRUE
[09:28:22.541] - queued futures: [n=1] TRUE
[09:28:22.541] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.541]  length: 0 (resolved future 1)
[09:28:22.541] Relaying remaining futures
[09:28:22.541] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.541] - nx: 1
[09:28:22.541] - relay: TRUE
[09:28:22.541] - stdout: TRUE
[09:28:22.542] - signal: TRUE
[09:28:22.542] - resignal: FALSE
[09:28:22.542] - force: TRUE
[09:28:22.542] - relayed: [n=1] TRUE
[09:28:22.542] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.542] - relayed: [n=1] TRUE
[09:28:22.542] - queued futures: [n=1] TRUE
[09:28:22.542] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.542] resolve() on list ... DONE
[09:28:22.542]  - Number of value chunks collected: 1
[09:28:22.542] Resolving 1 futures (chunks) ... DONE
[09:28:22.543] Reducing values from 1 chunks ...
[09:28:22.543]  - Number of values collected after concatenation: 3
[09:28:22.543]  - Number of values expected: 3
[09:28:22.543] Reducing values from 1 chunks ... DONE
[09:28:22.543] future_lapply() ... DONE
[09:28:22.543] future_by_internal() ... DONE
[09:28:22.543] future_by_internal() ...
[09:28:22.544] future_lapply() ...
[09:28:22.547] Number of chunks: 1
[09:28:22.547] getGlobalsAndPackagesXApply() ...
[09:28:22.547]  - future.globals: TRUE
[09:28:22.547] getGlobalsAndPackages() ...
[09:28:22.547] Searching for globals...
[09:28:22.548] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.548] Searching for globals ... DONE
[09:28:22.549] Resolving globals: FALSE
[09:28:22.549] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.549] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.549] - globals: [1] ‘FUN’
[09:28:22.549] 
[09:28:22.549] getGlobalsAndPackages() ... DONE
[09:28:22.550]  - globals found/used: [n=1] ‘FUN’
[09:28:22.550]  - needed namespaces: [n=0] 
[09:28:22.550] Finding globals ... DONE
[09:28:22.550]  - use_args: TRUE
[09:28:22.550]  - Getting '...' globals ...
[09:28:22.550] resolve() on list ...
[09:28:22.550]  recursive: 0
[09:28:22.550]  length: 1
[09:28:22.550]  elements: ‘...’
[09:28:22.551]  length: 0 (resolved future 1)
[09:28:22.551] resolve() on list ... DONE
[09:28:22.551]    - '...' content: [n=1] ‘digits’
[09:28:22.551] List of 1
[09:28:22.551]  $ ...:List of 1
[09:28:22.551]   ..$ digits: int 2
[09:28:22.551]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.551]  - attr(*, "where")=List of 1
[09:28:22.551]   ..$ ...:<environment: 0x555b09845ef8> 
[09:28:22.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.551]  - attr(*, "resolved")= logi TRUE
[09:28:22.551]  - attr(*, "total_size")= num NA
[09:28:22.554]  - Getting '...' globals ... DONE
[09:28:22.554] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.554] List of 2
[09:28:22.554]  $ ...future.FUN:function (object, ...)  
[09:28:22.554]  $ ...          :List of 1
[09:28:22.554]   ..$ digits: int 2
[09:28:22.554]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.554]  - attr(*, "where")=List of 2
[09:28:22.554]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.554]   ..$ ...          :<environment: 0x555b09845ef8> 
[09:28:22.554]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.554]  - attr(*, "resolved")= logi FALSE
[09:28:22.554]  - attr(*, "total_size")= num 1296
[09:28:22.557] Packages to be attached in all futures: [n=0] 
[09:28:22.557] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.557] Number of futures (= number of chunks): 1
[09:28:22.557] Launching 1 futures (chunks) ...
[09:28:22.557] Chunk #1 of 1 ...
[09:28:22.557]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.557] getGlobalsAndPackages() ...
[09:28:22.558] Searching for globals...
[09:28:22.558] 
[09:28:22.558] Searching for globals ... DONE
[09:28:22.558] - globals: [0] <none>
[09:28:22.558] getGlobalsAndPackages() ... DONE
[09:28:22.558]    + additional globals found: [n=0] 
[09:28:22.558]    + additional namespaces needed: [n=0] 
[09:28:22.558]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.558]  - seeds: <none>
[09:28:22.558]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.559] getGlobalsAndPackages() ...
[09:28:22.559] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.559] Resolving globals: FALSE
[09:28:22.559] Tweak future expression to call with '...' arguments ...
[09:28:22.559] {
[09:28:22.559]     do.call(function(...) {
[09:28:22.559]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.559]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.559]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.559]             on.exit(options(oopts), add = TRUE)
[09:28:22.559]         }
[09:28:22.559]         {
[09:28:22.559]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.559]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.559]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.559]             })
[09:28:22.559]         }
[09:28:22.559]     }, args = future.call.arguments)
[09:28:22.559] }
[09:28:22.559] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.559] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.560] 
[09:28:22.560] getGlobalsAndPackages() ... DONE
[09:28:22.560] run() for ‘Future’ ...
[09:28:22.560] - state: ‘created’
[09:28:22.560] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.563] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.563] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.563]   - Field: ‘label’
[09:28:22.564]   - Field: ‘local’
[09:28:22.564]   - Field: ‘owner’
[09:28:22.564]   - Field: ‘envir’
[09:28:22.564]   - Field: ‘packages’
[09:28:22.565]   - Field: ‘gc’
[09:28:22.565]   - Field: ‘conditions’
[09:28:22.565]   - Field: ‘expr’
[09:28:22.565]   - Field: ‘uuid’
[09:28:22.565]   - Field: ‘seed’
[09:28:22.565]   - Field: ‘version’
[09:28:22.566]   - Field: ‘result’
[09:28:22.566]   - Field: ‘asynchronous’
[09:28:22.566]   - Field: ‘calls’
[09:28:22.566]   - Field: ‘globals’
[09:28:22.566]   - Field: ‘stdout’
[09:28:22.566]   - Field: ‘earlySignal’
[09:28:22.566]   - Field: ‘lazy’
[09:28:22.566]   - Field: ‘state’
[09:28:22.566] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.566] - Launch lazy future ...
[09:28:22.567] Packages needed by the future expression (n = 0): <none>
[09:28:22.567] Packages needed by future strategies (n = 0): <none>
[09:28:22.567] {
[09:28:22.567]     {
[09:28:22.567]         {
[09:28:22.567]             ...future.startTime <- base::Sys.time()
[09:28:22.567]             {
[09:28:22.567]                 {
[09:28:22.567]                   {
[09:28:22.567]                     base::local({
[09:28:22.567]                       has_future <- base::requireNamespace("future", 
[09:28:22.567]                         quietly = TRUE)
[09:28:22.567]                       if (has_future) {
[09:28:22.567]                         ns <- base::getNamespace("future")
[09:28:22.567]                         version <- ns[[".package"]][["version"]]
[09:28:22.567]                         if (is.null(version)) 
[09:28:22.567]                           version <- utils::packageVersion("future")
[09:28:22.567]                       }
[09:28:22.567]                       else {
[09:28:22.567]                         version <- NULL
[09:28:22.567]                       }
[09:28:22.567]                       if (!has_future || version < "1.8.0") {
[09:28:22.567]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.567]                           "", base::R.version$version.string), 
[09:28:22.567]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.567]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.567]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.567]                             "release", "version")], collapse = " "), 
[09:28:22.567]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.567]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.567]                           info)
[09:28:22.567]                         info <- base::paste(info, collapse = "; ")
[09:28:22.567]                         if (!has_future) {
[09:28:22.567]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.567]                             info)
[09:28:22.567]                         }
[09:28:22.567]                         else {
[09:28:22.567]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.567]                             info, version)
[09:28:22.567]                         }
[09:28:22.567]                         base::stop(msg)
[09:28:22.567]                       }
[09:28:22.567]                     })
[09:28:22.567]                   }
[09:28:22.567]                   ...future.strategy.old <- future::plan("list")
[09:28:22.567]                   options(future.plan = NULL)
[09:28:22.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.567]                 }
[09:28:22.567]                 ...future.workdir <- getwd()
[09:28:22.567]             }
[09:28:22.567]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.567]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.567]         }
[09:28:22.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.567]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.567]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.567]             base::names(...future.oldOptions))
[09:28:22.567]     }
[09:28:22.567]     if (FALSE) {
[09:28:22.567]     }
[09:28:22.567]     else {
[09:28:22.567]         if (TRUE) {
[09:28:22.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.567]                 open = "w")
[09:28:22.567]         }
[09:28:22.567]         else {
[09:28:22.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.567]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.567]         }
[09:28:22.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.567]             base::sink(type = "output", split = FALSE)
[09:28:22.567]             base::close(...future.stdout)
[09:28:22.567]         }, add = TRUE)
[09:28:22.567]     }
[09:28:22.567]     ...future.frame <- base::sys.nframe()
[09:28:22.567]     ...future.conditions <- base::list()
[09:28:22.567]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.567]     if (FALSE) {
[09:28:22.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.567]     }
[09:28:22.567]     ...future.result <- base::tryCatch({
[09:28:22.567]         base::withCallingHandlers({
[09:28:22.567]             ...future.value <- base::withVisible(base::local({
[09:28:22.567]                 do.call(function(...) {
[09:28:22.567]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.567]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.567]                     ...future.globals.maxSize)) {
[09:28:22.567]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.567]                     on.exit(options(oopts), add = TRUE)
[09:28:22.567]                   }
[09:28:22.567]                   {
[09:28:22.567]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.567]                       FUN = function(jj) {
[09:28:22.567]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.567]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.567]                       })
[09:28:22.567]                   }
[09:28:22.567]                 }, args = future.call.arguments)
[09:28:22.567]             }))
[09:28:22.567]             future::FutureResult(value = ...future.value$value, 
[09:28:22.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.567]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.567]                     ...future.globalenv.names))
[09:28:22.567]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.567]         }, condition = base::local({
[09:28:22.567]             c <- base::c
[09:28:22.567]             inherits <- base::inherits
[09:28:22.567]             invokeRestart <- base::invokeRestart
[09:28:22.567]             length <- base::length
[09:28:22.567]             list <- base::list
[09:28:22.567]             seq.int <- base::seq.int
[09:28:22.567]             signalCondition <- base::signalCondition
[09:28:22.567]             sys.calls <- base::sys.calls
[09:28:22.567]             `[[` <- base::`[[`
[09:28:22.567]             `+` <- base::`+`
[09:28:22.567]             `<<-` <- base::`<<-`
[09:28:22.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.567]                   3L)]
[09:28:22.567]             }
[09:28:22.567]             function(cond) {
[09:28:22.567]                 is_error <- inherits(cond, "error")
[09:28:22.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.567]                   NULL)
[09:28:22.567]                 if (is_error) {
[09:28:22.567]                   sessionInformation <- function() {
[09:28:22.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.567]                       search = base::search(), system = base::Sys.info())
[09:28:22.567]                   }
[09:28:22.567]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.567]                     cond$call), session = sessionInformation(), 
[09:28:22.567]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.567]                   signalCondition(cond)
[09:28:22.567]                 }
[09:28:22.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.567]                 "immediateCondition"))) {
[09:28:22.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.567]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.567]                   if (TRUE && !signal) {
[09:28:22.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.567]                     {
[09:28:22.567]                       inherits <- base::inherits
[09:28:22.567]                       invokeRestart <- base::invokeRestart
[09:28:22.567]                       is.null <- base::is.null
[09:28:22.567]                       muffled <- FALSE
[09:28:22.567]                       if (inherits(cond, "message")) {
[09:28:22.567]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.567]                         if (muffled) 
[09:28:22.567]                           invokeRestart("muffleMessage")
[09:28:22.567]                       }
[09:28:22.567]                       else if (inherits(cond, "warning")) {
[09:28:22.567]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.567]                         if (muffled) 
[09:28:22.567]                           invokeRestart("muffleWarning")
[09:28:22.567]                       }
[09:28:22.567]                       else if (inherits(cond, "condition")) {
[09:28:22.567]                         if (!is.null(pattern)) {
[09:28:22.567]                           computeRestarts <- base::computeRestarts
[09:28:22.567]                           grepl <- base::grepl
[09:28:22.567]                           restarts <- computeRestarts(cond)
[09:28:22.567]                           for (restart in restarts) {
[09:28:22.567]                             name <- restart$name
[09:28:22.567]                             if (is.null(name)) 
[09:28:22.567]                               next
[09:28:22.567]                             if (!grepl(pattern, name)) 
[09:28:22.567]                               next
[09:28:22.567]                             invokeRestart(restart)
[09:28:22.567]                             muffled <- TRUE
[09:28:22.567]                             break
[09:28:22.567]                           }
[09:28:22.567]                         }
[09:28:22.567]                       }
[09:28:22.567]                       invisible(muffled)
[09:28:22.567]                     }
[09:28:22.567]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.567]                   }
[09:28:22.567]                 }
[09:28:22.567]                 else {
[09:28:22.567]                   if (TRUE) {
[09:28:22.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.567]                     {
[09:28:22.567]                       inherits <- base::inherits
[09:28:22.567]                       invokeRestart <- base::invokeRestart
[09:28:22.567]                       is.null <- base::is.null
[09:28:22.567]                       muffled <- FALSE
[09:28:22.567]                       if (inherits(cond, "message")) {
[09:28:22.567]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.567]                         if (muffled) 
[09:28:22.567]                           invokeRestart("muffleMessage")
[09:28:22.567]                       }
[09:28:22.567]                       else if (inherits(cond, "warning")) {
[09:28:22.567]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.567]                         if (muffled) 
[09:28:22.567]                           invokeRestart("muffleWarning")
[09:28:22.567]                       }
[09:28:22.567]                       else if (inherits(cond, "condition")) {
[09:28:22.567]                         if (!is.null(pattern)) {
[09:28:22.567]                           computeRestarts <- base::computeRestarts
[09:28:22.567]                           grepl <- base::grepl
[09:28:22.567]                           restarts <- computeRestarts(cond)
[09:28:22.567]                           for (restart in restarts) {
[09:28:22.567]                             name <- restart$name
[09:28:22.567]                             if (is.null(name)) 
[09:28:22.567]                               next
[09:28:22.567]                             if (!grepl(pattern, name)) 
[09:28:22.567]                               next
[09:28:22.567]                             invokeRestart(restart)
[09:28:22.567]                             muffled <- TRUE
[09:28:22.567]                             break
[09:28:22.567]                           }
[09:28:22.567]                         }
[09:28:22.567]                       }
[09:28:22.567]                       invisible(muffled)
[09:28:22.567]                     }
[09:28:22.567]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.567]                   }
[09:28:22.567]                 }
[09:28:22.567]             }
[09:28:22.567]         }))
[09:28:22.567]     }, error = function(ex) {
[09:28:22.567]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.567]                 ...future.rng), started = ...future.startTime, 
[09:28:22.567]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.567]             version = "1.8"), class = "FutureResult")
[09:28:22.567]     }, finally = {
[09:28:22.567]         if (!identical(...future.workdir, getwd())) 
[09:28:22.567]             setwd(...future.workdir)
[09:28:22.567]         {
[09:28:22.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.567]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.567]             }
[09:28:22.567]             base::options(...future.oldOptions)
[09:28:22.567]             if (.Platform$OS.type == "windows") {
[09:28:22.567]                 old_names <- names(...future.oldEnvVars)
[09:28:22.567]                 envs <- base::Sys.getenv()
[09:28:22.567]                 names <- names(envs)
[09:28:22.567]                 common <- intersect(names, old_names)
[09:28:22.567]                 added <- setdiff(names, old_names)
[09:28:22.567]                 removed <- setdiff(old_names, names)
[09:28:22.567]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.567]                   envs[common]]
[09:28:22.567]                 NAMES <- toupper(changed)
[09:28:22.567]                 args <- list()
[09:28:22.567]                 for (kk in seq_along(NAMES)) {
[09:28:22.567]                   name <- changed[[kk]]
[09:28:22.567]                   NAME <- NAMES[[kk]]
[09:28:22.567]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.567]                     next
[09:28:22.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.567]                 }
[09:28:22.567]                 NAMES <- toupper(added)
[09:28:22.567]                 for (kk in seq_along(NAMES)) {
[09:28:22.567]                   name <- added[[kk]]
[09:28:22.567]                   NAME <- NAMES[[kk]]
[09:28:22.567]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.567]                     next
[09:28:22.567]                   args[[name]] <- ""
[09:28:22.567]                 }
[09:28:22.567]                 NAMES <- toupper(removed)
[09:28:22.567]                 for (kk in seq_along(NAMES)) {
[09:28:22.567]                   name <- removed[[kk]]
[09:28:22.567]                   NAME <- NAMES[[kk]]
[09:28:22.567]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.567]                     next
[09:28:22.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.567]                 }
[09:28:22.567]                 if (length(args) > 0) 
[09:28:22.567]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.567]             }
[09:28:22.567]             else {
[09:28:22.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.567]             }
[09:28:22.567]             {
[09:28:22.567]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.567]                   0L) {
[09:28:22.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.567]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.567]                   base::options(opts)
[09:28:22.567]                 }
[09:28:22.567]                 {
[09:28:22.567]                   {
[09:28:22.567]                     NULL
[09:28:22.567]                     RNGkind("Mersenne-Twister")
[09:28:22.567]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.567]                       inherits = FALSE)
[09:28:22.567]                   }
[09:28:22.567]                   options(future.plan = NULL)
[09:28:22.567]                   if (is.na(NA_character_)) 
[09:28:22.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.567]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.567]                     .init = FALSE)
[09:28:22.567]                 }
[09:28:22.567]             }
[09:28:22.567]         }
[09:28:22.567]     })
[09:28:22.567]     if (TRUE) {
[09:28:22.567]         base::sink(type = "output", split = FALSE)
[09:28:22.567]         if (TRUE) {
[09:28:22.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.567]         }
[09:28:22.567]         else {
[09:28:22.567]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.567]         }
[09:28:22.567]         base::close(...future.stdout)
[09:28:22.567]         ...future.stdout <- NULL
[09:28:22.567]     }
[09:28:22.567]     ...future.result$conditions <- ...future.conditions
[09:28:22.567]     ...future.result$finished <- base::Sys.time()
[09:28:22.567]     ...future.result
[09:28:22.567] }
[09:28:22.569] assign_globals() ...
[09:28:22.569] List of 5
[09:28:22.569]  $ ...future.FUN            :function (object, ...)  
[09:28:22.569]  $ future.call.arguments    :List of 1
[09:28:22.569]   ..$ digits: int 2
[09:28:22.569]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.569]  $ ...future.elements_ii    :List of 6
[09:28:22.569]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[09:28:22.569]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[09:28:22.569]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[09:28:22.569]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[09:28:22.569]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[09:28:22.569]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[09:28:22.569]  $ ...future.seeds_ii       : NULL
[09:28:22.569]  $ ...future.globals.maxSize: NULL
[09:28:22.569]  - attr(*, "where")=List of 5
[09:28:22.569]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.569]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.569]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.569]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.569]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.569]  - attr(*, "resolved")= logi FALSE
[09:28:22.569]  - attr(*, "total_size")= num 1296
[09:28:22.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.569]  - attr(*, "already-done")= logi TRUE
[09:28:22.575] - copied ‘...future.FUN’ to environment
[09:28:22.575] - copied ‘future.call.arguments’ to environment
[09:28:22.575] - copied ‘...future.elements_ii’ to environment
[09:28:22.575] - copied ‘...future.seeds_ii’ to environment
[09:28:22.575] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.576] assign_globals() ... done
[09:28:22.576] plan(): Setting new future strategy stack:
[09:28:22.576] List of future strategies:
[09:28:22.576] 1. sequential:
[09:28:22.576]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.576]    - tweaked: FALSE
[09:28:22.576]    - call: NULL
[09:28:22.576] plan(): nbrOfWorkers() = 1
[09:28:22.578] plan(): Setting new future strategy stack:
[09:28:22.578] List of future strategies:
[09:28:22.578] 1. multisession:
[09:28:22.578]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:22.578]    - tweaked: FALSE
[09:28:22.578]    - call: plan(strategy)
[09:28:22.581] plan(): nbrOfWorkers() = 1
[09:28:22.581] SequentialFuture started (and completed)
[09:28:22.581] - Launch lazy future ... done
[09:28:22.581] run() for ‘SequentialFuture’ ... done
[09:28:22.581] Created future:
[09:28:22.581] SequentialFuture:
[09:28:22.581] Label: ‘future_by-1’
[09:28:22.581] Expression:
[09:28:22.581] {
[09:28:22.581]     do.call(function(...) {
[09:28:22.581]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.581]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.581]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.581]             on.exit(options(oopts), add = TRUE)
[09:28:22.581]         }
[09:28:22.581]         {
[09:28:22.581]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.581]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.581]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.581]             })
[09:28:22.581]         }
[09:28:22.581]     }, args = future.call.arguments)
[09:28:22.581] }
[09:28:22.581] Lazy evaluation: FALSE
[09:28:22.581] Asynchronous evaluation: FALSE
[09:28:22.581] Local evaluation: TRUE
[09:28:22.581] Environment: R_GlobalEnv
[09:28:22.581] Capture standard output: TRUE
[09:28:22.581] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.581] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.581] Packages: <none>
[09:28:22.581] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.581] Resolved: TRUE
[09:28:22.581] Value: 5.48 KiB of class ‘list’
[09:28:22.581] Early signaling: FALSE
[09:28:22.581] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.581] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.582] Chunk #1 of 1 ... DONE
[09:28:22.583] Launching 1 futures (chunks) ... DONE
[09:28:22.583] Resolving 1 futures (chunks) ...
[09:28:22.583] resolve() on list ...
[09:28:22.583]  recursive: 0
[09:28:22.583]  length: 1
[09:28:22.583] 
[09:28:22.583] resolved() for ‘SequentialFuture’ ...
[09:28:22.583] - state: ‘finished’
[09:28:22.583] - run: TRUE
[09:28:22.583] - result: ‘FutureResult’
[09:28:22.583] resolved() for ‘SequentialFuture’ ... done
[09:28:22.583] Future #1
[09:28:22.584] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.584] - nx: 1
[09:28:22.584] - relay: TRUE
[09:28:22.584] - stdout: TRUE
[09:28:22.584] - signal: TRUE
[09:28:22.584] - resignal: FALSE
[09:28:22.584] - force: TRUE
[09:28:22.584] - relayed: [n=1] FALSE
[09:28:22.584] - queued futures: [n=1] FALSE
[09:28:22.584]  - until=1
[09:28:22.584]  - relaying element #1
[09:28:22.585] - relayed: [n=1] TRUE
[09:28:22.585] - queued futures: [n=1] TRUE
[09:28:22.585] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.585]  length: 0 (resolved future 1)
[09:28:22.585] Relaying remaining futures
[09:28:22.585] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.585] - nx: 1
[09:28:22.585] - relay: TRUE
[09:28:22.585] - stdout: TRUE
[09:28:22.585] - signal: TRUE
[09:28:22.585] - resignal: FALSE
[09:28:22.586] - force: TRUE
[09:28:22.586] - relayed: [n=1] TRUE
[09:28:22.586] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.586] - relayed: [n=1] TRUE
[09:28:22.586] - queued futures: [n=1] TRUE
[09:28:22.586] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.586] resolve() on list ... DONE
[09:28:22.586]  - Number of value chunks collected: 1
[09:28:22.586] Resolving 1 futures (chunks) ... DONE
[09:28:22.586] Reducing values from 1 chunks ...
[09:28:22.586]  - Number of values collected after concatenation: 6
[09:28:22.587]  - Number of values expected: 6
[09:28:22.587] Reducing values from 1 chunks ... DONE
[09:28:22.587] future_lapply() ... DONE
[09:28:22.587] future_by_internal() ... DONE
[09:28:22.589] future_by_internal() ...
[09:28:22.589] future_lapply() ...
[09:28:22.593] Number of chunks: 1
[09:28:22.593] getGlobalsAndPackagesXApply() ...
[09:28:22.593]  - future.globals: TRUE
[09:28:22.593] getGlobalsAndPackages() ...
[09:28:22.593] Searching for globals...
[09:28:22.595] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:22.595] Searching for globals ... DONE
[09:28:22.595] Resolving globals: FALSE
[09:28:22.595] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[09:28:22.596] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[09:28:22.596] - globals: [1] ‘FUN’
[09:28:22.596] - packages: [1] ‘stats’
[09:28:22.596] getGlobalsAndPackages() ... DONE
[09:28:22.596]  - globals found/used: [n=1] ‘FUN’
[09:28:22.596]  - needed namespaces: [n=1] ‘stats’
[09:28:22.596] Finding globals ... DONE
[09:28:22.597]  - use_args: TRUE
[09:28:22.597]  - Getting '...' globals ...
[09:28:22.597] resolve() on list ...
[09:28:22.597]  recursive: 0
[09:28:22.597]  length: 1
[09:28:22.597]  elements: ‘...’
[09:28:22.597]  length: 0 (resolved future 1)
[09:28:22.597] resolve() on list ... DONE
[09:28:22.597]    - '...' content: [n=1] ‘singular.ok’
[09:28:22.598] List of 1
[09:28:22.598]  $ ...:List of 1
[09:28:22.598]   ..$ singular.ok: logi FALSE
[09:28:22.598]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.598]  - attr(*, "where")=List of 1
[09:28:22.598]   ..$ ...:<environment: 0x555b0a75eae0> 
[09:28:22.598]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.598]  - attr(*, "resolved")= logi TRUE
[09:28:22.598]  - attr(*, "total_size")= num NA
[09:28:22.600]  - Getting '...' globals ... DONE
[09:28:22.600] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.601] List of 2
[09:28:22.601]  $ ...future.FUN:function (x, ...)  
[09:28:22.601]  $ ...          :List of 1
[09:28:22.601]   ..$ singular.ok: logi FALSE
[09:28:22.601]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.601]  - attr(*, "where")=List of 2
[09:28:22.601]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.601]   ..$ ...          :<environment: 0x555b0a75eae0> 
[09:28:22.601]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.601]  - attr(*, "resolved")= logi FALSE
[09:28:22.601]  - attr(*, "total_size")= num 5384
[09:28:22.603] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:22.603] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.604] Number of futures (= number of chunks): 1
[09:28:22.604] Launching 1 futures (chunks) ...
[09:28:22.604] Chunk #1 of 1 ...
[09:28:22.604]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.604] getGlobalsAndPackages() ...
[09:28:22.604] Searching for globals...
[09:28:22.605] 
[09:28:22.605] Searching for globals ... DONE
[09:28:22.605] - globals: [0] <none>
[09:28:22.605] getGlobalsAndPackages() ... DONE
[09:28:22.605]    + additional globals found: [n=0] 
[09:28:22.605]    + additional namespaces needed: [n=0] 
[09:28:22.605]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.605]  - seeds: <none>
[09:28:22.605]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.605] getGlobalsAndPackages() ...
[09:28:22.605] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.606] Resolving globals: FALSE
[09:28:22.606] Tweak future expression to call with '...' arguments ...
[09:28:22.606] {
[09:28:22.606]     do.call(function(...) {
[09:28:22.606]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.606]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.606]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.606]             on.exit(options(oopts), add = TRUE)
[09:28:22.606]         }
[09:28:22.606]         {
[09:28:22.606]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.606]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.606]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.606]             })
[09:28:22.606]         }
[09:28:22.606]     }, args = future.call.arguments)
[09:28:22.606] }
[09:28:22.606] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.606] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.606] 
[09:28:22.606] getGlobalsAndPackages() ... DONE
[09:28:22.607] run() for ‘Future’ ...
[09:28:22.607] - state: ‘created’
[09:28:22.607] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.610] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.610] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.610]   - Field: ‘label’
[09:28:22.610]   - Field: ‘local’
[09:28:22.611]   - Field: ‘owner’
[09:28:22.611]   - Field: ‘envir’
[09:28:22.611]   - Field: ‘packages’
[09:28:22.611]   - Field: ‘gc’
[09:28:22.611]   - Field: ‘conditions’
[09:28:22.611]   - Field: ‘expr’
[09:28:22.611]   - Field: ‘uuid’
[09:28:22.611]   - Field: ‘seed’
[09:28:22.611]   - Field: ‘version’
[09:28:22.611]   - Field: ‘result’
[09:28:22.611]   - Field: ‘asynchronous’
[09:28:22.611]   - Field: ‘calls’
[09:28:22.612]   - Field: ‘globals’
[09:28:22.612]   - Field: ‘stdout’
[09:28:22.612]   - Field: ‘earlySignal’
[09:28:22.612]   - Field: ‘lazy’
[09:28:22.612]   - Field: ‘state’
[09:28:22.612] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.612] - Launch lazy future ...
[09:28:22.613] Packages needed by the future expression (n = 1): ‘stats’
[09:28:22.613] Packages needed by future strategies (n = 0): <none>
[09:28:22.614] {
[09:28:22.614]     {
[09:28:22.614]         {
[09:28:22.614]             ...future.startTime <- base::Sys.time()
[09:28:22.614]             {
[09:28:22.614]                 {
[09:28:22.614]                   {
[09:28:22.614]                     {
[09:28:22.614]                       base::local({
[09:28:22.614]                         has_future <- base::requireNamespace("future", 
[09:28:22.614]                           quietly = TRUE)
[09:28:22.614]                         if (has_future) {
[09:28:22.614]                           ns <- base::getNamespace("future")
[09:28:22.614]                           version <- ns[[".package"]][["version"]]
[09:28:22.614]                           if (is.null(version)) 
[09:28:22.614]                             version <- utils::packageVersion("future")
[09:28:22.614]                         }
[09:28:22.614]                         else {
[09:28:22.614]                           version <- NULL
[09:28:22.614]                         }
[09:28:22.614]                         if (!has_future || version < "1.8.0") {
[09:28:22.614]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.614]                             "", base::R.version$version.string), 
[09:28:22.614]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:22.614]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.614]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.614]                               "release", "version")], collapse = " "), 
[09:28:22.614]                             hostname = base::Sys.info()[["nodename"]])
[09:28:22.614]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.614]                             info)
[09:28:22.614]                           info <- base::paste(info, collapse = "; ")
[09:28:22.614]                           if (!has_future) {
[09:28:22.614]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.614]                               info)
[09:28:22.614]                           }
[09:28:22.614]                           else {
[09:28:22.614]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.614]                               info, version)
[09:28:22.614]                           }
[09:28:22.614]                           base::stop(msg)
[09:28:22.614]                         }
[09:28:22.614]                       })
[09:28:22.614]                     }
[09:28:22.614]                     base::local({
[09:28:22.614]                       for (pkg in "stats") {
[09:28:22.614]                         base::loadNamespace(pkg)
[09:28:22.614]                         base::library(pkg, character.only = TRUE)
[09:28:22.614]                       }
[09:28:22.614]                     })
[09:28:22.614]                   }
[09:28:22.614]                   ...future.strategy.old <- future::plan("list")
[09:28:22.614]                   options(future.plan = NULL)
[09:28:22.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.614]                 }
[09:28:22.614]                 ...future.workdir <- getwd()
[09:28:22.614]             }
[09:28:22.614]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.614]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.614]         }
[09:28:22.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.614]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.614]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.614]             base::names(...future.oldOptions))
[09:28:22.614]     }
[09:28:22.614]     if (FALSE) {
[09:28:22.614]     }
[09:28:22.614]     else {
[09:28:22.614]         if (TRUE) {
[09:28:22.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.614]                 open = "w")
[09:28:22.614]         }
[09:28:22.614]         else {
[09:28:22.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.614]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.614]         }
[09:28:22.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.614]             base::sink(type = "output", split = FALSE)
[09:28:22.614]             base::close(...future.stdout)
[09:28:22.614]         }, add = TRUE)
[09:28:22.614]     }
[09:28:22.614]     ...future.frame <- base::sys.nframe()
[09:28:22.614]     ...future.conditions <- base::list()
[09:28:22.614]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.614]     if (FALSE) {
[09:28:22.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.614]     }
[09:28:22.614]     ...future.result <- base::tryCatch({
[09:28:22.614]         base::withCallingHandlers({
[09:28:22.614]             ...future.value <- base::withVisible(base::local({
[09:28:22.614]                 do.call(function(...) {
[09:28:22.614]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.614]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.614]                     ...future.globals.maxSize)) {
[09:28:22.614]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.614]                     on.exit(options(oopts), add = TRUE)
[09:28:22.614]                   }
[09:28:22.614]                   {
[09:28:22.614]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.614]                       FUN = function(jj) {
[09:28:22.614]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.614]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.614]                       })
[09:28:22.614]                   }
[09:28:22.614]                 }, args = future.call.arguments)
[09:28:22.614]             }))
[09:28:22.614]             future::FutureResult(value = ...future.value$value, 
[09:28:22.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.614]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.614]                     ...future.globalenv.names))
[09:28:22.614]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.614]         }, condition = base::local({
[09:28:22.614]             c <- base::c
[09:28:22.614]             inherits <- base::inherits
[09:28:22.614]             invokeRestart <- base::invokeRestart
[09:28:22.614]             length <- base::length
[09:28:22.614]             list <- base::list
[09:28:22.614]             seq.int <- base::seq.int
[09:28:22.614]             signalCondition <- base::signalCondition
[09:28:22.614]             sys.calls <- base::sys.calls
[09:28:22.614]             `[[` <- base::`[[`
[09:28:22.614]             `+` <- base::`+`
[09:28:22.614]             `<<-` <- base::`<<-`
[09:28:22.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.614]                   3L)]
[09:28:22.614]             }
[09:28:22.614]             function(cond) {
[09:28:22.614]                 is_error <- inherits(cond, "error")
[09:28:22.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.614]                   NULL)
[09:28:22.614]                 if (is_error) {
[09:28:22.614]                   sessionInformation <- function() {
[09:28:22.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.614]                       search = base::search(), system = base::Sys.info())
[09:28:22.614]                   }
[09:28:22.614]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.614]                     cond$call), session = sessionInformation(), 
[09:28:22.614]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.614]                   signalCondition(cond)
[09:28:22.614]                 }
[09:28:22.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.614]                 "immediateCondition"))) {
[09:28:22.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.614]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.614]                   if (TRUE && !signal) {
[09:28:22.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.614]                     {
[09:28:22.614]                       inherits <- base::inherits
[09:28:22.614]                       invokeRestart <- base::invokeRestart
[09:28:22.614]                       is.null <- base::is.null
[09:28:22.614]                       muffled <- FALSE
[09:28:22.614]                       if (inherits(cond, "message")) {
[09:28:22.614]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.614]                         if (muffled) 
[09:28:22.614]                           invokeRestart("muffleMessage")
[09:28:22.614]                       }
[09:28:22.614]                       else if (inherits(cond, "warning")) {
[09:28:22.614]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.614]                         if (muffled) 
[09:28:22.614]                           invokeRestart("muffleWarning")
[09:28:22.614]                       }
[09:28:22.614]                       else if (inherits(cond, "condition")) {
[09:28:22.614]                         if (!is.null(pattern)) {
[09:28:22.614]                           computeRestarts <- base::computeRestarts
[09:28:22.614]                           grepl <- base::grepl
[09:28:22.614]                           restarts <- computeRestarts(cond)
[09:28:22.614]                           for (restart in restarts) {
[09:28:22.614]                             name <- restart$name
[09:28:22.614]                             if (is.null(name)) 
[09:28:22.614]                               next
[09:28:22.614]                             if (!grepl(pattern, name)) 
[09:28:22.614]                               next
[09:28:22.614]                             invokeRestart(restart)
[09:28:22.614]                             muffled <- TRUE
[09:28:22.614]                             break
[09:28:22.614]                           }
[09:28:22.614]                         }
[09:28:22.614]                       }
[09:28:22.614]                       invisible(muffled)
[09:28:22.614]                     }
[09:28:22.614]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.614]                   }
[09:28:22.614]                 }
[09:28:22.614]                 else {
[09:28:22.614]                   if (TRUE) {
[09:28:22.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.614]                     {
[09:28:22.614]                       inherits <- base::inherits
[09:28:22.614]                       invokeRestart <- base::invokeRestart
[09:28:22.614]                       is.null <- base::is.null
[09:28:22.614]                       muffled <- FALSE
[09:28:22.614]                       if (inherits(cond, "message")) {
[09:28:22.614]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.614]                         if (muffled) 
[09:28:22.614]                           invokeRestart("muffleMessage")
[09:28:22.614]                       }
[09:28:22.614]                       else if (inherits(cond, "warning")) {
[09:28:22.614]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.614]                         if (muffled) 
[09:28:22.614]                           invokeRestart("muffleWarning")
[09:28:22.614]                       }
[09:28:22.614]                       else if (inherits(cond, "condition")) {
[09:28:22.614]                         if (!is.null(pattern)) {
[09:28:22.614]                           computeRestarts <- base::computeRestarts
[09:28:22.614]                           grepl <- base::grepl
[09:28:22.614]                           restarts <- computeRestarts(cond)
[09:28:22.614]                           for (restart in restarts) {
[09:28:22.614]                             name <- restart$name
[09:28:22.614]                             if (is.null(name)) 
[09:28:22.614]                               next
[09:28:22.614]                             if (!grepl(pattern, name)) 
[09:28:22.614]                               next
[09:28:22.614]                             invokeRestart(restart)
[09:28:22.614]                             muffled <- TRUE
[09:28:22.614]                             break
[09:28:22.614]                           }
[09:28:22.614]                         }
[09:28:22.614]                       }
[09:28:22.614]                       invisible(muffled)
[09:28:22.614]                     }
[09:28:22.614]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.614]                   }
[09:28:22.614]                 }
[09:28:22.614]             }
[09:28:22.614]         }))
[09:28:22.614]     }, error = function(ex) {
[09:28:22.614]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.614]                 ...future.rng), started = ...future.startTime, 
[09:28:22.614]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.614]             version = "1.8"), class = "FutureResult")
[09:28:22.614]     }, finally = {
[09:28:22.614]         if (!identical(...future.workdir, getwd())) 
[09:28:22.614]             setwd(...future.workdir)
[09:28:22.614]         {
[09:28:22.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.614]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.614]             }
[09:28:22.614]             base::options(...future.oldOptions)
[09:28:22.614]             if (.Platform$OS.type == "windows") {
[09:28:22.614]                 old_names <- names(...future.oldEnvVars)
[09:28:22.614]                 envs <- base::Sys.getenv()
[09:28:22.614]                 names <- names(envs)
[09:28:22.614]                 common <- intersect(names, old_names)
[09:28:22.614]                 added <- setdiff(names, old_names)
[09:28:22.614]                 removed <- setdiff(old_names, names)
[09:28:22.614]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.614]                   envs[common]]
[09:28:22.614]                 NAMES <- toupper(changed)
[09:28:22.614]                 args <- list()
[09:28:22.614]                 for (kk in seq_along(NAMES)) {
[09:28:22.614]                   name <- changed[[kk]]
[09:28:22.614]                   NAME <- NAMES[[kk]]
[09:28:22.614]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.614]                     next
[09:28:22.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.614]                 }
[09:28:22.614]                 NAMES <- toupper(added)
[09:28:22.614]                 for (kk in seq_along(NAMES)) {
[09:28:22.614]                   name <- added[[kk]]
[09:28:22.614]                   NAME <- NAMES[[kk]]
[09:28:22.614]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.614]                     next
[09:28:22.614]                   args[[name]] <- ""
[09:28:22.614]                 }
[09:28:22.614]                 NAMES <- toupper(removed)
[09:28:22.614]                 for (kk in seq_along(NAMES)) {
[09:28:22.614]                   name <- removed[[kk]]
[09:28:22.614]                   NAME <- NAMES[[kk]]
[09:28:22.614]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.614]                     next
[09:28:22.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.614]                 }
[09:28:22.614]                 if (length(args) > 0) 
[09:28:22.614]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.614]             }
[09:28:22.614]             else {
[09:28:22.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.614]             }
[09:28:22.614]             {
[09:28:22.614]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.614]                   0L) {
[09:28:22.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.614]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.614]                   base::options(opts)
[09:28:22.614]                 }
[09:28:22.614]                 {
[09:28:22.614]                   {
[09:28:22.614]                     NULL
[09:28:22.614]                     RNGkind("Mersenne-Twister")
[09:28:22.614]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.614]                       inherits = FALSE)
[09:28:22.614]                   }
[09:28:22.614]                   options(future.plan = NULL)
[09:28:22.614]                   if (is.na(NA_character_)) 
[09:28:22.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.614]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.614]                     .init = FALSE)
[09:28:22.614]                 }
[09:28:22.614]             }
[09:28:22.614]         }
[09:28:22.614]     })
[09:28:22.614]     if (TRUE) {
[09:28:22.614]         base::sink(type = "output", split = FALSE)
[09:28:22.614]         if (TRUE) {
[09:28:22.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.614]         }
[09:28:22.614]         else {
[09:28:22.614]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.614]         }
[09:28:22.614]         base::close(...future.stdout)
[09:28:22.614]         ...future.stdout <- NULL
[09:28:22.614]     }
[09:28:22.614]     ...future.result$conditions <- ...future.conditions
[09:28:22.614]     ...future.result$finished <- base::Sys.time()
[09:28:22.614]     ...future.result
[09:28:22.614] }
[09:28:22.616] assign_globals() ...
[09:28:22.616] List of 5
[09:28:22.616]  $ ...future.FUN            :function (x, ...)  
[09:28:22.616]  $ future.call.arguments    :List of 1
[09:28:22.616]   ..$ singular.ok: logi FALSE
[09:28:22.616]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.616]  $ ...future.elements_ii    :List of 3
[09:28:22.616]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.616]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.616]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.616]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.616]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.616]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.616]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.616]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.616]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.616]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.616]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.616]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.616]  $ ...future.seeds_ii       : NULL
[09:28:22.616]  $ ...future.globals.maxSize: NULL
[09:28:22.616]  - attr(*, "where")=List of 5
[09:28:22.616]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.616]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.616]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.616]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.616]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.616]  - attr(*, "resolved")= logi FALSE
[09:28:22.616]  - attr(*, "total_size")= num 5384
[09:28:22.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.616]  - attr(*, "already-done")= logi TRUE
[09:28:22.624] - reassign environment for ‘...future.FUN’
[09:28:22.624] - copied ‘...future.FUN’ to environment
[09:28:22.624] - copied ‘future.call.arguments’ to environment
[09:28:22.624] - copied ‘...future.elements_ii’ to environment
[09:28:22.624] - copied ‘...future.seeds_ii’ to environment
[09:28:22.624] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.625] assign_globals() ... done
[09:28:22.625] plan(): Setting new future strategy stack:
[09:28:22.625] List of future strategies:
[09:28:22.625] 1. sequential:
[09:28:22.625]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.625]    - tweaked: FALSE
[09:28:22.625]    - call: NULL
[09:28:22.625] plan(): nbrOfWorkers() = 1
[09:28:22.628] plan(): Setting new future strategy stack:
[09:28:22.628] List of future strategies:
[09:28:22.628] 1. multisession:
[09:28:22.628]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:22.628]    - tweaked: FALSE
[09:28:22.628]    - call: plan(strategy)
[09:28:22.631] plan(): nbrOfWorkers() = 1
[09:28:22.631] SequentialFuture started (and completed)
[09:28:22.631] - Launch lazy future ... done
[09:28:22.632] run() for ‘SequentialFuture’ ... done
[09:28:22.632] Created future:
[09:28:22.632] SequentialFuture:
[09:28:22.632] Label: ‘future_by-1’
[09:28:22.632] Expression:
[09:28:22.632] {
[09:28:22.632]     do.call(function(...) {
[09:28:22.632]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.632]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.632]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.632]             on.exit(options(oopts), add = TRUE)
[09:28:22.632]         }
[09:28:22.632]         {
[09:28:22.632]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.632]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.632]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.632]             })
[09:28:22.632]         }
[09:28:22.632]     }, args = future.call.arguments)
[09:28:22.632] }
[09:28:22.632] Lazy evaluation: FALSE
[09:28:22.632] Asynchronous evaluation: FALSE
[09:28:22.632] Local evaluation: TRUE
[09:28:22.632] Environment: R_GlobalEnv
[09:28:22.632] Capture standard output: TRUE
[09:28:22.632] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.632] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.632] Packages: 1 packages (‘stats’)
[09:28:22.632] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.632] Resolved: TRUE
[09:28:22.632] Value: 26.06 KiB of class ‘list’
[09:28:22.632] Early signaling: FALSE
[09:28:22.632] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.632] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.633] Chunk #1 of 1 ... DONE
[09:28:22.633] Launching 1 futures (chunks) ... DONE
[09:28:22.633] Resolving 1 futures (chunks) ...
[09:28:22.633] resolve() on list ...
[09:28:22.634]  recursive: 0
[09:28:22.634]  length: 1
[09:28:22.634] 
[09:28:22.634] resolved() for ‘SequentialFuture’ ...
[09:28:22.634] - state: ‘finished’
[09:28:22.634] - run: TRUE
[09:28:22.634] - result: ‘FutureResult’
[09:28:22.634] resolved() for ‘SequentialFuture’ ... done
[09:28:22.634] Future #1
[09:28:22.634] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.634] - nx: 1
[09:28:22.635] - relay: TRUE
[09:28:22.635] - stdout: TRUE
[09:28:22.635] - signal: TRUE
[09:28:22.635] - resignal: FALSE
[09:28:22.635] - force: TRUE
[09:28:22.635] - relayed: [n=1] FALSE
[09:28:22.635] - queued futures: [n=1] FALSE
[09:28:22.635]  - until=1
[09:28:22.635]  - relaying element #1
[09:28:22.635] - relayed: [n=1] TRUE
[09:28:22.635] - queued futures: [n=1] TRUE
[09:28:22.636] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.636]  length: 0 (resolved future 1)
[09:28:22.636] Relaying remaining futures
[09:28:22.636] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.637] - nx: 1
[09:28:22.637] - relay: TRUE
[09:28:22.637] - stdout: TRUE
[09:28:22.637] - signal: TRUE
[09:28:22.637] - resignal: FALSE
[09:28:22.637] - force: TRUE
[09:28:22.637] - relayed: [n=1] TRUE
[09:28:22.637] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.638] - relayed: [n=1] TRUE
[09:28:22.638] - queued futures: [n=1] TRUE
[09:28:22.638] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.638] resolve() on list ... DONE
[09:28:22.638]  - Number of value chunks collected: 1
[09:28:22.638] Resolving 1 futures (chunks) ... DONE
[09:28:22.638] Reducing values from 1 chunks ...
[09:28:22.638]  - Number of values collected after concatenation: 3
[09:28:22.638]  - Number of values expected: 3
[09:28:22.638] Reducing values from 1 chunks ... DONE
[09:28:22.639] future_lapply() ... DONE
[09:28:22.639] future_by_internal() ... DONE
[09:28:22.642] future_by_internal() ...
[09:28:22.643] future_lapply() ...
[09:28:22.646] Number of chunks: 1
[09:28:22.646] getGlobalsAndPackagesXApply() ...
[09:28:22.646]  - future.globals: TRUE
[09:28:22.647] getGlobalsAndPackages() ...
[09:28:22.647] Searching for globals...
[09:28:22.648] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:22.648] Searching for globals ... DONE
[09:28:22.648] Resolving globals: FALSE
[09:28:22.649] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[09:28:22.649] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[09:28:22.649] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:22.649] - packages: [1] ‘stats’
[09:28:22.649] getGlobalsAndPackages() ... DONE
[09:28:22.650]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:22.650]  - needed namespaces: [n=1] ‘stats’
[09:28:22.650] Finding globals ... DONE
[09:28:22.650]  - use_args: TRUE
[09:28:22.650]  - Getting '...' globals ...
[09:28:22.650] resolve() on list ...
[09:28:22.650]  recursive: 0
[09:28:22.650]  length: 1
[09:28:22.650]  elements: ‘...’
[09:28:22.651]  length: 0 (resolved future 1)
[09:28:22.651] resolve() on list ... DONE
[09:28:22.651]    - '...' content: [n=0] 
[09:28:22.651] List of 1
[09:28:22.651]  $ ...: list()
[09:28:22.651]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.651]  - attr(*, "where")=List of 1
[09:28:22.651]   ..$ ...:<environment: 0x555b09b861f8> 
[09:28:22.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.651]  - attr(*, "resolved")= logi TRUE
[09:28:22.651]  - attr(*, "total_size")= num NA
[09:28:22.653]  - Getting '...' globals ... DONE
[09:28:22.653] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[09:28:22.653] List of 4
[09:28:22.653]  $ ...future.FUN:function (x)  
[09:28:22.653]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:22.653]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.653]  $ ...          : list()
[09:28:22.653]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.653]  - attr(*, "where")=List of 4
[09:28:22.653]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.653]   ..$ breaks       :<environment: R_EmptyEnv> 
[09:28:22.653]   ..$ wool         :<environment: R_EmptyEnv> 
[09:28:22.653]   ..$ ...          :<environment: 0x555b09b861f8> 
[09:28:22.653]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.653]  - attr(*, "resolved")= logi FALSE
[09:28:22.653]  - attr(*, "total_size")= num 2320
[09:28:22.658] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:22.658] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.659] Number of futures (= number of chunks): 1
[09:28:22.659] Launching 1 futures (chunks) ...
[09:28:22.659] Chunk #1 of 1 ...
[09:28:22.659]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.659] getGlobalsAndPackages() ...
[09:28:22.659] Searching for globals...
[09:28:22.660] 
[09:28:22.660] Searching for globals ... DONE
[09:28:22.660] - globals: [0] <none>
[09:28:22.660] getGlobalsAndPackages() ... DONE
[09:28:22.660]    + additional globals found: [n=0] 
[09:28:22.660]    + additional namespaces needed: [n=0] 
[09:28:22.660]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.660]  - seeds: <none>
[09:28:22.660]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.660] getGlobalsAndPackages() ...
[09:28:22.660] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.661] Resolving globals: FALSE
[09:28:22.661] Tweak future expression to call with '...' arguments ...
[09:28:22.661] {
[09:28:22.661]     do.call(function(...) {
[09:28:22.661]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.661]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.661]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.661]             on.exit(options(oopts), add = TRUE)
[09:28:22.661]         }
[09:28:22.661]         {
[09:28:22.661]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.661]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.661]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.661]             })
[09:28:22.661]         }
[09:28:22.661]     }, args = future.call.arguments)
[09:28:22.661] }
[09:28:22.661] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.661] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.662] 
[09:28:22.662] getGlobalsAndPackages() ... DONE
[09:28:22.662] run() for ‘Future’ ...
[09:28:22.662] - state: ‘created’
[09:28:22.662] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.665] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.666]   - Field: ‘label’
[09:28:22.666]   - Field: ‘local’
[09:28:22.666]   - Field: ‘owner’
[09:28:22.666]   - Field: ‘envir’
[09:28:22.666]   - Field: ‘packages’
[09:28:22.666]   - Field: ‘gc’
[09:28:22.666]   - Field: ‘conditions’
[09:28:22.666]   - Field: ‘expr’
[09:28:22.666]   - Field: ‘uuid’
[09:28:22.666]   - Field: ‘seed’
[09:28:22.666]   - Field: ‘version’
[09:28:22.667]   - Field: ‘result’
[09:28:22.667]   - Field: ‘asynchronous’
[09:28:22.667]   - Field: ‘calls’
[09:28:22.667]   - Field: ‘globals’
[09:28:22.667]   - Field: ‘stdout’
[09:28:22.667]   - Field: ‘earlySignal’
[09:28:22.667]   - Field: ‘lazy’
[09:28:22.667]   - Field: ‘state’
[09:28:22.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.667] - Launch lazy future ...
[09:28:22.667] Packages needed by the future expression (n = 1): ‘stats’
[09:28:22.668] Packages needed by future strategies (n = 0): <none>
[09:28:22.668] {
[09:28:22.668]     {
[09:28:22.668]         {
[09:28:22.668]             ...future.startTime <- base::Sys.time()
[09:28:22.668]             {
[09:28:22.668]                 {
[09:28:22.668]                   {
[09:28:22.668]                     {
[09:28:22.668]                       base::local({
[09:28:22.668]                         has_future <- base::requireNamespace("future", 
[09:28:22.668]                           quietly = TRUE)
[09:28:22.668]                         if (has_future) {
[09:28:22.668]                           ns <- base::getNamespace("future")
[09:28:22.668]                           version <- ns[[".package"]][["version"]]
[09:28:22.668]                           if (is.null(version)) 
[09:28:22.668]                             version <- utils::packageVersion("future")
[09:28:22.668]                         }
[09:28:22.668]                         else {
[09:28:22.668]                           version <- NULL
[09:28:22.668]                         }
[09:28:22.668]                         if (!has_future || version < "1.8.0") {
[09:28:22.668]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.668]                             "", base::R.version$version.string), 
[09:28:22.668]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:22.668]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.668]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.668]                               "release", "version")], collapse = " "), 
[09:28:22.668]                             hostname = base::Sys.info()[["nodename"]])
[09:28:22.668]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.668]                             info)
[09:28:22.668]                           info <- base::paste(info, collapse = "; ")
[09:28:22.668]                           if (!has_future) {
[09:28:22.668]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.668]                               info)
[09:28:22.668]                           }
[09:28:22.668]                           else {
[09:28:22.668]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.668]                               info, version)
[09:28:22.668]                           }
[09:28:22.668]                           base::stop(msg)
[09:28:22.668]                         }
[09:28:22.668]                       })
[09:28:22.668]                     }
[09:28:22.668]                     base::local({
[09:28:22.668]                       for (pkg in "stats") {
[09:28:22.668]                         base::loadNamespace(pkg)
[09:28:22.668]                         base::library(pkg, character.only = TRUE)
[09:28:22.668]                       }
[09:28:22.668]                     })
[09:28:22.668]                   }
[09:28:22.668]                   ...future.strategy.old <- future::plan("list")
[09:28:22.668]                   options(future.plan = NULL)
[09:28:22.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.668]                 }
[09:28:22.668]                 ...future.workdir <- getwd()
[09:28:22.668]             }
[09:28:22.668]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.668]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.668]         }
[09:28:22.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.668]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.668]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.668]             base::names(...future.oldOptions))
[09:28:22.668]     }
[09:28:22.668]     if (FALSE) {
[09:28:22.668]     }
[09:28:22.668]     else {
[09:28:22.668]         if (TRUE) {
[09:28:22.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.668]                 open = "w")
[09:28:22.668]         }
[09:28:22.668]         else {
[09:28:22.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.668]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.668]         }
[09:28:22.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.668]             base::sink(type = "output", split = FALSE)
[09:28:22.668]             base::close(...future.stdout)
[09:28:22.668]         }, add = TRUE)
[09:28:22.668]     }
[09:28:22.668]     ...future.frame <- base::sys.nframe()
[09:28:22.668]     ...future.conditions <- base::list()
[09:28:22.668]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.668]     if (FALSE) {
[09:28:22.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.668]     }
[09:28:22.668]     ...future.result <- base::tryCatch({
[09:28:22.668]         base::withCallingHandlers({
[09:28:22.668]             ...future.value <- base::withVisible(base::local({
[09:28:22.668]                 do.call(function(...) {
[09:28:22.668]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.668]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.668]                     ...future.globals.maxSize)) {
[09:28:22.668]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.668]                     on.exit(options(oopts), add = TRUE)
[09:28:22.668]                   }
[09:28:22.668]                   {
[09:28:22.668]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.668]                       FUN = function(jj) {
[09:28:22.668]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.668]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.668]                       })
[09:28:22.668]                   }
[09:28:22.668]                 }, args = future.call.arguments)
[09:28:22.668]             }))
[09:28:22.668]             future::FutureResult(value = ...future.value$value, 
[09:28:22.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.668]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.668]                     ...future.globalenv.names))
[09:28:22.668]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.668]         }, condition = base::local({
[09:28:22.668]             c <- base::c
[09:28:22.668]             inherits <- base::inherits
[09:28:22.668]             invokeRestart <- base::invokeRestart
[09:28:22.668]             length <- base::length
[09:28:22.668]             list <- base::list
[09:28:22.668]             seq.int <- base::seq.int
[09:28:22.668]             signalCondition <- base::signalCondition
[09:28:22.668]             sys.calls <- base::sys.calls
[09:28:22.668]             `[[` <- base::`[[`
[09:28:22.668]             `+` <- base::`+`
[09:28:22.668]             `<<-` <- base::`<<-`
[09:28:22.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.668]                   3L)]
[09:28:22.668]             }
[09:28:22.668]             function(cond) {
[09:28:22.668]                 is_error <- inherits(cond, "error")
[09:28:22.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.668]                   NULL)
[09:28:22.668]                 if (is_error) {
[09:28:22.668]                   sessionInformation <- function() {
[09:28:22.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.668]                       search = base::search(), system = base::Sys.info())
[09:28:22.668]                   }
[09:28:22.668]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.668]                     cond$call), session = sessionInformation(), 
[09:28:22.668]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.668]                   signalCondition(cond)
[09:28:22.668]                 }
[09:28:22.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.668]                 "immediateCondition"))) {
[09:28:22.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.668]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.668]                   if (TRUE && !signal) {
[09:28:22.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.668]                     {
[09:28:22.668]                       inherits <- base::inherits
[09:28:22.668]                       invokeRestart <- base::invokeRestart
[09:28:22.668]                       is.null <- base::is.null
[09:28:22.668]                       muffled <- FALSE
[09:28:22.668]                       if (inherits(cond, "message")) {
[09:28:22.668]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.668]                         if (muffled) 
[09:28:22.668]                           invokeRestart("muffleMessage")
[09:28:22.668]                       }
[09:28:22.668]                       else if (inherits(cond, "warning")) {
[09:28:22.668]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.668]                         if (muffled) 
[09:28:22.668]                           invokeRestart("muffleWarning")
[09:28:22.668]                       }
[09:28:22.668]                       else if (inherits(cond, "condition")) {
[09:28:22.668]                         if (!is.null(pattern)) {
[09:28:22.668]                           computeRestarts <- base::computeRestarts
[09:28:22.668]                           grepl <- base::grepl
[09:28:22.668]                           restarts <- computeRestarts(cond)
[09:28:22.668]                           for (restart in restarts) {
[09:28:22.668]                             name <- restart$name
[09:28:22.668]                             if (is.null(name)) 
[09:28:22.668]                               next
[09:28:22.668]                             if (!grepl(pattern, name)) 
[09:28:22.668]                               next
[09:28:22.668]                             invokeRestart(restart)
[09:28:22.668]                             muffled <- TRUE
[09:28:22.668]                             break
[09:28:22.668]                           }
[09:28:22.668]                         }
[09:28:22.668]                       }
[09:28:22.668]                       invisible(muffled)
[09:28:22.668]                     }
[09:28:22.668]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.668]                   }
[09:28:22.668]                 }
[09:28:22.668]                 else {
[09:28:22.668]                   if (TRUE) {
[09:28:22.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.668]                     {
[09:28:22.668]                       inherits <- base::inherits
[09:28:22.668]                       invokeRestart <- base::invokeRestart
[09:28:22.668]                       is.null <- base::is.null
[09:28:22.668]                       muffled <- FALSE
[09:28:22.668]                       if (inherits(cond, "message")) {
[09:28:22.668]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.668]                         if (muffled) 
[09:28:22.668]                           invokeRestart("muffleMessage")
[09:28:22.668]                       }
[09:28:22.668]                       else if (inherits(cond, "warning")) {
[09:28:22.668]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.668]                         if (muffled) 
[09:28:22.668]                           invokeRestart("muffleWarning")
[09:28:22.668]                       }
[09:28:22.668]                       else if (inherits(cond, "condition")) {
[09:28:22.668]                         if (!is.null(pattern)) {
[09:28:22.668]                           computeRestarts <- base::computeRestarts
[09:28:22.668]                           grepl <- base::grepl
[09:28:22.668]                           restarts <- computeRestarts(cond)
[09:28:22.668]                           for (restart in restarts) {
[09:28:22.668]                             name <- restart$name
[09:28:22.668]                             if (is.null(name)) 
[09:28:22.668]                               next
[09:28:22.668]                             if (!grepl(pattern, name)) 
[09:28:22.668]                               next
[09:28:22.668]                             invokeRestart(restart)
[09:28:22.668]                             muffled <- TRUE
[09:28:22.668]                             break
[09:28:22.668]                           }
[09:28:22.668]                         }
[09:28:22.668]                       }
[09:28:22.668]                       invisible(muffled)
[09:28:22.668]                     }
[09:28:22.668]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.668]                   }
[09:28:22.668]                 }
[09:28:22.668]             }
[09:28:22.668]         }))
[09:28:22.668]     }, error = function(ex) {
[09:28:22.668]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.668]                 ...future.rng), started = ...future.startTime, 
[09:28:22.668]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.668]             version = "1.8"), class = "FutureResult")
[09:28:22.668]     }, finally = {
[09:28:22.668]         if (!identical(...future.workdir, getwd())) 
[09:28:22.668]             setwd(...future.workdir)
[09:28:22.668]         {
[09:28:22.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.668]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.668]             }
[09:28:22.668]             base::options(...future.oldOptions)
[09:28:22.668]             if (.Platform$OS.type == "windows") {
[09:28:22.668]                 old_names <- names(...future.oldEnvVars)
[09:28:22.668]                 envs <- base::Sys.getenv()
[09:28:22.668]                 names <- names(envs)
[09:28:22.668]                 common <- intersect(names, old_names)
[09:28:22.668]                 added <- setdiff(names, old_names)
[09:28:22.668]                 removed <- setdiff(old_names, names)
[09:28:22.668]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.668]                   envs[common]]
[09:28:22.668]                 NAMES <- toupper(changed)
[09:28:22.668]                 args <- list()
[09:28:22.668]                 for (kk in seq_along(NAMES)) {
[09:28:22.668]                   name <- changed[[kk]]
[09:28:22.668]                   NAME <- NAMES[[kk]]
[09:28:22.668]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.668]                     next
[09:28:22.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.668]                 }
[09:28:22.668]                 NAMES <- toupper(added)
[09:28:22.668]                 for (kk in seq_along(NAMES)) {
[09:28:22.668]                   name <- added[[kk]]
[09:28:22.668]                   NAME <- NAMES[[kk]]
[09:28:22.668]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.668]                     next
[09:28:22.668]                   args[[name]] <- ""
[09:28:22.668]                 }
[09:28:22.668]                 NAMES <- toupper(removed)
[09:28:22.668]                 for (kk in seq_along(NAMES)) {
[09:28:22.668]                   name <- removed[[kk]]
[09:28:22.668]                   NAME <- NAMES[[kk]]
[09:28:22.668]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.668]                     next
[09:28:22.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.668]                 }
[09:28:22.668]                 if (length(args) > 0) 
[09:28:22.668]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.668]             }
[09:28:22.668]             else {
[09:28:22.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.668]             }
[09:28:22.668]             {
[09:28:22.668]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.668]                   0L) {
[09:28:22.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.668]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.668]                   base::options(opts)
[09:28:22.668]                 }
[09:28:22.668]                 {
[09:28:22.668]                   {
[09:28:22.668]                     NULL
[09:28:22.668]                     RNGkind("Mersenne-Twister")
[09:28:22.668]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.668]                       inherits = FALSE)
[09:28:22.668]                   }
[09:28:22.668]                   options(future.plan = NULL)
[09:28:22.668]                   if (is.na(NA_character_)) 
[09:28:22.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.668]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.668]                     .init = FALSE)
[09:28:22.668]                 }
[09:28:22.668]             }
[09:28:22.668]         }
[09:28:22.668]     })
[09:28:22.668]     if (TRUE) {
[09:28:22.668]         base::sink(type = "output", split = FALSE)
[09:28:22.668]         if (TRUE) {
[09:28:22.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.668]         }
[09:28:22.668]         else {
[09:28:22.668]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.668]         }
[09:28:22.668]         base::close(...future.stdout)
[09:28:22.668]         ...future.stdout <- NULL
[09:28:22.668]     }
[09:28:22.668]     ...future.result$conditions <- ...future.conditions
[09:28:22.668]     ...future.result$finished <- base::Sys.time()
[09:28:22.668]     ...future.result
[09:28:22.668] }
[09:28:22.670] assign_globals() ...
[09:28:22.670] List of 7
[09:28:22.670]  $ ...future.FUN            :function (x)  
[09:28:22.670]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:22.670]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.670]  $ future.call.arguments    : list()
[09:28:22.670]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.670]  $ ...future.elements_ii    :List of 3
[09:28:22.670]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.670]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.670]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.670]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.670]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.670]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.670]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.670]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.670]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.670]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.670]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.670]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.670]  $ ...future.seeds_ii       : NULL
[09:28:22.670]  $ ...future.globals.maxSize: NULL
[09:28:22.670]  - attr(*, "where")=List of 7
[09:28:22.670]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.670]   ..$ breaks                   :<environment: R_EmptyEnv> 
[09:28:22.670]   ..$ wool                     :<environment: R_EmptyEnv> 
[09:28:22.670]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.670]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.670]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.670]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.670]  - attr(*, "resolved")= logi FALSE
[09:28:22.670]  - attr(*, "total_size")= num 2320
[09:28:22.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.670]  - attr(*, "already-done")= logi TRUE
[09:28:22.679] - reassign environment for ‘...future.FUN’
[09:28:22.679] - copied ‘...future.FUN’ to environment
[09:28:22.679] - copied ‘breaks’ to environment
[09:28:22.679] - copied ‘wool’ to environment
[09:28:22.679] - copied ‘future.call.arguments’ to environment
[09:28:22.680] - copied ‘...future.elements_ii’ to environment
[09:28:22.680] - copied ‘...future.seeds_ii’ to environment
[09:28:22.681] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.681] assign_globals() ... done
[09:28:22.681] plan(): Setting new future strategy stack:
[09:28:22.681] List of future strategies:
[09:28:22.681] 1. sequential:
[09:28:22.681]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.681]    - tweaked: FALSE
[09:28:22.681]    - call: NULL
[09:28:22.682] plan(): nbrOfWorkers() = 1
[09:28:22.684] plan(): Setting new future strategy stack:
[09:28:22.684] List of future strategies:
[09:28:22.684] 1. multisession:
[09:28:22.684]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:22.684]    - tweaked: FALSE
[09:28:22.684]    - call: plan(strategy)
[09:28:22.687] plan(): nbrOfWorkers() = 1
[09:28:22.688] SequentialFuture started (and completed)
[09:28:22.688] - Launch lazy future ... done
[09:28:22.688] run() for ‘SequentialFuture’ ... done
[09:28:22.688] Created future:
[09:28:22.688] SequentialFuture:
[09:28:22.688] Label: ‘future_by-1’
[09:28:22.688] Expression:
[09:28:22.688] {
[09:28:22.688]     do.call(function(...) {
[09:28:22.688]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.688]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.688]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.688]             on.exit(options(oopts), add = TRUE)
[09:28:22.688]         }
[09:28:22.688]         {
[09:28:22.688]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.688]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.688]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.688]             })
[09:28:22.688]         }
[09:28:22.688]     }, args = future.call.arguments)
[09:28:22.688] }
[09:28:22.688] Lazy evaluation: FALSE
[09:28:22.688] Asynchronous evaluation: FALSE
[09:28:22.688] Local evaluation: TRUE
[09:28:22.688] Environment: 0x555b08c52a68
[09:28:22.688] Capture standard output: TRUE
[09:28:22.688] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.688] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[09:28:22.688] Packages: 1 packages (‘stats’)
[09:28:22.688] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.688] Resolved: TRUE
[09:28:22.688] Value: 25.57 KiB of class ‘list’
[09:28:22.688] Early signaling: FALSE
[09:28:22.688] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.688] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.690] Chunk #1 of 1 ... DONE
[09:28:22.690] Launching 1 futures (chunks) ... DONE
[09:28:22.690] Resolving 1 futures (chunks) ...
[09:28:22.690] resolve() on list ...
[09:28:22.690]  recursive: 0
[09:28:22.690]  length: 1
[09:28:22.690] 
[09:28:22.690] resolved() for ‘SequentialFuture’ ...
[09:28:22.690] - state: ‘finished’
[09:28:22.690] - run: TRUE
[09:28:22.690] - result: ‘FutureResult’
[09:28:22.691] resolved() for ‘SequentialFuture’ ... done
[09:28:22.691] Future #1
[09:28:22.691] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.691] - nx: 1
[09:28:22.691] - relay: TRUE
[09:28:22.691] - stdout: TRUE
[09:28:22.691] - signal: TRUE
[09:28:22.691] - resignal: FALSE
[09:28:22.691] - force: TRUE
[09:28:22.691] - relayed: [n=1] FALSE
[09:28:22.691] - queued futures: [n=1] FALSE
[09:28:22.692]  - until=1
[09:28:22.692]  - relaying element #1
[09:28:22.692] - relayed: [n=1] TRUE
[09:28:22.692] - queued futures: [n=1] TRUE
[09:28:22.692] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.692]  length: 0 (resolved future 1)
[09:28:22.692] Relaying remaining futures
[09:28:22.692] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.692] - nx: 1
[09:28:22.692] - relay: TRUE
[09:28:22.692] - stdout: TRUE
[09:28:22.693] - signal: TRUE
[09:28:22.693] - resignal: FALSE
[09:28:22.693] - force: TRUE
[09:28:22.693] - relayed: [n=1] TRUE
[09:28:22.693] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.693] - relayed: [n=1] TRUE
[09:28:22.693] - queued futures: [n=1] TRUE
[09:28:22.693] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.693] resolve() on list ... DONE
[09:28:22.693]  - Number of value chunks collected: 1
[09:28:22.694] Resolving 1 futures (chunks) ... DONE
[09:28:22.694] Reducing values from 1 chunks ...
[09:28:22.694]  - Number of values collected after concatenation: 3
[09:28:22.694]  - Number of values expected: 3
[09:28:22.694] Reducing values from 1 chunks ... DONE
[09:28:22.694] future_lapply() ... DONE
[09:28:22.694] future_by_internal() ... DONE
[09:28:22.694] future_by_internal() ...
[09:28:22.695] future_lapply() ...
[09:28:22.698] Number of chunks: 1
[09:28:22.698] getGlobalsAndPackagesXApply() ...
[09:28:22.698]  - future.globals: TRUE
[09:28:22.698] getGlobalsAndPackages() ...
[09:28:22.698] Searching for globals...
[09:28:22.699] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.700] Searching for globals ... DONE
[09:28:22.700] Resolving globals: FALSE
[09:28:22.700] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.700] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.700] - globals: [1] ‘FUN’
[09:28:22.700] 
[09:28:22.701] getGlobalsAndPackages() ... DONE
[09:28:22.701]  - globals found/used: [n=1] ‘FUN’
[09:28:22.701]  - needed namespaces: [n=0] 
[09:28:22.701] Finding globals ... DONE
[09:28:22.701]  - use_args: TRUE
[09:28:22.701]  - Getting '...' globals ...
[09:28:22.701] resolve() on list ...
[09:28:22.701]  recursive: 0
[09:28:22.701]  length: 1
[09:28:22.702]  elements: ‘...’
[09:28:22.702]  length: 0 (resolved future 1)
[09:28:22.702] resolve() on list ... DONE
[09:28:22.702]    - '...' content: [n=0] 
[09:28:22.702] List of 1
[09:28:22.702]  $ ...: list()
[09:28:22.702]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.702]  - attr(*, "where")=List of 1
[09:28:22.702]   ..$ ...:<environment: 0x555b0a3cb7e0> 
[09:28:22.702]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.702]  - attr(*, "resolved")= logi TRUE
[09:28:22.702]  - attr(*, "total_size")= num NA
[09:28:22.705]  - Getting '...' globals ... DONE
[09:28:22.705] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.706] List of 2
[09:28:22.706]  $ ...future.FUN:function (object, ...)  
[09:28:22.706]  $ ...          : list()
[09:28:22.706]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.706]  - attr(*, "where")=List of 2
[09:28:22.706]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.706]   ..$ ...          :<environment: 0x555b0a3cb7e0> 
[09:28:22.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.706]  - attr(*, "resolved")= logi FALSE
[09:28:22.706]  - attr(*, "total_size")= num 1240
[09:28:22.708] Packages to be attached in all futures: [n=0] 
[09:28:22.708] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.709] Number of futures (= number of chunks): 1
[09:28:22.709] Launching 1 futures (chunks) ...
[09:28:22.709] Chunk #1 of 1 ...
[09:28:22.709]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.709] getGlobalsAndPackages() ...
[09:28:22.709] Searching for globals...
[09:28:22.709] 
[09:28:22.710] Searching for globals ... DONE
[09:28:22.710] - globals: [0] <none>
[09:28:22.710] getGlobalsAndPackages() ... DONE
[09:28:22.710]    + additional globals found: [n=0] 
[09:28:22.710]    + additional namespaces needed: [n=0] 
[09:28:22.710]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.710]  - seeds: <none>
[09:28:22.710]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.710] getGlobalsAndPackages() ...
[09:28:22.710] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.710] Resolving globals: FALSE
[09:28:22.711] Tweak future expression to call with '...' arguments ...
[09:28:22.711] {
[09:28:22.711]     do.call(function(...) {
[09:28:22.711]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.711]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.711]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.711]             on.exit(options(oopts), add = TRUE)
[09:28:22.711]         }
[09:28:22.711]         {
[09:28:22.711]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.711]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.711]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.711]             })
[09:28:22.711]         }
[09:28:22.711]     }, args = future.call.arguments)
[09:28:22.711] }
[09:28:22.711] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.711] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.711] 
[09:28:22.711] getGlobalsAndPackages() ... DONE
[09:28:22.712] run() for ‘Future’ ...
[09:28:22.712] - state: ‘created’
[09:28:22.712] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.715] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.715]   - Field: ‘label’
[09:28:22.715]   - Field: ‘local’
[09:28:22.715]   - Field: ‘owner’
[09:28:22.715]   - Field: ‘envir’
[09:28:22.716]   - Field: ‘packages’
[09:28:22.716]   - Field: ‘gc’
[09:28:22.716]   - Field: ‘conditions’
[09:28:22.716]   - Field: ‘expr’
[09:28:22.716]   - Field: ‘uuid’
[09:28:22.716]   - Field: ‘seed’
[09:28:22.716]   - Field: ‘version’
[09:28:22.716]   - Field: ‘result’
[09:28:22.716]   - Field: ‘asynchronous’
[09:28:22.716]   - Field: ‘calls’
[09:28:22.716]   - Field: ‘globals’
[09:28:22.717]   - Field: ‘stdout’
[09:28:22.717]   - Field: ‘earlySignal’
[09:28:22.717]   - Field: ‘lazy’
[09:28:22.717]   - Field: ‘state’
[09:28:22.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.717] - Launch lazy future ...
[09:28:22.717] Packages needed by the future expression (n = 0): <none>
[09:28:22.717] Packages needed by future strategies (n = 0): <none>
[09:28:22.718] {
[09:28:22.718]     {
[09:28:22.718]         {
[09:28:22.718]             ...future.startTime <- base::Sys.time()
[09:28:22.718]             {
[09:28:22.718]                 {
[09:28:22.718]                   {
[09:28:22.718]                     base::local({
[09:28:22.718]                       has_future <- base::requireNamespace("future", 
[09:28:22.718]                         quietly = TRUE)
[09:28:22.718]                       if (has_future) {
[09:28:22.718]                         ns <- base::getNamespace("future")
[09:28:22.718]                         version <- ns[[".package"]][["version"]]
[09:28:22.718]                         if (is.null(version)) 
[09:28:22.718]                           version <- utils::packageVersion("future")
[09:28:22.718]                       }
[09:28:22.718]                       else {
[09:28:22.718]                         version <- NULL
[09:28:22.718]                       }
[09:28:22.718]                       if (!has_future || version < "1.8.0") {
[09:28:22.718]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.718]                           "", base::R.version$version.string), 
[09:28:22.718]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.718]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.718]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.718]                             "release", "version")], collapse = " "), 
[09:28:22.718]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.718]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.718]                           info)
[09:28:22.718]                         info <- base::paste(info, collapse = "; ")
[09:28:22.718]                         if (!has_future) {
[09:28:22.718]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.718]                             info)
[09:28:22.718]                         }
[09:28:22.718]                         else {
[09:28:22.718]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.718]                             info, version)
[09:28:22.718]                         }
[09:28:22.718]                         base::stop(msg)
[09:28:22.718]                       }
[09:28:22.718]                     })
[09:28:22.718]                   }
[09:28:22.718]                   ...future.strategy.old <- future::plan("list")
[09:28:22.718]                   options(future.plan = NULL)
[09:28:22.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.718]                 }
[09:28:22.718]                 ...future.workdir <- getwd()
[09:28:22.718]             }
[09:28:22.718]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.718]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.718]         }
[09:28:22.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.718]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.718]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.718]             base::names(...future.oldOptions))
[09:28:22.718]     }
[09:28:22.718]     if (FALSE) {
[09:28:22.718]     }
[09:28:22.718]     else {
[09:28:22.718]         if (TRUE) {
[09:28:22.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.718]                 open = "w")
[09:28:22.718]         }
[09:28:22.718]         else {
[09:28:22.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.718]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.718]         }
[09:28:22.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.718]             base::sink(type = "output", split = FALSE)
[09:28:22.718]             base::close(...future.stdout)
[09:28:22.718]         }, add = TRUE)
[09:28:22.718]     }
[09:28:22.718]     ...future.frame <- base::sys.nframe()
[09:28:22.718]     ...future.conditions <- base::list()
[09:28:22.718]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.718]     if (FALSE) {
[09:28:22.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.718]     }
[09:28:22.718]     ...future.result <- base::tryCatch({
[09:28:22.718]         base::withCallingHandlers({
[09:28:22.718]             ...future.value <- base::withVisible(base::local({
[09:28:22.718]                 do.call(function(...) {
[09:28:22.718]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.718]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.718]                     ...future.globals.maxSize)) {
[09:28:22.718]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.718]                     on.exit(options(oopts), add = TRUE)
[09:28:22.718]                   }
[09:28:22.718]                   {
[09:28:22.718]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.718]                       FUN = function(jj) {
[09:28:22.718]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.718]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.718]                       })
[09:28:22.718]                   }
[09:28:22.718]                 }, args = future.call.arguments)
[09:28:22.718]             }))
[09:28:22.718]             future::FutureResult(value = ...future.value$value, 
[09:28:22.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.718]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.718]                     ...future.globalenv.names))
[09:28:22.718]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.718]         }, condition = base::local({
[09:28:22.718]             c <- base::c
[09:28:22.718]             inherits <- base::inherits
[09:28:22.718]             invokeRestart <- base::invokeRestart
[09:28:22.718]             length <- base::length
[09:28:22.718]             list <- base::list
[09:28:22.718]             seq.int <- base::seq.int
[09:28:22.718]             signalCondition <- base::signalCondition
[09:28:22.718]             sys.calls <- base::sys.calls
[09:28:22.718]             `[[` <- base::`[[`
[09:28:22.718]             `+` <- base::`+`
[09:28:22.718]             `<<-` <- base::`<<-`
[09:28:22.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.718]                   3L)]
[09:28:22.718]             }
[09:28:22.718]             function(cond) {
[09:28:22.718]                 is_error <- inherits(cond, "error")
[09:28:22.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.718]                   NULL)
[09:28:22.718]                 if (is_error) {
[09:28:22.718]                   sessionInformation <- function() {
[09:28:22.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.718]                       search = base::search(), system = base::Sys.info())
[09:28:22.718]                   }
[09:28:22.718]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.718]                     cond$call), session = sessionInformation(), 
[09:28:22.718]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.718]                   signalCondition(cond)
[09:28:22.718]                 }
[09:28:22.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.718]                 "immediateCondition"))) {
[09:28:22.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.718]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.718]                   if (TRUE && !signal) {
[09:28:22.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.718]                     {
[09:28:22.718]                       inherits <- base::inherits
[09:28:22.718]                       invokeRestart <- base::invokeRestart
[09:28:22.718]                       is.null <- base::is.null
[09:28:22.718]                       muffled <- FALSE
[09:28:22.718]                       if (inherits(cond, "message")) {
[09:28:22.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.718]                         if (muffled) 
[09:28:22.718]                           invokeRestart("muffleMessage")
[09:28:22.718]                       }
[09:28:22.718]                       else if (inherits(cond, "warning")) {
[09:28:22.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.718]                         if (muffled) 
[09:28:22.718]                           invokeRestart("muffleWarning")
[09:28:22.718]                       }
[09:28:22.718]                       else if (inherits(cond, "condition")) {
[09:28:22.718]                         if (!is.null(pattern)) {
[09:28:22.718]                           computeRestarts <- base::computeRestarts
[09:28:22.718]                           grepl <- base::grepl
[09:28:22.718]                           restarts <- computeRestarts(cond)
[09:28:22.718]                           for (restart in restarts) {
[09:28:22.718]                             name <- restart$name
[09:28:22.718]                             if (is.null(name)) 
[09:28:22.718]                               next
[09:28:22.718]                             if (!grepl(pattern, name)) 
[09:28:22.718]                               next
[09:28:22.718]                             invokeRestart(restart)
[09:28:22.718]                             muffled <- TRUE
[09:28:22.718]                             break
[09:28:22.718]                           }
[09:28:22.718]                         }
[09:28:22.718]                       }
[09:28:22.718]                       invisible(muffled)
[09:28:22.718]                     }
[09:28:22.718]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.718]                   }
[09:28:22.718]                 }
[09:28:22.718]                 else {
[09:28:22.718]                   if (TRUE) {
[09:28:22.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.718]                     {
[09:28:22.718]                       inherits <- base::inherits
[09:28:22.718]                       invokeRestart <- base::invokeRestart
[09:28:22.718]                       is.null <- base::is.null
[09:28:22.718]                       muffled <- FALSE
[09:28:22.718]                       if (inherits(cond, "message")) {
[09:28:22.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.718]                         if (muffled) 
[09:28:22.718]                           invokeRestart("muffleMessage")
[09:28:22.718]                       }
[09:28:22.718]                       else if (inherits(cond, "warning")) {
[09:28:22.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.718]                         if (muffled) 
[09:28:22.718]                           invokeRestart("muffleWarning")
[09:28:22.718]                       }
[09:28:22.718]                       else if (inherits(cond, "condition")) {
[09:28:22.718]                         if (!is.null(pattern)) {
[09:28:22.718]                           computeRestarts <- base::computeRestarts
[09:28:22.718]                           grepl <- base::grepl
[09:28:22.718]                           restarts <- computeRestarts(cond)
[09:28:22.718]                           for (restart in restarts) {
[09:28:22.718]                             name <- restart$name
[09:28:22.718]                             if (is.null(name)) 
[09:28:22.718]                               next
[09:28:22.718]                             if (!grepl(pattern, name)) 
[09:28:22.718]                               next
[09:28:22.718]                             invokeRestart(restart)
[09:28:22.718]                             muffled <- TRUE
[09:28:22.718]                             break
[09:28:22.718]                           }
[09:28:22.718]                         }
[09:28:22.718]                       }
[09:28:22.718]                       invisible(muffled)
[09:28:22.718]                     }
[09:28:22.718]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.718]                   }
[09:28:22.718]                 }
[09:28:22.718]             }
[09:28:22.718]         }))
[09:28:22.718]     }, error = function(ex) {
[09:28:22.718]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.718]                 ...future.rng), started = ...future.startTime, 
[09:28:22.718]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.718]             version = "1.8"), class = "FutureResult")
[09:28:22.718]     }, finally = {
[09:28:22.718]         if (!identical(...future.workdir, getwd())) 
[09:28:22.718]             setwd(...future.workdir)
[09:28:22.718]         {
[09:28:22.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.718]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.718]             }
[09:28:22.718]             base::options(...future.oldOptions)
[09:28:22.718]             if (.Platform$OS.type == "windows") {
[09:28:22.718]                 old_names <- names(...future.oldEnvVars)
[09:28:22.718]                 envs <- base::Sys.getenv()
[09:28:22.718]                 names <- names(envs)
[09:28:22.718]                 common <- intersect(names, old_names)
[09:28:22.718]                 added <- setdiff(names, old_names)
[09:28:22.718]                 removed <- setdiff(old_names, names)
[09:28:22.718]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.718]                   envs[common]]
[09:28:22.718]                 NAMES <- toupper(changed)
[09:28:22.718]                 args <- list()
[09:28:22.718]                 for (kk in seq_along(NAMES)) {
[09:28:22.718]                   name <- changed[[kk]]
[09:28:22.718]                   NAME <- NAMES[[kk]]
[09:28:22.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.718]                     next
[09:28:22.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.718]                 }
[09:28:22.718]                 NAMES <- toupper(added)
[09:28:22.718]                 for (kk in seq_along(NAMES)) {
[09:28:22.718]                   name <- added[[kk]]
[09:28:22.718]                   NAME <- NAMES[[kk]]
[09:28:22.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.718]                     next
[09:28:22.718]                   args[[name]] <- ""
[09:28:22.718]                 }
[09:28:22.718]                 NAMES <- toupper(removed)
[09:28:22.718]                 for (kk in seq_along(NAMES)) {
[09:28:22.718]                   name <- removed[[kk]]
[09:28:22.718]                   NAME <- NAMES[[kk]]
[09:28:22.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.718]                     next
[09:28:22.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.718]                 }
[09:28:22.718]                 if (length(args) > 0) 
[09:28:22.718]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.718]             }
[09:28:22.718]             else {
[09:28:22.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.718]             }
[09:28:22.718]             {
[09:28:22.718]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.718]                   0L) {
[09:28:22.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.718]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.718]                   base::options(opts)
[09:28:22.718]                 }
[09:28:22.718]                 {
[09:28:22.718]                   {
[09:28:22.718]                     NULL
[09:28:22.718]                     RNGkind("Mersenne-Twister")
[09:28:22.718]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.718]                       inherits = FALSE)
[09:28:22.718]                   }
[09:28:22.718]                   options(future.plan = NULL)
[09:28:22.718]                   if (is.na(NA_character_)) 
[09:28:22.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.718]                     .init = FALSE)
[09:28:22.718]                 }
[09:28:22.718]             }
[09:28:22.718]         }
[09:28:22.718]     })
[09:28:22.718]     if (TRUE) {
[09:28:22.718]         base::sink(type = "output", split = FALSE)
[09:28:22.718]         if (TRUE) {
[09:28:22.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.718]         }
[09:28:22.718]         else {
[09:28:22.718]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.718]         }
[09:28:22.718]         base::close(...future.stdout)
[09:28:22.718]         ...future.stdout <- NULL
[09:28:22.718]     }
[09:28:22.718]     ...future.result$conditions <- ...future.conditions
[09:28:22.718]     ...future.result$finished <- base::Sys.time()
[09:28:22.718]     ...future.result
[09:28:22.718] }
[09:28:22.719] assign_globals() ...
[09:28:22.719] List of 5
[09:28:22.719]  $ ...future.FUN            :function (object, ...)  
[09:28:22.719]  $ future.call.arguments    : list()
[09:28:22.719]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.719]  $ ...future.elements_ii    :List of 3
[09:28:22.719]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.719]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.719]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.719]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.719]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.719]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.719]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.719]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.719]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.719]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.719]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.719]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.719]  $ ...future.seeds_ii       : NULL
[09:28:22.719]  $ ...future.globals.maxSize: NULL
[09:28:22.719]  - attr(*, "where")=List of 5
[09:28:22.719]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.719]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.719]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.719]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.719]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.719]  - attr(*, "resolved")= logi FALSE
[09:28:22.719]  - attr(*, "total_size")= num 1240
[09:28:22.719]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.719]  - attr(*, "already-done")= logi TRUE
[09:28:22.728] - copied ‘...future.FUN’ to environment
[09:28:22.728] - copied ‘future.call.arguments’ to environment
[09:28:22.728] - copied ‘...future.elements_ii’ to environment
[09:28:22.729] - copied ‘...future.seeds_ii’ to environment
[09:28:22.729] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.729] assign_globals() ... done
[09:28:22.729] plan(): Setting new future strategy stack:
[09:28:22.729] List of future strategies:
[09:28:22.729] 1. sequential:
[09:28:22.729]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.729]    - tweaked: FALSE
[09:28:22.729]    - call: NULL
[09:28:22.729] plan(): nbrOfWorkers() = 1
[09:28:22.732] plan(): Setting new future strategy stack:
[09:28:22.732] List of future strategies:
[09:28:22.732] 1. multisession:
[09:28:22.732]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:22.732]    - tweaked: FALSE
[09:28:22.732]    - call: plan(strategy)
[09:28:22.735] plan(): nbrOfWorkers() = 1
[09:28:22.735] SequentialFuture started (and completed)
[09:28:22.735] - Launch lazy future ... done
[09:28:22.735] run() for ‘SequentialFuture’ ... done
[09:28:22.735] Created future:
[09:28:22.735] SequentialFuture:
[09:28:22.735] Label: ‘future_by-1’
[09:28:22.735] Expression:
[09:28:22.735] {
[09:28:22.735]     do.call(function(...) {
[09:28:22.735]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.735]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.735]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.735]             on.exit(options(oopts), add = TRUE)
[09:28:22.735]         }
[09:28:22.735]         {
[09:28:22.735]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.735]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.735]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.735]             })
[09:28:22.735]         }
[09:28:22.735]     }, args = future.call.arguments)
[09:28:22.735] }
[09:28:22.735] Lazy evaluation: FALSE
[09:28:22.735] Asynchronous evaluation: FALSE
[09:28:22.735] Local evaluation: TRUE
[09:28:22.735] Environment: 0x555b0a38c6b8
[09:28:22.735] Capture standard output: TRUE
[09:28:22.735] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.735] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.735] Packages: <none>
[09:28:22.735] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.735] Resolved: TRUE
[09:28:22.735] Value: 5.37 KiB of class ‘list’
[09:28:22.735] Early signaling: FALSE
[09:28:22.735] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.735] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.737] Chunk #1 of 1 ... DONE
[09:28:22.737] Launching 1 futures (chunks) ... DONE
[09:28:22.737] Resolving 1 futures (chunks) ...
[09:28:22.737] resolve() on list ...
[09:28:22.737]  recursive: 0
[09:28:22.737]  length: 1
[09:28:22.737] 
[09:28:22.737] resolved() for ‘SequentialFuture’ ...
[09:28:22.737] - state: ‘finished’
[09:28:22.737] - run: TRUE
[09:28:22.738] - result: ‘FutureResult’
[09:28:22.738] resolved() for ‘SequentialFuture’ ... done
[09:28:22.738] Future #1
[09:28:22.738] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.738] - nx: 1
[09:28:22.738] - relay: TRUE
[09:28:22.738] - stdout: TRUE
[09:28:22.738] - signal: TRUE
[09:28:22.738] - resignal: FALSE
[09:28:22.738] - force: TRUE
[09:28:22.738] - relayed: [n=1] FALSE
[09:28:22.738] - queued futures: [n=1] FALSE
[09:28:22.739]  - until=1
[09:28:22.739]  - relaying element #1
[09:28:22.739] - relayed: [n=1] TRUE
[09:28:22.739] - queued futures: [n=1] TRUE
[09:28:22.739] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.739]  length: 0 (resolved future 1)
[09:28:22.739] Relaying remaining futures
[09:28:22.739] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.739] - nx: 1
[09:28:22.739] - relay: TRUE
[09:28:22.739] - stdout: TRUE
[09:28:22.740] - signal: TRUE
[09:28:22.740] - resignal: FALSE
[09:28:22.740] - force: TRUE
[09:28:22.740] - relayed: [n=1] TRUE
[09:28:22.740] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.740] - relayed: [n=1] TRUE
[09:28:22.740] - queued futures: [n=1] TRUE
[09:28:22.740] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.740] resolve() on list ... DONE
[09:28:22.740]  - Number of value chunks collected: 1
[09:28:22.740] Resolving 1 futures (chunks) ... DONE
[09:28:22.741] Reducing values from 1 chunks ...
[09:28:22.741]  - Number of values collected after concatenation: 3
[09:28:22.741]  - Number of values expected: 3
[09:28:22.741] Reducing values from 1 chunks ... DONE
[09:28:22.741] future_lapply() ... DONE
[09:28:22.741] future_by_internal() ... DONE
[09:28:22.742] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[09:28:22.742] future_lapply() ...
[09:28:22.745] Number of chunks: 1
[09:28:22.746] getGlobalsAndPackagesXApply() ...
[09:28:22.746]  - future.globals: TRUE
[09:28:22.746] getGlobalsAndPackages() ...
[09:28:22.746] Searching for globals...
[09:28:22.747] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.747] Searching for globals ... DONE
[09:28:22.747] Resolving globals: FALSE
[09:28:22.747] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.748] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.748] - globals: [1] ‘FUN’
[09:28:22.748] 
[09:28:22.748] getGlobalsAndPackages() ... DONE
[09:28:22.748]  - globals found/used: [n=1] ‘FUN’
[09:28:22.748]  - needed namespaces: [n=0] 
[09:28:22.748] Finding globals ... DONE
[09:28:22.748]  - use_args: TRUE
[09:28:22.748]  - Getting '...' globals ...
[09:28:22.749] resolve() on list ...
[09:28:22.749]  recursive: 0
[09:28:22.749]  length: 1
[09:28:22.749]  elements: ‘...’
[09:28:22.749]  length: 0 (resolved future 1)
[09:28:22.749] resolve() on list ... DONE
[09:28:22.749]    - '...' content: [n=0] 
[09:28:22.749] List of 1
[09:28:22.749]  $ ...: list()
[09:28:22.749]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.749]  - attr(*, "where")=List of 1
[09:28:22.749]   ..$ ...:<environment: 0x555b0a421de0> 
[09:28:22.749]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.749]  - attr(*, "resolved")= logi TRUE
[09:28:22.749]  - attr(*, "total_size")= num NA
[09:28:22.753]  - Getting '...' globals ... DONE
[09:28:22.753] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.753] List of 2
[09:28:22.753]  $ ...future.FUN:function (object, ...)  
[09:28:22.753]  $ ...          : list()
[09:28:22.753]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.753]  - attr(*, "where")=List of 2
[09:28:22.753]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.753]   ..$ ...          :<environment: 0x555b0a421de0> 
[09:28:22.753]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.753]  - attr(*, "resolved")= logi FALSE
[09:28:22.753]  - attr(*, "total_size")= num 1240
[09:28:22.755] Packages to be attached in all futures: [n=0] 
[09:28:22.756] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.756] Number of futures (= number of chunks): 1
[09:28:22.756] Launching 1 futures (chunks) ...
[09:28:22.756] Chunk #1 of 1 ...
[09:28:22.756]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.756] getGlobalsAndPackages() ...
[09:28:22.756] Searching for globals...
[09:28:22.757] 
[09:28:22.757] Searching for globals ... DONE
[09:28:22.757] - globals: [0] <none>
[09:28:22.757] getGlobalsAndPackages() ... DONE
[09:28:22.757]    + additional globals found: [n=0] 
[09:28:22.757]    + additional namespaces needed: [n=0] 
[09:28:22.757]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.757]  - seeds: <none>
[09:28:22.757]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.757] getGlobalsAndPackages() ...
[09:28:22.758] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.758] Resolving globals: FALSE
[09:28:22.758] Tweak future expression to call with '...' arguments ...
[09:28:22.758] {
[09:28:22.758]     do.call(function(...) {
[09:28:22.758]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.758]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.758]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.758]             on.exit(options(oopts), add = TRUE)
[09:28:22.758]         }
[09:28:22.758]         {
[09:28:22.758]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.758]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.758]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.758]             })
[09:28:22.758]         }
[09:28:22.758]     }, args = future.call.arguments)
[09:28:22.758] }
[09:28:22.758] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.758] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.759] 
[09:28:22.759] getGlobalsAndPackages() ... DONE
[09:28:22.759] run() for ‘Future’ ...
[09:28:22.759] - state: ‘created’
[09:28:22.759] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:22.762] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.762] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.762]   - Field: ‘label’
[09:28:22.763]   - Field: ‘local’
[09:28:22.763]   - Field: ‘owner’
[09:28:22.763]   - Field: ‘envir’
[09:28:22.763]   - Field: ‘packages’
[09:28:22.763]   - Field: ‘gc’
[09:28:22.763]   - Field: ‘conditions’
[09:28:22.763]   - Field: ‘expr’
[09:28:22.763]   - Field: ‘uuid’
[09:28:22.763]   - Field: ‘seed’
[09:28:22.763]   - Field: ‘version’
[09:28:22.763]   - Field: ‘result’
[09:28:22.764]   - Field: ‘asynchronous’
[09:28:22.764]   - Field: ‘calls’
[09:28:22.764]   - Field: ‘globals’
[09:28:22.764]   - Field: ‘stdout’
[09:28:22.764]   - Field: ‘earlySignal’
[09:28:22.764]   - Field: ‘lazy’
[09:28:22.764]   - Field: ‘state’
[09:28:22.764] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.764] - Launch lazy future ...
[09:28:22.764] Packages needed by the future expression (n = 0): <none>
[09:28:22.765] Packages needed by future strategies (n = 0): <none>
[09:28:22.765] {
[09:28:22.765]     {
[09:28:22.765]         {
[09:28:22.765]             ...future.startTime <- base::Sys.time()
[09:28:22.765]             {
[09:28:22.765]                 {
[09:28:22.765]                   {
[09:28:22.765]                     base::local({
[09:28:22.765]                       has_future <- base::requireNamespace("future", 
[09:28:22.765]                         quietly = TRUE)
[09:28:22.765]                       if (has_future) {
[09:28:22.765]                         ns <- base::getNamespace("future")
[09:28:22.765]                         version <- ns[[".package"]][["version"]]
[09:28:22.765]                         if (is.null(version)) 
[09:28:22.765]                           version <- utils::packageVersion("future")
[09:28:22.765]                       }
[09:28:22.765]                       else {
[09:28:22.765]                         version <- NULL
[09:28:22.765]                       }
[09:28:22.765]                       if (!has_future || version < "1.8.0") {
[09:28:22.765]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.765]                           "", base::R.version$version.string), 
[09:28:22.765]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.765]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.765]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.765]                             "release", "version")], collapse = " "), 
[09:28:22.765]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.765]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.765]                           info)
[09:28:22.765]                         info <- base::paste(info, collapse = "; ")
[09:28:22.765]                         if (!has_future) {
[09:28:22.765]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.765]                             info)
[09:28:22.765]                         }
[09:28:22.765]                         else {
[09:28:22.765]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.765]                             info, version)
[09:28:22.765]                         }
[09:28:22.765]                         base::stop(msg)
[09:28:22.765]                       }
[09:28:22.765]                     })
[09:28:22.765]                   }
[09:28:22.765]                   ...future.strategy.old <- future::plan("list")
[09:28:22.765]                   options(future.plan = NULL)
[09:28:22.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.765]                 }
[09:28:22.765]                 ...future.workdir <- getwd()
[09:28:22.765]             }
[09:28:22.765]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.765]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.765]         }
[09:28:22.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.765]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.765]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.765]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.765]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.765]             base::names(...future.oldOptions))
[09:28:22.765]     }
[09:28:22.765]     if (FALSE) {
[09:28:22.765]     }
[09:28:22.765]     else {
[09:28:22.765]         if (TRUE) {
[09:28:22.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.765]                 open = "w")
[09:28:22.765]         }
[09:28:22.765]         else {
[09:28:22.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.765]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.765]         }
[09:28:22.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.765]             base::sink(type = "output", split = FALSE)
[09:28:22.765]             base::close(...future.stdout)
[09:28:22.765]         }, add = TRUE)
[09:28:22.765]     }
[09:28:22.765]     ...future.frame <- base::sys.nframe()
[09:28:22.765]     ...future.conditions <- base::list()
[09:28:22.765]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.765]     if (FALSE) {
[09:28:22.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.765]     }
[09:28:22.765]     ...future.result <- base::tryCatch({
[09:28:22.765]         base::withCallingHandlers({
[09:28:22.765]             ...future.value <- base::withVisible(base::local({
[09:28:22.765]                 do.call(function(...) {
[09:28:22.765]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.765]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.765]                     ...future.globals.maxSize)) {
[09:28:22.765]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.765]                     on.exit(options(oopts), add = TRUE)
[09:28:22.765]                   }
[09:28:22.765]                   {
[09:28:22.765]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.765]                       FUN = function(jj) {
[09:28:22.765]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.765]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.765]                       })
[09:28:22.765]                   }
[09:28:22.765]                 }, args = future.call.arguments)
[09:28:22.765]             }))
[09:28:22.765]             future::FutureResult(value = ...future.value$value, 
[09:28:22.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.765]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.765]                     ...future.globalenv.names))
[09:28:22.765]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.765]         }, condition = base::local({
[09:28:22.765]             c <- base::c
[09:28:22.765]             inherits <- base::inherits
[09:28:22.765]             invokeRestart <- base::invokeRestart
[09:28:22.765]             length <- base::length
[09:28:22.765]             list <- base::list
[09:28:22.765]             seq.int <- base::seq.int
[09:28:22.765]             signalCondition <- base::signalCondition
[09:28:22.765]             sys.calls <- base::sys.calls
[09:28:22.765]             `[[` <- base::`[[`
[09:28:22.765]             `+` <- base::`+`
[09:28:22.765]             `<<-` <- base::`<<-`
[09:28:22.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.765]                   3L)]
[09:28:22.765]             }
[09:28:22.765]             function(cond) {
[09:28:22.765]                 is_error <- inherits(cond, "error")
[09:28:22.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.765]                   NULL)
[09:28:22.765]                 if (is_error) {
[09:28:22.765]                   sessionInformation <- function() {
[09:28:22.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.765]                       search = base::search(), system = base::Sys.info())
[09:28:22.765]                   }
[09:28:22.765]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.765]                     cond$call), session = sessionInformation(), 
[09:28:22.765]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.765]                   signalCondition(cond)
[09:28:22.765]                 }
[09:28:22.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.765]                 "immediateCondition"))) {
[09:28:22.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.765]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.765]                   if (TRUE && !signal) {
[09:28:22.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.765]                     {
[09:28:22.765]                       inherits <- base::inherits
[09:28:22.765]                       invokeRestart <- base::invokeRestart
[09:28:22.765]                       is.null <- base::is.null
[09:28:22.765]                       muffled <- FALSE
[09:28:22.765]                       if (inherits(cond, "message")) {
[09:28:22.765]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.765]                         if (muffled) 
[09:28:22.765]                           invokeRestart("muffleMessage")
[09:28:22.765]                       }
[09:28:22.765]                       else if (inherits(cond, "warning")) {
[09:28:22.765]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.765]                         if (muffled) 
[09:28:22.765]                           invokeRestart("muffleWarning")
[09:28:22.765]                       }
[09:28:22.765]                       else if (inherits(cond, "condition")) {
[09:28:22.765]                         if (!is.null(pattern)) {
[09:28:22.765]                           computeRestarts <- base::computeRestarts
[09:28:22.765]                           grepl <- base::grepl
[09:28:22.765]                           restarts <- computeRestarts(cond)
[09:28:22.765]                           for (restart in restarts) {
[09:28:22.765]                             name <- restart$name
[09:28:22.765]                             if (is.null(name)) 
[09:28:22.765]                               next
[09:28:22.765]                             if (!grepl(pattern, name)) 
[09:28:22.765]                               next
[09:28:22.765]                             invokeRestart(restart)
[09:28:22.765]                             muffled <- TRUE
[09:28:22.765]                             break
[09:28:22.765]                           }
[09:28:22.765]                         }
[09:28:22.765]                       }
[09:28:22.765]                       invisible(muffled)
[09:28:22.765]                     }
[09:28:22.765]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.765]                   }
[09:28:22.765]                 }
[09:28:22.765]                 else {
[09:28:22.765]                   if (TRUE) {
[09:28:22.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.765]                     {
[09:28:22.765]                       inherits <- base::inherits
[09:28:22.765]                       invokeRestart <- base::invokeRestart
[09:28:22.765]                       is.null <- base::is.null
[09:28:22.765]                       muffled <- FALSE
[09:28:22.765]                       if (inherits(cond, "message")) {
[09:28:22.765]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.765]                         if (muffled) 
[09:28:22.765]                           invokeRestart("muffleMessage")
[09:28:22.765]                       }
[09:28:22.765]                       else if (inherits(cond, "warning")) {
[09:28:22.765]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.765]                         if (muffled) 
[09:28:22.765]                           invokeRestart("muffleWarning")
[09:28:22.765]                       }
[09:28:22.765]                       else if (inherits(cond, "condition")) {
[09:28:22.765]                         if (!is.null(pattern)) {
[09:28:22.765]                           computeRestarts <- base::computeRestarts
[09:28:22.765]                           grepl <- base::grepl
[09:28:22.765]                           restarts <- computeRestarts(cond)
[09:28:22.765]                           for (restart in restarts) {
[09:28:22.765]                             name <- restart$name
[09:28:22.765]                             if (is.null(name)) 
[09:28:22.765]                               next
[09:28:22.765]                             if (!grepl(pattern, name)) 
[09:28:22.765]                               next
[09:28:22.765]                             invokeRestart(restart)
[09:28:22.765]                             muffled <- TRUE
[09:28:22.765]                             break
[09:28:22.765]                           }
[09:28:22.765]                         }
[09:28:22.765]                       }
[09:28:22.765]                       invisible(muffled)
[09:28:22.765]                     }
[09:28:22.765]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.765]                   }
[09:28:22.765]                 }
[09:28:22.765]             }
[09:28:22.765]         }))
[09:28:22.765]     }, error = function(ex) {
[09:28:22.765]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.765]                 ...future.rng), started = ...future.startTime, 
[09:28:22.765]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.765]             version = "1.8"), class = "FutureResult")
[09:28:22.765]     }, finally = {
[09:28:22.765]         if (!identical(...future.workdir, getwd())) 
[09:28:22.765]             setwd(...future.workdir)
[09:28:22.765]         {
[09:28:22.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.765]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.765]             }
[09:28:22.765]             base::options(...future.oldOptions)
[09:28:22.765]             if (.Platform$OS.type == "windows") {
[09:28:22.765]                 old_names <- names(...future.oldEnvVars)
[09:28:22.765]                 envs <- base::Sys.getenv()
[09:28:22.765]                 names <- names(envs)
[09:28:22.765]                 common <- intersect(names, old_names)
[09:28:22.765]                 added <- setdiff(names, old_names)
[09:28:22.765]                 removed <- setdiff(old_names, names)
[09:28:22.765]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.765]                   envs[common]]
[09:28:22.765]                 NAMES <- toupper(changed)
[09:28:22.765]                 args <- list()
[09:28:22.765]                 for (kk in seq_along(NAMES)) {
[09:28:22.765]                   name <- changed[[kk]]
[09:28:22.765]                   NAME <- NAMES[[kk]]
[09:28:22.765]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.765]                     next
[09:28:22.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.765]                 }
[09:28:22.765]                 NAMES <- toupper(added)
[09:28:22.765]                 for (kk in seq_along(NAMES)) {
[09:28:22.765]                   name <- added[[kk]]
[09:28:22.765]                   NAME <- NAMES[[kk]]
[09:28:22.765]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.765]                     next
[09:28:22.765]                   args[[name]] <- ""
[09:28:22.765]                 }
[09:28:22.765]                 NAMES <- toupper(removed)
[09:28:22.765]                 for (kk in seq_along(NAMES)) {
[09:28:22.765]                   name <- removed[[kk]]
[09:28:22.765]                   NAME <- NAMES[[kk]]
[09:28:22.765]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.765]                     next
[09:28:22.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.765]                 }
[09:28:22.765]                 if (length(args) > 0) 
[09:28:22.765]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.765]             }
[09:28:22.765]             else {
[09:28:22.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.765]             }
[09:28:22.765]             {
[09:28:22.765]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.765]                   0L) {
[09:28:22.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.765]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.765]                   base::options(opts)
[09:28:22.765]                 }
[09:28:22.765]                 {
[09:28:22.765]                   {
[09:28:22.765]                     NULL
[09:28:22.765]                     RNGkind("Mersenne-Twister")
[09:28:22.765]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.765]                       inherits = FALSE)
[09:28:22.765]                   }
[09:28:22.765]                   options(future.plan = NULL)
[09:28:22.765]                   if (is.na(NA_character_)) 
[09:28:22.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.765]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.765]                     .init = FALSE)
[09:28:22.765]                 }
[09:28:22.765]             }
[09:28:22.765]         }
[09:28:22.765]     })
[09:28:22.765]     if (TRUE) {
[09:28:22.765]         base::sink(type = "output", split = FALSE)
[09:28:22.765]         if (TRUE) {
[09:28:22.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.765]         }
[09:28:22.765]         else {
[09:28:22.765]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.765]         }
[09:28:22.765]         base::close(...future.stdout)
[09:28:22.765]         ...future.stdout <- NULL
[09:28:22.765]     }
[09:28:22.765]     ...future.result$conditions <- ...future.conditions
[09:28:22.765]     ...future.result$finished <- base::Sys.time()
[09:28:22.765]     ...future.result
[09:28:22.765] }
[09:28:22.767] assign_globals() ...
[09:28:22.767] List of 5
[09:28:22.767]  $ ...future.FUN            :function (object, ...)  
[09:28:22.767]  $ future.call.arguments    : list()
[09:28:22.767]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.767]  $ ...future.elements_ii    :List of 3
[09:28:22.767]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.767]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.767]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.767]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.767]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.767]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.767]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.767]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.767]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.767]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.767]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.767]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.767]  $ ...future.seeds_ii       : NULL
[09:28:22.767]  $ ...future.globals.maxSize: NULL
[09:28:22.767]  - attr(*, "where")=List of 5
[09:28:22.767]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.767]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.767]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.767]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.767]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.767]  - attr(*, "resolved")= logi FALSE
[09:28:22.767]  - attr(*, "total_size")= num 1240
[09:28:22.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.767]  - attr(*, "already-done")= logi TRUE
[09:28:22.776] - copied ‘...future.FUN’ to environment
[09:28:22.776] - copied ‘future.call.arguments’ to environment
[09:28:22.776] - copied ‘...future.elements_ii’ to environment
[09:28:22.776] - copied ‘...future.seeds_ii’ to environment
[09:28:22.776] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.776] assign_globals() ... done
[09:28:22.776] plan(): Setting new future strategy stack:
[09:28:22.776] List of future strategies:
[09:28:22.776] 1. sequential:
[09:28:22.776]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.776]    - tweaked: FALSE
[09:28:22.776]    - call: NULL
[09:28:22.777] plan(): nbrOfWorkers() = 1
[09:28:22.779] plan(): Setting new future strategy stack:
[09:28:22.779] List of future strategies:
[09:28:22.779] 1. multisession:
[09:28:22.779]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:22.779]    - tweaked: FALSE
[09:28:22.779]    - call: plan(strategy)
[09:28:22.782] plan(): nbrOfWorkers() = 1
[09:28:22.782] SequentialFuture started (and completed)
[09:28:22.782] - Launch lazy future ... done
[09:28:22.783] run() for ‘SequentialFuture’ ... done
[09:28:22.783] Created future:
[09:28:22.783] SequentialFuture:
[09:28:22.783] Label: ‘future_by-1’
[09:28:22.783] Expression:
[09:28:22.783] {
[09:28:22.783]     do.call(function(...) {
[09:28:22.783]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.783]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.783]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.783]             on.exit(options(oopts), add = TRUE)
[09:28:22.783]         }
[09:28:22.783]         {
[09:28:22.783]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.783]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.783]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.783]             })
[09:28:22.783]         }
[09:28:22.783]     }, args = future.call.arguments)
[09:28:22.783] }
[09:28:22.783] Lazy evaluation: FALSE
[09:28:22.783] Asynchronous evaluation: FALSE
[09:28:22.783] Local evaluation: TRUE
[09:28:22.783] Environment: 0x555b0a3cfb28
[09:28:22.783] Capture standard output: TRUE
[09:28:22.783] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.783] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.783] Packages: <none>
[09:28:22.783] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.783] Resolved: TRUE
[09:28:22.783] Value: 5.37 KiB of class ‘list’
[09:28:22.783] Early signaling: FALSE
[09:28:22.783] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.783] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.784] Chunk #1 of 1 ... DONE
[09:28:22.784] Launching 1 futures (chunks) ... DONE
[09:28:22.784] Resolving 1 futures (chunks) ...
[09:28:22.784] resolve() on list ...
[09:28:22.784]  recursive: 0
[09:28:22.784]  length: 1
[09:28:22.784] 
[09:28:22.785] resolved() for ‘SequentialFuture’ ...
[09:28:22.785] - state: ‘finished’
[09:28:22.785] - run: TRUE
[09:28:22.785] - result: ‘FutureResult’
[09:28:22.785] resolved() for ‘SequentialFuture’ ... done
[09:28:22.785] Future #1
[09:28:22.785] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.785] - nx: 1
[09:28:22.785] - relay: TRUE
[09:28:22.785] - stdout: TRUE
[09:28:22.785] - signal: TRUE
[09:28:22.786] - resignal: FALSE
[09:28:22.786] - force: TRUE
[09:28:22.786] - relayed: [n=1] FALSE
[09:28:22.786] - queued futures: [n=1] FALSE
[09:28:22.786]  - until=1
[09:28:22.786]  - relaying element #1
[09:28:22.786] - relayed: [n=1] TRUE
[09:28:22.786] - queued futures: [n=1] TRUE
[09:28:22.786] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.786]  length: 0 (resolved future 1)
[09:28:22.786] Relaying remaining futures
[09:28:22.787] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.787] - nx: 1
[09:28:22.787] - relay: TRUE
[09:28:22.787] - stdout: TRUE
[09:28:22.787] - signal: TRUE
[09:28:22.787] - resignal: FALSE
[09:28:22.787] - force: TRUE
[09:28:22.787] - relayed: [n=1] TRUE
[09:28:22.787] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.787] - relayed: [n=1] TRUE
[09:28:22.787] - queued futures: [n=1] TRUE
[09:28:22.787] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.788] resolve() on list ... DONE
[09:28:22.788]  - Number of value chunks collected: 1
[09:28:22.788] Resolving 1 futures (chunks) ... DONE
[09:28:22.788] Reducing values from 1 chunks ...
[09:28:22.788]  - Number of values collected after concatenation: 3
[09:28:22.788]  - Number of values expected: 3
[09:28:22.788] Reducing values from 1 chunks ... DONE
[09:28:22.788] future_lapply() ... DONE
[09:28:22.788] future_by_internal() ... DONE
[09:28:22.789] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[09:28:22.790] plan(): Setting new future strategy stack:
[09:28:22.790] List of future strategies:
[09:28:22.790] 1. sequential:
[09:28:22.790]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.790]    - tweaked: FALSE
[09:28:22.790]    - call: plan(strategy)
[09:28:22.790] plan(): nbrOfWorkers() = 1
[09:28:22.790] future_by_internal() ...
[09:28:22.791] future_lapply() ...
[09:28:22.791] Number of chunks: 1
[09:28:22.791] getGlobalsAndPackagesXApply() ...
[09:28:22.791]  - future.globals: TRUE
[09:28:22.791] getGlobalsAndPackages() ...
[09:28:22.791] Searching for globals...
[09:28:22.792] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.793] Searching for globals ... DONE
[09:28:22.793] Resolving globals: FALSE
[09:28:22.793] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.793] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.793] - globals: [1] ‘FUN’
[09:28:22.793] 
[09:28:22.794] getGlobalsAndPackages() ... DONE
[09:28:22.794]  - globals found/used: [n=1] ‘FUN’
[09:28:22.794]  - needed namespaces: [n=0] 
[09:28:22.794] Finding globals ... DONE
[09:28:22.794]  - use_args: TRUE
[09:28:22.794]  - Getting '...' globals ...
[09:28:22.794] resolve() on list ...
[09:28:22.794]  recursive: 0
[09:28:22.794]  length: 1
[09:28:22.794]  elements: ‘...’
[09:28:22.795]  length: 0 (resolved future 1)
[09:28:22.796] resolve() on list ... DONE
[09:28:22.796]    - '...' content: [n=0] 
[09:28:22.796] List of 1
[09:28:22.796]  $ ...: list()
[09:28:22.796]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.796]  - attr(*, "where")=List of 1
[09:28:22.796]   ..$ ...:<environment: 0x555b0a5de650> 
[09:28:22.796]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.796]  - attr(*, "resolved")= logi TRUE
[09:28:22.796]  - attr(*, "total_size")= num NA
[09:28:22.798]  - Getting '...' globals ... DONE
[09:28:22.799] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.799] List of 2
[09:28:22.799]  $ ...future.FUN:function (object, ...)  
[09:28:22.799]  $ ...          : list()
[09:28:22.799]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.799]  - attr(*, "where")=List of 2
[09:28:22.799]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.799]   ..$ ...          :<environment: 0x555b0a5de650> 
[09:28:22.799]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.799]  - attr(*, "resolved")= logi FALSE
[09:28:22.799]  - attr(*, "total_size")= num 1240
[09:28:22.801] Packages to be attached in all futures: [n=0] 
[09:28:22.801] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.801] Number of futures (= number of chunks): 1
[09:28:22.801] Launching 1 futures (chunks) ...
[09:28:22.802] Chunk #1 of 1 ...
[09:28:22.802]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.802] getGlobalsAndPackages() ...
[09:28:22.802] Searching for globals...
[09:28:22.802] 
[09:28:22.802] Searching for globals ... DONE
[09:28:22.802] - globals: [0] <none>
[09:28:22.803] getGlobalsAndPackages() ... DONE
[09:28:22.803]    + additional globals found: [n=0] 
[09:28:22.803]    + additional namespaces needed: [n=0] 
[09:28:22.803]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.803]  - seeds: <none>
[09:28:22.803]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.803] getGlobalsAndPackages() ...
[09:28:22.803] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.803] Resolving globals: FALSE
[09:28:22.803] Tweak future expression to call with '...' arguments ...
[09:28:22.803] {
[09:28:22.803]     do.call(function(...) {
[09:28:22.803]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.803]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.803]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.803]             on.exit(options(oopts), add = TRUE)
[09:28:22.803]         }
[09:28:22.803]         {
[09:28:22.803]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.803]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.803]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.803]             })
[09:28:22.803]         }
[09:28:22.803]     }, args = future.call.arguments)
[09:28:22.803] }
[09:28:22.804] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.804] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.804] 
[09:28:22.804] getGlobalsAndPackages() ... DONE
[09:28:22.804] run() for ‘Future’ ...
[09:28:22.805] - state: ‘created’
[09:28:22.805] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:22.805] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.805] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.805]   - Field: ‘label’
[09:28:22.805]   - Field: ‘local’
[09:28:22.805]   - Field: ‘owner’
[09:28:22.805]   - Field: ‘envir’
[09:28:22.805]   - Field: ‘packages’
[09:28:22.806]   - Field: ‘gc’
[09:28:22.806]   - Field: ‘conditions’
[09:28:22.806]   - Field: ‘expr’
[09:28:22.806]   - Field: ‘uuid’
[09:28:22.806]   - Field: ‘seed’
[09:28:22.806]   - Field: ‘version’
[09:28:22.806]   - Field: ‘result’
[09:28:22.806]   - Field: ‘asynchronous’
[09:28:22.806]   - Field: ‘calls’
[09:28:22.806]   - Field: ‘globals’
[09:28:22.806]   - Field: ‘stdout’
[09:28:22.806]   - Field: ‘earlySignal’
[09:28:22.807]   - Field: ‘lazy’
[09:28:22.807]   - Field: ‘state’
[09:28:22.807] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.807] - Launch lazy future ...
[09:28:22.807] Packages needed by the future expression (n = 0): <none>
[09:28:22.807] Packages needed by future strategies (n = 0): <none>
[09:28:22.807] {
[09:28:22.807]     {
[09:28:22.807]         {
[09:28:22.807]             ...future.startTime <- base::Sys.time()
[09:28:22.807]             {
[09:28:22.807]                 {
[09:28:22.807]                   {
[09:28:22.807]                     base::local({
[09:28:22.807]                       has_future <- base::requireNamespace("future", 
[09:28:22.807]                         quietly = TRUE)
[09:28:22.807]                       if (has_future) {
[09:28:22.807]                         ns <- base::getNamespace("future")
[09:28:22.807]                         version <- ns[[".package"]][["version"]]
[09:28:22.807]                         if (is.null(version)) 
[09:28:22.807]                           version <- utils::packageVersion("future")
[09:28:22.807]                       }
[09:28:22.807]                       else {
[09:28:22.807]                         version <- NULL
[09:28:22.807]                       }
[09:28:22.807]                       if (!has_future || version < "1.8.0") {
[09:28:22.807]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.807]                           "", base::R.version$version.string), 
[09:28:22.807]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.807]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.807]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.807]                             "release", "version")], collapse = " "), 
[09:28:22.807]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.807]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.807]                           info)
[09:28:22.807]                         info <- base::paste(info, collapse = "; ")
[09:28:22.807]                         if (!has_future) {
[09:28:22.807]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.807]                             info)
[09:28:22.807]                         }
[09:28:22.807]                         else {
[09:28:22.807]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.807]                             info, version)
[09:28:22.807]                         }
[09:28:22.807]                         base::stop(msg)
[09:28:22.807]                       }
[09:28:22.807]                     })
[09:28:22.807]                   }
[09:28:22.807]                   ...future.strategy.old <- future::plan("list")
[09:28:22.807]                   options(future.plan = NULL)
[09:28:22.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.807]                 }
[09:28:22.807]                 ...future.workdir <- getwd()
[09:28:22.807]             }
[09:28:22.807]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.807]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.807]         }
[09:28:22.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.807]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.807]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.807]             base::names(...future.oldOptions))
[09:28:22.807]     }
[09:28:22.807]     if (FALSE) {
[09:28:22.807]     }
[09:28:22.807]     else {
[09:28:22.807]         if (TRUE) {
[09:28:22.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.807]                 open = "w")
[09:28:22.807]         }
[09:28:22.807]         else {
[09:28:22.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.807]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.807]         }
[09:28:22.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.807]             base::sink(type = "output", split = FALSE)
[09:28:22.807]             base::close(...future.stdout)
[09:28:22.807]         }, add = TRUE)
[09:28:22.807]     }
[09:28:22.807]     ...future.frame <- base::sys.nframe()
[09:28:22.807]     ...future.conditions <- base::list()
[09:28:22.807]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.807]     if (FALSE) {
[09:28:22.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.807]     }
[09:28:22.807]     ...future.result <- base::tryCatch({
[09:28:22.807]         base::withCallingHandlers({
[09:28:22.807]             ...future.value <- base::withVisible(base::local({
[09:28:22.807]                 do.call(function(...) {
[09:28:22.807]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.807]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.807]                     ...future.globals.maxSize)) {
[09:28:22.807]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.807]                     on.exit(options(oopts), add = TRUE)
[09:28:22.807]                   }
[09:28:22.807]                   {
[09:28:22.807]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.807]                       FUN = function(jj) {
[09:28:22.807]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.807]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.807]                       })
[09:28:22.807]                   }
[09:28:22.807]                 }, args = future.call.arguments)
[09:28:22.807]             }))
[09:28:22.807]             future::FutureResult(value = ...future.value$value, 
[09:28:22.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.807]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.807]                     ...future.globalenv.names))
[09:28:22.807]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.807]         }, condition = base::local({
[09:28:22.807]             c <- base::c
[09:28:22.807]             inherits <- base::inherits
[09:28:22.807]             invokeRestart <- base::invokeRestart
[09:28:22.807]             length <- base::length
[09:28:22.807]             list <- base::list
[09:28:22.807]             seq.int <- base::seq.int
[09:28:22.807]             signalCondition <- base::signalCondition
[09:28:22.807]             sys.calls <- base::sys.calls
[09:28:22.807]             `[[` <- base::`[[`
[09:28:22.807]             `+` <- base::`+`
[09:28:22.807]             `<<-` <- base::`<<-`
[09:28:22.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.807]                   3L)]
[09:28:22.807]             }
[09:28:22.807]             function(cond) {
[09:28:22.807]                 is_error <- inherits(cond, "error")
[09:28:22.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.807]                   NULL)
[09:28:22.807]                 if (is_error) {
[09:28:22.807]                   sessionInformation <- function() {
[09:28:22.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.807]                       search = base::search(), system = base::Sys.info())
[09:28:22.807]                   }
[09:28:22.807]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.807]                     cond$call), session = sessionInformation(), 
[09:28:22.807]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.807]                   signalCondition(cond)
[09:28:22.807]                 }
[09:28:22.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.807]                 "immediateCondition"))) {
[09:28:22.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.807]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.807]                   if (TRUE && !signal) {
[09:28:22.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.807]                     {
[09:28:22.807]                       inherits <- base::inherits
[09:28:22.807]                       invokeRestart <- base::invokeRestart
[09:28:22.807]                       is.null <- base::is.null
[09:28:22.807]                       muffled <- FALSE
[09:28:22.807]                       if (inherits(cond, "message")) {
[09:28:22.807]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.807]                         if (muffled) 
[09:28:22.807]                           invokeRestart("muffleMessage")
[09:28:22.807]                       }
[09:28:22.807]                       else if (inherits(cond, "warning")) {
[09:28:22.807]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.807]                         if (muffled) 
[09:28:22.807]                           invokeRestart("muffleWarning")
[09:28:22.807]                       }
[09:28:22.807]                       else if (inherits(cond, "condition")) {
[09:28:22.807]                         if (!is.null(pattern)) {
[09:28:22.807]                           computeRestarts <- base::computeRestarts
[09:28:22.807]                           grepl <- base::grepl
[09:28:22.807]                           restarts <- computeRestarts(cond)
[09:28:22.807]                           for (restart in restarts) {
[09:28:22.807]                             name <- restart$name
[09:28:22.807]                             if (is.null(name)) 
[09:28:22.807]                               next
[09:28:22.807]                             if (!grepl(pattern, name)) 
[09:28:22.807]                               next
[09:28:22.807]                             invokeRestart(restart)
[09:28:22.807]                             muffled <- TRUE
[09:28:22.807]                             break
[09:28:22.807]                           }
[09:28:22.807]                         }
[09:28:22.807]                       }
[09:28:22.807]                       invisible(muffled)
[09:28:22.807]                     }
[09:28:22.807]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.807]                   }
[09:28:22.807]                 }
[09:28:22.807]                 else {
[09:28:22.807]                   if (TRUE) {
[09:28:22.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.807]                     {
[09:28:22.807]                       inherits <- base::inherits
[09:28:22.807]                       invokeRestart <- base::invokeRestart
[09:28:22.807]                       is.null <- base::is.null
[09:28:22.807]                       muffled <- FALSE
[09:28:22.807]                       if (inherits(cond, "message")) {
[09:28:22.807]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.807]                         if (muffled) 
[09:28:22.807]                           invokeRestart("muffleMessage")
[09:28:22.807]                       }
[09:28:22.807]                       else if (inherits(cond, "warning")) {
[09:28:22.807]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.807]                         if (muffled) 
[09:28:22.807]                           invokeRestart("muffleWarning")
[09:28:22.807]                       }
[09:28:22.807]                       else if (inherits(cond, "condition")) {
[09:28:22.807]                         if (!is.null(pattern)) {
[09:28:22.807]                           computeRestarts <- base::computeRestarts
[09:28:22.807]                           grepl <- base::grepl
[09:28:22.807]                           restarts <- computeRestarts(cond)
[09:28:22.807]                           for (restart in restarts) {
[09:28:22.807]                             name <- restart$name
[09:28:22.807]                             if (is.null(name)) 
[09:28:22.807]                               next
[09:28:22.807]                             if (!grepl(pattern, name)) 
[09:28:22.807]                               next
[09:28:22.807]                             invokeRestart(restart)
[09:28:22.807]                             muffled <- TRUE
[09:28:22.807]                             break
[09:28:22.807]                           }
[09:28:22.807]                         }
[09:28:22.807]                       }
[09:28:22.807]                       invisible(muffled)
[09:28:22.807]                     }
[09:28:22.807]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.807]                   }
[09:28:22.807]                 }
[09:28:22.807]             }
[09:28:22.807]         }))
[09:28:22.807]     }, error = function(ex) {
[09:28:22.807]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.807]                 ...future.rng), started = ...future.startTime, 
[09:28:22.807]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.807]             version = "1.8"), class = "FutureResult")
[09:28:22.807]     }, finally = {
[09:28:22.807]         if (!identical(...future.workdir, getwd())) 
[09:28:22.807]             setwd(...future.workdir)
[09:28:22.807]         {
[09:28:22.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.807]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.807]             }
[09:28:22.807]             base::options(...future.oldOptions)
[09:28:22.807]             if (.Platform$OS.type == "windows") {
[09:28:22.807]                 old_names <- names(...future.oldEnvVars)
[09:28:22.807]                 envs <- base::Sys.getenv()
[09:28:22.807]                 names <- names(envs)
[09:28:22.807]                 common <- intersect(names, old_names)
[09:28:22.807]                 added <- setdiff(names, old_names)
[09:28:22.807]                 removed <- setdiff(old_names, names)
[09:28:22.807]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.807]                   envs[common]]
[09:28:22.807]                 NAMES <- toupper(changed)
[09:28:22.807]                 args <- list()
[09:28:22.807]                 for (kk in seq_along(NAMES)) {
[09:28:22.807]                   name <- changed[[kk]]
[09:28:22.807]                   NAME <- NAMES[[kk]]
[09:28:22.807]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.807]                     next
[09:28:22.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.807]                 }
[09:28:22.807]                 NAMES <- toupper(added)
[09:28:22.807]                 for (kk in seq_along(NAMES)) {
[09:28:22.807]                   name <- added[[kk]]
[09:28:22.807]                   NAME <- NAMES[[kk]]
[09:28:22.807]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.807]                     next
[09:28:22.807]                   args[[name]] <- ""
[09:28:22.807]                 }
[09:28:22.807]                 NAMES <- toupper(removed)
[09:28:22.807]                 for (kk in seq_along(NAMES)) {
[09:28:22.807]                   name <- removed[[kk]]
[09:28:22.807]                   NAME <- NAMES[[kk]]
[09:28:22.807]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.807]                     next
[09:28:22.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.807]                 }
[09:28:22.807]                 if (length(args) > 0) 
[09:28:22.807]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.807]             }
[09:28:22.807]             else {
[09:28:22.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.807]             }
[09:28:22.807]             {
[09:28:22.807]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.807]                   0L) {
[09:28:22.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.807]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.807]                   base::options(opts)
[09:28:22.807]                 }
[09:28:22.807]                 {
[09:28:22.807]                   {
[09:28:22.807]                     NULL
[09:28:22.807]                     RNGkind("Mersenne-Twister")
[09:28:22.807]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.807]                       inherits = FALSE)
[09:28:22.807]                   }
[09:28:22.807]                   options(future.plan = NULL)
[09:28:22.807]                   if (is.na(NA_character_)) 
[09:28:22.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.807]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.807]                     .init = FALSE)
[09:28:22.807]                 }
[09:28:22.807]             }
[09:28:22.807]         }
[09:28:22.807]     })
[09:28:22.807]     if (TRUE) {
[09:28:22.807]         base::sink(type = "output", split = FALSE)
[09:28:22.807]         if (TRUE) {
[09:28:22.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.807]         }
[09:28:22.807]         else {
[09:28:22.807]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.807]         }
[09:28:22.807]         base::close(...future.stdout)
[09:28:22.807]         ...future.stdout <- NULL
[09:28:22.807]     }
[09:28:22.807]     ...future.result$conditions <- ...future.conditions
[09:28:22.807]     ...future.result$finished <- base::Sys.time()
[09:28:22.807]     ...future.result
[09:28:22.807] }
[09:28:22.809] assign_globals() ...
[09:28:22.809] List of 5
[09:28:22.809]  $ ...future.FUN            :function (object, ...)  
[09:28:22.809]  $ future.call.arguments    : list()
[09:28:22.809]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.809]  $ ...future.elements_ii    :List of 3
[09:28:22.809]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:22.809]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.809]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.809]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:22.809]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.809]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.809]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:22.809]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.809]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.809]  $ ...future.seeds_ii       : NULL
[09:28:22.809]  $ ...future.globals.maxSize: NULL
[09:28:22.809]  - attr(*, "where")=List of 5
[09:28:22.809]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.809]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.809]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.809]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.809]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.809]  - attr(*, "resolved")= logi FALSE
[09:28:22.809]  - attr(*, "total_size")= num 1240
[09:28:22.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.809]  - attr(*, "already-done")= logi TRUE
[09:28:22.818] - copied ‘...future.FUN’ to environment
[09:28:22.818] - copied ‘future.call.arguments’ to environment
[09:28:22.818] - copied ‘...future.elements_ii’ to environment
[09:28:22.818] - copied ‘...future.seeds_ii’ to environment
[09:28:22.818] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.818] assign_globals() ... done
[09:28:22.819] plan(): Setting new future strategy stack:
[09:28:22.819] List of future strategies:
[09:28:22.819] 1. sequential:
[09:28:22.819]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.819]    - tweaked: FALSE
[09:28:22.819]    - call: NULL
[09:28:22.819] plan(): nbrOfWorkers() = 1
[09:28:22.821] plan(): Setting new future strategy stack:
[09:28:22.821] List of future strategies:
[09:28:22.821] 1. sequential:
[09:28:22.821]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.821]    - tweaked: FALSE
[09:28:22.821]    - call: plan(strategy)
[09:28:22.821] plan(): nbrOfWorkers() = 1
[09:28:22.822] SequentialFuture started (and completed)
[09:28:22.822] - Launch lazy future ... done
[09:28:22.822] run() for ‘SequentialFuture’ ... done
[09:28:22.822] Created future:
[09:28:22.822] SequentialFuture:
[09:28:22.822] Label: ‘future_by-1’
[09:28:22.822] Expression:
[09:28:22.822] {
[09:28:22.822]     do.call(function(...) {
[09:28:22.822]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.822]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.822]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.822]             on.exit(options(oopts), add = TRUE)
[09:28:22.822]         }
[09:28:22.822]         {
[09:28:22.822]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.822]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.822]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.822]             })
[09:28:22.822]         }
[09:28:22.822]     }, args = future.call.arguments)
[09:28:22.822] }
[09:28:22.822] Lazy evaluation: FALSE
[09:28:22.822] Asynchronous evaluation: FALSE
[09:28:22.822] Local evaluation: TRUE
[09:28:22.822] Environment: R_GlobalEnv
[09:28:22.822] Capture standard output: TRUE
[09:28:22.822] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.822] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.822] Packages: <none>
[09:28:22.822] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.822] Resolved: TRUE
[09:28:22.822] Value: 4.62 KiB of class ‘list’
[09:28:22.822] Early signaling: FALSE
[09:28:22.822] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.822] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.823] Chunk #1 of 1 ... DONE
[09:28:22.823] Launching 1 futures (chunks) ... DONE
[09:28:22.823] Resolving 1 futures (chunks) ...
[09:28:22.823] resolve() on list ...
[09:28:22.823]  recursive: 0
[09:28:22.823]  length: 1
[09:28:22.824] 
[09:28:22.824] resolved() for ‘SequentialFuture’ ...
[09:28:22.824] - state: ‘finished’
[09:28:22.824] - run: TRUE
[09:28:22.824] - result: ‘FutureResult’
[09:28:22.824] resolved() for ‘SequentialFuture’ ... done
[09:28:22.824] Future #1
[09:28:22.824] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.824] - nx: 1
[09:28:22.824] - relay: TRUE
[09:28:22.825] - stdout: TRUE
[09:28:22.825] - signal: TRUE
[09:28:22.825] - resignal: FALSE
[09:28:22.825] - force: TRUE
[09:28:22.825] - relayed: [n=1] FALSE
[09:28:22.825] - queued futures: [n=1] FALSE
[09:28:22.825]  - until=1
[09:28:22.825]  - relaying element #1
[09:28:22.825] - relayed: [n=1] TRUE
[09:28:22.825] - queued futures: [n=1] TRUE
[09:28:22.825] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.826]  length: 0 (resolved future 1)
[09:28:22.826] Relaying remaining futures
[09:28:22.826] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.826] - nx: 1
[09:28:22.826] - relay: TRUE
[09:28:22.826] - stdout: TRUE
[09:28:22.826] - signal: TRUE
[09:28:22.826] - resignal: FALSE
[09:28:22.826] - force: TRUE
[09:28:22.826] - relayed: [n=1] TRUE
[09:28:22.826] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.826] - relayed: [n=1] TRUE
[09:28:22.826] - queued futures: [n=1] TRUE
[09:28:22.827] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.827] resolve() on list ... DONE
[09:28:22.827]  - Number of value chunks collected: 1
[09:28:22.827] Resolving 1 futures (chunks) ... DONE
[09:28:22.827] Reducing values from 1 chunks ...
[09:28:22.827]  - Number of values collected after concatenation: 3
[09:28:22.827]  - Number of values expected: 3
[09:28:22.827] Reducing values from 1 chunks ... DONE
[09:28:22.827] future_lapply() ... DONE
[09:28:22.827] future_by_internal() ... DONE
[09:28:22.828] future_by_internal() ...
[09:28:22.828] future_lapply() ...
[09:28:22.828] Number of chunks: 1
[09:28:22.828] getGlobalsAndPackagesXApply() ...
[09:28:22.828]  - future.globals: TRUE
[09:28:22.829] getGlobalsAndPackages() ...
[09:28:22.829] Searching for globals...
[09:28:22.830] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.830] Searching for globals ... DONE
[09:28:22.830] Resolving globals: FALSE
[09:28:22.830] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.830] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.830] - globals: [1] ‘FUN’
[09:28:22.831] 
[09:28:22.831] getGlobalsAndPackages() ... DONE
[09:28:22.831]  - globals found/used: [n=1] ‘FUN’
[09:28:22.831]  - needed namespaces: [n=0] 
[09:28:22.831] Finding globals ... DONE
[09:28:22.831]  - use_args: TRUE
[09:28:22.831]  - Getting '...' globals ...
[09:28:22.831] resolve() on list ...
[09:28:22.831]  recursive: 0
[09:28:22.832]  length: 1
[09:28:22.832]  elements: ‘...’
[09:28:22.832]  length: 0 (resolved future 1)
[09:28:22.832] resolve() on list ... DONE
[09:28:22.832]    - '...' content: [n=1] ‘digits’
[09:28:22.832] List of 1
[09:28:22.832]  $ ...:List of 1
[09:28:22.832]   ..$ digits: int 2
[09:28:22.832]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.832]  - attr(*, "where")=List of 1
[09:28:22.832]   ..$ ...:<environment: 0x555b0a19cf78> 
[09:28:22.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.832]  - attr(*, "resolved")= logi TRUE
[09:28:22.832]  - attr(*, "total_size")= num NA
[09:28:22.835]  - Getting '...' globals ... DONE
[09:28:22.835] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.835] List of 2
[09:28:22.835]  $ ...future.FUN:function (object, ...)  
[09:28:22.835]  $ ...          :List of 1
[09:28:22.835]   ..$ digits: int 2
[09:28:22.835]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.835]  - attr(*, "where")=List of 2
[09:28:22.835]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.835]   ..$ ...          :<environment: 0x555b0a19cf78> 
[09:28:22.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.835]  - attr(*, "resolved")= logi FALSE
[09:28:22.835]  - attr(*, "total_size")= num 1296
[09:28:22.839] Packages to be attached in all futures: [n=0] 
[09:28:22.839] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.839] Number of futures (= number of chunks): 1
[09:28:22.839] Launching 1 futures (chunks) ...
[09:28:22.839] Chunk #1 of 1 ...
[09:28:22.839]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.839] getGlobalsAndPackages() ...
[09:28:22.840] Searching for globals...
[09:28:22.840] 
[09:28:22.840] Searching for globals ... DONE
[09:28:22.840] - globals: [0] <none>
[09:28:22.840] getGlobalsAndPackages() ... DONE
[09:28:22.840]    + additional globals found: [n=0] 
[09:28:22.840]    + additional namespaces needed: [n=0] 
[09:28:22.840]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.840]  - seeds: <none>
[09:28:22.840]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.841] getGlobalsAndPackages() ...
[09:28:22.841] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.841] Resolving globals: FALSE
[09:28:22.841] Tweak future expression to call with '...' arguments ...
[09:28:22.841] {
[09:28:22.841]     do.call(function(...) {
[09:28:22.841]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.841]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.841]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.841]             on.exit(options(oopts), add = TRUE)
[09:28:22.841]         }
[09:28:22.841]         {
[09:28:22.841]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.841]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.841]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.841]             })
[09:28:22.841]         }
[09:28:22.841]     }, args = future.call.arguments)
[09:28:22.841] }
[09:28:22.841] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.841] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.842] 
[09:28:22.842] getGlobalsAndPackages() ... DONE
[09:28:22.842] run() for ‘Future’ ...
[09:28:22.842] - state: ‘created’
[09:28:22.842] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:22.842] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.842] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.843]   - Field: ‘label’
[09:28:22.843]   - Field: ‘local’
[09:28:22.843]   - Field: ‘owner’
[09:28:22.843]   - Field: ‘envir’
[09:28:22.843]   - Field: ‘packages’
[09:28:22.843]   - Field: ‘gc’
[09:28:22.843]   - Field: ‘conditions’
[09:28:22.843]   - Field: ‘expr’
[09:28:22.843]   - Field: ‘uuid’
[09:28:22.843]   - Field: ‘seed’
[09:28:22.843]   - Field: ‘version’
[09:28:22.844]   - Field: ‘result’
[09:28:22.844]   - Field: ‘asynchronous’
[09:28:22.844]   - Field: ‘calls’
[09:28:22.844]   - Field: ‘globals’
[09:28:22.844]   - Field: ‘stdout’
[09:28:22.844]   - Field: ‘earlySignal’
[09:28:22.844]   - Field: ‘lazy’
[09:28:22.844]   - Field: ‘state’
[09:28:22.844] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.844] - Launch lazy future ...
[09:28:22.845] Packages needed by the future expression (n = 0): <none>
[09:28:22.845] Packages needed by future strategies (n = 0): <none>
[09:28:22.845] {
[09:28:22.845]     {
[09:28:22.845]         {
[09:28:22.845]             ...future.startTime <- base::Sys.time()
[09:28:22.845]             {
[09:28:22.845]                 {
[09:28:22.845]                   {
[09:28:22.845]                     base::local({
[09:28:22.845]                       has_future <- base::requireNamespace("future", 
[09:28:22.845]                         quietly = TRUE)
[09:28:22.845]                       if (has_future) {
[09:28:22.845]                         ns <- base::getNamespace("future")
[09:28:22.845]                         version <- ns[[".package"]][["version"]]
[09:28:22.845]                         if (is.null(version)) 
[09:28:22.845]                           version <- utils::packageVersion("future")
[09:28:22.845]                       }
[09:28:22.845]                       else {
[09:28:22.845]                         version <- NULL
[09:28:22.845]                       }
[09:28:22.845]                       if (!has_future || version < "1.8.0") {
[09:28:22.845]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.845]                           "", base::R.version$version.string), 
[09:28:22.845]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.845]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.845]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.845]                             "release", "version")], collapse = " "), 
[09:28:22.845]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.845]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.845]                           info)
[09:28:22.845]                         info <- base::paste(info, collapse = "; ")
[09:28:22.845]                         if (!has_future) {
[09:28:22.845]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.845]                             info)
[09:28:22.845]                         }
[09:28:22.845]                         else {
[09:28:22.845]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.845]                             info, version)
[09:28:22.845]                         }
[09:28:22.845]                         base::stop(msg)
[09:28:22.845]                       }
[09:28:22.845]                     })
[09:28:22.845]                   }
[09:28:22.845]                   ...future.strategy.old <- future::plan("list")
[09:28:22.845]                   options(future.plan = NULL)
[09:28:22.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.845]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.845]                 }
[09:28:22.845]                 ...future.workdir <- getwd()
[09:28:22.845]             }
[09:28:22.845]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.845]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.845]         }
[09:28:22.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.845]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.845]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.845]             base::names(...future.oldOptions))
[09:28:22.845]     }
[09:28:22.845]     if (FALSE) {
[09:28:22.845]     }
[09:28:22.845]     else {
[09:28:22.845]         if (TRUE) {
[09:28:22.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.845]                 open = "w")
[09:28:22.845]         }
[09:28:22.845]         else {
[09:28:22.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.845]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.845]         }
[09:28:22.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.845]             base::sink(type = "output", split = FALSE)
[09:28:22.845]             base::close(...future.stdout)
[09:28:22.845]         }, add = TRUE)
[09:28:22.845]     }
[09:28:22.845]     ...future.frame <- base::sys.nframe()
[09:28:22.845]     ...future.conditions <- base::list()
[09:28:22.845]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.845]     if (FALSE) {
[09:28:22.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.845]     }
[09:28:22.845]     ...future.result <- base::tryCatch({
[09:28:22.845]         base::withCallingHandlers({
[09:28:22.845]             ...future.value <- base::withVisible(base::local({
[09:28:22.845]                 do.call(function(...) {
[09:28:22.845]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.845]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.845]                     ...future.globals.maxSize)) {
[09:28:22.845]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.845]                     on.exit(options(oopts), add = TRUE)
[09:28:22.845]                   }
[09:28:22.845]                   {
[09:28:22.845]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.845]                       FUN = function(jj) {
[09:28:22.845]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.845]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.845]                       })
[09:28:22.845]                   }
[09:28:22.845]                 }, args = future.call.arguments)
[09:28:22.845]             }))
[09:28:22.845]             future::FutureResult(value = ...future.value$value, 
[09:28:22.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.845]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.845]                     ...future.globalenv.names))
[09:28:22.845]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.845]         }, condition = base::local({
[09:28:22.845]             c <- base::c
[09:28:22.845]             inherits <- base::inherits
[09:28:22.845]             invokeRestart <- base::invokeRestart
[09:28:22.845]             length <- base::length
[09:28:22.845]             list <- base::list
[09:28:22.845]             seq.int <- base::seq.int
[09:28:22.845]             signalCondition <- base::signalCondition
[09:28:22.845]             sys.calls <- base::sys.calls
[09:28:22.845]             `[[` <- base::`[[`
[09:28:22.845]             `+` <- base::`+`
[09:28:22.845]             `<<-` <- base::`<<-`
[09:28:22.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.845]                   3L)]
[09:28:22.845]             }
[09:28:22.845]             function(cond) {
[09:28:22.845]                 is_error <- inherits(cond, "error")
[09:28:22.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.845]                   NULL)
[09:28:22.845]                 if (is_error) {
[09:28:22.845]                   sessionInformation <- function() {
[09:28:22.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.845]                       search = base::search(), system = base::Sys.info())
[09:28:22.845]                   }
[09:28:22.845]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.845]                     cond$call), session = sessionInformation(), 
[09:28:22.845]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.845]                   signalCondition(cond)
[09:28:22.845]                 }
[09:28:22.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.845]                 "immediateCondition"))) {
[09:28:22.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.845]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.845]                   if (TRUE && !signal) {
[09:28:22.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.845]                     {
[09:28:22.845]                       inherits <- base::inherits
[09:28:22.845]                       invokeRestart <- base::invokeRestart
[09:28:22.845]                       is.null <- base::is.null
[09:28:22.845]                       muffled <- FALSE
[09:28:22.845]                       if (inherits(cond, "message")) {
[09:28:22.845]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.845]                         if (muffled) 
[09:28:22.845]                           invokeRestart("muffleMessage")
[09:28:22.845]                       }
[09:28:22.845]                       else if (inherits(cond, "warning")) {
[09:28:22.845]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.845]                         if (muffled) 
[09:28:22.845]                           invokeRestart("muffleWarning")
[09:28:22.845]                       }
[09:28:22.845]                       else if (inherits(cond, "condition")) {
[09:28:22.845]                         if (!is.null(pattern)) {
[09:28:22.845]                           computeRestarts <- base::computeRestarts
[09:28:22.845]                           grepl <- base::grepl
[09:28:22.845]                           restarts <- computeRestarts(cond)
[09:28:22.845]                           for (restart in restarts) {
[09:28:22.845]                             name <- restart$name
[09:28:22.845]                             if (is.null(name)) 
[09:28:22.845]                               next
[09:28:22.845]                             if (!grepl(pattern, name)) 
[09:28:22.845]                               next
[09:28:22.845]                             invokeRestart(restart)
[09:28:22.845]                             muffled <- TRUE
[09:28:22.845]                             break
[09:28:22.845]                           }
[09:28:22.845]                         }
[09:28:22.845]                       }
[09:28:22.845]                       invisible(muffled)
[09:28:22.845]                     }
[09:28:22.845]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.845]                   }
[09:28:22.845]                 }
[09:28:22.845]                 else {
[09:28:22.845]                   if (TRUE) {
[09:28:22.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.845]                     {
[09:28:22.845]                       inherits <- base::inherits
[09:28:22.845]                       invokeRestart <- base::invokeRestart
[09:28:22.845]                       is.null <- base::is.null
[09:28:22.845]                       muffled <- FALSE
[09:28:22.845]                       if (inherits(cond, "message")) {
[09:28:22.845]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.845]                         if (muffled) 
[09:28:22.845]                           invokeRestart("muffleMessage")
[09:28:22.845]                       }
[09:28:22.845]                       else if (inherits(cond, "warning")) {
[09:28:22.845]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.845]                         if (muffled) 
[09:28:22.845]                           invokeRestart("muffleWarning")
[09:28:22.845]                       }
[09:28:22.845]                       else if (inherits(cond, "condition")) {
[09:28:22.845]                         if (!is.null(pattern)) {
[09:28:22.845]                           computeRestarts <- base::computeRestarts
[09:28:22.845]                           grepl <- base::grepl
[09:28:22.845]                           restarts <- computeRestarts(cond)
[09:28:22.845]                           for (restart in restarts) {
[09:28:22.845]                             name <- restart$name
[09:28:22.845]                             if (is.null(name)) 
[09:28:22.845]                               next
[09:28:22.845]                             if (!grepl(pattern, name)) 
[09:28:22.845]                               next
[09:28:22.845]                             invokeRestart(restart)
[09:28:22.845]                             muffled <- TRUE
[09:28:22.845]                             break
[09:28:22.845]                           }
[09:28:22.845]                         }
[09:28:22.845]                       }
[09:28:22.845]                       invisible(muffled)
[09:28:22.845]                     }
[09:28:22.845]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.845]                   }
[09:28:22.845]                 }
[09:28:22.845]             }
[09:28:22.845]         }))
[09:28:22.845]     }, error = function(ex) {
[09:28:22.845]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.845]                 ...future.rng), started = ...future.startTime, 
[09:28:22.845]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.845]             version = "1.8"), class = "FutureResult")
[09:28:22.845]     }, finally = {
[09:28:22.845]         if (!identical(...future.workdir, getwd())) 
[09:28:22.845]             setwd(...future.workdir)
[09:28:22.845]         {
[09:28:22.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.845]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.845]             }
[09:28:22.845]             base::options(...future.oldOptions)
[09:28:22.845]             if (.Platform$OS.type == "windows") {
[09:28:22.845]                 old_names <- names(...future.oldEnvVars)
[09:28:22.845]                 envs <- base::Sys.getenv()
[09:28:22.845]                 names <- names(envs)
[09:28:22.845]                 common <- intersect(names, old_names)
[09:28:22.845]                 added <- setdiff(names, old_names)
[09:28:22.845]                 removed <- setdiff(old_names, names)
[09:28:22.845]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.845]                   envs[common]]
[09:28:22.845]                 NAMES <- toupper(changed)
[09:28:22.845]                 args <- list()
[09:28:22.845]                 for (kk in seq_along(NAMES)) {
[09:28:22.845]                   name <- changed[[kk]]
[09:28:22.845]                   NAME <- NAMES[[kk]]
[09:28:22.845]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.845]                     next
[09:28:22.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.845]                 }
[09:28:22.845]                 NAMES <- toupper(added)
[09:28:22.845]                 for (kk in seq_along(NAMES)) {
[09:28:22.845]                   name <- added[[kk]]
[09:28:22.845]                   NAME <- NAMES[[kk]]
[09:28:22.845]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.845]                     next
[09:28:22.845]                   args[[name]] <- ""
[09:28:22.845]                 }
[09:28:22.845]                 NAMES <- toupper(removed)
[09:28:22.845]                 for (kk in seq_along(NAMES)) {
[09:28:22.845]                   name <- removed[[kk]]
[09:28:22.845]                   NAME <- NAMES[[kk]]
[09:28:22.845]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.845]                     next
[09:28:22.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.845]                 }
[09:28:22.845]                 if (length(args) > 0) 
[09:28:22.845]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.845]             }
[09:28:22.845]             else {
[09:28:22.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.845]             }
[09:28:22.845]             {
[09:28:22.845]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.845]                   0L) {
[09:28:22.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.845]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.845]                   base::options(opts)
[09:28:22.845]                 }
[09:28:22.845]                 {
[09:28:22.845]                   {
[09:28:22.845]                     NULL
[09:28:22.845]                     RNGkind("Mersenne-Twister")
[09:28:22.845]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.845]                       inherits = FALSE)
[09:28:22.845]                   }
[09:28:22.845]                   options(future.plan = NULL)
[09:28:22.845]                   if (is.na(NA_character_)) 
[09:28:22.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.845]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.845]                     .init = FALSE)
[09:28:22.845]                 }
[09:28:22.845]             }
[09:28:22.845]         }
[09:28:22.845]     })
[09:28:22.845]     if (TRUE) {
[09:28:22.845]         base::sink(type = "output", split = FALSE)
[09:28:22.845]         if (TRUE) {
[09:28:22.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.845]         }
[09:28:22.845]         else {
[09:28:22.845]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.845]         }
[09:28:22.845]         base::close(...future.stdout)
[09:28:22.845]         ...future.stdout <- NULL
[09:28:22.845]     }
[09:28:22.845]     ...future.result$conditions <- ...future.conditions
[09:28:22.845]     ...future.result$finished <- base::Sys.time()
[09:28:22.845]     ...future.result
[09:28:22.845] }
[09:28:22.847] assign_globals() ...
[09:28:22.847] List of 5
[09:28:22.847]  $ ...future.FUN            :function (object, ...)  
[09:28:22.847]  $ future.call.arguments    :List of 1
[09:28:22.847]   ..$ digits: int 2
[09:28:22.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.847]  $ ...future.elements_ii    :List of 6
[09:28:22.847]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[09:28:22.847]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[09:28:22.847]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[09:28:22.847]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[09:28:22.847]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[09:28:22.847]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[09:28:22.847]  $ ...future.seeds_ii       : NULL
[09:28:22.847]  $ ...future.globals.maxSize: NULL
[09:28:22.847]  - attr(*, "where")=List of 5
[09:28:22.847]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.847]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.847]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.847]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.847]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.847]  - attr(*, "resolved")= logi FALSE
[09:28:22.847]  - attr(*, "total_size")= num 1296
[09:28:22.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.847]  - attr(*, "already-done")= logi TRUE
[09:28:22.853] - copied ‘...future.FUN’ to environment
[09:28:22.853] - copied ‘future.call.arguments’ to environment
[09:28:22.853] - copied ‘...future.elements_ii’ to environment
[09:28:22.853] - copied ‘...future.seeds_ii’ to environment
[09:28:22.853] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.853] assign_globals() ... done
[09:28:22.853] plan(): Setting new future strategy stack:
[09:28:22.853] List of future strategies:
[09:28:22.853] 1. sequential:
[09:28:22.853]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.853]    - tweaked: FALSE
[09:28:22.853]    - call: NULL
[09:28:22.854] plan(): nbrOfWorkers() = 1
[09:28:22.855] plan(): Setting new future strategy stack:
[09:28:22.855] List of future strategies:
[09:28:22.855] 1. sequential:
[09:28:22.855]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.855]    - tweaked: FALSE
[09:28:22.855]    - call: plan(strategy)
[09:28:22.856] plan(): nbrOfWorkers() = 1
[09:28:22.856] SequentialFuture started (and completed)
[09:28:22.856] - Launch lazy future ... done
[09:28:22.856] run() for ‘SequentialFuture’ ... done
[09:28:22.856] Created future:
[09:28:22.856] SequentialFuture:
[09:28:22.856] Label: ‘future_by-1’
[09:28:22.856] Expression:
[09:28:22.856] {
[09:28:22.856]     do.call(function(...) {
[09:28:22.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.856]             on.exit(options(oopts), add = TRUE)
[09:28:22.856]         }
[09:28:22.856]         {
[09:28:22.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.856]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.856]             })
[09:28:22.856]         }
[09:28:22.856]     }, args = future.call.arguments)
[09:28:22.856] }
[09:28:22.856] Lazy evaluation: FALSE
[09:28:22.856] Asynchronous evaluation: FALSE
[09:28:22.856] Local evaluation: TRUE
[09:28:22.856] Environment: R_GlobalEnv
[09:28:22.856] Capture standard output: TRUE
[09:28:22.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.856] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.856] Packages: <none>
[09:28:22.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.856] Resolved: TRUE
[09:28:22.856] Value: 5.48 KiB of class ‘list’
[09:28:22.856] Early signaling: FALSE
[09:28:22.856] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.856] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.857] Chunk #1 of 1 ... DONE
[09:28:22.857] Launching 1 futures (chunks) ... DONE
[09:28:22.857] Resolving 1 futures (chunks) ...
[09:28:22.857] resolve() on list ...
[09:28:22.857]  recursive: 0
[09:28:22.858]  length: 1
[09:28:22.858] 
[09:28:22.858] resolved() for ‘SequentialFuture’ ...
[09:28:22.859] - state: ‘finished’
[09:28:22.859] - run: TRUE
[09:28:22.859] - result: ‘FutureResult’
[09:28:22.859] resolved() for ‘SequentialFuture’ ... done
[09:28:22.859] Future #1
[09:28:22.859] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.859] - nx: 1
[09:28:22.859] - relay: TRUE
[09:28:22.859] - stdout: TRUE
[09:28:22.859] - signal: TRUE
[09:28:22.859] - resignal: FALSE
[09:28:22.860] - force: TRUE
[09:28:22.860] - relayed: [n=1] FALSE
[09:28:22.860] - queued futures: [n=1] FALSE
[09:28:22.860]  - until=1
[09:28:22.860]  - relaying element #1
[09:28:22.860] - relayed: [n=1] TRUE
[09:28:22.860] - queued futures: [n=1] TRUE
[09:28:22.860] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.860]  length: 0 (resolved future 1)
[09:28:22.861] Relaying remaining futures
[09:28:22.861] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.861] - nx: 1
[09:28:22.861] - relay: TRUE
[09:28:22.861] - stdout: TRUE
[09:28:22.861] - signal: TRUE
[09:28:22.861] - resignal: FALSE
[09:28:22.861] - force: TRUE
[09:28:22.861] - relayed: [n=1] TRUE
[09:28:22.861] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.861] - relayed: [n=1] TRUE
[09:28:22.861] - queued futures: [n=1] TRUE
[09:28:22.862] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.862] resolve() on list ... DONE
[09:28:22.862]  - Number of value chunks collected: 1
[09:28:22.862] Resolving 1 futures (chunks) ... DONE
[09:28:22.862] Reducing values from 1 chunks ...
[09:28:22.862]  - Number of values collected after concatenation: 6
[09:28:22.862]  - Number of values expected: 6
[09:28:22.862] Reducing values from 1 chunks ... DONE
[09:28:22.862] future_lapply() ... DONE
[09:28:22.862] future_by_internal() ... DONE
[09:28:22.863] future_by_internal() ...
[09:28:22.864] future_lapply() ...
[09:28:22.864] Number of chunks: 1
[09:28:22.864] getGlobalsAndPackagesXApply() ...
[09:28:22.865]  - future.globals: TRUE
[09:28:22.865] getGlobalsAndPackages() ...
[09:28:22.865] Searching for globals...
[09:28:22.866] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:22.866] Searching for globals ... DONE
[09:28:22.866] Resolving globals: FALSE
[09:28:22.867] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[09:28:22.867] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[09:28:22.867] - globals: [1] ‘FUN’
[09:28:22.867] - packages: [1] ‘stats’
[09:28:22.867] getGlobalsAndPackages() ... DONE
[09:28:22.867]  - globals found/used: [n=1] ‘FUN’
[09:28:22.867]  - needed namespaces: [n=1] ‘stats’
[09:28:22.868] Finding globals ... DONE
[09:28:22.868]  - use_args: TRUE
[09:28:22.868]  - Getting '...' globals ...
[09:28:22.868] resolve() on list ...
[09:28:22.868]  recursive: 0
[09:28:22.868]  length: 1
[09:28:22.868]  elements: ‘...’
[09:28:22.868]  length: 0 (resolved future 1)
[09:28:22.869] resolve() on list ... DONE
[09:28:22.869]    - '...' content: [n=1] ‘singular.ok’
[09:28:22.869] List of 1
[09:28:22.869]  $ ...:List of 1
[09:28:22.869]   ..$ singular.ok: logi FALSE
[09:28:22.869]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.869]  - attr(*, "where")=List of 1
[09:28:22.869]   ..$ ...:<environment: 0x555b08f31dd8> 
[09:28:22.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.869]  - attr(*, "resolved")= logi TRUE
[09:28:22.869]  - attr(*, "total_size")= num NA
[09:28:22.871]  - Getting '...' globals ... DONE
[09:28:22.872] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.872] List of 2
[09:28:22.872]  $ ...future.FUN:function (x, ...)  
[09:28:22.872]  $ ...          :List of 1
[09:28:22.872]   ..$ singular.ok: logi FALSE
[09:28:22.872]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.872]  - attr(*, "where")=List of 2
[09:28:22.872]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.872]   ..$ ...          :<environment: 0x555b08f31dd8> 
[09:28:22.872]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.872]  - attr(*, "resolved")= logi FALSE
[09:28:22.872]  - attr(*, "total_size")= num 5384
[09:28:22.874] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:22.875] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.875] Number of futures (= number of chunks): 1
[09:28:22.875] Launching 1 futures (chunks) ...
[09:28:22.875] Chunk #1 of 1 ...
[09:28:22.875]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.875] getGlobalsAndPackages() ...
[09:28:22.875] Searching for globals...
[09:28:22.876] 
[09:28:22.876] Searching for globals ... DONE
[09:28:22.876] - globals: [0] <none>
[09:28:22.876] getGlobalsAndPackages() ... DONE
[09:28:22.876]    + additional globals found: [n=0] 
[09:28:22.876]    + additional namespaces needed: [n=0] 
[09:28:22.876]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.876]  - seeds: <none>
[09:28:22.876]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.877] getGlobalsAndPackages() ...
[09:28:22.877] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.878] Resolving globals: FALSE
[09:28:22.878] Tweak future expression to call with '...' arguments ...
[09:28:22.878] {
[09:28:22.878]     do.call(function(...) {
[09:28:22.878]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.878]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.878]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.878]             on.exit(options(oopts), add = TRUE)
[09:28:22.878]         }
[09:28:22.878]         {
[09:28:22.878]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.878]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.878]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.878]             })
[09:28:22.878]         }
[09:28:22.878]     }, args = future.call.arguments)
[09:28:22.878] }
[09:28:22.878] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.878] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.878] 
[09:28:22.879] getGlobalsAndPackages() ... DONE
[09:28:22.879] run() for ‘Future’ ...
[09:28:22.879] - state: ‘created’
[09:28:22.879] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:22.879] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.879] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.879]   - Field: ‘label’
[09:28:22.880]   - Field: ‘local’
[09:28:22.880]   - Field: ‘owner’
[09:28:22.880]   - Field: ‘envir’
[09:28:22.880]   - Field: ‘packages’
[09:28:22.880]   - Field: ‘gc’
[09:28:22.880]   - Field: ‘conditions’
[09:28:22.880]   - Field: ‘expr’
[09:28:22.880]   - Field: ‘uuid’
[09:28:22.880]   - Field: ‘seed’
[09:28:22.880]   - Field: ‘version’
[09:28:22.880]   - Field: ‘result’
[09:28:22.881]   - Field: ‘asynchronous’
[09:28:22.881]   - Field: ‘calls’
[09:28:22.881]   - Field: ‘globals’
[09:28:22.881]   - Field: ‘stdout’
[09:28:22.881]   - Field: ‘earlySignal’
[09:28:22.881]   - Field: ‘lazy’
[09:28:22.881]   - Field: ‘state’
[09:28:22.881] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.881] - Launch lazy future ...
[09:28:22.881] Packages needed by the future expression (n = 1): ‘stats’
[09:28:22.881] Packages needed by future strategies (n = 0): <none>
[09:28:22.882] {
[09:28:22.882]     {
[09:28:22.882]         {
[09:28:22.882]             ...future.startTime <- base::Sys.time()
[09:28:22.882]             {
[09:28:22.882]                 {
[09:28:22.882]                   {
[09:28:22.882]                     {
[09:28:22.882]                       base::local({
[09:28:22.882]                         has_future <- base::requireNamespace("future", 
[09:28:22.882]                           quietly = TRUE)
[09:28:22.882]                         if (has_future) {
[09:28:22.882]                           ns <- base::getNamespace("future")
[09:28:22.882]                           version <- ns[[".package"]][["version"]]
[09:28:22.882]                           if (is.null(version)) 
[09:28:22.882]                             version <- utils::packageVersion("future")
[09:28:22.882]                         }
[09:28:22.882]                         else {
[09:28:22.882]                           version <- NULL
[09:28:22.882]                         }
[09:28:22.882]                         if (!has_future || version < "1.8.0") {
[09:28:22.882]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.882]                             "", base::R.version$version.string), 
[09:28:22.882]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:22.882]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.882]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.882]                               "release", "version")], collapse = " "), 
[09:28:22.882]                             hostname = base::Sys.info()[["nodename"]])
[09:28:22.882]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.882]                             info)
[09:28:22.882]                           info <- base::paste(info, collapse = "; ")
[09:28:22.882]                           if (!has_future) {
[09:28:22.882]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.882]                               info)
[09:28:22.882]                           }
[09:28:22.882]                           else {
[09:28:22.882]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.882]                               info, version)
[09:28:22.882]                           }
[09:28:22.882]                           base::stop(msg)
[09:28:22.882]                         }
[09:28:22.882]                       })
[09:28:22.882]                     }
[09:28:22.882]                     base::local({
[09:28:22.882]                       for (pkg in "stats") {
[09:28:22.882]                         base::loadNamespace(pkg)
[09:28:22.882]                         base::library(pkg, character.only = TRUE)
[09:28:22.882]                       }
[09:28:22.882]                     })
[09:28:22.882]                   }
[09:28:22.882]                   ...future.strategy.old <- future::plan("list")
[09:28:22.882]                   options(future.plan = NULL)
[09:28:22.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.882]                 }
[09:28:22.882]                 ...future.workdir <- getwd()
[09:28:22.882]             }
[09:28:22.882]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.882]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.882]         }
[09:28:22.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.882]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.882]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.882]             base::names(...future.oldOptions))
[09:28:22.882]     }
[09:28:22.882]     if (FALSE) {
[09:28:22.882]     }
[09:28:22.882]     else {
[09:28:22.882]         if (TRUE) {
[09:28:22.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.882]                 open = "w")
[09:28:22.882]         }
[09:28:22.882]         else {
[09:28:22.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.882]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.882]         }
[09:28:22.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.882]             base::sink(type = "output", split = FALSE)
[09:28:22.882]             base::close(...future.stdout)
[09:28:22.882]         }, add = TRUE)
[09:28:22.882]     }
[09:28:22.882]     ...future.frame <- base::sys.nframe()
[09:28:22.882]     ...future.conditions <- base::list()
[09:28:22.882]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.882]     if (FALSE) {
[09:28:22.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.882]     }
[09:28:22.882]     ...future.result <- base::tryCatch({
[09:28:22.882]         base::withCallingHandlers({
[09:28:22.882]             ...future.value <- base::withVisible(base::local({
[09:28:22.882]                 do.call(function(...) {
[09:28:22.882]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.882]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.882]                     ...future.globals.maxSize)) {
[09:28:22.882]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.882]                     on.exit(options(oopts), add = TRUE)
[09:28:22.882]                   }
[09:28:22.882]                   {
[09:28:22.882]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.882]                       FUN = function(jj) {
[09:28:22.882]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.882]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.882]                       })
[09:28:22.882]                   }
[09:28:22.882]                 }, args = future.call.arguments)
[09:28:22.882]             }))
[09:28:22.882]             future::FutureResult(value = ...future.value$value, 
[09:28:22.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.882]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.882]                     ...future.globalenv.names))
[09:28:22.882]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.882]         }, condition = base::local({
[09:28:22.882]             c <- base::c
[09:28:22.882]             inherits <- base::inherits
[09:28:22.882]             invokeRestart <- base::invokeRestart
[09:28:22.882]             length <- base::length
[09:28:22.882]             list <- base::list
[09:28:22.882]             seq.int <- base::seq.int
[09:28:22.882]             signalCondition <- base::signalCondition
[09:28:22.882]             sys.calls <- base::sys.calls
[09:28:22.882]             `[[` <- base::`[[`
[09:28:22.882]             `+` <- base::`+`
[09:28:22.882]             `<<-` <- base::`<<-`
[09:28:22.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.882]                   3L)]
[09:28:22.882]             }
[09:28:22.882]             function(cond) {
[09:28:22.882]                 is_error <- inherits(cond, "error")
[09:28:22.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.882]                   NULL)
[09:28:22.882]                 if (is_error) {
[09:28:22.882]                   sessionInformation <- function() {
[09:28:22.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.882]                       search = base::search(), system = base::Sys.info())
[09:28:22.882]                   }
[09:28:22.882]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.882]                     cond$call), session = sessionInformation(), 
[09:28:22.882]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.882]                   signalCondition(cond)
[09:28:22.882]                 }
[09:28:22.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.882]                 "immediateCondition"))) {
[09:28:22.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.882]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.882]                   if (TRUE && !signal) {
[09:28:22.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.882]                     {
[09:28:22.882]                       inherits <- base::inherits
[09:28:22.882]                       invokeRestart <- base::invokeRestart
[09:28:22.882]                       is.null <- base::is.null
[09:28:22.882]                       muffled <- FALSE
[09:28:22.882]                       if (inherits(cond, "message")) {
[09:28:22.882]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.882]                         if (muffled) 
[09:28:22.882]                           invokeRestart("muffleMessage")
[09:28:22.882]                       }
[09:28:22.882]                       else if (inherits(cond, "warning")) {
[09:28:22.882]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.882]                         if (muffled) 
[09:28:22.882]                           invokeRestart("muffleWarning")
[09:28:22.882]                       }
[09:28:22.882]                       else if (inherits(cond, "condition")) {
[09:28:22.882]                         if (!is.null(pattern)) {
[09:28:22.882]                           computeRestarts <- base::computeRestarts
[09:28:22.882]                           grepl <- base::grepl
[09:28:22.882]                           restarts <- computeRestarts(cond)
[09:28:22.882]                           for (restart in restarts) {
[09:28:22.882]                             name <- restart$name
[09:28:22.882]                             if (is.null(name)) 
[09:28:22.882]                               next
[09:28:22.882]                             if (!grepl(pattern, name)) 
[09:28:22.882]                               next
[09:28:22.882]                             invokeRestart(restart)
[09:28:22.882]                             muffled <- TRUE
[09:28:22.882]                             break
[09:28:22.882]                           }
[09:28:22.882]                         }
[09:28:22.882]                       }
[09:28:22.882]                       invisible(muffled)
[09:28:22.882]                     }
[09:28:22.882]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.882]                   }
[09:28:22.882]                 }
[09:28:22.882]                 else {
[09:28:22.882]                   if (TRUE) {
[09:28:22.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.882]                     {
[09:28:22.882]                       inherits <- base::inherits
[09:28:22.882]                       invokeRestart <- base::invokeRestart
[09:28:22.882]                       is.null <- base::is.null
[09:28:22.882]                       muffled <- FALSE
[09:28:22.882]                       if (inherits(cond, "message")) {
[09:28:22.882]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.882]                         if (muffled) 
[09:28:22.882]                           invokeRestart("muffleMessage")
[09:28:22.882]                       }
[09:28:22.882]                       else if (inherits(cond, "warning")) {
[09:28:22.882]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.882]                         if (muffled) 
[09:28:22.882]                           invokeRestart("muffleWarning")
[09:28:22.882]                       }
[09:28:22.882]                       else if (inherits(cond, "condition")) {
[09:28:22.882]                         if (!is.null(pattern)) {
[09:28:22.882]                           computeRestarts <- base::computeRestarts
[09:28:22.882]                           grepl <- base::grepl
[09:28:22.882]                           restarts <- computeRestarts(cond)
[09:28:22.882]                           for (restart in restarts) {
[09:28:22.882]                             name <- restart$name
[09:28:22.882]                             if (is.null(name)) 
[09:28:22.882]                               next
[09:28:22.882]                             if (!grepl(pattern, name)) 
[09:28:22.882]                               next
[09:28:22.882]                             invokeRestart(restart)
[09:28:22.882]                             muffled <- TRUE
[09:28:22.882]                             break
[09:28:22.882]                           }
[09:28:22.882]                         }
[09:28:22.882]                       }
[09:28:22.882]                       invisible(muffled)
[09:28:22.882]                     }
[09:28:22.882]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.882]                   }
[09:28:22.882]                 }
[09:28:22.882]             }
[09:28:22.882]         }))
[09:28:22.882]     }, error = function(ex) {
[09:28:22.882]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.882]                 ...future.rng), started = ...future.startTime, 
[09:28:22.882]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.882]             version = "1.8"), class = "FutureResult")
[09:28:22.882]     }, finally = {
[09:28:22.882]         if (!identical(...future.workdir, getwd())) 
[09:28:22.882]             setwd(...future.workdir)
[09:28:22.882]         {
[09:28:22.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.882]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.882]             }
[09:28:22.882]             base::options(...future.oldOptions)
[09:28:22.882]             if (.Platform$OS.type == "windows") {
[09:28:22.882]                 old_names <- names(...future.oldEnvVars)
[09:28:22.882]                 envs <- base::Sys.getenv()
[09:28:22.882]                 names <- names(envs)
[09:28:22.882]                 common <- intersect(names, old_names)
[09:28:22.882]                 added <- setdiff(names, old_names)
[09:28:22.882]                 removed <- setdiff(old_names, names)
[09:28:22.882]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.882]                   envs[common]]
[09:28:22.882]                 NAMES <- toupper(changed)
[09:28:22.882]                 args <- list()
[09:28:22.882]                 for (kk in seq_along(NAMES)) {
[09:28:22.882]                   name <- changed[[kk]]
[09:28:22.882]                   NAME <- NAMES[[kk]]
[09:28:22.882]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.882]                     next
[09:28:22.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.882]                 }
[09:28:22.882]                 NAMES <- toupper(added)
[09:28:22.882]                 for (kk in seq_along(NAMES)) {
[09:28:22.882]                   name <- added[[kk]]
[09:28:22.882]                   NAME <- NAMES[[kk]]
[09:28:22.882]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.882]                     next
[09:28:22.882]                   args[[name]] <- ""
[09:28:22.882]                 }
[09:28:22.882]                 NAMES <- toupper(removed)
[09:28:22.882]                 for (kk in seq_along(NAMES)) {
[09:28:22.882]                   name <- removed[[kk]]
[09:28:22.882]                   NAME <- NAMES[[kk]]
[09:28:22.882]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.882]                     next
[09:28:22.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.882]                 }
[09:28:22.882]                 if (length(args) > 0) 
[09:28:22.882]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.882]             }
[09:28:22.882]             else {
[09:28:22.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.882]             }
[09:28:22.882]             {
[09:28:22.882]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.882]                   0L) {
[09:28:22.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.882]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.882]                   base::options(opts)
[09:28:22.882]                 }
[09:28:22.882]                 {
[09:28:22.882]                   {
[09:28:22.882]                     NULL
[09:28:22.882]                     RNGkind("Mersenne-Twister")
[09:28:22.882]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.882]                       inherits = FALSE)
[09:28:22.882]                   }
[09:28:22.882]                   options(future.plan = NULL)
[09:28:22.882]                   if (is.na(NA_character_)) 
[09:28:22.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.882]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.882]                     .init = FALSE)
[09:28:22.882]                 }
[09:28:22.882]             }
[09:28:22.882]         }
[09:28:22.882]     })
[09:28:22.882]     if (TRUE) {
[09:28:22.882]         base::sink(type = "output", split = FALSE)
[09:28:22.882]         if (TRUE) {
[09:28:22.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.882]         }
[09:28:22.882]         else {
[09:28:22.882]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.882]         }
[09:28:22.882]         base::close(...future.stdout)
[09:28:22.882]         ...future.stdout <- NULL
[09:28:22.882]     }
[09:28:22.882]     ...future.result$conditions <- ...future.conditions
[09:28:22.882]     ...future.result$finished <- base::Sys.time()
[09:28:22.882]     ...future.result
[09:28:22.882] }
[09:28:22.884] assign_globals() ...
[09:28:22.884] List of 5
[09:28:22.884]  $ ...future.FUN            :function (x, ...)  
[09:28:22.884]  $ future.call.arguments    :List of 1
[09:28:22.884]   ..$ singular.ok: logi FALSE
[09:28:22.884]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.884]  $ ...future.elements_ii    :List of 3
[09:28:22.884]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.884]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.884]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.884]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.884]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.884]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.884]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.884]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.884]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.884]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.884]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.884]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.884]  $ ...future.seeds_ii       : NULL
[09:28:22.884]  $ ...future.globals.maxSize: NULL
[09:28:22.884]  - attr(*, "where")=List of 5
[09:28:22.884]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.884]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.884]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.884]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.884]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.884]  - attr(*, "resolved")= logi FALSE
[09:28:22.884]  - attr(*, "total_size")= num 5384
[09:28:22.884]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.884]  - attr(*, "already-done")= logi TRUE
[09:28:22.892] - reassign environment for ‘...future.FUN’
[09:28:22.892] - copied ‘...future.FUN’ to environment
[09:28:22.892] - copied ‘future.call.arguments’ to environment
[09:28:22.892] - copied ‘...future.elements_ii’ to environment
[09:28:22.892] - copied ‘...future.seeds_ii’ to environment
[09:28:22.892] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.892] assign_globals() ... done
[09:28:22.893] plan(): Setting new future strategy stack:
[09:28:22.893] List of future strategies:
[09:28:22.893] 1. sequential:
[09:28:22.893]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.893]    - tweaked: FALSE
[09:28:22.893]    - call: NULL
[09:28:22.893] plan(): nbrOfWorkers() = 1
[09:28:22.896] plan(): Setting new future strategy stack:
[09:28:22.896] List of future strategies:
[09:28:22.896] 1. sequential:
[09:28:22.896]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.896]    - tweaked: FALSE
[09:28:22.896]    - call: plan(strategy)
[09:28:22.896] plan(): nbrOfWorkers() = 1
[09:28:22.896] SequentialFuture started (and completed)
[09:28:22.896] - Launch lazy future ... done
[09:28:22.896] run() for ‘SequentialFuture’ ... done
[09:28:22.897] Created future:
[09:28:22.897] SequentialFuture:
[09:28:22.897] Label: ‘future_by-1’
[09:28:22.897] Expression:
[09:28:22.897] {
[09:28:22.897]     do.call(function(...) {
[09:28:22.897]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.897]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.897]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.897]             on.exit(options(oopts), add = TRUE)
[09:28:22.897]         }
[09:28:22.897]         {
[09:28:22.897]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.897]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.897]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.897]             })
[09:28:22.897]         }
[09:28:22.897]     }, args = future.call.arguments)
[09:28:22.897] }
[09:28:22.897] Lazy evaluation: FALSE
[09:28:22.897] Asynchronous evaluation: FALSE
[09:28:22.897] Local evaluation: TRUE
[09:28:22.897] Environment: R_GlobalEnv
[09:28:22.897] Capture standard output: TRUE
[09:28:22.897] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.897] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.897] Packages: 1 packages (‘stats’)
[09:28:22.897] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.897] Resolved: TRUE
[09:28:22.897] Value: 26.06 KiB of class ‘list’
[09:28:22.897] Early signaling: FALSE
[09:28:22.897] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.897] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.899] Chunk #1 of 1 ... DONE
[09:28:22.899] Launching 1 futures (chunks) ... DONE
[09:28:22.899] Resolving 1 futures (chunks) ...
[09:28:22.899] resolve() on list ...
[09:28:22.899]  recursive: 0
[09:28:22.899]  length: 1
[09:28:22.899] 
[09:28:22.900] resolved() for ‘SequentialFuture’ ...
[09:28:22.900] - state: ‘finished’
[09:28:22.900] - run: TRUE
[09:28:22.900] - result: ‘FutureResult’
[09:28:22.900] resolved() for ‘SequentialFuture’ ... done
[09:28:22.900] Future #1
[09:28:22.900] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.900] - nx: 1
[09:28:22.900] - relay: TRUE
[09:28:22.900] - stdout: TRUE
[09:28:22.900] - signal: TRUE
[09:28:22.901] - resignal: FALSE
[09:28:22.901] - force: TRUE
[09:28:22.901] - relayed: [n=1] FALSE
[09:28:22.901] - queued futures: [n=1] FALSE
[09:28:22.901]  - until=1
[09:28:22.901]  - relaying element #1
[09:28:22.901] - relayed: [n=1] TRUE
[09:28:22.901] - queued futures: [n=1] TRUE
[09:28:22.901] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.901]  length: 0 (resolved future 1)
[09:28:22.902] Relaying remaining futures
[09:28:22.902] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.902] - nx: 1
[09:28:22.902] - relay: TRUE
[09:28:22.902] - stdout: TRUE
[09:28:22.902] - signal: TRUE
[09:28:22.902] - resignal: FALSE
[09:28:22.902] - force: TRUE
[09:28:22.902] - relayed: [n=1] TRUE
[09:28:22.902] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.902] - relayed: [n=1] TRUE
[09:28:22.902] - queued futures: [n=1] TRUE
[09:28:22.903] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.903] resolve() on list ... DONE
[09:28:22.903]  - Number of value chunks collected: 1
[09:28:22.903] Resolving 1 futures (chunks) ... DONE
[09:28:22.903] Reducing values from 1 chunks ...
[09:28:22.903]  - Number of values collected after concatenation: 3
[09:28:22.903]  - Number of values expected: 3
[09:28:22.903] Reducing values from 1 chunks ... DONE
[09:28:22.903] future_lapply() ... DONE
[09:28:22.903] future_by_internal() ... DONE
[09:28:22.907] future_by_internal() ...
[09:28:22.907] future_lapply() ...
[09:28:22.908] Number of chunks: 1
[09:28:22.908] getGlobalsAndPackagesXApply() ...
[09:28:22.908]  - future.globals: TRUE
[09:28:22.908] getGlobalsAndPackages() ...
[09:28:22.908] Searching for globals...
[09:28:22.910] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:22.910] Searching for globals ... DONE
[09:28:22.910] Resolving globals: FALSE
[09:28:22.911] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[09:28:22.911] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[09:28:22.911] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:22.911] - packages: [1] ‘stats’
[09:28:22.911] getGlobalsAndPackages() ... DONE
[09:28:22.911]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:22.911]  - needed namespaces: [n=1] ‘stats’
[09:28:22.911] Finding globals ... DONE
[09:28:22.912]  - use_args: TRUE
[09:28:22.912]  - Getting '...' globals ...
[09:28:22.912] resolve() on list ...
[09:28:22.912]  recursive: 0
[09:28:22.912]  length: 1
[09:28:22.912]  elements: ‘...’
[09:28:22.912]  length: 0 (resolved future 1)
[09:28:22.912] resolve() on list ... DONE
[09:28:22.912]    - '...' content: [n=0] 
[09:28:22.913] List of 1
[09:28:22.913]  $ ...: list()
[09:28:22.913]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.913]  - attr(*, "where")=List of 1
[09:28:22.913]   ..$ ...:<environment: 0x555b09d8c810> 
[09:28:22.913]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.913]  - attr(*, "resolved")= logi TRUE
[09:28:22.913]  - attr(*, "total_size")= num NA
[09:28:22.915]  - Getting '...' globals ... DONE
[09:28:22.915] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[09:28:22.915] List of 4
[09:28:22.915]  $ ...future.FUN:function (x)  
[09:28:22.915]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:22.915]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.915]  $ ...          : list()
[09:28:22.915]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.915]  - attr(*, "where")=List of 4
[09:28:22.915]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.915]   ..$ breaks       :<environment: R_EmptyEnv> 
[09:28:22.915]   ..$ wool         :<environment: R_EmptyEnv> 
[09:28:22.915]   ..$ ...          :<environment: 0x555b09d8c810> 
[09:28:22.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.915]  - attr(*, "resolved")= logi FALSE
[09:28:22.915]  - attr(*, "total_size")= num 2320
[09:28:22.920] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:22.920] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.920] Number of futures (= number of chunks): 1
[09:28:22.920] Launching 1 futures (chunks) ...
[09:28:22.920] Chunk #1 of 1 ...
[09:28:22.920]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.921] getGlobalsAndPackages() ...
[09:28:22.921] Searching for globals...
[09:28:22.921] 
[09:28:22.921] Searching for globals ... DONE
[09:28:22.921] - globals: [0] <none>
[09:28:22.921] getGlobalsAndPackages() ... DONE
[09:28:22.921]    + additional globals found: [n=0] 
[09:28:22.922]    + additional namespaces needed: [n=0] 
[09:28:22.922]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.922]  - seeds: <none>
[09:28:22.922]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.922] getGlobalsAndPackages() ...
[09:28:22.922] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.922] Resolving globals: FALSE
[09:28:22.922] Tweak future expression to call with '...' arguments ...
[09:28:22.922] {
[09:28:22.922]     do.call(function(...) {
[09:28:22.922]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.922]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.922]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.922]             on.exit(options(oopts), add = TRUE)
[09:28:22.922]         }
[09:28:22.922]         {
[09:28:22.922]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.922]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.922]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.922]             })
[09:28:22.922]         }
[09:28:22.922]     }, args = future.call.arguments)
[09:28:22.922] }
[09:28:22.923] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.923] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.923] 
[09:28:22.923] getGlobalsAndPackages() ... DONE
[09:28:22.923] run() for ‘Future’ ...
[09:28:22.923] - state: ‘created’
[09:28:22.924] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:22.924] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.924] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.924]   - Field: ‘label’
[09:28:22.924]   - Field: ‘local’
[09:28:22.924]   - Field: ‘owner’
[09:28:22.924]   - Field: ‘envir’
[09:28:22.924]   - Field: ‘packages’
[09:28:22.924]   - Field: ‘gc’
[09:28:22.925]   - Field: ‘conditions’
[09:28:22.925]   - Field: ‘expr’
[09:28:22.925]   - Field: ‘uuid’
[09:28:22.925]   - Field: ‘seed’
[09:28:22.925]   - Field: ‘version’
[09:28:22.925]   - Field: ‘result’
[09:28:22.925]   - Field: ‘asynchronous’
[09:28:22.925]   - Field: ‘calls’
[09:28:22.925]   - Field: ‘globals’
[09:28:22.925]   - Field: ‘stdout’
[09:28:22.925]   - Field: ‘earlySignal’
[09:28:22.925]   - Field: ‘lazy’
[09:28:22.926]   - Field: ‘state’
[09:28:22.926] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.926] - Launch lazy future ...
[09:28:22.926] Packages needed by the future expression (n = 1): ‘stats’
[09:28:22.926] Packages needed by future strategies (n = 0): <none>
[09:28:22.926] {
[09:28:22.926]     {
[09:28:22.926]         {
[09:28:22.926]             ...future.startTime <- base::Sys.time()
[09:28:22.926]             {
[09:28:22.926]                 {
[09:28:22.926]                   {
[09:28:22.926]                     {
[09:28:22.926]                       base::local({
[09:28:22.926]                         has_future <- base::requireNamespace("future", 
[09:28:22.926]                           quietly = TRUE)
[09:28:22.926]                         if (has_future) {
[09:28:22.926]                           ns <- base::getNamespace("future")
[09:28:22.926]                           version <- ns[[".package"]][["version"]]
[09:28:22.926]                           if (is.null(version)) 
[09:28:22.926]                             version <- utils::packageVersion("future")
[09:28:22.926]                         }
[09:28:22.926]                         else {
[09:28:22.926]                           version <- NULL
[09:28:22.926]                         }
[09:28:22.926]                         if (!has_future || version < "1.8.0") {
[09:28:22.926]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.926]                             "", base::R.version$version.string), 
[09:28:22.926]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:22.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.926]                               "release", "version")], collapse = " "), 
[09:28:22.926]                             hostname = base::Sys.info()[["nodename"]])
[09:28:22.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.926]                             info)
[09:28:22.926]                           info <- base::paste(info, collapse = "; ")
[09:28:22.926]                           if (!has_future) {
[09:28:22.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.926]                               info)
[09:28:22.926]                           }
[09:28:22.926]                           else {
[09:28:22.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.926]                               info, version)
[09:28:22.926]                           }
[09:28:22.926]                           base::stop(msg)
[09:28:22.926]                         }
[09:28:22.926]                       })
[09:28:22.926]                     }
[09:28:22.926]                     base::local({
[09:28:22.926]                       for (pkg in "stats") {
[09:28:22.926]                         base::loadNamespace(pkg)
[09:28:22.926]                         base::library(pkg, character.only = TRUE)
[09:28:22.926]                       }
[09:28:22.926]                     })
[09:28:22.926]                   }
[09:28:22.926]                   ...future.strategy.old <- future::plan("list")
[09:28:22.926]                   options(future.plan = NULL)
[09:28:22.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.926]                 }
[09:28:22.926]                 ...future.workdir <- getwd()
[09:28:22.926]             }
[09:28:22.926]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.926]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.926]         }
[09:28:22.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.926]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.926]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.926]             base::names(...future.oldOptions))
[09:28:22.926]     }
[09:28:22.926]     if (FALSE) {
[09:28:22.926]     }
[09:28:22.926]     else {
[09:28:22.926]         if (TRUE) {
[09:28:22.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.926]                 open = "w")
[09:28:22.926]         }
[09:28:22.926]         else {
[09:28:22.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.926]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.926]         }
[09:28:22.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.926]             base::sink(type = "output", split = FALSE)
[09:28:22.926]             base::close(...future.stdout)
[09:28:22.926]         }, add = TRUE)
[09:28:22.926]     }
[09:28:22.926]     ...future.frame <- base::sys.nframe()
[09:28:22.926]     ...future.conditions <- base::list()
[09:28:22.926]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.926]     if (FALSE) {
[09:28:22.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.926]     }
[09:28:22.926]     ...future.result <- base::tryCatch({
[09:28:22.926]         base::withCallingHandlers({
[09:28:22.926]             ...future.value <- base::withVisible(base::local({
[09:28:22.926]                 do.call(function(...) {
[09:28:22.926]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.926]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.926]                     ...future.globals.maxSize)) {
[09:28:22.926]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.926]                     on.exit(options(oopts), add = TRUE)
[09:28:22.926]                   }
[09:28:22.926]                   {
[09:28:22.926]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.926]                       FUN = function(jj) {
[09:28:22.926]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.926]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.926]                       })
[09:28:22.926]                   }
[09:28:22.926]                 }, args = future.call.arguments)
[09:28:22.926]             }))
[09:28:22.926]             future::FutureResult(value = ...future.value$value, 
[09:28:22.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.926]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.926]                     ...future.globalenv.names))
[09:28:22.926]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.926]         }, condition = base::local({
[09:28:22.926]             c <- base::c
[09:28:22.926]             inherits <- base::inherits
[09:28:22.926]             invokeRestart <- base::invokeRestart
[09:28:22.926]             length <- base::length
[09:28:22.926]             list <- base::list
[09:28:22.926]             seq.int <- base::seq.int
[09:28:22.926]             signalCondition <- base::signalCondition
[09:28:22.926]             sys.calls <- base::sys.calls
[09:28:22.926]             `[[` <- base::`[[`
[09:28:22.926]             `+` <- base::`+`
[09:28:22.926]             `<<-` <- base::`<<-`
[09:28:22.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.926]                   3L)]
[09:28:22.926]             }
[09:28:22.926]             function(cond) {
[09:28:22.926]                 is_error <- inherits(cond, "error")
[09:28:22.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.926]                   NULL)
[09:28:22.926]                 if (is_error) {
[09:28:22.926]                   sessionInformation <- function() {
[09:28:22.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.926]                       search = base::search(), system = base::Sys.info())
[09:28:22.926]                   }
[09:28:22.926]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.926]                     cond$call), session = sessionInformation(), 
[09:28:22.926]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.926]                   signalCondition(cond)
[09:28:22.926]                 }
[09:28:22.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.926]                 "immediateCondition"))) {
[09:28:22.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.926]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.926]                   if (TRUE && !signal) {
[09:28:22.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.926]                     {
[09:28:22.926]                       inherits <- base::inherits
[09:28:22.926]                       invokeRestart <- base::invokeRestart
[09:28:22.926]                       is.null <- base::is.null
[09:28:22.926]                       muffled <- FALSE
[09:28:22.926]                       if (inherits(cond, "message")) {
[09:28:22.926]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.926]                         if (muffled) 
[09:28:22.926]                           invokeRestart("muffleMessage")
[09:28:22.926]                       }
[09:28:22.926]                       else if (inherits(cond, "warning")) {
[09:28:22.926]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.926]                         if (muffled) 
[09:28:22.926]                           invokeRestart("muffleWarning")
[09:28:22.926]                       }
[09:28:22.926]                       else if (inherits(cond, "condition")) {
[09:28:22.926]                         if (!is.null(pattern)) {
[09:28:22.926]                           computeRestarts <- base::computeRestarts
[09:28:22.926]                           grepl <- base::grepl
[09:28:22.926]                           restarts <- computeRestarts(cond)
[09:28:22.926]                           for (restart in restarts) {
[09:28:22.926]                             name <- restart$name
[09:28:22.926]                             if (is.null(name)) 
[09:28:22.926]                               next
[09:28:22.926]                             if (!grepl(pattern, name)) 
[09:28:22.926]                               next
[09:28:22.926]                             invokeRestart(restart)
[09:28:22.926]                             muffled <- TRUE
[09:28:22.926]                             break
[09:28:22.926]                           }
[09:28:22.926]                         }
[09:28:22.926]                       }
[09:28:22.926]                       invisible(muffled)
[09:28:22.926]                     }
[09:28:22.926]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.926]                   }
[09:28:22.926]                 }
[09:28:22.926]                 else {
[09:28:22.926]                   if (TRUE) {
[09:28:22.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.926]                     {
[09:28:22.926]                       inherits <- base::inherits
[09:28:22.926]                       invokeRestart <- base::invokeRestart
[09:28:22.926]                       is.null <- base::is.null
[09:28:22.926]                       muffled <- FALSE
[09:28:22.926]                       if (inherits(cond, "message")) {
[09:28:22.926]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.926]                         if (muffled) 
[09:28:22.926]                           invokeRestart("muffleMessage")
[09:28:22.926]                       }
[09:28:22.926]                       else if (inherits(cond, "warning")) {
[09:28:22.926]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.926]                         if (muffled) 
[09:28:22.926]                           invokeRestart("muffleWarning")
[09:28:22.926]                       }
[09:28:22.926]                       else if (inherits(cond, "condition")) {
[09:28:22.926]                         if (!is.null(pattern)) {
[09:28:22.926]                           computeRestarts <- base::computeRestarts
[09:28:22.926]                           grepl <- base::grepl
[09:28:22.926]                           restarts <- computeRestarts(cond)
[09:28:22.926]                           for (restart in restarts) {
[09:28:22.926]                             name <- restart$name
[09:28:22.926]                             if (is.null(name)) 
[09:28:22.926]                               next
[09:28:22.926]                             if (!grepl(pattern, name)) 
[09:28:22.926]                               next
[09:28:22.926]                             invokeRestart(restart)
[09:28:22.926]                             muffled <- TRUE
[09:28:22.926]                             break
[09:28:22.926]                           }
[09:28:22.926]                         }
[09:28:22.926]                       }
[09:28:22.926]                       invisible(muffled)
[09:28:22.926]                     }
[09:28:22.926]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.926]                   }
[09:28:22.926]                 }
[09:28:22.926]             }
[09:28:22.926]         }))
[09:28:22.926]     }, error = function(ex) {
[09:28:22.926]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.926]                 ...future.rng), started = ...future.startTime, 
[09:28:22.926]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.926]             version = "1.8"), class = "FutureResult")
[09:28:22.926]     }, finally = {
[09:28:22.926]         if (!identical(...future.workdir, getwd())) 
[09:28:22.926]             setwd(...future.workdir)
[09:28:22.926]         {
[09:28:22.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.926]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.926]             }
[09:28:22.926]             base::options(...future.oldOptions)
[09:28:22.926]             if (.Platform$OS.type == "windows") {
[09:28:22.926]                 old_names <- names(...future.oldEnvVars)
[09:28:22.926]                 envs <- base::Sys.getenv()
[09:28:22.926]                 names <- names(envs)
[09:28:22.926]                 common <- intersect(names, old_names)
[09:28:22.926]                 added <- setdiff(names, old_names)
[09:28:22.926]                 removed <- setdiff(old_names, names)
[09:28:22.926]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.926]                   envs[common]]
[09:28:22.926]                 NAMES <- toupper(changed)
[09:28:22.926]                 args <- list()
[09:28:22.926]                 for (kk in seq_along(NAMES)) {
[09:28:22.926]                   name <- changed[[kk]]
[09:28:22.926]                   NAME <- NAMES[[kk]]
[09:28:22.926]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.926]                     next
[09:28:22.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.926]                 }
[09:28:22.926]                 NAMES <- toupper(added)
[09:28:22.926]                 for (kk in seq_along(NAMES)) {
[09:28:22.926]                   name <- added[[kk]]
[09:28:22.926]                   NAME <- NAMES[[kk]]
[09:28:22.926]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.926]                     next
[09:28:22.926]                   args[[name]] <- ""
[09:28:22.926]                 }
[09:28:22.926]                 NAMES <- toupper(removed)
[09:28:22.926]                 for (kk in seq_along(NAMES)) {
[09:28:22.926]                   name <- removed[[kk]]
[09:28:22.926]                   NAME <- NAMES[[kk]]
[09:28:22.926]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.926]                     next
[09:28:22.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.926]                 }
[09:28:22.926]                 if (length(args) > 0) 
[09:28:22.926]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.926]             }
[09:28:22.926]             else {
[09:28:22.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.926]             }
[09:28:22.926]             {
[09:28:22.926]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.926]                   0L) {
[09:28:22.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.926]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.926]                   base::options(opts)
[09:28:22.926]                 }
[09:28:22.926]                 {
[09:28:22.926]                   {
[09:28:22.926]                     NULL
[09:28:22.926]                     RNGkind("Mersenne-Twister")
[09:28:22.926]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.926]                       inherits = FALSE)
[09:28:22.926]                   }
[09:28:22.926]                   options(future.plan = NULL)
[09:28:22.926]                   if (is.na(NA_character_)) 
[09:28:22.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.926]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.926]                     .init = FALSE)
[09:28:22.926]                 }
[09:28:22.926]             }
[09:28:22.926]         }
[09:28:22.926]     })
[09:28:22.926]     if (TRUE) {
[09:28:22.926]         base::sink(type = "output", split = FALSE)
[09:28:22.926]         if (TRUE) {
[09:28:22.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.926]         }
[09:28:22.926]         else {
[09:28:22.926]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.926]         }
[09:28:22.926]         base::close(...future.stdout)
[09:28:22.926]         ...future.stdout <- NULL
[09:28:22.926]     }
[09:28:22.926]     ...future.result$conditions <- ...future.conditions
[09:28:22.926]     ...future.result$finished <- base::Sys.time()
[09:28:22.926]     ...future.result
[09:28:22.926] }
[09:28:22.928] assign_globals() ...
[09:28:22.928] List of 7
[09:28:22.928]  $ ...future.FUN            :function (x)  
[09:28:22.928]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:22.928]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.928]  $ future.call.arguments    : list()
[09:28:22.928]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.928]  $ ...future.elements_ii    :List of 3
[09:28:22.928]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.928]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.928]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.928]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.928]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.928]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.928]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.928]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.928]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.928]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.928]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.928]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.928]  $ ...future.seeds_ii       : NULL
[09:28:22.928]  $ ...future.globals.maxSize: NULL
[09:28:22.928]  - attr(*, "where")=List of 7
[09:28:22.928]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.928]   ..$ breaks                   :<environment: R_EmptyEnv> 
[09:28:22.928]   ..$ wool                     :<environment: R_EmptyEnv> 
[09:28:22.928]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.928]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.928]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.928]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.928]  - attr(*, "resolved")= logi FALSE
[09:28:22.928]  - attr(*, "total_size")= num 2320
[09:28:22.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.928]  - attr(*, "already-done")= logi TRUE
[09:28:22.938] - reassign environment for ‘...future.FUN’
[09:28:22.938] - copied ‘...future.FUN’ to environment
[09:28:22.938] - copied ‘breaks’ to environment
[09:28:22.938] - copied ‘wool’ to environment
[09:28:22.938] - copied ‘future.call.arguments’ to environment
[09:28:22.939] - copied ‘...future.elements_ii’ to environment
[09:28:22.939] - copied ‘...future.seeds_ii’ to environment
[09:28:22.939] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.939] assign_globals() ... done
[09:28:22.939] plan(): Setting new future strategy stack:
[09:28:22.939] List of future strategies:
[09:28:22.939] 1. sequential:
[09:28:22.939]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.939]    - tweaked: FALSE
[09:28:22.939]    - call: NULL
[09:28:22.940] plan(): nbrOfWorkers() = 1
[09:28:22.942] plan(): Setting new future strategy stack:
[09:28:22.942] List of future strategies:
[09:28:22.942] 1. sequential:
[09:28:22.942]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.942]    - tweaked: FALSE
[09:28:22.942]    - call: plan(strategy)
[09:28:22.943] plan(): nbrOfWorkers() = 1
[09:28:22.943] SequentialFuture started (and completed)
[09:28:22.943] - Launch lazy future ... done
[09:28:22.943] run() for ‘SequentialFuture’ ... done
[09:28:22.943] Created future:
[09:28:22.943] SequentialFuture:
[09:28:22.943] Label: ‘future_by-1’
[09:28:22.943] Expression:
[09:28:22.943] {
[09:28:22.943]     do.call(function(...) {
[09:28:22.943]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.943]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.943]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.943]             on.exit(options(oopts), add = TRUE)
[09:28:22.943]         }
[09:28:22.943]         {
[09:28:22.943]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.943]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.943]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.943]             })
[09:28:22.943]         }
[09:28:22.943]     }, args = future.call.arguments)
[09:28:22.943] }
[09:28:22.943] Lazy evaluation: FALSE
[09:28:22.943] Asynchronous evaluation: FALSE
[09:28:22.943] Local evaluation: TRUE
[09:28:22.943] Environment: 0x555b09d31718
[09:28:22.943] Capture standard output: TRUE
[09:28:22.943] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.943] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[09:28:22.943] Packages: 1 packages (‘stats’)
[09:28:22.943] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.943] Resolved: TRUE
[09:28:22.943] Value: 25.57 KiB of class ‘list’
[09:28:22.943] Early signaling: FALSE
[09:28:22.943] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.943] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.945] Chunk #1 of 1 ... DONE
[09:28:22.945] Launching 1 futures (chunks) ... DONE
[09:28:22.945] Resolving 1 futures (chunks) ...
[09:28:22.945] resolve() on list ...
[09:28:22.945]  recursive: 0
[09:28:22.945]  length: 1
[09:28:22.945] 
[09:28:22.945] resolved() for ‘SequentialFuture’ ...
[09:28:22.945] - state: ‘finished’
[09:28:22.946] - run: TRUE
[09:28:22.946] - result: ‘FutureResult’
[09:28:22.946] resolved() for ‘SequentialFuture’ ... done
[09:28:22.946] Future #1
[09:28:22.946] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.946] - nx: 1
[09:28:22.946] - relay: TRUE
[09:28:22.946] - stdout: TRUE
[09:28:22.946] - signal: TRUE
[09:28:22.946] - resignal: FALSE
[09:28:22.946] - force: TRUE
[09:28:22.947] - relayed: [n=1] FALSE
[09:28:22.947] - queued futures: [n=1] FALSE
[09:28:22.947]  - until=1
[09:28:22.947]  - relaying element #1
[09:28:22.947] - relayed: [n=1] TRUE
[09:28:22.947] - queued futures: [n=1] TRUE
[09:28:22.947] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.947]  length: 0 (resolved future 1)
[09:28:22.947] Relaying remaining futures
[09:28:22.947] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.947] - nx: 1
[09:28:22.948] - relay: TRUE
[09:28:22.948] - stdout: TRUE
[09:28:22.948] - signal: TRUE
[09:28:22.948] - resignal: FALSE
[09:28:22.948] - force: TRUE
[09:28:22.948] - relayed: [n=1] TRUE
[09:28:22.948] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.948] - relayed: [n=1] TRUE
[09:28:22.948] - queued futures: [n=1] TRUE
[09:28:22.948] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.948] resolve() on list ... DONE
[09:28:22.949]  - Number of value chunks collected: 1
[09:28:22.949] Resolving 1 futures (chunks) ... DONE
[09:28:22.949] Reducing values from 1 chunks ...
[09:28:22.949]  - Number of values collected after concatenation: 3
[09:28:22.949]  - Number of values expected: 3
[09:28:22.949] Reducing values from 1 chunks ... DONE
[09:28:22.949] future_lapply() ... DONE
[09:28:22.949] future_by_internal() ... DONE
[09:28:22.949] future_by_internal() ...
[09:28:22.950] future_lapply() ...
[09:28:22.950] Number of chunks: 1
[09:28:22.950] getGlobalsAndPackagesXApply() ...
[09:28:22.950]  - future.globals: TRUE
[09:28:22.950] getGlobalsAndPackages() ...
[09:28:22.951] Searching for globals...
[09:28:22.951] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.952] Searching for globals ... DONE
[09:28:22.952] Resolving globals: FALSE
[09:28:22.952] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.952] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.952] - globals: [1] ‘FUN’
[09:28:22.953] 
[09:28:22.953] getGlobalsAndPackages() ... DONE
[09:28:22.953]  - globals found/used: [n=1] ‘FUN’
[09:28:22.953]  - needed namespaces: [n=0] 
[09:28:22.953] Finding globals ... DONE
[09:28:22.953]  - use_args: TRUE
[09:28:22.953]  - Getting '...' globals ...
[09:28:22.953] resolve() on list ...
[09:28:22.953]  recursive: 0
[09:28:22.953]  length: 1
[09:28:22.954]  elements: ‘...’
[09:28:22.954]  length: 0 (resolved future 1)
[09:28:22.954] resolve() on list ... DONE
[09:28:22.954]    - '...' content: [n=0] 
[09:28:22.954] List of 1
[09:28:22.954]  $ ...: list()
[09:28:22.954]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.954]  - attr(*, "where")=List of 1
[09:28:22.954]   ..$ ...:<environment: 0x555b0a3d36d0> 
[09:28:22.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.954]  - attr(*, "resolved")= logi TRUE
[09:28:22.954]  - attr(*, "total_size")= num NA
[09:28:22.957]  - Getting '...' globals ... DONE
[09:28:22.957] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.957] List of 2
[09:28:22.957]  $ ...future.FUN:function (object, ...)  
[09:28:22.957]  $ ...          : list()
[09:28:22.957]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.957]  - attr(*, "where")=List of 2
[09:28:22.957]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.957]   ..$ ...          :<environment: 0x555b0a3d36d0> 
[09:28:22.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.957]  - attr(*, "resolved")= logi FALSE
[09:28:22.957]  - attr(*, "total_size")= num 1240
[09:28:22.960] Packages to be attached in all futures: [n=0] 
[09:28:22.960] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.960] Number of futures (= number of chunks): 1
[09:28:22.960] Launching 1 futures (chunks) ...
[09:28:22.961] Chunk #1 of 1 ...
[09:28:22.961]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.961] getGlobalsAndPackages() ...
[09:28:22.961] Searching for globals...
[09:28:22.961] 
[09:28:22.961] Searching for globals ... DONE
[09:28:22.961] - globals: [0] <none>
[09:28:22.961] getGlobalsAndPackages() ... DONE
[09:28:22.962]    + additional globals found: [n=0] 
[09:28:22.962]    + additional namespaces needed: [n=0] 
[09:28:22.962]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:22.962]  - seeds: <none>
[09:28:22.962]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.962] getGlobalsAndPackages() ...
[09:28:22.962] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.962] Resolving globals: FALSE
[09:28:22.962] Tweak future expression to call with '...' arguments ...
[09:28:22.962] {
[09:28:22.962]     do.call(function(...) {
[09:28:22.962]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.962]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.962]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.962]             on.exit(options(oopts), add = TRUE)
[09:28:22.962]         }
[09:28:22.962]         {
[09:28:22.962]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.962]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.962]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.962]             })
[09:28:22.962]         }
[09:28:22.962]     }, args = future.call.arguments)
[09:28:22.962] }
[09:28:22.963] Tweak future expression to call with '...' arguments ... DONE
[09:28:22.963] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:22.963] 
[09:28:22.963] getGlobalsAndPackages() ... DONE
[09:28:22.963] run() for ‘Future’ ...
[09:28:22.963] - state: ‘created’
[09:28:22.964] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:22.964] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:22.964]   - Field: ‘label’
[09:28:22.964]   - Field: ‘local’
[09:28:22.964]   - Field: ‘owner’
[09:28:22.964]   - Field: ‘envir’
[09:28:22.964]   - Field: ‘packages’
[09:28:22.964]   - Field: ‘gc’
[09:28:22.965]   - Field: ‘conditions’
[09:28:22.965]   - Field: ‘expr’
[09:28:22.965]   - Field: ‘uuid’
[09:28:22.965]   - Field: ‘seed’
[09:28:22.965]   - Field: ‘version’
[09:28:22.965]   - Field: ‘result’
[09:28:22.965]   - Field: ‘asynchronous’
[09:28:22.965]   - Field: ‘calls’
[09:28:22.965]   - Field: ‘globals’
[09:28:22.965]   - Field: ‘stdout’
[09:28:22.965]   - Field: ‘earlySignal’
[09:28:22.965]   - Field: ‘lazy’
[09:28:22.966]   - Field: ‘state’
[09:28:22.966] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:22.966] - Launch lazy future ...
[09:28:22.966] Packages needed by the future expression (n = 0): <none>
[09:28:22.966] Packages needed by future strategies (n = 0): <none>
[09:28:22.966] {
[09:28:22.966]     {
[09:28:22.966]         {
[09:28:22.966]             ...future.startTime <- base::Sys.time()
[09:28:22.966]             {
[09:28:22.966]                 {
[09:28:22.966]                   {
[09:28:22.966]                     base::local({
[09:28:22.966]                       has_future <- base::requireNamespace("future", 
[09:28:22.966]                         quietly = TRUE)
[09:28:22.966]                       if (has_future) {
[09:28:22.966]                         ns <- base::getNamespace("future")
[09:28:22.966]                         version <- ns[[".package"]][["version"]]
[09:28:22.966]                         if (is.null(version)) 
[09:28:22.966]                           version <- utils::packageVersion("future")
[09:28:22.966]                       }
[09:28:22.966]                       else {
[09:28:22.966]                         version <- NULL
[09:28:22.966]                       }
[09:28:22.966]                       if (!has_future || version < "1.8.0") {
[09:28:22.966]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:22.966]                           "", base::R.version$version.string), 
[09:28:22.966]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:22.966]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:22.966]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:22.966]                             "release", "version")], collapse = " "), 
[09:28:22.966]                           hostname = base::Sys.info()[["nodename"]])
[09:28:22.966]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:22.966]                           info)
[09:28:22.966]                         info <- base::paste(info, collapse = "; ")
[09:28:22.966]                         if (!has_future) {
[09:28:22.966]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:22.966]                             info)
[09:28:22.966]                         }
[09:28:22.966]                         else {
[09:28:22.966]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:22.966]                             info, version)
[09:28:22.966]                         }
[09:28:22.966]                         base::stop(msg)
[09:28:22.966]                       }
[09:28:22.966]                     })
[09:28:22.966]                   }
[09:28:22.966]                   ...future.strategy.old <- future::plan("list")
[09:28:22.966]                   options(future.plan = NULL)
[09:28:22.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:22.966]                 }
[09:28:22.966]                 ...future.workdir <- getwd()
[09:28:22.966]             }
[09:28:22.966]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:22.966]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:22.966]         }
[09:28:22.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:22.966]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:22.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:22.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:22.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:22.966]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:22.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:22.966]             base::names(...future.oldOptions))
[09:28:22.966]     }
[09:28:22.966]     if (FALSE) {
[09:28:22.966]     }
[09:28:22.966]     else {
[09:28:22.966]         if (TRUE) {
[09:28:22.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:22.966]                 open = "w")
[09:28:22.966]         }
[09:28:22.966]         else {
[09:28:22.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:22.966]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:22.966]         }
[09:28:22.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:22.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:22.966]             base::sink(type = "output", split = FALSE)
[09:28:22.966]             base::close(...future.stdout)
[09:28:22.966]         }, add = TRUE)
[09:28:22.966]     }
[09:28:22.966]     ...future.frame <- base::sys.nframe()
[09:28:22.966]     ...future.conditions <- base::list()
[09:28:22.966]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:22.966]     if (FALSE) {
[09:28:22.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:22.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:22.966]     }
[09:28:22.966]     ...future.result <- base::tryCatch({
[09:28:22.966]         base::withCallingHandlers({
[09:28:22.966]             ...future.value <- base::withVisible(base::local({
[09:28:22.966]                 do.call(function(...) {
[09:28:22.966]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.966]                   if (!identical(...future.globals.maxSize.org, 
[09:28:22.966]                     ...future.globals.maxSize)) {
[09:28:22.966]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.966]                     on.exit(options(oopts), add = TRUE)
[09:28:22.966]                   }
[09:28:22.966]                   {
[09:28:22.966]                     lapply(seq_along(...future.elements_ii), 
[09:28:22.966]                       FUN = function(jj) {
[09:28:22.966]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.966]                         ...future.FUN(...future.X_jj, ...)
[09:28:22.966]                       })
[09:28:22.966]                   }
[09:28:22.966]                 }, args = future.call.arguments)
[09:28:22.966]             }))
[09:28:22.966]             future::FutureResult(value = ...future.value$value, 
[09:28:22.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.966]                   ...future.rng), globalenv = if (FALSE) 
[09:28:22.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:22.966]                     ...future.globalenv.names))
[09:28:22.966]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:22.966]         }, condition = base::local({
[09:28:22.966]             c <- base::c
[09:28:22.966]             inherits <- base::inherits
[09:28:22.966]             invokeRestart <- base::invokeRestart
[09:28:22.966]             length <- base::length
[09:28:22.966]             list <- base::list
[09:28:22.966]             seq.int <- base::seq.int
[09:28:22.966]             signalCondition <- base::signalCondition
[09:28:22.966]             sys.calls <- base::sys.calls
[09:28:22.966]             `[[` <- base::`[[`
[09:28:22.966]             `+` <- base::`+`
[09:28:22.966]             `<<-` <- base::`<<-`
[09:28:22.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:22.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:22.966]                   3L)]
[09:28:22.966]             }
[09:28:22.966]             function(cond) {
[09:28:22.966]                 is_error <- inherits(cond, "error")
[09:28:22.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:22.966]                   NULL)
[09:28:22.966]                 if (is_error) {
[09:28:22.966]                   sessionInformation <- function() {
[09:28:22.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:22.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:22.966]                       search = base::search(), system = base::Sys.info())
[09:28:22.966]                   }
[09:28:22.966]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:22.966]                     cond$call), session = sessionInformation(), 
[09:28:22.966]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:22.966]                   signalCondition(cond)
[09:28:22.966]                 }
[09:28:22.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:22.966]                 "immediateCondition"))) {
[09:28:22.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:22.966]                   ...future.conditions[[length(...future.conditions) + 
[09:28:22.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:22.966]                   if (TRUE && !signal) {
[09:28:22.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.966]                     {
[09:28:22.966]                       inherits <- base::inherits
[09:28:22.966]                       invokeRestart <- base::invokeRestart
[09:28:22.966]                       is.null <- base::is.null
[09:28:22.966]                       muffled <- FALSE
[09:28:22.966]                       if (inherits(cond, "message")) {
[09:28:22.966]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.966]                         if (muffled) 
[09:28:22.966]                           invokeRestart("muffleMessage")
[09:28:22.966]                       }
[09:28:22.966]                       else if (inherits(cond, "warning")) {
[09:28:22.966]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.966]                         if (muffled) 
[09:28:22.966]                           invokeRestart("muffleWarning")
[09:28:22.966]                       }
[09:28:22.966]                       else if (inherits(cond, "condition")) {
[09:28:22.966]                         if (!is.null(pattern)) {
[09:28:22.966]                           computeRestarts <- base::computeRestarts
[09:28:22.966]                           grepl <- base::grepl
[09:28:22.966]                           restarts <- computeRestarts(cond)
[09:28:22.966]                           for (restart in restarts) {
[09:28:22.966]                             name <- restart$name
[09:28:22.966]                             if (is.null(name)) 
[09:28:22.966]                               next
[09:28:22.966]                             if (!grepl(pattern, name)) 
[09:28:22.966]                               next
[09:28:22.966]                             invokeRestart(restart)
[09:28:22.966]                             muffled <- TRUE
[09:28:22.966]                             break
[09:28:22.966]                           }
[09:28:22.966]                         }
[09:28:22.966]                       }
[09:28:22.966]                       invisible(muffled)
[09:28:22.966]                     }
[09:28:22.966]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.966]                   }
[09:28:22.966]                 }
[09:28:22.966]                 else {
[09:28:22.966]                   if (TRUE) {
[09:28:22.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:22.966]                     {
[09:28:22.966]                       inherits <- base::inherits
[09:28:22.966]                       invokeRestart <- base::invokeRestart
[09:28:22.966]                       is.null <- base::is.null
[09:28:22.966]                       muffled <- FALSE
[09:28:22.966]                       if (inherits(cond, "message")) {
[09:28:22.966]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:22.966]                         if (muffled) 
[09:28:22.966]                           invokeRestart("muffleMessage")
[09:28:22.966]                       }
[09:28:22.966]                       else if (inherits(cond, "warning")) {
[09:28:22.966]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:22.966]                         if (muffled) 
[09:28:22.966]                           invokeRestart("muffleWarning")
[09:28:22.966]                       }
[09:28:22.966]                       else if (inherits(cond, "condition")) {
[09:28:22.966]                         if (!is.null(pattern)) {
[09:28:22.966]                           computeRestarts <- base::computeRestarts
[09:28:22.966]                           grepl <- base::grepl
[09:28:22.966]                           restarts <- computeRestarts(cond)
[09:28:22.966]                           for (restart in restarts) {
[09:28:22.966]                             name <- restart$name
[09:28:22.966]                             if (is.null(name)) 
[09:28:22.966]                               next
[09:28:22.966]                             if (!grepl(pattern, name)) 
[09:28:22.966]                               next
[09:28:22.966]                             invokeRestart(restart)
[09:28:22.966]                             muffled <- TRUE
[09:28:22.966]                             break
[09:28:22.966]                           }
[09:28:22.966]                         }
[09:28:22.966]                       }
[09:28:22.966]                       invisible(muffled)
[09:28:22.966]                     }
[09:28:22.966]                     muffleCondition(cond, pattern = "^muffle")
[09:28:22.966]                   }
[09:28:22.966]                 }
[09:28:22.966]             }
[09:28:22.966]         }))
[09:28:22.966]     }, error = function(ex) {
[09:28:22.966]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:22.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:22.966]                 ...future.rng), started = ...future.startTime, 
[09:28:22.966]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:22.966]             version = "1.8"), class = "FutureResult")
[09:28:22.966]     }, finally = {
[09:28:22.966]         if (!identical(...future.workdir, getwd())) 
[09:28:22.966]             setwd(...future.workdir)
[09:28:22.966]         {
[09:28:22.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:22.966]                 ...future.oldOptions$nwarnings <- NULL
[09:28:22.966]             }
[09:28:22.966]             base::options(...future.oldOptions)
[09:28:22.966]             if (.Platform$OS.type == "windows") {
[09:28:22.966]                 old_names <- names(...future.oldEnvVars)
[09:28:22.966]                 envs <- base::Sys.getenv()
[09:28:22.966]                 names <- names(envs)
[09:28:22.966]                 common <- intersect(names, old_names)
[09:28:22.966]                 added <- setdiff(names, old_names)
[09:28:22.966]                 removed <- setdiff(old_names, names)
[09:28:22.966]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:22.966]                   envs[common]]
[09:28:22.966]                 NAMES <- toupper(changed)
[09:28:22.966]                 args <- list()
[09:28:22.966]                 for (kk in seq_along(NAMES)) {
[09:28:22.966]                   name <- changed[[kk]]
[09:28:22.966]                   NAME <- NAMES[[kk]]
[09:28:22.966]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.966]                     next
[09:28:22.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.966]                 }
[09:28:22.966]                 NAMES <- toupper(added)
[09:28:22.966]                 for (kk in seq_along(NAMES)) {
[09:28:22.966]                   name <- added[[kk]]
[09:28:22.966]                   NAME <- NAMES[[kk]]
[09:28:22.966]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.966]                     next
[09:28:22.966]                   args[[name]] <- ""
[09:28:22.966]                 }
[09:28:22.966]                 NAMES <- toupper(removed)
[09:28:22.966]                 for (kk in seq_along(NAMES)) {
[09:28:22.966]                   name <- removed[[kk]]
[09:28:22.966]                   NAME <- NAMES[[kk]]
[09:28:22.966]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:22.966]                     next
[09:28:22.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:22.966]                 }
[09:28:22.966]                 if (length(args) > 0) 
[09:28:22.966]                   base::do.call(base::Sys.setenv, args = args)
[09:28:22.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:22.966]             }
[09:28:22.966]             else {
[09:28:22.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:22.966]             }
[09:28:22.966]             {
[09:28:22.966]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:22.966]                   0L) {
[09:28:22.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:22.966]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:22.966]                   base::options(opts)
[09:28:22.966]                 }
[09:28:22.966]                 {
[09:28:22.966]                   {
[09:28:22.966]                     NULL
[09:28:22.966]                     RNGkind("Mersenne-Twister")
[09:28:22.966]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:22.966]                       inherits = FALSE)
[09:28:22.966]                   }
[09:28:22.966]                   options(future.plan = NULL)
[09:28:22.966]                   if (is.na(NA_character_)) 
[09:28:22.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:22.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:22.966]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:22.966]                     .init = FALSE)
[09:28:22.966]                 }
[09:28:22.966]             }
[09:28:22.966]         }
[09:28:22.966]     })
[09:28:22.966]     if (TRUE) {
[09:28:22.966]         base::sink(type = "output", split = FALSE)
[09:28:22.966]         if (TRUE) {
[09:28:22.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:22.966]         }
[09:28:22.966]         else {
[09:28:22.966]             ...future.result["stdout"] <- base::list(NULL)
[09:28:22.966]         }
[09:28:22.966]         base::close(...future.stdout)
[09:28:22.966]         ...future.stdout <- NULL
[09:28:22.966]     }
[09:28:22.966]     ...future.result$conditions <- ...future.conditions
[09:28:22.966]     ...future.result$finished <- base::Sys.time()
[09:28:22.966]     ...future.result
[09:28:22.966] }
[09:28:22.968] assign_globals() ...
[09:28:22.968] List of 5
[09:28:22.968]  $ ...future.FUN            :function (object, ...)  
[09:28:22.968]  $ future.call.arguments    : list()
[09:28:22.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.968]  $ ...future.elements_ii    :List of 3
[09:28:22.968]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.968]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:22.968]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.968]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:22.968]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.968]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:22.968]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.968]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:22.968]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:22.968]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:22.968]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:22.968]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:22.968]  $ ...future.seeds_ii       : NULL
[09:28:22.968]  $ ...future.globals.maxSize: NULL
[09:28:22.968]  - attr(*, "where")=List of 5
[09:28:22.968]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:22.968]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:22.968]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:22.968]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:22.968]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:22.968]  - attr(*, "resolved")= logi FALSE
[09:28:22.968]  - attr(*, "total_size")= num 1240
[09:28:22.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.968]  - attr(*, "already-done")= logi TRUE
[09:28:22.976] - copied ‘...future.FUN’ to environment
[09:28:22.977] - copied ‘future.call.arguments’ to environment
[09:28:22.977] - copied ‘...future.elements_ii’ to environment
[09:28:22.977] - copied ‘...future.seeds_ii’ to environment
[09:28:22.977] - copied ‘...future.globals.maxSize’ to environment
[09:28:22.977] assign_globals() ... done
[09:28:22.977] plan(): Setting new future strategy stack:
[09:28:22.978] List of future strategies:
[09:28:22.978] 1. sequential:
[09:28:22.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.978]    - tweaked: FALSE
[09:28:22.978]    - call: NULL
[09:28:22.978] plan(): nbrOfWorkers() = 1
[09:28:22.980] plan(): Setting new future strategy stack:
[09:28:22.980] List of future strategies:
[09:28:22.980] 1. sequential:
[09:28:22.980]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:22.980]    - tweaked: FALSE
[09:28:22.980]    - call: plan(strategy)
[09:28:22.981] plan(): nbrOfWorkers() = 1
[09:28:22.981] SequentialFuture started (and completed)
[09:28:22.981] - Launch lazy future ... done
[09:28:22.981] run() for ‘SequentialFuture’ ... done
[09:28:22.981] Created future:
[09:28:22.981] SequentialFuture:
[09:28:22.981] Label: ‘future_by-1’
[09:28:22.981] Expression:
[09:28:22.981] {
[09:28:22.981]     do.call(function(...) {
[09:28:22.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:22.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:22.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:22.981]             on.exit(options(oopts), add = TRUE)
[09:28:22.981]         }
[09:28:22.981]         {
[09:28:22.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:22.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:22.981]                 ...future.FUN(...future.X_jj, ...)
[09:28:22.981]             })
[09:28:22.981]         }
[09:28:22.981]     }, args = future.call.arguments)
[09:28:22.981] }
[09:28:22.981] Lazy evaluation: FALSE
[09:28:22.981] Asynchronous evaluation: FALSE
[09:28:22.981] Local evaluation: TRUE
[09:28:22.981] Environment: 0x555b0a387220
[09:28:22.981] Capture standard output: TRUE
[09:28:22.981] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:22.981] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:22.981] Packages: <none>
[09:28:22.981] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:22.981] Resolved: TRUE
[09:28:22.981] Value: 5.37 KiB of class ‘list’
[09:28:22.981] Early signaling: FALSE
[09:28:22.981] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:22.981] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:22.982] Chunk #1 of 1 ... DONE
[09:28:22.982] Launching 1 futures (chunks) ... DONE
[09:28:22.982] Resolving 1 futures (chunks) ...
[09:28:22.983] resolve() on list ...
[09:28:22.983]  recursive: 0
[09:28:22.983]  length: 1
[09:28:22.983] 
[09:28:22.983] resolved() for ‘SequentialFuture’ ...
[09:28:22.983] - state: ‘finished’
[09:28:22.983] - run: TRUE
[09:28:22.983] - result: ‘FutureResult’
[09:28:22.983] resolved() for ‘SequentialFuture’ ... done
[09:28:22.983] Future #1
[09:28:22.983] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:22.984] - nx: 1
[09:28:22.984] - relay: TRUE
[09:28:22.984] - stdout: TRUE
[09:28:22.984] - signal: TRUE
[09:28:22.984] - resignal: FALSE
[09:28:22.984] - force: TRUE
[09:28:22.984] - relayed: [n=1] FALSE
[09:28:22.984] - queued futures: [n=1] FALSE
[09:28:22.984]  - until=1
[09:28:22.984]  - relaying element #1
[09:28:22.984] - relayed: [n=1] TRUE
[09:28:22.985] - queued futures: [n=1] TRUE
[09:28:22.985] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:22.985]  length: 0 (resolved future 1)
[09:28:22.985] Relaying remaining futures
[09:28:22.985] signalConditionsASAP(NULL, pos=0) ...
[09:28:22.985] - nx: 1
[09:28:22.985] - relay: TRUE
[09:28:22.985] - stdout: TRUE
[09:28:22.985] - signal: TRUE
[09:28:22.985] - resignal: FALSE
[09:28:22.985] - force: TRUE
[09:28:22.985] - relayed: [n=1] TRUE
[09:28:22.985] - queued futures: [n=1] TRUE
 - flush all
[09:28:22.986] - relayed: [n=1] TRUE
[09:28:22.986] - queued futures: [n=1] TRUE
[09:28:22.986] signalConditionsASAP(NULL, pos=0) ... done
[09:28:22.986] resolve() on list ... DONE
[09:28:22.986]  - Number of value chunks collected: 1
[09:28:22.986] Resolving 1 futures (chunks) ... DONE
[09:28:22.986] Reducing values from 1 chunks ...
[09:28:22.986]  - Number of values collected after concatenation: 3
[09:28:22.986]  - Number of values expected: 3
[09:28:22.986] Reducing values from 1 chunks ... DONE
[09:28:22.986] future_lapply() ... DONE
[09:28:22.987] future_by_internal() ... DONE
[09:28:22.987] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[09:28:22.988] future_lapply() ...
[09:28:22.988] Number of chunks: 1
[09:28:22.988] getGlobalsAndPackagesXApply() ...
[09:28:22.988]  - future.globals: TRUE
[09:28:22.988] getGlobalsAndPackages() ...
[09:28:22.988] Searching for globals...
[09:28:22.989] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:22.989] Searching for globals ... DONE
[09:28:22.990] Resolving globals: FALSE
[09:28:22.990] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:22.990] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:22.990] - globals: [1] ‘FUN’
[09:28:22.990] 
[09:28:22.990] getGlobalsAndPackages() ... DONE
[09:28:22.991]  - globals found/used: [n=1] ‘FUN’
[09:28:22.991]  - needed namespaces: [n=0] 
[09:28:22.991] Finding globals ... DONE
[09:28:22.991]  - use_args: TRUE
[09:28:22.991]  - Getting '...' globals ...
[09:28:22.991] resolve() on list ...
[09:28:22.991]  recursive: 0
[09:28:22.991]  length: 1
[09:28:22.991]  elements: ‘...’
[09:28:22.992]  length: 0 (resolved future 1)
[09:28:22.992] resolve() on list ... DONE
[09:28:22.992]    - '...' content: [n=0] 
[09:28:22.992] List of 1
[09:28:22.992]  $ ...: list()
[09:28:22.992]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.992]  - attr(*, "where")=List of 1
[09:28:22.992]   ..$ ...:<environment: 0x555b0a186bf0> 
[09:28:22.992]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.992]  - attr(*, "resolved")= logi TRUE
[09:28:22.992]  - attr(*, "total_size")= num NA
[09:28:22.994]  - Getting '...' globals ... DONE
[09:28:22.994] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:22.994] List of 2
[09:28:22.994]  $ ...future.FUN:function (object, ...)  
[09:28:22.994]  $ ...          : list()
[09:28:22.994]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:22.994]  - attr(*, "where")=List of 2
[09:28:22.994]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:22.994]   ..$ ...          :<environment: 0x555b0a186bf0> 
[09:28:22.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:22.994]  - attr(*, "resolved")= logi FALSE
[09:28:22.994]  - attr(*, "total_size")= num 1240
[09:28:22.998] Packages to be attached in all futures: [n=0] 
[09:28:22.998] getGlobalsAndPackagesXApply() ... DONE
[09:28:22.998] Number of futures (= number of chunks): 1
[09:28:22.998] Launching 1 futures (chunks) ...
[09:28:22.998] Chunk #1 of 1 ...
[09:28:22.998]  - Finding globals in 'X' for chunk #1 ...
[09:28:22.998] getGlobalsAndPackages() ...
[09:28:22.999] Searching for globals...
[09:28:22.999] 
[09:28:22.999] Searching for globals ... DONE
[09:28:22.999] - globals: [0] <none>
[09:28:22.999] getGlobalsAndPackages() ... DONE
[09:28:22.999]    + additional globals found: [n=0] 
[09:28:22.999]    + additional namespaces needed: [n=0] 
[09:28:23.000]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:23.000]  - seeds: <none>
[09:28:23.000]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.000] getGlobalsAndPackages() ...
[09:28:23.000] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.000] Resolving globals: FALSE
[09:28:23.000] Tweak future expression to call with '...' arguments ...
[09:28:23.000] {
[09:28:23.000]     do.call(function(...) {
[09:28:23.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.000]             on.exit(options(oopts), add = TRUE)
[09:28:23.000]         }
[09:28:23.000]         {
[09:28:23.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.000]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.000]             })
[09:28:23.000]         }
[09:28:23.000]     }, args = future.call.arguments)
[09:28:23.000] }
[09:28:23.000] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.001] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.001] 
[09:28:23.001] getGlobalsAndPackages() ... DONE
[09:28:23.001] run() for ‘Future’ ...
[09:28:23.001] - state: ‘created’
[09:28:23.001] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:28:23.002] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:23.002] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:28:23.002]   - Field: ‘label’
[09:28:23.002]   - Field: ‘local’
[09:28:23.002]   - Field: ‘owner’
[09:28:23.002]   - Field: ‘envir’
[09:28:23.002]   - Field: ‘packages’
[09:28:23.002]   - Field: ‘gc’
[09:28:23.002]   - Field: ‘conditions’
[09:28:23.002]   - Field: ‘expr’
[09:28:23.003]   - Field: ‘uuid’
[09:28:23.003]   - Field: ‘seed’
[09:28:23.003]   - Field: ‘version’
[09:28:23.003]   - Field: ‘result’
[09:28:23.003]   - Field: ‘asynchronous’
[09:28:23.003]   - Field: ‘calls’
[09:28:23.003]   - Field: ‘globals’
[09:28:23.003]   - Field: ‘stdout’
[09:28:23.003]   - Field: ‘earlySignal’
[09:28:23.003]   - Field: ‘lazy’
[09:28:23.003]   - Field: ‘state’
[09:28:23.003] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:28:23.004] - Launch lazy future ...
[09:28:23.004] Packages needed by the future expression (n = 0): <none>
[09:28:23.004] Packages needed by future strategies (n = 0): <none>
[09:28:23.004] {
[09:28:23.004]     {
[09:28:23.004]         {
[09:28:23.004]             ...future.startTime <- base::Sys.time()
[09:28:23.004]             {
[09:28:23.004]                 {
[09:28:23.004]                   {
[09:28:23.004]                     base::local({
[09:28:23.004]                       has_future <- base::requireNamespace("future", 
[09:28:23.004]                         quietly = TRUE)
[09:28:23.004]                       if (has_future) {
[09:28:23.004]                         ns <- base::getNamespace("future")
[09:28:23.004]                         version <- ns[[".package"]][["version"]]
[09:28:23.004]                         if (is.null(version)) 
[09:28:23.004]                           version <- utils::packageVersion("future")
[09:28:23.004]                       }
[09:28:23.004]                       else {
[09:28:23.004]                         version <- NULL
[09:28:23.004]                       }
[09:28:23.004]                       if (!has_future || version < "1.8.0") {
[09:28:23.004]                         info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.004]                           "", base::R.version$version.string), 
[09:28:23.004]                           platform = base::sprintf("%s (%s-bit)", 
[09:28:23.004]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:23.004]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.004]                             "release", "version")], collapse = " "), 
[09:28:23.004]                           hostname = base::Sys.info()[["nodename"]])
[09:28:23.004]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.004]                           info)
[09:28:23.004]                         info <- base::paste(info, collapse = "; ")
[09:28:23.004]                         if (!has_future) {
[09:28:23.004]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.004]                             info)
[09:28:23.004]                         }
[09:28:23.004]                         else {
[09:28:23.004]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.004]                             info, version)
[09:28:23.004]                         }
[09:28:23.004]                         base::stop(msg)
[09:28:23.004]                       }
[09:28:23.004]                     })
[09:28:23.004]                   }
[09:28:23.004]                   ...future.strategy.old <- future::plan("list")
[09:28:23.004]                   options(future.plan = NULL)
[09:28:23.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.004]                 }
[09:28:23.004]                 ...future.workdir <- getwd()
[09:28:23.004]             }
[09:28:23.004]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.004]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.004]         }
[09:28:23.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:23.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.004]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.004]             base::names(...future.oldOptions))
[09:28:23.004]     }
[09:28:23.004]     if (FALSE) {
[09:28:23.004]     }
[09:28:23.004]     else {
[09:28:23.004]         if (TRUE) {
[09:28:23.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.004]                 open = "w")
[09:28:23.004]         }
[09:28:23.004]         else {
[09:28:23.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.004]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.004]         }
[09:28:23.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.004]             base::sink(type = "output", split = FALSE)
[09:28:23.004]             base::close(...future.stdout)
[09:28:23.004]         }, add = TRUE)
[09:28:23.004]     }
[09:28:23.004]     ...future.frame <- base::sys.nframe()
[09:28:23.004]     ...future.conditions <- base::list()
[09:28:23.004]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.004]     if (FALSE) {
[09:28:23.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.004]     }
[09:28:23.004]     ...future.result <- base::tryCatch({
[09:28:23.004]         base::withCallingHandlers({
[09:28:23.004]             ...future.value <- base::withVisible(base::local({
[09:28:23.004]                 do.call(function(...) {
[09:28:23.004]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.004]                   if (!identical(...future.globals.maxSize.org, 
[09:28:23.004]                     ...future.globals.maxSize)) {
[09:28:23.004]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.004]                     on.exit(options(oopts), add = TRUE)
[09:28:23.004]                   }
[09:28:23.004]                   {
[09:28:23.004]                     lapply(seq_along(...future.elements_ii), 
[09:28:23.004]                       FUN = function(jj) {
[09:28:23.004]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.004]                         ...future.FUN(...future.X_jj, ...)
[09:28:23.004]                       })
[09:28:23.004]                   }
[09:28:23.004]                 }, args = future.call.arguments)
[09:28:23.004]             }))
[09:28:23.004]             future::FutureResult(value = ...future.value$value, 
[09:28:23.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.004]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.004]                     ...future.globalenv.names))
[09:28:23.004]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.004]         }, condition = base::local({
[09:28:23.004]             c <- base::c
[09:28:23.004]             inherits <- base::inherits
[09:28:23.004]             invokeRestart <- base::invokeRestart
[09:28:23.004]             length <- base::length
[09:28:23.004]             list <- base::list
[09:28:23.004]             seq.int <- base::seq.int
[09:28:23.004]             signalCondition <- base::signalCondition
[09:28:23.004]             sys.calls <- base::sys.calls
[09:28:23.004]             `[[` <- base::`[[`
[09:28:23.004]             `+` <- base::`+`
[09:28:23.004]             `<<-` <- base::`<<-`
[09:28:23.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.004]                   3L)]
[09:28:23.004]             }
[09:28:23.004]             function(cond) {
[09:28:23.004]                 is_error <- inherits(cond, "error")
[09:28:23.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.004]                   NULL)
[09:28:23.004]                 if (is_error) {
[09:28:23.004]                   sessionInformation <- function() {
[09:28:23.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.004]                       search = base::search(), system = base::Sys.info())
[09:28:23.004]                   }
[09:28:23.004]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.004]                     cond$call), session = sessionInformation(), 
[09:28:23.004]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.004]                   signalCondition(cond)
[09:28:23.004]                 }
[09:28:23.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.004]                 "immediateCondition"))) {
[09:28:23.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.004]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.004]                   if (TRUE && !signal) {
[09:28:23.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.004]                     {
[09:28:23.004]                       inherits <- base::inherits
[09:28:23.004]                       invokeRestart <- base::invokeRestart
[09:28:23.004]                       is.null <- base::is.null
[09:28:23.004]                       muffled <- FALSE
[09:28:23.004]                       if (inherits(cond, "message")) {
[09:28:23.004]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.004]                         if (muffled) 
[09:28:23.004]                           invokeRestart("muffleMessage")
[09:28:23.004]                       }
[09:28:23.004]                       else if (inherits(cond, "warning")) {
[09:28:23.004]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.004]                         if (muffled) 
[09:28:23.004]                           invokeRestart("muffleWarning")
[09:28:23.004]                       }
[09:28:23.004]                       else if (inherits(cond, "condition")) {
[09:28:23.004]                         if (!is.null(pattern)) {
[09:28:23.004]                           computeRestarts <- base::computeRestarts
[09:28:23.004]                           grepl <- base::grepl
[09:28:23.004]                           restarts <- computeRestarts(cond)
[09:28:23.004]                           for (restart in restarts) {
[09:28:23.004]                             name <- restart$name
[09:28:23.004]                             if (is.null(name)) 
[09:28:23.004]                               next
[09:28:23.004]                             if (!grepl(pattern, name)) 
[09:28:23.004]                               next
[09:28:23.004]                             invokeRestart(restart)
[09:28:23.004]                             muffled <- TRUE
[09:28:23.004]                             break
[09:28:23.004]                           }
[09:28:23.004]                         }
[09:28:23.004]                       }
[09:28:23.004]                       invisible(muffled)
[09:28:23.004]                     }
[09:28:23.004]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.004]                   }
[09:28:23.004]                 }
[09:28:23.004]                 else {
[09:28:23.004]                   if (TRUE) {
[09:28:23.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.004]                     {
[09:28:23.004]                       inherits <- base::inherits
[09:28:23.004]                       invokeRestart <- base::invokeRestart
[09:28:23.004]                       is.null <- base::is.null
[09:28:23.004]                       muffled <- FALSE
[09:28:23.004]                       if (inherits(cond, "message")) {
[09:28:23.004]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.004]                         if (muffled) 
[09:28:23.004]                           invokeRestart("muffleMessage")
[09:28:23.004]                       }
[09:28:23.004]                       else if (inherits(cond, "warning")) {
[09:28:23.004]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.004]                         if (muffled) 
[09:28:23.004]                           invokeRestart("muffleWarning")
[09:28:23.004]                       }
[09:28:23.004]                       else if (inherits(cond, "condition")) {
[09:28:23.004]                         if (!is.null(pattern)) {
[09:28:23.004]                           computeRestarts <- base::computeRestarts
[09:28:23.004]                           grepl <- base::grepl
[09:28:23.004]                           restarts <- computeRestarts(cond)
[09:28:23.004]                           for (restart in restarts) {
[09:28:23.004]                             name <- restart$name
[09:28:23.004]                             if (is.null(name)) 
[09:28:23.004]                               next
[09:28:23.004]                             if (!grepl(pattern, name)) 
[09:28:23.004]                               next
[09:28:23.004]                             invokeRestart(restart)
[09:28:23.004]                             muffled <- TRUE
[09:28:23.004]                             break
[09:28:23.004]                           }
[09:28:23.004]                         }
[09:28:23.004]                       }
[09:28:23.004]                       invisible(muffled)
[09:28:23.004]                     }
[09:28:23.004]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.004]                   }
[09:28:23.004]                 }
[09:28:23.004]             }
[09:28:23.004]         }))
[09:28:23.004]     }, error = function(ex) {
[09:28:23.004]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.004]                 ...future.rng), started = ...future.startTime, 
[09:28:23.004]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.004]             version = "1.8"), class = "FutureResult")
[09:28:23.004]     }, finally = {
[09:28:23.004]         if (!identical(...future.workdir, getwd())) 
[09:28:23.004]             setwd(...future.workdir)
[09:28:23.004]         {
[09:28:23.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.004]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.004]             }
[09:28:23.004]             base::options(...future.oldOptions)
[09:28:23.004]             if (.Platform$OS.type == "windows") {
[09:28:23.004]                 old_names <- names(...future.oldEnvVars)
[09:28:23.004]                 envs <- base::Sys.getenv()
[09:28:23.004]                 names <- names(envs)
[09:28:23.004]                 common <- intersect(names, old_names)
[09:28:23.004]                 added <- setdiff(names, old_names)
[09:28:23.004]                 removed <- setdiff(old_names, names)
[09:28:23.004]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.004]                   envs[common]]
[09:28:23.004]                 NAMES <- toupper(changed)
[09:28:23.004]                 args <- list()
[09:28:23.004]                 for (kk in seq_along(NAMES)) {
[09:28:23.004]                   name <- changed[[kk]]
[09:28:23.004]                   NAME <- NAMES[[kk]]
[09:28:23.004]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.004]                     next
[09:28:23.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.004]                 }
[09:28:23.004]                 NAMES <- toupper(added)
[09:28:23.004]                 for (kk in seq_along(NAMES)) {
[09:28:23.004]                   name <- added[[kk]]
[09:28:23.004]                   NAME <- NAMES[[kk]]
[09:28:23.004]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.004]                     next
[09:28:23.004]                   args[[name]] <- ""
[09:28:23.004]                 }
[09:28:23.004]                 NAMES <- toupper(removed)
[09:28:23.004]                 for (kk in seq_along(NAMES)) {
[09:28:23.004]                   name <- removed[[kk]]
[09:28:23.004]                   NAME <- NAMES[[kk]]
[09:28:23.004]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.004]                     next
[09:28:23.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.004]                 }
[09:28:23.004]                 if (length(args) > 0) 
[09:28:23.004]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.004]             }
[09:28:23.004]             else {
[09:28:23.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.004]             }
[09:28:23.004]             {
[09:28:23.004]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.004]                   0L) {
[09:28:23.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.004]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.004]                   base::options(opts)
[09:28:23.004]                 }
[09:28:23.004]                 {
[09:28:23.004]                   {
[09:28:23.004]                     NULL
[09:28:23.004]                     RNGkind("Mersenne-Twister")
[09:28:23.004]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:28:23.004]                       inherits = FALSE)
[09:28:23.004]                   }
[09:28:23.004]                   options(future.plan = NULL)
[09:28:23.004]                   if (is.na(NA_character_)) 
[09:28:23.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.004]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.004]                     .init = FALSE)
[09:28:23.004]                 }
[09:28:23.004]             }
[09:28:23.004]         }
[09:28:23.004]     })
[09:28:23.004]     if (TRUE) {
[09:28:23.004]         base::sink(type = "output", split = FALSE)
[09:28:23.004]         if (TRUE) {
[09:28:23.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.004]         }
[09:28:23.004]         else {
[09:28:23.004]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.004]         }
[09:28:23.004]         base::close(...future.stdout)
[09:28:23.004]         ...future.stdout <- NULL
[09:28:23.004]     }
[09:28:23.004]     ...future.result$conditions <- ...future.conditions
[09:28:23.004]     ...future.result$finished <- base::Sys.time()
[09:28:23.004]     ...future.result
[09:28:23.004] }
[09:28:23.006] assign_globals() ...
[09:28:23.006] List of 5
[09:28:23.006]  $ ...future.FUN            :function (object, ...)  
[09:28:23.006]  $ future.call.arguments    : list()
[09:28:23.006]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.006]  $ ...future.elements_ii    :List of 3
[09:28:23.006]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.006]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:23.006]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.006]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:23.006]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.006]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:23.006]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.006]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:23.006]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.006]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:23.006]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.006]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:23.006]  $ ...future.seeds_ii       : NULL
[09:28:23.006]  $ ...future.globals.maxSize: NULL
[09:28:23.006]  - attr(*, "where")=List of 5
[09:28:23.006]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.006]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.006]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.006]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.006]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.006]  - attr(*, "resolved")= logi FALSE
[09:28:23.006]  - attr(*, "total_size")= num 1240
[09:28:23.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.006]  - attr(*, "already-done")= logi TRUE
[09:28:23.014] - copied ‘...future.FUN’ to environment
[09:28:23.014] - copied ‘future.call.arguments’ to environment
[09:28:23.014] - copied ‘...future.elements_ii’ to environment
[09:28:23.014] - copied ‘...future.seeds_ii’ to environment
[09:28:23.014] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.015] assign_globals() ... done
[09:28:23.015] plan(): Setting new future strategy stack:
[09:28:23.015] List of future strategies:
[09:28:23.015] 1. sequential:
[09:28:23.015]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.015]    - tweaked: FALSE
[09:28:23.015]    - call: NULL
[09:28:23.015] plan(): nbrOfWorkers() = 1
[09:28:23.018] plan(): Setting new future strategy stack:
[09:28:23.019] List of future strategies:
[09:28:23.019] 1. sequential:
[09:28:23.019]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.019]    - tweaked: FALSE
[09:28:23.019]    - call: plan(strategy)
[09:28:23.019] plan(): nbrOfWorkers() = 1
[09:28:23.019] SequentialFuture started (and completed)
[09:28:23.019] - Launch lazy future ... done
[09:28:23.019] run() for ‘SequentialFuture’ ... done
[09:28:23.020] Created future:
[09:28:23.020] SequentialFuture:
[09:28:23.020] Label: ‘future_by-1’
[09:28:23.020] Expression:
[09:28:23.020] {
[09:28:23.020]     do.call(function(...) {
[09:28:23.020]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.020]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.020]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.020]             on.exit(options(oopts), add = TRUE)
[09:28:23.020]         }
[09:28:23.020]         {
[09:28:23.020]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.020]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.020]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.020]             })
[09:28:23.020]         }
[09:28:23.020]     }, args = future.call.arguments)
[09:28:23.020] }
[09:28:23.020] Lazy evaluation: FALSE
[09:28:23.020] Asynchronous evaluation: FALSE
[09:28:23.020] Local evaluation: TRUE
[09:28:23.020] Environment: 0x555b09d89ca0
[09:28:23.020] Capture standard output: TRUE
[09:28:23.020] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.020] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:23.020] Packages: <none>
[09:28:23.020] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.020] Resolved: TRUE
[09:28:23.020] Value: 5.37 KiB of class ‘list’
[09:28:23.020] Early signaling: FALSE
[09:28:23.020] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.020] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:28:23.021] Chunk #1 of 1 ... DONE
[09:28:23.021] Launching 1 futures (chunks) ... DONE
[09:28:23.021] Resolving 1 futures (chunks) ...
[09:28:23.021] resolve() on list ...
[09:28:23.021]  recursive: 0
[09:28:23.021]  length: 1
[09:28:23.021] 
[09:28:23.021] resolved() for ‘SequentialFuture’ ...
[09:28:23.022] - state: ‘finished’
[09:28:23.022] - run: TRUE
[09:28:23.022] - result: ‘FutureResult’
[09:28:23.022] resolved() for ‘SequentialFuture’ ... done
[09:28:23.022] Future #1
[09:28:23.022] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:28:23.022] - nx: 1
[09:28:23.022] - relay: TRUE
[09:28:23.022] - stdout: TRUE
[09:28:23.022] - signal: TRUE
[09:28:23.022] - resignal: FALSE
[09:28:23.022] - force: TRUE
[09:28:23.023] - relayed: [n=1] FALSE
[09:28:23.023] - queued futures: [n=1] FALSE
[09:28:23.023]  - until=1
[09:28:23.023]  - relaying element #1
[09:28:23.023] - relayed: [n=1] TRUE
[09:28:23.023] - queued futures: [n=1] TRUE
[09:28:23.023] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:28:23.023]  length: 0 (resolved future 1)
[09:28:23.023] Relaying remaining futures
[09:28:23.023] signalConditionsASAP(NULL, pos=0) ...
[09:28:23.023] - nx: 1
[09:28:23.024] - relay: TRUE
[09:28:23.024] - stdout: TRUE
[09:28:23.024] - signal: TRUE
[09:28:23.024] - resignal: FALSE
[09:28:23.024] - force: TRUE
[09:28:23.024] - relayed: [n=1] TRUE
[09:28:23.024] - queued futures: [n=1] TRUE
 - flush all
[09:28:23.024] - relayed: [n=1] TRUE
[09:28:23.024] - queued futures: [n=1] TRUE
[09:28:23.024] signalConditionsASAP(NULL, pos=0) ... done
[09:28:23.024] resolve() on list ... DONE
[09:28:23.025]  - Number of value chunks collected: 1
[09:28:23.025] Resolving 1 futures (chunks) ... DONE
[09:28:23.025] Reducing values from 1 chunks ...
[09:28:23.025]  - Number of values collected after concatenation: 3
[09:28:23.025]  - Number of values expected: 3
[09:28:23.025] Reducing values from 1 chunks ... DONE
[09:28:23.025] future_lapply() ... DONE
[09:28:23.025] future_by_internal() ... DONE
[09:28:23.026] future_by_internal() ...
- plan('multicore') ...
[09:28:23.026] plan(): Setting new future strategy stack:
[09:28:23.026] List of future strategies:
[09:28:23.026] 1. multicore:
[09:28:23.026]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.026]    - tweaked: FALSE
[09:28:23.026]    - call: plan(strategy)
[09:28:23.030] plan(): nbrOfWorkers() = 2
[09:28:23.030] future_by_internal() ...
[09:28:23.031] future_lapply() ...
[09:28:23.035] Number of chunks: 2
[09:28:23.035] getGlobalsAndPackagesXApply() ...
[09:28:23.035]  - future.globals: TRUE
[09:28:23.035] getGlobalsAndPackages() ...
[09:28:23.035] Searching for globals...
[09:28:23.036] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:23.036] Searching for globals ... DONE
[09:28:23.036] Resolving globals: FALSE
[09:28:23.036] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:23.037] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:23.037] - globals: [1] ‘FUN’
[09:28:23.037] 
[09:28:23.037] getGlobalsAndPackages() ... DONE
[09:28:23.037]  - globals found/used: [n=1] ‘FUN’
[09:28:23.037]  - needed namespaces: [n=0] 
[09:28:23.037] Finding globals ... DONE
[09:28:23.037]  - use_args: TRUE
[09:28:23.038]  - Getting '...' globals ...
[09:28:23.038] resolve() on list ...
[09:28:23.038]  recursive: 0
[09:28:23.038]  length: 1
[09:28:23.038]  elements: ‘...’
[09:28:23.038]  length: 0 (resolved future 1)
[09:28:23.038] resolve() on list ... DONE
[09:28:23.038]    - '...' content: [n=0] 
[09:28:23.038] List of 1
[09:28:23.038]  $ ...: list()
[09:28:23.038]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.038]  - attr(*, "where")=List of 1
[09:28:23.038]   ..$ ...:<environment: 0x555b0a1f9738> 
[09:28:23.038]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.038]  - attr(*, "resolved")= logi TRUE
[09:28:23.038]  - attr(*, "total_size")= num NA
[09:28:23.042]  - Getting '...' globals ... DONE
[09:28:23.042] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:23.042] List of 2
[09:28:23.042]  $ ...future.FUN:function (object, ...)  
[09:28:23.042]  $ ...          : list()
[09:28:23.042]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.042]  - attr(*, "where")=List of 2
[09:28:23.042]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:23.042]   ..$ ...          :<environment: 0x555b0a1f9738> 
[09:28:23.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.042]  - attr(*, "resolved")= logi FALSE
[09:28:23.042]  - attr(*, "total_size")= num 1240
[09:28:23.045] Packages to be attached in all futures: [n=0] 
[09:28:23.045] getGlobalsAndPackagesXApply() ... DONE
[09:28:23.045] Number of futures (= number of chunks): 2
[09:28:23.045] Launching 2 futures (chunks) ...
[09:28:23.045] Chunk #1 of 2 ...
[09:28:23.046]  - Finding globals in 'X' for chunk #1 ...
[09:28:23.046] getGlobalsAndPackages() ...
[09:28:23.046] Searching for globals...
[09:28:23.046] 
[09:28:23.046] Searching for globals ... DONE
[09:28:23.046] - globals: [0] <none>
[09:28:23.046] getGlobalsAndPackages() ... DONE
[09:28:23.046]    + additional globals found: [n=0] 
[09:28:23.046]    + additional namespaces needed: [n=0] 
[09:28:23.047]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:23.047]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.047]  - seeds: <none>
[09:28:23.047]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.047] getGlobalsAndPackages() ...
[09:28:23.047] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.047] Resolving globals: FALSE
[09:28:23.047] Tweak future expression to call with '...' arguments ...
[09:28:23.047] {
[09:28:23.047]     do.call(function(...) {
[09:28:23.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.047]             on.exit(options(oopts), add = TRUE)
[09:28:23.047]         }
[09:28:23.047]         {
[09:28:23.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.047]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.047]             })
[09:28:23.047]         }
[09:28:23.047]     }, args = future.call.arguments)
[09:28:23.047] }
[09:28:23.048] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.048] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.048] 
[09:28:23.048] getGlobalsAndPackages() ... DONE
[09:28:23.048] run() for ‘Future’ ...
[09:28:23.048] - state: ‘created’
[09:28:23.049] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.052] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.052] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.052]   - Field: ‘label’
[09:28:23.052]   - Field: ‘local’
[09:28:23.052]   - Field: ‘owner’
[09:28:23.052]   - Field: ‘envir’
[09:28:23.053]   - Field: ‘workers’
[09:28:23.053]   - Field: ‘packages’
[09:28:23.053]   - Field: ‘gc’
[09:28:23.053]   - Field: ‘job’
[09:28:23.053]   - Field: ‘conditions’
[09:28:23.053]   - Field: ‘expr’
[09:28:23.053]   - Field: ‘uuid’
[09:28:23.053]   - Field: ‘seed’
[09:28:23.053]   - Field: ‘version’
[09:28:23.053]   - Field: ‘result’
[09:28:23.053]   - Field: ‘asynchronous’
[09:28:23.053]   - Field: ‘calls’
[09:28:23.054]   - Field: ‘globals’
[09:28:23.054]   - Field: ‘stdout’
[09:28:23.054]   - Field: ‘earlySignal’
[09:28:23.054]   - Field: ‘lazy’
[09:28:23.054]   - Field: ‘state’
[09:28:23.054] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.054] - Launch lazy future ...
[09:28:23.055] Packages needed by the future expression (n = 0): <none>
[09:28:23.055] Packages needed by future strategies (n = 0): <none>
[09:28:23.056] {
[09:28:23.056]     {
[09:28:23.056]         {
[09:28:23.056]             ...future.startTime <- base::Sys.time()
[09:28:23.056]             {
[09:28:23.056]                 {
[09:28:23.056]                   {
[09:28:23.056]                     {
[09:28:23.056]                       base::local({
[09:28:23.056]                         has_future <- base::requireNamespace("future", 
[09:28:23.056]                           quietly = TRUE)
[09:28:23.056]                         if (has_future) {
[09:28:23.056]                           ns <- base::getNamespace("future")
[09:28:23.056]                           version <- ns[[".package"]][["version"]]
[09:28:23.056]                           if (is.null(version)) 
[09:28:23.056]                             version <- utils::packageVersion("future")
[09:28:23.056]                         }
[09:28:23.056]                         else {
[09:28:23.056]                           version <- NULL
[09:28:23.056]                         }
[09:28:23.056]                         if (!has_future || version < "1.8.0") {
[09:28:23.056]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.056]                             "", base::R.version$version.string), 
[09:28:23.056]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:23.056]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:23.056]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.056]                               "release", "version")], collapse = " "), 
[09:28:23.056]                             hostname = base::Sys.info()[["nodename"]])
[09:28:23.056]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.056]                             info)
[09:28:23.056]                           info <- base::paste(info, collapse = "; ")
[09:28:23.056]                           if (!has_future) {
[09:28:23.056]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.056]                               info)
[09:28:23.056]                           }
[09:28:23.056]                           else {
[09:28:23.056]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.056]                               info, version)
[09:28:23.056]                           }
[09:28:23.056]                           base::stop(msg)
[09:28:23.056]                         }
[09:28:23.056]                       })
[09:28:23.056]                     }
[09:28:23.056]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.056]                     base::options(mc.cores = 1L)
[09:28:23.056]                   }
[09:28:23.056]                   ...future.strategy.old <- future::plan("list")
[09:28:23.056]                   options(future.plan = NULL)
[09:28:23.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.056]                 }
[09:28:23.056]                 ...future.workdir <- getwd()
[09:28:23.056]             }
[09:28:23.056]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.056]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.056]         }
[09:28:23.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.056]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.056]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.056]             base::names(...future.oldOptions))
[09:28:23.056]     }
[09:28:23.056]     if (FALSE) {
[09:28:23.056]     }
[09:28:23.056]     else {
[09:28:23.056]         if (TRUE) {
[09:28:23.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.056]                 open = "w")
[09:28:23.056]         }
[09:28:23.056]         else {
[09:28:23.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.056]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.056]         }
[09:28:23.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.056]             base::sink(type = "output", split = FALSE)
[09:28:23.056]             base::close(...future.stdout)
[09:28:23.056]         }, add = TRUE)
[09:28:23.056]     }
[09:28:23.056]     ...future.frame <- base::sys.nframe()
[09:28:23.056]     ...future.conditions <- base::list()
[09:28:23.056]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.056]     if (FALSE) {
[09:28:23.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.056]     }
[09:28:23.056]     ...future.result <- base::tryCatch({
[09:28:23.056]         base::withCallingHandlers({
[09:28:23.056]             ...future.value <- base::withVisible(base::local({
[09:28:23.056]                 withCallingHandlers({
[09:28:23.056]                   {
[09:28:23.056]                     do.call(function(...) {
[09:28:23.056]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.056]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.056]                         ...future.globals.maxSize)) {
[09:28:23.056]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.056]                         on.exit(options(oopts), add = TRUE)
[09:28:23.056]                       }
[09:28:23.056]                       {
[09:28:23.056]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.056]                           FUN = function(jj) {
[09:28:23.056]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.056]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.056]                           })
[09:28:23.056]                       }
[09:28:23.056]                     }, args = future.call.arguments)
[09:28:23.056]                   }
[09:28:23.056]                 }, immediateCondition = function(cond) {
[09:28:23.056]                   save_rds <- function (object, pathname, ...) 
[09:28:23.056]                   {
[09:28:23.056]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.056]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.056]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.056]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.056]                         fi_tmp[["mtime"]])
[09:28:23.056]                     }
[09:28:23.056]                     tryCatch({
[09:28:23.056]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.056]                     }, error = function(ex) {
[09:28:23.056]                       msg <- conditionMessage(ex)
[09:28:23.056]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.056]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.056]                         fi_tmp[["mtime"]], msg)
[09:28:23.056]                       ex$message <- msg
[09:28:23.056]                       stop(ex)
[09:28:23.056]                     })
[09:28:23.056]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.056]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.056]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.056]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.056]                       fi <- file.info(pathname)
[09:28:23.056]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.056]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.056]                         fi[["size"]], fi[["mtime"]])
[09:28:23.056]                       stop(msg)
[09:28:23.056]                     }
[09:28:23.056]                     invisible(pathname)
[09:28:23.056]                   }
[09:28:23.056]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.056]                     rootPath = tempdir()) 
[09:28:23.056]                   {
[09:28:23.056]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.056]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.056]                       tmpdir = path, fileext = ".rds")
[09:28:23.056]                     save_rds(obj, file)
[09:28:23.056]                   }
[09:28:23.056]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.056]                   {
[09:28:23.056]                     inherits <- base::inherits
[09:28:23.056]                     invokeRestart <- base::invokeRestart
[09:28:23.056]                     is.null <- base::is.null
[09:28:23.056]                     muffled <- FALSE
[09:28:23.056]                     if (inherits(cond, "message")) {
[09:28:23.056]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.056]                       if (muffled) 
[09:28:23.056]                         invokeRestart("muffleMessage")
[09:28:23.056]                     }
[09:28:23.056]                     else if (inherits(cond, "warning")) {
[09:28:23.056]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.056]                       if (muffled) 
[09:28:23.056]                         invokeRestart("muffleWarning")
[09:28:23.056]                     }
[09:28:23.056]                     else if (inherits(cond, "condition")) {
[09:28:23.056]                       if (!is.null(pattern)) {
[09:28:23.056]                         computeRestarts <- base::computeRestarts
[09:28:23.056]                         grepl <- base::grepl
[09:28:23.056]                         restarts <- computeRestarts(cond)
[09:28:23.056]                         for (restart in restarts) {
[09:28:23.056]                           name <- restart$name
[09:28:23.056]                           if (is.null(name)) 
[09:28:23.056]                             next
[09:28:23.056]                           if (!grepl(pattern, name)) 
[09:28:23.056]                             next
[09:28:23.056]                           invokeRestart(restart)
[09:28:23.056]                           muffled <- TRUE
[09:28:23.056]                           break
[09:28:23.056]                         }
[09:28:23.056]                       }
[09:28:23.056]                     }
[09:28:23.056]                     invisible(muffled)
[09:28:23.056]                   }
[09:28:23.056]                   muffleCondition(cond)
[09:28:23.056]                 })
[09:28:23.056]             }))
[09:28:23.056]             future::FutureResult(value = ...future.value$value, 
[09:28:23.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.056]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.056]                     ...future.globalenv.names))
[09:28:23.056]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.056]         }, condition = base::local({
[09:28:23.056]             c <- base::c
[09:28:23.056]             inherits <- base::inherits
[09:28:23.056]             invokeRestart <- base::invokeRestart
[09:28:23.056]             length <- base::length
[09:28:23.056]             list <- base::list
[09:28:23.056]             seq.int <- base::seq.int
[09:28:23.056]             signalCondition <- base::signalCondition
[09:28:23.056]             sys.calls <- base::sys.calls
[09:28:23.056]             `[[` <- base::`[[`
[09:28:23.056]             `+` <- base::`+`
[09:28:23.056]             `<<-` <- base::`<<-`
[09:28:23.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.056]                   3L)]
[09:28:23.056]             }
[09:28:23.056]             function(cond) {
[09:28:23.056]                 is_error <- inherits(cond, "error")
[09:28:23.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.056]                   NULL)
[09:28:23.056]                 if (is_error) {
[09:28:23.056]                   sessionInformation <- function() {
[09:28:23.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.056]                       search = base::search(), system = base::Sys.info())
[09:28:23.056]                   }
[09:28:23.056]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.056]                     cond$call), session = sessionInformation(), 
[09:28:23.056]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.056]                   signalCondition(cond)
[09:28:23.056]                 }
[09:28:23.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.056]                 "immediateCondition"))) {
[09:28:23.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.056]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.056]                   if (TRUE && !signal) {
[09:28:23.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.056]                     {
[09:28:23.056]                       inherits <- base::inherits
[09:28:23.056]                       invokeRestart <- base::invokeRestart
[09:28:23.056]                       is.null <- base::is.null
[09:28:23.056]                       muffled <- FALSE
[09:28:23.056]                       if (inherits(cond, "message")) {
[09:28:23.056]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.056]                         if (muffled) 
[09:28:23.056]                           invokeRestart("muffleMessage")
[09:28:23.056]                       }
[09:28:23.056]                       else if (inherits(cond, "warning")) {
[09:28:23.056]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.056]                         if (muffled) 
[09:28:23.056]                           invokeRestart("muffleWarning")
[09:28:23.056]                       }
[09:28:23.056]                       else if (inherits(cond, "condition")) {
[09:28:23.056]                         if (!is.null(pattern)) {
[09:28:23.056]                           computeRestarts <- base::computeRestarts
[09:28:23.056]                           grepl <- base::grepl
[09:28:23.056]                           restarts <- computeRestarts(cond)
[09:28:23.056]                           for (restart in restarts) {
[09:28:23.056]                             name <- restart$name
[09:28:23.056]                             if (is.null(name)) 
[09:28:23.056]                               next
[09:28:23.056]                             if (!grepl(pattern, name)) 
[09:28:23.056]                               next
[09:28:23.056]                             invokeRestart(restart)
[09:28:23.056]                             muffled <- TRUE
[09:28:23.056]                             break
[09:28:23.056]                           }
[09:28:23.056]                         }
[09:28:23.056]                       }
[09:28:23.056]                       invisible(muffled)
[09:28:23.056]                     }
[09:28:23.056]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.056]                   }
[09:28:23.056]                 }
[09:28:23.056]                 else {
[09:28:23.056]                   if (TRUE) {
[09:28:23.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.056]                     {
[09:28:23.056]                       inherits <- base::inherits
[09:28:23.056]                       invokeRestart <- base::invokeRestart
[09:28:23.056]                       is.null <- base::is.null
[09:28:23.056]                       muffled <- FALSE
[09:28:23.056]                       if (inherits(cond, "message")) {
[09:28:23.056]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.056]                         if (muffled) 
[09:28:23.056]                           invokeRestart("muffleMessage")
[09:28:23.056]                       }
[09:28:23.056]                       else if (inherits(cond, "warning")) {
[09:28:23.056]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.056]                         if (muffled) 
[09:28:23.056]                           invokeRestart("muffleWarning")
[09:28:23.056]                       }
[09:28:23.056]                       else if (inherits(cond, "condition")) {
[09:28:23.056]                         if (!is.null(pattern)) {
[09:28:23.056]                           computeRestarts <- base::computeRestarts
[09:28:23.056]                           grepl <- base::grepl
[09:28:23.056]                           restarts <- computeRestarts(cond)
[09:28:23.056]                           for (restart in restarts) {
[09:28:23.056]                             name <- restart$name
[09:28:23.056]                             if (is.null(name)) 
[09:28:23.056]                               next
[09:28:23.056]                             if (!grepl(pattern, name)) 
[09:28:23.056]                               next
[09:28:23.056]                             invokeRestart(restart)
[09:28:23.056]                             muffled <- TRUE
[09:28:23.056]                             break
[09:28:23.056]                           }
[09:28:23.056]                         }
[09:28:23.056]                       }
[09:28:23.056]                       invisible(muffled)
[09:28:23.056]                     }
[09:28:23.056]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.056]                   }
[09:28:23.056]                 }
[09:28:23.056]             }
[09:28:23.056]         }))
[09:28:23.056]     }, error = function(ex) {
[09:28:23.056]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.056]                 ...future.rng), started = ...future.startTime, 
[09:28:23.056]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.056]             version = "1.8"), class = "FutureResult")
[09:28:23.056]     }, finally = {
[09:28:23.056]         if (!identical(...future.workdir, getwd())) 
[09:28:23.056]             setwd(...future.workdir)
[09:28:23.056]         {
[09:28:23.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.056]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.056]             }
[09:28:23.056]             base::options(...future.oldOptions)
[09:28:23.056]             if (.Platform$OS.type == "windows") {
[09:28:23.056]                 old_names <- names(...future.oldEnvVars)
[09:28:23.056]                 envs <- base::Sys.getenv()
[09:28:23.056]                 names <- names(envs)
[09:28:23.056]                 common <- intersect(names, old_names)
[09:28:23.056]                 added <- setdiff(names, old_names)
[09:28:23.056]                 removed <- setdiff(old_names, names)
[09:28:23.056]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.056]                   envs[common]]
[09:28:23.056]                 NAMES <- toupper(changed)
[09:28:23.056]                 args <- list()
[09:28:23.056]                 for (kk in seq_along(NAMES)) {
[09:28:23.056]                   name <- changed[[kk]]
[09:28:23.056]                   NAME <- NAMES[[kk]]
[09:28:23.056]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.056]                     next
[09:28:23.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.056]                 }
[09:28:23.056]                 NAMES <- toupper(added)
[09:28:23.056]                 for (kk in seq_along(NAMES)) {
[09:28:23.056]                   name <- added[[kk]]
[09:28:23.056]                   NAME <- NAMES[[kk]]
[09:28:23.056]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.056]                     next
[09:28:23.056]                   args[[name]] <- ""
[09:28:23.056]                 }
[09:28:23.056]                 NAMES <- toupper(removed)
[09:28:23.056]                 for (kk in seq_along(NAMES)) {
[09:28:23.056]                   name <- removed[[kk]]
[09:28:23.056]                   NAME <- NAMES[[kk]]
[09:28:23.056]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.056]                     next
[09:28:23.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.056]                 }
[09:28:23.056]                 if (length(args) > 0) 
[09:28:23.056]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.056]             }
[09:28:23.056]             else {
[09:28:23.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.056]             }
[09:28:23.056]             {
[09:28:23.056]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.056]                   0L) {
[09:28:23.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.056]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.056]                   base::options(opts)
[09:28:23.056]                 }
[09:28:23.056]                 {
[09:28:23.056]                   {
[09:28:23.056]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.056]                     NULL
[09:28:23.056]                   }
[09:28:23.056]                   options(future.plan = NULL)
[09:28:23.056]                   if (is.na(NA_character_)) 
[09:28:23.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.056]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.056]                     .init = FALSE)
[09:28:23.056]                 }
[09:28:23.056]             }
[09:28:23.056]         }
[09:28:23.056]     })
[09:28:23.056]     if (TRUE) {
[09:28:23.056]         base::sink(type = "output", split = FALSE)
[09:28:23.056]         if (TRUE) {
[09:28:23.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.056]         }
[09:28:23.056]         else {
[09:28:23.056]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.056]         }
[09:28:23.056]         base::close(...future.stdout)
[09:28:23.056]         ...future.stdout <- NULL
[09:28:23.056]     }
[09:28:23.056]     ...future.result$conditions <- ...future.conditions
[09:28:23.056]     ...future.result$finished <- base::Sys.time()
[09:28:23.056]     ...future.result
[09:28:23.056] }
[09:28:23.058] assign_globals() ...
[09:28:23.058] List of 5
[09:28:23.058]  $ ...future.FUN            :function (object, ...)  
[09:28:23.058]  $ future.call.arguments    : list()
[09:28:23.058]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.058]  $ ...future.elements_ii    :List of 1
[09:28:23.058]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:23.058]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:23.058]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.058]  $ ...future.seeds_ii       : NULL
[09:28:23.058]  $ ...future.globals.maxSize: NULL
[09:28:23.058]  - attr(*, "where")=List of 5
[09:28:23.058]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.058]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.058]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.058]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.058]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.058]  - attr(*, "resolved")= logi FALSE
[09:28:23.058]  - attr(*, "total_size")= num 1240
[09:28:23.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.058]  - attr(*, "already-done")= logi TRUE
[09:28:23.063] - copied ‘...future.FUN’ to environment
[09:28:23.063] - copied ‘future.call.arguments’ to environment
[09:28:23.063] - copied ‘...future.elements_ii’ to environment
[09:28:23.063] - copied ‘...future.seeds_ii’ to environment
[09:28:23.063] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.063] assign_globals() ... done
[09:28:23.063] requestCore(): workers = 2
[09:28:23.068] MulticoreFuture started
[09:28:23.069] - Launch lazy future ... done
[09:28:23.069] plan(): Setting new future strategy stack:
[09:28:23.069] run() for ‘MulticoreFuture’ ... done
[09:28:23.070] Created future:
[09:28:23.070] List of future strategies:
[09:28:23.070] 1. sequential:
[09:28:23.070]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.070]    - tweaked: FALSE
[09:28:23.070]    - call: NULL
[09:28:23.072] plan(): nbrOfWorkers() = 1
[09:28:23.076] plan(): Setting new future strategy stack:
[09:28:23.076] List of future strategies:
[09:28:23.076] 1. multicore:
[09:28:23.076]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.076]    - tweaked: FALSE
[09:28:23.076]    - call: plan(strategy)
[09:28:23.082] plan(): nbrOfWorkers() = 2
[09:28:23.070] MulticoreFuture:
[09:28:23.070] Label: ‘future_by-1’
[09:28:23.070] Expression:
[09:28:23.070] {
[09:28:23.070]     do.call(function(...) {
[09:28:23.070]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.070]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.070]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.070]             on.exit(options(oopts), add = TRUE)
[09:28:23.070]         }
[09:28:23.070]         {
[09:28:23.070]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.070]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.070]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.070]             })
[09:28:23.070]         }
[09:28:23.070]     }, args = future.call.arguments)
[09:28:23.070] }
[09:28:23.070] Lazy evaluation: FALSE
[09:28:23.070] Asynchronous evaluation: TRUE
[09:28:23.070] Local evaluation: TRUE
[09:28:23.070] Environment: R_GlobalEnv
[09:28:23.070] Capture standard output: TRUE
[09:28:23.070] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.070] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:23.070] Packages: <none>
[09:28:23.070] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.070] Resolved: TRUE
[09:28:23.070] Value: <not collected>
[09:28:23.070] Conditions captured: <none>
[09:28:23.070] Early signaling: FALSE
[09:28:23.070] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.070] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.084] Chunk #1 of 2 ... DONE
[09:28:23.084] Chunk #2 of 2 ...
[09:28:23.084]  - Finding globals in 'X' for chunk #2 ...
[09:28:23.084] getGlobalsAndPackages() ...
[09:28:23.085] Searching for globals...
[09:28:23.086] 
[09:28:23.086] Searching for globals ... DONE
[09:28:23.086] - globals: [0] <none>
[09:28:23.086] getGlobalsAndPackages() ... DONE
[09:28:23.086]    + additional globals found: [n=0] 
[09:28:23.086]    + additional namespaces needed: [n=0] 
[09:28:23.087]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:23.087]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.087]  - seeds: <none>
[09:28:23.087]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.087] getGlobalsAndPackages() ...
[09:28:23.088] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.088] Resolving globals: FALSE
[09:28:23.088] Tweak future expression to call with '...' arguments ...
[09:28:23.088] {
[09:28:23.088]     do.call(function(...) {
[09:28:23.088]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.088]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.088]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.088]             on.exit(options(oopts), add = TRUE)
[09:28:23.088]         }
[09:28:23.088]         {
[09:28:23.088]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.088]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.088]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.088]             })
[09:28:23.088]         }
[09:28:23.088]     }, args = future.call.arguments)
[09:28:23.088] }
[09:28:23.089] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.089] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.089] 
[09:28:23.089] getGlobalsAndPackages() ... DONE
[09:28:23.090] run() for ‘Future’ ...
[09:28:23.090] - state: ‘created’
[09:28:23.090] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.095] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.095] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.095]   - Field: ‘label’
[09:28:23.095]   - Field: ‘local’
[09:28:23.096]   - Field: ‘owner’
[09:28:23.096]   - Field: ‘envir’
[09:28:23.096]   - Field: ‘workers’
[09:28:23.096]   - Field: ‘packages’
[09:28:23.096]   - Field: ‘gc’
[09:28:23.096]   - Field: ‘job’
[09:28:23.096]   - Field: ‘conditions’
[09:28:23.097]   - Field: ‘expr’
[09:28:23.097]   - Field: ‘uuid’
[09:28:23.097]   - Field: ‘seed’
[09:28:23.097]   - Field: ‘version’
[09:28:23.097]   - Field: ‘result’
[09:28:23.097]   - Field: ‘asynchronous’
[09:28:23.097]   - Field: ‘calls’
[09:28:23.097]   - Field: ‘globals’
[09:28:23.097]   - Field: ‘stdout’
[09:28:23.098]   - Field: ‘earlySignal’
[09:28:23.098]   - Field: ‘lazy’
[09:28:23.098]   - Field: ‘state’
[09:28:23.098] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.098] - Launch lazy future ...
[09:28:23.098] Packages needed by the future expression (n = 0): <none>
[09:28:23.099] Packages needed by future strategies (n = 0): <none>
[09:28:23.099] {
[09:28:23.099]     {
[09:28:23.099]         {
[09:28:23.099]             ...future.startTime <- base::Sys.time()
[09:28:23.099]             {
[09:28:23.099]                 {
[09:28:23.099]                   {
[09:28:23.099]                     {
[09:28:23.099]                       base::local({
[09:28:23.099]                         has_future <- base::requireNamespace("future", 
[09:28:23.099]                           quietly = TRUE)
[09:28:23.099]                         if (has_future) {
[09:28:23.099]                           ns <- base::getNamespace("future")
[09:28:23.099]                           version <- ns[[".package"]][["version"]]
[09:28:23.099]                           if (is.null(version)) 
[09:28:23.099]                             version <- utils::packageVersion("future")
[09:28:23.099]                         }
[09:28:23.099]                         else {
[09:28:23.099]                           version <- NULL
[09:28:23.099]                         }
[09:28:23.099]                         if (!has_future || version < "1.8.0") {
[09:28:23.099]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.099]                             "", base::R.version$version.string), 
[09:28:23.099]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:23.099]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:23.099]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.099]                               "release", "version")], collapse = " "), 
[09:28:23.099]                             hostname = base::Sys.info()[["nodename"]])
[09:28:23.099]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.099]                             info)
[09:28:23.099]                           info <- base::paste(info, collapse = "; ")
[09:28:23.099]                           if (!has_future) {
[09:28:23.099]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.099]                               info)
[09:28:23.099]                           }
[09:28:23.099]                           else {
[09:28:23.099]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.099]                               info, version)
[09:28:23.099]                           }
[09:28:23.099]                           base::stop(msg)
[09:28:23.099]                         }
[09:28:23.099]                       })
[09:28:23.099]                     }
[09:28:23.099]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.099]                     base::options(mc.cores = 1L)
[09:28:23.099]                   }
[09:28:23.099]                   ...future.strategy.old <- future::plan("list")
[09:28:23.099]                   options(future.plan = NULL)
[09:28:23.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.099]                 }
[09:28:23.099]                 ...future.workdir <- getwd()
[09:28:23.099]             }
[09:28:23.099]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.099]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.099]         }
[09:28:23.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.099]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.099]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.099]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.099]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.099]             base::names(...future.oldOptions))
[09:28:23.099]     }
[09:28:23.099]     if (FALSE) {
[09:28:23.099]     }
[09:28:23.099]     else {
[09:28:23.099]         if (TRUE) {
[09:28:23.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.099]                 open = "w")
[09:28:23.099]         }
[09:28:23.099]         else {
[09:28:23.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.099]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.099]         }
[09:28:23.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.099]             base::sink(type = "output", split = FALSE)
[09:28:23.099]             base::close(...future.stdout)
[09:28:23.099]         }, add = TRUE)
[09:28:23.099]     }
[09:28:23.099]     ...future.frame <- base::sys.nframe()
[09:28:23.099]     ...future.conditions <- base::list()
[09:28:23.099]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.099]     if (FALSE) {
[09:28:23.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.099]     }
[09:28:23.099]     ...future.result <- base::tryCatch({
[09:28:23.099]         base::withCallingHandlers({
[09:28:23.099]             ...future.value <- base::withVisible(base::local({
[09:28:23.099]                 withCallingHandlers({
[09:28:23.099]                   {
[09:28:23.099]                     do.call(function(...) {
[09:28:23.099]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.099]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.099]                         ...future.globals.maxSize)) {
[09:28:23.099]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.099]                         on.exit(options(oopts), add = TRUE)
[09:28:23.099]                       }
[09:28:23.099]                       {
[09:28:23.099]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.099]                           FUN = function(jj) {
[09:28:23.099]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.099]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.099]                           })
[09:28:23.099]                       }
[09:28:23.099]                     }, args = future.call.arguments)
[09:28:23.099]                   }
[09:28:23.099]                 }, immediateCondition = function(cond) {
[09:28:23.099]                   save_rds <- function (object, pathname, ...) 
[09:28:23.099]                   {
[09:28:23.099]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.099]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.099]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.099]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.099]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.099]                         fi_tmp[["mtime"]])
[09:28:23.099]                     }
[09:28:23.099]                     tryCatch({
[09:28:23.099]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.099]                     }, error = function(ex) {
[09:28:23.099]                       msg <- conditionMessage(ex)
[09:28:23.099]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.099]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.099]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.099]                         fi_tmp[["mtime"]], msg)
[09:28:23.099]                       ex$message <- msg
[09:28:23.099]                       stop(ex)
[09:28:23.099]                     })
[09:28:23.099]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.099]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.099]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.099]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.099]                       fi <- file.info(pathname)
[09:28:23.099]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.099]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.099]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.099]                         fi[["size"]], fi[["mtime"]])
[09:28:23.099]                       stop(msg)
[09:28:23.099]                     }
[09:28:23.099]                     invisible(pathname)
[09:28:23.099]                   }
[09:28:23.099]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.099]                     rootPath = tempdir()) 
[09:28:23.099]                   {
[09:28:23.099]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.099]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.099]                       tmpdir = path, fileext = ".rds")
[09:28:23.099]                     save_rds(obj, file)
[09:28:23.099]                   }
[09:28:23.099]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.099]                   {
[09:28:23.099]                     inherits <- base::inherits
[09:28:23.099]                     invokeRestart <- base::invokeRestart
[09:28:23.099]                     is.null <- base::is.null
[09:28:23.099]                     muffled <- FALSE
[09:28:23.099]                     if (inherits(cond, "message")) {
[09:28:23.099]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.099]                       if (muffled) 
[09:28:23.099]                         invokeRestart("muffleMessage")
[09:28:23.099]                     }
[09:28:23.099]                     else if (inherits(cond, "warning")) {
[09:28:23.099]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.099]                       if (muffled) 
[09:28:23.099]                         invokeRestart("muffleWarning")
[09:28:23.099]                     }
[09:28:23.099]                     else if (inherits(cond, "condition")) {
[09:28:23.099]                       if (!is.null(pattern)) {
[09:28:23.099]                         computeRestarts <- base::computeRestarts
[09:28:23.099]                         grepl <- base::grepl
[09:28:23.099]                         restarts <- computeRestarts(cond)
[09:28:23.099]                         for (restart in restarts) {
[09:28:23.099]                           name <- restart$name
[09:28:23.099]                           if (is.null(name)) 
[09:28:23.099]                             next
[09:28:23.099]                           if (!grepl(pattern, name)) 
[09:28:23.099]                             next
[09:28:23.099]                           invokeRestart(restart)
[09:28:23.099]                           muffled <- TRUE
[09:28:23.099]                           break
[09:28:23.099]                         }
[09:28:23.099]                       }
[09:28:23.099]                     }
[09:28:23.099]                     invisible(muffled)
[09:28:23.099]                   }
[09:28:23.099]                   muffleCondition(cond)
[09:28:23.099]                 })
[09:28:23.099]             }))
[09:28:23.099]             future::FutureResult(value = ...future.value$value, 
[09:28:23.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.099]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.099]                     ...future.globalenv.names))
[09:28:23.099]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.099]         }, condition = base::local({
[09:28:23.099]             c <- base::c
[09:28:23.099]             inherits <- base::inherits
[09:28:23.099]             invokeRestart <- base::invokeRestart
[09:28:23.099]             length <- base::length
[09:28:23.099]             list <- base::list
[09:28:23.099]             seq.int <- base::seq.int
[09:28:23.099]             signalCondition <- base::signalCondition
[09:28:23.099]             sys.calls <- base::sys.calls
[09:28:23.099]             `[[` <- base::`[[`
[09:28:23.099]             `+` <- base::`+`
[09:28:23.099]             `<<-` <- base::`<<-`
[09:28:23.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.099]                   3L)]
[09:28:23.099]             }
[09:28:23.099]             function(cond) {
[09:28:23.099]                 is_error <- inherits(cond, "error")
[09:28:23.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.099]                   NULL)
[09:28:23.099]                 if (is_error) {
[09:28:23.099]                   sessionInformation <- function() {
[09:28:23.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.099]                       search = base::search(), system = base::Sys.info())
[09:28:23.099]                   }
[09:28:23.099]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.099]                     cond$call), session = sessionInformation(), 
[09:28:23.099]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.099]                   signalCondition(cond)
[09:28:23.099]                 }
[09:28:23.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.099]                 "immediateCondition"))) {
[09:28:23.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.099]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.099]                   if (TRUE && !signal) {
[09:28:23.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.099]                     {
[09:28:23.099]                       inherits <- base::inherits
[09:28:23.099]                       invokeRestart <- base::invokeRestart
[09:28:23.099]                       is.null <- base::is.null
[09:28:23.099]                       muffled <- FALSE
[09:28:23.099]                       if (inherits(cond, "message")) {
[09:28:23.099]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.099]                         if (muffled) 
[09:28:23.099]                           invokeRestart("muffleMessage")
[09:28:23.099]                       }
[09:28:23.099]                       else if (inherits(cond, "warning")) {
[09:28:23.099]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.099]                         if (muffled) 
[09:28:23.099]                           invokeRestart("muffleWarning")
[09:28:23.099]                       }
[09:28:23.099]                       else if (inherits(cond, "condition")) {
[09:28:23.099]                         if (!is.null(pattern)) {
[09:28:23.099]                           computeRestarts <- base::computeRestarts
[09:28:23.099]                           grepl <- base::grepl
[09:28:23.099]                           restarts <- computeRestarts(cond)
[09:28:23.099]                           for (restart in restarts) {
[09:28:23.099]                             name <- restart$name
[09:28:23.099]                             if (is.null(name)) 
[09:28:23.099]                               next
[09:28:23.099]                             if (!grepl(pattern, name)) 
[09:28:23.099]                               next
[09:28:23.099]                             invokeRestart(restart)
[09:28:23.099]                             muffled <- TRUE
[09:28:23.099]                             break
[09:28:23.099]                           }
[09:28:23.099]                         }
[09:28:23.099]                       }
[09:28:23.099]                       invisible(muffled)
[09:28:23.099]                     }
[09:28:23.099]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.099]                   }
[09:28:23.099]                 }
[09:28:23.099]                 else {
[09:28:23.099]                   if (TRUE) {
[09:28:23.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.099]                     {
[09:28:23.099]                       inherits <- base::inherits
[09:28:23.099]                       invokeRestart <- base::invokeRestart
[09:28:23.099]                       is.null <- base::is.null
[09:28:23.099]                       muffled <- FALSE
[09:28:23.099]                       if (inherits(cond, "message")) {
[09:28:23.099]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.099]                         if (muffled) 
[09:28:23.099]                           invokeRestart("muffleMessage")
[09:28:23.099]                       }
[09:28:23.099]                       else if (inherits(cond, "warning")) {
[09:28:23.099]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.099]                         if (muffled) 
[09:28:23.099]                           invokeRestart("muffleWarning")
[09:28:23.099]                       }
[09:28:23.099]                       else if (inherits(cond, "condition")) {
[09:28:23.099]                         if (!is.null(pattern)) {
[09:28:23.099]                           computeRestarts <- base::computeRestarts
[09:28:23.099]                           grepl <- base::grepl
[09:28:23.099]                           restarts <- computeRestarts(cond)
[09:28:23.099]                           for (restart in restarts) {
[09:28:23.099]                             name <- restart$name
[09:28:23.099]                             if (is.null(name)) 
[09:28:23.099]                               next
[09:28:23.099]                             if (!grepl(pattern, name)) 
[09:28:23.099]                               next
[09:28:23.099]                             invokeRestart(restart)
[09:28:23.099]                             muffled <- TRUE
[09:28:23.099]                             break
[09:28:23.099]                           }
[09:28:23.099]                         }
[09:28:23.099]                       }
[09:28:23.099]                       invisible(muffled)
[09:28:23.099]                     }
[09:28:23.099]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.099]                   }
[09:28:23.099]                 }
[09:28:23.099]             }
[09:28:23.099]         }))
[09:28:23.099]     }, error = function(ex) {
[09:28:23.099]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.099]                 ...future.rng), started = ...future.startTime, 
[09:28:23.099]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.099]             version = "1.8"), class = "FutureResult")
[09:28:23.099]     }, finally = {
[09:28:23.099]         if (!identical(...future.workdir, getwd())) 
[09:28:23.099]             setwd(...future.workdir)
[09:28:23.099]         {
[09:28:23.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.099]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.099]             }
[09:28:23.099]             base::options(...future.oldOptions)
[09:28:23.099]             if (.Platform$OS.type == "windows") {
[09:28:23.099]                 old_names <- names(...future.oldEnvVars)
[09:28:23.099]                 envs <- base::Sys.getenv()
[09:28:23.099]                 names <- names(envs)
[09:28:23.099]                 common <- intersect(names, old_names)
[09:28:23.099]                 added <- setdiff(names, old_names)
[09:28:23.099]                 removed <- setdiff(old_names, names)
[09:28:23.099]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.099]                   envs[common]]
[09:28:23.099]                 NAMES <- toupper(changed)
[09:28:23.099]                 args <- list()
[09:28:23.099]                 for (kk in seq_along(NAMES)) {
[09:28:23.099]                   name <- changed[[kk]]
[09:28:23.099]                   NAME <- NAMES[[kk]]
[09:28:23.099]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.099]                     next
[09:28:23.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.099]                 }
[09:28:23.099]                 NAMES <- toupper(added)
[09:28:23.099]                 for (kk in seq_along(NAMES)) {
[09:28:23.099]                   name <- added[[kk]]
[09:28:23.099]                   NAME <- NAMES[[kk]]
[09:28:23.099]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.099]                     next
[09:28:23.099]                   args[[name]] <- ""
[09:28:23.099]                 }
[09:28:23.099]                 NAMES <- toupper(removed)
[09:28:23.099]                 for (kk in seq_along(NAMES)) {
[09:28:23.099]                   name <- removed[[kk]]
[09:28:23.099]                   NAME <- NAMES[[kk]]
[09:28:23.099]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.099]                     next
[09:28:23.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.099]                 }
[09:28:23.099]                 if (length(args) > 0) 
[09:28:23.099]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.099]             }
[09:28:23.099]             else {
[09:28:23.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.099]             }
[09:28:23.099]             {
[09:28:23.099]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.099]                   0L) {
[09:28:23.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.099]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.099]                   base::options(opts)
[09:28:23.099]                 }
[09:28:23.099]                 {
[09:28:23.099]                   {
[09:28:23.099]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.099]                     NULL
[09:28:23.099]                   }
[09:28:23.099]                   options(future.plan = NULL)
[09:28:23.099]                   if (is.na(NA_character_)) 
[09:28:23.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.099]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.099]                     .init = FALSE)
[09:28:23.099]                 }
[09:28:23.099]             }
[09:28:23.099]         }
[09:28:23.099]     })
[09:28:23.099]     if (TRUE) {
[09:28:23.099]         base::sink(type = "output", split = FALSE)
[09:28:23.099]         if (TRUE) {
[09:28:23.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.099]         }
[09:28:23.099]         else {
[09:28:23.099]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.099]         }
[09:28:23.099]         base::close(...future.stdout)
[09:28:23.099]         ...future.stdout <- NULL
[09:28:23.099]     }
[09:28:23.099]     ...future.result$conditions <- ...future.conditions
[09:28:23.099]     ...future.result$finished <- base::Sys.time()
[09:28:23.099]     ...future.result
[09:28:23.099] }
[09:28:23.102] assign_globals() ...
[09:28:23.102] List of 5
[09:28:23.102]  $ ...future.FUN            :function (object, ...)  
[09:28:23.102]  $ future.call.arguments    : list()
[09:28:23.102]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.102]  $ ...future.elements_ii    :List of 2
[09:28:23.102]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:23.102]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:23.102]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.102]   ..$ :'data.frame':	18 obs. of  2 variables:
[09:28:23.102]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:23.102]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.102]  $ ...future.seeds_ii       : NULL
[09:28:23.102]  $ ...future.globals.maxSize: NULL
[09:28:23.102]  - attr(*, "where")=List of 5
[09:28:23.102]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.102]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.102]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.102]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.102]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.102]  - attr(*, "resolved")= logi FALSE
[09:28:23.102]  - attr(*, "total_size")= num 1240
[09:28:23.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.102]  - attr(*, "already-done")= logi TRUE
[09:28:23.110] - copied ‘...future.FUN’ to environment
[09:28:23.111] - copied ‘future.call.arguments’ to environment
[09:28:23.111] - copied ‘...future.elements_ii’ to environment
[09:28:23.111] - copied ‘...future.seeds_ii’ to environment
[09:28:23.111] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.111] assign_globals() ... done
[09:28:23.111] requestCore(): workers = 2
[09:28:23.119] MulticoreFuture started
[09:28:23.119] - Launch lazy future ... done
[09:28:23.120] plan(): Setting new future strategy stack:
[09:28:23.120] run() for ‘MulticoreFuture’ ... done
[09:28:23.120] Created future:
[09:28:23.120] List of future strategies:
[09:28:23.120] 1. sequential:
[09:28:23.120]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.120]    - tweaked: FALSE
[09:28:23.120]    - call: NULL
[09:28:23.122] plan(): nbrOfWorkers() = 1
[09:28:23.127] plan(): Setting new future strategy stack:
[09:28:23.127] List of future strategies:
[09:28:23.127] 1. multicore:
[09:28:23.127]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.127]    - tweaked: FALSE
[09:28:23.127]    - call: plan(strategy)
[09:28:23.132] plan(): nbrOfWorkers() = 2
[09:28:23.121] MulticoreFuture:
[09:28:23.121] Label: ‘future_by-2’
[09:28:23.121] Expression:
[09:28:23.121] {
[09:28:23.121]     do.call(function(...) {
[09:28:23.121]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.121]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.121]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.121]             on.exit(options(oopts), add = TRUE)
[09:28:23.121]         }
[09:28:23.121]         {
[09:28:23.121]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.121]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.121]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.121]             })
[09:28:23.121]         }
[09:28:23.121]     }, args = future.call.arguments)
[09:28:23.121] }
[09:28:23.121] Lazy evaluation: FALSE
[09:28:23.121] Asynchronous evaluation: TRUE
[09:28:23.121] Local evaluation: TRUE
[09:28:23.121] Environment: R_GlobalEnv
[09:28:23.121] Capture standard output: TRUE
[09:28:23.121] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.121] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:23.121] Packages: <none>
[09:28:23.121] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.121] Resolved: TRUE
[09:28:23.121] Value: <not collected>
[09:28:23.121] Conditions captured: <none>
[09:28:23.121] Early signaling: FALSE
[09:28:23.121] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.121] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.133] Chunk #2 of 2 ... DONE
[09:28:23.133] Launching 2 futures (chunks) ... DONE
[09:28:23.133] Resolving 2 futures (chunks) ...
[09:28:23.134] resolve() on list ...
[09:28:23.134]  recursive: 0
[09:28:23.134]  length: 2
[09:28:23.134] 
[09:28:23.135] Future #1
[09:28:23.135] result() for MulticoreFuture ...
[09:28:23.137] result() for MulticoreFuture ...
[09:28:23.137] result() for MulticoreFuture ... done
[09:28:23.137] result() for MulticoreFuture ... done
[09:28:23.137] result() for MulticoreFuture ...
[09:28:23.137] result() for MulticoreFuture ... done
[09:28:23.138] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:23.138] - nx: 2
[09:28:23.138] - relay: TRUE
[09:28:23.138] - stdout: TRUE
[09:28:23.138] - signal: TRUE
[09:28:23.138] - resignal: FALSE
[09:28:23.139] - force: TRUE
[09:28:23.139] - relayed: [n=2] FALSE, FALSE
[09:28:23.139] - queued futures: [n=2] FALSE, FALSE
[09:28:23.139]  - until=1
[09:28:23.139]  - relaying element #1
[09:28:23.139] result() for MulticoreFuture ...
[09:28:23.140] result() for MulticoreFuture ... done
[09:28:23.140] result() for MulticoreFuture ...
[09:28:23.140] result() for MulticoreFuture ... done
[09:28:23.140] result() for MulticoreFuture ...
[09:28:23.140] result() for MulticoreFuture ... done
[09:28:23.140] result() for MulticoreFuture ...
[09:28:23.141] result() for MulticoreFuture ... done
[09:28:23.141] - relayed: [n=2] TRUE, FALSE
[09:28:23.141] - queued futures: [n=2] TRUE, FALSE
[09:28:23.141] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:23.141]  length: 1 (resolved future 1)
[09:28:23.141] Future #2
[09:28:23.142] result() for MulticoreFuture ...
[09:28:23.142] result() for MulticoreFuture ...
[09:28:23.142] result() for MulticoreFuture ... done
[09:28:23.142] result() for MulticoreFuture ... done
[09:28:23.143] result() for MulticoreFuture ...
[09:28:23.143] result() for MulticoreFuture ... done
[09:28:23.143] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:23.143] - nx: 2
[09:28:23.143] - relay: TRUE
[09:28:23.143] - stdout: TRUE
[09:28:23.143] - signal: TRUE
[09:28:23.143] - resignal: FALSE
[09:28:23.144] - force: TRUE
[09:28:23.144] - relayed: [n=2] TRUE, FALSE
[09:28:23.144] - queued futures: [n=2] TRUE, FALSE
[09:28:23.144]  - until=2
[09:28:23.144]  - relaying element #2
[09:28:23.144] result() for MulticoreFuture ...
[09:28:23.144] result() for MulticoreFuture ... done
[09:28:23.144] result() for MulticoreFuture ...
[09:28:23.145] result() for MulticoreFuture ... done
[09:28:23.145] result() for MulticoreFuture ...
[09:28:23.145] result() for MulticoreFuture ... done
[09:28:23.145] result() for MulticoreFuture ...
[09:28:23.145] result() for MulticoreFuture ... done
[09:28:23.145] - relayed: [n=2] TRUE, TRUE
[09:28:23.145] - queued futures: [n=2] TRUE, TRUE
[09:28:23.145] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:23.145]  length: 0 (resolved future 2)
[09:28:23.146] Relaying remaining futures
[09:28:23.146] signalConditionsASAP(NULL, pos=0) ...
[09:28:23.146] - nx: 2
[09:28:23.146] - relay: TRUE
[09:28:23.146] - stdout: TRUE
[09:28:23.146] - signal: TRUE
[09:28:23.146] - resignal: FALSE
[09:28:23.146] - force: TRUE
[09:28:23.146] - relayed: [n=2] TRUE, TRUE
[09:28:23.146] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:23.147] - relayed: [n=2] TRUE, TRUE
[09:28:23.147] - queued futures: [n=2] TRUE, TRUE
[09:28:23.147] signalConditionsASAP(NULL, pos=0) ... done
[09:28:23.147] resolve() on list ... DONE
[09:28:23.147] result() for MulticoreFuture ...
[09:28:23.147] result() for MulticoreFuture ... done
[09:28:23.147] result() for MulticoreFuture ...
[09:28:23.147] result() for MulticoreFuture ... done
[09:28:23.147] result() for MulticoreFuture ...
[09:28:23.148] result() for MulticoreFuture ... done
[09:28:23.148] result() for MulticoreFuture ...
[09:28:23.148] result() for MulticoreFuture ... done
[09:28:23.148]  - Number of value chunks collected: 2
[09:28:23.148] Resolving 2 futures (chunks) ... DONE
[09:28:23.148] Reducing values from 2 chunks ...
[09:28:23.148]  - Number of values collected after concatenation: 3
[09:28:23.148]  - Number of values expected: 3
[09:28:23.148] Reducing values from 2 chunks ... DONE
[09:28:23.149] future_lapply() ... DONE
[09:28:23.149] future_by_internal() ... DONE
[09:28:23.149] future_by_internal() ...
[09:28:23.149] future_lapply() ...
[09:28:23.154] Number of chunks: 2
[09:28:23.154] getGlobalsAndPackagesXApply() ...
[09:28:23.154]  - future.globals: TRUE
[09:28:23.154] getGlobalsAndPackages() ...
[09:28:23.155] Searching for globals...
[09:28:23.156] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:23.156] Searching for globals ... DONE
[09:28:23.156] Resolving globals: FALSE
[09:28:23.156] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:23.157] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:23.157] - globals: [1] ‘FUN’
[09:28:23.157] 
[09:28:23.157] getGlobalsAndPackages() ... DONE
[09:28:23.159]  - globals found/used: [n=1] ‘FUN’
[09:28:23.159]  - needed namespaces: [n=0] 
[09:28:23.160] Finding globals ... DONE
[09:28:23.160]  - use_args: TRUE
[09:28:23.160]  - Getting '...' globals ...
[09:28:23.160] resolve() on list ...
[09:28:23.160]  recursive: 0
[09:28:23.161]  length: 1
[09:28:23.161]  elements: ‘...’
[09:28:23.161]  length: 0 (resolved future 1)
[09:28:23.161] resolve() on list ... DONE
[09:28:23.161]    - '...' content: [n=1] ‘digits’
[09:28:23.161] List of 1
[09:28:23.161]  $ ...:List of 1
[09:28:23.161]   ..$ digits: int 2
[09:28:23.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.161]  - attr(*, "where")=List of 1
[09:28:23.161]   ..$ ...:<environment: 0x555b0a4d4910> 
[09:28:23.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.161]  - attr(*, "resolved")= logi TRUE
[09:28:23.161]  - attr(*, "total_size")= num NA
[09:28:23.165]  - Getting '...' globals ... DONE
[09:28:23.165] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:23.165] List of 2
[09:28:23.165]  $ ...future.FUN:function (object, ...)  
[09:28:23.165]  $ ...          :List of 1
[09:28:23.165]   ..$ digits: int 2
[09:28:23.165]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.165]  - attr(*, "where")=List of 2
[09:28:23.165]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:23.165]   ..$ ...          :<environment: 0x555b0a4d4910> 
[09:28:23.165]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.165]  - attr(*, "resolved")= logi FALSE
[09:28:23.165]  - attr(*, "total_size")= num 1296
[09:28:23.168] Packages to be attached in all futures: [n=0] 
[09:28:23.168] getGlobalsAndPackagesXApply() ... DONE
[09:28:23.168] Number of futures (= number of chunks): 2
[09:28:23.168] Launching 2 futures (chunks) ...
[09:28:23.169] Chunk #1 of 2 ...
[09:28:23.169]  - Finding globals in 'X' for chunk #1 ...
[09:28:23.169] getGlobalsAndPackages() ...
[09:28:23.169] Searching for globals...
[09:28:23.169] 
[09:28:23.169] Searching for globals ... DONE
[09:28:23.169] - globals: [0] <none>
[09:28:23.169] getGlobalsAndPackages() ... DONE
[09:28:23.169]    + additional globals found: [n=0] 
[09:28:23.170]    + additional namespaces needed: [n=0] 
[09:28:23.170]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:23.170]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.170]  - seeds: <none>
[09:28:23.170]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.170] getGlobalsAndPackages() ...
[09:28:23.170] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.170] Resolving globals: FALSE
[09:28:23.170] Tweak future expression to call with '...' arguments ...
[09:28:23.170] {
[09:28:23.170]     do.call(function(...) {
[09:28:23.170]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.170]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.170]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.170]             on.exit(options(oopts), add = TRUE)
[09:28:23.170]         }
[09:28:23.170]         {
[09:28:23.170]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.170]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.170]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.170]             })
[09:28:23.170]         }
[09:28:23.170]     }, args = future.call.arguments)
[09:28:23.170] }
[09:28:23.171] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.171] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.171] 
[09:28:23.171] getGlobalsAndPackages() ... DONE
[09:28:23.172] run() for ‘Future’ ...
[09:28:23.172] - state: ‘created’
[09:28:23.172] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.175] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.175] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.175]   - Field: ‘label’
[09:28:23.176]   - Field: ‘local’
[09:28:23.176]   - Field: ‘owner’
[09:28:23.176]   - Field: ‘envir’
[09:28:23.176]   - Field: ‘workers’
[09:28:23.176]   - Field: ‘packages’
[09:28:23.176]   - Field: ‘gc’
[09:28:23.176]   - Field: ‘job’
[09:28:23.176]   - Field: ‘conditions’
[09:28:23.176]   - Field: ‘expr’
[09:28:23.177]   - Field: ‘uuid’
[09:28:23.177]   - Field: ‘seed’
[09:28:23.177]   - Field: ‘version’
[09:28:23.177]   - Field: ‘result’
[09:28:23.177]   - Field: ‘asynchronous’
[09:28:23.177]   - Field: ‘calls’
[09:28:23.177]   - Field: ‘globals’
[09:28:23.177]   - Field: ‘stdout’
[09:28:23.177]   - Field: ‘earlySignal’
[09:28:23.177]   - Field: ‘lazy’
[09:28:23.177]   - Field: ‘state’
[09:28:23.177] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.178] - Launch lazy future ...
[09:28:23.178] Packages needed by the future expression (n = 0): <none>
[09:28:23.178] Packages needed by future strategies (n = 0): <none>
[09:28:23.178] {
[09:28:23.178]     {
[09:28:23.178]         {
[09:28:23.178]             ...future.startTime <- base::Sys.time()
[09:28:23.178]             {
[09:28:23.178]                 {
[09:28:23.178]                   {
[09:28:23.178]                     {
[09:28:23.178]                       base::local({
[09:28:23.178]                         has_future <- base::requireNamespace("future", 
[09:28:23.178]                           quietly = TRUE)
[09:28:23.178]                         if (has_future) {
[09:28:23.178]                           ns <- base::getNamespace("future")
[09:28:23.178]                           version <- ns[[".package"]][["version"]]
[09:28:23.178]                           if (is.null(version)) 
[09:28:23.178]                             version <- utils::packageVersion("future")
[09:28:23.178]                         }
[09:28:23.178]                         else {
[09:28:23.178]                           version <- NULL
[09:28:23.178]                         }
[09:28:23.178]                         if (!has_future || version < "1.8.0") {
[09:28:23.178]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.178]                             "", base::R.version$version.string), 
[09:28:23.178]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:23.178]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:23.178]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.178]                               "release", "version")], collapse = " "), 
[09:28:23.178]                             hostname = base::Sys.info()[["nodename"]])
[09:28:23.178]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.178]                             info)
[09:28:23.178]                           info <- base::paste(info, collapse = "; ")
[09:28:23.178]                           if (!has_future) {
[09:28:23.178]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.178]                               info)
[09:28:23.178]                           }
[09:28:23.178]                           else {
[09:28:23.178]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.178]                               info, version)
[09:28:23.178]                           }
[09:28:23.178]                           base::stop(msg)
[09:28:23.178]                         }
[09:28:23.178]                       })
[09:28:23.178]                     }
[09:28:23.178]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.178]                     base::options(mc.cores = 1L)
[09:28:23.178]                   }
[09:28:23.178]                   ...future.strategy.old <- future::plan("list")
[09:28:23.178]                   options(future.plan = NULL)
[09:28:23.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.178]                 }
[09:28:23.178]                 ...future.workdir <- getwd()
[09:28:23.178]             }
[09:28:23.178]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.178]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.178]         }
[09:28:23.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.178]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.178]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.178]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.178]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.178]             base::names(...future.oldOptions))
[09:28:23.178]     }
[09:28:23.178]     if (FALSE) {
[09:28:23.178]     }
[09:28:23.178]     else {
[09:28:23.178]         if (TRUE) {
[09:28:23.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.178]                 open = "w")
[09:28:23.178]         }
[09:28:23.178]         else {
[09:28:23.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.178]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.178]         }
[09:28:23.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.178]             base::sink(type = "output", split = FALSE)
[09:28:23.178]             base::close(...future.stdout)
[09:28:23.178]         }, add = TRUE)
[09:28:23.178]     }
[09:28:23.178]     ...future.frame <- base::sys.nframe()
[09:28:23.178]     ...future.conditions <- base::list()
[09:28:23.178]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.178]     if (FALSE) {
[09:28:23.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.178]     }
[09:28:23.178]     ...future.result <- base::tryCatch({
[09:28:23.178]         base::withCallingHandlers({
[09:28:23.178]             ...future.value <- base::withVisible(base::local({
[09:28:23.178]                 withCallingHandlers({
[09:28:23.178]                   {
[09:28:23.178]                     do.call(function(...) {
[09:28:23.178]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.178]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.178]                         ...future.globals.maxSize)) {
[09:28:23.178]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.178]                         on.exit(options(oopts), add = TRUE)
[09:28:23.178]                       }
[09:28:23.178]                       {
[09:28:23.178]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.178]                           FUN = function(jj) {
[09:28:23.178]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.178]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.178]                           })
[09:28:23.178]                       }
[09:28:23.178]                     }, args = future.call.arguments)
[09:28:23.178]                   }
[09:28:23.178]                 }, immediateCondition = function(cond) {
[09:28:23.178]                   save_rds <- function (object, pathname, ...) 
[09:28:23.178]                   {
[09:28:23.178]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.178]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.178]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.178]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.178]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.178]                         fi_tmp[["mtime"]])
[09:28:23.178]                     }
[09:28:23.178]                     tryCatch({
[09:28:23.178]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.178]                     }, error = function(ex) {
[09:28:23.178]                       msg <- conditionMessage(ex)
[09:28:23.178]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.178]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.178]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.178]                         fi_tmp[["mtime"]], msg)
[09:28:23.178]                       ex$message <- msg
[09:28:23.178]                       stop(ex)
[09:28:23.178]                     })
[09:28:23.178]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.178]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.178]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.178]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.178]                       fi <- file.info(pathname)
[09:28:23.178]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.178]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.178]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.178]                         fi[["size"]], fi[["mtime"]])
[09:28:23.178]                       stop(msg)
[09:28:23.178]                     }
[09:28:23.178]                     invisible(pathname)
[09:28:23.178]                   }
[09:28:23.178]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.178]                     rootPath = tempdir()) 
[09:28:23.178]                   {
[09:28:23.178]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.178]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.178]                       tmpdir = path, fileext = ".rds")
[09:28:23.178]                     save_rds(obj, file)
[09:28:23.178]                   }
[09:28:23.178]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.178]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.178]                   {
[09:28:23.178]                     inherits <- base::inherits
[09:28:23.178]                     invokeRestart <- base::invokeRestart
[09:28:23.178]                     is.null <- base::is.null
[09:28:23.178]                     muffled <- FALSE
[09:28:23.178]                     if (inherits(cond, "message")) {
[09:28:23.178]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.178]                       if (muffled) 
[09:28:23.178]                         invokeRestart("muffleMessage")
[09:28:23.178]                     }
[09:28:23.178]                     else if (inherits(cond, "warning")) {
[09:28:23.178]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.178]                       if (muffled) 
[09:28:23.178]                         invokeRestart("muffleWarning")
[09:28:23.178]                     }
[09:28:23.178]                     else if (inherits(cond, "condition")) {
[09:28:23.178]                       if (!is.null(pattern)) {
[09:28:23.178]                         computeRestarts <- base::computeRestarts
[09:28:23.178]                         grepl <- base::grepl
[09:28:23.178]                         restarts <- computeRestarts(cond)
[09:28:23.178]                         for (restart in restarts) {
[09:28:23.178]                           name <- restart$name
[09:28:23.178]                           if (is.null(name)) 
[09:28:23.178]                             next
[09:28:23.178]                           if (!grepl(pattern, name)) 
[09:28:23.178]                             next
[09:28:23.178]                           invokeRestart(restart)
[09:28:23.178]                           muffled <- TRUE
[09:28:23.178]                           break
[09:28:23.178]                         }
[09:28:23.178]                       }
[09:28:23.178]                     }
[09:28:23.178]                     invisible(muffled)
[09:28:23.178]                   }
[09:28:23.178]                   muffleCondition(cond)
[09:28:23.178]                 })
[09:28:23.178]             }))
[09:28:23.178]             future::FutureResult(value = ...future.value$value, 
[09:28:23.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.178]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.178]                     ...future.globalenv.names))
[09:28:23.178]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.178]         }, condition = base::local({
[09:28:23.178]             c <- base::c
[09:28:23.178]             inherits <- base::inherits
[09:28:23.178]             invokeRestart <- base::invokeRestart
[09:28:23.178]             length <- base::length
[09:28:23.178]             list <- base::list
[09:28:23.178]             seq.int <- base::seq.int
[09:28:23.178]             signalCondition <- base::signalCondition
[09:28:23.178]             sys.calls <- base::sys.calls
[09:28:23.178]             `[[` <- base::`[[`
[09:28:23.178]             `+` <- base::`+`
[09:28:23.178]             `<<-` <- base::`<<-`
[09:28:23.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.178]                   3L)]
[09:28:23.178]             }
[09:28:23.178]             function(cond) {
[09:28:23.178]                 is_error <- inherits(cond, "error")
[09:28:23.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.178]                   NULL)
[09:28:23.178]                 if (is_error) {
[09:28:23.178]                   sessionInformation <- function() {
[09:28:23.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.178]                       search = base::search(), system = base::Sys.info())
[09:28:23.178]                   }
[09:28:23.178]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.178]                     cond$call), session = sessionInformation(), 
[09:28:23.178]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.178]                   signalCondition(cond)
[09:28:23.178]                 }
[09:28:23.178]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.178]                 "immediateCondition"))) {
[09:28:23.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.178]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.178]                   if (TRUE && !signal) {
[09:28:23.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.178]                     {
[09:28:23.178]                       inherits <- base::inherits
[09:28:23.178]                       invokeRestart <- base::invokeRestart
[09:28:23.178]                       is.null <- base::is.null
[09:28:23.178]                       muffled <- FALSE
[09:28:23.178]                       if (inherits(cond, "message")) {
[09:28:23.178]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.178]                         if (muffled) 
[09:28:23.178]                           invokeRestart("muffleMessage")
[09:28:23.178]                       }
[09:28:23.178]                       else if (inherits(cond, "warning")) {
[09:28:23.178]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.178]                         if (muffled) 
[09:28:23.178]                           invokeRestart("muffleWarning")
[09:28:23.178]                       }
[09:28:23.178]                       else if (inherits(cond, "condition")) {
[09:28:23.178]                         if (!is.null(pattern)) {
[09:28:23.178]                           computeRestarts <- base::computeRestarts
[09:28:23.178]                           grepl <- base::grepl
[09:28:23.178]                           restarts <- computeRestarts(cond)
[09:28:23.178]                           for (restart in restarts) {
[09:28:23.178]                             name <- restart$name
[09:28:23.178]                             if (is.null(name)) 
[09:28:23.178]                               next
[09:28:23.178]                             if (!grepl(pattern, name)) 
[09:28:23.178]                               next
[09:28:23.178]                             invokeRestart(restart)
[09:28:23.178]                             muffled <- TRUE
[09:28:23.178]                             break
[09:28:23.178]                           }
[09:28:23.178]                         }
[09:28:23.178]                       }
[09:28:23.178]                       invisible(muffled)
[09:28:23.178]                     }
[09:28:23.178]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.178]                   }
[09:28:23.178]                 }
[09:28:23.178]                 else {
[09:28:23.178]                   if (TRUE) {
[09:28:23.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.178]                     {
[09:28:23.178]                       inherits <- base::inherits
[09:28:23.178]                       invokeRestart <- base::invokeRestart
[09:28:23.178]                       is.null <- base::is.null
[09:28:23.178]                       muffled <- FALSE
[09:28:23.178]                       if (inherits(cond, "message")) {
[09:28:23.178]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.178]                         if (muffled) 
[09:28:23.178]                           invokeRestart("muffleMessage")
[09:28:23.178]                       }
[09:28:23.178]                       else if (inherits(cond, "warning")) {
[09:28:23.178]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.178]                         if (muffled) 
[09:28:23.178]                           invokeRestart("muffleWarning")
[09:28:23.178]                       }
[09:28:23.178]                       else if (inherits(cond, "condition")) {
[09:28:23.178]                         if (!is.null(pattern)) {
[09:28:23.178]                           computeRestarts <- base::computeRestarts
[09:28:23.178]                           grepl <- base::grepl
[09:28:23.178]                           restarts <- computeRestarts(cond)
[09:28:23.178]                           for (restart in restarts) {
[09:28:23.178]                             name <- restart$name
[09:28:23.178]                             if (is.null(name)) 
[09:28:23.178]                               next
[09:28:23.178]                             if (!grepl(pattern, name)) 
[09:28:23.178]                               next
[09:28:23.178]                             invokeRestart(restart)
[09:28:23.178]                             muffled <- TRUE
[09:28:23.178]                             break
[09:28:23.178]                           }
[09:28:23.178]                         }
[09:28:23.178]                       }
[09:28:23.178]                       invisible(muffled)
[09:28:23.178]                     }
[09:28:23.178]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.178]                   }
[09:28:23.178]                 }
[09:28:23.178]             }
[09:28:23.178]         }))
[09:28:23.178]     }, error = function(ex) {
[09:28:23.178]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.178]                 ...future.rng), started = ...future.startTime, 
[09:28:23.178]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.178]             version = "1.8"), class = "FutureResult")
[09:28:23.178]     }, finally = {
[09:28:23.178]         if (!identical(...future.workdir, getwd())) 
[09:28:23.178]             setwd(...future.workdir)
[09:28:23.178]         {
[09:28:23.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.178]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.178]             }
[09:28:23.178]             base::options(...future.oldOptions)
[09:28:23.178]             if (.Platform$OS.type == "windows") {
[09:28:23.178]                 old_names <- names(...future.oldEnvVars)
[09:28:23.178]                 envs <- base::Sys.getenv()
[09:28:23.178]                 names <- names(envs)
[09:28:23.178]                 common <- intersect(names, old_names)
[09:28:23.178]                 added <- setdiff(names, old_names)
[09:28:23.178]                 removed <- setdiff(old_names, names)
[09:28:23.178]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.178]                   envs[common]]
[09:28:23.178]                 NAMES <- toupper(changed)
[09:28:23.178]                 args <- list()
[09:28:23.178]                 for (kk in seq_along(NAMES)) {
[09:28:23.178]                   name <- changed[[kk]]
[09:28:23.178]                   NAME <- NAMES[[kk]]
[09:28:23.178]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.178]                     next
[09:28:23.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.178]                 }
[09:28:23.178]                 NAMES <- toupper(added)
[09:28:23.178]                 for (kk in seq_along(NAMES)) {
[09:28:23.178]                   name <- added[[kk]]
[09:28:23.178]                   NAME <- NAMES[[kk]]
[09:28:23.178]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.178]                     next
[09:28:23.178]                   args[[name]] <- ""
[09:28:23.178]                 }
[09:28:23.178]                 NAMES <- toupper(removed)
[09:28:23.178]                 for (kk in seq_along(NAMES)) {
[09:28:23.178]                   name <- removed[[kk]]
[09:28:23.178]                   NAME <- NAMES[[kk]]
[09:28:23.178]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.178]                     next
[09:28:23.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.178]                 }
[09:28:23.178]                 if (length(args) > 0) 
[09:28:23.178]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.178]             }
[09:28:23.178]             else {
[09:28:23.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.178]             }
[09:28:23.178]             {
[09:28:23.178]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.178]                   0L) {
[09:28:23.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.178]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.178]                   base::options(opts)
[09:28:23.178]                 }
[09:28:23.178]                 {
[09:28:23.178]                   {
[09:28:23.178]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.178]                     NULL
[09:28:23.178]                   }
[09:28:23.178]                   options(future.plan = NULL)
[09:28:23.178]                   if (is.na(NA_character_)) 
[09:28:23.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.178]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.178]                     .init = FALSE)
[09:28:23.178]                 }
[09:28:23.178]             }
[09:28:23.178]         }
[09:28:23.178]     })
[09:28:23.178]     if (TRUE) {
[09:28:23.178]         base::sink(type = "output", split = FALSE)
[09:28:23.178]         if (TRUE) {
[09:28:23.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.178]         }
[09:28:23.178]         else {
[09:28:23.178]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.178]         }
[09:28:23.178]         base::close(...future.stdout)
[09:28:23.178]         ...future.stdout <- NULL
[09:28:23.178]     }
[09:28:23.178]     ...future.result$conditions <- ...future.conditions
[09:28:23.178]     ...future.result$finished <- base::Sys.time()
[09:28:23.178]     ...future.result
[09:28:23.178] }
[09:28:23.181] assign_globals() ...
[09:28:23.181] List of 5
[09:28:23.181]  $ ...future.FUN            :function (object, ...)  
[09:28:23.181]  $ future.call.arguments    :List of 1
[09:28:23.181]   ..$ digits: int 2
[09:28:23.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.181]  $ ...future.elements_ii    :List of 3
[09:28:23.181]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[09:28:23.181]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[09:28:23.181]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[09:28:23.181]  $ ...future.seeds_ii       : NULL
[09:28:23.181]  $ ...future.globals.maxSize: NULL
[09:28:23.181]  - attr(*, "where")=List of 5
[09:28:23.181]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.181]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.181]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.181]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.181]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.181]  - attr(*, "resolved")= logi FALSE
[09:28:23.181]  - attr(*, "total_size")= num 1296
[09:28:23.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.181]  - attr(*, "already-done")= logi TRUE
[09:28:23.190] - copied ‘...future.FUN’ to environment
[09:28:23.190] - copied ‘future.call.arguments’ to environment
[09:28:23.190] - copied ‘...future.elements_ii’ to environment
[09:28:23.190] - copied ‘...future.seeds_ii’ to environment
[09:28:23.190] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.190] assign_globals() ... done
[09:28:23.190] requestCore(): workers = 2
[09:28:23.192] MulticoreFuture started
[09:28:23.193] - Launch lazy future ... done
[09:28:23.193] run() for ‘MulticoreFuture’ ... done
[09:28:23.194] plan(): Setting new future strategy stack:
[09:28:23.194] Created future:
[09:28:23.194] List of future strategies:
[09:28:23.194] 1. sequential:
[09:28:23.194]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.194]    - tweaked: FALSE
[09:28:23.194]    - call: NULL
[09:28:23.196] plan(): nbrOfWorkers() = 1
[09:28:23.199] plan(): Setting new future strategy stack:
[09:28:23.199] List of future strategies:
[09:28:23.199] 1. multicore:
[09:28:23.199]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.199]    - tweaked: FALSE
[09:28:23.199]    - call: plan(strategy)
[09:28:23.204] plan(): nbrOfWorkers() = 2
[09:28:23.194] MulticoreFuture:
[09:28:23.194] Label: ‘future_by-1’
[09:28:23.194] Expression:
[09:28:23.194] {
[09:28:23.194]     do.call(function(...) {
[09:28:23.194]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.194]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.194]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.194]             on.exit(options(oopts), add = TRUE)
[09:28:23.194]         }
[09:28:23.194]         {
[09:28:23.194]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.194]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.194]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.194]             })
[09:28:23.194]         }
[09:28:23.194]     }, args = future.call.arguments)
[09:28:23.194] }
[09:28:23.194] Lazy evaluation: FALSE
[09:28:23.194] Asynchronous evaluation: TRUE
[09:28:23.194] Local evaluation: TRUE
[09:28:23.194] Environment: R_GlobalEnv
[09:28:23.194] Capture standard output: TRUE
[09:28:23.194] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.194] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:23.194] Packages: <none>
[09:28:23.194] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.194] Resolved: TRUE
[09:28:23.194] Value: <not collected>
[09:28:23.194] Conditions captured: <none>
[09:28:23.194] Early signaling: FALSE
[09:28:23.194] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.194] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.206] Chunk #1 of 2 ... DONE
[09:28:23.206] Chunk #2 of 2 ...
[09:28:23.206]  - Finding globals in 'X' for chunk #2 ...
[09:28:23.207] getGlobalsAndPackages() ...
[09:28:23.207] Searching for globals...
[09:28:23.208] 
[09:28:23.208] Searching for globals ... DONE
[09:28:23.208] - globals: [0] <none>
[09:28:23.208] getGlobalsAndPackages() ... DONE
[09:28:23.209]    + additional globals found: [n=0] 
[09:28:23.209]    + additional namespaces needed: [n=0] 
[09:28:23.209]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:23.209]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.210]  - seeds: <none>
[09:28:23.210]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.210] getGlobalsAndPackages() ...
[09:28:23.210] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.211] Resolving globals: FALSE
[09:28:23.211] Tweak future expression to call with '...' arguments ...
[09:28:23.211] {
[09:28:23.211]     do.call(function(...) {
[09:28:23.211]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.211]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.211]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.211]             on.exit(options(oopts), add = TRUE)
[09:28:23.211]         }
[09:28:23.211]         {
[09:28:23.211]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.211]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.211]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.211]             })
[09:28:23.211]         }
[09:28:23.211]     }, args = future.call.arguments)
[09:28:23.211] }
[09:28:23.212] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.213] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.213] 
[09:28:23.213] getGlobalsAndPackages() ... DONE
[09:28:23.214] run() for ‘Future’ ...
[09:28:23.215] - state: ‘created’
[09:28:23.215] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.221] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.221] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.221]   - Field: ‘label’
[09:28:23.221]   - Field: ‘local’
[09:28:23.221]   - Field: ‘owner’
[09:28:23.222]   - Field: ‘envir’
[09:28:23.222]   - Field: ‘workers’
[09:28:23.222]   - Field: ‘packages’
[09:28:23.222]   - Field: ‘gc’
[09:28:23.222]   - Field: ‘job’
[09:28:23.223]   - Field: ‘conditions’
[09:28:23.223]   - Field: ‘expr’
[09:28:23.223]   - Field: ‘uuid’
[09:28:23.223]   - Field: ‘seed’
[09:28:23.223]   - Field: ‘version’
[09:28:23.223]   - Field: ‘result’
[09:28:23.224]   - Field: ‘asynchronous’
[09:28:23.224]   - Field: ‘calls’
[09:28:23.224]   - Field: ‘globals’
[09:28:23.224]   - Field: ‘stdout’
[09:28:23.224]   - Field: ‘earlySignal’
[09:28:23.224]   - Field: ‘lazy’
[09:28:23.224]   - Field: ‘state’
[09:28:23.225] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.225] - Launch lazy future ...
[09:28:23.225] Packages needed by the future expression (n = 0): <none>
[09:28:23.225] Packages needed by future strategies (n = 0): <none>
[09:28:23.226] {
[09:28:23.226]     {
[09:28:23.226]         {
[09:28:23.226]             ...future.startTime <- base::Sys.time()
[09:28:23.226]             {
[09:28:23.226]                 {
[09:28:23.226]                   {
[09:28:23.226]                     {
[09:28:23.226]                       base::local({
[09:28:23.226]                         has_future <- base::requireNamespace("future", 
[09:28:23.226]                           quietly = TRUE)
[09:28:23.226]                         if (has_future) {
[09:28:23.226]                           ns <- base::getNamespace("future")
[09:28:23.226]                           version <- ns[[".package"]][["version"]]
[09:28:23.226]                           if (is.null(version)) 
[09:28:23.226]                             version <- utils::packageVersion("future")
[09:28:23.226]                         }
[09:28:23.226]                         else {
[09:28:23.226]                           version <- NULL
[09:28:23.226]                         }
[09:28:23.226]                         if (!has_future || version < "1.8.0") {
[09:28:23.226]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.226]                             "", base::R.version$version.string), 
[09:28:23.226]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:23.226]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:23.226]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.226]                               "release", "version")], collapse = " "), 
[09:28:23.226]                             hostname = base::Sys.info()[["nodename"]])
[09:28:23.226]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.226]                             info)
[09:28:23.226]                           info <- base::paste(info, collapse = "; ")
[09:28:23.226]                           if (!has_future) {
[09:28:23.226]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.226]                               info)
[09:28:23.226]                           }
[09:28:23.226]                           else {
[09:28:23.226]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.226]                               info, version)
[09:28:23.226]                           }
[09:28:23.226]                           base::stop(msg)
[09:28:23.226]                         }
[09:28:23.226]                       })
[09:28:23.226]                     }
[09:28:23.226]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.226]                     base::options(mc.cores = 1L)
[09:28:23.226]                   }
[09:28:23.226]                   ...future.strategy.old <- future::plan("list")
[09:28:23.226]                   options(future.plan = NULL)
[09:28:23.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.226]                 }
[09:28:23.226]                 ...future.workdir <- getwd()
[09:28:23.226]             }
[09:28:23.226]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.226]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.226]         }
[09:28:23.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.226]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.226]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.226]             base::names(...future.oldOptions))
[09:28:23.226]     }
[09:28:23.226]     if (FALSE) {
[09:28:23.226]     }
[09:28:23.226]     else {
[09:28:23.226]         if (TRUE) {
[09:28:23.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.226]                 open = "w")
[09:28:23.226]         }
[09:28:23.226]         else {
[09:28:23.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.226]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.226]         }
[09:28:23.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.226]             base::sink(type = "output", split = FALSE)
[09:28:23.226]             base::close(...future.stdout)
[09:28:23.226]         }, add = TRUE)
[09:28:23.226]     }
[09:28:23.226]     ...future.frame <- base::sys.nframe()
[09:28:23.226]     ...future.conditions <- base::list()
[09:28:23.226]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.226]     if (FALSE) {
[09:28:23.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.226]     }
[09:28:23.226]     ...future.result <- base::tryCatch({
[09:28:23.226]         base::withCallingHandlers({
[09:28:23.226]             ...future.value <- base::withVisible(base::local({
[09:28:23.226]                 withCallingHandlers({
[09:28:23.226]                   {
[09:28:23.226]                     do.call(function(...) {
[09:28:23.226]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.226]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.226]                         ...future.globals.maxSize)) {
[09:28:23.226]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.226]                         on.exit(options(oopts), add = TRUE)
[09:28:23.226]                       }
[09:28:23.226]                       {
[09:28:23.226]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.226]                           FUN = function(jj) {
[09:28:23.226]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.226]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.226]                           })
[09:28:23.226]                       }
[09:28:23.226]                     }, args = future.call.arguments)
[09:28:23.226]                   }
[09:28:23.226]                 }, immediateCondition = function(cond) {
[09:28:23.226]                   save_rds <- function (object, pathname, ...) 
[09:28:23.226]                   {
[09:28:23.226]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.226]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.226]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.226]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.226]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.226]                         fi_tmp[["mtime"]])
[09:28:23.226]                     }
[09:28:23.226]                     tryCatch({
[09:28:23.226]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.226]                     }, error = function(ex) {
[09:28:23.226]                       msg <- conditionMessage(ex)
[09:28:23.226]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.226]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.226]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.226]                         fi_tmp[["mtime"]], msg)
[09:28:23.226]                       ex$message <- msg
[09:28:23.226]                       stop(ex)
[09:28:23.226]                     })
[09:28:23.226]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.226]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.226]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.226]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.226]                       fi <- file.info(pathname)
[09:28:23.226]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.226]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.226]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.226]                         fi[["size"]], fi[["mtime"]])
[09:28:23.226]                       stop(msg)
[09:28:23.226]                     }
[09:28:23.226]                     invisible(pathname)
[09:28:23.226]                   }
[09:28:23.226]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.226]                     rootPath = tempdir()) 
[09:28:23.226]                   {
[09:28:23.226]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.226]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.226]                       tmpdir = path, fileext = ".rds")
[09:28:23.226]                     save_rds(obj, file)
[09:28:23.226]                   }
[09:28:23.226]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.226]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.226]                   {
[09:28:23.226]                     inherits <- base::inherits
[09:28:23.226]                     invokeRestart <- base::invokeRestart
[09:28:23.226]                     is.null <- base::is.null
[09:28:23.226]                     muffled <- FALSE
[09:28:23.226]                     if (inherits(cond, "message")) {
[09:28:23.226]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.226]                       if (muffled) 
[09:28:23.226]                         invokeRestart("muffleMessage")
[09:28:23.226]                     }
[09:28:23.226]                     else if (inherits(cond, "warning")) {
[09:28:23.226]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.226]                       if (muffled) 
[09:28:23.226]                         invokeRestart("muffleWarning")
[09:28:23.226]                     }
[09:28:23.226]                     else if (inherits(cond, "condition")) {
[09:28:23.226]                       if (!is.null(pattern)) {
[09:28:23.226]                         computeRestarts <- base::computeRestarts
[09:28:23.226]                         grepl <- base::grepl
[09:28:23.226]                         restarts <- computeRestarts(cond)
[09:28:23.226]                         for (restart in restarts) {
[09:28:23.226]                           name <- restart$name
[09:28:23.226]                           if (is.null(name)) 
[09:28:23.226]                             next
[09:28:23.226]                           if (!grepl(pattern, name)) 
[09:28:23.226]                             next
[09:28:23.226]                           invokeRestart(restart)
[09:28:23.226]                           muffled <- TRUE
[09:28:23.226]                           break
[09:28:23.226]                         }
[09:28:23.226]                       }
[09:28:23.226]                     }
[09:28:23.226]                     invisible(muffled)
[09:28:23.226]                   }
[09:28:23.226]                   muffleCondition(cond)
[09:28:23.226]                 })
[09:28:23.226]             }))
[09:28:23.226]             future::FutureResult(value = ...future.value$value, 
[09:28:23.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.226]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.226]                     ...future.globalenv.names))
[09:28:23.226]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.226]         }, condition = base::local({
[09:28:23.226]             c <- base::c
[09:28:23.226]             inherits <- base::inherits
[09:28:23.226]             invokeRestart <- base::invokeRestart
[09:28:23.226]             length <- base::length
[09:28:23.226]             list <- base::list
[09:28:23.226]             seq.int <- base::seq.int
[09:28:23.226]             signalCondition <- base::signalCondition
[09:28:23.226]             sys.calls <- base::sys.calls
[09:28:23.226]             `[[` <- base::`[[`
[09:28:23.226]             `+` <- base::`+`
[09:28:23.226]             `<<-` <- base::`<<-`
[09:28:23.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.226]                   3L)]
[09:28:23.226]             }
[09:28:23.226]             function(cond) {
[09:28:23.226]                 is_error <- inherits(cond, "error")
[09:28:23.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.226]                   NULL)
[09:28:23.226]                 if (is_error) {
[09:28:23.226]                   sessionInformation <- function() {
[09:28:23.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.226]                       search = base::search(), system = base::Sys.info())
[09:28:23.226]                   }
[09:28:23.226]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.226]                     cond$call), session = sessionInformation(), 
[09:28:23.226]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.226]                   signalCondition(cond)
[09:28:23.226]                 }
[09:28:23.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.226]                 "immediateCondition"))) {
[09:28:23.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.226]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.226]                   if (TRUE && !signal) {
[09:28:23.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.226]                     {
[09:28:23.226]                       inherits <- base::inherits
[09:28:23.226]                       invokeRestart <- base::invokeRestart
[09:28:23.226]                       is.null <- base::is.null
[09:28:23.226]                       muffled <- FALSE
[09:28:23.226]                       if (inherits(cond, "message")) {
[09:28:23.226]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.226]                         if (muffled) 
[09:28:23.226]                           invokeRestart("muffleMessage")
[09:28:23.226]                       }
[09:28:23.226]                       else if (inherits(cond, "warning")) {
[09:28:23.226]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.226]                         if (muffled) 
[09:28:23.226]                           invokeRestart("muffleWarning")
[09:28:23.226]                       }
[09:28:23.226]                       else if (inherits(cond, "condition")) {
[09:28:23.226]                         if (!is.null(pattern)) {
[09:28:23.226]                           computeRestarts <- base::computeRestarts
[09:28:23.226]                           grepl <- base::grepl
[09:28:23.226]                           restarts <- computeRestarts(cond)
[09:28:23.226]                           for (restart in restarts) {
[09:28:23.226]                             name <- restart$name
[09:28:23.226]                             if (is.null(name)) 
[09:28:23.226]                               next
[09:28:23.226]                             if (!grepl(pattern, name)) 
[09:28:23.226]                               next
[09:28:23.226]                             invokeRestart(restart)
[09:28:23.226]                             muffled <- TRUE
[09:28:23.226]                             break
[09:28:23.226]                           }
[09:28:23.226]                         }
[09:28:23.226]                       }
[09:28:23.226]                       invisible(muffled)
[09:28:23.226]                     }
[09:28:23.226]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.226]                   }
[09:28:23.226]                 }
[09:28:23.226]                 else {
[09:28:23.226]                   if (TRUE) {
[09:28:23.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.226]                     {
[09:28:23.226]                       inherits <- base::inherits
[09:28:23.226]                       invokeRestart <- base::invokeRestart
[09:28:23.226]                       is.null <- base::is.null
[09:28:23.226]                       muffled <- FALSE
[09:28:23.226]                       if (inherits(cond, "message")) {
[09:28:23.226]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.226]                         if (muffled) 
[09:28:23.226]                           invokeRestart("muffleMessage")
[09:28:23.226]                       }
[09:28:23.226]                       else if (inherits(cond, "warning")) {
[09:28:23.226]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.226]                         if (muffled) 
[09:28:23.226]                           invokeRestart("muffleWarning")
[09:28:23.226]                       }
[09:28:23.226]                       else if (inherits(cond, "condition")) {
[09:28:23.226]                         if (!is.null(pattern)) {
[09:28:23.226]                           computeRestarts <- base::computeRestarts
[09:28:23.226]                           grepl <- base::grepl
[09:28:23.226]                           restarts <- computeRestarts(cond)
[09:28:23.226]                           for (restart in restarts) {
[09:28:23.226]                             name <- restart$name
[09:28:23.226]                             if (is.null(name)) 
[09:28:23.226]                               next
[09:28:23.226]                             if (!grepl(pattern, name)) 
[09:28:23.226]                               next
[09:28:23.226]                             invokeRestart(restart)
[09:28:23.226]                             muffled <- TRUE
[09:28:23.226]                             break
[09:28:23.226]                           }
[09:28:23.226]                         }
[09:28:23.226]                       }
[09:28:23.226]                       invisible(muffled)
[09:28:23.226]                     }
[09:28:23.226]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.226]                   }
[09:28:23.226]                 }
[09:28:23.226]             }
[09:28:23.226]         }))
[09:28:23.226]     }, error = function(ex) {
[09:28:23.226]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.226]                 ...future.rng), started = ...future.startTime, 
[09:28:23.226]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.226]             version = "1.8"), class = "FutureResult")
[09:28:23.226]     }, finally = {
[09:28:23.226]         if (!identical(...future.workdir, getwd())) 
[09:28:23.226]             setwd(...future.workdir)
[09:28:23.226]         {
[09:28:23.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.226]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.226]             }
[09:28:23.226]             base::options(...future.oldOptions)
[09:28:23.226]             if (.Platform$OS.type == "windows") {
[09:28:23.226]                 old_names <- names(...future.oldEnvVars)
[09:28:23.226]                 envs <- base::Sys.getenv()
[09:28:23.226]                 names <- names(envs)
[09:28:23.226]                 common <- intersect(names, old_names)
[09:28:23.226]                 added <- setdiff(names, old_names)
[09:28:23.226]                 removed <- setdiff(old_names, names)
[09:28:23.226]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.226]                   envs[common]]
[09:28:23.226]                 NAMES <- toupper(changed)
[09:28:23.226]                 args <- list()
[09:28:23.226]                 for (kk in seq_along(NAMES)) {
[09:28:23.226]                   name <- changed[[kk]]
[09:28:23.226]                   NAME <- NAMES[[kk]]
[09:28:23.226]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.226]                     next
[09:28:23.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.226]                 }
[09:28:23.226]                 NAMES <- toupper(added)
[09:28:23.226]                 for (kk in seq_along(NAMES)) {
[09:28:23.226]                   name <- added[[kk]]
[09:28:23.226]                   NAME <- NAMES[[kk]]
[09:28:23.226]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.226]                     next
[09:28:23.226]                   args[[name]] <- ""
[09:28:23.226]                 }
[09:28:23.226]                 NAMES <- toupper(removed)
[09:28:23.226]                 for (kk in seq_along(NAMES)) {
[09:28:23.226]                   name <- removed[[kk]]
[09:28:23.226]                   NAME <- NAMES[[kk]]
[09:28:23.226]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.226]                     next
[09:28:23.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.226]                 }
[09:28:23.226]                 if (length(args) > 0) 
[09:28:23.226]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.226]             }
[09:28:23.226]             else {
[09:28:23.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.226]             }
[09:28:23.226]             {
[09:28:23.226]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.226]                   0L) {
[09:28:23.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.226]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.226]                   base::options(opts)
[09:28:23.226]                 }
[09:28:23.226]                 {
[09:28:23.226]                   {
[09:28:23.226]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.226]                     NULL
[09:28:23.226]                   }
[09:28:23.226]                   options(future.plan = NULL)
[09:28:23.226]                   if (is.na(NA_character_)) 
[09:28:23.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.226]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.226]                     .init = FALSE)
[09:28:23.226]                 }
[09:28:23.226]             }
[09:28:23.226]         }
[09:28:23.226]     })
[09:28:23.226]     if (TRUE) {
[09:28:23.226]         base::sink(type = "output", split = FALSE)
[09:28:23.226]         if (TRUE) {
[09:28:23.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.226]         }
[09:28:23.226]         else {
[09:28:23.226]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.226]         }
[09:28:23.226]         base::close(...future.stdout)
[09:28:23.226]         ...future.stdout <- NULL
[09:28:23.226]     }
[09:28:23.226]     ...future.result$conditions <- ...future.conditions
[09:28:23.226]     ...future.result$finished <- base::Sys.time()
[09:28:23.226]     ...future.result
[09:28:23.226] }
[09:28:23.229] assign_globals() ...
[09:28:23.229] List of 5
[09:28:23.229]  $ ...future.FUN            :function (object, ...)  
[09:28:23.229]  $ future.call.arguments    :List of 1
[09:28:23.229]   ..$ digits: int 2
[09:28:23.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.229]  $ ...future.elements_ii    :List of 3
[09:28:23.229]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[09:28:23.229]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[09:28:23.229]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[09:28:23.229]  $ ...future.seeds_ii       : NULL
[09:28:23.229]  $ ...future.globals.maxSize: NULL
[09:28:23.229]  - attr(*, "where")=List of 5
[09:28:23.229]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.229]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.229]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.229]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.229]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.229]  - attr(*, "resolved")= logi FALSE
[09:28:23.229]  - attr(*, "total_size")= num 1296
[09:28:23.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.229]  - attr(*, "already-done")= logi TRUE
[09:28:23.242] - copied ‘...future.FUN’ to environment
[09:28:23.242] - copied ‘future.call.arguments’ to environment
[09:28:23.243] - copied ‘...future.elements_ii’ to environment
[09:28:23.243] - copied ‘...future.seeds_ii’ to environment
[09:28:23.243] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.243] assign_globals() ... done
[09:28:23.243] requestCore(): workers = 2
[09:28:23.246] MulticoreFuture started
[09:28:23.246] - Launch lazy future ... done
[09:28:23.246] run() for ‘MulticoreFuture’ ... done
[09:28:23.247] Created future:
[09:28:23.247] plan(): Setting new future strategy stack:
[09:28:23.247] List of future strategies:
[09:28:23.247] 1. sequential:
[09:28:23.247]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.247]    - tweaked: FALSE
[09:28:23.247]    - call: NULL
[09:28:23.248] plan(): nbrOfWorkers() = 1
[09:28:23.251] plan(): Setting new future strategy stack:
[09:28:23.252] List of future strategies:
[09:28:23.252] 1. multicore:
[09:28:23.252]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.252]    - tweaked: FALSE
[09:28:23.252]    - call: plan(strategy)
[09:28:23.257] plan(): nbrOfWorkers() = 2
[09:28:23.247] MulticoreFuture:
[09:28:23.247] Label: ‘future_by-2’
[09:28:23.247] Expression:
[09:28:23.247] {
[09:28:23.247]     do.call(function(...) {
[09:28:23.247]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.247]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.247]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.247]             on.exit(options(oopts), add = TRUE)
[09:28:23.247]         }
[09:28:23.247]         {
[09:28:23.247]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.247]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.247]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.247]             })
[09:28:23.247]         }
[09:28:23.247]     }, args = future.call.arguments)
[09:28:23.247] }
[09:28:23.247] Lazy evaluation: FALSE
[09:28:23.247] Asynchronous evaluation: TRUE
[09:28:23.247] Local evaluation: TRUE
[09:28:23.247] Environment: R_GlobalEnv
[09:28:23.247] Capture standard output: TRUE
[09:28:23.247] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.247] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:23.247] Packages: <none>
[09:28:23.247] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.247] Resolved: TRUE
[09:28:23.247] Value: <not collected>
[09:28:23.247] Conditions captured: <none>
[09:28:23.247] Early signaling: FALSE
[09:28:23.247] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.247] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.258] Chunk #2 of 2 ... DONE
[09:28:23.258] Launching 2 futures (chunks) ... DONE
[09:28:23.258] Resolving 2 futures (chunks) ...
[09:28:23.259] resolve() on list ...
[09:28:23.259]  recursive: 0
[09:28:23.259]  length: 2
[09:28:23.259] 
[09:28:23.259] Future #1
[09:28:23.260] result() for MulticoreFuture ...
[09:28:23.261] result() for MulticoreFuture ...
[09:28:23.261] result() for MulticoreFuture ... done
[09:28:23.261] result() for MulticoreFuture ... done
[09:28:23.261] result() for MulticoreFuture ...
[09:28:23.261] result() for MulticoreFuture ... done
[09:28:23.262] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:23.262] - nx: 2
[09:28:23.262] - relay: TRUE
[09:28:23.262] - stdout: TRUE
[09:28:23.262] - signal: TRUE
[09:28:23.263] - resignal: FALSE
[09:28:23.263] - force: TRUE
[09:28:23.263] - relayed: [n=2] FALSE, FALSE
[09:28:23.263] - queued futures: [n=2] FALSE, FALSE
[09:28:23.263]  - until=1
[09:28:23.263]  - relaying element #1
[09:28:23.264] result() for MulticoreFuture ...
[09:28:23.264] result() for MulticoreFuture ... done
[09:28:23.264] result() for MulticoreFuture ...
[09:28:23.264] result() for MulticoreFuture ... done
[09:28:23.265] result() for MulticoreFuture ...
[09:28:23.265] result() for MulticoreFuture ... done
[09:28:23.265] result() for MulticoreFuture ...
[09:28:23.265] result() for MulticoreFuture ... done
[09:28:23.265] - relayed: [n=2] TRUE, FALSE
[09:28:23.265] - queued futures: [n=2] TRUE, FALSE
[09:28:23.266] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:23.266]  length: 1 (resolved future 1)
[09:28:23.266] Future #2
[09:28:23.266] result() for MulticoreFuture ...
[09:28:23.267] result() for MulticoreFuture ...
[09:28:23.267] result() for MulticoreFuture ... done
[09:28:23.267] result() for MulticoreFuture ... done
[09:28:23.267] result() for MulticoreFuture ...
[09:28:23.268] result() for MulticoreFuture ... done
[09:28:23.268] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:23.268] - nx: 2
[09:28:23.268] - relay: TRUE
[09:28:23.268] - stdout: TRUE
[09:28:23.268] - signal: TRUE
[09:28:23.268] - resignal: FALSE
[09:28:23.269] - force: TRUE
[09:28:23.269] - relayed: [n=2] TRUE, FALSE
[09:28:23.269] - queued futures: [n=2] TRUE, FALSE
[09:28:23.269]  - until=2
[09:28:23.269]  - relaying element #2
[09:28:23.269] result() for MulticoreFuture ...
[09:28:23.269] result() for MulticoreFuture ... done
[09:28:23.269] result() for MulticoreFuture ...
[09:28:23.270] result() for MulticoreFuture ... done
[09:28:23.270] result() for MulticoreFuture ...
[09:28:23.270] result() for MulticoreFuture ... done
[09:28:23.270] result() for MulticoreFuture ...
[09:28:23.270] result() for MulticoreFuture ... done
[09:28:23.270] - relayed: [n=2] TRUE, TRUE
[09:28:23.270] - queued futures: [n=2] TRUE, TRUE
[09:28:23.270] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:23.271]  length: 0 (resolved future 2)
[09:28:23.271] Relaying remaining futures
[09:28:23.271] signalConditionsASAP(NULL, pos=0) ...
[09:28:23.271] - nx: 2
[09:28:23.271] - relay: TRUE
[09:28:23.271] - stdout: TRUE
[09:28:23.271] - signal: TRUE
[09:28:23.271] - resignal: FALSE
[09:28:23.271] - force: TRUE
[09:28:23.271] - relayed: [n=2] TRUE, TRUE
[09:28:23.272] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:23.272] - relayed: [n=2] TRUE, TRUE
[09:28:23.272] - queued futures: [n=2] TRUE, TRUE
[09:28:23.272] signalConditionsASAP(NULL, pos=0) ... done
[09:28:23.272] resolve() on list ... DONE
[09:28:23.272] result() for MulticoreFuture ...
[09:28:23.272] result() for MulticoreFuture ... done
[09:28:23.272] result() for MulticoreFuture ...
[09:28:23.273] result() for MulticoreFuture ... done
[09:28:23.273] result() for MulticoreFuture ...
[09:28:23.273] result() for MulticoreFuture ... done
[09:28:23.273] result() for MulticoreFuture ...
[09:28:23.273] result() for MulticoreFuture ... done
[09:28:23.273]  - Number of value chunks collected: 2
[09:28:23.273] Resolving 2 futures (chunks) ... DONE
[09:28:23.273] Reducing values from 2 chunks ...
[09:28:23.274]  - Number of values collected after concatenation: 6
[09:28:23.274]  - Number of values expected: 6
[09:28:23.274] Reducing values from 2 chunks ... DONE
[09:28:23.274] future_lapply() ... DONE
[09:28:23.274] future_by_internal() ... DONE
[09:28:23.275] future_by_internal() ...
[09:28:23.276] future_lapply() ...
[09:28:23.283] Number of chunks: 2
[09:28:23.284] getGlobalsAndPackagesXApply() ...
[09:28:23.284]  - future.globals: TRUE
[09:28:23.284] getGlobalsAndPackages() ...
[09:28:23.284] Searching for globals...
[09:28:23.286] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:23.287] Searching for globals ... DONE
[09:28:23.287] Resolving globals: FALSE
[09:28:23.287] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[09:28:23.288] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[09:28:23.288] - globals: [1] ‘FUN’
[09:28:23.288] - packages: [1] ‘stats’
[09:28:23.288] getGlobalsAndPackages() ... DONE
[09:28:23.288]  - globals found/used: [n=1] ‘FUN’
[09:28:23.288]  - needed namespaces: [n=1] ‘stats’
[09:28:23.288] Finding globals ... DONE
[09:28:23.288]  - use_args: TRUE
[09:28:23.288]  - Getting '...' globals ...
[09:28:23.289] resolve() on list ...
[09:28:23.289]  recursive: 0
[09:28:23.289]  length: 1
[09:28:23.289]  elements: ‘...’
[09:28:23.289]  length: 0 (resolved future 1)
[09:28:23.289] resolve() on list ... DONE
[09:28:23.289]    - '...' content: [n=1] ‘singular.ok’
[09:28:23.290] List of 1
[09:28:23.290]  $ ...:List of 1
[09:28:23.290]   ..$ singular.ok: logi FALSE
[09:28:23.290]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.290]  - attr(*, "where")=List of 1
[09:28:23.290]   ..$ ...:<environment: 0x555b0a78c680> 
[09:28:23.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.290]  - attr(*, "resolved")= logi TRUE
[09:28:23.290]  - attr(*, "total_size")= num NA
[09:28:23.293]  - Getting '...' globals ... DONE
[09:28:23.293] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:23.293] List of 2
[09:28:23.293]  $ ...future.FUN:function (x, ...)  
[09:28:23.293]  $ ...          :List of 1
[09:28:23.293]   ..$ singular.ok: logi FALSE
[09:28:23.293]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.293]  - attr(*, "where")=List of 2
[09:28:23.293]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:23.293]   ..$ ...          :<environment: 0x555b0a78c680> 
[09:28:23.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.293]  - attr(*, "resolved")= logi FALSE
[09:28:23.293]  - attr(*, "total_size")= num 5384
[09:28:23.296] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:23.296] getGlobalsAndPackagesXApply() ... DONE
[09:28:23.296] Number of futures (= number of chunks): 2
[09:28:23.296] Launching 2 futures (chunks) ...
[09:28:23.297] Chunk #1 of 2 ...
[09:28:23.297]  - Finding globals in 'X' for chunk #1 ...
[09:28:23.297] getGlobalsAndPackages() ...
[09:28:23.297] Searching for globals...
[09:28:23.297] 
[09:28:23.297] Searching for globals ... DONE
[09:28:23.297] - globals: [0] <none>
[09:28:23.298] getGlobalsAndPackages() ... DONE
[09:28:23.298]    + additional globals found: [n=0] 
[09:28:23.298]    + additional namespaces needed: [n=0] 
[09:28:23.298]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:23.298]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.298]  - seeds: <none>
[09:28:23.298]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.298] getGlobalsAndPackages() ...
[09:28:23.298] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.298] Resolving globals: FALSE
[09:28:23.299] Tweak future expression to call with '...' arguments ...
[09:28:23.299] {
[09:28:23.299]     do.call(function(...) {
[09:28:23.299]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.299]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.299]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.299]             on.exit(options(oopts), add = TRUE)
[09:28:23.299]         }
[09:28:23.299]         {
[09:28:23.299]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.299]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.299]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.299]             })
[09:28:23.299]         }
[09:28:23.299]     }, args = future.call.arguments)
[09:28:23.299] }
[09:28:23.299] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.299] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.299] 
[09:28:23.299] getGlobalsAndPackages() ... DONE
[09:28:23.300] run() for ‘Future’ ...
[09:28:23.300] - state: ‘created’
[09:28:23.300] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.305] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.305] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.306]   - Field: ‘label’
[09:28:23.306]   - Field: ‘local’
[09:28:23.306]   - Field: ‘owner’
[09:28:23.306]   - Field: ‘envir’
[09:28:23.306]   - Field: ‘workers’
[09:28:23.306]   - Field: ‘packages’
[09:28:23.306]   - Field: ‘gc’
[09:28:23.306]   - Field: ‘job’
[09:28:23.306]   - Field: ‘conditions’
[09:28:23.306]   - Field: ‘expr’
[09:28:23.307]   - Field: ‘uuid’
[09:28:23.307]   - Field: ‘seed’
[09:28:23.307]   - Field: ‘version’
[09:28:23.307]   - Field: ‘result’
[09:28:23.307]   - Field: ‘asynchronous’
[09:28:23.307]   - Field: ‘calls’
[09:28:23.307]   - Field: ‘globals’
[09:28:23.307]   - Field: ‘stdout’
[09:28:23.307]   - Field: ‘earlySignal’
[09:28:23.307]   - Field: ‘lazy’
[09:28:23.308]   - Field: ‘state’
[09:28:23.308] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.308] - Launch lazy future ...
[09:28:23.308] Packages needed by the future expression (n = 1): ‘stats’
[09:28:23.308] Packages needed by future strategies (n = 0): <none>
[09:28:23.309] {
[09:28:23.309]     {
[09:28:23.309]         {
[09:28:23.309]             ...future.startTime <- base::Sys.time()
[09:28:23.309]             {
[09:28:23.309]                 {
[09:28:23.309]                   {
[09:28:23.309]                     {
[09:28:23.309]                       {
[09:28:23.309]                         base::local({
[09:28:23.309]                           has_future <- base::requireNamespace("future", 
[09:28:23.309]                             quietly = TRUE)
[09:28:23.309]                           if (has_future) {
[09:28:23.309]                             ns <- base::getNamespace("future")
[09:28:23.309]                             version <- ns[[".package"]][["version"]]
[09:28:23.309]                             if (is.null(version)) 
[09:28:23.309]                               version <- utils::packageVersion("future")
[09:28:23.309]                           }
[09:28:23.309]                           else {
[09:28:23.309]                             version <- NULL
[09:28:23.309]                           }
[09:28:23.309]                           if (!has_future || version < "1.8.0") {
[09:28:23.309]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.309]                               "", base::R.version$version.string), 
[09:28:23.309]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:23.309]                                 base::R.version$platform, 8 * 
[09:28:23.309]                                   base::.Machine$sizeof.pointer), 
[09:28:23.309]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.309]                                 "release", "version")], collapse = " "), 
[09:28:23.309]                               hostname = base::Sys.info()[["nodename"]])
[09:28:23.309]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.309]                               info)
[09:28:23.309]                             info <- base::paste(info, collapse = "; ")
[09:28:23.309]                             if (!has_future) {
[09:28:23.309]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.309]                                 info)
[09:28:23.309]                             }
[09:28:23.309]                             else {
[09:28:23.309]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.309]                                 info, version)
[09:28:23.309]                             }
[09:28:23.309]                             base::stop(msg)
[09:28:23.309]                           }
[09:28:23.309]                         })
[09:28:23.309]                       }
[09:28:23.309]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.309]                       base::options(mc.cores = 1L)
[09:28:23.309]                     }
[09:28:23.309]                     base::local({
[09:28:23.309]                       for (pkg in "stats") {
[09:28:23.309]                         base::loadNamespace(pkg)
[09:28:23.309]                         base::library(pkg, character.only = TRUE)
[09:28:23.309]                       }
[09:28:23.309]                     })
[09:28:23.309]                   }
[09:28:23.309]                   ...future.strategy.old <- future::plan("list")
[09:28:23.309]                   options(future.plan = NULL)
[09:28:23.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.309]                 }
[09:28:23.309]                 ...future.workdir <- getwd()
[09:28:23.309]             }
[09:28:23.309]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.309]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.309]         }
[09:28:23.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.309]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.309]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.309]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.309]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.309]             base::names(...future.oldOptions))
[09:28:23.309]     }
[09:28:23.309]     if (FALSE) {
[09:28:23.309]     }
[09:28:23.309]     else {
[09:28:23.309]         if (TRUE) {
[09:28:23.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.309]                 open = "w")
[09:28:23.309]         }
[09:28:23.309]         else {
[09:28:23.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.309]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.309]         }
[09:28:23.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.309]             base::sink(type = "output", split = FALSE)
[09:28:23.309]             base::close(...future.stdout)
[09:28:23.309]         }, add = TRUE)
[09:28:23.309]     }
[09:28:23.309]     ...future.frame <- base::sys.nframe()
[09:28:23.309]     ...future.conditions <- base::list()
[09:28:23.309]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.309]     if (FALSE) {
[09:28:23.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.309]     }
[09:28:23.309]     ...future.result <- base::tryCatch({
[09:28:23.309]         base::withCallingHandlers({
[09:28:23.309]             ...future.value <- base::withVisible(base::local({
[09:28:23.309]                 withCallingHandlers({
[09:28:23.309]                   {
[09:28:23.309]                     do.call(function(...) {
[09:28:23.309]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.309]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.309]                         ...future.globals.maxSize)) {
[09:28:23.309]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.309]                         on.exit(options(oopts), add = TRUE)
[09:28:23.309]                       }
[09:28:23.309]                       {
[09:28:23.309]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.309]                           FUN = function(jj) {
[09:28:23.309]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.309]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.309]                           })
[09:28:23.309]                       }
[09:28:23.309]                     }, args = future.call.arguments)
[09:28:23.309]                   }
[09:28:23.309]                 }, immediateCondition = function(cond) {
[09:28:23.309]                   save_rds <- function (object, pathname, ...) 
[09:28:23.309]                   {
[09:28:23.309]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.309]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.309]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.309]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.309]                         fi_tmp[["mtime"]])
[09:28:23.309]                     }
[09:28:23.309]                     tryCatch({
[09:28:23.309]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.309]                     }, error = function(ex) {
[09:28:23.309]                       msg <- conditionMessage(ex)
[09:28:23.309]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.309]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.309]                         fi_tmp[["mtime"]], msg)
[09:28:23.309]                       ex$message <- msg
[09:28:23.309]                       stop(ex)
[09:28:23.309]                     })
[09:28:23.309]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.309]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.309]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.309]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.309]                       fi <- file.info(pathname)
[09:28:23.309]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.309]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.309]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.309]                         fi[["size"]], fi[["mtime"]])
[09:28:23.309]                       stop(msg)
[09:28:23.309]                     }
[09:28:23.309]                     invisible(pathname)
[09:28:23.309]                   }
[09:28:23.309]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.309]                     rootPath = tempdir()) 
[09:28:23.309]                   {
[09:28:23.309]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.309]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.309]                       tmpdir = path, fileext = ".rds")
[09:28:23.309]                     save_rds(obj, file)
[09:28:23.309]                   }
[09:28:23.309]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.309]                   {
[09:28:23.309]                     inherits <- base::inherits
[09:28:23.309]                     invokeRestart <- base::invokeRestart
[09:28:23.309]                     is.null <- base::is.null
[09:28:23.309]                     muffled <- FALSE
[09:28:23.309]                     if (inherits(cond, "message")) {
[09:28:23.309]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.309]                       if (muffled) 
[09:28:23.309]                         invokeRestart("muffleMessage")
[09:28:23.309]                     }
[09:28:23.309]                     else if (inherits(cond, "warning")) {
[09:28:23.309]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.309]                       if (muffled) 
[09:28:23.309]                         invokeRestart("muffleWarning")
[09:28:23.309]                     }
[09:28:23.309]                     else if (inherits(cond, "condition")) {
[09:28:23.309]                       if (!is.null(pattern)) {
[09:28:23.309]                         computeRestarts <- base::computeRestarts
[09:28:23.309]                         grepl <- base::grepl
[09:28:23.309]                         restarts <- computeRestarts(cond)
[09:28:23.309]                         for (restart in restarts) {
[09:28:23.309]                           name <- restart$name
[09:28:23.309]                           if (is.null(name)) 
[09:28:23.309]                             next
[09:28:23.309]                           if (!grepl(pattern, name)) 
[09:28:23.309]                             next
[09:28:23.309]                           invokeRestart(restart)
[09:28:23.309]                           muffled <- TRUE
[09:28:23.309]                           break
[09:28:23.309]                         }
[09:28:23.309]                       }
[09:28:23.309]                     }
[09:28:23.309]                     invisible(muffled)
[09:28:23.309]                   }
[09:28:23.309]                   muffleCondition(cond)
[09:28:23.309]                 })
[09:28:23.309]             }))
[09:28:23.309]             future::FutureResult(value = ...future.value$value, 
[09:28:23.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.309]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.309]                     ...future.globalenv.names))
[09:28:23.309]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.309]         }, condition = base::local({
[09:28:23.309]             c <- base::c
[09:28:23.309]             inherits <- base::inherits
[09:28:23.309]             invokeRestart <- base::invokeRestart
[09:28:23.309]             length <- base::length
[09:28:23.309]             list <- base::list
[09:28:23.309]             seq.int <- base::seq.int
[09:28:23.309]             signalCondition <- base::signalCondition
[09:28:23.309]             sys.calls <- base::sys.calls
[09:28:23.309]             `[[` <- base::`[[`
[09:28:23.309]             `+` <- base::`+`
[09:28:23.309]             `<<-` <- base::`<<-`
[09:28:23.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.309]                   3L)]
[09:28:23.309]             }
[09:28:23.309]             function(cond) {
[09:28:23.309]                 is_error <- inherits(cond, "error")
[09:28:23.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.309]                   NULL)
[09:28:23.309]                 if (is_error) {
[09:28:23.309]                   sessionInformation <- function() {
[09:28:23.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.309]                       search = base::search(), system = base::Sys.info())
[09:28:23.309]                   }
[09:28:23.309]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.309]                     cond$call), session = sessionInformation(), 
[09:28:23.309]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.309]                   signalCondition(cond)
[09:28:23.309]                 }
[09:28:23.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.309]                 "immediateCondition"))) {
[09:28:23.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.309]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.309]                   if (TRUE && !signal) {
[09:28:23.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.309]                     {
[09:28:23.309]                       inherits <- base::inherits
[09:28:23.309]                       invokeRestart <- base::invokeRestart
[09:28:23.309]                       is.null <- base::is.null
[09:28:23.309]                       muffled <- FALSE
[09:28:23.309]                       if (inherits(cond, "message")) {
[09:28:23.309]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.309]                         if (muffled) 
[09:28:23.309]                           invokeRestart("muffleMessage")
[09:28:23.309]                       }
[09:28:23.309]                       else if (inherits(cond, "warning")) {
[09:28:23.309]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.309]                         if (muffled) 
[09:28:23.309]                           invokeRestart("muffleWarning")
[09:28:23.309]                       }
[09:28:23.309]                       else if (inherits(cond, "condition")) {
[09:28:23.309]                         if (!is.null(pattern)) {
[09:28:23.309]                           computeRestarts <- base::computeRestarts
[09:28:23.309]                           grepl <- base::grepl
[09:28:23.309]                           restarts <- computeRestarts(cond)
[09:28:23.309]                           for (restart in restarts) {
[09:28:23.309]                             name <- restart$name
[09:28:23.309]                             if (is.null(name)) 
[09:28:23.309]                               next
[09:28:23.309]                             if (!grepl(pattern, name)) 
[09:28:23.309]                               next
[09:28:23.309]                             invokeRestart(restart)
[09:28:23.309]                             muffled <- TRUE
[09:28:23.309]                             break
[09:28:23.309]                           }
[09:28:23.309]                         }
[09:28:23.309]                       }
[09:28:23.309]                       invisible(muffled)
[09:28:23.309]                     }
[09:28:23.309]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.309]                   }
[09:28:23.309]                 }
[09:28:23.309]                 else {
[09:28:23.309]                   if (TRUE) {
[09:28:23.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.309]                     {
[09:28:23.309]                       inherits <- base::inherits
[09:28:23.309]                       invokeRestart <- base::invokeRestart
[09:28:23.309]                       is.null <- base::is.null
[09:28:23.309]                       muffled <- FALSE
[09:28:23.309]                       if (inherits(cond, "message")) {
[09:28:23.309]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.309]                         if (muffled) 
[09:28:23.309]                           invokeRestart("muffleMessage")
[09:28:23.309]                       }
[09:28:23.309]                       else if (inherits(cond, "warning")) {
[09:28:23.309]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.309]                         if (muffled) 
[09:28:23.309]                           invokeRestart("muffleWarning")
[09:28:23.309]                       }
[09:28:23.309]                       else if (inherits(cond, "condition")) {
[09:28:23.309]                         if (!is.null(pattern)) {
[09:28:23.309]                           computeRestarts <- base::computeRestarts
[09:28:23.309]                           grepl <- base::grepl
[09:28:23.309]                           restarts <- computeRestarts(cond)
[09:28:23.309]                           for (restart in restarts) {
[09:28:23.309]                             name <- restart$name
[09:28:23.309]                             if (is.null(name)) 
[09:28:23.309]                               next
[09:28:23.309]                             if (!grepl(pattern, name)) 
[09:28:23.309]                               next
[09:28:23.309]                             invokeRestart(restart)
[09:28:23.309]                             muffled <- TRUE
[09:28:23.309]                             break
[09:28:23.309]                           }
[09:28:23.309]                         }
[09:28:23.309]                       }
[09:28:23.309]                       invisible(muffled)
[09:28:23.309]                     }
[09:28:23.309]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.309]                   }
[09:28:23.309]                 }
[09:28:23.309]             }
[09:28:23.309]         }))
[09:28:23.309]     }, error = function(ex) {
[09:28:23.309]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.309]                 ...future.rng), started = ...future.startTime, 
[09:28:23.309]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.309]             version = "1.8"), class = "FutureResult")
[09:28:23.309]     }, finally = {
[09:28:23.309]         if (!identical(...future.workdir, getwd())) 
[09:28:23.309]             setwd(...future.workdir)
[09:28:23.309]         {
[09:28:23.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.309]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.309]             }
[09:28:23.309]             base::options(...future.oldOptions)
[09:28:23.309]             if (.Platform$OS.type == "windows") {
[09:28:23.309]                 old_names <- names(...future.oldEnvVars)
[09:28:23.309]                 envs <- base::Sys.getenv()
[09:28:23.309]                 names <- names(envs)
[09:28:23.309]                 common <- intersect(names, old_names)
[09:28:23.309]                 added <- setdiff(names, old_names)
[09:28:23.309]                 removed <- setdiff(old_names, names)
[09:28:23.309]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.309]                   envs[common]]
[09:28:23.309]                 NAMES <- toupper(changed)
[09:28:23.309]                 args <- list()
[09:28:23.309]                 for (kk in seq_along(NAMES)) {
[09:28:23.309]                   name <- changed[[kk]]
[09:28:23.309]                   NAME <- NAMES[[kk]]
[09:28:23.309]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.309]                     next
[09:28:23.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.309]                 }
[09:28:23.309]                 NAMES <- toupper(added)
[09:28:23.309]                 for (kk in seq_along(NAMES)) {
[09:28:23.309]                   name <- added[[kk]]
[09:28:23.309]                   NAME <- NAMES[[kk]]
[09:28:23.309]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.309]                     next
[09:28:23.309]                   args[[name]] <- ""
[09:28:23.309]                 }
[09:28:23.309]                 NAMES <- toupper(removed)
[09:28:23.309]                 for (kk in seq_along(NAMES)) {
[09:28:23.309]                   name <- removed[[kk]]
[09:28:23.309]                   NAME <- NAMES[[kk]]
[09:28:23.309]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.309]                     next
[09:28:23.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.309]                 }
[09:28:23.309]                 if (length(args) > 0) 
[09:28:23.309]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.309]             }
[09:28:23.309]             else {
[09:28:23.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.309]             }
[09:28:23.309]             {
[09:28:23.309]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.309]                   0L) {
[09:28:23.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.309]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.309]                   base::options(opts)
[09:28:23.309]                 }
[09:28:23.309]                 {
[09:28:23.309]                   {
[09:28:23.309]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.309]                     NULL
[09:28:23.309]                   }
[09:28:23.309]                   options(future.plan = NULL)
[09:28:23.309]                   if (is.na(NA_character_)) 
[09:28:23.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.309]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.309]                     .init = FALSE)
[09:28:23.309]                 }
[09:28:23.309]             }
[09:28:23.309]         }
[09:28:23.309]     })
[09:28:23.309]     if (TRUE) {
[09:28:23.309]         base::sink(type = "output", split = FALSE)
[09:28:23.309]         if (TRUE) {
[09:28:23.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.309]         }
[09:28:23.309]         else {
[09:28:23.309]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.309]         }
[09:28:23.309]         base::close(...future.stdout)
[09:28:23.309]         ...future.stdout <- NULL
[09:28:23.309]     }
[09:28:23.309]     ...future.result$conditions <- ...future.conditions
[09:28:23.309]     ...future.result$finished <- base::Sys.time()
[09:28:23.309]     ...future.result
[09:28:23.309] }
[09:28:23.311] assign_globals() ...
[09:28:23.311] List of 5
[09:28:23.311]  $ ...future.FUN            :function (x, ...)  
[09:28:23.311]  $ future.call.arguments    :List of 1
[09:28:23.311]   ..$ singular.ok: logi FALSE
[09:28:23.311]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.311]  $ ...future.elements_ii    :List of 1
[09:28:23.311]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.311]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:23.311]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.311]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:23.311]  $ ...future.seeds_ii       : NULL
[09:28:23.311]  $ ...future.globals.maxSize: NULL
[09:28:23.311]  - attr(*, "where")=List of 5
[09:28:23.311]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.311]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.311]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.311]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.311]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.311]  - attr(*, "resolved")= logi FALSE
[09:28:23.311]  - attr(*, "total_size")= num 5384
[09:28:23.311]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.311]  - attr(*, "already-done")= logi TRUE
[09:28:23.317] - reassign environment for ‘...future.FUN’
[09:28:23.317] - copied ‘...future.FUN’ to environment
[09:28:23.318] - copied ‘future.call.arguments’ to environment
[09:28:23.318] - copied ‘...future.elements_ii’ to environment
[09:28:23.318] - copied ‘...future.seeds_ii’ to environment
[09:28:23.318] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.318] assign_globals() ... done
[09:28:23.318] requestCore(): workers = 2
[09:28:23.320] MulticoreFuture started
[09:28:23.320] - Launch lazy future ... done
[09:28:23.321] run() for ‘MulticoreFuture’ ... done
[09:28:23.321] Created future:
[09:28:23.322] plan(): Setting new future strategy stack:
[09:28:23.322] List of future strategies:
[09:28:23.322] 1. sequential:
[09:28:23.322]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.322]    - tweaked: FALSE
[09:28:23.322]    - call: NULL
[09:28:23.323] plan(): nbrOfWorkers() = 1
[09:28:23.326] plan(): Setting new future strategy stack:
[09:28:23.327] List of future strategies:
[09:28:23.327] 1. multicore:
[09:28:23.327]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.327]    - tweaked: FALSE
[09:28:23.327]    - call: plan(strategy)
[09:28:23.331] plan(): nbrOfWorkers() = 2
[09:28:23.321] MulticoreFuture:
[09:28:23.321] Label: ‘future_by-1’
[09:28:23.321] Expression:
[09:28:23.321] {
[09:28:23.321]     do.call(function(...) {
[09:28:23.321]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.321]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.321]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.321]             on.exit(options(oopts), add = TRUE)
[09:28:23.321]         }
[09:28:23.321]         {
[09:28:23.321]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.321]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.321]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.321]             })
[09:28:23.321]         }
[09:28:23.321]     }, args = future.call.arguments)
[09:28:23.321] }
[09:28:23.321] Lazy evaluation: FALSE
[09:28:23.321] Asynchronous evaluation: TRUE
[09:28:23.321] Local evaluation: TRUE
[09:28:23.321] Environment: R_GlobalEnv
[09:28:23.321] Capture standard output: TRUE
[09:28:23.321] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.321] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:23.321] Packages: 1 packages (‘stats’)
[09:28:23.321] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.321] Resolved: TRUE
[09:28:23.321] Value: <not collected>
[09:28:23.321] Conditions captured: <none>
[09:28:23.321] Early signaling: FALSE
[09:28:23.321] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.321] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.333] Chunk #1 of 2 ... DONE
[09:28:23.333] Chunk #2 of 2 ...
[09:28:23.333]  - Finding globals in 'X' for chunk #2 ...
[09:28:23.334] getGlobalsAndPackages() ...
[09:28:23.334] Searching for globals...
[09:28:23.334] 
[09:28:23.335] Searching for globals ... DONE
[09:28:23.335] - globals: [0] <none>
[09:28:23.335] getGlobalsAndPackages() ... DONE
[09:28:23.335]    + additional globals found: [n=0] 
[09:28:23.335]    + additional namespaces needed: [n=0] 
[09:28:23.335]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:23.335]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.335]  - seeds: <none>
[09:28:23.336]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.336] getGlobalsAndPackages() ...
[09:28:23.336] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.336] Resolving globals: FALSE
[09:28:23.336] Tweak future expression to call with '...' arguments ...
[09:28:23.336] {
[09:28:23.336]     do.call(function(...) {
[09:28:23.336]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.336]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.336]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.336]             on.exit(options(oopts), add = TRUE)
[09:28:23.336]         }
[09:28:23.336]         {
[09:28:23.336]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.336]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.336]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.336]             })
[09:28:23.336]         }
[09:28:23.336]     }, args = future.call.arguments)
[09:28:23.336] }
[09:28:23.337] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.337] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.337] 
[09:28:23.337] getGlobalsAndPackages() ... DONE
[09:28:23.338] run() for ‘Future’ ...
[09:28:23.338] - state: ‘created’
[09:28:23.338] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.346] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.346] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.347]   - Field: ‘label’
[09:28:23.347]   - Field: ‘local’
[09:28:23.347]   - Field: ‘owner’
[09:28:23.348]   - Field: ‘envir’
[09:28:23.348]   - Field: ‘workers’
[09:28:23.348]   - Field: ‘packages’
[09:28:23.348]   - Field: ‘gc’
[09:28:23.349]   - Field: ‘job’
[09:28:23.349]   - Field: ‘conditions’
[09:28:23.349]   - Field: ‘expr’
[09:28:23.349]   - Field: ‘uuid’
[09:28:23.350]   - Field: ‘seed’
[09:28:23.350]   - Field: ‘version’
[09:28:23.350]   - Field: ‘result’
[09:28:23.351]   - Field: ‘asynchronous’
[09:28:23.351]   - Field: ‘calls’
[09:28:23.351]   - Field: ‘globals’
[09:28:23.351]   - Field: ‘stdout’
[09:28:23.351]   - Field: ‘earlySignal’
[09:28:23.351]   - Field: ‘lazy’
[09:28:23.352]   - Field: ‘state’
[09:28:23.352] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.352] - Launch lazy future ...
[09:28:23.352] Packages needed by the future expression (n = 1): ‘stats’
[09:28:23.353] Packages needed by future strategies (n = 0): <none>
[09:28:23.354] {
[09:28:23.354]     {
[09:28:23.354]         {
[09:28:23.354]             ...future.startTime <- base::Sys.time()
[09:28:23.354]             {
[09:28:23.354]                 {
[09:28:23.354]                   {
[09:28:23.354]                     {
[09:28:23.354]                       {
[09:28:23.354]                         base::local({
[09:28:23.354]                           has_future <- base::requireNamespace("future", 
[09:28:23.354]                             quietly = TRUE)
[09:28:23.354]                           if (has_future) {
[09:28:23.354]                             ns <- base::getNamespace("future")
[09:28:23.354]                             version <- ns[[".package"]][["version"]]
[09:28:23.354]                             if (is.null(version)) 
[09:28:23.354]                               version <- utils::packageVersion("future")
[09:28:23.354]                           }
[09:28:23.354]                           else {
[09:28:23.354]                             version <- NULL
[09:28:23.354]                           }
[09:28:23.354]                           if (!has_future || version < "1.8.0") {
[09:28:23.354]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.354]                               "", base::R.version$version.string), 
[09:28:23.354]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:23.354]                                 base::R.version$platform, 8 * 
[09:28:23.354]                                   base::.Machine$sizeof.pointer), 
[09:28:23.354]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.354]                                 "release", "version")], collapse = " "), 
[09:28:23.354]                               hostname = base::Sys.info()[["nodename"]])
[09:28:23.354]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.354]                               info)
[09:28:23.354]                             info <- base::paste(info, collapse = "; ")
[09:28:23.354]                             if (!has_future) {
[09:28:23.354]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.354]                                 info)
[09:28:23.354]                             }
[09:28:23.354]                             else {
[09:28:23.354]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.354]                                 info, version)
[09:28:23.354]                             }
[09:28:23.354]                             base::stop(msg)
[09:28:23.354]                           }
[09:28:23.354]                         })
[09:28:23.354]                       }
[09:28:23.354]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.354]                       base::options(mc.cores = 1L)
[09:28:23.354]                     }
[09:28:23.354]                     base::local({
[09:28:23.354]                       for (pkg in "stats") {
[09:28:23.354]                         base::loadNamespace(pkg)
[09:28:23.354]                         base::library(pkg, character.only = TRUE)
[09:28:23.354]                       }
[09:28:23.354]                     })
[09:28:23.354]                   }
[09:28:23.354]                   ...future.strategy.old <- future::plan("list")
[09:28:23.354]                   options(future.plan = NULL)
[09:28:23.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.354]                 }
[09:28:23.354]                 ...future.workdir <- getwd()
[09:28:23.354]             }
[09:28:23.354]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.354]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.354]         }
[09:28:23.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.354]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.354]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.354]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.354]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.354]             base::names(...future.oldOptions))
[09:28:23.354]     }
[09:28:23.354]     if (FALSE) {
[09:28:23.354]     }
[09:28:23.354]     else {
[09:28:23.354]         if (TRUE) {
[09:28:23.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.354]                 open = "w")
[09:28:23.354]         }
[09:28:23.354]         else {
[09:28:23.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.354]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.354]         }
[09:28:23.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.354]             base::sink(type = "output", split = FALSE)
[09:28:23.354]             base::close(...future.stdout)
[09:28:23.354]         }, add = TRUE)
[09:28:23.354]     }
[09:28:23.354]     ...future.frame <- base::sys.nframe()
[09:28:23.354]     ...future.conditions <- base::list()
[09:28:23.354]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.354]     if (FALSE) {
[09:28:23.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.354]     }
[09:28:23.354]     ...future.result <- base::tryCatch({
[09:28:23.354]         base::withCallingHandlers({
[09:28:23.354]             ...future.value <- base::withVisible(base::local({
[09:28:23.354]                 withCallingHandlers({
[09:28:23.354]                   {
[09:28:23.354]                     do.call(function(...) {
[09:28:23.354]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.354]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.354]                         ...future.globals.maxSize)) {
[09:28:23.354]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.354]                         on.exit(options(oopts), add = TRUE)
[09:28:23.354]                       }
[09:28:23.354]                       {
[09:28:23.354]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.354]                           FUN = function(jj) {
[09:28:23.354]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.354]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.354]                           })
[09:28:23.354]                       }
[09:28:23.354]                     }, args = future.call.arguments)
[09:28:23.354]                   }
[09:28:23.354]                 }, immediateCondition = function(cond) {
[09:28:23.354]                   save_rds <- function (object, pathname, ...) 
[09:28:23.354]                   {
[09:28:23.354]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.354]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.354]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.354]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.354]                         fi_tmp[["mtime"]])
[09:28:23.354]                     }
[09:28:23.354]                     tryCatch({
[09:28:23.354]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.354]                     }, error = function(ex) {
[09:28:23.354]                       msg <- conditionMessage(ex)
[09:28:23.354]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.354]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.354]                         fi_tmp[["mtime"]], msg)
[09:28:23.354]                       ex$message <- msg
[09:28:23.354]                       stop(ex)
[09:28:23.354]                     })
[09:28:23.354]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.354]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.354]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.354]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.354]                       fi <- file.info(pathname)
[09:28:23.354]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.354]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.354]                         fi[["size"]], fi[["mtime"]])
[09:28:23.354]                       stop(msg)
[09:28:23.354]                     }
[09:28:23.354]                     invisible(pathname)
[09:28:23.354]                   }
[09:28:23.354]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.354]                     rootPath = tempdir()) 
[09:28:23.354]                   {
[09:28:23.354]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.354]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.354]                       tmpdir = path, fileext = ".rds")
[09:28:23.354]                     save_rds(obj, file)
[09:28:23.354]                   }
[09:28:23.354]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.354]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.354]                   {
[09:28:23.354]                     inherits <- base::inherits
[09:28:23.354]                     invokeRestart <- base::invokeRestart
[09:28:23.354]                     is.null <- base::is.null
[09:28:23.354]                     muffled <- FALSE
[09:28:23.354]                     if (inherits(cond, "message")) {
[09:28:23.354]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.354]                       if (muffled) 
[09:28:23.354]                         invokeRestart("muffleMessage")
[09:28:23.354]                     }
[09:28:23.354]                     else if (inherits(cond, "warning")) {
[09:28:23.354]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.354]                       if (muffled) 
[09:28:23.354]                         invokeRestart("muffleWarning")
[09:28:23.354]                     }
[09:28:23.354]                     else if (inherits(cond, "condition")) {
[09:28:23.354]                       if (!is.null(pattern)) {
[09:28:23.354]                         computeRestarts <- base::computeRestarts
[09:28:23.354]                         grepl <- base::grepl
[09:28:23.354]                         restarts <- computeRestarts(cond)
[09:28:23.354]                         for (restart in restarts) {
[09:28:23.354]                           name <- restart$name
[09:28:23.354]                           if (is.null(name)) 
[09:28:23.354]                             next
[09:28:23.354]                           if (!grepl(pattern, name)) 
[09:28:23.354]                             next
[09:28:23.354]                           invokeRestart(restart)
[09:28:23.354]                           muffled <- TRUE
[09:28:23.354]                           break
[09:28:23.354]                         }
[09:28:23.354]                       }
[09:28:23.354]                     }
[09:28:23.354]                     invisible(muffled)
[09:28:23.354]                   }
[09:28:23.354]                   muffleCondition(cond)
[09:28:23.354]                 })
[09:28:23.354]             }))
[09:28:23.354]             future::FutureResult(value = ...future.value$value, 
[09:28:23.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.354]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.354]                     ...future.globalenv.names))
[09:28:23.354]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.354]         }, condition = base::local({
[09:28:23.354]             c <- base::c
[09:28:23.354]             inherits <- base::inherits
[09:28:23.354]             invokeRestart <- base::invokeRestart
[09:28:23.354]             length <- base::length
[09:28:23.354]             list <- base::list
[09:28:23.354]             seq.int <- base::seq.int
[09:28:23.354]             signalCondition <- base::signalCondition
[09:28:23.354]             sys.calls <- base::sys.calls
[09:28:23.354]             `[[` <- base::`[[`
[09:28:23.354]             `+` <- base::`+`
[09:28:23.354]             `<<-` <- base::`<<-`
[09:28:23.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.354]                   3L)]
[09:28:23.354]             }
[09:28:23.354]             function(cond) {
[09:28:23.354]                 is_error <- inherits(cond, "error")
[09:28:23.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.354]                   NULL)
[09:28:23.354]                 if (is_error) {
[09:28:23.354]                   sessionInformation <- function() {
[09:28:23.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.354]                       search = base::search(), system = base::Sys.info())
[09:28:23.354]                   }
[09:28:23.354]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.354]                     cond$call), session = sessionInformation(), 
[09:28:23.354]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.354]                   signalCondition(cond)
[09:28:23.354]                 }
[09:28:23.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.354]                 "immediateCondition"))) {
[09:28:23.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.354]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.354]                   if (TRUE && !signal) {
[09:28:23.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.354]                     {
[09:28:23.354]                       inherits <- base::inherits
[09:28:23.354]                       invokeRestart <- base::invokeRestart
[09:28:23.354]                       is.null <- base::is.null
[09:28:23.354]                       muffled <- FALSE
[09:28:23.354]                       if (inherits(cond, "message")) {
[09:28:23.354]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.354]                         if (muffled) 
[09:28:23.354]                           invokeRestart("muffleMessage")
[09:28:23.354]                       }
[09:28:23.354]                       else if (inherits(cond, "warning")) {
[09:28:23.354]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.354]                         if (muffled) 
[09:28:23.354]                           invokeRestart("muffleWarning")
[09:28:23.354]                       }
[09:28:23.354]                       else if (inherits(cond, "condition")) {
[09:28:23.354]                         if (!is.null(pattern)) {
[09:28:23.354]                           computeRestarts <- base::computeRestarts
[09:28:23.354]                           grepl <- base::grepl
[09:28:23.354]                           restarts <- computeRestarts(cond)
[09:28:23.354]                           for (restart in restarts) {
[09:28:23.354]                             name <- restart$name
[09:28:23.354]                             if (is.null(name)) 
[09:28:23.354]                               next
[09:28:23.354]                             if (!grepl(pattern, name)) 
[09:28:23.354]                               next
[09:28:23.354]                             invokeRestart(restart)
[09:28:23.354]                             muffled <- TRUE
[09:28:23.354]                             break
[09:28:23.354]                           }
[09:28:23.354]                         }
[09:28:23.354]                       }
[09:28:23.354]                       invisible(muffled)
[09:28:23.354]                     }
[09:28:23.354]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.354]                   }
[09:28:23.354]                 }
[09:28:23.354]                 else {
[09:28:23.354]                   if (TRUE) {
[09:28:23.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.354]                     {
[09:28:23.354]                       inherits <- base::inherits
[09:28:23.354]                       invokeRestart <- base::invokeRestart
[09:28:23.354]                       is.null <- base::is.null
[09:28:23.354]                       muffled <- FALSE
[09:28:23.354]                       if (inherits(cond, "message")) {
[09:28:23.354]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.354]                         if (muffled) 
[09:28:23.354]                           invokeRestart("muffleMessage")
[09:28:23.354]                       }
[09:28:23.354]                       else if (inherits(cond, "warning")) {
[09:28:23.354]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.354]                         if (muffled) 
[09:28:23.354]                           invokeRestart("muffleWarning")
[09:28:23.354]                       }
[09:28:23.354]                       else if (inherits(cond, "condition")) {
[09:28:23.354]                         if (!is.null(pattern)) {
[09:28:23.354]                           computeRestarts <- base::computeRestarts
[09:28:23.354]                           grepl <- base::grepl
[09:28:23.354]                           restarts <- computeRestarts(cond)
[09:28:23.354]                           for (restart in restarts) {
[09:28:23.354]                             name <- restart$name
[09:28:23.354]                             if (is.null(name)) 
[09:28:23.354]                               next
[09:28:23.354]                             if (!grepl(pattern, name)) 
[09:28:23.354]                               next
[09:28:23.354]                             invokeRestart(restart)
[09:28:23.354]                             muffled <- TRUE
[09:28:23.354]                             break
[09:28:23.354]                           }
[09:28:23.354]                         }
[09:28:23.354]                       }
[09:28:23.354]                       invisible(muffled)
[09:28:23.354]                     }
[09:28:23.354]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.354]                   }
[09:28:23.354]                 }
[09:28:23.354]             }
[09:28:23.354]         }))
[09:28:23.354]     }, error = function(ex) {
[09:28:23.354]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.354]                 ...future.rng), started = ...future.startTime, 
[09:28:23.354]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.354]             version = "1.8"), class = "FutureResult")
[09:28:23.354]     }, finally = {
[09:28:23.354]         if (!identical(...future.workdir, getwd())) 
[09:28:23.354]             setwd(...future.workdir)
[09:28:23.354]         {
[09:28:23.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.354]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.354]             }
[09:28:23.354]             base::options(...future.oldOptions)
[09:28:23.354]             if (.Platform$OS.type == "windows") {
[09:28:23.354]                 old_names <- names(...future.oldEnvVars)
[09:28:23.354]                 envs <- base::Sys.getenv()
[09:28:23.354]                 names <- names(envs)
[09:28:23.354]                 common <- intersect(names, old_names)
[09:28:23.354]                 added <- setdiff(names, old_names)
[09:28:23.354]                 removed <- setdiff(old_names, names)
[09:28:23.354]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.354]                   envs[common]]
[09:28:23.354]                 NAMES <- toupper(changed)
[09:28:23.354]                 args <- list()
[09:28:23.354]                 for (kk in seq_along(NAMES)) {
[09:28:23.354]                   name <- changed[[kk]]
[09:28:23.354]                   NAME <- NAMES[[kk]]
[09:28:23.354]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.354]                     next
[09:28:23.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.354]                 }
[09:28:23.354]                 NAMES <- toupper(added)
[09:28:23.354]                 for (kk in seq_along(NAMES)) {
[09:28:23.354]                   name <- added[[kk]]
[09:28:23.354]                   NAME <- NAMES[[kk]]
[09:28:23.354]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.354]                     next
[09:28:23.354]                   args[[name]] <- ""
[09:28:23.354]                 }
[09:28:23.354]                 NAMES <- toupper(removed)
[09:28:23.354]                 for (kk in seq_along(NAMES)) {
[09:28:23.354]                   name <- removed[[kk]]
[09:28:23.354]                   NAME <- NAMES[[kk]]
[09:28:23.354]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.354]                     next
[09:28:23.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.354]                 }
[09:28:23.354]                 if (length(args) > 0) 
[09:28:23.354]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.354]             }
[09:28:23.354]             else {
[09:28:23.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.354]             }
[09:28:23.354]             {
[09:28:23.354]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.354]                   0L) {
[09:28:23.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.354]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.354]                   base::options(opts)
[09:28:23.354]                 }
[09:28:23.354]                 {
[09:28:23.354]                   {
[09:28:23.354]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.354]                     NULL
[09:28:23.354]                   }
[09:28:23.354]                   options(future.plan = NULL)
[09:28:23.354]                   if (is.na(NA_character_)) 
[09:28:23.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.354]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.354]                     .init = FALSE)
[09:28:23.354]                 }
[09:28:23.354]             }
[09:28:23.354]         }
[09:28:23.354]     })
[09:28:23.354]     if (TRUE) {
[09:28:23.354]         base::sink(type = "output", split = FALSE)
[09:28:23.354]         if (TRUE) {
[09:28:23.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.354]         }
[09:28:23.354]         else {
[09:28:23.354]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.354]         }
[09:28:23.354]         base::close(...future.stdout)
[09:28:23.354]         ...future.stdout <- NULL
[09:28:23.354]     }
[09:28:23.354]     ...future.result$conditions <- ...future.conditions
[09:28:23.354]     ...future.result$finished <- base::Sys.time()
[09:28:23.354]     ...future.result
[09:28:23.354] }
[09:28:23.356] assign_globals() ...
[09:28:23.356] List of 5
[09:28:23.356]  $ ...future.FUN            :function (x, ...)  
[09:28:23.356]  $ future.call.arguments    :List of 1
[09:28:23.356]   ..$ singular.ok: logi FALSE
[09:28:23.356]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.356]  $ ...future.elements_ii    :List of 2
[09:28:23.356]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.356]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:23.356]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.356]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:23.356]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.356]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:23.356]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.356]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:23.356]  $ ...future.seeds_ii       : NULL
[09:28:23.356]  $ ...future.globals.maxSize: NULL
[09:28:23.356]  - attr(*, "where")=List of 5
[09:28:23.356]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.356]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.356]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.356]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.356]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.356]  - attr(*, "resolved")= logi FALSE
[09:28:23.356]  - attr(*, "total_size")= num 5384
[09:28:23.356]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.356]  - attr(*, "already-done")= logi TRUE
[09:28:23.366] - reassign environment for ‘...future.FUN’
[09:28:23.366] - copied ‘...future.FUN’ to environment
[09:28:23.367] - copied ‘future.call.arguments’ to environment
[09:28:23.367] - copied ‘...future.elements_ii’ to environment
[09:28:23.367] - copied ‘...future.seeds_ii’ to environment
[09:28:23.367] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.367] assign_globals() ... done
[09:28:23.367] requestCore(): workers = 2
[09:28:23.369] MulticoreFuture started
[09:28:23.369] - Launch lazy future ... done
[09:28:23.370] run() for ‘MulticoreFuture’ ... done
[09:28:23.370] Created future:
[09:28:23.370] plan(): Setting new future strategy stack:
[09:28:23.371] List of future strategies:
[09:28:23.371] 1. sequential:
[09:28:23.371]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.371]    - tweaked: FALSE
[09:28:23.371]    - call: NULL
[09:28:23.372] plan(): nbrOfWorkers() = 1
[09:28:23.376] plan(): Setting new future strategy stack:
[09:28:23.376] List of future strategies:
[09:28:23.376] 1. multicore:
[09:28:23.376]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.376]    - tweaked: FALSE
[09:28:23.376]    - call: plan(strategy)
[09:28:23.381] plan(): nbrOfWorkers() = 2
[09:28:23.370] MulticoreFuture:
[09:28:23.370] Label: ‘future_by-2’
[09:28:23.370] Expression:
[09:28:23.370] {
[09:28:23.370]     do.call(function(...) {
[09:28:23.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.370]             on.exit(options(oopts), add = TRUE)
[09:28:23.370]         }
[09:28:23.370]         {
[09:28:23.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.370]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.370]             })
[09:28:23.370]         }
[09:28:23.370]     }, args = future.call.arguments)
[09:28:23.370] }
[09:28:23.370] Lazy evaluation: FALSE
[09:28:23.370] Asynchronous evaluation: TRUE
[09:28:23.370] Local evaluation: TRUE
[09:28:23.370] Environment: R_GlobalEnv
[09:28:23.370] Capture standard output: TRUE
[09:28:23.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.370] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:23.370] Packages: 1 packages (‘stats’)
[09:28:23.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.370] Resolved: FALSE
[09:28:23.370] Value: <not collected>
[09:28:23.370] Conditions captured: <none>
[09:28:23.370] Early signaling: FALSE
[09:28:23.370] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.370] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.383] Chunk #2 of 2 ... DONE
[09:28:23.383] Launching 2 futures (chunks) ... DONE
[09:28:23.383] Resolving 2 futures (chunks) ...
[09:28:23.384] resolve() on list ...
[09:28:23.384]  recursive: 0
[09:28:23.384]  length: 2
[09:28:23.384] 
[09:28:23.384] Future #1
[09:28:23.385] result() for MulticoreFuture ...
[09:28:23.386] result() for MulticoreFuture ...
[09:28:23.386] result() for MulticoreFuture ... done
[09:28:23.386] result() for MulticoreFuture ... done
[09:28:23.386] result() for MulticoreFuture ...
[09:28:23.387] result() for MulticoreFuture ... done
[09:28:23.387] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:23.387] - nx: 2
[09:28:23.387] - relay: TRUE
[09:28:23.387] - stdout: TRUE
[09:28:23.387] - signal: TRUE
[09:28:23.387] - resignal: FALSE
[09:28:23.387] - force: TRUE
[09:28:23.388] - relayed: [n=2] FALSE, FALSE
[09:28:23.388] - queued futures: [n=2] FALSE, FALSE
[09:28:23.388]  - until=1
[09:28:23.388]  - relaying element #1
[09:28:23.390] result() for MulticoreFuture ...
[09:28:23.391] result() for MulticoreFuture ... done
[09:28:23.391] result() for MulticoreFuture ...
[09:28:23.391] result() for MulticoreFuture ... done
[09:28:23.392] result() for MulticoreFuture ...
[09:28:23.392] result() for MulticoreFuture ... done
[09:28:23.392] result() for MulticoreFuture ...
[09:28:23.393] result() for MulticoreFuture ... done
[09:28:23.393] - relayed: [n=2] TRUE, FALSE
[09:28:23.393] - queued futures: [n=2] TRUE, FALSE
[09:28:23.393] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:23.394]  length: 1 (resolved future 1)
[09:28:23.394] Future #2
[09:28:23.395] result() for MulticoreFuture ...
[09:28:23.397] result() for MulticoreFuture ...
[09:28:23.397] result() for MulticoreFuture ... done
[09:28:23.397] result() for MulticoreFuture ... done
[09:28:23.397] result() for MulticoreFuture ...
[09:28:23.397] result() for MulticoreFuture ... done
[09:28:23.398] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:23.398] - nx: 2
[09:28:23.398] - relay: TRUE
[09:28:23.398] - stdout: TRUE
[09:28:23.398] - signal: TRUE
[09:28:23.398] - resignal: FALSE
[09:28:23.398] - force: TRUE
[09:28:23.399] - relayed: [n=2] TRUE, FALSE
[09:28:23.399] - queued futures: [n=2] TRUE, FALSE
[09:28:23.399]  - until=2
[09:28:23.399]  - relaying element #2
[09:28:23.399] result() for MulticoreFuture ...
[09:28:23.399] result() for MulticoreFuture ... done
[09:28:23.399] result() for MulticoreFuture ...
[09:28:23.400] result() for MulticoreFuture ... done
[09:28:23.400] result() for MulticoreFuture ...
[09:28:23.400] result() for MulticoreFuture ... done
[09:28:23.400] result() for MulticoreFuture ...
[09:28:23.400] result() for MulticoreFuture ... done
[09:28:23.400] - relayed: [n=2] TRUE, TRUE
[09:28:23.400] - queued futures: [n=2] TRUE, TRUE
[09:28:23.401] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:23.401]  length: 0 (resolved future 2)
[09:28:23.401] Relaying remaining futures
[09:28:23.401] signalConditionsASAP(NULL, pos=0) ...
[09:28:23.401] - nx: 2
[09:28:23.401] - relay: TRUE
[09:28:23.401] - stdout: TRUE
[09:28:23.401] - signal: TRUE
[09:28:23.401] - resignal: FALSE
[09:28:23.402] - force: TRUE
[09:28:23.402] - relayed: [n=2] TRUE, TRUE
[09:28:23.402] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:23.402] - relayed: [n=2] TRUE, TRUE
[09:28:23.402] - queued futures: [n=2] TRUE, TRUE
[09:28:23.402] signalConditionsASAP(NULL, pos=0) ... done
[09:28:23.402] resolve() on list ... DONE
[09:28:23.402] result() for MulticoreFuture ...
[09:28:23.402] result() for MulticoreFuture ... done
[09:28:23.403] result() for MulticoreFuture ...
[09:28:23.403] result() for MulticoreFuture ... done
[09:28:23.403] result() for MulticoreFuture ...
[09:28:23.403] result() for MulticoreFuture ... done
[09:28:23.403] result() for MulticoreFuture ...
[09:28:23.403] result() for MulticoreFuture ... done
[09:28:23.403]  - Number of value chunks collected: 2
[09:28:23.403] Resolving 2 futures (chunks) ... DONE
[09:28:23.403] Reducing values from 2 chunks ...
[09:28:23.404]  - Number of values collected after concatenation: 3
[09:28:23.404]  - Number of values expected: 3
[09:28:23.404] Reducing values from 2 chunks ... DONE
[09:28:23.404] future_lapply() ... DONE
[09:28:23.404] future_by_internal() ... DONE
[09:28:23.408] future_by_internal() ...
[09:28:23.409] future_lapply() ...
[09:28:23.414] Number of chunks: 2
[09:28:23.414] getGlobalsAndPackagesXApply() ...
[09:28:23.414]  - future.globals: TRUE
[09:28:23.414] getGlobalsAndPackages() ...
[09:28:23.414] Searching for globals...
[09:28:23.420] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:23.420] Searching for globals ... DONE
[09:28:23.420] Resolving globals: FALSE
[09:28:23.420] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[09:28:23.421] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[09:28:23.421] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:23.421] - packages: [1] ‘stats’
[09:28:23.421] getGlobalsAndPackages() ... DONE
[09:28:23.421]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:23.421]  - needed namespaces: [n=1] ‘stats’
[09:28:23.422] Finding globals ... DONE
[09:28:23.422]  - use_args: TRUE
[09:28:23.422]  - Getting '...' globals ...
[09:28:23.422] resolve() on list ...
[09:28:23.422]  recursive: 0
[09:28:23.422]  length: 1
[09:28:23.422]  elements: ‘...’
[09:28:23.423]  length: 0 (resolved future 1)
[09:28:23.423] resolve() on list ... DONE
[09:28:23.423]    - '...' content: [n=0] 
[09:28:23.423] List of 1
[09:28:23.423]  $ ...: list()
[09:28:23.423]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.423]  - attr(*, "where")=List of 1
[09:28:23.423]   ..$ ...:<environment: 0x555b0a4c6088> 
[09:28:23.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.423]  - attr(*, "resolved")= logi TRUE
[09:28:23.423]  - attr(*, "total_size")= num NA
[09:28:23.426]  - Getting '...' globals ... DONE
[09:28:23.426] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[09:28:23.426] List of 4
[09:28:23.426]  $ ...future.FUN:function (x)  
[09:28:23.426]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:23.426]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:23.426]  $ ...          : list()
[09:28:23.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.426]  - attr(*, "where")=List of 4
[09:28:23.426]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:23.426]   ..$ breaks       :<environment: R_EmptyEnv> 
[09:28:23.426]   ..$ wool         :<environment: R_EmptyEnv> 
[09:28:23.426]   ..$ ...          :<environment: 0x555b0a4c6088> 
[09:28:23.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.426]  - attr(*, "resolved")= logi FALSE
[09:28:23.426]  - attr(*, "total_size")= num 2320
[09:28:23.430] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:23.430] getGlobalsAndPackagesXApply() ... DONE
[09:28:23.430] Number of futures (= number of chunks): 2
[09:28:23.430] Launching 2 futures (chunks) ...
[09:28:23.430] Chunk #1 of 2 ...
[09:28:23.430]  - Finding globals in 'X' for chunk #1 ...
[09:28:23.430] getGlobalsAndPackages() ...
[09:28:23.430] Searching for globals...
[09:28:23.431] 
[09:28:23.431] Searching for globals ... DONE
[09:28:23.431] - globals: [0] <none>
[09:28:23.431] getGlobalsAndPackages() ... DONE
[09:28:23.431]    + additional globals found: [n=0] 
[09:28:23.431]    + additional namespaces needed: [n=0] 
[09:28:23.431]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:23.431]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.431]  - seeds: <none>
[09:28:23.432]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.432] getGlobalsAndPackages() ...
[09:28:23.432] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.432] Resolving globals: FALSE
[09:28:23.432] Tweak future expression to call with '...' arguments ...
[09:28:23.432] {
[09:28:23.432]     do.call(function(...) {
[09:28:23.432]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.432]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.432]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.432]             on.exit(options(oopts), add = TRUE)
[09:28:23.432]         }
[09:28:23.432]         {
[09:28:23.432]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.432]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.432]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.432]             })
[09:28:23.432]         }
[09:28:23.432]     }, args = future.call.arguments)
[09:28:23.432] }
[09:28:23.432] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.433] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.433] 
[09:28:23.433] getGlobalsAndPackages() ... DONE
[09:28:23.433] run() for ‘Future’ ...
[09:28:23.433] - state: ‘created’
[09:28:23.433] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.437] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.437] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.437]   - Field: ‘label’
[09:28:23.437]   - Field: ‘local’
[09:28:23.437]   - Field: ‘owner’
[09:28:23.437]   - Field: ‘envir’
[09:28:23.438]   - Field: ‘workers’
[09:28:23.438]   - Field: ‘packages’
[09:28:23.438]   - Field: ‘gc’
[09:28:23.438]   - Field: ‘job’
[09:28:23.438]   - Field: ‘conditions’
[09:28:23.438]   - Field: ‘expr’
[09:28:23.438]   - Field: ‘uuid’
[09:28:23.438]   - Field: ‘seed’
[09:28:23.438]   - Field: ‘version’
[09:28:23.438]   - Field: ‘result’
[09:28:23.438]   - Field: ‘asynchronous’
[09:28:23.439]   - Field: ‘calls’
[09:28:23.439]   - Field: ‘globals’
[09:28:23.439]   - Field: ‘stdout’
[09:28:23.439]   - Field: ‘earlySignal’
[09:28:23.439]   - Field: ‘lazy’
[09:28:23.439]   - Field: ‘state’
[09:28:23.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.439] - Launch lazy future ...
[09:28:23.441] Packages needed by the future expression (n = 1): ‘stats’
[09:28:23.441] Packages needed by future strategies (n = 0): <none>
[09:28:23.441] {
[09:28:23.441]     {
[09:28:23.441]         {
[09:28:23.441]             ...future.startTime <- base::Sys.time()
[09:28:23.441]             {
[09:28:23.441]                 {
[09:28:23.441]                   {
[09:28:23.441]                     {
[09:28:23.441]                       {
[09:28:23.441]                         base::local({
[09:28:23.441]                           has_future <- base::requireNamespace("future", 
[09:28:23.441]                             quietly = TRUE)
[09:28:23.441]                           if (has_future) {
[09:28:23.441]                             ns <- base::getNamespace("future")
[09:28:23.441]                             version <- ns[[".package"]][["version"]]
[09:28:23.441]                             if (is.null(version)) 
[09:28:23.441]                               version <- utils::packageVersion("future")
[09:28:23.441]                           }
[09:28:23.441]                           else {
[09:28:23.441]                             version <- NULL
[09:28:23.441]                           }
[09:28:23.441]                           if (!has_future || version < "1.8.0") {
[09:28:23.441]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.441]                               "", base::R.version$version.string), 
[09:28:23.441]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:23.441]                                 base::R.version$platform, 8 * 
[09:28:23.441]                                   base::.Machine$sizeof.pointer), 
[09:28:23.441]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.441]                                 "release", "version")], collapse = " "), 
[09:28:23.441]                               hostname = base::Sys.info()[["nodename"]])
[09:28:23.441]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.441]                               info)
[09:28:23.441]                             info <- base::paste(info, collapse = "; ")
[09:28:23.441]                             if (!has_future) {
[09:28:23.441]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.441]                                 info)
[09:28:23.441]                             }
[09:28:23.441]                             else {
[09:28:23.441]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.441]                                 info, version)
[09:28:23.441]                             }
[09:28:23.441]                             base::stop(msg)
[09:28:23.441]                           }
[09:28:23.441]                         })
[09:28:23.441]                       }
[09:28:23.441]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.441]                       base::options(mc.cores = 1L)
[09:28:23.441]                     }
[09:28:23.441]                     base::local({
[09:28:23.441]                       for (pkg in "stats") {
[09:28:23.441]                         base::loadNamespace(pkg)
[09:28:23.441]                         base::library(pkg, character.only = TRUE)
[09:28:23.441]                       }
[09:28:23.441]                     })
[09:28:23.441]                   }
[09:28:23.441]                   ...future.strategy.old <- future::plan("list")
[09:28:23.441]                   options(future.plan = NULL)
[09:28:23.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.441]                 }
[09:28:23.441]                 ...future.workdir <- getwd()
[09:28:23.441]             }
[09:28:23.441]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.441]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.441]         }
[09:28:23.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.441]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.441]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.441]             base::names(...future.oldOptions))
[09:28:23.441]     }
[09:28:23.441]     if (FALSE) {
[09:28:23.441]     }
[09:28:23.441]     else {
[09:28:23.441]         if (TRUE) {
[09:28:23.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.441]                 open = "w")
[09:28:23.441]         }
[09:28:23.441]         else {
[09:28:23.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.441]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.441]         }
[09:28:23.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.441]             base::sink(type = "output", split = FALSE)
[09:28:23.441]             base::close(...future.stdout)
[09:28:23.441]         }, add = TRUE)
[09:28:23.441]     }
[09:28:23.441]     ...future.frame <- base::sys.nframe()
[09:28:23.441]     ...future.conditions <- base::list()
[09:28:23.441]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.441]     if (FALSE) {
[09:28:23.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.441]     }
[09:28:23.441]     ...future.result <- base::tryCatch({
[09:28:23.441]         base::withCallingHandlers({
[09:28:23.441]             ...future.value <- base::withVisible(base::local({
[09:28:23.441]                 withCallingHandlers({
[09:28:23.441]                   {
[09:28:23.441]                     do.call(function(...) {
[09:28:23.441]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.441]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.441]                         ...future.globals.maxSize)) {
[09:28:23.441]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.441]                         on.exit(options(oopts), add = TRUE)
[09:28:23.441]                       }
[09:28:23.441]                       {
[09:28:23.441]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.441]                           FUN = function(jj) {
[09:28:23.441]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.441]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.441]                           })
[09:28:23.441]                       }
[09:28:23.441]                     }, args = future.call.arguments)
[09:28:23.441]                   }
[09:28:23.441]                 }, immediateCondition = function(cond) {
[09:28:23.441]                   save_rds <- function (object, pathname, ...) 
[09:28:23.441]                   {
[09:28:23.441]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.441]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.441]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.441]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.441]                         fi_tmp[["mtime"]])
[09:28:23.441]                     }
[09:28:23.441]                     tryCatch({
[09:28:23.441]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.441]                     }, error = function(ex) {
[09:28:23.441]                       msg <- conditionMessage(ex)
[09:28:23.441]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.441]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.441]                         fi_tmp[["mtime"]], msg)
[09:28:23.441]                       ex$message <- msg
[09:28:23.441]                       stop(ex)
[09:28:23.441]                     })
[09:28:23.441]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.441]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.441]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.441]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.441]                       fi <- file.info(pathname)
[09:28:23.441]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.441]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.441]                         fi[["size"]], fi[["mtime"]])
[09:28:23.441]                       stop(msg)
[09:28:23.441]                     }
[09:28:23.441]                     invisible(pathname)
[09:28:23.441]                   }
[09:28:23.441]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.441]                     rootPath = tempdir()) 
[09:28:23.441]                   {
[09:28:23.441]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.441]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.441]                       tmpdir = path, fileext = ".rds")
[09:28:23.441]                     save_rds(obj, file)
[09:28:23.441]                   }
[09:28:23.441]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.441]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.441]                   {
[09:28:23.441]                     inherits <- base::inherits
[09:28:23.441]                     invokeRestart <- base::invokeRestart
[09:28:23.441]                     is.null <- base::is.null
[09:28:23.441]                     muffled <- FALSE
[09:28:23.441]                     if (inherits(cond, "message")) {
[09:28:23.441]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.441]                       if (muffled) 
[09:28:23.441]                         invokeRestart("muffleMessage")
[09:28:23.441]                     }
[09:28:23.441]                     else if (inherits(cond, "warning")) {
[09:28:23.441]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.441]                       if (muffled) 
[09:28:23.441]                         invokeRestart("muffleWarning")
[09:28:23.441]                     }
[09:28:23.441]                     else if (inherits(cond, "condition")) {
[09:28:23.441]                       if (!is.null(pattern)) {
[09:28:23.441]                         computeRestarts <- base::computeRestarts
[09:28:23.441]                         grepl <- base::grepl
[09:28:23.441]                         restarts <- computeRestarts(cond)
[09:28:23.441]                         for (restart in restarts) {
[09:28:23.441]                           name <- restart$name
[09:28:23.441]                           if (is.null(name)) 
[09:28:23.441]                             next
[09:28:23.441]                           if (!grepl(pattern, name)) 
[09:28:23.441]                             next
[09:28:23.441]                           invokeRestart(restart)
[09:28:23.441]                           muffled <- TRUE
[09:28:23.441]                           break
[09:28:23.441]                         }
[09:28:23.441]                       }
[09:28:23.441]                     }
[09:28:23.441]                     invisible(muffled)
[09:28:23.441]                   }
[09:28:23.441]                   muffleCondition(cond)
[09:28:23.441]                 })
[09:28:23.441]             }))
[09:28:23.441]             future::FutureResult(value = ...future.value$value, 
[09:28:23.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.441]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.441]                     ...future.globalenv.names))
[09:28:23.441]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.441]         }, condition = base::local({
[09:28:23.441]             c <- base::c
[09:28:23.441]             inherits <- base::inherits
[09:28:23.441]             invokeRestart <- base::invokeRestart
[09:28:23.441]             length <- base::length
[09:28:23.441]             list <- base::list
[09:28:23.441]             seq.int <- base::seq.int
[09:28:23.441]             signalCondition <- base::signalCondition
[09:28:23.441]             sys.calls <- base::sys.calls
[09:28:23.441]             `[[` <- base::`[[`
[09:28:23.441]             `+` <- base::`+`
[09:28:23.441]             `<<-` <- base::`<<-`
[09:28:23.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.441]                   3L)]
[09:28:23.441]             }
[09:28:23.441]             function(cond) {
[09:28:23.441]                 is_error <- inherits(cond, "error")
[09:28:23.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.441]                   NULL)
[09:28:23.441]                 if (is_error) {
[09:28:23.441]                   sessionInformation <- function() {
[09:28:23.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.441]                       search = base::search(), system = base::Sys.info())
[09:28:23.441]                   }
[09:28:23.441]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.441]                     cond$call), session = sessionInformation(), 
[09:28:23.441]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.441]                   signalCondition(cond)
[09:28:23.441]                 }
[09:28:23.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.441]                 "immediateCondition"))) {
[09:28:23.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.441]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.441]                   if (TRUE && !signal) {
[09:28:23.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.441]                     {
[09:28:23.441]                       inherits <- base::inherits
[09:28:23.441]                       invokeRestart <- base::invokeRestart
[09:28:23.441]                       is.null <- base::is.null
[09:28:23.441]                       muffled <- FALSE
[09:28:23.441]                       if (inherits(cond, "message")) {
[09:28:23.441]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.441]                         if (muffled) 
[09:28:23.441]                           invokeRestart("muffleMessage")
[09:28:23.441]                       }
[09:28:23.441]                       else if (inherits(cond, "warning")) {
[09:28:23.441]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.441]                         if (muffled) 
[09:28:23.441]                           invokeRestart("muffleWarning")
[09:28:23.441]                       }
[09:28:23.441]                       else if (inherits(cond, "condition")) {
[09:28:23.441]                         if (!is.null(pattern)) {
[09:28:23.441]                           computeRestarts <- base::computeRestarts
[09:28:23.441]                           grepl <- base::grepl
[09:28:23.441]                           restarts <- computeRestarts(cond)
[09:28:23.441]                           for (restart in restarts) {
[09:28:23.441]                             name <- restart$name
[09:28:23.441]                             if (is.null(name)) 
[09:28:23.441]                               next
[09:28:23.441]                             if (!grepl(pattern, name)) 
[09:28:23.441]                               next
[09:28:23.441]                             invokeRestart(restart)
[09:28:23.441]                             muffled <- TRUE
[09:28:23.441]                             break
[09:28:23.441]                           }
[09:28:23.441]                         }
[09:28:23.441]                       }
[09:28:23.441]                       invisible(muffled)
[09:28:23.441]                     }
[09:28:23.441]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.441]                   }
[09:28:23.441]                 }
[09:28:23.441]                 else {
[09:28:23.441]                   if (TRUE) {
[09:28:23.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.441]                     {
[09:28:23.441]                       inherits <- base::inherits
[09:28:23.441]                       invokeRestart <- base::invokeRestart
[09:28:23.441]                       is.null <- base::is.null
[09:28:23.441]                       muffled <- FALSE
[09:28:23.441]                       if (inherits(cond, "message")) {
[09:28:23.441]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.441]                         if (muffled) 
[09:28:23.441]                           invokeRestart("muffleMessage")
[09:28:23.441]                       }
[09:28:23.441]                       else if (inherits(cond, "warning")) {
[09:28:23.441]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.441]                         if (muffled) 
[09:28:23.441]                           invokeRestart("muffleWarning")
[09:28:23.441]                       }
[09:28:23.441]                       else if (inherits(cond, "condition")) {
[09:28:23.441]                         if (!is.null(pattern)) {
[09:28:23.441]                           computeRestarts <- base::computeRestarts
[09:28:23.441]                           grepl <- base::grepl
[09:28:23.441]                           restarts <- computeRestarts(cond)
[09:28:23.441]                           for (restart in restarts) {
[09:28:23.441]                             name <- restart$name
[09:28:23.441]                             if (is.null(name)) 
[09:28:23.441]                               next
[09:28:23.441]                             if (!grepl(pattern, name)) 
[09:28:23.441]                               next
[09:28:23.441]                             invokeRestart(restart)
[09:28:23.441]                             muffled <- TRUE
[09:28:23.441]                             break
[09:28:23.441]                           }
[09:28:23.441]                         }
[09:28:23.441]                       }
[09:28:23.441]                       invisible(muffled)
[09:28:23.441]                     }
[09:28:23.441]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.441]                   }
[09:28:23.441]                 }
[09:28:23.441]             }
[09:28:23.441]         }))
[09:28:23.441]     }, error = function(ex) {
[09:28:23.441]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.441]                 ...future.rng), started = ...future.startTime, 
[09:28:23.441]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.441]             version = "1.8"), class = "FutureResult")
[09:28:23.441]     }, finally = {
[09:28:23.441]         if (!identical(...future.workdir, getwd())) 
[09:28:23.441]             setwd(...future.workdir)
[09:28:23.441]         {
[09:28:23.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.441]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.441]             }
[09:28:23.441]             base::options(...future.oldOptions)
[09:28:23.441]             if (.Platform$OS.type == "windows") {
[09:28:23.441]                 old_names <- names(...future.oldEnvVars)
[09:28:23.441]                 envs <- base::Sys.getenv()
[09:28:23.441]                 names <- names(envs)
[09:28:23.441]                 common <- intersect(names, old_names)
[09:28:23.441]                 added <- setdiff(names, old_names)
[09:28:23.441]                 removed <- setdiff(old_names, names)
[09:28:23.441]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.441]                   envs[common]]
[09:28:23.441]                 NAMES <- toupper(changed)
[09:28:23.441]                 args <- list()
[09:28:23.441]                 for (kk in seq_along(NAMES)) {
[09:28:23.441]                   name <- changed[[kk]]
[09:28:23.441]                   NAME <- NAMES[[kk]]
[09:28:23.441]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.441]                     next
[09:28:23.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.441]                 }
[09:28:23.441]                 NAMES <- toupper(added)
[09:28:23.441]                 for (kk in seq_along(NAMES)) {
[09:28:23.441]                   name <- added[[kk]]
[09:28:23.441]                   NAME <- NAMES[[kk]]
[09:28:23.441]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.441]                     next
[09:28:23.441]                   args[[name]] <- ""
[09:28:23.441]                 }
[09:28:23.441]                 NAMES <- toupper(removed)
[09:28:23.441]                 for (kk in seq_along(NAMES)) {
[09:28:23.441]                   name <- removed[[kk]]
[09:28:23.441]                   NAME <- NAMES[[kk]]
[09:28:23.441]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.441]                     next
[09:28:23.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.441]                 }
[09:28:23.441]                 if (length(args) > 0) 
[09:28:23.441]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.441]             }
[09:28:23.441]             else {
[09:28:23.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.441]             }
[09:28:23.441]             {
[09:28:23.441]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.441]                   0L) {
[09:28:23.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.441]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.441]                   base::options(opts)
[09:28:23.441]                 }
[09:28:23.441]                 {
[09:28:23.441]                   {
[09:28:23.441]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.441]                     NULL
[09:28:23.441]                   }
[09:28:23.441]                   options(future.plan = NULL)
[09:28:23.441]                   if (is.na(NA_character_)) 
[09:28:23.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.441]                     .init = FALSE)
[09:28:23.441]                 }
[09:28:23.441]             }
[09:28:23.441]         }
[09:28:23.441]     })
[09:28:23.441]     if (TRUE) {
[09:28:23.441]         base::sink(type = "output", split = FALSE)
[09:28:23.441]         if (TRUE) {
[09:28:23.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.441]         }
[09:28:23.441]         else {
[09:28:23.441]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.441]         }
[09:28:23.441]         base::close(...future.stdout)
[09:28:23.441]         ...future.stdout <- NULL
[09:28:23.441]     }
[09:28:23.441]     ...future.result$conditions <- ...future.conditions
[09:28:23.441]     ...future.result$finished <- base::Sys.time()
[09:28:23.441]     ...future.result
[09:28:23.441] }
[09:28:23.443] assign_globals() ...
[09:28:23.443] List of 7
[09:28:23.443]  $ ...future.FUN            :function (x)  
[09:28:23.443]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:23.443]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:23.443]  $ future.call.arguments    : list()
[09:28:23.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.443]  $ ...future.elements_ii    :List of 1
[09:28:23.443]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.443]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:23.443]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.443]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:23.443]  $ ...future.seeds_ii       : NULL
[09:28:23.443]  $ ...future.globals.maxSize: NULL
[09:28:23.443]  - attr(*, "where")=List of 7
[09:28:23.443]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.443]   ..$ breaks                   :<environment: R_EmptyEnv> 
[09:28:23.443]   ..$ wool                     :<environment: R_EmptyEnv> 
[09:28:23.443]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.443]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.443]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.443]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.443]  - attr(*, "resolved")= logi FALSE
[09:28:23.443]  - attr(*, "total_size")= num 2320
[09:28:23.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.443]  - attr(*, "already-done")= logi TRUE
[09:28:23.450] - reassign environment for ‘...future.FUN’
[09:28:23.450] - copied ‘...future.FUN’ to environment
[09:28:23.450] - copied ‘breaks’ to environment
[09:28:23.451] - copied ‘wool’ to environment
[09:28:23.451] - copied ‘future.call.arguments’ to environment
[09:28:23.451] - copied ‘...future.elements_ii’ to environment
[09:28:23.451] - copied ‘...future.seeds_ii’ to environment
[09:28:23.451] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.451] assign_globals() ... done
[09:28:23.451] requestCore(): workers = 2
[09:28:23.453] MulticoreFuture started
[09:28:23.453] - Launch lazy future ... done
[09:28:23.454] run() for ‘MulticoreFuture’ ... done
[09:28:23.454] Created future:
[09:28:23.454] plan(): Setting new future strategy stack:
[09:28:23.455] List of future strategies:
[09:28:23.455] 1. sequential:
[09:28:23.455]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.455]    - tweaked: FALSE
[09:28:23.455]    - call: NULL
[09:28:23.456] plan(): nbrOfWorkers() = 1
[09:28:23.459] plan(): Setting new future strategy stack:
[09:28:23.459] List of future strategies:
[09:28:23.459] 1. multicore:
[09:28:23.459]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.459]    - tweaked: FALSE
[09:28:23.459]    - call: plan(strategy)
[09:28:23.464] plan(): nbrOfWorkers() = 2
[09:28:23.454] MulticoreFuture:
[09:28:23.454] Label: ‘future_by-1’
[09:28:23.454] Expression:
[09:28:23.454] {
[09:28:23.454]     do.call(function(...) {
[09:28:23.454]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.454]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.454]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.454]             on.exit(options(oopts), add = TRUE)
[09:28:23.454]         }
[09:28:23.454]         {
[09:28:23.454]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.454]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.454]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.454]             })
[09:28:23.454]         }
[09:28:23.454]     }, args = future.call.arguments)
[09:28:23.454] }
[09:28:23.454] Lazy evaluation: FALSE
[09:28:23.454] Asynchronous evaluation: TRUE
[09:28:23.454] Local evaluation: TRUE
[09:28:23.454] Environment: 0x555b0a46cc90
[09:28:23.454] Capture standard output: TRUE
[09:28:23.454] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.454] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[09:28:23.454] Packages: 1 packages (‘stats’)
[09:28:23.454] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.454] Resolved: TRUE
[09:28:23.454] Value: <not collected>
[09:28:23.454] Conditions captured: <none>
[09:28:23.454] Early signaling: FALSE
[09:28:23.454] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.454] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.466] Chunk #1 of 2 ... DONE
[09:28:23.466] Chunk #2 of 2 ...
[09:28:23.467]  - Finding globals in 'X' for chunk #2 ...
[09:28:23.467] getGlobalsAndPackages() ...
[09:28:23.467] Searching for globals...
[09:28:23.468] 
[09:28:23.468] Searching for globals ... DONE
[09:28:23.468] - globals: [0] <none>
[09:28:23.468] getGlobalsAndPackages() ... DONE
[09:28:23.468]    + additional globals found: [n=0] 
[09:28:23.468]    + additional namespaces needed: [n=0] 
[09:28:23.468]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:23.469]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.469]  - seeds: <none>
[09:28:23.469]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.469] getGlobalsAndPackages() ...
[09:28:23.469] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.469] Resolving globals: FALSE
[09:28:23.469] Tweak future expression to call with '...' arguments ...
[09:28:23.470] {
[09:28:23.470]     do.call(function(...) {
[09:28:23.470]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.470]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.470]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.470]             on.exit(options(oopts), add = TRUE)
[09:28:23.470]         }
[09:28:23.470]         {
[09:28:23.470]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.470]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.470]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.470]             })
[09:28:23.470]         }
[09:28:23.470]     }, args = future.call.arguments)
[09:28:23.470] }
[09:28:23.470] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.471] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.471] 
[09:28:23.471] getGlobalsAndPackages() ... DONE
[09:28:23.472] run() for ‘Future’ ...
[09:28:23.472] - state: ‘created’
[09:28:23.472] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.476] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.476] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.477]   - Field: ‘label’
[09:28:23.477]   - Field: ‘local’
[09:28:23.477]   - Field: ‘owner’
[09:28:23.477]   - Field: ‘envir’
[09:28:23.477]   - Field: ‘workers’
[09:28:23.477]   - Field: ‘packages’
[09:28:23.477]   - Field: ‘gc’
[09:28:23.478]   - Field: ‘job’
[09:28:23.478]   - Field: ‘conditions’
[09:28:23.478]   - Field: ‘expr’
[09:28:23.478]   - Field: ‘uuid’
[09:28:23.478]   - Field: ‘seed’
[09:28:23.478]   - Field: ‘version’
[09:28:23.478]   - Field: ‘result’
[09:28:23.479]   - Field: ‘asynchronous’
[09:28:23.479]   - Field: ‘calls’
[09:28:23.479]   - Field: ‘globals’
[09:28:23.479]   - Field: ‘stdout’
[09:28:23.479]   - Field: ‘earlySignal’
[09:28:23.479]   - Field: ‘lazy’
[09:28:23.479]   - Field: ‘state’
[09:28:23.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.480] - Launch lazy future ...
[09:28:23.480] Packages needed by the future expression (n = 1): ‘stats’
[09:28:23.483] Packages needed by future strategies (n = 0): <none>
[09:28:23.485] {
[09:28:23.485]     {
[09:28:23.485]         {
[09:28:23.485]             ...future.startTime <- base::Sys.time()
[09:28:23.485]             {
[09:28:23.485]                 {
[09:28:23.485]                   {
[09:28:23.485]                     {
[09:28:23.485]                       {
[09:28:23.485]                         base::local({
[09:28:23.485]                           has_future <- base::requireNamespace("future", 
[09:28:23.485]                             quietly = TRUE)
[09:28:23.485]                           if (has_future) {
[09:28:23.485]                             ns <- base::getNamespace("future")
[09:28:23.485]                             version <- ns[[".package"]][["version"]]
[09:28:23.485]                             if (is.null(version)) 
[09:28:23.485]                               version <- utils::packageVersion("future")
[09:28:23.485]                           }
[09:28:23.485]                           else {
[09:28:23.485]                             version <- NULL
[09:28:23.485]                           }
[09:28:23.485]                           if (!has_future || version < "1.8.0") {
[09:28:23.485]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.485]                               "", base::R.version$version.string), 
[09:28:23.485]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:23.485]                                 base::R.version$platform, 8 * 
[09:28:23.485]                                   base::.Machine$sizeof.pointer), 
[09:28:23.485]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.485]                                 "release", "version")], collapse = " "), 
[09:28:23.485]                               hostname = base::Sys.info()[["nodename"]])
[09:28:23.485]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.485]                               info)
[09:28:23.485]                             info <- base::paste(info, collapse = "; ")
[09:28:23.485]                             if (!has_future) {
[09:28:23.485]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.485]                                 info)
[09:28:23.485]                             }
[09:28:23.485]                             else {
[09:28:23.485]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.485]                                 info, version)
[09:28:23.485]                             }
[09:28:23.485]                             base::stop(msg)
[09:28:23.485]                           }
[09:28:23.485]                         })
[09:28:23.485]                       }
[09:28:23.485]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.485]                       base::options(mc.cores = 1L)
[09:28:23.485]                     }
[09:28:23.485]                     base::local({
[09:28:23.485]                       for (pkg in "stats") {
[09:28:23.485]                         base::loadNamespace(pkg)
[09:28:23.485]                         base::library(pkg, character.only = TRUE)
[09:28:23.485]                       }
[09:28:23.485]                     })
[09:28:23.485]                   }
[09:28:23.485]                   ...future.strategy.old <- future::plan("list")
[09:28:23.485]                   options(future.plan = NULL)
[09:28:23.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.485]                 }
[09:28:23.485]                 ...future.workdir <- getwd()
[09:28:23.485]             }
[09:28:23.485]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.485]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.485]         }
[09:28:23.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.485]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.485]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.485]             base::names(...future.oldOptions))
[09:28:23.485]     }
[09:28:23.485]     if (FALSE) {
[09:28:23.485]     }
[09:28:23.485]     else {
[09:28:23.485]         if (TRUE) {
[09:28:23.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.485]                 open = "w")
[09:28:23.485]         }
[09:28:23.485]         else {
[09:28:23.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.485]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.485]         }
[09:28:23.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.485]             base::sink(type = "output", split = FALSE)
[09:28:23.485]             base::close(...future.stdout)
[09:28:23.485]         }, add = TRUE)
[09:28:23.485]     }
[09:28:23.485]     ...future.frame <- base::sys.nframe()
[09:28:23.485]     ...future.conditions <- base::list()
[09:28:23.485]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.485]     if (FALSE) {
[09:28:23.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.485]     }
[09:28:23.485]     ...future.result <- base::tryCatch({
[09:28:23.485]         base::withCallingHandlers({
[09:28:23.485]             ...future.value <- base::withVisible(base::local({
[09:28:23.485]                 withCallingHandlers({
[09:28:23.485]                   {
[09:28:23.485]                     do.call(function(...) {
[09:28:23.485]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.485]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.485]                         ...future.globals.maxSize)) {
[09:28:23.485]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.485]                         on.exit(options(oopts), add = TRUE)
[09:28:23.485]                       }
[09:28:23.485]                       {
[09:28:23.485]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.485]                           FUN = function(jj) {
[09:28:23.485]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.485]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.485]                           })
[09:28:23.485]                       }
[09:28:23.485]                     }, args = future.call.arguments)
[09:28:23.485]                   }
[09:28:23.485]                 }, immediateCondition = function(cond) {
[09:28:23.485]                   save_rds <- function (object, pathname, ...) 
[09:28:23.485]                   {
[09:28:23.485]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.485]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.485]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.485]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.485]                         fi_tmp[["mtime"]])
[09:28:23.485]                     }
[09:28:23.485]                     tryCatch({
[09:28:23.485]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.485]                     }, error = function(ex) {
[09:28:23.485]                       msg <- conditionMessage(ex)
[09:28:23.485]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.485]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.485]                         fi_tmp[["mtime"]], msg)
[09:28:23.485]                       ex$message <- msg
[09:28:23.485]                       stop(ex)
[09:28:23.485]                     })
[09:28:23.485]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.485]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.485]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.485]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.485]                       fi <- file.info(pathname)
[09:28:23.485]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.485]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.485]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.485]                         fi[["size"]], fi[["mtime"]])
[09:28:23.485]                       stop(msg)
[09:28:23.485]                     }
[09:28:23.485]                     invisible(pathname)
[09:28:23.485]                   }
[09:28:23.485]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.485]                     rootPath = tempdir()) 
[09:28:23.485]                   {
[09:28:23.485]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.485]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.485]                       tmpdir = path, fileext = ".rds")
[09:28:23.485]                     save_rds(obj, file)
[09:28:23.485]                   }
[09:28:23.485]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.485]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.485]                   {
[09:28:23.485]                     inherits <- base::inherits
[09:28:23.485]                     invokeRestart <- base::invokeRestart
[09:28:23.485]                     is.null <- base::is.null
[09:28:23.485]                     muffled <- FALSE
[09:28:23.485]                     if (inherits(cond, "message")) {
[09:28:23.485]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.485]                       if (muffled) 
[09:28:23.485]                         invokeRestart("muffleMessage")
[09:28:23.485]                     }
[09:28:23.485]                     else if (inherits(cond, "warning")) {
[09:28:23.485]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.485]                       if (muffled) 
[09:28:23.485]                         invokeRestart("muffleWarning")
[09:28:23.485]                     }
[09:28:23.485]                     else if (inherits(cond, "condition")) {
[09:28:23.485]                       if (!is.null(pattern)) {
[09:28:23.485]                         computeRestarts <- base::computeRestarts
[09:28:23.485]                         grepl <- base::grepl
[09:28:23.485]                         restarts <- computeRestarts(cond)
[09:28:23.485]                         for (restart in restarts) {
[09:28:23.485]                           name <- restart$name
[09:28:23.485]                           if (is.null(name)) 
[09:28:23.485]                             next
[09:28:23.485]                           if (!grepl(pattern, name)) 
[09:28:23.485]                             next
[09:28:23.485]                           invokeRestart(restart)
[09:28:23.485]                           muffled <- TRUE
[09:28:23.485]                           break
[09:28:23.485]                         }
[09:28:23.485]                       }
[09:28:23.485]                     }
[09:28:23.485]                     invisible(muffled)
[09:28:23.485]                   }
[09:28:23.485]                   muffleCondition(cond)
[09:28:23.485]                 })
[09:28:23.485]             }))
[09:28:23.485]             future::FutureResult(value = ...future.value$value, 
[09:28:23.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.485]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.485]                     ...future.globalenv.names))
[09:28:23.485]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.485]         }, condition = base::local({
[09:28:23.485]             c <- base::c
[09:28:23.485]             inherits <- base::inherits
[09:28:23.485]             invokeRestart <- base::invokeRestart
[09:28:23.485]             length <- base::length
[09:28:23.485]             list <- base::list
[09:28:23.485]             seq.int <- base::seq.int
[09:28:23.485]             signalCondition <- base::signalCondition
[09:28:23.485]             sys.calls <- base::sys.calls
[09:28:23.485]             `[[` <- base::`[[`
[09:28:23.485]             `+` <- base::`+`
[09:28:23.485]             `<<-` <- base::`<<-`
[09:28:23.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.485]                   3L)]
[09:28:23.485]             }
[09:28:23.485]             function(cond) {
[09:28:23.485]                 is_error <- inherits(cond, "error")
[09:28:23.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.485]                   NULL)
[09:28:23.485]                 if (is_error) {
[09:28:23.485]                   sessionInformation <- function() {
[09:28:23.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.485]                       search = base::search(), system = base::Sys.info())
[09:28:23.485]                   }
[09:28:23.485]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.485]                     cond$call), session = sessionInformation(), 
[09:28:23.485]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.485]                   signalCondition(cond)
[09:28:23.485]                 }
[09:28:23.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.485]                 "immediateCondition"))) {
[09:28:23.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.485]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.485]                   if (TRUE && !signal) {
[09:28:23.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.485]                     {
[09:28:23.485]                       inherits <- base::inherits
[09:28:23.485]                       invokeRestart <- base::invokeRestart
[09:28:23.485]                       is.null <- base::is.null
[09:28:23.485]                       muffled <- FALSE
[09:28:23.485]                       if (inherits(cond, "message")) {
[09:28:23.485]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.485]                         if (muffled) 
[09:28:23.485]                           invokeRestart("muffleMessage")
[09:28:23.485]                       }
[09:28:23.485]                       else if (inherits(cond, "warning")) {
[09:28:23.485]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.485]                         if (muffled) 
[09:28:23.485]                           invokeRestart("muffleWarning")
[09:28:23.485]                       }
[09:28:23.485]                       else if (inherits(cond, "condition")) {
[09:28:23.485]                         if (!is.null(pattern)) {
[09:28:23.485]                           computeRestarts <- base::computeRestarts
[09:28:23.485]                           grepl <- base::grepl
[09:28:23.485]                           restarts <- computeRestarts(cond)
[09:28:23.485]                           for (restart in restarts) {
[09:28:23.485]                             name <- restart$name
[09:28:23.485]                             if (is.null(name)) 
[09:28:23.485]                               next
[09:28:23.485]                             if (!grepl(pattern, name)) 
[09:28:23.485]                               next
[09:28:23.485]                             invokeRestart(restart)
[09:28:23.485]                             muffled <- TRUE
[09:28:23.485]                             break
[09:28:23.485]                           }
[09:28:23.485]                         }
[09:28:23.485]                       }
[09:28:23.485]                       invisible(muffled)
[09:28:23.485]                     }
[09:28:23.485]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.485]                   }
[09:28:23.485]                 }
[09:28:23.485]                 else {
[09:28:23.485]                   if (TRUE) {
[09:28:23.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.485]                     {
[09:28:23.485]                       inherits <- base::inherits
[09:28:23.485]                       invokeRestart <- base::invokeRestart
[09:28:23.485]                       is.null <- base::is.null
[09:28:23.485]                       muffled <- FALSE
[09:28:23.485]                       if (inherits(cond, "message")) {
[09:28:23.485]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.485]                         if (muffled) 
[09:28:23.485]                           invokeRestart("muffleMessage")
[09:28:23.485]                       }
[09:28:23.485]                       else if (inherits(cond, "warning")) {
[09:28:23.485]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.485]                         if (muffled) 
[09:28:23.485]                           invokeRestart("muffleWarning")
[09:28:23.485]                       }
[09:28:23.485]                       else if (inherits(cond, "condition")) {
[09:28:23.485]                         if (!is.null(pattern)) {
[09:28:23.485]                           computeRestarts <- base::computeRestarts
[09:28:23.485]                           grepl <- base::grepl
[09:28:23.485]                           restarts <- computeRestarts(cond)
[09:28:23.485]                           for (restart in restarts) {
[09:28:23.485]                             name <- restart$name
[09:28:23.485]                             if (is.null(name)) 
[09:28:23.485]                               next
[09:28:23.485]                             if (!grepl(pattern, name)) 
[09:28:23.485]                               next
[09:28:23.485]                             invokeRestart(restart)
[09:28:23.485]                             muffled <- TRUE
[09:28:23.485]                             break
[09:28:23.485]                           }
[09:28:23.485]                         }
[09:28:23.485]                       }
[09:28:23.485]                       invisible(muffled)
[09:28:23.485]                     }
[09:28:23.485]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.485]                   }
[09:28:23.485]                 }
[09:28:23.485]             }
[09:28:23.485]         }))
[09:28:23.485]     }, error = function(ex) {
[09:28:23.485]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.485]                 ...future.rng), started = ...future.startTime, 
[09:28:23.485]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.485]             version = "1.8"), class = "FutureResult")
[09:28:23.485]     }, finally = {
[09:28:23.485]         if (!identical(...future.workdir, getwd())) 
[09:28:23.485]             setwd(...future.workdir)
[09:28:23.485]         {
[09:28:23.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.485]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.485]             }
[09:28:23.485]             base::options(...future.oldOptions)
[09:28:23.485]             if (.Platform$OS.type == "windows") {
[09:28:23.485]                 old_names <- names(...future.oldEnvVars)
[09:28:23.485]                 envs <- base::Sys.getenv()
[09:28:23.485]                 names <- names(envs)
[09:28:23.485]                 common <- intersect(names, old_names)
[09:28:23.485]                 added <- setdiff(names, old_names)
[09:28:23.485]                 removed <- setdiff(old_names, names)
[09:28:23.485]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.485]                   envs[common]]
[09:28:23.485]                 NAMES <- toupper(changed)
[09:28:23.485]                 args <- list()
[09:28:23.485]                 for (kk in seq_along(NAMES)) {
[09:28:23.485]                   name <- changed[[kk]]
[09:28:23.485]                   NAME <- NAMES[[kk]]
[09:28:23.485]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.485]                     next
[09:28:23.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.485]                 }
[09:28:23.485]                 NAMES <- toupper(added)
[09:28:23.485]                 for (kk in seq_along(NAMES)) {
[09:28:23.485]                   name <- added[[kk]]
[09:28:23.485]                   NAME <- NAMES[[kk]]
[09:28:23.485]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.485]                     next
[09:28:23.485]                   args[[name]] <- ""
[09:28:23.485]                 }
[09:28:23.485]                 NAMES <- toupper(removed)
[09:28:23.485]                 for (kk in seq_along(NAMES)) {
[09:28:23.485]                   name <- removed[[kk]]
[09:28:23.485]                   NAME <- NAMES[[kk]]
[09:28:23.485]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.485]                     next
[09:28:23.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.485]                 }
[09:28:23.485]                 if (length(args) > 0) 
[09:28:23.485]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.485]             }
[09:28:23.485]             else {
[09:28:23.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.485]             }
[09:28:23.485]             {
[09:28:23.485]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.485]                   0L) {
[09:28:23.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.485]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.485]                   base::options(opts)
[09:28:23.485]                 }
[09:28:23.485]                 {
[09:28:23.485]                   {
[09:28:23.485]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.485]                     NULL
[09:28:23.485]                   }
[09:28:23.485]                   options(future.plan = NULL)
[09:28:23.485]                   if (is.na(NA_character_)) 
[09:28:23.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.485]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.485]                     .init = FALSE)
[09:28:23.485]                 }
[09:28:23.485]             }
[09:28:23.485]         }
[09:28:23.485]     })
[09:28:23.485]     if (TRUE) {
[09:28:23.485]         base::sink(type = "output", split = FALSE)
[09:28:23.485]         if (TRUE) {
[09:28:23.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.485]         }
[09:28:23.485]         else {
[09:28:23.485]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.485]         }
[09:28:23.485]         base::close(...future.stdout)
[09:28:23.485]         ...future.stdout <- NULL
[09:28:23.485]     }
[09:28:23.485]     ...future.result$conditions <- ...future.conditions
[09:28:23.485]     ...future.result$finished <- base::Sys.time()
[09:28:23.485]     ...future.result
[09:28:23.485] }
[09:28:23.488] assign_globals() ...
[09:28:23.488] List of 7
[09:28:23.488]  $ ...future.FUN            :function (x)  
[09:28:23.488]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:23.488]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:23.488]  $ future.call.arguments    : list()
[09:28:23.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.488]  $ ...future.elements_ii    :List of 2
[09:28:23.488]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.488]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:23.488]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.488]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:23.488]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.488]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:23.488]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.488]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:23.488]  $ ...future.seeds_ii       : NULL
[09:28:23.488]  $ ...future.globals.maxSize: NULL
[09:28:23.488]  - attr(*, "where")=List of 7
[09:28:23.488]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.488]   ..$ breaks                   :<environment: R_EmptyEnv> 
[09:28:23.488]   ..$ wool                     :<environment: R_EmptyEnv> 
[09:28:23.488]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.488]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.488]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.488]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.488]  - attr(*, "resolved")= logi FALSE
[09:28:23.488]  - attr(*, "total_size")= num 2320
[09:28:23.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.488]  - attr(*, "already-done")= logi TRUE
[09:28:23.501] - reassign environment for ‘...future.FUN’
[09:28:23.501] - copied ‘...future.FUN’ to environment
[09:28:23.501] - copied ‘breaks’ to environment
[09:28:23.502] - copied ‘wool’ to environment
[09:28:23.502] - copied ‘future.call.arguments’ to environment
[09:28:23.502] - copied ‘...future.elements_ii’ to environment
[09:28:23.502] - copied ‘...future.seeds_ii’ to environment
[09:28:23.502] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.502] assign_globals() ... done
[09:28:23.502] requestCore(): workers = 2
[09:28:23.504] MulticoreFuture started
[09:28:23.504] - Launch lazy future ... done
[09:28:23.505] run() for ‘MulticoreFuture’ ... done
[09:28:23.505] Created future:
[09:28:23.505] plan(): Setting new future strategy stack:
[09:28:23.506] List of future strategies:
[09:28:23.506] 1. sequential:
[09:28:23.506]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.506]    - tweaked: FALSE
[09:28:23.506]    - call: NULL
[09:28:23.507] plan(): nbrOfWorkers() = 1
[09:28:23.512] plan(): Setting new future strategy stack:
[09:28:23.512] List of future strategies:
[09:28:23.512] 1. multicore:
[09:28:23.512]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.512]    - tweaked: FALSE
[09:28:23.512]    - call: plan(strategy)
[09:28:23.517] plan(): nbrOfWorkers() = 2
[09:28:23.505] MulticoreFuture:
[09:28:23.505] Label: ‘future_by-2’
[09:28:23.505] Expression:
[09:28:23.505] {
[09:28:23.505]     do.call(function(...) {
[09:28:23.505]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.505]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.505]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.505]             on.exit(options(oopts), add = TRUE)
[09:28:23.505]         }
[09:28:23.505]         {
[09:28:23.505]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.505]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.505]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.505]             })
[09:28:23.505]         }
[09:28:23.505]     }, args = future.call.arguments)
[09:28:23.505] }
[09:28:23.505] Lazy evaluation: FALSE
[09:28:23.505] Asynchronous evaluation: TRUE
[09:28:23.505] Local evaluation: TRUE
[09:28:23.505] Environment: 0x555b0a46cc90
[09:28:23.505] Capture standard output: TRUE
[09:28:23.505] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.505] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[09:28:23.505] Packages: 1 packages (‘stats’)
[09:28:23.505] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.505] Resolved: FALSE
[09:28:23.505] Value: <not collected>
[09:28:23.505] Conditions captured: <none>
[09:28:23.505] Early signaling: FALSE
[09:28:23.505] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.505] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.518] Chunk #2 of 2 ... DONE
[09:28:23.518] Launching 2 futures (chunks) ... DONE
[09:28:23.519] Resolving 2 futures (chunks) ...
[09:28:23.519] resolve() on list ...
[09:28:23.519]  recursive: 0
[09:28:23.519]  length: 2
[09:28:23.519] 
[09:28:23.520] Future #1
[09:28:23.520] result() for MulticoreFuture ...
[09:28:23.521] result() for MulticoreFuture ...
[09:28:23.521] result() for MulticoreFuture ... done
[09:28:23.522] result() for MulticoreFuture ... done
[09:28:23.522] result() for MulticoreFuture ...
[09:28:23.522] result() for MulticoreFuture ... done
[09:28:23.522] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:23.522] - nx: 2
[09:28:23.522] - relay: TRUE
[09:28:23.522] - stdout: TRUE
[09:28:23.522] - signal: TRUE
[09:28:23.523] - resignal: FALSE
[09:28:23.523] - force: TRUE
[09:28:23.523] - relayed: [n=2] FALSE, FALSE
[09:28:23.523] - queued futures: [n=2] FALSE, FALSE
[09:28:23.523]  - until=1
[09:28:23.523]  - relaying element #1
[09:28:23.523] result() for MulticoreFuture ...
[09:28:23.523] result() for MulticoreFuture ... done
[09:28:23.524] result() for MulticoreFuture ...
[09:28:23.524] result() for MulticoreFuture ... done
[09:28:23.524] result() for MulticoreFuture ...
[09:28:23.524] result() for MulticoreFuture ... done
[09:28:23.524] result() for MulticoreFuture ...
[09:28:23.524] result() for MulticoreFuture ... done
[09:28:23.525] - relayed: [n=2] TRUE, FALSE
[09:28:23.525] - queued futures: [n=2] TRUE, FALSE
[09:28:23.525] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:23.525]  length: 1 (resolved future 1)
[09:28:23.525] Future #2
[09:28:23.525] result() for MulticoreFuture ...
[09:28:23.527] result() for MulticoreFuture ...
[09:28:23.527] result() for MulticoreFuture ... done
[09:28:23.527] result() for MulticoreFuture ... done
[09:28:23.527] result() for MulticoreFuture ...
[09:28:23.527] result() for MulticoreFuture ... done
[09:28:23.528] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:23.528] - nx: 2
[09:28:23.528] - relay: TRUE
[09:28:23.528] - stdout: TRUE
[09:28:23.531] - signal: TRUE
[09:28:23.531] - resignal: FALSE
[09:28:23.531] - force: TRUE
[09:28:23.531] - relayed: [n=2] TRUE, FALSE
[09:28:23.531] - queued futures: [n=2] TRUE, FALSE
[09:28:23.532]  - until=2
[09:28:23.532]  - relaying element #2
[09:28:23.532] result() for MulticoreFuture ...
[09:28:23.532] result() for MulticoreFuture ... done
[09:28:23.532] result() for MulticoreFuture ...
[09:28:23.533] result() for MulticoreFuture ... done
[09:28:23.533] result() for MulticoreFuture ...
[09:28:23.533] result() for MulticoreFuture ... done
[09:28:23.533] result() for MulticoreFuture ...
[09:28:23.533] result() for MulticoreFuture ... done
[09:28:23.533] - relayed: [n=2] TRUE, TRUE
[09:28:23.534] - queued futures: [n=2] TRUE, TRUE
[09:28:23.534] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:23.534]  length: 0 (resolved future 2)
[09:28:23.534] Relaying remaining futures
[09:28:23.534] signalConditionsASAP(NULL, pos=0) ...
[09:28:23.534] - nx: 2
[09:28:23.534] - relay: TRUE
[09:28:23.535] - stdout: TRUE
[09:28:23.535] - signal: TRUE
[09:28:23.535] - resignal: FALSE
[09:28:23.535] - force: TRUE
[09:28:23.535] - relayed: [n=2] TRUE, TRUE
[09:28:23.535] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:23.535] - relayed: [n=2] TRUE, TRUE
[09:28:23.536] - queued futures: [n=2] TRUE, TRUE
[09:28:23.536] signalConditionsASAP(NULL, pos=0) ... done
[09:28:23.536] resolve() on list ... DONE
[09:28:23.536] result() for MulticoreFuture ...
[09:28:23.536] result() for MulticoreFuture ... done
[09:28:23.536] result() for MulticoreFuture ...
[09:28:23.536] result() for MulticoreFuture ... done
[09:28:23.537] result() for MulticoreFuture ...
[09:28:23.537] result() for MulticoreFuture ... done
[09:28:23.537] result() for MulticoreFuture ...
[09:28:23.537] result() for MulticoreFuture ... done
[09:28:23.537]  - Number of value chunks collected: 2
[09:28:23.537] Resolving 2 futures (chunks) ... DONE
[09:28:23.537] Reducing values from 2 chunks ...
[09:28:23.537]  - Number of values collected after concatenation: 3
[09:28:23.538]  - Number of values expected: 3
[09:28:23.538] Reducing values from 2 chunks ... DONE
[09:28:23.538] future_lapply() ... DONE
[09:28:23.538] future_by_internal() ... DONE
[09:28:23.539] future_by_internal() ...
[09:28:23.539] future_lapply() ...
[09:28:23.543] Number of chunks: 2
[09:28:23.544] getGlobalsAndPackagesXApply() ...
[09:28:23.544]  - future.globals: TRUE
[09:28:23.544] getGlobalsAndPackages() ...
[09:28:23.544] Searching for globals...
[09:28:23.545] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:23.545] Searching for globals ... DONE
[09:28:23.545] Resolving globals: FALSE
[09:28:23.546] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:23.546] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:23.546] - globals: [1] ‘FUN’
[09:28:23.546] 
[09:28:23.546] getGlobalsAndPackages() ... DONE
[09:28:23.547]  - globals found/used: [n=1] ‘FUN’
[09:28:23.547]  - needed namespaces: [n=0] 
[09:28:23.547] Finding globals ... DONE
[09:28:23.547]  - use_args: TRUE
[09:28:23.547]  - Getting '...' globals ...
[09:28:23.547] resolve() on list ...
[09:28:23.547]  recursive: 0
[09:28:23.547]  length: 1
[09:28:23.548]  elements: ‘...’
[09:28:23.548]  length: 0 (resolved future 1)
[09:28:23.548] resolve() on list ... DONE
[09:28:23.548]    - '...' content: [n=0] 
[09:28:23.548] List of 1
[09:28:23.548]  $ ...: list()
[09:28:23.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.548]  - attr(*, "where")=List of 1
[09:28:23.548]   ..$ ...:<environment: 0x555b08eabd80> 
[09:28:23.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.548]  - attr(*, "resolved")= logi TRUE
[09:28:23.548]  - attr(*, "total_size")= num NA
[09:28:23.551]  - Getting '...' globals ... DONE
[09:28:23.551] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:23.551] List of 2
[09:28:23.551]  $ ...future.FUN:function (object, ...)  
[09:28:23.551]  $ ...          : list()
[09:28:23.551]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.551]  - attr(*, "where")=List of 2
[09:28:23.551]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:23.551]   ..$ ...          :<environment: 0x555b08eabd80> 
[09:28:23.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.551]  - attr(*, "resolved")= logi FALSE
[09:28:23.551]  - attr(*, "total_size")= num 1240
[09:28:23.554] Packages to be attached in all futures: [n=0] 
[09:28:23.554] getGlobalsAndPackagesXApply() ... DONE
[09:28:23.554] Number of futures (= number of chunks): 2
[09:28:23.554] Launching 2 futures (chunks) ...
[09:28:23.554] Chunk #1 of 2 ...
[09:28:23.554]  - Finding globals in 'X' for chunk #1 ...
[09:28:23.554] getGlobalsAndPackages() ...
[09:28:23.554] Searching for globals...
[09:28:23.557] 
[09:28:23.557] Searching for globals ... DONE
[09:28:23.557] - globals: [0] <none>
[09:28:23.557] getGlobalsAndPackages() ... DONE
[09:28:23.557]    + additional globals found: [n=0] 
[09:28:23.557]    + additional namespaces needed: [n=0] 
[09:28:23.557]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:23.557]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.557]  - seeds: <none>
[09:28:23.558]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.558] getGlobalsAndPackages() ...
[09:28:23.558] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.558] Resolving globals: FALSE
[09:28:23.558] Tweak future expression to call with '...' arguments ...
[09:28:23.558] {
[09:28:23.558]     do.call(function(...) {
[09:28:23.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.558]             on.exit(options(oopts), add = TRUE)
[09:28:23.558]         }
[09:28:23.558]         {
[09:28:23.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.558]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.558]             })
[09:28:23.558]         }
[09:28:23.558]     }, args = future.call.arguments)
[09:28:23.558] }
[09:28:23.558] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.559] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.559] 
[09:28:23.559] getGlobalsAndPackages() ... DONE
[09:28:23.559] run() for ‘Future’ ...
[09:28:23.559] - state: ‘created’
[09:28:23.560] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.563] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.563] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.564]   - Field: ‘label’
[09:28:23.564]   - Field: ‘local’
[09:28:23.564]   - Field: ‘owner’
[09:28:23.564]   - Field: ‘envir’
[09:28:23.564]   - Field: ‘workers’
[09:28:23.564]   - Field: ‘packages’
[09:28:23.564]   - Field: ‘gc’
[09:28:23.564]   - Field: ‘job’
[09:28:23.564]   - Field: ‘conditions’
[09:28:23.565]   - Field: ‘expr’
[09:28:23.565]   - Field: ‘uuid’
[09:28:23.565]   - Field: ‘seed’
[09:28:23.565]   - Field: ‘version’
[09:28:23.565]   - Field: ‘result’
[09:28:23.565]   - Field: ‘asynchronous’
[09:28:23.565]   - Field: ‘calls’
[09:28:23.565]   - Field: ‘globals’
[09:28:23.565]   - Field: ‘stdout’
[09:28:23.565]   - Field: ‘earlySignal’
[09:28:23.565]   - Field: ‘lazy’
[09:28:23.566]   - Field: ‘state’
[09:28:23.566] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.566] - Launch lazy future ...
[09:28:23.566] Packages needed by the future expression (n = 0): <none>
[09:28:23.566] Packages needed by future strategies (n = 0): <none>
[09:28:23.567] {
[09:28:23.567]     {
[09:28:23.567]         {
[09:28:23.567]             ...future.startTime <- base::Sys.time()
[09:28:23.567]             {
[09:28:23.567]                 {
[09:28:23.567]                   {
[09:28:23.567]                     {
[09:28:23.567]                       base::local({
[09:28:23.567]                         has_future <- base::requireNamespace("future", 
[09:28:23.567]                           quietly = TRUE)
[09:28:23.567]                         if (has_future) {
[09:28:23.567]                           ns <- base::getNamespace("future")
[09:28:23.567]                           version <- ns[[".package"]][["version"]]
[09:28:23.567]                           if (is.null(version)) 
[09:28:23.567]                             version <- utils::packageVersion("future")
[09:28:23.567]                         }
[09:28:23.567]                         else {
[09:28:23.567]                           version <- NULL
[09:28:23.567]                         }
[09:28:23.567]                         if (!has_future || version < "1.8.0") {
[09:28:23.567]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.567]                             "", base::R.version$version.string), 
[09:28:23.567]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:23.567]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:23.567]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.567]                               "release", "version")], collapse = " "), 
[09:28:23.567]                             hostname = base::Sys.info()[["nodename"]])
[09:28:23.567]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.567]                             info)
[09:28:23.567]                           info <- base::paste(info, collapse = "; ")
[09:28:23.567]                           if (!has_future) {
[09:28:23.567]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.567]                               info)
[09:28:23.567]                           }
[09:28:23.567]                           else {
[09:28:23.567]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.567]                               info, version)
[09:28:23.567]                           }
[09:28:23.567]                           base::stop(msg)
[09:28:23.567]                         }
[09:28:23.567]                       })
[09:28:23.567]                     }
[09:28:23.567]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.567]                     base::options(mc.cores = 1L)
[09:28:23.567]                   }
[09:28:23.567]                   ...future.strategy.old <- future::plan("list")
[09:28:23.567]                   options(future.plan = NULL)
[09:28:23.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.567]                 }
[09:28:23.567]                 ...future.workdir <- getwd()
[09:28:23.567]             }
[09:28:23.567]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.567]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.567]         }
[09:28:23.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.567]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.567]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.567]             base::names(...future.oldOptions))
[09:28:23.567]     }
[09:28:23.567]     if (FALSE) {
[09:28:23.567]     }
[09:28:23.567]     else {
[09:28:23.567]         if (TRUE) {
[09:28:23.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.567]                 open = "w")
[09:28:23.567]         }
[09:28:23.567]         else {
[09:28:23.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.567]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.567]         }
[09:28:23.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.567]             base::sink(type = "output", split = FALSE)
[09:28:23.567]             base::close(...future.stdout)
[09:28:23.567]         }, add = TRUE)
[09:28:23.567]     }
[09:28:23.567]     ...future.frame <- base::sys.nframe()
[09:28:23.567]     ...future.conditions <- base::list()
[09:28:23.567]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.567]     if (FALSE) {
[09:28:23.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.567]     }
[09:28:23.567]     ...future.result <- base::tryCatch({
[09:28:23.567]         base::withCallingHandlers({
[09:28:23.567]             ...future.value <- base::withVisible(base::local({
[09:28:23.567]                 withCallingHandlers({
[09:28:23.567]                   {
[09:28:23.567]                     do.call(function(...) {
[09:28:23.567]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.567]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.567]                         ...future.globals.maxSize)) {
[09:28:23.567]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.567]                         on.exit(options(oopts), add = TRUE)
[09:28:23.567]                       }
[09:28:23.567]                       {
[09:28:23.567]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.567]                           FUN = function(jj) {
[09:28:23.567]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.567]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.567]                           })
[09:28:23.567]                       }
[09:28:23.567]                     }, args = future.call.arguments)
[09:28:23.567]                   }
[09:28:23.567]                 }, immediateCondition = function(cond) {
[09:28:23.567]                   save_rds <- function (object, pathname, ...) 
[09:28:23.567]                   {
[09:28:23.567]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.567]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.567]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.567]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.567]                         fi_tmp[["mtime"]])
[09:28:23.567]                     }
[09:28:23.567]                     tryCatch({
[09:28:23.567]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.567]                     }, error = function(ex) {
[09:28:23.567]                       msg <- conditionMessage(ex)
[09:28:23.567]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.567]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.567]                         fi_tmp[["mtime"]], msg)
[09:28:23.567]                       ex$message <- msg
[09:28:23.567]                       stop(ex)
[09:28:23.567]                     })
[09:28:23.567]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.567]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.567]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.567]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.567]                       fi <- file.info(pathname)
[09:28:23.567]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.567]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.567]                         fi[["size"]], fi[["mtime"]])
[09:28:23.567]                       stop(msg)
[09:28:23.567]                     }
[09:28:23.567]                     invisible(pathname)
[09:28:23.567]                   }
[09:28:23.567]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.567]                     rootPath = tempdir()) 
[09:28:23.567]                   {
[09:28:23.567]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.567]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.567]                       tmpdir = path, fileext = ".rds")
[09:28:23.567]                     save_rds(obj, file)
[09:28:23.567]                   }
[09:28:23.567]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.567]                   {
[09:28:23.567]                     inherits <- base::inherits
[09:28:23.567]                     invokeRestart <- base::invokeRestart
[09:28:23.567]                     is.null <- base::is.null
[09:28:23.567]                     muffled <- FALSE
[09:28:23.567]                     if (inherits(cond, "message")) {
[09:28:23.567]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.567]                       if (muffled) 
[09:28:23.567]                         invokeRestart("muffleMessage")
[09:28:23.567]                     }
[09:28:23.567]                     else if (inherits(cond, "warning")) {
[09:28:23.567]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.567]                       if (muffled) 
[09:28:23.567]                         invokeRestart("muffleWarning")
[09:28:23.567]                     }
[09:28:23.567]                     else if (inherits(cond, "condition")) {
[09:28:23.567]                       if (!is.null(pattern)) {
[09:28:23.567]                         computeRestarts <- base::computeRestarts
[09:28:23.567]                         grepl <- base::grepl
[09:28:23.567]                         restarts <- computeRestarts(cond)
[09:28:23.567]                         for (restart in restarts) {
[09:28:23.567]                           name <- restart$name
[09:28:23.567]                           if (is.null(name)) 
[09:28:23.567]                             next
[09:28:23.567]                           if (!grepl(pattern, name)) 
[09:28:23.567]                             next
[09:28:23.567]                           invokeRestart(restart)
[09:28:23.567]                           muffled <- TRUE
[09:28:23.567]                           break
[09:28:23.567]                         }
[09:28:23.567]                       }
[09:28:23.567]                     }
[09:28:23.567]                     invisible(muffled)
[09:28:23.567]                   }
[09:28:23.567]                   muffleCondition(cond)
[09:28:23.567]                 })
[09:28:23.567]             }))
[09:28:23.567]             future::FutureResult(value = ...future.value$value, 
[09:28:23.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.567]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.567]                     ...future.globalenv.names))
[09:28:23.567]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.567]         }, condition = base::local({
[09:28:23.567]             c <- base::c
[09:28:23.567]             inherits <- base::inherits
[09:28:23.567]             invokeRestart <- base::invokeRestart
[09:28:23.567]             length <- base::length
[09:28:23.567]             list <- base::list
[09:28:23.567]             seq.int <- base::seq.int
[09:28:23.567]             signalCondition <- base::signalCondition
[09:28:23.567]             sys.calls <- base::sys.calls
[09:28:23.567]             `[[` <- base::`[[`
[09:28:23.567]             `+` <- base::`+`
[09:28:23.567]             `<<-` <- base::`<<-`
[09:28:23.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.567]                   3L)]
[09:28:23.567]             }
[09:28:23.567]             function(cond) {
[09:28:23.567]                 is_error <- inherits(cond, "error")
[09:28:23.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.567]                   NULL)
[09:28:23.567]                 if (is_error) {
[09:28:23.567]                   sessionInformation <- function() {
[09:28:23.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.567]                       search = base::search(), system = base::Sys.info())
[09:28:23.567]                   }
[09:28:23.567]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.567]                     cond$call), session = sessionInformation(), 
[09:28:23.567]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.567]                   signalCondition(cond)
[09:28:23.567]                 }
[09:28:23.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.567]                 "immediateCondition"))) {
[09:28:23.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.567]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.567]                   if (TRUE && !signal) {
[09:28:23.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.567]                     {
[09:28:23.567]                       inherits <- base::inherits
[09:28:23.567]                       invokeRestart <- base::invokeRestart
[09:28:23.567]                       is.null <- base::is.null
[09:28:23.567]                       muffled <- FALSE
[09:28:23.567]                       if (inherits(cond, "message")) {
[09:28:23.567]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.567]                         if (muffled) 
[09:28:23.567]                           invokeRestart("muffleMessage")
[09:28:23.567]                       }
[09:28:23.567]                       else if (inherits(cond, "warning")) {
[09:28:23.567]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.567]                         if (muffled) 
[09:28:23.567]                           invokeRestart("muffleWarning")
[09:28:23.567]                       }
[09:28:23.567]                       else if (inherits(cond, "condition")) {
[09:28:23.567]                         if (!is.null(pattern)) {
[09:28:23.567]                           computeRestarts <- base::computeRestarts
[09:28:23.567]                           grepl <- base::grepl
[09:28:23.567]                           restarts <- computeRestarts(cond)
[09:28:23.567]                           for (restart in restarts) {
[09:28:23.567]                             name <- restart$name
[09:28:23.567]                             if (is.null(name)) 
[09:28:23.567]                               next
[09:28:23.567]                             if (!grepl(pattern, name)) 
[09:28:23.567]                               next
[09:28:23.567]                             invokeRestart(restart)
[09:28:23.567]                             muffled <- TRUE
[09:28:23.567]                             break
[09:28:23.567]                           }
[09:28:23.567]                         }
[09:28:23.567]                       }
[09:28:23.567]                       invisible(muffled)
[09:28:23.567]                     }
[09:28:23.567]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.567]                   }
[09:28:23.567]                 }
[09:28:23.567]                 else {
[09:28:23.567]                   if (TRUE) {
[09:28:23.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.567]                     {
[09:28:23.567]                       inherits <- base::inherits
[09:28:23.567]                       invokeRestart <- base::invokeRestart
[09:28:23.567]                       is.null <- base::is.null
[09:28:23.567]                       muffled <- FALSE
[09:28:23.567]                       if (inherits(cond, "message")) {
[09:28:23.567]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.567]                         if (muffled) 
[09:28:23.567]                           invokeRestart("muffleMessage")
[09:28:23.567]                       }
[09:28:23.567]                       else if (inherits(cond, "warning")) {
[09:28:23.567]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.567]                         if (muffled) 
[09:28:23.567]                           invokeRestart("muffleWarning")
[09:28:23.567]                       }
[09:28:23.567]                       else if (inherits(cond, "condition")) {
[09:28:23.567]                         if (!is.null(pattern)) {
[09:28:23.567]                           computeRestarts <- base::computeRestarts
[09:28:23.567]                           grepl <- base::grepl
[09:28:23.567]                           restarts <- computeRestarts(cond)
[09:28:23.567]                           for (restart in restarts) {
[09:28:23.567]                             name <- restart$name
[09:28:23.567]                             if (is.null(name)) 
[09:28:23.567]                               next
[09:28:23.567]                             if (!grepl(pattern, name)) 
[09:28:23.567]                               next
[09:28:23.567]                             invokeRestart(restart)
[09:28:23.567]                             muffled <- TRUE
[09:28:23.567]                             break
[09:28:23.567]                           }
[09:28:23.567]                         }
[09:28:23.567]                       }
[09:28:23.567]                       invisible(muffled)
[09:28:23.567]                     }
[09:28:23.567]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.567]                   }
[09:28:23.567]                 }
[09:28:23.567]             }
[09:28:23.567]         }))
[09:28:23.567]     }, error = function(ex) {
[09:28:23.567]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.567]                 ...future.rng), started = ...future.startTime, 
[09:28:23.567]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.567]             version = "1.8"), class = "FutureResult")
[09:28:23.567]     }, finally = {
[09:28:23.567]         if (!identical(...future.workdir, getwd())) 
[09:28:23.567]             setwd(...future.workdir)
[09:28:23.567]         {
[09:28:23.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.567]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.567]             }
[09:28:23.567]             base::options(...future.oldOptions)
[09:28:23.567]             if (.Platform$OS.type == "windows") {
[09:28:23.567]                 old_names <- names(...future.oldEnvVars)
[09:28:23.567]                 envs <- base::Sys.getenv()
[09:28:23.567]                 names <- names(envs)
[09:28:23.567]                 common <- intersect(names, old_names)
[09:28:23.567]                 added <- setdiff(names, old_names)
[09:28:23.567]                 removed <- setdiff(old_names, names)
[09:28:23.567]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.567]                   envs[common]]
[09:28:23.567]                 NAMES <- toupper(changed)
[09:28:23.567]                 args <- list()
[09:28:23.567]                 for (kk in seq_along(NAMES)) {
[09:28:23.567]                   name <- changed[[kk]]
[09:28:23.567]                   NAME <- NAMES[[kk]]
[09:28:23.567]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.567]                     next
[09:28:23.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.567]                 }
[09:28:23.567]                 NAMES <- toupper(added)
[09:28:23.567]                 for (kk in seq_along(NAMES)) {
[09:28:23.567]                   name <- added[[kk]]
[09:28:23.567]                   NAME <- NAMES[[kk]]
[09:28:23.567]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.567]                     next
[09:28:23.567]                   args[[name]] <- ""
[09:28:23.567]                 }
[09:28:23.567]                 NAMES <- toupper(removed)
[09:28:23.567]                 for (kk in seq_along(NAMES)) {
[09:28:23.567]                   name <- removed[[kk]]
[09:28:23.567]                   NAME <- NAMES[[kk]]
[09:28:23.567]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.567]                     next
[09:28:23.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.567]                 }
[09:28:23.567]                 if (length(args) > 0) 
[09:28:23.567]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.567]             }
[09:28:23.567]             else {
[09:28:23.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.567]             }
[09:28:23.567]             {
[09:28:23.567]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.567]                   0L) {
[09:28:23.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.567]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.567]                   base::options(opts)
[09:28:23.567]                 }
[09:28:23.567]                 {
[09:28:23.567]                   {
[09:28:23.567]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.567]                     NULL
[09:28:23.567]                   }
[09:28:23.567]                   options(future.plan = NULL)
[09:28:23.567]                   if (is.na(NA_character_)) 
[09:28:23.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.567]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.567]                     .init = FALSE)
[09:28:23.567]                 }
[09:28:23.567]             }
[09:28:23.567]         }
[09:28:23.567]     })
[09:28:23.567]     if (TRUE) {
[09:28:23.567]         base::sink(type = "output", split = FALSE)
[09:28:23.567]         if (TRUE) {
[09:28:23.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.567]         }
[09:28:23.567]         else {
[09:28:23.567]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.567]         }
[09:28:23.567]         base::close(...future.stdout)
[09:28:23.567]         ...future.stdout <- NULL
[09:28:23.567]     }
[09:28:23.567]     ...future.result$conditions <- ...future.conditions
[09:28:23.567]     ...future.result$finished <- base::Sys.time()
[09:28:23.567]     ...future.result
[09:28:23.567] }
[09:28:23.569] assign_globals() ...
[09:28:23.569] List of 5
[09:28:23.569]  $ ...future.FUN            :function (object, ...)  
[09:28:23.569]  $ future.call.arguments    : list()
[09:28:23.569]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.569]  $ ...future.elements_ii    :List of 1
[09:28:23.569]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.569]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:23.569]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.569]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:23.569]  $ ...future.seeds_ii       : NULL
[09:28:23.569]  $ ...future.globals.maxSize: NULL
[09:28:23.569]  - attr(*, "where")=List of 5
[09:28:23.569]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.569]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.569]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.569]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.569]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.569]  - attr(*, "resolved")= logi FALSE
[09:28:23.569]  - attr(*, "total_size")= num 1240
[09:28:23.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.569]  - attr(*, "already-done")= logi TRUE
[09:28:23.574] - copied ‘...future.FUN’ to environment
[09:28:23.575] - copied ‘future.call.arguments’ to environment
[09:28:23.575] - copied ‘...future.elements_ii’ to environment
[09:28:23.575] - copied ‘...future.seeds_ii’ to environment
[09:28:23.575] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.575] assign_globals() ... done
[09:28:23.575] requestCore(): workers = 2
[09:28:23.577] MulticoreFuture started
[09:28:23.577] - Launch lazy future ... done
[09:28:23.578] run() for ‘MulticoreFuture’ ... done
[09:28:23.578] Created future:
[09:28:23.578] plan(): Setting new future strategy stack:
[09:28:23.578] List of future strategies:
[09:28:23.578] 1. sequential:
[09:28:23.578]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.578]    - tweaked: FALSE
[09:28:23.578]    - call: NULL
[09:28:23.579] plan(): nbrOfWorkers() = 1
[09:28:23.582] plan(): Setting new future strategy stack:
[09:28:23.583] List of future strategies:
[09:28:23.583] 1. multicore:
[09:28:23.583]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.583]    - tweaked: FALSE
[09:28:23.583]    - call: plan(strategy)
[09:28:23.578] MulticoreFuture:
[09:28:23.578] Label: ‘future_by-1’
[09:28:23.578] Expression:
[09:28:23.578] {
[09:28:23.578]     do.call(function(...) {
[09:28:23.578]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.578]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.578]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.578]             on.exit(options(oopts), add = TRUE)
[09:28:23.578]         }
[09:28:23.578]         {
[09:28:23.578]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.578]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.578]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.578]             })
[09:28:23.578]         }
[09:28:23.578]     }, args = future.call.arguments)
[09:28:23.578] }
[09:28:23.578] Lazy evaluation: FALSE
[09:28:23.578] Asynchronous evaluation: TRUE
[09:28:23.578] Local evaluation: TRUE
[09:28:23.578] Environment: 0x555b0a784220
[09:28:23.578] Capture standard output: TRUE
[09:28:23.578] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.578] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:23.578] Packages: <none>
[09:28:23.578] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.578] Resolved: FALSE
[09:28:23.578] Value: <not collected>
[09:28:23.578] Conditions captured: <none>
[09:28:23.578] Early signaling: FALSE
[09:28:23.578] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.578] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.591] Chunk #1 of 2 ... DONE
[09:28:23.588] plan(): nbrOfWorkers() = 2
[09:28:23.591] Chunk #2 of 2 ...
[09:28:23.591]  - Finding globals in 'X' for chunk #2 ...
[09:28:23.592] getGlobalsAndPackages() ...
[09:28:23.592] Searching for globals...
[09:28:23.592] 
[09:28:23.593] Searching for globals ... DONE
[09:28:23.593] - globals: [0] <none>
[09:28:23.593] getGlobalsAndPackages() ... DONE
[09:28:23.593]    + additional globals found: [n=0] 
[09:28:23.593]    + additional namespaces needed: [n=0] 
[09:28:23.593]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:23.593]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.594]  - seeds: <none>
[09:28:23.596]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.596] getGlobalsAndPackages() ...
[09:28:23.597] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.597] Resolving globals: FALSE
[09:28:23.597] Tweak future expression to call with '...' arguments ...
[09:28:23.598] {
[09:28:23.598]     do.call(function(...) {
[09:28:23.598]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.598]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.598]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.598]             on.exit(options(oopts), add = TRUE)
[09:28:23.598]         }
[09:28:23.598]         {
[09:28:23.598]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.598]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.598]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.598]             })
[09:28:23.598]         }
[09:28:23.598]     }, args = future.call.arguments)
[09:28:23.598] }
[09:28:23.599] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.600] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.600] 
[09:28:23.600] getGlobalsAndPackages() ... DONE
[09:28:23.601] run() for ‘Future’ ...
[09:28:23.601] - state: ‘created’
[09:28:23.602] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.607] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.607]   - Field: ‘label’
[09:28:23.608]   - Field: ‘local’
[09:28:23.608]   - Field: ‘owner’
[09:28:23.608]   - Field: ‘envir’
[09:28:23.609]   - Field: ‘workers’
[09:28:23.609]   - Field: ‘packages’
[09:28:23.609]   - Field: ‘gc’
[09:28:23.609]   - Field: ‘job’
[09:28:23.609]   - Field: ‘conditions’
[09:28:23.609]   - Field: ‘expr’
[09:28:23.610]   - Field: ‘uuid’
[09:28:23.610]   - Field: ‘seed’
[09:28:23.610]   - Field: ‘version’
[09:28:23.610]   - Field: ‘result’
[09:28:23.610]   - Field: ‘asynchronous’
[09:28:23.610]   - Field: ‘calls’
[09:28:23.610]   - Field: ‘globals’
[09:28:23.611]   - Field: ‘stdout’
[09:28:23.611]   - Field: ‘earlySignal’
[09:28:23.611]   - Field: ‘lazy’
[09:28:23.611]   - Field: ‘state’
[09:28:23.611] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.611] - Launch lazy future ...
[09:28:23.612] Packages needed by the future expression (n = 0): <none>
[09:28:23.612] Packages needed by future strategies (n = 0): <none>
[09:28:23.613] {
[09:28:23.613]     {
[09:28:23.613]         {
[09:28:23.613]             ...future.startTime <- base::Sys.time()
[09:28:23.613]             {
[09:28:23.613]                 {
[09:28:23.613]                   {
[09:28:23.613]                     {
[09:28:23.613]                       base::local({
[09:28:23.613]                         has_future <- base::requireNamespace("future", 
[09:28:23.613]                           quietly = TRUE)
[09:28:23.613]                         if (has_future) {
[09:28:23.613]                           ns <- base::getNamespace("future")
[09:28:23.613]                           version <- ns[[".package"]][["version"]]
[09:28:23.613]                           if (is.null(version)) 
[09:28:23.613]                             version <- utils::packageVersion("future")
[09:28:23.613]                         }
[09:28:23.613]                         else {
[09:28:23.613]                           version <- NULL
[09:28:23.613]                         }
[09:28:23.613]                         if (!has_future || version < "1.8.0") {
[09:28:23.613]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.613]                             "", base::R.version$version.string), 
[09:28:23.613]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:23.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:23.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.613]                               "release", "version")], collapse = " "), 
[09:28:23.613]                             hostname = base::Sys.info()[["nodename"]])
[09:28:23.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.613]                             info)
[09:28:23.613]                           info <- base::paste(info, collapse = "; ")
[09:28:23.613]                           if (!has_future) {
[09:28:23.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.613]                               info)
[09:28:23.613]                           }
[09:28:23.613]                           else {
[09:28:23.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.613]                               info, version)
[09:28:23.613]                           }
[09:28:23.613]                           base::stop(msg)
[09:28:23.613]                         }
[09:28:23.613]                       })
[09:28:23.613]                     }
[09:28:23.613]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.613]                     base::options(mc.cores = 1L)
[09:28:23.613]                   }
[09:28:23.613]                   ...future.strategy.old <- future::plan("list")
[09:28:23.613]                   options(future.plan = NULL)
[09:28:23.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.613]                 }
[09:28:23.613]                 ...future.workdir <- getwd()
[09:28:23.613]             }
[09:28:23.613]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.613]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.613]         }
[09:28:23.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.613]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.613]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.613]             base::names(...future.oldOptions))
[09:28:23.613]     }
[09:28:23.613]     if (FALSE) {
[09:28:23.613]     }
[09:28:23.613]     else {
[09:28:23.613]         if (TRUE) {
[09:28:23.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.613]                 open = "w")
[09:28:23.613]         }
[09:28:23.613]         else {
[09:28:23.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.613]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.613]         }
[09:28:23.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.613]             base::sink(type = "output", split = FALSE)
[09:28:23.613]             base::close(...future.stdout)
[09:28:23.613]         }, add = TRUE)
[09:28:23.613]     }
[09:28:23.613]     ...future.frame <- base::sys.nframe()
[09:28:23.613]     ...future.conditions <- base::list()
[09:28:23.613]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.613]     if (FALSE) {
[09:28:23.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.613]     }
[09:28:23.613]     ...future.result <- base::tryCatch({
[09:28:23.613]         base::withCallingHandlers({
[09:28:23.613]             ...future.value <- base::withVisible(base::local({
[09:28:23.613]                 withCallingHandlers({
[09:28:23.613]                   {
[09:28:23.613]                     do.call(function(...) {
[09:28:23.613]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.613]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.613]                         ...future.globals.maxSize)) {
[09:28:23.613]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.613]                         on.exit(options(oopts), add = TRUE)
[09:28:23.613]                       }
[09:28:23.613]                       {
[09:28:23.613]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.613]                           FUN = function(jj) {
[09:28:23.613]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.613]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.613]                           })
[09:28:23.613]                       }
[09:28:23.613]                     }, args = future.call.arguments)
[09:28:23.613]                   }
[09:28:23.613]                 }, immediateCondition = function(cond) {
[09:28:23.613]                   save_rds <- function (object, pathname, ...) 
[09:28:23.613]                   {
[09:28:23.613]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.613]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.613]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.613]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.613]                         fi_tmp[["mtime"]])
[09:28:23.613]                     }
[09:28:23.613]                     tryCatch({
[09:28:23.613]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.613]                     }, error = function(ex) {
[09:28:23.613]                       msg <- conditionMessage(ex)
[09:28:23.613]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.613]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.613]                         fi_tmp[["mtime"]], msg)
[09:28:23.613]                       ex$message <- msg
[09:28:23.613]                       stop(ex)
[09:28:23.613]                     })
[09:28:23.613]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.613]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.613]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.613]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.613]                       fi <- file.info(pathname)
[09:28:23.613]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.613]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.613]                         fi[["size"]], fi[["mtime"]])
[09:28:23.613]                       stop(msg)
[09:28:23.613]                     }
[09:28:23.613]                     invisible(pathname)
[09:28:23.613]                   }
[09:28:23.613]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.613]                     rootPath = tempdir()) 
[09:28:23.613]                   {
[09:28:23.613]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.613]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.613]                       tmpdir = path, fileext = ".rds")
[09:28:23.613]                     save_rds(obj, file)
[09:28:23.613]                   }
[09:28:23.613]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.613]                   {
[09:28:23.613]                     inherits <- base::inherits
[09:28:23.613]                     invokeRestart <- base::invokeRestart
[09:28:23.613]                     is.null <- base::is.null
[09:28:23.613]                     muffled <- FALSE
[09:28:23.613]                     if (inherits(cond, "message")) {
[09:28:23.613]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.613]                       if (muffled) 
[09:28:23.613]                         invokeRestart("muffleMessage")
[09:28:23.613]                     }
[09:28:23.613]                     else if (inherits(cond, "warning")) {
[09:28:23.613]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.613]                       if (muffled) 
[09:28:23.613]                         invokeRestart("muffleWarning")
[09:28:23.613]                     }
[09:28:23.613]                     else if (inherits(cond, "condition")) {
[09:28:23.613]                       if (!is.null(pattern)) {
[09:28:23.613]                         computeRestarts <- base::computeRestarts
[09:28:23.613]                         grepl <- base::grepl
[09:28:23.613]                         restarts <- computeRestarts(cond)
[09:28:23.613]                         for (restart in restarts) {
[09:28:23.613]                           name <- restart$name
[09:28:23.613]                           if (is.null(name)) 
[09:28:23.613]                             next
[09:28:23.613]                           if (!grepl(pattern, name)) 
[09:28:23.613]                             next
[09:28:23.613]                           invokeRestart(restart)
[09:28:23.613]                           muffled <- TRUE
[09:28:23.613]                           break
[09:28:23.613]                         }
[09:28:23.613]                       }
[09:28:23.613]                     }
[09:28:23.613]                     invisible(muffled)
[09:28:23.613]                   }
[09:28:23.613]                   muffleCondition(cond)
[09:28:23.613]                 })
[09:28:23.613]             }))
[09:28:23.613]             future::FutureResult(value = ...future.value$value, 
[09:28:23.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.613]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.613]                     ...future.globalenv.names))
[09:28:23.613]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.613]         }, condition = base::local({
[09:28:23.613]             c <- base::c
[09:28:23.613]             inherits <- base::inherits
[09:28:23.613]             invokeRestart <- base::invokeRestart
[09:28:23.613]             length <- base::length
[09:28:23.613]             list <- base::list
[09:28:23.613]             seq.int <- base::seq.int
[09:28:23.613]             signalCondition <- base::signalCondition
[09:28:23.613]             sys.calls <- base::sys.calls
[09:28:23.613]             `[[` <- base::`[[`
[09:28:23.613]             `+` <- base::`+`
[09:28:23.613]             `<<-` <- base::`<<-`
[09:28:23.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.613]                   3L)]
[09:28:23.613]             }
[09:28:23.613]             function(cond) {
[09:28:23.613]                 is_error <- inherits(cond, "error")
[09:28:23.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.613]                   NULL)
[09:28:23.613]                 if (is_error) {
[09:28:23.613]                   sessionInformation <- function() {
[09:28:23.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.613]                       search = base::search(), system = base::Sys.info())
[09:28:23.613]                   }
[09:28:23.613]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.613]                     cond$call), session = sessionInformation(), 
[09:28:23.613]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.613]                   signalCondition(cond)
[09:28:23.613]                 }
[09:28:23.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.613]                 "immediateCondition"))) {
[09:28:23.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.613]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.613]                   if (TRUE && !signal) {
[09:28:23.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.613]                     {
[09:28:23.613]                       inherits <- base::inherits
[09:28:23.613]                       invokeRestart <- base::invokeRestart
[09:28:23.613]                       is.null <- base::is.null
[09:28:23.613]                       muffled <- FALSE
[09:28:23.613]                       if (inherits(cond, "message")) {
[09:28:23.613]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.613]                         if (muffled) 
[09:28:23.613]                           invokeRestart("muffleMessage")
[09:28:23.613]                       }
[09:28:23.613]                       else if (inherits(cond, "warning")) {
[09:28:23.613]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.613]                         if (muffled) 
[09:28:23.613]                           invokeRestart("muffleWarning")
[09:28:23.613]                       }
[09:28:23.613]                       else if (inherits(cond, "condition")) {
[09:28:23.613]                         if (!is.null(pattern)) {
[09:28:23.613]                           computeRestarts <- base::computeRestarts
[09:28:23.613]                           grepl <- base::grepl
[09:28:23.613]                           restarts <- computeRestarts(cond)
[09:28:23.613]                           for (restart in restarts) {
[09:28:23.613]                             name <- restart$name
[09:28:23.613]                             if (is.null(name)) 
[09:28:23.613]                               next
[09:28:23.613]                             if (!grepl(pattern, name)) 
[09:28:23.613]                               next
[09:28:23.613]                             invokeRestart(restart)
[09:28:23.613]                             muffled <- TRUE
[09:28:23.613]                             break
[09:28:23.613]                           }
[09:28:23.613]                         }
[09:28:23.613]                       }
[09:28:23.613]                       invisible(muffled)
[09:28:23.613]                     }
[09:28:23.613]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.613]                   }
[09:28:23.613]                 }
[09:28:23.613]                 else {
[09:28:23.613]                   if (TRUE) {
[09:28:23.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.613]                     {
[09:28:23.613]                       inherits <- base::inherits
[09:28:23.613]                       invokeRestart <- base::invokeRestart
[09:28:23.613]                       is.null <- base::is.null
[09:28:23.613]                       muffled <- FALSE
[09:28:23.613]                       if (inherits(cond, "message")) {
[09:28:23.613]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.613]                         if (muffled) 
[09:28:23.613]                           invokeRestart("muffleMessage")
[09:28:23.613]                       }
[09:28:23.613]                       else if (inherits(cond, "warning")) {
[09:28:23.613]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.613]                         if (muffled) 
[09:28:23.613]                           invokeRestart("muffleWarning")
[09:28:23.613]                       }
[09:28:23.613]                       else if (inherits(cond, "condition")) {
[09:28:23.613]                         if (!is.null(pattern)) {
[09:28:23.613]                           computeRestarts <- base::computeRestarts
[09:28:23.613]                           grepl <- base::grepl
[09:28:23.613]                           restarts <- computeRestarts(cond)
[09:28:23.613]                           for (restart in restarts) {
[09:28:23.613]                             name <- restart$name
[09:28:23.613]                             if (is.null(name)) 
[09:28:23.613]                               next
[09:28:23.613]                             if (!grepl(pattern, name)) 
[09:28:23.613]                               next
[09:28:23.613]                             invokeRestart(restart)
[09:28:23.613]                             muffled <- TRUE
[09:28:23.613]                             break
[09:28:23.613]                           }
[09:28:23.613]                         }
[09:28:23.613]                       }
[09:28:23.613]                       invisible(muffled)
[09:28:23.613]                     }
[09:28:23.613]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.613]                   }
[09:28:23.613]                 }
[09:28:23.613]             }
[09:28:23.613]         }))
[09:28:23.613]     }, error = function(ex) {
[09:28:23.613]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.613]                 ...future.rng), started = ...future.startTime, 
[09:28:23.613]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.613]             version = "1.8"), class = "FutureResult")
[09:28:23.613]     }, finally = {
[09:28:23.613]         if (!identical(...future.workdir, getwd())) 
[09:28:23.613]             setwd(...future.workdir)
[09:28:23.613]         {
[09:28:23.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.613]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.613]             }
[09:28:23.613]             base::options(...future.oldOptions)
[09:28:23.613]             if (.Platform$OS.type == "windows") {
[09:28:23.613]                 old_names <- names(...future.oldEnvVars)
[09:28:23.613]                 envs <- base::Sys.getenv()
[09:28:23.613]                 names <- names(envs)
[09:28:23.613]                 common <- intersect(names, old_names)
[09:28:23.613]                 added <- setdiff(names, old_names)
[09:28:23.613]                 removed <- setdiff(old_names, names)
[09:28:23.613]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.613]                   envs[common]]
[09:28:23.613]                 NAMES <- toupper(changed)
[09:28:23.613]                 args <- list()
[09:28:23.613]                 for (kk in seq_along(NAMES)) {
[09:28:23.613]                   name <- changed[[kk]]
[09:28:23.613]                   NAME <- NAMES[[kk]]
[09:28:23.613]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.613]                     next
[09:28:23.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.613]                 }
[09:28:23.613]                 NAMES <- toupper(added)
[09:28:23.613]                 for (kk in seq_along(NAMES)) {
[09:28:23.613]                   name <- added[[kk]]
[09:28:23.613]                   NAME <- NAMES[[kk]]
[09:28:23.613]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.613]                     next
[09:28:23.613]                   args[[name]] <- ""
[09:28:23.613]                 }
[09:28:23.613]                 NAMES <- toupper(removed)
[09:28:23.613]                 for (kk in seq_along(NAMES)) {
[09:28:23.613]                   name <- removed[[kk]]
[09:28:23.613]                   NAME <- NAMES[[kk]]
[09:28:23.613]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.613]                     next
[09:28:23.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.613]                 }
[09:28:23.613]                 if (length(args) > 0) 
[09:28:23.613]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.613]             }
[09:28:23.613]             else {
[09:28:23.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.613]             }
[09:28:23.613]             {
[09:28:23.613]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.613]                   0L) {
[09:28:23.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.613]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.613]                   base::options(opts)
[09:28:23.613]                 }
[09:28:23.613]                 {
[09:28:23.613]                   {
[09:28:23.613]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.613]                     NULL
[09:28:23.613]                   }
[09:28:23.613]                   options(future.plan = NULL)
[09:28:23.613]                   if (is.na(NA_character_)) 
[09:28:23.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.613]                     .init = FALSE)
[09:28:23.613]                 }
[09:28:23.613]             }
[09:28:23.613]         }
[09:28:23.613]     })
[09:28:23.613]     if (TRUE) {
[09:28:23.613]         base::sink(type = "output", split = FALSE)
[09:28:23.613]         if (TRUE) {
[09:28:23.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.613]         }
[09:28:23.613]         else {
[09:28:23.613]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.613]         }
[09:28:23.613]         base::close(...future.stdout)
[09:28:23.613]         ...future.stdout <- NULL
[09:28:23.613]     }
[09:28:23.613]     ...future.result$conditions <- ...future.conditions
[09:28:23.613]     ...future.result$finished <- base::Sys.time()
[09:28:23.613]     ...future.result
[09:28:23.613] }
[09:28:23.615] assign_globals() ...
[09:28:23.616] List of 5
[09:28:23.616]  $ ...future.FUN            :function (object, ...)  
[09:28:23.616]  $ future.call.arguments    : list()
[09:28:23.616]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.616]  $ ...future.elements_ii    :List of 2
[09:28:23.616]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.616]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:23.616]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.616]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:23.616]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.616]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:23.616]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.616]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:23.616]  $ ...future.seeds_ii       : NULL
[09:28:23.616]  $ ...future.globals.maxSize: NULL
[09:28:23.616]  - attr(*, "where")=List of 5
[09:28:23.616]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.616]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.616]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.616]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.616]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.616]  - attr(*, "resolved")= logi FALSE
[09:28:23.616]  - attr(*, "total_size")= num 1240
[09:28:23.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.616]  - attr(*, "already-done")= logi TRUE
[09:28:23.624] - copied ‘...future.FUN’ to environment
[09:28:23.625] - copied ‘future.call.arguments’ to environment
[09:28:23.625] - copied ‘...future.elements_ii’ to environment
[09:28:23.625] - copied ‘...future.seeds_ii’ to environment
[09:28:23.625] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.625] assign_globals() ... done
[09:28:23.625] requestCore(): workers = 2
[09:28:23.627] MulticoreFuture started
[09:28:23.627] - Launch lazy future ... done
[09:28:23.628] run() for ‘MulticoreFuture’ ... done
[09:28:23.628] Created future:
[09:28:23.628] plan(): Setting new future strategy stack:
[09:28:23.628] List of future strategies:
[09:28:23.628] 1. sequential:
[09:28:23.628]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.628]    - tweaked: FALSE
[09:28:23.628]    - call: NULL
[09:28:23.629] plan(): nbrOfWorkers() = 1
[09:28:23.633] plan(): Setting new future strategy stack:
[09:28:23.634] List of future strategies:
[09:28:23.634] 1. multicore:
[09:28:23.634]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.634]    - tweaked: FALSE
[09:28:23.634]    - call: plan(strategy)
[09:28:23.628] MulticoreFuture:
[09:28:23.628] Label: ‘future_by-2’
[09:28:23.628] Expression:
[09:28:23.628] {
[09:28:23.628]     do.call(function(...) {
[09:28:23.628]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.628]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.628]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.628]             on.exit(options(oopts), add = TRUE)
[09:28:23.628]         }
[09:28:23.628]         {
[09:28:23.628]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.628]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.628]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.628]             })
[09:28:23.628]         }
[09:28:23.628]     }, args = future.call.arguments)
[09:28:23.628] }
[09:28:23.628] Lazy evaluation: FALSE
[09:28:23.628] Asynchronous evaluation: TRUE
[09:28:23.628] Local evaluation: TRUE
[09:28:23.628] Environment: 0x555b0a784220
[09:28:23.628] Capture standard output: TRUE
[09:28:23.628] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.628] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:23.628] Packages: <none>
[09:28:23.628] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.628] Resolved: FALSE
[09:28:23.628] Value: <not collected>
[09:28:23.628] Conditions captured: <none>
[09:28:23.628] Early signaling: FALSE
[09:28:23.628] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.628] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.641] Chunk #2 of 2 ... DONE
[09:28:23.641] Launching 2 futures (chunks) ... DONE
[09:28:23.641] Resolving 2 futures (chunks) ...
[09:28:23.642] resolve() on list ...
[09:28:23.642]  recursive: 0
[09:28:23.642]  length: 2
[09:28:23.642] 
[09:28:23.642] Future #1
[09:28:23.643] result() for MulticoreFuture ...
[09:28:23.644] plan(): nbrOfWorkers() = 2
[09:28:23.646] result() for MulticoreFuture ...
[09:28:23.646] result() for MulticoreFuture ... done
[09:28:23.647] result() for MulticoreFuture ... done
[09:28:23.647] result() for MulticoreFuture ...
[09:28:23.647] result() for MulticoreFuture ... done
[09:28:23.647] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:23.647] - nx: 2
[09:28:23.648] - relay: TRUE
[09:28:23.648] - stdout: TRUE
[09:28:23.648] - signal: TRUE
[09:28:23.648] - resignal: FALSE
[09:28:23.648] - force: TRUE
[09:28:23.649] - relayed: [n=2] FALSE, FALSE
[09:28:23.649] - queued futures: [n=2] FALSE, FALSE
[09:28:23.649]  - until=1
[09:28:23.650]  - relaying element #1
[09:28:23.650] result() for MulticoreFuture ...
[09:28:23.650] result() for MulticoreFuture ... done
[09:28:23.650] result() for MulticoreFuture ...
[09:28:23.650] result() for MulticoreFuture ... done
[09:28:23.651] result() for MulticoreFuture ...
[09:28:23.651] result() for MulticoreFuture ... done
[09:28:23.651] result() for MulticoreFuture ...
[09:28:23.652] result() for MulticoreFuture ... done
[09:28:23.652] - relayed: [n=2] TRUE, FALSE
[09:28:23.652] - queued futures: [n=2] TRUE, FALSE
[09:28:23.652] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:23.652]  length: 1 (resolved future 1)
[09:28:23.653] Future #2
[09:28:23.653] result() for MulticoreFuture ...
[09:28:23.654] result() for MulticoreFuture ...
[09:28:23.654] result() for MulticoreFuture ... done
[09:28:23.655] result() for MulticoreFuture ... done
[09:28:23.655] result() for MulticoreFuture ...
[09:28:23.655] result() for MulticoreFuture ... done
[09:28:23.655] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:23.655] - nx: 2
[09:28:23.655] - relay: TRUE
[09:28:23.656] - stdout: TRUE
[09:28:23.656] - signal: TRUE
[09:28:23.656] - resignal: FALSE
[09:28:23.656] - force: TRUE
[09:28:23.656] - relayed: [n=2] TRUE, FALSE
[09:28:23.656] - queued futures: [n=2] TRUE, FALSE
[09:28:23.656]  - until=2
[09:28:23.656]  - relaying element #2
[09:28:23.657] result() for MulticoreFuture ...
[09:28:23.657] result() for MulticoreFuture ... done
[09:28:23.657] result() for MulticoreFuture ...
[09:28:23.657] result() for MulticoreFuture ... done
[09:28:23.657] result() for MulticoreFuture ...
[09:28:23.657] result() for MulticoreFuture ... done
[09:28:23.658] result() for MulticoreFuture ...
[09:28:23.658] result() for MulticoreFuture ... done
[09:28:23.658] - relayed: [n=2] TRUE, TRUE
[09:28:23.658] - queued futures: [n=2] TRUE, TRUE
[09:28:23.658] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:23.658]  length: 0 (resolved future 2)
[09:28:23.658] Relaying remaining futures
[09:28:23.658] signalConditionsASAP(NULL, pos=0) ...
[09:28:23.658] - nx: 2
[09:28:23.659] - relay: TRUE
[09:28:23.659] - stdout: TRUE
[09:28:23.659] - signal: TRUE
[09:28:23.659] - resignal: FALSE
[09:28:23.659] - force: TRUE
[09:28:23.659] - relayed: [n=2] TRUE, TRUE
[09:28:23.659] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:23.659] - relayed: [n=2] TRUE, TRUE
[09:28:23.659] - queued futures: [n=2] TRUE, TRUE
[09:28:23.659] signalConditionsASAP(NULL, pos=0) ... done
[09:28:23.660] resolve() on list ... DONE
[09:28:23.660] result() for MulticoreFuture ...
[09:28:23.660] result() for MulticoreFuture ... done
[09:28:23.660] result() for MulticoreFuture ...
[09:28:23.660] result() for MulticoreFuture ... done
[09:28:23.660] result() for MulticoreFuture ...
[09:28:23.660] result() for MulticoreFuture ... done
[09:28:23.660] result() for MulticoreFuture ...
[09:28:23.661] result() for MulticoreFuture ... done
[09:28:23.661]  - Number of value chunks collected: 2
[09:28:23.661] Resolving 2 futures (chunks) ... DONE
[09:28:23.661] Reducing values from 2 chunks ...
[09:28:23.661]  - Number of values collected after concatenation: 3
[09:28:23.661]  - Number of values expected: 3
[09:28:23.661] Reducing values from 2 chunks ... DONE
[09:28:23.661] future_lapply() ... DONE
[09:28:23.661] future_by_internal() ... DONE
[09:28:23.662] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[09:28:23.663] future_lapply() ...
[09:28:23.667] Number of chunks: 2
[09:28:23.667] getGlobalsAndPackagesXApply() ...
[09:28:23.667]  - future.globals: TRUE
[09:28:23.668] getGlobalsAndPackages() ...
[09:28:23.668] Searching for globals...
[09:28:23.669] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:23.669] Searching for globals ... DONE
[09:28:23.669] Resolving globals: FALSE
[09:28:23.670] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:23.670] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:23.670] - globals: [1] ‘FUN’
[09:28:23.670] 
[09:28:23.670] getGlobalsAndPackages() ... DONE
[09:28:23.670]  - globals found/used: [n=1] ‘FUN’
[09:28:23.670]  - needed namespaces: [n=0] 
[09:28:23.670] Finding globals ... DONE
[09:28:23.671]  - use_args: TRUE
[09:28:23.671]  - Getting '...' globals ...
[09:28:23.671] resolve() on list ...
[09:28:23.671]  recursive: 0
[09:28:23.671]  length: 1
[09:28:23.671]  elements: ‘...’
[09:28:23.671]  length: 0 (resolved future 1)
[09:28:23.672] resolve() on list ... DONE
[09:28:23.672]    - '...' content: [n=0] 
[09:28:23.672] List of 1
[09:28:23.672]  $ ...: list()
[09:28:23.672]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.672]  - attr(*, "where")=List of 1
[09:28:23.672]   ..$ ...:<environment: 0x555b09ba3ee8> 
[09:28:23.672]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.672]  - attr(*, "resolved")= logi TRUE
[09:28:23.672]  - attr(*, "total_size")= num NA
[09:28:23.676]  - Getting '...' globals ... DONE
[09:28:23.677] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:23.677] List of 2
[09:28:23.677]  $ ...future.FUN:function (object, ...)  
[09:28:23.677]  $ ...          : list()
[09:28:23.677]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.677]  - attr(*, "where")=List of 2
[09:28:23.677]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:23.677]   ..$ ...          :<environment: 0x555b09ba3ee8> 
[09:28:23.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.677]  - attr(*, "resolved")= logi FALSE
[09:28:23.677]  - attr(*, "total_size")= num 1240
[09:28:23.680] Packages to be attached in all futures: [n=0] 
[09:28:23.680] getGlobalsAndPackagesXApply() ... DONE
[09:28:23.680] Number of futures (= number of chunks): 2
[09:28:23.680] Launching 2 futures (chunks) ...
[09:28:23.680] Chunk #1 of 2 ...
[09:28:23.680]  - Finding globals in 'X' for chunk #1 ...
[09:28:23.681] getGlobalsAndPackages() ...
[09:28:23.681] Searching for globals...
[09:28:23.681] 
[09:28:23.681] Searching for globals ... DONE
[09:28:23.681] - globals: [0] <none>
[09:28:23.681] getGlobalsAndPackages() ... DONE
[09:28:23.681]    + additional globals found: [n=0] 
[09:28:23.682]    + additional namespaces needed: [n=0] 
[09:28:23.682]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:23.682]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.682]  - seeds: <none>
[09:28:23.682]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.682] getGlobalsAndPackages() ...
[09:28:23.682] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.682] Resolving globals: FALSE
[09:28:23.682] Tweak future expression to call with '...' arguments ...
[09:28:23.682] {
[09:28:23.682]     do.call(function(...) {
[09:28:23.682]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.682]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.682]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.682]             on.exit(options(oopts), add = TRUE)
[09:28:23.682]         }
[09:28:23.682]         {
[09:28:23.682]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.682]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.682]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.682]             })
[09:28:23.682]         }
[09:28:23.682]     }, args = future.call.arguments)
[09:28:23.682] }
[09:28:23.683] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.683] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.683] 
[09:28:23.683] getGlobalsAndPackages() ... DONE
[09:28:23.684] run() for ‘Future’ ...
[09:28:23.684] - state: ‘created’
[09:28:23.684] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.687] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.687] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.687]   - Field: ‘label’
[09:28:23.688]   - Field: ‘local’
[09:28:23.688]   - Field: ‘owner’
[09:28:23.688]   - Field: ‘envir’
[09:28:23.688]   - Field: ‘workers’
[09:28:23.688]   - Field: ‘packages’
[09:28:23.688]   - Field: ‘gc’
[09:28:23.688]   - Field: ‘job’
[09:28:23.688]   - Field: ‘conditions’
[09:28:23.688]   - Field: ‘expr’
[09:28:23.688]   - Field: ‘uuid’
[09:28:23.689]   - Field: ‘seed’
[09:28:23.689]   - Field: ‘version’
[09:28:23.689]   - Field: ‘result’
[09:28:23.689]   - Field: ‘asynchronous’
[09:28:23.689]   - Field: ‘calls’
[09:28:23.689]   - Field: ‘globals’
[09:28:23.689]   - Field: ‘stdout’
[09:28:23.689]   - Field: ‘earlySignal’
[09:28:23.689]   - Field: ‘lazy’
[09:28:23.689]   - Field: ‘state’
[09:28:23.689] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.690] - Launch lazy future ...
[09:28:23.690] Packages needed by the future expression (n = 0): <none>
[09:28:23.690] Packages needed by future strategies (n = 0): <none>
[09:28:23.690] {
[09:28:23.690]     {
[09:28:23.690]         {
[09:28:23.690]             ...future.startTime <- base::Sys.time()
[09:28:23.690]             {
[09:28:23.690]                 {
[09:28:23.690]                   {
[09:28:23.690]                     {
[09:28:23.690]                       base::local({
[09:28:23.690]                         has_future <- base::requireNamespace("future", 
[09:28:23.690]                           quietly = TRUE)
[09:28:23.690]                         if (has_future) {
[09:28:23.690]                           ns <- base::getNamespace("future")
[09:28:23.690]                           version <- ns[[".package"]][["version"]]
[09:28:23.690]                           if (is.null(version)) 
[09:28:23.690]                             version <- utils::packageVersion("future")
[09:28:23.690]                         }
[09:28:23.690]                         else {
[09:28:23.690]                           version <- NULL
[09:28:23.690]                         }
[09:28:23.690]                         if (!has_future || version < "1.8.0") {
[09:28:23.690]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.690]                             "", base::R.version$version.string), 
[09:28:23.690]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:23.690]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:23.690]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.690]                               "release", "version")], collapse = " "), 
[09:28:23.690]                             hostname = base::Sys.info()[["nodename"]])
[09:28:23.690]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.690]                             info)
[09:28:23.690]                           info <- base::paste(info, collapse = "; ")
[09:28:23.690]                           if (!has_future) {
[09:28:23.690]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.690]                               info)
[09:28:23.690]                           }
[09:28:23.690]                           else {
[09:28:23.690]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.690]                               info, version)
[09:28:23.690]                           }
[09:28:23.690]                           base::stop(msg)
[09:28:23.690]                         }
[09:28:23.690]                       })
[09:28:23.690]                     }
[09:28:23.690]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.690]                     base::options(mc.cores = 1L)
[09:28:23.690]                   }
[09:28:23.690]                   ...future.strategy.old <- future::plan("list")
[09:28:23.690]                   options(future.plan = NULL)
[09:28:23.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.690]                 }
[09:28:23.690]                 ...future.workdir <- getwd()
[09:28:23.690]             }
[09:28:23.690]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.690]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.690]         }
[09:28:23.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.690]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.690]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.690]             base::names(...future.oldOptions))
[09:28:23.690]     }
[09:28:23.690]     if (FALSE) {
[09:28:23.690]     }
[09:28:23.690]     else {
[09:28:23.690]         if (TRUE) {
[09:28:23.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.690]                 open = "w")
[09:28:23.690]         }
[09:28:23.690]         else {
[09:28:23.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.690]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.690]         }
[09:28:23.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.690]             base::sink(type = "output", split = FALSE)
[09:28:23.690]             base::close(...future.stdout)
[09:28:23.690]         }, add = TRUE)
[09:28:23.690]     }
[09:28:23.690]     ...future.frame <- base::sys.nframe()
[09:28:23.690]     ...future.conditions <- base::list()
[09:28:23.690]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.690]     if (FALSE) {
[09:28:23.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.690]     }
[09:28:23.690]     ...future.result <- base::tryCatch({
[09:28:23.690]         base::withCallingHandlers({
[09:28:23.690]             ...future.value <- base::withVisible(base::local({
[09:28:23.690]                 withCallingHandlers({
[09:28:23.690]                   {
[09:28:23.690]                     do.call(function(...) {
[09:28:23.690]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.690]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.690]                         ...future.globals.maxSize)) {
[09:28:23.690]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.690]                         on.exit(options(oopts), add = TRUE)
[09:28:23.690]                       }
[09:28:23.690]                       {
[09:28:23.690]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.690]                           FUN = function(jj) {
[09:28:23.690]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.690]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.690]                           })
[09:28:23.690]                       }
[09:28:23.690]                     }, args = future.call.arguments)
[09:28:23.690]                   }
[09:28:23.690]                 }, immediateCondition = function(cond) {
[09:28:23.690]                   save_rds <- function (object, pathname, ...) 
[09:28:23.690]                   {
[09:28:23.690]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.690]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.690]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.690]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.690]                         fi_tmp[["mtime"]])
[09:28:23.690]                     }
[09:28:23.690]                     tryCatch({
[09:28:23.690]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.690]                     }, error = function(ex) {
[09:28:23.690]                       msg <- conditionMessage(ex)
[09:28:23.690]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.690]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.690]                         fi_tmp[["mtime"]], msg)
[09:28:23.690]                       ex$message <- msg
[09:28:23.690]                       stop(ex)
[09:28:23.690]                     })
[09:28:23.690]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.690]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.690]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.690]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.690]                       fi <- file.info(pathname)
[09:28:23.690]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.690]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.690]                         fi[["size"]], fi[["mtime"]])
[09:28:23.690]                       stop(msg)
[09:28:23.690]                     }
[09:28:23.690]                     invisible(pathname)
[09:28:23.690]                   }
[09:28:23.690]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.690]                     rootPath = tempdir()) 
[09:28:23.690]                   {
[09:28:23.690]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.690]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.690]                       tmpdir = path, fileext = ".rds")
[09:28:23.690]                     save_rds(obj, file)
[09:28:23.690]                   }
[09:28:23.690]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.690]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.690]                   {
[09:28:23.690]                     inherits <- base::inherits
[09:28:23.690]                     invokeRestart <- base::invokeRestart
[09:28:23.690]                     is.null <- base::is.null
[09:28:23.690]                     muffled <- FALSE
[09:28:23.690]                     if (inherits(cond, "message")) {
[09:28:23.690]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.690]                       if (muffled) 
[09:28:23.690]                         invokeRestart("muffleMessage")
[09:28:23.690]                     }
[09:28:23.690]                     else if (inherits(cond, "warning")) {
[09:28:23.690]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.690]                       if (muffled) 
[09:28:23.690]                         invokeRestart("muffleWarning")
[09:28:23.690]                     }
[09:28:23.690]                     else if (inherits(cond, "condition")) {
[09:28:23.690]                       if (!is.null(pattern)) {
[09:28:23.690]                         computeRestarts <- base::computeRestarts
[09:28:23.690]                         grepl <- base::grepl
[09:28:23.690]                         restarts <- computeRestarts(cond)
[09:28:23.690]                         for (restart in restarts) {
[09:28:23.690]                           name <- restart$name
[09:28:23.690]                           if (is.null(name)) 
[09:28:23.690]                             next
[09:28:23.690]                           if (!grepl(pattern, name)) 
[09:28:23.690]                             next
[09:28:23.690]                           invokeRestart(restart)
[09:28:23.690]                           muffled <- TRUE
[09:28:23.690]                           break
[09:28:23.690]                         }
[09:28:23.690]                       }
[09:28:23.690]                     }
[09:28:23.690]                     invisible(muffled)
[09:28:23.690]                   }
[09:28:23.690]                   muffleCondition(cond)
[09:28:23.690]                 })
[09:28:23.690]             }))
[09:28:23.690]             future::FutureResult(value = ...future.value$value, 
[09:28:23.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.690]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.690]                     ...future.globalenv.names))
[09:28:23.690]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.690]         }, condition = base::local({
[09:28:23.690]             c <- base::c
[09:28:23.690]             inherits <- base::inherits
[09:28:23.690]             invokeRestart <- base::invokeRestart
[09:28:23.690]             length <- base::length
[09:28:23.690]             list <- base::list
[09:28:23.690]             seq.int <- base::seq.int
[09:28:23.690]             signalCondition <- base::signalCondition
[09:28:23.690]             sys.calls <- base::sys.calls
[09:28:23.690]             `[[` <- base::`[[`
[09:28:23.690]             `+` <- base::`+`
[09:28:23.690]             `<<-` <- base::`<<-`
[09:28:23.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.690]                   3L)]
[09:28:23.690]             }
[09:28:23.690]             function(cond) {
[09:28:23.690]                 is_error <- inherits(cond, "error")
[09:28:23.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.690]                   NULL)
[09:28:23.690]                 if (is_error) {
[09:28:23.690]                   sessionInformation <- function() {
[09:28:23.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.690]                       search = base::search(), system = base::Sys.info())
[09:28:23.690]                   }
[09:28:23.690]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.690]                     cond$call), session = sessionInformation(), 
[09:28:23.690]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.690]                   signalCondition(cond)
[09:28:23.690]                 }
[09:28:23.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.690]                 "immediateCondition"))) {
[09:28:23.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.690]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.690]                   if (TRUE && !signal) {
[09:28:23.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.690]                     {
[09:28:23.690]                       inherits <- base::inherits
[09:28:23.690]                       invokeRestart <- base::invokeRestart
[09:28:23.690]                       is.null <- base::is.null
[09:28:23.690]                       muffled <- FALSE
[09:28:23.690]                       if (inherits(cond, "message")) {
[09:28:23.690]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.690]                         if (muffled) 
[09:28:23.690]                           invokeRestart("muffleMessage")
[09:28:23.690]                       }
[09:28:23.690]                       else if (inherits(cond, "warning")) {
[09:28:23.690]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.690]                         if (muffled) 
[09:28:23.690]                           invokeRestart("muffleWarning")
[09:28:23.690]                       }
[09:28:23.690]                       else if (inherits(cond, "condition")) {
[09:28:23.690]                         if (!is.null(pattern)) {
[09:28:23.690]                           computeRestarts <- base::computeRestarts
[09:28:23.690]                           grepl <- base::grepl
[09:28:23.690]                           restarts <- computeRestarts(cond)
[09:28:23.690]                           for (restart in restarts) {
[09:28:23.690]                             name <- restart$name
[09:28:23.690]                             if (is.null(name)) 
[09:28:23.690]                               next
[09:28:23.690]                             if (!grepl(pattern, name)) 
[09:28:23.690]                               next
[09:28:23.690]                             invokeRestart(restart)
[09:28:23.690]                             muffled <- TRUE
[09:28:23.690]                             break
[09:28:23.690]                           }
[09:28:23.690]                         }
[09:28:23.690]                       }
[09:28:23.690]                       invisible(muffled)
[09:28:23.690]                     }
[09:28:23.690]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.690]                   }
[09:28:23.690]                 }
[09:28:23.690]                 else {
[09:28:23.690]                   if (TRUE) {
[09:28:23.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.690]                     {
[09:28:23.690]                       inherits <- base::inherits
[09:28:23.690]                       invokeRestart <- base::invokeRestart
[09:28:23.690]                       is.null <- base::is.null
[09:28:23.690]                       muffled <- FALSE
[09:28:23.690]                       if (inherits(cond, "message")) {
[09:28:23.690]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.690]                         if (muffled) 
[09:28:23.690]                           invokeRestart("muffleMessage")
[09:28:23.690]                       }
[09:28:23.690]                       else if (inherits(cond, "warning")) {
[09:28:23.690]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.690]                         if (muffled) 
[09:28:23.690]                           invokeRestart("muffleWarning")
[09:28:23.690]                       }
[09:28:23.690]                       else if (inherits(cond, "condition")) {
[09:28:23.690]                         if (!is.null(pattern)) {
[09:28:23.690]                           computeRestarts <- base::computeRestarts
[09:28:23.690]                           grepl <- base::grepl
[09:28:23.690]                           restarts <- computeRestarts(cond)
[09:28:23.690]                           for (restart in restarts) {
[09:28:23.690]                             name <- restart$name
[09:28:23.690]                             if (is.null(name)) 
[09:28:23.690]                               next
[09:28:23.690]                             if (!grepl(pattern, name)) 
[09:28:23.690]                               next
[09:28:23.690]                             invokeRestart(restart)
[09:28:23.690]                             muffled <- TRUE
[09:28:23.690]                             break
[09:28:23.690]                           }
[09:28:23.690]                         }
[09:28:23.690]                       }
[09:28:23.690]                       invisible(muffled)
[09:28:23.690]                     }
[09:28:23.690]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.690]                   }
[09:28:23.690]                 }
[09:28:23.690]             }
[09:28:23.690]         }))
[09:28:23.690]     }, error = function(ex) {
[09:28:23.690]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.690]                 ...future.rng), started = ...future.startTime, 
[09:28:23.690]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.690]             version = "1.8"), class = "FutureResult")
[09:28:23.690]     }, finally = {
[09:28:23.690]         if (!identical(...future.workdir, getwd())) 
[09:28:23.690]             setwd(...future.workdir)
[09:28:23.690]         {
[09:28:23.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.690]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.690]             }
[09:28:23.690]             base::options(...future.oldOptions)
[09:28:23.690]             if (.Platform$OS.type == "windows") {
[09:28:23.690]                 old_names <- names(...future.oldEnvVars)
[09:28:23.690]                 envs <- base::Sys.getenv()
[09:28:23.690]                 names <- names(envs)
[09:28:23.690]                 common <- intersect(names, old_names)
[09:28:23.690]                 added <- setdiff(names, old_names)
[09:28:23.690]                 removed <- setdiff(old_names, names)
[09:28:23.690]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.690]                   envs[common]]
[09:28:23.690]                 NAMES <- toupper(changed)
[09:28:23.690]                 args <- list()
[09:28:23.690]                 for (kk in seq_along(NAMES)) {
[09:28:23.690]                   name <- changed[[kk]]
[09:28:23.690]                   NAME <- NAMES[[kk]]
[09:28:23.690]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.690]                     next
[09:28:23.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.690]                 }
[09:28:23.690]                 NAMES <- toupper(added)
[09:28:23.690]                 for (kk in seq_along(NAMES)) {
[09:28:23.690]                   name <- added[[kk]]
[09:28:23.690]                   NAME <- NAMES[[kk]]
[09:28:23.690]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.690]                     next
[09:28:23.690]                   args[[name]] <- ""
[09:28:23.690]                 }
[09:28:23.690]                 NAMES <- toupper(removed)
[09:28:23.690]                 for (kk in seq_along(NAMES)) {
[09:28:23.690]                   name <- removed[[kk]]
[09:28:23.690]                   NAME <- NAMES[[kk]]
[09:28:23.690]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.690]                     next
[09:28:23.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.690]                 }
[09:28:23.690]                 if (length(args) > 0) 
[09:28:23.690]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.690]             }
[09:28:23.690]             else {
[09:28:23.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.690]             }
[09:28:23.690]             {
[09:28:23.690]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.690]                   0L) {
[09:28:23.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.690]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.690]                   base::options(opts)
[09:28:23.690]                 }
[09:28:23.690]                 {
[09:28:23.690]                   {
[09:28:23.690]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.690]                     NULL
[09:28:23.690]                   }
[09:28:23.690]                   options(future.plan = NULL)
[09:28:23.690]                   if (is.na(NA_character_)) 
[09:28:23.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.690]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.690]                     .init = FALSE)
[09:28:23.690]                 }
[09:28:23.690]             }
[09:28:23.690]         }
[09:28:23.690]     })
[09:28:23.690]     if (TRUE) {
[09:28:23.690]         base::sink(type = "output", split = FALSE)
[09:28:23.690]         if (TRUE) {
[09:28:23.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.690]         }
[09:28:23.690]         else {
[09:28:23.690]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.690]         }
[09:28:23.690]         base::close(...future.stdout)
[09:28:23.690]         ...future.stdout <- NULL
[09:28:23.690]     }
[09:28:23.690]     ...future.result$conditions <- ...future.conditions
[09:28:23.690]     ...future.result$finished <- base::Sys.time()
[09:28:23.690]     ...future.result
[09:28:23.690] }
[09:28:23.693] assign_globals() ...
[09:28:23.693] List of 5
[09:28:23.693]  $ ...future.FUN            :function (object, ...)  
[09:28:23.693]  $ future.call.arguments    : list()
[09:28:23.693]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.693]  $ ...future.elements_ii    :List of 1
[09:28:23.693]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.693]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[09:28:23.693]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.693]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:23.693]  $ ...future.seeds_ii       : NULL
[09:28:23.693]  $ ...future.globals.maxSize: NULL
[09:28:23.693]  - attr(*, "where")=List of 5
[09:28:23.693]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.693]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.693]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.693]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.693]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.693]  - attr(*, "resolved")= logi FALSE
[09:28:23.693]  - attr(*, "total_size")= num 1240
[09:28:23.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.693]  - attr(*, "already-done")= logi TRUE
[09:28:23.700] - copied ‘...future.FUN’ to environment
[09:28:23.700] - copied ‘future.call.arguments’ to environment
[09:28:23.701] - copied ‘...future.elements_ii’ to environment
[09:28:23.701] - copied ‘...future.seeds_ii’ to environment
[09:28:23.701] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.701] assign_globals() ... done
[09:28:23.701] requestCore(): workers = 2
[09:28:23.703] MulticoreFuture started
[09:28:23.704] - Launch lazy future ... done
[09:28:23.704] run() for ‘MulticoreFuture’ ... done
[09:28:23.704] plan(): Setting new future strategy stack:
[09:28:23.705] Created future:
[09:28:23.705] List of future strategies:
[09:28:23.705] 1. sequential:
[09:28:23.705]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.705]    - tweaked: FALSE
[09:28:23.705]    - call: NULL
[09:28:23.706] plan(): nbrOfWorkers() = 1
[09:28:23.711] plan(): Setting new future strategy stack:
[09:28:23.711] List of future strategies:
[09:28:23.711] 1. multicore:
[09:28:23.711]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.711]    - tweaked: FALSE
[09:28:23.711]    - call: plan(strategy)
[09:28:23.717] plan(): nbrOfWorkers() = 2
[09:28:23.705] MulticoreFuture:
[09:28:23.705] Label: ‘future_by-1’
[09:28:23.705] Expression:
[09:28:23.705] {
[09:28:23.705]     do.call(function(...) {
[09:28:23.705]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.705]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.705]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.705]             on.exit(options(oopts), add = TRUE)
[09:28:23.705]         }
[09:28:23.705]         {
[09:28:23.705]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.705]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.705]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.705]             })
[09:28:23.705]         }
[09:28:23.705]     }, args = future.call.arguments)
[09:28:23.705] }
[09:28:23.705] Lazy evaluation: FALSE
[09:28:23.705] Asynchronous evaluation: TRUE
[09:28:23.705] Local evaluation: TRUE
[09:28:23.705] Environment: 0x555b0858ca08
[09:28:23.705] Capture standard output: TRUE
[09:28:23.705] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.705] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:23.705] Packages: <none>
[09:28:23.705] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.705] Resolved: TRUE
[09:28:23.705] Value: <not collected>
[09:28:23.705] Conditions captured: <none>
[09:28:23.705] Early signaling: FALSE
[09:28:23.705] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.705] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.718] Chunk #1 of 2 ... DONE
[09:28:23.718] Chunk #2 of 2 ...
[09:28:23.719]  - Finding globals in 'X' for chunk #2 ...
[09:28:23.719] getGlobalsAndPackages() ...
[09:28:23.719] Searching for globals...
[09:28:23.720] 
[09:28:23.720] Searching for globals ... DONE
[09:28:23.720] - globals: [0] <none>
[09:28:23.721] getGlobalsAndPackages() ... DONE
[09:28:23.721]    + additional globals found: [n=0] 
[09:28:23.721]    + additional namespaces needed: [n=0] 
[09:28:23.721]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:23.721]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:23.721]  - seeds: <none>
[09:28:23.721]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.722] getGlobalsAndPackages() ...
[09:28:23.722] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.722] Resolving globals: FALSE
[09:28:23.722] Tweak future expression to call with '...' arguments ...
[09:28:23.722] {
[09:28:23.722]     do.call(function(...) {
[09:28:23.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.722]             on.exit(options(oopts), add = TRUE)
[09:28:23.722]         }
[09:28:23.722]         {
[09:28:23.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.722]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.722]             })
[09:28:23.722]         }
[09:28:23.722]     }, args = future.call.arguments)
[09:28:23.722] }
[09:28:23.723] Tweak future expression to call with '...' arguments ... DONE
[09:28:23.723] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:23.724] 
[09:28:23.724] getGlobalsAndPackages() ... DONE
[09:28:23.724] run() for ‘Future’ ...
[09:28:23.724] - state: ‘created’
[09:28:23.725] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:28:23.729] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.729] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:28:23.729]   - Field: ‘label’
[09:28:23.730]   - Field: ‘local’
[09:28:23.730]   - Field: ‘owner’
[09:28:23.730]   - Field: ‘envir’
[09:28:23.730]   - Field: ‘workers’
[09:28:23.730]   - Field: ‘packages’
[09:28:23.730]   - Field: ‘gc’
[09:28:23.730]   - Field: ‘job’
[09:28:23.730]   - Field: ‘conditions’
[09:28:23.731]   - Field: ‘expr’
[09:28:23.731]   - Field: ‘uuid’
[09:28:23.731]   - Field: ‘seed’
[09:28:23.731]   - Field: ‘version’
[09:28:23.731]   - Field: ‘result’
[09:28:23.731]   - Field: ‘asynchronous’
[09:28:23.731]   - Field: ‘calls’
[09:28:23.731]   - Field: ‘globals’
[09:28:23.732]   - Field: ‘stdout’
[09:28:23.732]   - Field: ‘earlySignal’
[09:28:23.732]   - Field: ‘lazy’
[09:28:23.732]   - Field: ‘state’
[09:28:23.732] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:28:23.732] - Launch lazy future ...
[09:28:23.733] Packages needed by the future expression (n = 0): <none>
[09:28:23.733] Packages needed by future strategies (n = 0): <none>
[09:28:23.733] {
[09:28:23.733]     {
[09:28:23.733]         {
[09:28:23.733]             ...future.startTime <- base::Sys.time()
[09:28:23.733]             {
[09:28:23.733]                 {
[09:28:23.733]                   {
[09:28:23.733]                     {
[09:28:23.733]                       base::local({
[09:28:23.733]                         has_future <- base::requireNamespace("future", 
[09:28:23.733]                           quietly = TRUE)
[09:28:23.733]                         if (has_future) {
[09:28:23.733]                           ns <- base::getNamespace("future")
[09:28:23.733]                           version <- ns[[".package"]][["version"]]
[09:28:23.733]                           if (is.null(version)) 
[09:28:23.733]                             version <- utils::packageVersion("future")
[09:28:23.733]                         }
[09:28:23.733]                         else {
[09:28:23.733]                           version <- NULL
[09:28:23.733]                         }
[09:28:23.733]                         if (!has_future || version < "1.8.0") {
[09:28:23.733]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:23.733]                             "", base::R.version$version.string), 
[09:28:23.733]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:23.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:23.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:23.733]                               "release", "version")], collapse = " "), 
[09:28:23.733]                             hostname = base::Sys.info()[["nodename"]])
[09:28:23.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:23.733]                             info)
[09:28:23.733]                           info <- base::paste(info, collapse = "; ")
[09:28:23.733]                           if (!has_future) {
[09:28:23.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:23.733]                               info)
[09:28:23.733]                           }
[09:28:23.733]                           else {
[09:28:23.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:23.733]                               info, version)
[09:28:23.733]                           }
[09:28:23.733]                           base::stop(msg)
[09:28:23.733]                         }
[09:28:23.733]                       })
[09:28:23.733]                     }
[09:28:23.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:23.733]                     base::options(mc.cores = 1L)
[09:28:23.733]                   }
[09:28:23.733]                   ...future.strategy.old <- future::plan("list")
[09:28:23.733]                   options(future.plan = NULL)
[09:28:23.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:23.733]                 }
[09:28:23.733]                 ...future.workdir <- getwd()
[09:28:23.733]             }
[09:28:23.733]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:23.733]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:23.733]         }
[09:28:23.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:23.733]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:23.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:23.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:23.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:23.733]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:23.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:23.733]             base::names(...future.oldOptions))
[09:28:23.733]     }
[09:28:23.733]     if (FALSE) {
[09:28:23.733]     }
[09:28:23.733]     else {
[09:28:23.733]         if (TRUE) {
[09:28:23.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:23.733]                 open = "w")
[09:28:23.733]         }
[09:28:23.733]         else {
[09:28:23.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:23.733]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:23.733]         }
[09:28:23.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:23.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:23.733]             base::sink(type = "output", split = FALSE)
[09:28:23.733]             base::close(...future.stdout)
[09:28:23.733]         }, add = TRUE)
[09:28:23.733]     }
[09:28:23.733]     ...future.frame <- base::sys.nframe()
[09:28:23.733]     ...future.conditions <- base::list()
[09:28:23.733]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:23.733]     if (FALSE) {
[09:28:23.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:23.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:23.733]     }
[09:28:23.733]     ...future.result <- base::tryCatch({
[09:28:23.733]         base::withCallingHandlers({
[09:28:23.733]             ...future.value <- base::withVisible(base::local({
[09:28:23.733]                 withCallingHandlers({
[09:28:23.733]                   {
[09:28:23.733]                     do.call(function(...) {
[09:28:23.733]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.733]                       if (!identical(...future.globals.maxSize.org, 
[09:28:23.733]                         ...future.globals.maxSize)) {
[09:28:23.733]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.733]                         on.exit(options(oopts), add = TRUE)
[09:28:23.733]                       }
[09:28:23.733]                       {
[09:28:23.733]                         lapply(seq_along(...future.elements_ii), 
[09:28:23.733]                           FUN = function(jj) {
[09:28:23.733]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.733]                             ...future.FUN(...future.X_jj, ...)
[09:28:23.733]                           })
[09:28:23.733]                       }
[09:28:23.733]                     }, args = future.call.arguments)
[09:28:23.733]                   }
[09:28:23.733]                 }, immediateCondition = function(cond) {
[09:28:23.733]                   save_rds <- function (object, pathname, ...) 
[09:28:23.733]                   {
[09:28:23.733]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:28:23.733]                     if (file_test("-f", pathname_tmp)) {
[09:28:23.733]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.733]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:28:23.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.733]                         fi_tmp[["mtime"]])
[09:28:23.733]                     }
[09:28:23.733]                     tryCatch({
[09:28:23.733]                       saveRDS(object, file = pathname_tmp, ...)
[09:28:23.733]                     }, error = function(ex) {
[09:28:23.733]                       msg <- conditionMessage(ex)
[09:28:23.733]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.733]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:28:23.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.733]                         fi_tmp[["mtime"]], msg)
[09:28:23.733]                       ex$message <- msg
[09:28:23.733]                       stop(ex)
[09:28:23.733]                     })
[09:28:23.733]                     stopifnot(file_test("-f", pathname_tmp))
[09:28:23.733]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:28:23.733]                     if (!res || file_test("-f", pathname_tmp)) {
[09:28:23.733]                       fi_tmp <- file.info(pathname_tmp)
[09:28:23.733]                       fi <- file.info(pathname)
[09:28:23.733]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:28:23.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:28:23.733]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:28:23.733]                         fi[["size"]], fi[["mtime"]])
[09:28:23.733]                       stop(msg)
[09:28:23.733]                     }
[09:28:23.733]                     invisible(pathname)
[09:28:23.733]                   }
[09:28:23.733]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:28:23.733]                     rootPath = tempdir()) 
[09:28:23.733]                   {
[09:28:23.733]                     obj <- list(time = Sys.time(), condition = cond)
[09:28:23.733]                     file <- tempfile(pattern = class(cond)[1], 
[09:28:23.733]                       tmpdir = path, fileext = ".rds")
[09:28:23.733]                     save_rds(obj, file)
[09:28:23.733]                   }
[09:28:23.733]                   saveImmediateCondition(cond, path = "/tmp/Rtmpn4ALVk/.future/immediateConditions")
[09:28:23.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.733]                   {
[09:28:23.733]                     inherits <- base::inherits
[09:28:23.733]                     invokeRestart <- base::invokeRestart
[09:28:23.733]                     is.null <- base::is.null
[09:28:23.733]                     muffled <- FALSE
[09:28:23.733]                     if (inherits(cond, "message")) {
[09:28:23.733]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:23.733]                       if (muffled) 
[09:28:23.733]                         invokeRestart("muffleMessage")
[09:28:23.733]                     }
[09:28:23.733]                     else if (inherits(cond, "warning")) {
[09:28:23.733]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:23.733]                       if (muffled) 
[09:28:23.733]                         invokeRestart("muffleWarning")
[09:28:23.733]                     }
[09:28:23.733]                     else if (inherits(cond, "condition")) {
[09:28:23.733]                       if (!is.null(pattern)) {
[09:28:23.733]                         computeRestarts <- base::computeRestarts
[09:28:23.733]                         grepl <- base::grepl
[09:28:23.733]                         restarts <- computeRestarts(cond)
[09:28:23.733]                         for (restart in restarts) {
[09:28:23.733]                           name <- restart$name
[09:28:23.733]                           if (is.null(name)) 
[09:28:23.733]                             next
[09:28:23.733]                           if (!grepl(pattern, name)) 
[09:28:23.733]                             next
[09:28:23.733]                           invokeRestart(restart)
[09:28:23.733]                           muffled <- TRUE
[09:28:23.733]                           break
[09:28:23.733]                         }
[09:28:23.733]                       }
[09:28:23.733]                     }
[09:28:23.733]                     invisible(muffled)
[09:28:23.733]                   }
[09:28:23.733]                   muffleCondition(cond)
[09:28:23.733]                 })
[09:28:23.733]             }))
[09:28:23.733]             future::FutureResult(value = ...future.value$value, 
[09:28:23.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.733]                   ...future.rng), globalenv = if (FALSE) 
[09:28:23.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:23.733]                     ...future.globalenv.names))
[09:28:23.733]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:23.733]         }, condition = base::local({
[09:28:23.733]             c <- base::c
[09:28:23.733]             inherits <- base::inherits
[09:28:23.733]             invokeRestart <- base::invokeRestart
[09:28:23.733]             length <- base::length
[09:28:23.733]             list <- base::list
[09:28:23.733]             seq.int <- base::seq.int
[09:28:23.733]             signalCondition <- base::signalCondition
[09:28:23.733]             sys.calls <- base::sys.calls
[09:28:23.733]             `[[` <- base::`[[`
[09:28:23.733]             `+` <- base::`+`
[09:28:23.733]             `<<-` <- base::`<<-`
[09:28:23.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:23.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:23.733]                   3L)]
[09:28:23.733]             }
[09:28:23.733]             function(cond) {
[09:28:23.733]                 is_error <- inherits(cond, "error")
[09:28:23.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:23.733]                   NULL)
[09:28:23.733]                 if (is_error) {
[09:28:23.733]                   sessionInformation <- function() {
[09:28:23.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:23.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:23.733]                       search = base::search(), system = base::Sys.info())
[09:28:23.733]                   }
[09:28:23.733]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:23.733]                     cond$call), session = sessionInformation(), 
[09:28:23.733]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:23.733]                   signalCondition(cond)
[09:28:23.733]                 }
[09:28:23.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:23.733]                 "immediateCondition"))) {
[09:28:23.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:23.733]                   ...future.conditions[[length(...future.conditions) + 
[09:28:23.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:23.733]                   if (TRUE && !signal) {
[09:28:23.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.733]                     {
[09:28:23.733]                       inherits <- base::inherits
[09:28:23.733]                       invokeRestart <- base::invokeRestart
[09:28:23.733]                       is.null <- base::is.null
[09:28:23.733]                       muffled <- FALSE
[09:28:23.733]                       if (inherits(cond, "message")) {
[09:28:23.733]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.733]                         if (muffled) 
[09:28:23.733]                           invokeRestart("muffleMessage")
[09:28:23.733]                       }
[09:28:23.733]                       else if (inherits(cond, "warning")) {
[09:28:23.733]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.733]                         if (muffled) 
[09:28:23.733]                           invokeRestart("muffleWarning")
[09:28:23.733]                       }
[09:28:23.733]                       else if (inherits(cond, "condition")) {
[09:28:23.733]                         if (!is.null(pattern)) {
[09:28:23.733]                           computeRestarts <- base::computeRestarts
[09:28:23.733]                           grepl <- base::grepl
[09:28:23.733]                           restarts <- computeRestarts(cond)
[09:28:23.733]                           for (restart in restarts) {
[09:28:23.733]                             name <- restart$name
[09:28:23.733]                             if (is.null(name)) 
[09:28:23.733]                               next
[09:28:23.733]                             if (!grepl(pattern, name)) 
[09:28:23.733]                               next
[09:28:23.733]                             invokeRestart(restart)
[09:28:23.733]                             muffled <- TRUE
[09:28:23.733]                             break
[09:28:23.733]                           }
[09:28:23.733]                         }
[09:28:23.733]                       }
[09:28:23.733]                       invisible(muffled)
[09:28:23.733]                     }
[09:28:23.733]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.733]                   }
[09:28:23.733]                 }
[09:28:23.733]                 else {
[09:28:23.733]                   if (TRUE) {
[09:28:23.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:23.733]                     {
[09:28:23.733]                       inherits <- base::inherits
[09:28:23.733]                       invokeRestart <- base::invokeRestart
[09:28:23.733]                       is.null <- base::is.null
[09:28:23.733]                       muffled <- FALSE
[09:28:23.733]                       if (inherits(cond, "message")) {
[09:28:23.733]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:23.733]                         if (muffled) 
[09:28:23.733]                           invokeRestart("muffleMessage")
[09:28:23.733]                       }
[09:28:23.733]                       else if (inherits(cond, "warning")) {
[09:28:23.733]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:23.733]                         if (muffled) 
[09:28:23.733]                           invokeRestart("muffleWarning")
[09:28:23.733]                       }
[09:28:23.733]                       else if (inherits(cond, "condition")) {
[09:28:23.733]                         if (!is.null(pattern)) {
[09:28:23.733]                           computeRestarts <- base::computeRestarts
[09:28:23.733]                           grepl <- base::grepl
[09:28:23.733]                           restarts <- computeRestarts(cond)
[09:28:23.733]                           for (restart in restarts) {
[09:28:23.733]                             name <- restart$name
[09:28:23.733]                             if (is.null(name)) 
[09:28:23.733]                               next
[09:28:23.733]                             if (!grepl(pattern, name)) 
[09:28:23.733]                               next
[09:28:23.733]                             invokeRestart(restart)
[09:28:23.733]                             muffled <- TRUE
[09:28:23.733]                             break
[09:28:23.733]                           }
[09:28:23.733]                         }
[09:28:23.733]                       }
[09:28:23.733]                       invisible(muffled)
[09:28:23.733]                     }
[09:28:23.733]                     muffleCondition(cond, pattern = "^muffle")
[09:28:23.733]                   }
[09:28:23.733]                 }
[09:28:23.733]             }
[09:28:23.733]         }))
[09:28:23.733]     }, error = function(ex) {
[09:28:23.733]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:23.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:23.733]                 ...future.rng), started = ...future.startTime, 
[09:28:23.733]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:23.733]             version = "1.8"), class = "FutureResult")
[09:28:23.733]     }, finally = {
[09:28:23.733]         if (!identical(...future.workdir, getwd())) 
[09:28:23.733]             setwd(...future.workdir)
[09:28:23.733]         {
[09:28:23.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:23.733]                 ...future.oldOptions$nwarnings <- NULL
[09:28:23.733]             }
[09:28:23.733]             base::options(...future.oldOptions)
[09:28:23.733]             if (.Platform$OS.type == "windows") {
[09:28:23.733]                 old_names <- names(...future.oldEnvVars)
[09:28:23.733]                 envs <- base::Sys.getenv()
[09:28:23.733]                 names <- names(envs)
[09:28:23.733]                 common <- intersect(names, old_names)
[09:28:23.733]                 added <- setdiff(names, old_names)
[09:28:23.733]                 removed <- setdiff(old_names, names)
[09:28:23.733]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:23.733]                   envs[common]]
[09:28:23.733]                 NAMES <- toupper(changed)
[09:28:23.733]                 args <- list()
[09:28:23.733]                 for (kk in seq_along(NAMES)) {
[09:28:23.733]                   name <- changed[[kk]]
[09:28:23.733]                   NAME <- NAMES[[kk]]
[09:28:23.733]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.733]                     next
[09:28:23.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.733]                 }
[09:28:23.733]                 NAMES <- toupper(added)
[09:28:23.733]                 for (kk in seq_along(NAMES)) {
[09:28:23.733]                   name <- added[[kk]]
[09:28:23.733]                   NAME <- NAMES[[kk]]
[09:28:23.733]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.733]                     next
[09:28:23.733]                   args[[name]] <- ""
[09:28:23.733]                 }
[09:28:23.733]                 NAMES <- toupper(removed)
[09:28:23.733]                 for (kk in seq_along(NAMES)) {
[09:28:23.733]                   name <- removed[[kk]]
[09:28:23.733]                   NAME <- NAMES[[kk]]
[09:28:23.733]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:23.733]                     next
[09:28:23.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:23.733]                 }
[09:28:23.733]                 if (length(args) > 0) 
[09:28:23.733]                   base::do.call(base::Sys.setenv, args = args)
[09:28:23.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:23.733]             }
[09:28:23.733]             else {
[09:28:23.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:23.733]             }
[09:28:23.733]             {
[09:28:23.733]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:23.733]                   0L) {
[09:28:23.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:23.733]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:23.733]                   base::options(opts)
[09:28:23.733]                 }
[09:28:23.733]                 {
[09:28:23.733]                   {
[09:28:23.733]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:23.733]                     NULL
[09:28:23.733]                   }
[09:28:23.733]                   options(future.plan = NULL)
[09:28:23.733]                   if (is.na(NA_character_)) 
[09:28:23.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:23.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:23.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:23.733]                     .init = FALSE)
[09:28:23.733]                 }
[09:28:23.733]             }
[09:28:23.733]         }
[09:28:23.733]     })
[09:28:23.733]     if (TRUE) {
[09:28:23.733]         base::sink(type = "output", split = FALSE)
[09:28:23.733]         if (TRUE) {
[09:28:23.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:23.733]         }
[09:28:23.733]         else {
[09:28:23.733]             ...future.result["stdout"] <- base::list(NULL)
[09:28:23.733]         }
[09:28:23.733]         base::close(...future.stdout)
[09:28:23.733]         ...future.stdout <- NULL
[09:28:23.733]     }
[09:28:23.733]     ...future.result$conditions <- ...future.conditions
[09:28:23.733]     ...future.result$finished <- base::Sys.time()
[09:28:23.733]     ...future.result
[09:28:23.733] }
[09:28:23.737] assign_globals() ...
[09:28:23.737] List of 5
[09:28:23.737]  $ ...future.FUN            :function (object, ...)  
[09:28:23.737]  $ future.call.arguments    : list()
[09:28:23.737]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:23.737]  $ ...future.elements_ii    :List of 2
[09:28:23.737]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.737]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[09:28:23.737]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.737]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[09:28:23.737]   ..$ :'data.frame':	18 obs. of  3 variables:
[09:28:23.737]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[09:28:23.737]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[09:28:23.737]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[09:28:23.737]  $ ...future.seeds_ii       : NULL
[09:28:23.737]  $ ...future.globals.maxSize: NULL
[09:28:23.737]  - attr(*, "where")=List of 5
[09:28:23.737]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:28:23.737]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:28:23.737]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:28:23.737]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:28:23.737]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:28:23.737]  - attr(*, "resolved")= logi FALSE
[09:28:23.737]  - attr(*, "total_size")= num 1240
[09:28:23.737]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:23.737]  - attr(*, "already-done")= logi TRUE
[09:28:23.749] - copied ‘...future.FUN’ to environment
[09:28:23.749] - copied ‘future.call.arguments’ to environment
[09:28:23.749] - copied ‘...future.elements_ii’ to environment
[09:28:23.749] - copied ‘...future.seeds_ii’ to environment
[09:28:23.749] - copied ‘...future.globals.maxSize’ to environment
[09:28:23.749] assign_globals() ... done
[09:28:23.749] requestCore(): workers = 2
[09:28:23.752] MulticoreFuture started
[09:28:23.752] - Launch lazy future ... done
[09:28:23.752] run() for ‘MulticoreFuture’ ... done
[09:28:23.753] plan(): Setting new future strategy stack:
[09:28:23.753] Created future:
[09:28:23.753] List of future strategies:
[09:28:23.753] 1. sequential:
[09:28:23.753]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:23.753]    - tweaked: FALSE
[09:28:23.753]    - call: NULL
[09:28:23.755] plan(): nbrOfWorkers() = 1
[09:28:23.760] plan(): Setting new future strategy stack:
[09:28:23.760] List of future strategies:
[09:28:23.760] 1. multicore:
[09:28:23.760]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:28:23.760]    - tweaked: FALSE
[09:28:23.760]    - call: plan(strategy)
[09:28:23.765] plan(): nbrOfWorkers() = 2
[09:28:23.753] MulticoreFuture:
[09:28:23.753] Label: ‘future_by-2’
[09:28:23.753] Expression:
[09:28:23.753] {
[09:28:23.753]     do.call(function(...) {
[09:28:23.753]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:23.753]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:23.753]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:23.753]             on.exit(options(oopts), add = TRUE)
[09:28:23.753]         }
[09:28:23.753]         {
[09:28:23.753]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:23.753]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:23.753]                 ...future.FUN(...future.X_jj, ...)
[09:28:23.753]             })
[09:28:23.753]         }
[09:28:23.753]     }, args = future.call.arguments)
[09:28:23.753] }
[09:28:23.753] Lazy evaluation: FALSE
[09:28:23.753] Asynchronous evaluation: TRUE
[09:28:23.753] Local evaluation: TRUE
[09:28:23.753] Environment: 0x555b0858ca08
[09:28:23.753] Capture standard output: TRUE
[09:28:23.753] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:23.753] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:23.753] Packages: <none>
[09:28:23.753] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:23.753] Resolved: TRUE
[09:28:23.753] Value: <not collected>
[09:28:23.753] Conditions captured: <none>
[09:28:23.753] Early signaling: FALSE
[09:28:23.753] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:23.753] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:23.766] Chunk #2 of 2 ... DONE
[09:28:23.767] Launching 2 futures (chunks) ... DONE
[09:28:23.767] Resolving 2 futures (chunks) ...
[09:28:23.767] resolve() on list ...
[09:28:23.767]  recursive: 0
[09:28:23.767]  length: 2
[09:28:23.767] 
[09:28:23.768] Future #1
[09:28:23.768] result() for MulticoreFuture ...
[09:28:23.769] result() for MulticoreFuture ...
[09:28:23.769] result() for MulticoreFuture ... done
[09:28:23.769] result() for MulticoreFuture ... done
[09:28:23.769] result() for MulticoreFuture ...
[09:28:23.769] result() for MulticoreFuture ... done
[09:28:23.770] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:28:23.770] - nx: 2
[09:28:23.770] - relay: TRUE
[09:28:23.770] - stdout: TRUE
[09:28:23.770] - signal: TRUE
[09:28:23.770] - resignal: FALSE
[09:28:23.770] - force: TRUE
[09:28:23.770] - relayed: [n=2] FALSE, FALSE
[09:28:23.771] - queued futures: [n=2] FALSE, FALSE
[09:28:23.771]  - until=1
[09:28:23.771]  - relaying element #1
[09:28:23.771] result() for MulticoreFuture ...
[09:28:23.771] result() for MulticoreFuture ... done
[09:28:23.771] result() for MulticoreFuture ...
[09:28:23.772] result() for MulticoreFuture ... done
[09:28:23.772] result() for MulticoreFuture ...
[09:28:23.772] result() for MulticoreFuture ... done
[09:28:23.772] result() for MulticoreFuture ...
[09:28:23.772] result() for MulticoreFuture ... done
[09:28:23.772] - relayed: [n=2] TRUE, FALSE
[09:28:23.773] - queued futures: [n=2] TRUE, FALSE
[09:28:23.773] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:28:23.773]  length: 1 (resolved future 1)
[09:28:23.773] Future #2
[09:28:23.773] result() for MulticoreFuture ...
[09:28:23.774] result() for MulticoreFuture ...
[09:28:23.774] result() for MulticoreFuture ... done
[09:28:23.774] result() for MulticoreFuture ... done
[09:28:23.774] result() for MulticoreFuture ...
[09:28:23.774] result() for MulticoreFuture ... done
[09:28:23.775] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:28:23.775] - nx: 2
[09:28:23.775] - relay: TRUE
[09:28:23.775] - stdout: TRUE
[09:28:23.775] - signal: TRUE
[09:28:23.775] - resignal: FALSE
[09:28:23.775] - force: TRUE
[09:28:23.775] - relayed: [n=2] TRUE, FALSE
[09:28:23.776] - queued futures: [n=2] TRUE, FALSE
[09:28:23.776]  - until=2
[09:28:23.776]  - relaying element #2
[09:28:23.776] result() for MulticoreFuture ...
[09:28:23.776] result() for MulticoreFuture ... done
[09:28:23.776] result() for MulticoreFuture ...
[09:28:23.776] result() for MulticoreFuture ... done
[09:28:23.776] result() for MulticoreFuture ...
[09:28:23.777] result() for MulticoreFuture ... done
[09:28:23.777] result() for MulticoreFuture ...
[09:28:23.777] result() for MulticoreFuture ... done
[09:28:23.777] - relayed: [n=2] TRUE, TRUE
[09:28:23.777] - queued futures: [n=2] TRUE, TRUE
[09:28:23.777] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:28:23.777]  length: 0 (resolved future 2)
[09:28:23.777] Relaying remaining futures
[09:28:23.777] signalConditionsASAP(NULL, pos=0) ...
[09:28:23.777] - nx: 2
[09:28:23.778] - relay: TRUE
[09:28:23.778] - stdout: TRUE
[09:28:23.778] - signal: TRUE
[09:28:23.778] - resignal: FALSE
[09:28:23.778] - force: TRUE
[09:28:23.778] - relayed: [n=2] TRUE, TRUE
[09:28:23.778] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:23.778] - relayed: [n=2] TRUE, TRUE
[09:28:23.779] - queued futures: [n=2] TRUE, TRUE
[09:28:23.779] signalConditionsASAP(NULL, pos=0) ... done
[09:28:23.779] resolve() on list ... DONE
[09:28:23.779] result() for MulticoreFuture ...
[09:28:23.779] result() for MulticoreFuture ... done
[09:28:23.779] result() for MulticoreFuture ...
[09:28:23.779] result() for MulticoreFuture ... done
[09:28:23.779] result() for MulticoreFuture ...
[09:28:23.779] result() for MulticoreFuture ... done
[09:28:23.780] result() for MulticoreFuture ...
[09:28:23.780] result() for MulticoreFuture ... done
[09:28:23.780]  - Number of value chunks collected: 2
[09:28:23.780] Resolving 2 futures (chunks) ... DONE
[09:28:23.780] Reducing values from 2 chunks ...
[09:28:23.780]  - Number of values collected after concatenation: 3
[09:28:23.780]  - Number of values expected: 3
[09:28:23.780] Reducing values from 2 chunks ... DONE
[09:28:23.780] future_lapply() ... DONE
[09:28:23.781] future_by_internal() ... DONE
[09:28:23.782] future_by_internal() ...
- plan('multisession') ...
[09:28:23.782] plan(): Setting new future strategy stack:
[09:28:23.782] List of future strategies:
[09:28:23.782] 1. multisession:
[09:28:23.782]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:23.782]    - tweaked: FALSE
[09:28:23.782]    - call: plan(strategy)
[09:28:23.786] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:28:23.786] multisession:
[09:28:23.786] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:28:23.786] - tweaked: FALSE
[09:28:23.786] - call: plan(strategy)
[09:28:23.792] getGlobalsAndPackages() ...
[09:28:23.793] Not searching for globals
[09:28:23.793] - globals: [0] <none>
[09:28:23.793] getGlobalsAndPackages() ... DONE
[09:28:23.793] [local output] makeClusterPSOCK() ...
[09:28:23.839] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:28:23.840] [local output] Base port: 11346
[09:28:23.840] [local output] Getting setup options for 2 cluster nodes ...
[09:28:23.841] [local output]  - Node 1 of 2 ...
[09:28:23.841] [local output] localMachine=TRUE => revtunnel=FALSE

[09:28:23.842] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpn4ALVk/worker.rank=1.parallelly.parent=28740.70441632a937.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpn4ALVk/worker.rank=1.parallelly.parent=28740.70441632a937.pid")'’
[09:28:24.029] - Possible to infer worker's PID: TRUE
[09:28:24.029] [local output] Rscript port: 11346

[09:28:24.030] [local output]  - Node 2 of 2 ...
[09:28:24.030] [local output] localMachine=TRUE => revtunnel=FALSE

[09:28:24.031] [local output] Rscript port: 11346

[09:28:24.031] [local output] Getting setup options for 2 cluster nodes ... done
[09:28:24.031] [local output]  - Parallel setup requested for some PSOCK nodes
[09:28:24.031] [local output] Setting up PSOCK nodes in parallel
[09:28:24.032] List of 36
[09:28:24.032]  $ worker          : chr "localhost"
[09:28:24.032]   ..- attr(*, "localhost")= logi TRUE
[09:28:24.032]  $ master          : chr "localhost"
[09:28:24.032]  $ port            : int 11346
[09:28:24.032]  $ connectTimeout  : num 120
[09:28:24.032]  $ timeout         : num 2592000
[09:28:24.032]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:28:24.032]  $ homogeneous     : logi TRUE
[09:28:24.032]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:28:24.032]  $ rscript_envs    : NULL
[09:28:24.032]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:28:24.032]  $ rscript_startup : NULL
[09:28:24.032]  $ rscript_sh      : chr "sh"
[09:28:24.032]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:28:24.032]  $ methods         : logi TRUE
[09:28:24.032]  $ socketOptions   : chr "no-delay"
[09:28:24.032]  $ useXDR          : logi FALSE
[09:28:24.032]  $ outfile         : chr "/dev/null"
[09:28:24.032]  $ renice          : int NA
[09:28:24.032]  $ rshcmd          : NULL
[09:28:24.032]  $ user            : chr(0) 
[09:28:24.032]  $ revtunnel       : logi FALSE
[09:28:24.032]  $ rshlogfile      : NULL
[09:28:24.032]  $ rshopts         : chr(0) 
[09:28:24.032]  $ rank            : int 1
[09:28:24.032]  $ manual          : logi FALSE
[09:28:24.032]  $ dryrun          : logi FALSE
[09:28:24.032]  $ quiet           : logi FALSE
[09:28:24.032]  $ setup_strategy  : chr "parallel"
[09:28:24.032]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:28:24.032]  $ pidfile         : chr "/tmp/Rtmpn4ALVk/worker.rank=1.parallelly.parent=28740.70441632a937.pid"
[09:28:24.032]  $ rshcmd_label    : NULL
[09:28:24.032]  $ rsh_call        : NULL
[09:28:24.032]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:28:24.032]  $ localMachine    : logi TRUE
[09:28:24.032]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:28:24.032]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:28:24.032]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:28:24.032]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:28:24.032]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:28:24.032]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:28:24.032]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:28:24.032]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:28:24.032]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:28:24.032]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:28:24.032]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:28:24.032]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:28:24.032]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:28:24.032]  $ arguments       :List of 28
[09:28:24.032]   ..$ worker          : chr "localhost"
[09:28:24.032]   ..$ master          : NULL
[09:28:24.032]   ..$ port            : int 11346
[09:28:24.032]   ..$ connectTimeout  : num 120
[09:28:24.032]   ..$ timeout         : num 2592000
[09:28:24.032]   ..$ rscript         : NULL
[09:28:24.032]   ..$ homogeneous     : NULL
[09:28:24.032]   ..$ rscript_args    : NULL
[09:28:24.032]   ..$ rscript_envs    : NULL
[09:28:24.032]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:28:24.032]   ..$ rscript_startup : NULL
[09:28:24.032]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:28:24.032]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:28:24.032]   ..$ methods         : logi TRUE
[09:28:24.032]   ..$ socketOptions   : chr "no-delay"
[09:28:24.032]   ..$ useXDR          : logi FALSE
[09:28:24.032]   ..$ outfile         : chr "/dev/null"
[09:28:24.032]   ..$ renice          : int NA
[09:28:24.032]   ..$ rshcmd          : NULL
[09:28:24.032]   ..$ user            : NULL
[09:28:24.032]   ..$ revtunnel       : logi NA
[09:28:24.032]   ..$ rshlogfile      : NULL
[09:28:24.032]   ..$ rshopts         : NULL
[09:28:24.032]   ..$ rank            : int 1
[09:28:24.032]   ..$ manual          : logi FALSE
[09:28:24.032]   ..$ dryrun          : logi FALSE
[09:28:24.032]   ..$ quiet           : logi FALSE
[09:28:24.032]   ..$ setup_strategy  : chr "parallel"
[09:28:24.032]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:28:24.048] [local output] System call to launch all workers:
[09:28:24.048] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpn4ALVk/worker.rank=1.parallelly.parent=28740.70441632a937.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11346 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:28:24.048] [local output] Starting PSOCK main server
[09:28:24.054] [local output] Workers launched
[09:28:24.054] [local output] Waiting for workers to connect back
[09:28:24.054]  - [local output] 0 workers out of 2 ready
[09:28:24.297]  - [local output] 0 workers out of 2 ready
[09:28:24.298]  - [local output] 1 workers out of 2 ready
[09:28:24.298]  - [local output] 2 workers out of 2 ready
[09:28:24.298] [local output] Launching of workers completed
[09:28:24.298] [local output] Collecting session information from workers
[09:28:24.299] [local output]  - Worker #1 of 2
[09:28:24.300] [local output]  - Worker #2 of 2
[09:28:24.300] [local output] makeClusterPSOCK() ... done
[09:28:24.311] Packages needed by the future expression (n = 0): <none>
[09:28:24.312] Packages needed by future strategies (n = 0): <none>
[09:28:24.312] {
[09:28:24.312]     {
[09:28:24.312]         {
[09:28:24.312]             ...future.startTime <- base::Sys.time()
[09:28:24.312]             {
[09:28:24.312]                 {
[09:28:24.312]                   {
[09:28:24.312]                     {
[09:28:24.312]                       base::local({
[09:28:24.312]                         has_future <- base::requireNamespace("future", 
[09:28:24.312]                           quietly = TRUE)
[09:28:24.312]                         if (has_future) {
[09:28:24.312]                           ns <- base::getNamespace("future")
[09:28:24.312]                           version <- ns[[".package"]][["version"]]
[09:28:24.312]                           if (is.null(version)) 
[09:28:24.312]                             version <- utils::packageVersion("future")
[09:28:24.312]                         }
[09:28:24.312]                         else {
[09:28:24.312]                           version <- NULL
[09:28:24.312]                         }
[09:28:24.312]                         if (!has_future || version < "1.8.0") {
[09:28:24.312]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:24.312]                             "", base::R.version$version.string), 
[09:28:24.312]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:24.312]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:24.312]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:24.312]                               "release", "version")], collapse = " "), 
[09:28:24.312]                             hostname = base::Sys.info()[["nodename"]])
[09:28:24.312]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:24.312]                             info)
[09:28:24.312]                           info <- base::paste(info, collapse = "; ")
[09:28:24.312]                           if (!has_future) {
[09:28:24.312]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:24.312]                               info)
[09:28:24.312]                           }
[09:28:24.312]                           else {
[09:28:24.312]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:24.312]                               info, version)
[09:28:24.312]                           }
[09:28:24.312]                           base::stop(msg)
[09:28:24.312]                         }
[09:28:24.312]                       })
[09:28:24.312]                     }
[09:28:24.312]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:24.312]                     base::options(mc.cores = 1L)
[09:28:24.312]                   }
[09:28:24.312]                   ...future.strategy.old <- future::plan("list")
[09:28:24.312]                   options(future.plan = NULL)
[09:28:24.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:24.312]                 }
[09:28:24.312]                 ...future.workdir <- getwd()
[09:28:24.312]             }
[09:28:24.312]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:24.312]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:24.312]         }
[09:28:24.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:24.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:28:24.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:24.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:24.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:24.312]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:24.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:24.312]             base::names(...future.oldOptions))
[09:28:24.312]     }
[09:28:24.312]     if (FALSE) {
[09:28:24.312]     }
[09:28:24.312]     else {
[09:28:24.312]         if (TRUE) {
[09:28:24.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:24.312]                 open = "w")
[09:28:24.312]         }
[09:28:24.312]         else {
[09:28:24.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:24.312]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:24.312]         }
[09:28:24.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:24.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:24.312]             base::sink(type = "output", split = FALSE)
[09:28:24.312]             base::close(...future.stdout)
[09:28:24.312]         }, add = TRUE)
[09:28:24.312]     }
[09:28:24.312]     ...future.frame <- base::sys.nframe()
[09:28:24.312]     ...future.conditions <- base::list()
[09:28:24.312]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:24.312]     if (FALSE) {
[09:28:24.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:24.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:24.312]     }
[09:28:24.312]     ...future.result <- base::tryCatch({
[09:28:24.312]         base::withCallingHandlers({
[09:28:24.312]             ...future.value <- base::withVisible(base::local({
[09:28:24.312]                 ...future.makeSendCondition <- base::local({
[09:28:24.312]                   sendCondition <- NULL
[09:28:24.312]                   function(frame = 1L) {
[09:28:24.312]                     if (is.function(sendCondition)) 
[09:28:24.312]                       return(sendCondition)
[09:28:24.312]                     ns <- getNamespace("parallel")
[09:28:24.312]                     if (exists("sendData", mode = "function", 
[09:28:24.312]                       envir = ns)) {
[09:28:24.312]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:24.312]                         envir = ns)
[09:28:24.312]                       envir <- sys.frame(frame)
[09:28:24.312]                       master <- NULL
[09:28:24.312]                       while (!identical(envir, .GlobalEnv) && 
[09:28:24.312]                         !identical(envir, emptyenv())) {
[09:28:24.312]                         if (exists("master", mode = "list", envir = envir, 
[09:28:24.312]                           inherits = FALSE)) {
[09:28:24.312]                           master <- get("master", mode = "list", 
[09:28:24.312]                             envir = envir, inherits = FALSE)
[09:28:24.312]                           if (inherits(master, c("SOCKnode", 
[09:28:24.312]                             "SOCK0node"))) {
[09:28:24.312]                             sendCondition <<- function(cond) {
[09:28:24.312]                               data <- list(type = "VALUE", value = cond, 
[09:28:24.312]                                 success = TRUE)
[09:28:24.312]                               parallel_sendData(master, data)
[09:28:24.312]                             }
[09:28:24.312]                             return(sendCondition)
[09:28:24.312]                           }
[09:28:24.312]                         }
[09:28:24.312]                         frame <- frame + 1L
[09:28:24.312]                         envir <- sys.frame(frame)
[09:28:24.312]                       }
[09:28:24.312]                     }
[09:28:24.312]                     sendCondition <<- function(cond) NULL
[09:28:24.312]                   }
[09:28:24.312]                 })
[09:28:24.312]                 withCallingHandlers({
[09:28:24.312]                   NA
[09:28:24.312]                 }, immediateCondition = function(cond) {
[09:28:24.312]                   sendCondition <- ...future.makeSendCondition()
[09:28:24.312]                   sendCondition(cond)
[09:28:24.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.312]                   {
[09:28:24.312]                     inherits <- base::inherits
[09:28:24.312]                     invokeRestart <- base::invokeRestart
[09:28:24.312]                     is.null <- base::is.null
[09:28:24.312]                     muffled <- FALSE
[09:28:24.312]                     if (inherits(cond, "message")) {
[09:28:24.312]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:24.312]                       if (muffled) 
[09:28:24.312]                         invokeRestart("muffleMessage")
[09:28:24.312]                     }
[09:28:24.312]                     else if (inherits(cond, "warning")) {
[09:28:24.312]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:24.312]                       if (muffled) 
[09:28:24.312]                         invokeRestart("muffleWarning")
[09:28:24.312]                     }
[09:28:24.312]                     else if (inherits(cond, "condition")) {
[09:28:24.312]                       if (!is.null(pattern)) {
[09:28:24.312]                         computeRestarts <- base::computeRestarts
[09:28:24.312]                         grepl <- base::grepl
[09:28:24.312]                         restarts <- computeRestarts(cond)
[09:28:24.312]                         for (restart in restarts) {
[09:28:24.312]                           name <- restart$name
[09:28:24.312]                           if (is.null(name)) 
[09:28:24.312]                             next
[09:28:24.312]                           if (!grepl(pattern, name)) 
[09:28:24.312]                             next
[09:28:24.312]                           invokeRestart(restart)
[09:28:24.312]                           muffled <- TRUE
[09:28:24.312]                           break
[09:28:24.312]                         }
[09:28:24.312]                       }
[09:28:24.312]                     }
[09:28:24.312]                     invisible(muffled)
[09:28:24.312]                   }
[09:28:24.312]                   muffleCondition(cond)
[09:28:24.312]                 })
[09:28:24.312]             }))
[09:28:24.312]             future::FutureResult(value = ...future.value$value, 
[09:28:24.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.312]                   ...future.rng), globalenv = if (FALSE) 
[09:28:24.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:24.312]                     ...future.globalenv.names))
[09:28:24.312]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:24.312]         }, condition = base::local({
[09:28:24.312]             c <- base::c
[09:28:24.312]             inherits <- base::inherits
[09:28:24.312]             invokeRestart <- base::invokeRestart
[09:28:24.312]             length <- base::length
[09:28:24.312]             list <- base::list
[09:28:24.312]             seq.int <- base::seq.int
[09:28:24.312]             signalCondition <- base::signalCondition
[09:28:24.312]             sys.calls <- base::sys.calls
[09:28:24.312]             `[[` <- base::`[[`
[09:28:24.312]             `+` <- base::`+`
[09:28:24.312]             `<<-` <- base::`<<-`
[09:28:24.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:24.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:24.312]                   3L)]
[09:28:24.312]             }
[09:28:24.312]             function(cond) {
[09:28:24.312]                 is_error <- inherits(cond, "error")
[09:28:24.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:24.312]                   NULL)
[09:28:24.312]                 if (is_error) {
[09:28:24.312]                   sessionInformation <- function() {
[09:28:24.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:24.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:24.312]                       search = base::search(), system = base::Sys.info())
[09:28:24.312]                   }
[09:28:24.312]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:24.312]                     cond$call), session = sessionInformation(), 
[09:28:24.312]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:24.312]                   signalCondition(cond)
[09:28:24.312]                 }
[09:28:24.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:24.312]                 "immediateCondition"))) {
[09:28:24.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:24.312]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:24.312]                   if (TRUE && !signal) {
[09:28:24.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.312]                     {
[09:28:24.312]                       inherits <- base::inherits
[09:28:24.312]                       invokeRestart <- base::invokeRestart
[09:28:24.312]                       is.null <- base::is.null
[09:28:24.312]                       muffled <- FALSE
[09:28:24.312]                       if (inherits(cond, "message")) {
[09:28:24.312]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.312]                         if (muffled) 
[09:28:24.312]                           invokeRestart("muffleMessage")
[09:28:24.312]                       }
[09:28:24.312]                       else if (inherits(cond, "warning")) {
[09:28:24.312]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.312]                         if (muffled) 
[09:28:24.312]                           invokeRestart("muffleWarning")
[09:28:24.312]                       }
[09:28:24.312]                       else if (inherits(cond, "condition")) {
[09:28:24.312]                         if (!is.null(pattern)) {
[09:28:24.312]                           computeRestarts <- base::computeRestarts
[09:28:24.312]                           grepl <- base::grepl
[09:28:24.312]                           restarts <- computeRestarts(cond)
[09:28:24.312]                           for (restart in restarts) {
[09:28:24.312]                             name <- restart$name
[09:28:24.312]                             if (is.null(name)) 
[09:28:24.312]                               next
[09:28:24.312]                             if (!grepl(pattern, name)) 
[09:28:24.312]                               next
[09:28:24.312]                             invokeRestart(restart)
[09:28:24.312]                             muffled <- TRUE
[09:28:24.312]                             break
[09:28:24.312]                           }
[09:28:24.312]                         }
[09:28:24.312]                       }
[09:28:24.312]                       invisible(muffled)
[09:28:24.312]                     }
[09:28:24.312]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.312]                   }
[09:28:24.312]                 }
[09:28:24.312]                 else {
[09:28:24.312]                   if (TRUE) {
[09:28:24.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.312]                     {
[09:28:24.312]                       inherits <- base::inherits
[09:28:24.312]                       invokeRestart <- base::invokeRestart
[09:28:24.312]                       is.null <- base::is.null
[09:28:24.312]                       muffled <- FALSE
[09:28:24.312]                       if (inherits(cond, "message")) {
[09:28:24.312]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.312]                         if (muffled) 
[09:28:24.312]                           invokeRestart("muffleMessage")
[09:28:24.312]                       }
[09:28:24.312]                       else if (inherits(cond, "warning")) {
[09:28:24.312]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.312]                         if (muffled) 
[09:28:24.312]                           invokeRestart("muffleWarning")
[09:28:24.312]                       }
[09:28:24.312]                       else if (inherits(cond, "condition")) {
[09:28:24.312]                         if (!is.null(pattern)) {
[09:28:24.312]                           computeRestarts <- base::computeRestarts
[09:28:24.312]                           grepl <- base::grepl
[09:28:24.312]                           restarts <- computeRestarts(cond)
[09:28:24.312]                           for (restart in restarts) {
[09:28:24.312]                             name <- restart$name
[09:28:24.312]                             if (is.null(name)) 
[09:28:24.312]                               next
[09:28:24.312]                             if (!grepl(pattern, name)) 
[09:28:24.312]                               next
[09:28:24.312]                             invokeRestart(restart)
[09:28:24.312]                             muffled <- TRUE
[09:28:24.312]                             break
[09:28:24.312]                           }
[09:28:24.312]                         }
[09:28:24.312]                       }
[09:28:24.312]                       invisible(muffled)
[09:28:24.312]                     }
[09:28:24.312]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.312]                   }
[09:28:24.312]                 }
[09:28:24.312]             }
[09:28:24.312]         }))
[09:28:24.312]     }, error = function(ex) {
[09:28:24.312]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:24.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.312]                 ...future.rng), started = ...future.startTime, 
[09:28:24.312]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:24.312]             version = "1.8"), class = "FutureResult")
[09:28:24.312]     }, finally = {
[09:28:24.312]         if (!identical(...future.workdir, getwd())) 
[09:28:24.312]             setwd(...future.workdir)
[09:28:24.312]         {
[09:28:24.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:24.312]                 ...future.oldOptions$nwarnings <- NULL
[09:28:24.312]             }
[09:28:24.312]             base::options(...future.oldOptions)
[09:28:24.312]             if (.Platform$OS.type == "windows") {
[09:28:24.312]                 old_names <- names(...future.oldEnvVars)
[09:28:24.312]                 envs <- base::Sys.getenv()
[09:28:24.312]                 names <- names(envs)
[09:28:24.312]                 common <- intersect(names, old_names)
[09:28:24.312]                 added <- setdiff(names, old_names)
[09:28:24.312]                 removed <- setdiff(old_names, names)
[09:28:24.312]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:24.312]                   envs[common]]
[09:28:24.312]                 NAMES <- toupper(changed)
[09:28:24.312]                 args <- list()
[09:28:24.312]                 for (kk in seq_along(NAMES)) {
[09:28:24.312]                   name <- changed[[kk]]
[09:28:24.312]                   NAME <- NAMES[[kk]]
[09:28:24.312]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.312]                     next
[09:28:24.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.312]                 }
[09:28:24.312]                 NAMES <- toupper(added)
[09:28:24.312]                 for (kk in seq_along(NAMES)) {
[09:28:24.312]                   name <- added[[kk]]
[09:28:24.312]                   NAME <- NAMES[[kk]]
[09:28:24.312]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.312]                     next
[09:28:24.312]                   args[[name]] <- ""
[09:28:24.312]                 }
[09:28:24.312]                 NAMES <- toupper(removed)
[09:28:24.312]                 for (kk in seq_along(NAMES)) {
[09:28:24.312]                   name <- removed[[kk]]
[09:28:24.312]                   NAME <- NAMES[[kk]]
[09:28:24.312]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.312]                     next
[09:28:24.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.312]                 }
[09:28:24.312]                 if (length(args) > 0) 
[09:28:24.312]                   base::do.call(base::Sys.setenv, args = args)
[09:28:24.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:24.312]             }
[09:28:24.312]             else {
[09:28:24.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:24.312]             }
[09:28:24.312]             {
[09:28:24.312]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:24.312]                   0L) {
[09:28:24.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:24.312]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:24.312]                   base::options(opts)
[09:28:24.312]                 }
[09:28:24.312]                 {
[09:28:24.312]                   {
[09:28:24.312]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:24.312]                     NULL
[09:28:24.312]                   }
[09:28:24.312]                   options(future.plan = NULL)
[09:28:24.312]                   if (is.na(NA_character_)) 
[09:28:24.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:24.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:24.312]                     .init = FALSE)
[09:28:24.312]                 }
[09:28:24.312]             }
[09:28:24.312]         }
[09:28:24.312]     })
[09:28:24.312]     if (TRUE) {
[09:28:24.312]         base::sink(type = "output", split = FALSE)
[09:28:24.312]         if (TRUE) {
[09:28:24.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:24.312]         }
[09:28:24.312]         else {
[09:28:24.312]             ...future.result["stdout"] <- base::list(NULL)
[09:28:24.312]         }
[09:28:24.312]         base::close(...future.stdout)
[09:28:24.312]         ...future.stdout <- NULL
[09:28:24.312]     }
[09:28:24.312]     ...future.result$conditions <- ...future.conditions
[09:28:24.312]     ...future.result$finished <- base::Sys.time()
[09:28:24.312]     ...future.result
[09:28:24.312] }
[09:28:24.363] MultisessionFuture started
[09:28:24.363] result() for ClusterFuture ...
[09:28:24.364] receiveMessageFromWorker() for ClusterFuture ...
[09:28:24.365] - Validating connection of MultisessionFuture
[09:28:24.395] - received message: FutureResult
[09:28:24.395] - Received FutureResult
[09:28:24.396] - Erased future from FutureRegistry
[09:28:24.396] result() for ClusterFuture ...
[09:28:24.396] - result already collected: FutureResult
[09:28:24.396] result() for ClusterFuture ... done
[09:28:24.396] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:24.396] result() for ClusterFuture ... done
[09:28:24.396] result() for ClusterFuture ...
[09:28:24.396] - result already collected: FutureResult
[09:28:24.397] result() for ClusterFuture ... done
[09:28:24.397] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:28:24.400] plan(): nbrOfWorkers() = 2
[09:28:24.401] future_by_internal() ...
[09:28:24.401] future_lapply() ...
[09:28:24.405] Number of chunks: 2
[09:28:24.405] getGlobalsAndPackagesXApply() ...
[09:28:24.406]  - future.globals: TRUE
[09:28:24.406] getGlobalsAndPackages() ...
[09:28:24.406] Searching for globals...
[09:28:24.407] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:24.407] Searching for globals ... DONE
[09:28:24.407] Resolving globals: FALSE
[09:28:24.408] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:24.408] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:24.408] - globals: [1] ‘FUN’
[09:28:24.408] 
[09:28:24.409] getGlobalsAndPackages() ... DONE
[09:28:24.409]  - globals found/used: [n=1] ‘FUN’
[09:28:24.409]  - needed namespaces: [n=0] 
[09:28:24.409] Finding globals ... DONE
[09:28:24.409]  - use_args: TRUE
[09:28:24.409]  - Getting '...' globals ...
[09:28:24.409] resolve() on list ...
[09:28:24.410]  recursive: 0
[09:28:24.410]  length: 1
[09:28:24.410]  elements: ‘...’
[09:28:24.410]  length: 0 (resolved future 1)
[09:28:24.410] resolve() on list ... DONE
[09:28:24.410]    - '...' content: [n=0] 
[09:28:24.410] List of 1
[09:28:24.410]  $ ...: list()
[09:28:24.410]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:24.410]  - attr(*, "where")=List of 1
[09:28:24.410]   ..$ ...:<environment: 0x555b0b9e9470> 
[09:28:24.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:24.410]  - attr(*, "resolved")= logi TRUE
[09:28:24.410]  - attr(*, "total_size")= num NA
[09:28:24.413]  - Getting '...' globals ... DONE
[09:28:24.414] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:24.414] List of 2
[09:28:24.414]  $ ...future.FUN:function (object, ...)  
[09:28:24.414]  $ ...          : list()
[09:28:24.414]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:24.414]  - attr(*, "where")=List of 2
[09:28:24.414]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:24.414]   ..$ ...          :<environment: 0x555b0b9e9470> 
[09:28:24.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:24.414]  - attr(*, "resolved")= logi FALSE
[09:28:24.414]  - attr(*, "total_size")= num 1240
[09:28:24.417] Packages to be attached in all futures: [n=0] 
[09:28:24.417] getGlobalsAndPackagesXApply() ... DONE
[09:28:24.417] Number of futures (= number of chunks): 2
[09:28:24.417] Launching 2 futures (chunks) ...
[09:28:24.418] Chunk #1 of 2 ...
[09:28:24.418]  - Finding globals in 'X' for chunk #1 ...
[09:28:24.418] getGlobalsAndPackages() ...
[09:28:24.418] Searching for globals...
[09:28:24.418] 
[09:28:24.419] Searching for globals ... DONE
[09:28:24.419] - globals: [0] <none>
[09:28:24.419] getGlobalsAndPackages() ... DONE
[09:28:24.419]    + additional globals found: [n=0] 
[09:28:24.419]    + additional namespaces needed: [n=0] 
[09:28:24.419]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:24.419]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:24.419]  - seeds: <none>
[09:28:24.419]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.420] getGlobalsAndPackages() ...
[09:28:24.420] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.420] Resolving globals: FALSE
[09:28:24.420] Tweak future expression to call with '...' arguments ...
[09:28:24.420] {
[09:28:24.420]     do.call(function(...) {
[09:28:24.420]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.420]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.420]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.420]             on.exit(options(oopts), add = TRUE)
[09:28:24.420]         }
[09:28:24.420]         {
[09:28:24.420]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.420]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.420]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.420]             })
[09:28:24.420]         }
[09:28:24.420]     }, args = future.call.arguments)
[09:28:24.420] }
[09:28:24.420] Tweak future expression to call with '...' arguments ... DONE
[09:28:24.421] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.421] 
[09:28:24.421] getGlobalsAndPackages() ... DONE
[09:28:24.421] run() for ‘Future’ ...
[09:28:24.422] - state: ‘created’
[09:28:24.422] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:24.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:24.437]   - Field: ‘node’
[09:28:24.437]   - Field: ‘label’
[09:28:24.437]   - Field: ‘local’
[09:28:24.437]   - Field: ‘owner’
[09:28:24.437]   - Field: ‘envir’
[09:28:24.437]   - Field: ‘workers’
[09:28:24.437]   - Field: ‘packages’
[09:28:24.437]   - Field: ‘gc’
[09:28:24.437]   - Field: ‘conditions’
[09:28:24.437]   - Field: ‘persistent’
[09:28:24.438]   - Field: ‘expr’
[09:28:24.438]   - Field: ‘uuid’
[09:28:24.438]   - Field: ‘seed’
[09:28:24.438]   - Field: ‘version’
[09:28:24.438]   - Field: ‘result’
[09:28:24.438]   - Field: ‘asynchronous’
[09:28:24.438]   - Field: ‘calls’
[09:28:24.438]   - Field: ‘globals’
[09:28:24.438]   - Field: ‘stdout’
[09:28:24.439]   - Field: ‘earlySignal’
[09:28:24.439]   - Field: ‘lazy’
[09:28:24.439]   - Field: ‘state’
[09:28:24.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:24.439] - Launch lazy future ...
[09:28:24.439] Packages needed by the future expression (n = 0): <none>
[09:28:24.439] Packages needed by future strategies (n = 0): <none>
[09:28:24.440] {
[09:28:24.440]     {
[09:28:24.440]         {
[09:28:24.440]             ...future.startTime <- base::Sys.time()
[09:28:24.440]             {
[09:28:24.440]                 {
[09:28:24.440]                   {
[09:28:24.440]                     {
[09:28:24.440]                       base::local({
[09:28:24.440]                         has_future <- base::requireNamespace("future", 
[09:28:24.440]                           quietly = TRUE)
[09:28:24.440]                         if (has_future) {
[09:28:24.440]                           ns <- base::getNamespace("future")
[09:28:24.440]                           version <- ns[[".package"]][["version"]]
[09:28:24.440]                           if (is.null(version)) 
[09:28:24.440]                             version <- utils::packageVersion("future")
[09:28:24.440]                         }
[09:28:24.440]                         else {
[09:28:24.440]                           version <- NULL
[09:28:24.440]                         }
[09:28:24.440]                         if (!has_future || version < "1.8.0") {
[09:28:24.440]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:24.440]                             "", base::R.version$version.string), 
[09:28:24.440]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:24.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:24.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:24.440]                               "release", "version")], collapse = " "), 
[09:28:24.440]                             hostname = base::Sys.info()[["nodename"]])
[09:28:24.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:24.440]                             info)
[09:28:24.440]                           info <- base::paste(info, collapse = "; ")
[09:28:24.440]                           if (!has_future) {
[09:28:24.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:24.440]                               info)
[09:28:24.440]                           }
[09:28:24.440]                           else {
[09:28:24.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:24.440]                               info, version)
[09:28:24.440]                           }
[09:28:24.440]                           base::stop(msg)
[09:28:24.440]                         }
[09:28:24.440]                       })
[09:28:24.440]                     }
[09:28:24.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:24.440]                     base::options(mc.cores = 1L)
[09:28:24.440]                   }
[09:28:24.440]                   ...future.strategy.old <- future::plan("list")
[09:28:24.440]                   options(future.plan = NULL)
[09:28:24.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:24.440]                 }
[09:28:24.440]                 ...future.workdir <- getwd()
[09:28:24.440]             }
[09:28:24.440]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:24.440]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:24.440]         }
[09:28:24.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:24.440]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:24.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:24.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:24.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:24.440]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:24.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:24.440]             base::names(...future.oldOptions))
[09:28:24.440]     }
[09:28:24.440]     if (FALSE) {
[09:28:24.440]     }
[09:28:24.440]     else {
[09:28:24.440]         if (TRUE) {
[09:28:24.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:24.440]                 open = "w")
[09:28:24.440]         }
[09:28:24.440]         else {
[09:28:24.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:24.440]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:24.440]         }
[09:28:24.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:24.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:24.440]             base::sink(type = "output", split = FALSE)
[09:28:24.440]             base::close(...future.stdout)
[09:28:24.440]         }, add = TRUE)
[09:28:24.440]     }
[09:28:24.440]     ...future.frame <- base::sys.nframe()
[09:28:24.440]     ...future.conditions <- base::list()
[09:28:24.440]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:24.440]     if (FALSE) {
[09:28:24.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:24.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:24.440]     }
[09:28:24.440]     ...future.result <- base::tryCatch({
[09:28:24.440]         base::withCallingHandlers({
[09:28:24.440]             ...future.value <- base::withVisible(base::local({
[09:28:24.440]                 ...future.makeSendCondition <- base::local({
[09:28:24.440]                   sendCondition <- NULL
[09:28:24.440]                   function(frame = 1L) {
[09:28:24.440]                     if (is.function(sendCondition)) 
[09:28:24.440]                       return(sendCondition)
[09:28:24.440]                     ns <- getNamespace("parallel")
[09:28:24.440]                     if (exists("sendData", mode = "function", 
[09:28:24.440]                       envir = ns)) {
[09:28:24.440]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:24.440]                         envir = ns)
[09:28:24.440]                       envir <- sys.frame(frame)
[09:28:24.440]                       master <- NULL
[09:28:24.440]                       while (!identical(envir, .GlobalEnv) && 
[09:28:24.440]                         !identical(envir, emptyenv())) {
[09:28:24.440]                         if (exists("master", mode = "list", envir = envir, 
[09:28:24.440]                           inherits = FALSE)) {
[09:28:24.440]                           master <- get("master", mode = "list", 
[09:28:24.440]                             envir = envir, inherits = FALSE)
[09:28:24.440]                           if (inherits(master, c("SOCKnode", 
[09:28:24.440]                             "SOCK0node"))) {
[09:28:24.440]                             sendCondition <<- function(cond) {
[09:28:24.440]                               data <- list(type = "VALUE", value = cond, 
[09:28:24.440]                                 success = TRUE)
[09:28:24.440]                               parallel_sendData(master, data)
[09:28:24.440]                             }
[09:28:24.440]                             return(sendCondition)
[09:28:24.440]                           }
[09:28:24.440]                         }
[09:28:24.440]                         frame <- frame + 1L
[09:28:24.440]                         envir <- sys.frame(frame)
[09:28:24.440]                       }
[09:28:24.440]                     }
[09:28:24.440]                     sendCondition <<- function(cond) NULL
[09:28:24.440]                   }
[09:28:24.440]                 })
[09:28:24.440]                 withCallingHandlers({
[09:28:24.440]                   {
[09:28:24.440]                     do.call(function(...) {
[09:28:24.440]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.440]                       if (!identical(...future.globals.maxSize.org, 
[09:28:24.440]                         ...future.globals.maxSize)) {
[09:28:24.440]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.440]                         on.exit(options(oopts), add = TRUE)
[09:28:24.440]                       }
[09:28:24.440]                       {
[09:28:24.440]                         lapply(seq_along(...future.elements_ii), 
[09:28:24.440]                           FUN = function(jj) {
[09:28:24.440]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.440]                             ...future.FUN(...future.X_jj, ...)
[09:28:24.440]                           })
[09:28:24.440]                       }
[09:28:24.440]                     }, args = future.call.arguments)
[09:28:24.440]                   }
[09:28:24.440]                 }, immediateCondition = function(cond) {
[09:28:24.440]                   sendCondition <- ...future.makeSendCondition()
[09:28:24.440]                   sendCondition(cond)
[09:28:24.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.440]                   {
[09:28:24.440]                     inherits <- base::inherits
[09:28:24.440]                     invokeRestart <- base::invokeRestart
[09:28:24.440]                     is.null <- base::is.null
[09:28:24.440]                     muffled <- FALSE
[09:28:24.440]                     if (inherits(cond, "message")) {
[09:28:24.440]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:24.440]                       if (muffled) 
[09:28:24.440]                         invokeRestart("muffleMessage")
[09:28:24.440]                     }
[09:28:24.440]                     else if (inherits(cond, "warning")) {
[09:28:24.440]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:24.440]                       if (muffled) 
[09:28:24.440]                         invokeRestart("muffleWarning")
[09:28:24.440]                     }
[09:28:24.440]                     else if (inherits(cond, "condition")) {
[09:28:24.440]                       if (!is.null(pattern)) {
[09:28:24.440]                         computeRestarts <- base::computeRestarts
[09:28:24.440]                         grepl <- base::grepl
[09:28:24.440]                         restarts <- computeRestarts(cond)
[09:28:24.440]                         for (restart in restarts) {
[09:28:24.440]                           name <- restart$name
[09:28:24.440]                           if (is.null(name)) 
[09:28:24.440]                             next
[09:28:24.440]                           if (!grepl(pattern, name)) 
[09:28:24.440]                             next
[09:28:24.440]                           invokeRestart(restart)
[09:28:24.440]                           muffled <- TRUE
[09:28:24.440]                           break
[09:28:24.440]                         }
[09:28:24.440]                       }
[09:28:24.440]                     }
[09:28:24.440]                     invisible(muffled)
[09:28:24.440]                   }
[09:28:24.440]                   muffleCondition(cond)
[09:28:24.440]                 })
[09:28:24.440]             }))
[09:28:24.440]             future::FutureResult(value = ...future.value$value, 
[09:28:24.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.440]                   ...future.rng), globalenv = if (FALSE) 
[09:28:24.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:24.440]                     ...future.globalenv.names))
[09:28:24.440]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:24.440]         }, condition = base::local({
[09:28:24.440]             c <- base::c
[09:28:24.440]             inherits <- base::inherits
[09:28:24.440]             invokeRestart <- base::invokeRestart
[09:28:24.440]             length <- base::length
[09:28:24.440]             list <- base::list
[09:28:24.440]             seq.int <- base::seq.int
[09:28:24.440]             signalCondition <- base::signalCondition
[09:28:24.440]             sys.calls <- base::sys.calls
[09:28:24.440]             `[[` <- base::`[[`
[09:28:24.440]             `+` <- base::`+`
[09:28:24.440]             `<<-` <- base::`<<-`
[09:28:24.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:24.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:24.440]                   3L)]
[09:28:24.440]             }
[09:28:24.440]             function(cond) {
[09:28:24.440]                 is_error <- inherits(cond, "error")
[09:28:24.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:24.440]                   NULL)
[09:28:24.440]                 if (is_error) {
[09:28:24.440]                   sessionInformation <- function() {
[09:28:24.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:24.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:24.440]                       search = base::search(), system = base::Sys.info())
[09:28:24.440]                   }
[09:28:24.440]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:24.440]                     cond$call), session = sessionInformation(), 
[09:28:24.440]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:24.440]                   signalCondition(cond)
[09:28:24.440]                 }
[09:28:24.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:24.440]                 "immediateCondition"))) {
[09:28:24.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:24.440]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:24.440]                   if (TRUE && !signal) {
[09:28:24.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.440]                     {
[09:28:24.440]                       inherits <- base::inherits
[09:28:24.440]                       invokeRestart <- base::invokeRestart
[09:28:24.440]                       is.null <- base::is.null
[09:28:24.440]                       muffled <- FALSE
[09:28:24.440]                       if (inherits(cond, "message")) {
[09:28:24.440]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.440]                         if (muffled) 
[09:28:24.440]                           invokeRestart("muffleMessage")
[09:28:24.440]                       }
[09:28:24.440]                       else if (inherits(cond, "warning")) {
[09:28:24.440]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.440]                         if (muffled) 
[09:28:24.440]                           invokeRestart("muffleWarning")
[09:28:24.440]                       }
[09:28:24.440]                       else if (inherits(cond, "condition")) {
[09:28:24.440]                         if (!is.null(pattern)) {
[09:28:24.440]                           computeRestarts <- base::computeRestarts
[09:28:24.440]                           grepl <- base::grepl
[09:28:24.440]                           restarts <- computeRestarts(cond)
[09:28:24.440]                           for (restart in restarts) {
[09:28:24.440]                             name <- restart$name
[09:28:24.440]                             if (is.null(name)) 
[09:28:24.440]                               next
[09:28:24.440]                             if (!grepl(pattern, name)) 
[09:28:24.440]                               next
[09:28:24.440]                             invokeRestart(restart)
[09:28:24.440]                             muffled <- TRUE
[09:28:24.440]                             break
[09:28:24.440]                           }
[09:28:24.440]                         }
[09:28:24.440]                       }
[09:28:24.440]                       invisible(muffled)
[09:28:24.440]                     }
[09:28:24.440]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.440]                   }
[09:28:24.440]                 }
[09:28:24.440]                 else {
[09:28:24.440]                   if (TRUE) {
[09:28:24.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.440]                     {
[09:28:24.440]                       inherits <- base::inherits
[09:28:24.440]                       invokeRestart <- base::invokeRestart
[09:28:24.440]                       is.null <- base::is.null
[09:28:24.440]                       muffled <- FALSE
[09:28:24.440]                       if (inherits(cond, "message")) {
[09:28:24.440]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.440]                         if (muffled) 
[09:28:24.440]                           invokeRestart("muffleMessage")
[09:28:24.440]                       }
[09:28:24.440]                       else if (inherits(cond, "warning")) {
[09:28:24.440]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.440]                         if (muffled) 
[09:28:24.440]                           invokeRestart("muffleWarning")
[09:28:24.440]                       }
[09:28:24.440]                       else if (inherits(cond, "condition")) {
[09:28:24.440]                         if (!is.null(pattern)) {
[09:28:24.440]                           computeRestarts <- base::computeRestarts
[09:28:24.440]                           grepl <- base::grepl
[09:28:24.440]                           restarts <- computeRestarts(cond)
[09:28:24.440]                           for (restart in restarts) {
[09:28:24.440]                             name <- restart$name
[09:28:24.440]                             if (is.null(name)) 
[09:28:24.440]                               next
[09:28:24.440]                             if (!grepl(pattern, name)) 
[09:28:24.440]                               next
[09:28:24.440]                             invokeRestart(restart)
[09:28:24.440]                             muffled <- TRUE
[09:28:24.440]                             break
[09:28:24.440]                           }
[09:28:24.440]                         }
[09:28:24.440]                       }
[09:28:24.440]                       invisible(muffled)
[09:28:24.440]                     }
[09:28:24.440]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.440]                   }
[09:28:24.440]                 }
[09:28:24.440]             }
[09:28:24.440]         }))
[09:28:24.440]     }, error = function(ex) {
[09:28:24.440]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:24.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.440]                 ...future.rng), started = ...future.startTime, 
[09:28:24.440]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:24.440]             version = "1.8"), class = "FutureResult")
[09:28:24.440]     }, finally = {
[09:28:24.440]         if (!identical(...future.workdir, getwd())) 
[09:28:24.440]             setwd(...future.workdir)
[09:28:24.440]         {
[09:28:24.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:24.440]                 ...future.oldOptions$nwarnings <- NULL
[09:28:24.440]             }
[09:28:24.440]             base::options(...future.oldOptions)
[09:28:24.440]             if (.Platform$OS.type == "windows") {
[09:28:24.440]                 old_names <- names(...future.oldEnvVars)
[09:28:24.440]                 envs <- base::Sys.getenv()
[09:28:24.440]                 names <- names(envs)
[09:28:24.440]                 common <- intersect(names, old_names)
[09:28:24.440]                 added <- setdiff(names, old_names)
[09:28:24.440]                 removed <- setdiff(old_names, names)
[09:28:24.440]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:24.440]                   envs[common]]
[09:28:24.440]                 NAMES <- toupper(changed)
[09:28:24.440]                 args <- list()
[09:28:24.440]                 for (kk in seq_along(NAMES)) {
[09:28:24.440]                   name <- changed[[kk]]
[09:28:24.440]                   NAME <- NAMES[[kk]]
[09:28:24.440]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.440]                     next
[09:28:24.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.440]                 }
[09:28:24.440]                 NAMES <- toupper(added)
[09:28:24.440]                 for (kk in seq_along(NAMES)) {
[09:28:24.440]                   name <- added[[kk]]
[09:28:24.440]                   NAME <- NAMES[[kk]]
[09:28:24.440]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.440]                     next
[09:28:24.440]                   args[[name]] <- ""
[09:28:24.440]                 }
[09:28:24.440]                 NAMES <- toupper(removed)
[09:28:24.440]                 for (kk in seq_along(NAMES)) {
[09:28:24.440]                   name <- removed[[kk]]
[09:28:24.440]                   NAME <- NAMES[[kk]]
[09:28:24.440]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.440]                     next
[09:28:24.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.440]                 }
[09:28:24.440]                 if (length(args) > 0) 
[09:28:24.440]                   base::do.call(base::Sys.setenv, args = args)
[09:28:24.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:24.440]             }
[09:28:24.440]             else {
[09:28:24.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:24.440]             }
[09:28:24.440]             {
[09:28:24.440]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:24.440]                   0L) {
[09:28:24.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:24.440]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:24.440]                   base::options(opts)
[09:28:24.440]                 }
[09:28:24.440]                 {
[09:28:24.440]                   {
[09:28:24.440]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:24.440]                     NULL
[09:28:24.440]                   }
[09:28:24.440]                   options(future.plan = NULL)
[09:28:24.440]                   if (is.na(NA_character_)) 
[09:28:24.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:24.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:24.440]                     .init = FALSE)
[09:28:24.440]                 }
[09:28:24.440]             }
[09:28:24.440]         }
[09:28:24.440]     })
[09:28:24.440]     if (TRUE) {
[09:28:24.440]         base::sink(type = "output", split = FALSE)
[09:28:24.440]         if (TRUE) {
[09:28:24.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:24.440]         }
[09:28:24.440]         else {
[09:28:24.440]             ...future.result["stdout"] <- base::list(NULL)
[09:28:24.440]         }
[09:28:24.440]         base::close(...future.stdout)
[09:28:24.440]         ...future.stdout <- NULL
[09:28:24.440]     }
[09:28:24.440]     ...future.result$conditions <- ...future.conditions
[09:28:24.440]     ...future.result$finished <- base::Sys.time()
[09:28:24.440]     ...future.result
[09:28:24.440] }
[09:28:24.443] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[09:28:24.443] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[09:28:24.444] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[09:28:24.444] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:24.444] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:24.445] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[09:28:24.445] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[09:28:24.445] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:24.446] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:24.446] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:28:24.446] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:28:24.446] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[09:28:24.447] MultisessionFuture started
[09:28:24.447] - Launch lazy future ... done
[09:28:24.447] run() for ‘MultisessionFuture’ ... done
[09:28:24.447] Created future:
[09:28:24.448] MultisessionFuture:
[09:28:24.448] Label: ‘future_by-1’
[09:28:24.448] Expression:
[09:28:24.448] {
[09:28:24.448]     do.call(function(...) {
[09:28:24.448]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.448]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.448]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.448]             on.exit(options(oopts), add = TRUE)
[09:28:24.448]         }
[09:28:24.448]         {
[09:28:24.448]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.448]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.448]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.448]             })
[09:28:24.448]         }
[09:28:24.448]     }, args = future.call.arguments)
[09:28:24.448] }
[09:28:24.448] Lazy evaluation: FALSE
[09:28:24.448] Asynchronous evaluation: TRUE
[09:28:24.448] Local evaluation: TRUE
[09:28:24.448] Environment: R_GlobalEnv
[09:28:24.448] Capture standard output: TRUE
[09:28:24.448] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:24.448] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:24.448] Packages: <none>
[09:28:24.448] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:24.448] Resolved: FALSE
[09:28:24.448] Value: <not collected>
[09:28:24.448] Conditions captured: <none>
[09:28:24.448] Early signaling: FALSE
[09:28:24.448] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:24.448] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.460] Chunk #1 of 2 ... DONE
[09:28:24.460] Chunk #2 of 2 ...
[09:28:24.460]  - Finding globals in 'X' for chunk #2 ...
[09:28:24.460] getGlobalsAndPackages() ...
[09:28:24.460] Searching for globals...
[09:28:24.461] 
[09:28:24.461] Searching for globals ... DONE
[09:28:24.461] - globals: [0] <none>
[09:28:24.461] getGlobalsAndPackages() ... DONE
[09:28:24.461]    + additional globals found: [n=0] 
[09:28:24.462]    + additional namespaces needed: [n=0] 
[09:28:24.462]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:24.462]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:24.462]  - seeds: <none>
[09:28:24.462]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.462] getGlobalsAndPackages() ...
[09:28:24.462] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.462] Resolving globals: FALSE
[09:28:24.463] Tweak future expression to call with '...' arguments ...
[09:28:24.463] {
[09:28:24.463]     do.call(function(...) {
[09:28:24.463]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.463]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.463]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.463]             on.exit(options(oopts), add = TRUE)
[09:28:24.463]         }
[09:28:24.463]         {
[09:28:24.463]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.463]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.463]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.463]             })
[09:28:24.463]         }
[09:28:24.463]     }, args = future.call.arguments)
[09:28:24.463] }
[09:28:24.463] Tweak future expression to call with '...' arguments ... DONE
[09:28:24.463] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.463] 
[09:28:24.464] getGlobalsAndPackages() ... DONE
[09:28:24.464] run() for ‘Future’ ...
[09:28:24.464] - state: ‘created’
[09:28:24.464] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:24.478] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:24.479]   - Field: ‘node’
[09:28:24.479]   - Field: ‘label’
[09:28:24.479]   - Field: ‘local’
[09:28:24.479]   - Field: ‘owner’
[09:28:24.479]   - Field: ‘envir’
[09:28:24.479]   - Field: ‘workers’
[09:28:24.479]   - Field: ‘packages’
[09:28:24.479]   - Field: ‘gc’
[09:28:24.479]   - Field: ‘conditions’
[09:28:24.479]   - Field: ‘persistent’
[09:28:24.480]   - Field: ‘expr’
[09:28:24.480]   - Field: ‘uuid’
[09:28:24.480]   - Field: ‘seed’
[09:28:24.480]   - Field: ‘version’
[09:28:24.480]   - Field: ‘result’
[09:28:24.480]   - Field: ‘asynchronous’
[09:28:24.480]   - Field: ‘calls’
[09:28:24.480]   - Field: ‘globals’
[09:28:24.481]   - Field: ‘stdout’
[09:28:24.481]   - Field: ‘earlySignal’
[09:28:24.481]   - Field: ‘lazy’
[09:28:24.481]   - Field: ‘state’
[09:28:24.481] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:24.481] - Launch lazy future ...
[09:28:24.481] Packages needed by the future expression (n = 0): <none>
[09:28:24.481] Packages needed by future strategies (n = 0): <none>
[09:28:24.482] {
[09:28:24.482]     {
[09:28:24.482]         {
[09:28:24.482]             ...future.startTime <- base::Sys.time()
[09:28:24.482]             {
[09:28:24.482]                 {
[09:28:24.482]                   {
[09:28:24.482]                     {
[09:28:24.482]                       base::local({
[09:28:24.482]                         has_future <- base::requireNamespace("future", 
[09:28:24.482]                           quietly = TRUE)
[09:28:24.482]                         if (has_future) {
[09:28:24.482]                           ns <- base::getNamespace("future")
[09:28:24.482]                           version <- ns[[".package"]][["version"]]
[09:28:24.482]                           if (is.null(version)) 
[09:28:24.482]                             version <- utils::packageVersion("future")
[09:28:24.482]                         }
[09:28:24.482]                         else {
[09:28:24.482]                           version <- NULL
[09:28:24.482]                         }
[09:28:24.482]                         if (!has_future || version < "1.8.0") {
[09:28:24.482]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:24.482]                             "", base::R.version$version.string), 
[09:28:24.482]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:24.482]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:24.482]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:24.482]                               "release", "version")], collapse = " "), 
[09:28:24.482]                             hostname = base::Sys.info()[["nodename"]])
[09:28:24.482]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:24.482]                             info)
[09:28:24.482]                           info <- base::paste(info, collapse = "; ")
[09:28:24.482]                           if (!has_future) {
[09:28:24.482]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:24.482]                               info)
[09:28:24.482]                           }
[09:28:24.482]                           else {
[09:28:24.482]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:24.482]                               info, version)
[09:28:24.482]                           }
[09:28:24.482]                           base::stop(msg)
[09:28:24.482]                         }
[09:28:24.482]                       })
[09:28:24.482]                     }
[09:28:24.482]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:24.482]                     base::options(mc.cores = 1L)
[09:28:24.482]                   }
[09:28:24.482]                   ...future.strategy.old <- future::plan("list")
[09:28:24.482]                   options(future.plan = NULL)
[09:28:24.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:24.482]                 }
[09:28:24.482]                 ...future.workdir <- getwd()
[09:28:24.482]             }
[09:28:24.482]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:24.482]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:24.482]         }
[09:28:24.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:24.482]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:24.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:24.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:24.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:24.482]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:24.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:24.482]             base::names(...future.oldOptions))
[09:28:24.482]     }
[09:28:24.482]     if (FALSE) {
[09:28:24.482]     }
[09:28:24.482]     else {
[09:28:24.482]         if (TRUE) {
[09:28:24.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:24.482]                 open = "w")
[09:28:24.482]         }
[09:28:24.482]         else {
[09:28:24.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:24.482]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:24.482]         }
[09:28:24.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:24.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:24.482]             base::sink(type = "output", split = FALSE)
[09:28:24.482]             base::close(...future.stdout)
[09:28:24.482]         }, add = TRUE)
[09:28:24.482]     }
[09:28:24.482]     ...future.frame <- base::sys.nframe()
[09:28:24.482]     ...future.conditions <- base::list()
[09:28:24.482]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:24.482]     if (FALSE) {
[09:28:24.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:24.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:24.482]     }
[09:28:24.482]     ...future.result <- base::tryCatch({
[09:28:24.482]         base::withCallingHandlers({
[09:28:24.482]             ...future.value <- base::withVisible(base::local({
[09:28:24.482]                 ...future.makeSendCondition <- base::local({
[09:28:24.482]                   sendCondition <- NULL
[09:28:24.482]                   function(frame = 1L) {
[09:28:24.482]                     if (is.function(sendCondition)) 
[09:28:24.482]                       return(sendCondition)
[09:28:24.482]                     ns <- getNamespace("parallel")
[09:28:24.482]                     if (exists("sendData", mode = "function", 
[09:28:24.482]                       envir = ns)) {
[09:28:24.482]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:24.482]                         envir = ns)
[09:28:24.482]                       envir <- sys.frame(frame)
[09:28:24.482]                       master <- NULL
[09:28:24.482]                       while (!identical(envir, .GlobalEnv) && 
[09:28:24.482]                         !identical(envir, emptyenv())) {
[09:28:24.482]                         if (exists("master", mode = "list", envir = envir, 
[09:28:24.482]                           inherits = FALSE)) {
[09:28:24.482]                           master <- get("master", mode = "list", 
[09:28:24.482]                             envir = envir, inherits = FALSE)
[09:28:24.482]                           if (inherits(master, c("SOCKnode", 
[09:28:24.482]                             "SOCK0node"))) {
[09:28:24.482]                             sendCondition <<- function(cond) {
[09:28:24.482]                               data <- list(type = "VALUE", value = cond, 
[09:28:24.482]                                 success = TRUE)
[09:28:24.482]                               parallel_sendData(master, data)
[09:28:24.482]                             }
[09:28:24.482]                             return(sendCondition)
[09:28:24.482]                           }
[09:28:24.482]                         }
[09:28:24.482]                         frame <- frame + 1L
[09:28:24.482]                         envir <- sys.frame(frame)
[09:28:24.482]                       }
[09:28:24.482]                     }
[09:28:24.482]                     sendCondition <<- function(cond) NULL
[09:28:24.482]                   }
[09:28:24.482]                 })
[09:28:24.482]                 withCallingHandlers({
[09:28:24.482]                   {
[09:28:24.482]                     do.call(function(...) {
[09:28:24.482]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.482]                       if (!identical(...future.globals.maxSize.org, 
[09:28:24.482]                         ...future.globals.maxSize)) {
[09:28:24.482]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.482]                         on.exit(options(oopts), add = TRUE)
[09:28:24.482]                       }
[09:28:24.482]                       {
[09:28:24.482]                         lapply(seq_along(...future.elements_ii), 
[09:28:24.482]                           FUN = function(jj) {
[09:28:24.482]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.482]                             ...future.FUN(...future.X_jj, ...)
[09:28:24.482]                           })
[09:28:24.482]                       }
[09:28:24.482]                     }, args = future.call.arguments)
[09:28:24.482]                   }
[09:28:24.482]                 }, immediateCondition = function(cond) {
[09:28:24.482]                   sendCondition <- ...future.makeSendCondition()
[09:28:24.482]                   sendCondition(cond)
[09:28:24.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.482]                   {
[09:28:24.482]                     inherits <- base::inherits
[09:28:24.482]                     invokeRestart <- base::invokeRestart
[09:28:24.482]                     is.null <- base::is.null
[09:28:24.482]                     muffled <- FALSE
[09:28:24.482]                     if (inherits(cond, "message")) {
[09:28:24.482]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:24.482]                       if (muffled) 
[09:28:24.482]                         invokeRestart("muffleMessage")
[09:28:24.482]                     }
[09:28:24.482]                     else if (inherits(cond, "warning")) {
[09:28:24.482]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:24.482]                       if (muffled) 
[09:28:24.482]                         invokeRestart("muffleWarning")
[09:28:24.482]                     }
[09:28:24.482]                     else if (inherits(cond, "condition")) {
[09:28:24.482]                       if (!is.null(pattern)) {
[09:28:24.482]                         computeRestarts <- base::computeRestarts
[09:28:24.482]                         grepl <- base::grepl
[09:28:24.482]                         restarts <- computeRestarts(cond)
[09:28:24.482]                         for (restart in restarts) {
[09:28:24.482]                           name <- restart$name
[09:28:24.482]                           if (is.null(name)) 
[09:28:24.482]                             next
[09:28:24.482]                           if (!grepl(pattern, name)) 
[09:28:24.482]                             next
[09:28:24.482]                           invokeRestart(restart)
[09:28:24.482]                           muffled <- TRUE
[09:28:24.482]                           break
[09:28:24.482]                         }
[09:28:24.482]                       }
[09:28:24.482]                     }
[09:28:24.482]                     invisible(muffled)
[09:28:24.482]                   }
[09:28:24.482]                   muffleCondition(cond)
[09:28:24.482]                 })
[09:28:24.482]             }))
[09:28:24.482]             future::FutureResult(value = ...future.value$value, 
[09:28:24.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.482]                   ...future.rng), globalenv = if (FALSE) 
[09:28:24.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:24.482]                     ...future.globalenv.names))
[09:28:24.482]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:24.482]         }, condition = base::local({
[09:28:24.482]             c <- base::c
[09:28:24.482]             inherits <- base::inherits
[09:28:24.482]             invokeRestart <- base::invokeRestart
[09:28:24.482]             length <- base::length
[09:28:24.482]             list <- base::list
[09:28:24.482]             seq.int <- base::seq.int
[09:28:24.482]             signalCondition <- base::signalCondition
[09:28:24.482]             sys.calls <- base::sys.calls
[09:28:24.482]             `[[` <- base::`[[`
[09:28:24.482]             `+` <- base::`+`
[09:28:24.482]             `<<-` <- base::`<<-`
[09:28:24.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:24.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:24.482]                   3L)]
[09:28:24.482]             }
[09:28:24.482]             function(cond) {
[09:28:24.482]                 is_error <- inherits(cond, "error")
[09:28:24.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:24.482]                   NULL)
[09:28:24.482]                 if (is_error) {
[09:28:24.482]                   sessionInformation <- function() {
[09:28:24.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:24.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:24.482]                       search = base::search(), system = base::Sys.info())
[09:28:24.482]                   }
[09:28:24.482]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:24.482]                     cond$call), session = sessionInformation(), 
[09:28:24.482]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:24.482]                   signalCondition(cond)
[09:28:24.482]                 }
[09:28:24.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:24.482]                 "immediateCondition"))) {
[09:28:24.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:24.482]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:24.482]                   if (TRUE && !signal) {
[09:28:24.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.482]                     {
[09:28:24.482]                       inherits <- base::inherits
[09:28:24.482]                       invokeRestart <- base::invokeRestart
[09:28:24.482]                       is.null <- base::is.null
[09:28:24.482]                       muffled <- FALSE
[09:28:24.482]                       if (inherits(cond, "message")) {
[09:28:24.482]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.482]                         if (muffled) 
[09:28:24.482]                           invokeRestart("muffleMessage")
[09:28:24.482]                       }
[09:28:24.482]                       else if (inherits(cond, "warning")) {
[09:28:24.482]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.482]                         if (muffled) 
[09:28:24.482]                           invokeRestart("muffleWarning")
[09:28:24.482]                       }
[09:28:24.482]                       else if (inherits(cond, "condition")) {
[09:28:24.482]                         if (!is.null(pattern)) {
[09:28:24.482]                           computeRestarts <- base::computeRestarts
[09:28:24.482]                           grepl <- base::grepl
[09:28:24.482]                           restarts <- computeRestarts(cond)
[09:28:24.482]                           for (restart in restarts) {
[09:28:24.482]                             name <- restart$name
[09:28:24.482]                             if (is.null(name)) 
[09:28:24.482]                               next
[09:28:24.482]                             if (!grepl(pattern, name)) 
[09:28:24.482]                               next
[09:28:24.482]                             invokeRestart(restart)
[09:28:24.482]                             muffled <- TRUE
[09:28:24.482]                             break
[09:28:24.482]                           }
[09:28:24.482]                         }
[09:28:24.482]                       }
[09:28:24.482]                       invisible(muffled)
[09:28:24.482]                     }
[09:28:24.482]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.482]                   }
[09:28:24.482]                 }
[09:28:24.482]                 else {
[09:28:24.482]                   if (TRUE) {
[09:28:24.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.482]                     {
[09:28:24.482]                       inherits <- base::inherits
[09:28:24.482]                       invokeRestart <- base::invokeRestart
[09:28:24.482]                       is.null <- base::is.null
[09:28:24.482]                       muffled <- FALSE
[09:28:24.482]                       if (inherits(cond, "message")) {
[09:28:24.482]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.482]                         if (muffled) 
[09:28:24.482]                           invokeRestart("muffleMessage")
[09:28:24.482]                       }
[09:28:24.482]                       else if (inherits(cond, "warning")) {
[09:28:24.482]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.482]                         if (muffled) 
[09:28:24.482]                           invokeRestart("muffleWarning")
[09:28:24.482]                       }
[09:28:24.482]                       else if (inherits(cond, "condition")) {
[09:28:24.482]                         if (!is.null(pattern)) {
[09:28:24.482]                           computeRestarts <- base::computeRestarts
[09:28:24.482]                           grepl <- base::grepl
[09:28:24.482]                           restarts <- computeRestarts(cond)
[09:28:24.482]                           for (restart in restarts) {
[09:28:24.482]                             name <- restart$name
[09:28:24.482]                             if (is.null(name)) 
[09:28:24.482]                               next
[09:28:24.482]                             if (!grepl(pattern, name)) 
[09:28:24.482]                               next
[09:28:24.482]                             invokeRestart(restart)
[09:28:24.482]                             muffled <- TRUE
[09:28:24.482]                             break
[09:28:24.482]                           }
[09:28:24.482]                         }
[09:28:24.482]                       }
[09:28:24.482]                       invisible(muffled)
[09:28:24.482]                     }
[09:28:24.482]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.482]                   }
[09:28:24.482]                 }
[09:28:24.482]             }
[09:28:24.482]         }))
[09:28:24.482]     }, error = function(ex) {
[09:28:24.482]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:24.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.482]                 ...future.rng), started = ...future.startTime, 
[09:28:24.482]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:24.482]             version = "1.8"), class = "FutureResult")
[09:28:24.482]     }, finally = {
[09:28:24.482]         if (!identical(...future.workdir, getwd())) 
[09:28:24.482]             setwd(...future.workdir)
[09:28:24.482]         {
[09:28:24.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:24.482]                 ...future.oldOptions$nwarnings <- NULL
[09:28:24.482]             }
[09:28:24.482]             base::options(...future.oldOptions)
[09:28:24.482]             if (.Platform$OS.type == "windows") {
[09:28:24.482]                 old_names <- names(...future.oldEnvVars)
[09:28:24.482]                 envs <- base::Sys.getenv()
[09:28:24.482]                 names <- names(envs)
[09:28:24.482]                 common <- intersect(names, old_names)
[09:28:24.482]                 added <- setdiff(names, old_names)
[09:28:24.482]                 removed <- setdiff(old_names, names)
[09:28:24.482]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:24.482]                   envs[common]]
[09:28:24.482]                 NAMES <- toupper(changed)
[09:28:24.482]                 args <- list()
[09:28:24.482]                 for (kk in seq_along(NAMES)) {
[09:28:24.482]                   name <- changed[[kk]]
[09:28:24.482]                   NAME <- NAMES[[kk]]
[09:28:24.482]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.482]                     next
[09:28:24.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.482]                 }
[09:28:24.482]                 NAMES <- toupper(added)
[09:28:24.482]                 for (kk in seq_along(NAMES)) {
[09:28:24.482]                   name <- added[[kk]]
[09:28:24.482]                   NAME <- NAMES[[kk]]
[09:28:24.482]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.482]                     next
[09:28:24.482]                   args[[name]] <- ""
[09:28:24.482]                 }
[09:28:24.482]                 NAMES <- toupper(removed)
[09:28:24.482]                 for (kk in seq_along(NAMES)) {
[09:28:24.482]                   name <- removed[[kk]]
[09:28:24.482]                   NAME <- NAMES[[kk]]
[09:28:24.482]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.482]                     next
[09:28:24.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.482]                 }
[09:28:24.482]                 if (length(args) > 0) 
[09:28:24.482]                   base::do.call(base::Sys.setenv, args = args)
[09:28:24.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:24.482]             }
[09:28:24.482]             else {
[09:28:24.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:24.482]             }
[09:28:24.482]             {
[09:28:24.482]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:24.482]                   0L) {
[09:28:24.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:24.482]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:24.482]                   base::options(opts)
[09:28:24.482]                 }
[09:28:24.482]                 {
[09:28:24.482]                   {
[09:28:24.482]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:24.482]                     NULL
[09:28:24.482]                   }
[09:28:24.482]                   options(future.plan = NULL)
[09:28:24.482]                   if (is.na(NA_character_)) 
[09:28:24.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:24.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:24.482]                     .init = FALSE)
[09:28:24.482]                 }
[09:28:24.482]             }
[09:28:24.482]         }
[09:28:24.482]     })
[09:28:24.482]     if (TRUE) {
[09:28:24.482]         base::sink(type = "output", split = FALSE)
[09:28:24.482]         if (TRUE) {
[09:28:24.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:24.482]         }
[09:28:24.482]         else {
[09:28:24.482]             ...future.result["stdout"] <- base::list(NULL)
[09:28:24.482]         }
[09:28:24.482]         base::close(...future.stdout)
[09:28:24.482]         ...future.stdout <- NULL
[09:28:24.482]     }
[09:28:24.482]     ...future.result$conditions <- ...future.conditions
[09:28:24.482]     ...future.result$finished <- base::Sys.time()
[09:28:24.482]     ...future.result
[09:28:24.482] }
[09:28:24.533] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[09:28:24.534] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[09:28:24.534] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[09:28:24.534] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:24.535] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:24.535] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[09:28:24.535] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[09:28:24.536] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:24.536] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:24.536] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:28:24.536] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:28:24.537] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[09:28:24.537] MultisessionFuture started
[09:28:24.537] - Launch lazy future ... done
[09:28:24.537] run() for ‘MultisessionFuture’ ... done
[09:28:24.538] Created future:
[09:28:24.538] MultisessionFuture:
[09:28:24.538] Label: ‘future_by-2’
[09:28:24.538] Expression:
[09:28:24.538] {
[09:28:24.538]     do.call(function(...) {
[09:28:24.538]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.538]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.538]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.538]             on.exit(options(oopts), add = TRUE)
[09:28:24.538]         }
[09:28:24.538]         {
[09:28:24.538]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.538]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.538]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.538]             })
[09:28:24.538]         }
[09:28:24.538]     }, args = future.call.arguments)
[09:28:24.538] }
[09:28:24.538] Lazy evaluation: FALSE
[09:28:24.538] Asynchronous evaluation: TRUE
[09:28:24.538] Local evaluation: TRUE
[09:28:24.538] Environment: R_GlobalEnv
[09:28:24.538] Capture standard output: TRUE
[09:28:24.538] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:24.538] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:24.538] Packages: <none>
[09:28:24.538] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:24.538] Resolved: FALSE
[09:28:24.538] Value: <not collected>
[09:28:24.538] Conditions captured: <none>
[09:28:24.538] Early signaling: FALSE
[09:28:24.538] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:24.538] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.550] Chunk #2 of 2 ... DONE
[09:28:24.550] Launching 2 futures (chunks) ... DONE
[09:28:24.550] Resolving 2 futures (chunks) ...
[09:28:24.550] resolve() on list ...
[09:28:24.550]  recursive: 0
[09:28:24.550]  length: 2
[09:28:24.550] 
[09:28:24.551] receiveMessageFromWorker() for ClusterFuture ...
[09:28:24.551] - Validating connection of MultisessionFuture
[09:28:24.551] - received message: FutureResult
[09:28:24.551] - Received FutureResult
[09:28:24.552] - Erased future from FutureRegistry
[09:28:24.552] result() for ClusterFuture ...
[09:28:24.552] - result already collected: FutureResult
[09:28:24.552] result() for ClusterFuture ... done
[09:28:24.552] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:24.552] Future #1
[09:28:24.552] result() for ClusterFuture ...
[09:28:24.552] - result already collected: FutureResult
[09:28:24.553] result() for ClusterFuture ... done
[09:28:24.553] result() for ClusterFuture ...
[09:28:24.553] - result already collected: FutureResult
[09:28:24.553] result() for ClusterFuture ... done
[09:28:24.553] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:24.553] - nx: 2
[09:28:24.553] - relay: TRUE
[09:28:24.553] - stdout: TRUE
[09:28:24.553] - signal: TRUE
[09:28:24.553] - resignal: FALSE
[09:28:24.554] - force: TRUE
[09:28:24.554] - relayed: [n=2] FALSE, FALSE
[09:28:24.554] - queued futures: [n=2] FALSE, FALSE
[09:28:24.554]  - until=1
[09:28:24.554]  - relaying element #1
[09:28:24.554] result() for ClusterFuture ...
[09:28:24.554] - result already collected: FutureResult
[09:28:24.554] result() for ClusterFuture ... done
[09:28:24.554] result() for ClusterFuture ...
[09:28:24.555] - result already collected: FutureResult
[09:28:24.555] result() for ClusterFuture ... done
[09:28:24.555] result() for ClusterFuture ...
[09:28:24.555] - result already collected: FutureResult
[09:28:24.555] result() for ClusterFuture ... done
[09:28:24.555] result() for ClusterFuture ...
[09:28:24.555] - result already collected: FutureResult
[09:28:24.555] result() for ClusterFuture ... done
[09:28:24.555] - relayed: [n=2] TRUE, FALSE
[09:28:24.556] - queued futures: [n=2] TRUE, FALSE
[09:28:24.556] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:24.556]  length: 1 (resolved future 1)
[09:28:24.619] receiveMessageFromWorker() for ClusterFuture ...
[09:28:24.619] - Validating connection of MultisessionFuture
[09:28:24.619] - received message: FutureResult
[09:28:24.619] - Received FutureResult
[09:28:24.619] - Erased future from FutureRegistry
[09:28:24.620] result() for ClusterFuture ...
[09:28:24.620] - result already collected: FutureResult
[09:28:24.620] result() for ClusterFuture ... done
[09:28:24.620] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:24.620] Future #2
[09:28:24.620] result() for ClusterFuture ...
[09:28:24.620] - result already collected: FutureResult
[09:28:24.620] result() for ClusterFuture ... done
[09:28:24.620] result() for ClusterFuture ...
[09:28:24.621] - result already collected: FutureResult
[09:28:24.621] result() for ClusterFuture ... done
[09:28:24.621] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:24.621] - nx: 2
[09:28:24.621] - relay: TRUE
[09:28:24.624] - stdout: TRUE
[09:28:24.624] - signal: TRUE
[09:28:24.624] - resignal: FALSE
[09:28:24.624] - force: TRUE
[09:28:24.624] - relayed: [n=2] TRUE, FALSE
[09:28:24.624] - queued futures: [n=2] TRUE, FALSE
[09:28:24.624]  - until=2
[09:28:24.624]  - relaying element #2
[09:28:24.625] result() for ClusterFuture ...
[09:28:24.625] - result already collected: FutureResult
[09:28:24.625] result() for ClusterFuture ... done
[09:28:24.625] result() for ClusterFuture ...
[09:28:24.625] - result already collected: FutureResult
[09:28:24.625] result() for ClusterFuture ... done
[09:28:24.625] result() for ClusterFuture ...
[09:28:24.625] - result already collected: FutureResult
[09:28:24.625] result() for ClusterFuture ... done
[09:28:24.625] result() for ClusterFuture ...
[09:28:24.625] - result already collected: FutureResult
[09:28:24.625] result() for ClusterFuture ... done
[09:28:24.626] - relayed: [n=2] TRUE, TRUE
[09:28:24.626] - queued futures: [n=2] TRUE, TRUE
[09:28:24.626] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:24.626]  length: 0 (resolved future 2)
[09:28:24.626] Relaying remaining futures
[09:28:24.626] signalConditionsASAP(NULL, pos=0) ...
[09:28:24.626] - nx: 2
[09:28:24.626] - relay: TRUE
[09:28:24.626] - stdout: TRUE
[09:28:24.626] - signal: TRUE
[09:28:24.626] - resignal: FALSE
[09:28:24.626] - force: TRUE
[09:28:24.627] - relayed: [n=2] TRUE, TRUE
[09:28:24.627] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:24.627] - relayed: [n=2] TRUE, TRUE
[09:28:24.627] - queued futures: [n=2] TRUE, TRUE
[09:28:24.627] signalConditionsASAP(NULL, pos=0) ... done
[09:28:24.627] resolve() on list ... DONE
[09:28:24.627] result() for ClusterFuture ...
[09:28:24.627] - result already collected: FutureResult
[09:28:24.627] result() for ClusterFuture ... done
[09:28:24.627] result() for ClusterFuture ...
[09:28:24.627] - result already collected: FutureResult
[09:28:24.627] result() for ClusterFuture ... done
[09:28:24.628] result() for ClusterFuture ...
[09:28:24.628] - result already collected: FutureResult
[09:28:24.628] result() for ClusterFuture ... done
[09:28:24.628] result() for ClusterFuture ...
[09:28:24.628] - result already collected: FutureResult
[09:28:24.628] result() for ClusterFuture ... done
[09:28:24.628]  - Number of value chunks collected: 2
[09:28:24.628] Resolving 2 futures (chunks) ... DONE
[09:28:24.628] Reducing values from 2 chunks ...
[09:28:24.628]  - Number of values collected after concatenation: 3
[09:28:24.628]  - Number of values expected: 3
[09:28:24.629] Reducing values from 2 chunks ... DONE
[09:28:24.629] future_lapply() ... DONE
[09:28:24.629] future_by_internal() ... DONE
[09:28:24.629] future_by_internal() ...
[09:28:24.629] future_lapply() ...
[09:28:24.633] Number of chunks: 2
[09:28:24.634] getGlobalsAndPackagesXApply() ...
[09:28:24.634]  - future.globals: TRUE
[09:28:24.634] getGlobalsAndPackages() ...
[09:28:24.634] Searching for globals...
[09:28:24.635] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:24.635] Searching for globals ... DONE
[09:28:24.635] Resolving globals: FALSE
[09:28:24.635] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:24.636] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:24.636] - globals: [1] ‘FUN’
[09:28:24.636] 
[09:28:24.636] getGlobalsAndPackages() ... DONE
[09:28:24.636]  - globals found/used: [n=1] ‘FUN’
[09:28:24.636]  - needed namespaces: [n=0] 
[09:28:24.636] Finding globals ... DONE
[09:28:24.637]  - use_args: TRUE
[09:28:24.637]  - Getting '...' globals ...
[09:28:24.637] resolve() on list ...
[09:28:24.637]  recursive: 0
[09:28:24.637]  length: 1
[09:28:24.637]  elements: ‘...’
[09:28:24.637]  length: 0 (resolved future 1)
[09:28:24.637] resolve() on list ... DONE
[09:28:24.637]    - '...' content: [n=1] ‘digits’
[09:28:24.638] List of 1
[09:28:24.638]  $ ...:List of 1
[09:28:24.638]   ..$ digits: int 2
[09:28:24.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:24.638]  - attr(*, "where")=List of 1
[09:28:24.638]   ..$ ...:<environment: 0x555b0a944fd0> 
[09:28:24.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:24.638]  - attr(*, "resolved")= logi TRUE
[09:28:24.638]  - attr(*, "total_size")= num NA
[09:28:24.641]  - Getting '...' globals ... DONE
[09:28:24.641] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:24.641] List of 2
[09:28:24.641]  $ ...future.FUN:function (object, ...)  
[09:28:24.641]  $ ...          :List of 1
[09:28:24.641]   ..$ digits: int 2
[09:28:24.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:24.641]  - attr(*, "where")=List of 2
[09:28:24.641]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:24.641]   ..$ ...          :<environment: 0x555b0a944fd0> 
[09:28:24.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:24.641]  - attr(*, "resolved")= logi FALSE
[09:28:24.641]  - attr(*, "total_size")= num 1296
[09:28:24.644] Packages to be attached in all futures: [n=0] 
[09:28:24.644] getGlobalsAndPackagesXApply() ... DONE
[09:28:24.644] Number of futures (= number of chunks): 2
[09:28:24.644] Launching 2 futures (chunks) ...
[09:28:24.644] Chunk #1 of 2 ...
[09:28:24.644]  - Finding globals in 'X' for chunk #1 ...
[09:28:24.644] getGlobalsAndPackages() ...
[09:28:24.645] Searching for globals...
[09:28:24.645] 
[09:28:24.645] Searching for globals ... DONE
[09:28:24.645] - globals: [0] <none>
[09:28:24.645] getGlobalsAndPackages() ... DONE
[09:28:24.645]    + additional globals found: [n=0] 
[09:28:24.645]    + additional namespaces needed: [n=0] 
[09:28:24.645]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:24.645]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:24.645]  - seeds: <none>
[09:28:24.646]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.646] getGlobalsAndPackages() ...
[09:28:24.646] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.646] Resolving globals: FALSE
[09:28:24.646] Tweak future expression to call with '...' arguments ...
[09:28:24.646] {
[09:28:24.646]     do.call(function(...) {
[09:28:24.646]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.646]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.646]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.646]             on.exit(options(oopts), add = TRUE)
[09:28:24.646]         }
[09:28:24.646]         {
[09:28:24.646]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.646]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.646]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.646]             })
[09:28:24.646]         }
[09:28:24.646]     }, args = future.call.arguments)
[09:28:24.646] }
[09:28:24.646] Tweak future expression to call with '...' arguments ... DONE
[09:28:24.647] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.647] 
[09:28:24.647] getGlobalsAndPackages() ... DONE
[09:28:24.647] run() for ‘Future’ ...
[09:28:24.647] - state: ‘created’
[09:28:24.647] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:24.661] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.661] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:24.662]   - Field: ‘node’
[09:28:24.662]   - Field: ‘label’
[09:28:24.662]   - Field: ‘local’
[09:28:24.662]   - Field: ‘owner’
[09:28:24.662]   - Field: ‘envir’
[09:28:24.662]   - Field: ‘workers’
[09:28:24.662]   - Field: ‘packages’
[09:28:24.662]   - Field: ‘gc’
[09:28:24.662]   - Field: ‘conditions’
[09:28:24.662]   - Field: ‘persistent’
[09:28:24.662]   - Field: ‘expr’
[09:28:24.663]   - Field: ‘uuid’
[09:28:24.663]   - Field: ‘seed’
[09:28:24.663]   - Field: ‘version’
[09:28:24.663]   - Field: ‘result’
[09:28:24.663]   - Field: ‘asynchronous’
[09:28:24.663]   - Field: ‘calls’
[09:28:24.663]   - Field: ‘globals’
[09:28:24.663]   - Field: ‘stdout’
[09:28:24.663]   - Field: ‘earlySignal’
[09:28:24.663]   - Field: ‘lazy’
[09:28:24.663]   - Field: ‘state’
[09:28:24.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:24.664] - Launch lazy future ...
[09:28:24.664] Packages needed by the future expression (n = 0): <none>
[09:28:24.664] Packages needed by future strategies (n = 0): <none>
[09:28:24.664] {
[09:28:24.664]     {
[09:28:24.664]         {
[09:28:24.664]             ...future.startTime <- base::Sys.time()
[09:28:24.664]             {
[09:28:24.664]                 {
[09:28:24.664]                   {
[09:28:24.664]                     {
[09:28:24.664]                       base::local({
[09:28:24.664]                         has_future <- base::requireNamespace("future", 
[09:28:24.664]                           quietly = TRUE)
[09:28:24.664]                         if (has_future) {
[09:28:24.664]                           ns <- base::getNamespace("future")
[09:28:24.664]                           version <- ns[[".package"]][["version"]]
[09:28:24.664]                           if (is.null(version)) 
[09:28:24.664]                             version <- utils::packageVersion("future")
[09:28:24.664]                         }
[09:28:24.664]                         else {
[09:28:24.664]                           version <- NULL
[09:28:24.664]                         }
[09:28:24.664]                         if (!has_future || version < "1.8.0") {
[09:28:24.664]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:24.664]                             "", base::R.version$version.string), 
[09:28:24.664]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:24.664]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:24.664]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:24.664]                               "release", "version")], collapse = " "), 
[09:28:24.664]                             hostname = base::Sys.info()[["nodename"]])
[09:28:24.664]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:24.664]                             info)
[09:28:24.664]                           info <- base::paste(info, collapse = "; ")
[09:28:24.664]                           if (!has_future) {
[09:28:24.664]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:24.664]                               info)
[09:28:24.664]                           }
[09:28:24.664]                           else {
[09:28:24.664]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:24.664]                               info, version)
[09:28:24.664]                           }
[09:28:24.664]                           base::stop(msg)
[09:28:24.664]                         }
[09:28:24.664]                       })
[09:28:24.664]                     }
[09:28:24.664]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:24.664]                     base::options(mc.cores = 1L)
[09:28:24.664]                   }
[09:28:24.664]                   ...future.strategy.old <- future::plan("list")
[09:28:24.664]                   options(future.plan = NULL)
[09:28:24.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:24.664]                 }
[09:28:24.664]                 ...future.workdir <- getwd()
[09:28:24.664]             }
[09:28:24.664]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:24.664]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:24.664]         }
[09:28:24.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:24.664]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:24.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:24.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:24.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:24.664]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:24.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:24.664]             base::names(...future.oldOptions))
[09:28:24.664]     }
[09:28:24.664]     if (FALSE) {
[09:28:24.664]     }
[09:28:24.664]     else {
[09:28:24.664]         if (TRUE) {
[09:28:24.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:24.664]                 open = "w")
[09:28:24.664]         }
[09:28:24.664]         else {
[09:28:24.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:24.664]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:24.664]         }
[09:28:24.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:24.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:24.664]             base::sink(type = "output", split = FALSE)
[09:28:24.664]             base::close(...future.stdout)
[09:28:24.664]         }, add = TRUE)
[09:28:24.664]     }
[09:28:24.664]     ...future.frame <- base::sys.nframe()
[09:28:24.664]     ...future.conditions <- base::list()
[09:28:24.664]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:24.664]     if (FALSE) {
[09:28:24.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:24.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:24.664]     }
[09:28:24.664]     ...future.result <- base::tryCatch({
[09:28:24.664]         base::withCallingHandlers({
[09:28:24.664]             ...future.value <- base::withVisible(base::local({
[09:28:24.664]                 ...future.makeSendCondition <- base::local({
[09:28:24.664]                   sendCondition <- NULL
[09:28:24.664]                   function(frame = 1L) {
[09:28:24.664]                     if (is.function(sendCondition)) 
[09:28:24.664]                       return(sendCondition)
[09:28:24.664]                     ns <- getNamespace("parallel")
[09:28:24.664]                     if (exists("sendData", mode = "function", 
[09:28:24.664]                       envir = ns)) {
[09:28:24.664]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:24.664]                         envir = ns)
[09:28:24.664]                       envir <- sys.frame(frame)
[09:28:24.664]                       master <- NULL
[09:28:24.664]                       while (!identical(envir, .GlobalEnv) && 
[09:28:24.664]                         !identical(envir, emptyenv())) {
[09:28:24.664]                         if (exists("master", mode = "list", envir = envir, 
[09:28:24.664]                           inherits = FALSE)) {
[09:28:24.664]                           master <- get("master", mode = "list", 
[09:28:24.664]                             envir = envir, inherits = FALSE)
[09:28:24.664]                           if (inherits(master, c("SOCKnode", 
[09:28:24.664]                             "SOCK0node"))) {
[09:28:24.664]                             sendCondition <<- function(cond) {
[09:28:24.664]                               data <- list(type = "VALUE", value = cond, 
[09:28:24.664]                                 success = TRUE)
[09:28:24.664]                               parallel_sendData(master, data)
[09:28:24.664]                             }
[09:28:24.664]                             return(sendCondition)
[09:28:24.664]                           }
[09:28:24.664]                         }
[09:28:24.664]                         frame <- frame + 1L
[09:28:24.664]                         envir <- sys.frame(frame)
[09:28:24.664]                       }
[09:28:24.664]                     }
[09:28:24.664]                     sendCondition <<- function(cond) NULL
[09:28:24.664]                   }
[09:28:24.664]                 })
[09:28:24.664]                 withCallingHandlers({
[09:28:24.664]                   {
[09:28:24.664]                     do.call(function(...) {
[09:28:24.664]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.664]                       if (!identical(...future.globals.maxSize.org, 
[09:28:24.664]                         ...future.globals.maxSize)) {
[09:28:24.664]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.664]                         on.exit(options(oopts), add = TRUE)
[09:28:24.664]                       }
[09:28:24.664]                       {
[09:28:24.664]                         lapply(seq_along(...future.elements_ii), 
[09:28:24.664]                           FUN = function(jj) {
[09:28:24.664]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.664]                             ...future.FUN(...future.X_jj, ...)
[09:28:24.664]                           })
[09:28:24.664]                       }
[09:28:24.664]                     }, args = future.call.arguments)
[09:28:24.664]                   }
[09:28:24.664]                 }, immediateCondition = function(cond) {
[09:28:24.664]                   sendCondition <- ...future.makeSendCondition()
[09:28:24.664]                   sendCondition(cond)
[09:28:24.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.664]                   {
[09:28:24.664]                     inherits <- base::inherits
[09:28:24.664]                     invokeRestart <- base::invokeRestart
[09:28:24.664]                     is.null <- base::is.null
[09:28:24.664]                     muffled <- FALSE
[09:28:24.664]                     if (inherits(cond, "message")) {
[09:28:24.664]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:24.664]                       if (muffled) 
[09:28:24.664]                         invokeRestart("muffleMessage")
[09:28:24.664]                     }
[09:28:24.664]                     else if (inherits(cond, "warning")) {
[09:28:24.664]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:24.664]                       if (muffled) 
[09:28:24.664]                         invokeRestart("muffleWarning")
[09:28:24.664]                     }
[09:28:24.664]                     else if (inherits(cond, "condition")) {
[09:28:24.664]                       if (!is.null(pattern)) {
[09:28:24.664]                         computeRestarts <- base::computeRestarts
[09:28:24.664]                         grepl <- base::grepl
[09:28:24.664]                         restarts <- computeRestarts(cond)
[09:28:24.664]                         for (restart in restarts) {
[09:28:24.664]                           name <- restart$name
[09:28:24.664]                           if (is.null(name)) 
[09:28:24.664]                             next
[09:28:24.664]                           if (!grepl(pattern, name)) 
[09:28:24.664]                             next
[09:28:24.664]                           invokeRestart(restart)
[09:28:24.664]                           muffled <- TRUE
[09:28:24.664]                           break
[09:28:24.664]                         }
[09:28:24.664]                       }
[09:28:24.664]                     }
[09:28:24.664]                     invisible(muffled)
[09:28:24.664]                   }
[09:28:24.664]                   muffleCondition(cond)
[09:28:24.664]                 })
[09:28:24.664]             }))
[09:28:24.664]             future::FutureResult(value = ...future.value$value, 
[09:28:24.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.664]                   ...future.rng), globalenv = if (FALSE) 
[09:28:24.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:24.664]                     ...future.globalenv.names))
[09:28:24.664]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:24.664]         }, condition = base::local({
[09:28:24.664]             c <- base::c
[09:28:24.664]             inherits <- base::inherits
[09:28:24.664]             invokeRestart <- base::invokeRestart
[09:28:24.664]             length <- base::length
[09:28:24.664]             list <- base::list
[09:28:24.664]             seq.int <- base::seq.int
[09:28:24.664]             signalCondition <- base::signalCondition
[09:28:24.664]             sys.calls <- base::sys.calls
[09:28:24.664]             `[[` <- base::`[[`
[09:28:24.664]             `+` <- base::`+`
[09:28:24.664]             `<<-` <- base::`<<-`
[09:28:24.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:24.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:24.664]                   3L)]
[09:28:24.664]             }
[09:28:24.664]             function(cond) {
[09:28:24.664]                 is_error <- inherits(cond, "error")
[09:28:24.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:24.664]                   NULL)
[09:28:24.664]                 if (is_error) {
[09:28:24.664]                   sessionInformation <- function() {
[09:28:24.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:24.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:24.664]                       search = base::search(), system = base::Sys.info())
[09:28:24.664]                   }
[09:28:24.664]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:24.664]                     cond$call), session = sessionInformation(), 
[09:28:24.664]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:24.664]                   signalCondition(cond)
[09:28:24.664]                 }
[09:28:24.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:24.664]                 "immediateCondition"))) {
[09:28:24.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:24.664]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:24.664]                   if (TRUE && !signal) {
[09:28:24.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.664]                     {
[09:28:24.664]                       inherits <- base::inherits
[09:28:24.664]                       invokeRestart <- base::invokeRestart
[09:28:24.664]                       is.null <- base::is.null
[09:28:24.664]                       muffled <- FALSE
[09:28:24.664]                       if (inherits(cond, "message")) {
[09:28:24.664]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.664]                         if (muffled) 
[09:28:24.664]                           invokeRestart("muffleMessage")
[09:28:24.664]                       }
[09:28:24.664]                       else if (inherits(cond, "warning")) {
[09:28:24.664]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.664]                         if (muffled) 
[09:28:24.664]                           invokeRestart("muffleWarning")
[09:28:24.664]                       }
[09:28:24.664]                       else if (inherits(cond, "condition")) {
[09:28:24.664]                         if (!is.null(pattern)) {
[09:28:24.664]                           computeRestarts <- base::computeRestarts
[09:28:24.664]                           grepl <- base::grepl
[09:28:24.664]                           restarts <- computeRestarts(cond)
[09:28:24.664]                           for (restart in restarts) {
[09:28:24.664]                             name <- restart$name
[09:28:24.664]                             if (is.null(name)) 
[09:28:24.664]                               next
[09:28:24.664]                             if (!grepl(pattern, name)) 
[09:28:24.664]                               next
[09:28:24.664]                             invokeRestart(restart)
[09:28:24.664]                             muffled <- TRUE
[09:28:24.664]                             break
[09:28:24.664]                           }
[09:28:24.664]                         }
[09:28:24.664]                       }
[09:28:24.664]                       invisible(muffled)
[09:28:24.664]                     }
[09:28:24.664]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.664]                   }
[09:28:24.664]                 }
[09:28:24.664]                 else {
[09:28:24.664]                   if (TRUE) {
[09:28:24.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.664]                     {
[09:28:24.664]                       inherits <- base::inherits
[09:28:24.664]                       invokeRestart <- base::invokeRestart
[09:28:24.664]                       is.null <- base::is.null
[09:28:24.664]                       muffled <- FALSE
[09:28:24.664]                       if (inherits(cond, "message")) {
[09:28:24.664]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.664]                         if (muffled) 
[09:28:24.664]                           invokeRestart("muffleMessage")
[09:28:24.664]                       }
[09:28:24.664]                       else if (inherits(cond, "warning")) {
[09:28:24.664]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.664]                         if (muffled) 
[09:28:24.664]                           invokeRestart("muffleWarning")
[09:28:24.664]                       }
[09:28:24.664]                       else if (inherits(cond, "condition")) {
[09:28:24.664]                         if (!is.null(pattern)) {
[09:28:24.664]                           computeRestarts <- base::computeRestarts
[09:28:24.664]                           grepl <- base::grepl
[09:28:24.664]                           restarts <- computeRestarts(cond)
[09:28:24.664]                           for (restart in restarts) {
[09:28:24.664]                             name <- restart$name
[09:28:24.664]                             if (is.null(name)) 
[09:28:24.664]                               next
[09:28:24.664]                             if (!grepl(pattern, name)) 
[09:28:24.664]                               next
[09:28:24.664]                             invokeRestart(restart)
[09:28:24.664]                             muffled <- TRUE
[09:28:24.664]                             break
[09:28:24.664]                           }
[09:28:24.664]                         }
[09:28:24.664]                       }
[09:28:24.664]                       invisible(muffled)
[09:28:24.664]                     }
[09:28:24.664]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.664]                   }
[09:28:24.664]                 }
[09:28:24.664]             }
[09:28:24.664]         }))
[09:28:24.664]     }, error = function(ex) {
[09:28:24.664]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:24.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.664]                 ...future.rng), started = ...future.startTime, 
[09:28:24.664]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:24.664]             version = "1.8"), class = "FutureResult")
[09:28:24.664]     }, finally = {
[09:28:24.664]         if (!identical(...future.workdir, getwd())) 
[09:28:24.664]             setwd(...future.workdir)
[09:28:24.664]         {
[09:28:24.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:24.664]                 ...future.oldOptions$nwarnings <- NULL
[09:28:24.664]             }
[09:28:24.664]             base::options(...future.oldOptions)
[09:28:24.664]             if (.Platform$OS.type == "windows") {
[09:28:24.664]                 old_names <- names(...future.oldEnvVars)
[09:28:24.664]                 envs <- base::Sys.getenv()
[09:28:24.664]                 names <- names(envs)
[09:28:24.664]                 common <- intersect(names, old_names)
[09:28:24.664]                 added <- setdiff(names, old_names)
[09:28:24.664]                 removed <- setdiff(old_names, names)
[09:28:24.664]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:24.664]                   envs[common]]
[09:28:24.664]                 NAMES <- toupper(changed)
[09:28:24.664]                 args <- list()
[09:28:24.664]                 for (kk in seq_along(NAMES)) {
[09:28:24.664]                   name <- changed[[kk]]
[09:28:24.664]                   NAME <- NAMES[[kk]]
[09:28:24.664]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.664]                     next
[09:28:24.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.664]                 }
[09:28:24.664]                 NAMES <- toupper(added)
[09:28:24.664]                 for (kk in seq_along(NAMES)) {
[09:28:24.664]                   name <- added[[kk]]
[09:28:24.664]                   NAME <- NAMES[[kk]]
[09:28:24.664]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.664]                     next
[09:28:24.664]                   args[[name]] <- ""
[09:28:24.664]                 }
[09:28:24.664]                 NAMES <- toupper(removed)
[09:28:24.664]                 for (kk in seq_along(NAMES)) {
[09:28:24.664]                   name <- removed[[kk]]
[09:28:24.664]                   NAME <- NAMES[[kk]]
[09:28:24.664]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.664]                     next
[09:28:24.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.664]                 }
[09:28:24.664]                 if (length(args) > 0) 
[09:28:24.664]                   base::do.call(base::Sys.setenv, args = args)
[09:28:24.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:24.664]             }
[09:28:24.664]             else {
[09:28:24.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:24.664]             }
[09:28:24.664]             {
[09:28:24.664]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:24.664]                   0L) {
[09:28:24.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:24.664]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:24.664]                   base::options(opts)
[09:28:24.664]                 }
[09:28:24.664]                 {
[09:28:24.664]                   {
[09:28:24.664]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:24.664]                     NULL
[09:28:24.664]                   }
[09:28:24.664]                   options(future.plan = NULL)
[09:28:24.664]                   if (is.na(NA_character_)) 
[09:28:24.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:24.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:24.664]                     .init = FALSE)
[09:28:24.664]                 }
[09:28:24.664]             }
[09:28:24.664]         }
[09:28:24.664]     })
[09:28:24.664]     if (TRUE) {
[09:28:24.664]         base::sink(type = "output", split = FALSE)
[09:28:24.664]         if (TRUE) {
[09:28:24.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:24.664]         }
[09:28:24.664]         else {
[09:28:24.664]             ...future.result["stdout"] <- base::list(NULL)
[09:28:24.664]         }
[09:28:24.664]         base::close(...future.stdout)
[09:28:24.664]         ...future.stdout <- NULL
[09:28:24.664]     }
[09:28:24.664]     ...future.result$conditions <- ...future.conditions
[09:28:24.664]     ...future.result$finished <- base::Sys.time()
[09:28:24.664]     ...future.result
[09:28:24.664] }
[09:28:24.667] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[09:28:24.667] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[09:28:24.668] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[09:28:24.668] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[09:28:24.668] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[09:28:24.668] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[09:28:24.669] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[09:28:24.669] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:24.669] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:24.669] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:28:24.670] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:28:24.670] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[09:28:24.670] MultisessionFuture started
[09:28:24.671] - Launch lazy future ... done
[09:28:24.671] run() for ‘MultisessionFuture’ ... done
[09:28:24.671] Created future:
[09:28:24.671] MultisessionFuture:
[09:28:24.671] Label: ‘future_by-1’
[09:28:24.671] Expression:
[09:28:24.671] {
[09:28:24.671]     do.call(function(...) {
[09:28:24.671]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.671]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.671]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.671]             on.exit(options(oopts), add = TRUE)
[09:28:24.671]         }
[09:28:24.671]         {
[09:28:24.671]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.671]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.671]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.671]             })
[09:28:24.671]         }
[09:28:24.671]     }, args = future.call.arguments)
[09:28:24.671] }
[09:28:24.671] Lazy evaluation: FALSE
[09:28:24.671] Asynchronous evaluation: TRUE
[09:28:24.671] Local evaluation: TRUE
[09:28:24.671] Environment: R_GlobalEnv
[09:28:24.671] Capture standard output: TRUE
[09:28:24.671] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:24.671] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:24.671] Packages: <none>
[09:28:24.671] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:24.671] Resolved: FALSE
[09:28:24.671] Value: <not collected>
[09:28:24.671] Conditions captured: <none>
[09:28:24.671] Early signaling: FALSE
[09:28:24.671] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:24.671] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.683] Chunk #1 of 2 ... DONE
[09:28:24.683] Chunk #2 of 2 ...
[09:28:24.683]  - Finding globals in 'X' for chunk #2 ...
[09:28:24.683] getGlobalsAndPackages() ...
[09:28:24.683] Searching for globals...
[09:28:24.683] 
[09:28:24.683] Searching for globals ... DONE
[09:28:24.683] - globals: [0] <none>
[09:28:24.684] getGlobalsAndPackages() ... DONE
[09:28:24.684]    + additional globals found: [n=0] 
[09:28:24.684]    + additional namespaces needed: [n=0] 
[09:28:24.684]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:24.684]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:24.684]  - seeds: <none>
[09:28:24.684]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.684] getGlobalsAndPackages() ...
[09:28:24.684] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.684] Resolving globals: FALSE
[09:28:24.685] Tweak future expression to call with '...' arguments ...
[09:28:24.685] {
[09:28:24.685]     do.call(function(...) {
[09:28:24.685]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.685]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.685]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.685]             on.exit(options(oopts), add = TRUE)
[09:28:24.685]         }
[09:28:24.685]         {
[09:28:24.685]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.685]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.685]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.685]             })
[09:28:24.685]         }
[09:28:24.685]     }, args = future.call.arguments)
[09:28:24.685] }
[09:28:24.685] Tweak future expression to call with '...' arguments ... DONE
[09:28:24.685] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.685] 
[09:28:24.685] getGlobalsAndPackages() ... DONE
[09:28:24.686] run() for ‘Future’ ...
[09:28:24.686] - state: ‘created’
[09:28:24.686] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:24.699] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:24.699]   - Field: ‘node’
[09:28:24.700]   - Field: ‘label’
[09:28:24.700]   - Field: ‘local’
[09:28:24.700]   - Field: ‘owner’
[09:28:24.700]   - Field: ‘envir’
[09:28:24.700]   - Field: ‘workers’
[09:28:24.700]   - Field: ‘packages’
[09:28:24.700]   - Field: ‘gc’
[09:28:24.700]   - Field: ‘conditions’
[09:28:24.700]   - Field: ‘persistent’
[09:28:24.700]   - Field: ‘expr’
[09:28:24.701]   - Field: ‘uuid’
[09:28:24.701]   - Field: ‘seed’
[09:28:24.701]   - Field: ‘version’
[09:28:24.701]   - Field: ‘result’
[09:28:24.701]   - Field: ‘asynchronous’
[09:28:24.701]   - Field: ‘calls’
[09:28:24.701]   - Field: ‘globals’
[09:28:24.701]   - Field: ‘stdout’
[09:28:24.701]   - Field: ‘earlySignal’
[09:28:24.701]   - Field: ‘lazy’
[09:28:24.701]   - Field: ‘state’
[09:28:24.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:24.702] - Launch lazy future ...
[09:28:24.702] Packages needed by the future expression (n = 0): <none>
[09:28:24.702] Packages needed by future strategies (n = 0): <none>
[09:28:24.702] {
[09:28:24.702]     {
[09:28:24.702]         {
[09:28:24.702]             ...future.startTime <- base::Sys.time()
[09:28:24.702]             {
[09:28:24.702]                 {
[09:28:24.702]                   {
[09:28:24.702]                     {
[09:28:24.702]                       base::local({
[09:28:24.702]                         has_future <- base::requireNamespace("future", 
[09:28:24.702]                           quietly = TRUE)
[09:28:24.702]                         if (has_future) {
[09:28:24.702]                           ns <- base::getNamespace("future")
[09:28:24.702]                           version <- ns[[".package"]][["version"]]
[09:28:24.702]                           if (is.null(version)) 
[09:28:24.702]                             version <- utils::packageVersion("future")
[09:28:24.702]                         }
[09:28:24.702]                         else {
[09:28:24.702]                           version <- NULL
[09:28:24.702]                         }
[09:28:24.702]                         if (!has_future || version < "1.8.0") {
[09:28:24.702]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:24.702]                             "", base::R.version$version.string), 
[09:28:24.702]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:24.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:24.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:24.702]                               "release", "version")], collapse = " "), 
[09:28:24.702]                             hostname = base::Sys.info()[["nodename"]])
[09:28:24.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:24.702]                             info)
[09:28:24.702]                           info <- base::paste(info, collapse = "; ")
[09:28:24.702]                           if (!has_future) {
[09:28:24.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:24.702]                               info)
[09:28:24.702]                           }
[09:28:24.702]                           else {
[09:28:24.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:24.702]                               info, version)
[09:28:24.702]                           }
[09:28:24.702]                           base::stop(msg)
[09:28:24.702]                         }
[09:28:24.702]                       })
[09:28:24.702]                     }
[09:28:24.702]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:24.702]                     base::options(mc.cores = 1L)
[09:28:24.702]                   }
[09:28:24.702]                   ...future.strategy.old <- future::plan("list")
[09:28:24.702]                   options(future.plan = NULL)
[09:28:24.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:24.702]                 }
[09:28:24.702]                 ...future.workdir <- getwd()
[09:28:24.702]             }
[09:28:24.702]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:24.702]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:24.702]         }
[09:28:24.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:24.702]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:24.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:24.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:24.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:24.702]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:24.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:24.702]             base::names(...future.oldOptions))
[09:28:24.702]     }
[09:28:24.702]     if (FALSE) {
[09:28:24.702]     }
[09:28:24.702]     else {
[09:28:24.702]         if (TRUE) {
[09:28:24.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:24.702]                 open = "w")
[09:28:24.702]         }
[09:28:24.702]         else {
[09:28:24.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:24.702]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:24.702]         }
[09:28:24.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:24.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:24.702]             base::sink(type = "output", split = FALSE)
[09:28:24.702]             base::close(...future.stdout)
[09:28:24.702]         }, add = TRUE)
[09:28:24.702]     }
[09:28:24.702]     ...future.frame <- base::sys.nframe()
[09:28:24.702]     ...future.conditions <- base::list()
[09:28:24.702]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:24.702]     if (FALSE) {
[09:28:24.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:24.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:24.702]     }
[09:28:24.702]     ...future.result <- base::tryCatch({
[09:28:24.702]         base::withCallingHandlers({
[09:28:24.702]             ...future.value <- base::withVisible(base::local({
[09:28:24.702]                 ...future.makeSendCondition <- base::local({
[09:28:24.702]                   sendCondition <- NULL
[09:28:24.702]                   function(frame = 1L) {
[09:28:24.702]                     if (is.function(sendCondition)) 
[09:28:24.702]                       return(sendCondition)
[09:28:24.702]                     ns <- getNamespace("parallel")
[09:28:24.702]                     if (exists("sendData", mode = "function", 
[09:28:24.702]                       envir = ns)) {
[09:28:24.702]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:24.702]                         envir = ns)
[09:28:24.702]                       envir <- sys.frame(frame)
[09:28:24.702]                       master <- NULL
[09:28:24.702]                       while (!identical(envir, .GlobalEnv) && 
[09:28:24.702]                         !identical(envir, emptyenv())) {
[09:28:24.702]                         if (exists("master", mode = "list", envir = envir, 
[09:28:24.702]                           inherits = FALSE)) {
[09:28:24.702]                           master <- get("master", mode = "list", 
[09:28:24.702]                             envir = envir, inherits = FALSE)
[09:28:24.702]                           if (inherits(master, c("SOCKnode", 
[09:28:24.702]                             "SOCK0node"))) {
[09:28:24.702]                             sendCondition <<- function(cond) {
[09:28:24.702]                               data <- list(type = "VALUE", value = cond, 
[09:28:24.702]                                 success = TRUE)
[09:28:24.702]                               parallel_sendData(master, data)
[09:28:24.702]                             }
[09:28:24.702]                             return(sendCondition)
[09:28:24.702]                           }
[09:28:24.702]                         }
[09:28:24.702]                         frame <- frame + 1L
[09:28:24.702]                         envir <- sys.frame(frame)
[09:28:24.702]                       }
[09:28:24.702]                     }
[09:28:24.702]                     sendCondition <<- function(cond) NULL
[09:28:24.702]                   }
[09:28:24.702]                 })
[09:28:24.702]                 withCallingHandlers({
[09:28:24.702]                   {
[09:28:24.702]                     do.call(function(...) {
[09:28:24.702]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.702]                       if (!identical(...future.globals.maxSize.org, 
[09:28:24.702]                         ...future.globals.maxSize)) {
[09:28:24.702]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.702]                         on.exit(options(oopts), add = TRUE)
[09:28:24.702]                       }
[09:28:24.702]                       {
[09:28:24.702]                         lapply(seq_along(...future.elements_ii), 
[09:28:24.702]                           FUN = function(jj) {
[09:28:24.702]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.702]                             ...future.FUN(...future.X_jj, ...)
[09:28:24.702]                           })
[09:28:24.702]                       }
[09:28:24.702]                     }, args = future.call.arguments)
[09:28:24.702]                   }
[09:28:24.702]                 }, immediateCondition = function(cond) {
[09:28:24.702]                   sendCondition <- ...future.makeSendCondition()
[09:28:24.702]                   sendCondition(cond)
[09:28:24.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.702]                   {
[09:28:24.702]                     inherits <- base::inherits
[09:28:24.702]                     invokeRestart <- base::invokeRestart
[09:28:24.702]                     is.null <- base::is.null
[09:28:24.702]                     muffled <- FALSE
[09:28:24.702]                     if (inherits(cond, "message")) {
[09:28:24.702]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:24.702]                       if (muffled) 
[09:28:24.702]                         invokeRestart("muffleMessage")
[09:28:24.702]                     }
[09:28:24.702]                     else if (inherits(cond, "warning")) {
[09:28:24.702]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:24.702]                       if (muffled) 
[09:28:24.702]                         invokeRestart("muffleWarning")
[09:28:24.702]                     }
[09:28:24.702]                     else if (inherits(cond, "condition")) {
[09:28:24.702]                       if (!is.null(pattern)) {
[09:28:24.702]                         computeRestarts <- base::computeRestarts
[09:28:24.702]                         grepl <- base::grepl
[09:28:24.702]                         restarts <- computeRestarts(cond)
[09:28:24.702]                         for (restart in restarts) {
[09:28:24.702]                           name <- restart$name
[09:28:24.702]                           if (is.null(name)) 
[09:28:24.702]                             next
[09:28:24.702]                           if (!grepl(pattern, name)) 
[09:28:24.702]                             next
[09:28:24.702]                           invokeRestart(restart)
[09:28:24.702]                           muffled <- TRUE
[09:28:24.702]                           break
[09:28:24.702]                         }
[09:28:24.702]                       }
[09:28:24.702]                     }
[09:28:24.702]                     invisible(muffled)
[09:28:24.702]                   }
[09:28:24.702]                   muffleCondition(cond)
[09:28:24.702]                 })
[09:28:24.702]             }))
[09:28:24.702]             future::FutureResult(value = ...future.value$value, 
[09:28:24.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.702]                   ...future.rng), globalenv = if (FALSE) 
[09:28:24.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:24.702]                     ...future.globalenv.names))
[09:28:24.702]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:24.702]         }, condition = base::local({
[09:28:24.702]             c <- base::c
[09:28:24.702]             inherits <- base::inherits
[09:28:24.702]             invokeRestart <- base::invokeRestart
[09:28:24.702]             length <- base::length
[09:28:24.702]             list <- base::list
[09:28:24.702]             seq.int <- base::seq.int
[09:28:24.702]             signalCondition <- base::signalCondition
[09:28:24.702]             sys.calls <- base::sys.calls
[09:28:24.702]             `[[` <- base::`[[`
[09:28:24.702]             `+` <- base::`+`
[09:28:24.702]             `<<-` <- base::`<<-`
[09:28:24.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:24.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:24.702]                   3L)]
[09:28:24.702]             }
[09:28:24.702]             function(cond) {
[09:28:24.702]                 is_error <- inherits(cond, "error")
[09:28:24.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:24.702]                   NULL)
[09:28:24.702]                 if (is_error) {
[09:28:24.702]                   sessionInformation <- function() {
[09:28:24.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:24.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:24.702]                       search = base::search(), system = base::Sys.info())
[09:28:24.702]                   }
[09:28:24.702]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:24.702]                     cond$call), session = sessionInformation(), 
[09:28:24.702]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:24.702]                   signalCondition(cond)
[09:28:24.702]                 }
[09:28:24.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:24.702]                 "immediateCondition"))) {
[09:28:24.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:24.702]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:24.702]                   if (TRUE && !signal) {
[09:28:24.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.702]                     {
[09:28:24.702]                       inherits <- base::inherits
[09:28:24.702]                       invokeRestart <- base::invokeRestart
[09:28:24.702]                       is.null <- base::is.null
[09:28:24.702]                       muffled <- FALSE
[09:28:24.702]                       if (inherits(cond, "message")) {
[09:28:24.702]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.702]                         if (muffled) 
[09:28:24.702]                           invokeRestart("muffleMessage")
[09:28:24.702]                       }
[09:28:24.702]                       else if (inherits(cond, "warning")) {
[09:28:24.702]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.702]                         if (muffled) 
[09:28:24.702]                           invokeRestart("muffleWarning")
[09:28:24.702]                       }
[09:28:24.702]                       else if (inherits(cond, "condition")) {
[09:28:24.702]                         if (!is.null(pattern)) {
[09:28:24.702]                           computeRestarts <- base::computeRestarts
[09:28:24.702]                           grepl <- base::grepl
[09:28:24.702]                           restarts <- computeRestarts(cond)
[09:28:24.702]                           for (restart in restarts) {
[09:28:24.702]                             name <- restart$name
[09:28:24.702]                             if (is.null(name)) 
[09:28:24.702]                               next
[09:28:24.702]                             if (!grepl(pattern, name)) 
[09:28:24.702]                               next
[09:28:24.702]                             invokeRestart(restart)
[09:28:24.702]                             muffled <- TRUE
[09:28:24.702]                             break
[09:28:24.702]                           }
[09:28:24.702]                         }
[09:28:24.702]                       }
[09:28:24.702]                       invisible(muffled)
[09:28:24.702]                     }
[09:28:24.702]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.702]                   }
[09:28:24.702]                 }
[09:28:24.702]                 else {
[09:28:24.702]                   if (TRUE) {
[09:28:24.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.702]                     {
[09:28:24.702]                       inherits <- base::inherits
[09:28:24.702]                       invokeRestart <- base::invokeRestart
[09:28:24.702]                       is.null <- base::is.null
[09:28:24.702]                       muffled <- FALSE
[09:28:24.702]                       if (inherits(cond, "message")) {
[09:28:24.702]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.702]                         if (muffled) 
[09:28:24.702]                           invokeRestart("muffleMessage")
[09:28:24.702]                       }
[09:28:24.702]                       else if (inherits(cond, "warning")) {
[09:28:24.702]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.702]                         if (muffled) 
[09:28:24.702]                           invokeRestart("muffleWarning")
[09:28:24.702]                       }
[09:28:24.702]                       else if (inherits(cond, "condition")) {
[09:28:24.702]                         if (!is.null(pattern)) {
[09:28:24.702]                           computeRestarts <- base::computeRestarts
[09:28:24.702]                           grepl <- base::grepl
[09:28:24.702]                           restarts <- computeRestarts(cond)
[09:28:24.702]                           for (restart in restarts) {
[09:28:24.702]                             name <- restart$name
[09:28:24.702]                             if (is.null(name)) 
[09:28:24.702]                               next
[09:28:24.702]                             if (!grepl(pattern, name)) 
[09:28:24.702]                               next
[09:28:24.702]                             invokeRestart(restart)
[09:28:24.702]                             muffled <- TRUE
[09:28:24.702]                             break
[09:28:24.702]                           }
[09:28:24.702]                         }
[09:28:24.702]                       }
[09:28:24.702]                       invisible(muffled)
[09:28:24.702]                     }
[09:28:24.702]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.702]                   }
[09:28:24.702]                 }
[09:28:24.702]             }
[09:28:24.702]         }))
[09:28:24.702]     }, error = function(ex) {
[09:28:24.702]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:24.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.702]                 ...future.rng), started = ...future.startTime, 
[09:28:24.702]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:24.702]             version = "1.8"), class = "FutureResult")
[09:28:24.702]     }, finally = {
[09:28:24.702]         if (!identical(...future.workdir, getwd())) 
[09:28:24.702]             setwd(...future.workdir)
[09:28:24.702]         {
[09:28:24.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:24.702]                 ...future.oldOptions$nwarnings <- NULL
[09:28:24.702]             }
[09:28:24.702]             base::options(...future.oldOptions)
[09:28:24.702]             if (.Platform$OS.type == "windows") {
[09:28:24.702]                 old_names <- names(...future.oldEnvVars)
[09:28:24.702]                 envs <- base::Sys.getenv()
[09:28:24.702]                 names <- names(envs)
[09:28:24.702]                 common <- intersect(names, old_names)
[09:28:24.702]                 added <- setdiff(names, old_names)
[09:28:24.702]                 removed <- setdiff(old_names, names)
[09:28:24.702]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:24.702]                   envs[common]]
[09:28:24.702]                 NAMES <- toupper(changed)
[09:28:24.702]                 args <- list()
[09:28:24.702]                 for (kk in seq_along(NAMES)) {
[09:28:24.702]                   name <- changed[[kk]]
[09:28:24.702]                   NAME <- NAMES[[kk]]
[09:28:24.702]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.702]                     next
[09:28:24.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.702]                 }
[09:28:24.702]                 NAMES <- toupper(added)
[09:28:24.702]                 for (kk in seq_along(NAMES)) {
[09:28:24.702]                   name <- added[[kk]]
[09:28:24.702]                   NAME <- NAMES[[kk]]
[09:28:24.702]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.702]                     next
[09:28:24.702]                   args[[name]] <- ""
[09:28:24.702]                 }
[09:28:24.702]                 NAMES <- toupper(removed)
[09:28:24.702]                 for (kk in seq_along(NAMES)) {
[09:28:24.702]                   name <- removed[[kk]]
[09:28:24.702]                   NAME <- NAMES[[kk]]
[09:28:24.702]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.702]                     next
[09:28:24.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.702]                 }
[09:28:24.702]                 if (length(args) > 0) 
[09:28:24.702]                   base::do.call(base::Sys.setenv, args = args)
[09:28:24.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:24.702]             }
[09:28:24.702]             else {
[09:28:24.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:24.702]             }
[09:28:24.702]             {
[09:28:24.702]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:24.702]                   0L) {
[09:28:24.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:24.702]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:24.702]                   base::options(opts)
[09:28:24.702]                 }
[09:28:24.702]                 {
[09:28:24.702]                   {
[09:28:24.702]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:24.702]                     NULL
[09:28:24.702]                   }
[09:28:24.702]                   options(future.plan = NULL)
[09:28:24.702]                   if (is.na(NA_character_)) 
[09:28:24.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:24.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:24.702]                     .init = FALSE)
[09:28:24.702]                 }
[09:28:24.702]             }
[09:28:24.702]         }
[09:28:24.702]     })
[09:28:24.702]     if (TRUE) {
[09:28:24.702]         base::sink(type = "output", split = FALSE)
[09:28:24.702]         if (TRUE) {
[09:28:24.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:24.702]         }
[09:28:24.702]         else {
[09:28:24.702]             ...future.result["stdout"] <- base::list(NULL)
[09:28:24.702]         }
[09:28:24.702]         base::close(...future.stdout)
[09:28:24.702]         ...future.stdout <- NULL
[09:28:24.702]     }
[09:28:24.702]     ...future.result$conditions <- ...future.conditions
[09:28:24.702]     ...future.result$finished <- base::Sys.time()
[09:28:24.702]     ...future.result
[09:28:24.702] }
[09:28:24.705] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[09:28:24.705] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[09:28:24.705] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[09:28:24.706] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[09:28:24.706] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[09:28:24.706] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[09:28:24.706] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[09:28:24.706] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:24.707] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:24.707] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:28:24.707] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:28:24.707] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[09:28:24.708] MultisessionFuture started
[09:28:24.708] - Launch lazy future ... done
[09:28:24.708] run() for ‘MultisessionFuture’ ... done
[09:28:24.708] Created future:
[09:28:24.708] MultisessionFuture:
[09:28:24.708] Label: ‘future_by-2’
[09:28:24.708] Expression:
[09:28:24.708] {
[09:28:24.708]     do.call(function(...) {
[09:28:24.708]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.708]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.708]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.708]             on.exit(options(oopts), add = TRUE)
[09:28:24.708]         }
[09:28:24.708]         {
[09:28:24.708]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.708]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.708]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.708]             })
[09:28:24.708]         }
[09:28:24.708]     }, args = future.call.arguments)
[09:28:24.708] }
[09:28:24.708] Lazy evaluation: FALSE
[09:28:24.708] Asynchronous evaluation: TRUE
[09:28:24.708] Local evaluation: TRUE
[09:28:24.708] Environment: R_GlobalEnv
[09:28:24.708] Capture standard output: TRUE
[09:28:24.708] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:24.708] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:24.708] Packages: <none>
[09:28:24.708] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:24.708] Resolved: FALSE
[09:28:24.708] Value: <not collected>
[09:28:24.708] Conditions captured: <none>
[09:28:24.708] Early signaling: FALSE
[09:28:24.708] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:24.708] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.719] Chunk #2 of 2 ... DONE
[09:28:24.720] Launching 2 futures (chunks) ... DONE
[09:28:24.720] Resolving 2 futures (chunks) ...
[09:28:24.720] resolve() on list ...
[09:28:24.720]  recursive: 0
[09:28:24.720]  length: 2
[09:28:24.720] 
[09:28:24.721] receiveMessageFromWorker() for ClusterFuture ...
[09:28:24.721] - Validating connection of MultisessionFuture
[09:28:24.721] - received message: FutureResult
[09:28:24.721] - Received FutureResult
[09:28:24.721] - Erased future from FutureRegistry
[09:28:24.721] result() for ClusterFuture ...
[09:28:24.721] - result already collected: FutureResult
[09:28:24.721] result() for ClusterFuture ... done
[09:28:24.721] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:24.722] Future #1
[09:28:24.722] result() for ClusterFuture ...
[09:28:24.722] - result already collected: FutureResult
[09:28:24.722] result() for ClusterFuture ... done
[09:28:24.722] result() for ClusterFuture ...
[09:28:24.722] - result already collected: FutureResult
[09:28:24.722] result() for ClusterFuture ... done
[09:28:24.722] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:24.722] - nx: 2
[09:28:24.722] - relay: TRUE
[09:28:24.722] - stdout: TRUE
[09:28:24.723] - signal: TRUE
[09:28:24.723] - resignal: FALSE
[09:28:24.723] - force: TRUE
[09:28:24.723] - relayed: [n=2] FALSE, FALSE
[09:28:24.723] - queued futures: [n=2] FALSE, FALSE
[09:28:24.723]  - until=1
[09:28:24.723]  - relaying element #1
[09:28:24.723] result() for ClusterFuture ...
[09:28:24.723] - result already collected: FutureResult
[09:28:24.723] result() for ClusterFuture ... done
[09:28:24.723] result() for ClusterFuture ...
[09:28:24.723] - result already collected: FutureResult
[09:28:24.724] result() for ClusterFuture ... done
[09:28:24.724] result() for ClusterFuture ...
[09:28:24.724] - result already collected: FutureResult
[09:28:24.724] result() for ClusterFuture ... done
[09:28:24.724] result() for ClusterFuture ...
[09:28:24.724] - result already collected: FutureResult
[09:28:24.724] result() for ClusterFuture ... done
[09:28:24.724] - relayed: [n=2] TRUE, FALSE
[09:28:24.724] - queued futures: [n=2] TRUE, FALSE
[09:28:24.724] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:24.724]  length: 1 (resolved future 1)
[09:28:24.749] receiveMessageFromWorker() for ClusterFuture ...
[09:28:24.750] - Validating connection of MultisessionFuture
[09:28:24.750] - received message: FutureResult
[09:28:24.750] - Received FutureResult
[09:28:24.750] - Erased future from FutureRegistry
[09:28:24.750] result() for ClusterFuture ...
[09:28:24.750] - result already collected: FutureResult
[09:28:24.750] result() for ClusterFuture ... done
[09:28:24.750] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:24.751] Future #2
[09:28:24.751] result() for ClusterFuture ...
[09:28:24.751] - result already collected: FutureResult
[09:28:24.751] result() for ClusterFuture ... done
[09:28:24.751] result() for ClusterFuture ...
[09:28:24.751] - result already collected: FutureResult
[09:28:24.751] result() for ClusterFuture ... done
[09:28:24.751] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:24.751] - nx: 2
[09:28:24.751] - relay: TRUE
[09:28:24.751] - stdout: TRUE
[09:28:24.751] - signal: TRUE
[09:28:24.752] - resignal: FALSE
[09:28:24.752] - force: TRUE
[09:28:24.752] - relayed: [n=2] TRUE, FALSE
[09:28:24.752] - queued futures: [n=2] TRUE, FALSE
[09:28:24.752]  - until=2
[09:28:24.752]  - relaying element #2
[09:28:24.752] result() for ClusterFuture ...
[09:28:24.752] - result already collected: FutureResult
[09:28:24.752] result() for ClusterFuture ... done
[09:28:24.752] result() for ClusterFuture ...
[09:28:24.752] - result already collected: FutureResult
[09:28:24.752] result() for ClusterFuture ... done
[09:28:24.753] result() for ClusterFuture ...
[09:28:24.753] - result already collected: FutureResult
[09:28:24.753] result() for ClusterFuture ... done
[09:28:24.753] result() for ClusterFuture ...
[09:28:24.753] - result already collected: FutureResult
[09:28:24.753] result() for ClusterFuture ... done
[09:28:24.753] - relayed: [n=2] TRUE, TRUE
[09:28:24.753] - queued futures: [n=2] TRUE, TRUE
[09:28:24.753] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:24.753]  length: 0 (resolved future 2)
[09:28:24.753] Relaying remaining futures
[09:28:24.754] signalConditionsASAP(NULL, pos=0) ...
[09:28:24.754] - nx: 2
[09:28:24.754] - relay: TRUE
[09:28:24.754] - stdout: TRUE
[09:28:24.754] - signal: TRUE
[09:28:24.754] - resignal: FALSE
[09:28:24.754] - force: TRUE
[09:28:24.754] - relayed: [n=2] TRUE, TRUE
[09:28:24.754] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:24.754] - relayed: [n=2] TRUE, TRUE
[09:28:24.754] - queued futures: [n=2] TRUE, TRUE
[09:28:24.754] signalConditionsASAP(NULL, pos=0) ... done
[09:28:24.755] resolve() on list ... DONE
[09:28:24.755] result() for ClusterFuture ...
[09:28:24.755] - result already collected: FutureResult
[09:28:24.755] result() for ClusterFuture ... done
[09:28:24.755] result() for ClusterFuture ...
[09:28:24.755] - result already collected: FutureResult
[09:28:24.755] result() for ClusterFuture ... done
[09:28:24.755] result() for ClusterFuture ...
[09:28:24.755] - result already collected: FutureResult
[09:28:24.755] result() for ClusterFuture ... done
[09:28:24.755] result() for ClusterFuture ...
[09:28:24.756] - result already collected: FutureResult
[09:28:24.756] result() for ClusterFuture ... done
[09:28:24.756]  - Number of value chunks collected: 2
[09:28:24.756] Resolving 2 futures (chunks) ... DONE
[09:28:24.756] Reducing values from 2 chunks ...
[09:28:24.756]  - Number of values collected after concatenation: 6
[09:28:24.756]  - Number of values expected: 6
[09:28:24.756] Reducing values from 2 chunks ... DONE
[09:28:24.756] future_lapply() ... DONE
[09:28:24.756] future_by_internal() ... DONE
[09:28:24.757] future_by_internal() ...
[09:28:24.758] future_lapply() ...
[09:28:24.762] Number of chunks: 2
[09:28:24.762] getGlobalsAndPackagesXApply() ...
[09:28:24.762]  - future.globals: TRUE
[09:28:24.762] getGlobalsAndPackages() ...
[09:28:24.762] Searching for globals...
[09:28:24.764] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:24.764] Searching for globals ... DONE
[09:28:24.764] Resolving globals: FALSE
[09:28:24.764] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[09:28:24.765] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[09:28:24.765] - globals: [1] ‘FUN’
[09:28:24.765] - packages: [1] ‘stats’
[09:28:24.765] getGlobalsAndPackages() ... DONE
[09:28:24.765]  - globals found/used: [n=1] ‘FUN’
[09:28:24.765]  - needed namespaces: [n=1] ‘stats’
[09:28:24.765] Finding globals ... DONE
[09:28:24.765]  - use_args: TRUE
[09:28:24.765]  - Getting '...' globals ...
[09:28:24.766] resolve() on list ...
[09:28:24.766]  recursive: 0
[09:28:24.766]  length: 1
[09:28:24.766]  elements: ‘...’
[09:28:24.766]  length: 0 (resolved future 1)
[09:28:24.766] resolve() on list ... DONE
[09:28:24.766]    - '...' content: [n=1] ‘singular.ok’
[09:28:24.766] List of 1
[09:28:24.766]  $ ...:List of 1
[09:28:24.766]   ..$ singular.ok: logi FALSE
[09:28:24.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:24.766]  - attr(*, "where")=List of 1
[09:28:24.766]   ..$ ...:<environment: 0x555b0c6aaae8> 
[09:28:24.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:24.766]  - attr(*, "resolved")= logi TRUE
[09:28:24.766]  - attr(*, "total_size")= num NA
[09:28:24.769]  - Getting '...' globals ... DONE
[09:28:24.769] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:24.769] List of 2
[09:28:24.769]  $ ...future.FUN:function (x, ...)  
[09:28:24.769]  $ ...          :List of 1
[09:28:24.769]   ..$ singular.ok: logi FALSE
[09:28:24.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:24.769]  - attr(*, "where")=List of 2
[09:28:24.769]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:24.769]   ..$ ...          :<environment: 0x555b0c6aaae8> 
[09:28:24.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:24.769]  - attr(*, "resolved")= logi FALSE
[09:28:24.769]  - attr(*, "total_size")= num 5384
[09:28:24.772] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:24.773] getGlobalsAndPackagesXApply() ... DONE
[09:28:24.773] Number of futures (= number of chunks): 2
[09:28:24.773] Launching 2 futures (chunks) ...
[09:28:24.773] Chunk #1 of 2 ...
[09:28:24.773]  - Finding globals in 'X' for chunk #1 ...
[09:28:24.773] getGlobalsAndPackages() ...
[09:28:24.773] Searching for globals...
[09:28:24.774] 
[09:28:24.774] Searching for globals ... DONE
[09:28:24.774] - globals: [0] <none>
[09:28:24.774] getGlobalsAndPackages() ... DONE
[09:28:24.774]    + additional globals found: [n=0] 
[09:28:24.774]    + additional namespaces needed: [n=0] 
[09:28:24.774]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:24.774]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:24.774]  - seeds: <none>
[09:28:24.774]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.774] getGlobalsAndPackages() ...
[09:28:24.775] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.775] Resolving globals: FALSE
[09:28:24.775] Tweak future expression to call with '...' arguments ...
[09:28:24.775] {
[09:28:24.775]     do.call(function(...) {
[09:28:24.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.775]             on.exit(options(oopts), add = TRUE)
[09:28:24.775]         }
[09:28:24.775]         {
[09:28:24.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.775]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.775]             })
[09:28:24.775]         }
[09:28:24.775]     }, args = future.call.arguments)
[09:28:24.775] }
[09:28:24.775] Tweak future expression to call with '...' arguments ... DONE
[09:28:24.775] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.776] 
[09:28:24.776] getGlobalsAndPackages() ... DONE
[09:28:24.776] run() for ‘Future’ ...
[09:28:24.776] - state: ‘created’
[09:28:24.776] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:24.792] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.792] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:24.792]   - Field: ‘node’
[09:28:24.792]   - Field: ‘label’
[09:28:24.792]   - Field: ‘local’
[09:28:24.792]   - Field: ‘owner’
[09:28:24.792]   - Field: ‘envir’
[09:28:24.792]   - Field: ‘workers’
[09:28:24.792]   - Field: ‘packages’
[09:28:24.792]   - Field: ‘gc’
[09:28:24.793]   - Field: ‘conditions’
[09:28:24.793]   - Field: ‘persistent’
[09:28:24.793]   - Field: ‘expr’
[09:28:24.793]   - Field: ‘uuid’
[09:28:24.793]   - Field: ‘seed’
[09:28:24.793]   - Field: ‘version’
[09:28:24.793]   - Field: ‘result’
[09:28:24.793]   - Field: ‘asynchronous’
[09:28:24.793]   - Field: ‘calls’
[09:28:24.793]   - Field: ‘globals’
[09:28:24.793]   - Field: ‘stdout’
[09:28:24.793]   - Field: ‘earlySignal’
[09:28:24.794]   - Field: ‘lazy’
[09:28:24.794]   - Field: ‘state’
[09:28:24.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:24.794] - Launch lazy future ...
[09:28:24.794] Packages needed by the future expression (n = 1): ‘stats’
[09:28:24.794] Packages needed by future strategies (n = 0): <none>
[09:28:24.795] {
[09:28:24.795]     {
[09:28:24.795]         {
[09:28:24.795]             ...future.startTime <- base::Sys.time()
[09:28:24.795]             {
[09:28:24.795]                 {
[09:28:24.795]                   {
[09:28:24.795]                     {
[09:28:24.795]                       {
[09:28:24.795]                         base::local({
[09:28:24.795]                           has_future <- base::requireNamespace("future", 
[09:28:24.795]                             quietly = TRUE)
[09:28:24.795]                           if (has_future) {
[09:28:24.795]                             ns <- base::getNamespace("future")
[09:28:24.795]                             version <- ns[[".package"]][["version"]]
[09:28:24.795]                             if (is.null(version)) 
[09:28:24.795]                               version <- utils::packageVersion("future")
[09:28:24.795]                           }
[09:28:24.795]                           else {
[09:28:24.795]                             version <- NULL
[09:28:24.795]                           }
[09:28:24.795]                           if (!has_future || version < "1.8.0") {
[09:28:24.795]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:24.795]                               "", base::R.version$version.string), 
[09:28:24.795]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:24.795]                                 base::R.version$platform, 8 * 
[09:28:24.795]                                   base::.Machine$sizeof.pointer), 
[09:28:24.795]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:24.795]                                 "release", "version")], collapse = " "), 
[09:28:24.795]                               hostname = base::Sys.info()[["nodename"]])
[09:28:24.795]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:24.795]                               info)
[09:28:24.795]                             info <- base::paste(info, collapse = "; ")
[09:28:24.795]                             if (!has_future) {
[09:28:24.795]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:24.795]                                 info)
[09:28:24.795]                             }
[09:28:24.795]                             else {
[09:28:24.795]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:24.795]                                 info, version)
[09:28:24.795]                             }
[09:28:24.795]                             base::stop(msg)
[09:28:24.795]                           }
[09:28:24.795]                         })
[09:28:24.795]                       }
[09:28:24.795]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:24.795]                       base::options(mc.cores = 1L)
[09:28:24.795]                     }
[09:28:24.795]                     base::local({
[09:28:24.795]                       for (pkg in "stats") {
[09:28:24.795]                         base::loadNamespace(pkg)
[09:28:24.795]                         base::library(pkg, character.only = TRUE)
[09:28:24.795]                       }
[09:28:24.795]                     })
[09:28:24.795]                   }
[09:28:24.795]                   ...future.strategy.old <- future::plan("list")
[09:28:24.795]                   options(future.plan = NULL)
[09:28:24.795]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.795]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:24.795]                 }
[09:28:24.795]                 ...future.workdir <- getwd()
[09:28:24.795]             }
[09:28:24.795]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:24.795]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:24.795]         }
[09:28:24.795]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:24.795]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:24.795]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:24.795]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:24.795]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:24.795]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:24.795]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:24.795]             base::names(...future.oldOptions))
[09:28:24.795]     }
[09:28:24.795]     if (FALSE) {
[09:28:24.795]     }
[09:28:24.795]     else {
[09:28:24.795]         if (TRUE) {
[09:28:24.795]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:24.795]                 open = "w")
[09:28:24.795]         }
[09:28:24.795]         else {
[09:28:24.795]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:24.795]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:24.795]         }
[09:28:24.795]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:24.795]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:24.795]             base::sink(type = "output", split = FALSE)
[09:28:24.795]             base::close(...future.stdout)
[09:28:24.795]         }, add = TRUE)
[09:28:24.795]     }
[09:28:24.795]     ...future.frame <- base::sys.nframe()
[09:28:24.795]     ...future.conditions <- base::list()
[09:28:24.795]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:24.795]     if (FALSE) {
[09:28:24.795]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:24.795]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:24.795]     }
[09:28:24.795]     ...future.result <- base::tryCatch({
[09:28:24.795]         base::withCallingHandlers({
[09:28:24.795]             ...future.value <- base::withVisible(base::local({
[09:28:24.795]                 ...future.makeSendCondition <- base::local({
[09:28:24.795]                   sendCondition <- NULL
[09:28:24.795]                   function(frame = 1L) {
[09:28:24.795]                     if (is.function(sendCondition)) 
[09:28:24.795]                       return(sendCondition)
[09:28:24.795]                     ns <- getNamespace("parallel")
[09:28:24.795]                     if (exists("sendData", mode = "function", 
[09:28:24.795]                       envir = ns)) {
[09:28:24.795]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:24.795]                         envir = ns)
[09:28:24.795]                       envir <- sys.frame(frame)
[09:28:24.795]                       master <- NULL
[09:28:24.795]                       while (!identical(envir, .GlobalEnv) && 
[09:28:24.795]                         !identical(envir, emptyenv())) {
[09:28:24.795]                         if (exists("master", mode = "list", envir = envir, 
[09:28:24.795]                           inherits = FALSE)) {
[09:28:24.795]                           master <- get("master", mode = "list", 
[09:28:24.795]                             envir = envir, inherits = FALSE)
[09:28:24.795]                           if (inherits(master, c("SOCKnode", 
[09:28:24.795]                             "SOCK0node"))) {
[09:28:24.795]                             sendCondition <<- function(cond) {
[09:28:24.795]                               data <- list(type = "VALUE", value = cond, 
[09:28:24.795]                                 success = TRUE)
[09:28:24.795]                               parallel_sendData(master, data)
[09:28:24.795]                             }
[09:28:24.795]                             return(sendCondition)
[09:28:24.795]                           }
[09:28:24.795]                         }
[09:28:24.795]                         frame <- frame + 1L
[09:28:24.795]                         envir <- sys.frame(frame)
[09:28:24.795]                       }
[09:28:24.795]                     }
[09:28:24.795]                     sendCondition <<- function(cond) NULL
[09:28:24.795]                   }
[09:28:24.795]                 })
[09:28:24.795]                 withCallingHandlers({
[09:28:24.795]                   {
[09:28:24.795]                     do.call(function(...) {
[09:28:24.795]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.795]                       if (!identical(...future.globals.maxSize.org, 
[09:28:24.795]                         ...future.globals.maxSize)) {
[09:28:24.795]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.795]                         on.exit(options(oopts), add = TRUE)
[09:28:24.795]                       }
[09:28:24.795]                       {
[09:28:24.795]                         lapply(seq_along(...future.elements_ii), 
[09:28:24.795]                           FUN = function(jj) {
[09:28:24.795]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.795]                             ...future.FUN(...future.X_jj, ...)
[09:28:24.795]                           })
[09:28:24.795]                       }
[09:28:24.795]                     }, args = future.call.arguments)
[09:28:24.795]                   }
[09:28:24.795]                 }, immediateCondition = function(cond) {
[09:28:24.795]                   sendCondition <- ...future.makeSendCondition()
[09:28:24.795]                   sendCondition(cond)
[09:28:24.795]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.795]                   {
[09:28:24.795]                     inherits <- base::inherits
[09:28:24.795]                     invokeRestart <- base::invokeRestart
[09:28:24.795]                     is.null <- base::is.null
[09:28:24.795]                     muffled <- FALSE
[09:28:24.795]                     if (inherits(cond, "message")) {
[09:28:24.795]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:24.795]                       if (muffled) 
[09:28:24.795]                         invokeRestart("muffleMessage")
[09:28:24.795]                     }
[09:28:24.795]                     else if (inherits(cond, "warning")) {
[09:28:24.795]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:24.795]                       if (muffled) 
[09:28:24.795]                         invokeRestart("muffleWarning")
[09:28:24.795]                     }
[09:28:24.795]                     else if (inherits(cond, "condition")) {
[09:28:24.795]                       if (!is.null(pattern)) {
[09:28:24.795]                         computeRestarts <- base::computeRestarts
[09:28:24.795]                         grepl <- base::grepl
[09:28:24.795]                         restarts <- computeRestarts(cond)
[09:28:24.795]                         for (restart in restarts) {
[09:28:24.795]                           name <- restart$name
[09:28:24.795]                           if (is.null(name)) 
[09:28:24.795]                             next
[09:28:24.795]                           if (!grepl(pattern, name)) 
[09:28:24.795]                             next
[09:28:24.795]                           invokeRestart(restart)
[09:28:24.795]                           muffled <- TRUE
[09:28:24.795]                           break
[09:28:24.795]                         }
[09:28:24.795]                       }
[09:28:24.795]                     }
[09:28:24.795]                     invisible(muffled)
[09:28:24.795]                   }
[09:28:24.795]                   muffleCondition(cond)
[09:28:24.795]                 })
[09:28:24.795]             }))
[09:28:24.795]             future::FutureResult(value = ...future.value$value, 
[09:28:24.795]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.795]                   ...future.rng), globalenv = if (FALSE) 
[09:28:24.795]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:24.795]                     ...future.globalenv.names))
[09:28:24.795]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:24.795]         }, condition = base::local({
[09:28:24.795]             c <- base::c
[09:28:24.795]             inherits <- base::inherits
[09:28:24.795]             invokeRestart <- base::invokeRestart
[09:28:24.795]             length <- base::length
[09:28:24.795]             list <- base::list
[09:28:24.795]             seq.int <- base::seq.int
[09:28:24.795]             signalCondition <- base::signalCondition
[09:28:24.795]             sys.calls <- base::sys.calls
[09:28:24.795]             `[[` <- base::`[[`
[09:28:24.795]             `+` <- base::`+`
[09:28:24.795]             `<<-` <- base::`<<-`
[09:28:24.795]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:24.795]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:24.795]                   3L)]
[09:28:24.795]             }
[09:28:24.795]             function(cond) {
[09:28:24.795]                 is_error <- inherits(cond, "error")
[09:28:24.795]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:24.795]                   NULL)
[09:28:24.795]                 if (is_error) {
[09:28:24.795]                   sessionInformation <- function() {
[09:28:24.795]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:24.795]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:24.795]                       search = base::search(), system = base::Sys.info())
[09:28:24.795]                   }
[09:28:24.795]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.795]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:24.795]                     cond$call), session = sessionInformation(), 
[09:28:24.795]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:24.795]                   signalCondition(cond)
[09:28:24.795]                 }
[09:28:24.795]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:24.795]                 "immediateCondition"))) {
[09:28:24.795]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:24.795]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.795]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:24.795]                   if (TRUE && !signal) {
[09:28:24.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.795]                     {
[09:28:24.795]                       inherits <- base::inherits
[09:28:24.795]                       invokeRestart <- base::invokeRestart
[09:28:24.795]                       is.null <- base::is.null
[09:28:24.795]                       muffled <- FALSE
[09:28:24.795]                       if (inherits(cond, "message")) {
[09:28:24.795]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.795]                         if (muffled) 
[09:28:24.795]                           invokeRestart("muffleMessage")
[09:28:24.795]                       }
[09:28:24.795]                       else if (inherits(cond, "warning")) {
[09:28:24.795]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.795]                         if (muffled) 
[09:28:24.795]                           invokeRestart("muffleWarning")
[09:28:24.795]                       }
[09:28:24.795]                       else if (inherits(cond, "condition")) {
[09:28:24.795]                         if (!is.null(pattern)) {
[09:28:24.795]                           computeRestarts <- base::computeRestarts
[09:28:24.795]                           grepl <- base::grepl
[09:28:24.795]                           restarts <- computeRestarts(cond)
[09:28:24.795]                           for (restart in restarts) {
[09:28:24.795]                             name <- restart$name
[09:28:24.795]                             if (is.null(name)) 
[09:28:24.795]                               next
[09:28:24.795]                             if (!grepl(pattern, name)) 
[09:28:24.795]                               next
[09:28:24.795]                             invokeRestart(restart)
[09:28:24.795]                             muffled <- TRUE
[09:28:24.795]                             break
[09:28:24.795]                           }
[09:28:24.795]                         }
[09:28:24.795]                       }
[09:28:24.795]                       invisible(muffled)
[09:28:24.795]                     }
[09:28:24.795]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.795]                   }
[09:28:24.795]                 }
[09:28:24.795]                 else {
[09:28:24.795]                   if (TRUE) {
[09:28:24.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.795]                     {
[09:28:24.795]                       inherits <- base::inherits
[09:28:24.795]                       invokeRestart <- base::invokeRestart
[09:28:24.795]                       is.null <- base::is.null
[09:28:24.795]                       muffled <- FALSE
[09:28:24.795]                       if (inherits(cond, "message")) {
[09:28:24.795]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.795]                         if (muffled) 
[09:28:24.795]                           invokeRestart("muffleMessage")
[09:28:24.795]                       }
[09:28:24.795]                       else if (inherits(cond, "warning")) {
[09:28:24.795]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.795]                         if (muffled) 
[09:28:24.795]                           invokeRestart("muffleWarning")
[09:28:24.795]                       }
[09:28:24.795]                       else if (inherits(cond, "condition")) {
[09:28:24.795]                         if (!is.null(pattern)) {
[09:28:24.795]                           computeRestarts <- base::computeRestarts
[09:28:24.795]                           grepl <- base::grepl
[09:28:24.795]                           restarts <- computeRestarts(cond)
[09:28:24.795]                           for (restart in restarts) {
[09:28:24.795]                             name <- restart$name
[09:28:24.795]                             if (is.null(name)) 
[09:28:24.795]                               next
[09:28:24.795]                             if (!grepl(pattern, name)) 
[09:28:24.795]                               next
[09:28:24.795]                             invokeRestart(restart)
[09:28:24.795]                             muffled <- TRUE
[09:28:24.795]                             break
[09:28:24.795]                           }
[09:28:24.795]                         }
[09:28:24.795]                       }
[09:28:24.795]                       invisible(muffled)
[09:28:24.795]                     }
[09:28:24.795]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.795]                   }
[09:28:24.795]                 }
[09:28:24.795]             }
[09:28:24.795]         }))
[09:28:24.795]     }, error = function(ex) {
[09:28:24.795]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:24.795]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.795]                 ...future.rng), started = ...future.startTime, 
[09:28:24.795]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:24.795]             version = "1.8"), class = "FutureResult")
[09:28:24.795]     }, finally = {
[09:28:24.795]         if (!identical(...future.workdir, getwd())) 
[09:28:24.795]             setwd(...future.workdir)
[09:28:24.795]         {
[09:28:24.795]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:24.795]                 ...future.oldOptions$nwarnings <- NULL
[09:28:24.795]             }
[09:28:24.795]             base::options(...future.oldOptions)
[09:28:24.795]             if (.Platform$OS.type == "windows") {
[09:28:24.795]                 old_names <- names(...future.oldEnvVars)
[09:28:24.795]                 envs <- base::Sys.getenv()
[09:28:24.795]                 names <- names(envs)
[09:28:24.795]                 common <- intersect(names, old_names)
[09:28:24.795]                 added <- setdiff(names, old_names)
[09:28:24.795]                 removed <- setdiff(old_names, names)
[09:28:24.795]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:24.795]                   envs[common]]
[09:28:24.795]                 NAMES <- toupper(changed)
[09:28:24.795]                 args <- list()
[09:28:24.795]                 for (kk in seq_along(NAMES)) {
[09:28:24.795]                   name <- changed[[kk]]
[09:28:24.795]                   NAME <- NAMES[[kk]]
[09:28:24.795]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.795]                     next
[09:28:24.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.795]                 }
[09:28:24.795]                 NAMES <- toupper(added)
[09:28:24.795]                 for (kk in seq_along(NAMES)) {
[09:28:24.795]                   name <- added[[kk]]
[09:28:24.795]                   NAME <- NAMES[[kk]]
[09:28:24.795]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.795]                     next
[09:28:24.795]                   args[[name]] <- ""
[09:28:24.795]                 }
[09:28:24.795]                 NAMES <- toupper(removed)
[09:28:24.795]                 for (kk in seq_along(NAMES)) {
[09:28:24.795]                   name <- removed[[kk]]
[09:28:24.795]                   NAME <- NAMES[[kk]]
[09:28:24.795]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.795]                     next
[09:28:24.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.795]                 }
[09:28:24.795]                 if (length(args) > 0) 
[09:28:24.795]                   base::do.call(base::Sys.setenv, args = args)
[09:28:24.795]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:24.795]             }
[09:28:24.795]             else {
[09:28:24.795]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:24.795]             }
[09:28:24.795]             {
[09:28:24.795]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:24.795]                   0L) {
[09:28:24.795]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:24.795]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:24.795]                   base::options(opts)
[09:28:24.795]                 }
[09:28:24.795]                 {
[09:28:24.795]                   {
[09:28:24.795]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:24.795]                     NULL
[09:28:24.795]                   }
[09:28:24.795]                   options(future.plan = NULL)
[09:28:24.795]                   if (is.na(NA_character_)) 
[09:28:24.795]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.795]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:24.795]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:24.795]                     .init = FALSE)
[09:28:24.795]                 }
[09:28:24.795]             }
[09:28:24.795]         }
[09:28:24.795]     })
[09:28:24.795]     if (TRUE) {
[09:28:24.795]         base::sink(type = "output", split = FALSE)
[09:28:24.795]         if (TRUE) {
[09:28:24.795]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:24.795]         }
[09:28:24.795]         else {
[09:28:24.795]             ...future.result["stdout"] <- base::list(NULL)
[09:28:24.795]         }
[09:28:24.795]         base::close(...future.stdout)
[09:28:24.795]         ...future.stdout <- NULL
[09:28:24.795]     }
[09:28:24.795]     ...future.result$conditions <- ...future.conditions
[09:28:24.795]     ...future.result$finished <- base::Sys.time()
[09:28:24.795]     ...future.result
[09:28:24.795] }
[09:28:24.797] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[09:28:24.797] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[09:28:24.798] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[09:28:24.798] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[09:28:24.798] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[09:28:24.799] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[09:28:24.799] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[09:28:24.799] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:24.799] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:24.800] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:28:24.800] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:28:24.800] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[09:28:24.801] MultisessionFuture started
[09:28:24.801] - Launch lazy future ... done
[09:28:24.801] run() for ‘MultisessionFuture’ ... done
[09:28:24.801] Created future:
[09:28:24.801] MultisessionFuture:
[09:28:24.801] Label: ‘future_by-1’
[09:28:24.801] Expression:
[09:28:24.801] {
[09:28:24.801]     do.call(function(...) {
[09:28:24.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.801]             on.exit(options(oopts), add = TRUE)
[09:28:24.801]         }
[09:28:24.801]         {
[09:28:24.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.801]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.801]             })
[09:28:24.801]         }
[09:28:24.801]     }, args = future.call.arguments)
[09:28:24.801] }
[09:28:24.801] Lazy evaluation: FALSE
[09:28:24.801] Asynchronous evaluation: TRUE
[09:28:24.801] Local evaluation: TRUE
[09:28:24.801] Environment: R_GlobalEnv
[09:28:24.801] Capture standard output: TRUE
[09:28:24.801] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:24.801] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:24.801] Packages: 1 packages (‘stats’)
[09:28:24.801] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:24.801] Resolved: FALSE
[09:28:24.801] Value: <not collected>
[09:28:24.801] Conditions captured: <none>
[09:28:24.801] Early signaling: FALSE
[09:28:24.801] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:24.801] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.813] Chunk #1 of 2 ... DONE
[09:28:24.813] Chunk #2 of 2 ...
[09:28:24.813]  - Finding globals in 'X' for chunk #2 ...
[09:28:24.813] getGlobalsAndPackages() ...
[09:28:24.813] Searching for globals...
[09:28:24.814] 
[09:28:24.814] Searching for globals ... DONE
[09:28:24.814] - globals: [0] <none>
[09:28:24.814] getGlobalsAndPackages() ... DONE
[09:28:24.814]    + additional globals found: [n=0] 
[09:28:24.814]    + additional namespaces needed: [n=0] 
[09:28:24.814]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:24.814]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:24.814]  - seeds: <none>
[09:28:24.814]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.814] getGlobalsAndPackages() ...
[09:28:24.815] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.815] Resolving globals: FALSE
[09:28:24.815] Tweak future expression to call with '...' arguments ...
[09:28:24.815] {
[09:28:24.815]     do.call(function(...) {
[09:28:24.815]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.815]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.815]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.815]             on.exit(options(oopts), add = TRUE)
[09:28:24.815]         }
[09:28:24.815]         {
[09:28:24.815]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.815]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.815]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.815]             })
[09:28:24.815]         }
[09:28:24.815]     }, args = future.call.arguments)
[09:28:24.815] }
[09:28:24.815] Tweak future expression to call with '...' arguments ... DONE
[09:28:24.815] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.816] 
[09:28:24.816] getGlobalsAndPackages() ... DONE
[09:28:24.816] run() for ‘Future’ ...
[09:28:24.816] - state: ‘created’
[09:28:24.816] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:24.830] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:24.830]   - Field: ‘node’
[09:28:24.830]   - Field: ‘label’
[09:28:24.831]   - Field: ‘local’
[09:28:24.831]   - Field: ‘owner’
[09:28:24.831]   - Field: ‘envir’
[09:28:24.831]   - Field: ‘workers’
[09:28:24.831]   - Field: ‘packages’
[09:28:24.831]   - Field: ‘gc’
[09:28:24.831]   - Field: ‘conditions’
[09:28:24.831]   - Field: ‘persistent’
[09:28:24.831]   - Field: ‘expr’
[09:28:24.831]   - Field: ‘uuid’
[09:28:24.831]   - Field: ‘seed’
[09:28:24.832]   - Field: ‘version’
[09:28:24.832]   - Field: ‘result’
[09:28:24.832]   - Field: ‘asynchronous’
[09:28:24.832]   - Field: ‘calls’
[09:28:24.832]   - Field: ‘globals’
[09:28:24.832]   - Field: ‘stdout’
[09:28:24.832]   - Field: ‘earlySignal’
[09:28:24.832]   - Field: ‘lazy’
[09:28:24.832]   - Field: ‘state’
[09:28:24.832] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:24.832] - Launch lazy future ...
[09:28:24.833] Packages needed by the future expression (n = 1): ‘stats’
[09:28:24.833] Packages needed by future strategies (n = 0): <none>
[09:28:24.833] {
[09:28:24.833]     {
[09:28:24.833]         {
[09:28:24.833]             ...future.startTime <- base::Sys.time()
[09:28:24.833]             {
[09:28:24.833]                 {
[09:28:24.833]                   {
[09:28:24.833]                     {
[09:28:24.833]                       {
[09:28:24.833]                         base::local({
[09:28:24.833]                           has_future <- base::requireNamespace("future", 
[09:28:24.833]                             quietly = TRUE)
[09:28:24.833]                           if (has_future) {
[09:28:24.833]                             ns <- base::getNamespace("future")
[09:28:24.833]                             version <- ns[[".package"]][["version"]]
[09:28:24.833]                             if (is.null(version)) 
[09:28:24.833]                               version <- utils::packageVersion("future")
[09:28:24.833]                           }
[09:28:24.833]                           else {
[09:28:24.833]                             version <- NULL
[09:28:24.833]                           }
[09:28:24.833]                           if (!has_future || version < "1.8.0") {
[09:28:24.833]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:24.833]                               "", base::R.version$version.string), 
[09:28:24.833]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:24.833]                                 base::R.version$platform, 8 * 
[09:28:24.833]                                   base::.Machine$sizeof.pointer), 
[09:28:24.833]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:24.833]                                 "release", "version")], collapse = " "), 
[09:28:24.833]                               hostname = base::Sys.info()[["nodename"]])
[09:28:24.833]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:24.833]                               info)
[09:28:24.833]                             info <- base::paste(info, collapse = "; ")
[09:28:24.833]                             if (!has_future) {
[09:28:24.833]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:24.833]                                 info)
[09:28:24.833]                             }
[09:28:24.833]                             else {
[09:28:24.833]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:24.833]                                 info, version)
[09:28:24.833]                             }
[09:28:24.833]                             base::stop(msg)
[09:28:24.833]                           }
[09:28:24.833]                         })
[09:28:24.833]                       }
[09:28:24.833]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:24.833]                       base::options(mc.cores = 1L)
[09:28:24.833]                     }
[09:28:24.833]                     base::local({
[09:28:24.833]                       for (pkg in "stats") {
[09:28:24.833]                         base::loadNamespace(pkg)
[09:28:24.833]                         base::library(pkg, character.only = TRUE)
[09:28:24.833]                       }
[09:28:24.833]                     })
[09:28:24.833]                   }
[09:28:24.833]                   ...future.strategy.old <- future::plan("list")
[09:28:24.833]                   options(future.plan = NULL)
[09:28:24.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:24.833]                 }
[09:28:24.833]                 ...future.workdir <- getwd()
[09:28:24.833]             }
[09:28:24.833]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:24.833]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:24.833]         }
[09:28:24.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:24.833]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:24.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:24.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:24.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:24.833]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:24.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:24.833]             base::names(...future.oldOptions))
[09:28:24.833]     }
[09:28:24.833]     if (FALSE) {
[09:28:24.833]     }
[09:28:24.833]     else {
[09:28:24.833]         if (TRUE) {
[09:28:24.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:24.833]                 open = "w")
[09:28:24.833]         }
[09:28:24.833]         else {
[09:28:24.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:24.833]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:24.833]         }
[09:28:24.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:24.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:24.833]             base::sink(type = "output", split = FALSE)
[09:28:24.833]             base::close(...future.stdout)
[09:28:24.833]         }, add = TRUE)
[09:28:24.833]     }
[09:28:24.833]     ...future.frame <- base::sys.nframe()
[09:28:24.833]     ...future.conditions <- base::list()
[09:28:24.833]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:24.833]     if (FALSE) {
[09:28:24.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:24.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:24.833]     }
[09:28:24.833]     ...future.result <- base::tryCatch({
[09:28:24.833]         base::withCallingHandlers({
[09:28:24.833]             ...future.value <- base::withVisible(base::local({
[09:28:24.833]                 ...future.makeSendCondition <- base::local({
[09:28:24.833]                   sendCondition <- NULL
[09:28:24.833]                   function(frame = 1L) {
[09:28:24.833]                     if (is.function(sendCondition)) 
[09:28:24.833]                       return(sendCondition)
[09:28:24.833]                     ns <- getNamespace("parallel")
[09:28:24.833]                     if (exists("sendData", mode = "function", 
[09:28:24.833]                       envir = ns)) {
[09:28:24.833]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:24.833]                         envir = ns)
[09:28:24.833]                       envir <- sys.frame(frame)
[09:28:24.833]                       master <- NULL
[09:28:24.833]                       while (!identical(envir, .GlobalEnv) && 
[09:28:24.833]                         !identical(envir, emptyenv())) {
[09:28:24.833]                         if (exists("master", mode = "list", envir = envir, 
[09:28:24.833]                           inherits = FALSE)) {
[09:28:24.833]                           master <- get("master", mode = "list", 
[09:28:24.833]                             envir = envir, inherits = FALSE)
[09:28:24.833]                           if (inherits(master, c("SOCKnode", 
[09:28:24.833]                             "SOCK0node"))) {
[09:28:24.833]                             sendCondition <<- function(cond) {
[09:28:24.833]                               data <- list(type = "VALUE", value = cond, 
[09:28:24.833]                                 success = TRUE)
[09:28:24.833]                               parallel_sendData(master, data)
[09:28:24.833]                             }
[09:28:24.833]                             return(sendCondition)
[09:28:24.833]                           }
[09:28:24.833]                         }
[09:28:24.833]                         frame <- frame + 1L
[09:28:24.833]                         envir <- sys.frame(frame)
[09:28:24.833]                       }
[09:28:24.833]                     }
[09:28:24.833]                     sendCondition <<- function(cond) NULL
[09:28:24.833]                   }
[09:28:24.833]                 })
[09:28:24.833]                 withCallingHandlers({
[09:28:24.833]                   {
[09:28:24.833]                     do.call(function(...) {
[09:28:24.833]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.833]                       if (!identical(...future.globals.maxSize.org, 
[09:28:24.833]                         ...future.globals.maxSize)) {
[09:28:24.833]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.833]                         on.exit(options(oopts), add = TRUE)
[09:28:24.833]                       }
[09:28:24.833]                       {
[09:28:24.833]                         lapply(seq_along(...future.elements_ii), 
[09:28:24.833]                           FUN = function(jj) {
[09:28:24.833]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.833]                             ...future.FUN(...future.X_jj, ...)
[09:28:24.833]                           })
[09:28:24.833]                       }
[09:28:24.833]                     }, args = future.call.arguments)
[09:28:24.833]                   }
[09:28:24.833]                 }, immediateCondition = function(cond) {
[09:28:24.833]                   sendCondition <- ...future.makeSendCondition()
[09:28:24.833]                   sendCondition(cond)
[09:28:24.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.833]                   {
[09:28:24.833]                     inherits <- base::inherits
[09:28:24.833]                     invokeRestart <- base::invokeRestart
[09:28:24.833]                     is.null <- base::is.null
[09:28:24.833]                     muffled <- FALSE
[09:28:24.833]                     if (inherits(cond, "message")) {
[09:28:24.833]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:24.833]                       if (muffled) 
[09:28:24.833]                         invokeRestart("muffleMessage")
[09:28:24.833]                     }
[09:28:24.833]                     else if (inherits(cond, "warning")) {
[09:28:24.833]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:24.833]                       if (muffled) 
[09:28:24.833]                         invokeRestart("muffleWarning")
[09:28:24.833]                     }
[09:28:24.833]                     else if (inherits(cond, "condition")) {
[09:28:24.833]                       if (!is.null(pattern)) {
[09:28:24.833]                         computeRestarts <- base::computeRestarts
[09:28:24.833]                         grepl <- base::grepl
[09:28:24.833]                         restarts <- computeRestarts(cond)
[09:28:24.833]                         for (restart in restarts) {
[09:28:24.833]                           name <- restart$name
[09:28:24.833]                           if (is.null(name)) 
[09:28:24.833]                             next
[09:28:24.833]                           if (!grepl(pattern, name)) 
[09:28:24.833]                             next
[09:28:24.833]                           invokeRestart(restart)
[09:28:24.833]                           muffled <- TRUE
[09:28:24.833]                           break
[09:28:24.833]                         }
[09:28:24.833]                       }
[09:28:24.833]                     }
[09:28:24.833]                     invisible(muffled)
[09:28:24.833]                   }
[09:28:24.833]                   muffleCondition(cond)
[09:28:24.833]                 })
[09:28:24.833]             }))
[09:28:24.833]             future::FutureResult(value = ...future.value$value, 
[09:28:24.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.833]                   ...future.rng), globalenv = if (FALSE) 
[09:28:24.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:24.833]                     ...future.globalenv.names))
[09:28:24.833]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:24.833]         }, condition = base::local({
[09:28:24.833]             c <- base::c
[09:28:24.833]             inherits <- base::inherits
[09:28:24.833]             invokeRestart <- base::invokeRestart
[09:28:24.833]             length <- base::length
[09:28:24.833]             list <- base::list
[09:28:24.833]             seq.int <- base::seq.int
[09:28:24.833]             signalCondition <- base::signalCondition
[09:28:24.833]             sys.calls <- base::sys.calls
[09:28:24.833]             `[[` <- base::`[[`
[09:28:24.833]             `+` <- base::`+`
[09:28:24.833]             `<<-` <- base::`<<-`
[09:28:24.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:24.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:24.833]                   3L)]
[09:28:24.833]             }
[09:28:24.833]             function(cond) {
[09:28:24.833]                 is_error <- inherits(cond, "error")
[09:28:24.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:24.833]                   NULL)
[09:28:24.833]                 if (is_error) {
[09:28:24.833]                   sessionInformation <- function() {
[09:28:24.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:24.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:24.833]                       search = base::search(), system = base::Sys.info())
[09:28:24.833]                   }
[09:28:24.833]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:24.833]                     cond$call), session = sessionInformation(), 
[09:28:24.833]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:24.833]                   signalCondition(cond)
[09:28:24.833]                 }
[09:28:24.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:24.833]                 "immediateCondition"))) {
[09:28:24.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:24.833]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:24.833]                   if (TRUE && !signal) {
[09:28:24.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.833]                     {
[09:28:24.833]                       inherits <- base::inherits
[09:28:24.833]                       invokeRestart <- base::invokeRestart
[09:28:24.833]                       is.null <- base::is.null
[09:28:24.833]                       muffled <- FALSE
[09:28:24.833]                       if (inherits(cond, "message")) {
[09:28:24.833]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.833]                         if (muffled) 
[09:28:24.833]                           invokeRestart("muffleMessage")
[09:28:24.833]                       }
[09:28:24.833]                       else if (inherits(cond, "warning")) {
[09:28:24.833]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.833]                         if (muffled) 
[09:28:24.833]                           invokeRestart("muffleWarning")
[09:28:24.833]                       }
[09:28:24.833]                       else if (inherits(cond, "condition")) {
[09:28:24.833]                         if (!is.null(pattern)) {
[09:28:24.833]                           computeRestarts <- base::computeRestarts
[09:28:24.833]                           grepl <- base::grepl
[09:28:24.833]                           restarts <- computeRestarts(cond)
[09:28:24.833]                           for (restart in restarts) {
[09:28:24.833]                             name <- restart$name
[09:28:24.833]                             if (is.null(name)) 
[09:28:24.833]                               next
[09:28:24.833]                             if (!grepl(pattern, name)) 
[09:28:24.833]                               next
[09:28:24.833]                             invokeRestart(restart)
[09:28:24.833]                             muffled <- TRUE
[09:28:24.833]                             break
[09:28:24.833]                           }
[09:28:24.833]                         }
[09:28:24.833]                       }
[09:28:24.833]                       invisible(muffled)
[09:28:24.833]                     }
[09:28:24.833]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.833]                   }
[09:28:24.833]                 }
[09:28:24.833]                 else {
[09:28:24.833]                   if (TRUE) {
[09:28:24.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.833]                     {
[09:28:24.833]                       inherits <- base::inherits
[09:28:24.833]                       invokeRestart <- base::invokeRestart
[09:28:24.833]                       is.null <- base::is.null
[09:28:24.833]                       muffled <- FALSE
[09:28:24.833]                       if (inherits(cond, "message")) {
[09:28:24.833]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.833]                         if (muffled) 
[09:28:24.833]                           invokeRestart("muffleMessage")
[09:28:24.833]                       }
[09:28:24.833]                       else if (inherits(cond, "warning")) {
[09:28:24.833]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.833]                         if (muffled) 
[09:28:24.833]                           invokeRestart("muffleWarning")
[09:28:24.833]                       }
[09:28:24.833]                       else if (inherits(cond, "condition")) {
[09:28:24.833]                         if (!is.null(pattern)) {
[09:28:24.833]                           computeRestarts <- base::computeRestarts
[09:28:24.833]                           grepl <- base::grepl
[09:28:24.833]                           restarts <- computeRestarts(cond)
[09:28:24.833]                           for (restart in restarts) {
[09:28:24.833]                             name <- restart$name
[09:28:24.833]                             if (is.null(name)) 
[09:28:24.833]                               next
[09:28:24.833]                             if (!grepl(pattern, name)) 
[09:28:24.833]                               next
[09:28:24.833]                             invokeRestart(restart)
[09:28:24.833]                             muffled <- TRUE
[09:28:24.833]                             break
[09:28:24.833]                           }
[09:28:24.833]                         }
[09:28:24.833]                       }
[09:28:24.833]                       invisible(muffled)
[09:28:24.833]                     }
[09:28:24.833]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.833]                   }
[09:28:24.833]                 }
[09:28:24.833]             }
[09:28:24.833]         }))
[09:28:24.833]     }, error = function(ex) {
[09:28:24.833]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:24.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.833]                 ...future.rng), started = ...future.startTime, 
[09:28:24.833]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:24.833]             version = "1.8"), class = "FutureResult")
[09:28:24.833]     }, finally = {
[09:28:24.833]         if (!identical(...future.workdir, getwd())) 
[09:28:24.833]             setwd(...future.workdir)
[09:28:24.833]         {
[09:28:24.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:24.833]                 ...future.oldOptions$nwarnings <- NULL
[09:28:24.833]             }
[09:28:24.833]             base::options(...future.oldOptions)
[09:28:24.833]             if (.Platform$OS.type == "windows") {
[09:28:24.833]                 old_names <- names(...future.oldEnvVars)
[09:28:24.833]                 envs <- base::Sys.getenv()
[09:28:24.833]                 names <- names(envs)
[09:28:24.833]                 common <- intersect(names, old_names)
[09:28:24.833]                 added <- setdiff(names, old_names)
[09:28:24.833]                 removed <- setdiff(old_names, names)
[09:28:24.833]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:24.833]                   envs[common]]
[09:28:24.833]                 NAMES <- toupper(changed)
[09:28:24.833]                 args <- list()
[09:28:24.833]                 for (kk in seq_along(NAMES)) {
[09:28:24.833]                   name <- changed[[kk]]
[09:28:24.833]                   NAME <- NAMES[[kk]]
[09:28:24.833]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.833]                     next
[09:28:24.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.833]                 }
[09:28:24.833]                 NAMES <- toupper(added)
[09:28:24.833]                 for (kk in seq_along(NAMES)) {
[09:28:24.833]                   name <- added[[kk]]
[09:28:24.833]                   NAME <- NAMES[[kk]]
[09:28:24.833]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.833]                     next
[09:28:24.833]                   args[[name]] <- ""
[09:28:24.833]                 }
[09:28:24.833]                 NAMES <- toupper(removed)
[09:28:24.833]                 for (kk in seq_along(NAMES)) {
[09:28:24.833]                   name <- removed[[kk]]
[09:28:24.833]                   NAME <- NAMES[[kk]]
[09:28:24.833]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.833]                     next
[09:28:24.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.833]                 }
[09:28:24.833]                 if (length(args) > 0) 
[09:28:24.833]                   base::do.call(base::Sys.setenv, args = args)
[09:28:24.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:24.833]             }
[09:28:24.833]             else {
[09:28:24.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:24.833]             }
[09:28:24.833]             {
[09:28:24.833]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:24.833]                   0L) {
[09:28:24.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:24.833]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:24.833]                   base::options(opts)
[09:28:24.833]                 }
[09:28:24.833]                 {
[09:28:24.833]                   {
[09:28:24.833]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:24.833]                     NULL
[09:28:24.833]                   }
[09:28:24.833]                   options(future.plan = NULL)
[09:28:24.833]                   if (is.na(NA_character_)) 
[09:28:24.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:24.833]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:24.833]                     .init = FALSE)
[09:28:24.833]                 }
[09:28:24.833]             }
[09:28:24.833]         }
[09:28:24.833]     })
[09:28:24.833]     if (TRUE) {
[09:28:24.833]         base::sink(type = "output", split = FALSE)
[09:28:24.833]         if (TRUE) {
[09:28:24.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:24.833]         }
[09:28:24.833]         else {
[09:28:24.833]             ...future.result["stdout"] <- base::list(NULL)
[09:28:24.833]         }
[09:28:24.833]         base::close(...future.stdout)
[09:28:24.833]         ...future.stdout <- NULL
[09:28:24.833]     }
[09:28:24.833]     ...future.result$conditions <- ...future.conditions
[09:28:24.833]     ...future.result$finished <- base::Sys.time()
[09:28:24.833]     ...future.result
[09:28:24.833] }
[09:28:24.836] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[09:28:24.836] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[09:28:24.836] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[09:28:24.837] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[09:28:24.837] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[09:28:24.837] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[09:28:24.837] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[09:28:24.838] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:24.838] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:24.838] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:28:24.838] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:28:24.838] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[09:28:24.839] MultisessionFuture started
[09:28:24.839] - Launch lazy future ... done
[09:28:24.839] run() for ‘MultisessionFuture’ ... done
[09:28:24.839] Created future:
[09:28:24.839] MultisessionFuture:
[09:28:24.839] Label: ‘future_by-2’
[09:28:24.839] Expression:
[09:28:24.839] {
[09:28:24.839]     do.call(function(...) {
[09:28:24.839]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.839]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.839]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.839]             on.exit(options(oopts), add = TRUE)
[09:28:24.839]         }
[09:28:24.839]         {
[09:28:24.839]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.839]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.839]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.839]             })
[09:28:24.839]         }
[09:28:24.839]     }, args = future.call.arguments)
[09:28:24.839] }
[09:28:24.839] Lazy evaluation: FALSE
[09:28:24.839] Asynchronous evaluation: TRUE
[09:28:24.839] Local evaluation: TRUE
[09:28:24.839] Environment: R_GlobalEnv
[09:28:24.839] Capture standard output: TRUE
[09:28:24.839] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:24.839] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:24.839] Packages: 1 packages (‘stats’)
[09:28:24.839] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:24.839] Resolved: FALSE
[09:28:24.839] Value: <not collected>
[09:28:24.839] Conditions captured: <none>
[09:28:24.839] Early signaling: FALSE
[09:28:24.839] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:24.839] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.851] Chunk #2 of 2 ... DONE
[09:28:24.851] Launching 2 futures (chunks) ... DONE
[09:28:24.851] Resolving 2 futures (chunks) ...
[09:28:24.851] resolve() on list ...
[09:28:24.851]  recursive: 0
[09:28:24.851]  length: 2
[09:28:24.851] 
[09:28:24.852] receiveMessageFromWorker() for ClusterFuture ...
[09:28:24.852] - Validating connection of MultisessionFuture
[09:28:24.852] - received message: FutureResult
[09:28:24.852] - Received FutureResult
[09:28:24.852] - Erased future from FutureRegistry
[09:28:24.853] result() for ClusterFuture ...
[09:28:24.853] - result already collected: FutureResult
[09:28:24.853] result() for ClusterFuture ... done
[09:28:24.853] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:24.853] Future #1
[09:28:24.853] result() for ClusterFuture ...
[09:28:24.853] - result already collected: FutureResult
[09:28:24.853] result() for ClusterFuture ... done
[09:28:24.853] result() for ClusterFuture ...
[09:28:24.853] - result already collected: FutureResult
[09:28:24.853] result() for ClusterFuture ... done
[09:28:24.853] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:24.854] - nx: 2
[09:28:24.854] - relay: TRUE
[09:28:24.854] - stdout: TRUE
[09:28:24.854] - signal: TRUE
[09:28:24.854] - resignal: FALSE
[09:28:24.854] - force: TRUE
[09:28:24.854] - relayed: [n=2] FALSE, FALSE
[09:28:24.854] - queued futures: [n=2] FALSE, FALSE
[09:28:24.854]  - until=1
[09:28:24.854]  - relaying element #1
[09:28:24.854] result() for ClusterFuture ...
[09:28:24.854] - result already collected: FutureResult
[09:28:24.855] result() for ClusterFuture ... done
[09:28:24.855] result() for ClusterFuture ...
[09:28:24.855] - result already collected: FutureResult
[09:28:24.855] result() for ClusterFuture ... done
[09:28:24.855] result() for ClusterFuture ...
[09:28:24.855] - result already collected: FutureResult
[09:28:24.855] result() for ClusterFuture ... done
[09:28:24.855] result() for ClusterFuture ...
[09:28:24.855] - result already collected: FutureResult
[09:28:24.855] result() for ClusterFuture ... done
[09:28:24.855] - relayed: [n=2] TRUE, FALSE
[09:28:24.856] - queued futures: [n=2] TRUE, FALSE
[09:28:24.856] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:24.856]  length: 1 (resolved future 1)
[09:28:24.885] receiveMessageFromWorker() for ClusterFuture ...
[09:28:24.885] - Validating connection of MultisessionFuture
[09:28:24.885] - received message: FutureResult
[09:28:24.885] - Received FutureResult
[09:28:24.886] - Erased future from FutureRegistry
[09:28:24.886] result() for ClusterFuture ...
[09:28:24.886] - result already collected: FutureResult
[09:28:24.886] result() for ClusterFuture ... done
[09:28:24.886] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:24.886] Future #2
[09:28:24.886] result() for ClusterFuture ...
[09:28:24.886] - result already collected: FutureResult
[09:28:24.886] result() for ClusterFuture ... done
[09:28:24.886] result() for ClusterFuture ...
[09:28:24.886] - result already collected: FutureResult
[09:28:24.887] result() for ClusterFuture ... done
[09:28:24.887] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:24.887] - nx: 2
[09:28:24.887] - relay: TRUE
[09:28:24.887] - stdout: TRUE
[09:28:24.887] - signal: TRUE
[09:28:24.887] - resignal: FALSE
[09:28:24.887] - force: TRUE
[09:28:24.887] - relayed: [n=2] TRUE, FALSE
[09:28:24.887] - queued futures: [n=2] TRUE, FALSE
[09:28:24.887]  - until=2
[09:28:24.887]  - relaying element #2
[09:28:24.888] result() for ClusterFuture ...
[09:28:24.888] - result already collected: FutureResult
[09:28:24.888] result() for ClusterFuture ... done
[09:28:24.888] result() for ClusterFuture ...
[09:28:24.888] - result already collected: FutureResult
[09:28:24.888] result() for ClusterFuture ... done
[09:28:24.888] result() for ClusterFuture ...
[09:28:24.888] - result already collected: FutureResult
[09:28:24.888] result() for ClusterFuture ... done
[09:28:24.888] result() for ClusterFuture ...
[09:28:24.888] - result already collected: FutureResult
[09:28:24.889] result() for ClusterFuture ... done
[09:28:24.889] - relayed: [n=2] TRUE, TRUE
[09:28:24.889] - queued futures: [n=2] TRUE, TRUE
[09:28:24.889] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:24.889]  length: 0 (resolved future 2)
[09:28:24.889] Relaying remaining futures
[09:28:24.889] signalConditionsASAP(NULL, pos=0) ...
[09:28:24.889] - nx: 2
[09:28:24.889] - relay: TRUE
[09:28:24.889] - stdout: TRUE
[09:28:24.889] - signal: TRUE
[09:28:24.889] - resignal: FALSE
[09:28:24.889] - force: TRUE
[09:28:24.890] - relayed: [n=2] TRUE, TRUE
[09:28:24.890] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:24.890] - relayed: [n=2] TRUE, TRUE
[09:28:24.890] - queued futures: [n=2] TRUE, TRUE
[09:28:24.890] signalConditionsASAP(NULL, pos=0) ... done
[09:28:24.890] resolve() on list ... DONE
[09:28:24.890] result() for ClusterFuture ...
[09:28:24.890] - result already collected: FutureResult
[09:28:24.890] result() for ClusterFuture ... done
[09:28:24.890] result() for ClusterFuture ...
[09:28:24.890] - result already collected: FutureResult
[09:28:24.891] result() for ClusterFuture ... done
[09:28:24.891] result() for ClusterFuture ...
[09:28:24.891] - result already collected: FutureResult
[09:28:24.891] result() for ClusterFuture ... done
[09:28:24.891] result() for ClusterFuture ...
[09:28:24.891] - result already collected: FutureResult
[09:28:24.891] result() for ClusterFuture ... done
[09:28:24.891]  - Number of value chunks collected: 2
[09:28:24.891] Resolving 2 futures (chunks) ... DONE
[09:28:24.891] Reducing values from 2 chunks ...
[09:28:24.891]  - Number of values collected after concatenation: 3
[09:28:24.892]  - Number of values expected: 3
[09:28:24.892] Reducing values from 2 chunks ... DONE
[09:28:24.892] future_lapply() ... DONE
[09:28:24.892] future_by_internal() ... DONE
[09:28:24.895] future_by_internal() ...
[09:28:24.896] future_lapply() ...
[09:28:24.900] Number of chunks: 2
[09:28:24.900] getGlobalsAndPackagesXApply() ...
[09:28:24.900]  - future.globals: TRUE
[09:28:24.900] getGlobalsAndPackages() ...
[09:28:24.900] Searching for globals...
[09:28:24.902] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[09:28:24.902] Searching for globals ... DONE
[09:28:24.902] Resolving globals: FALSE
[09:28:24.903] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[09:28:24.903] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[09:28:24.903] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:24.903] - packages: [1] ‘stats’
[09:28:24.903] getGlobalsAndPackages() ... DONE
[09:28:24.903]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[09:28:24.904]  - needed namespaces: [n=1] ‘stats’
[09:28:24.904] Finding globals ... DONE
[09:28:24.904]  - use_args: TRUE
[09:28:24.904]  - Getting '...' globals ...
[09:28:24.904] resolve() on list ...
[09:28:24.904]  recursive: 0
[09:28:24.904]  length: 1
[09:28:24.904]  elements: ‘...’
[09:28:24.905]  length: 0 (resolved future 1)
[09:28:24.905] resolve() on list ... DONE
[09:28:24.905]    - '...' content: [n=0] 
[09:28:24.905] List of 1
[09:28:24.905]  $ ...: list()
[09:28:24.905]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:24.905]  - attr(*, "where")=List of 1
[09:28:24.905]   ..$ ...:<environment: 0x555b0bd18828> 
[09:28:24.905]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:24.905]  - attr(*, "resolved")= logi TRUE
[09:28:24.905]  - attr(*, "total_size")= num NA
[09:28:24.907]  - Getting '...' globals ... DONE
[09:28:24.907] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[09:28:24.908] List of 4
[09:28:24.908]  $ ...future.FUN:function (x)  
[09:28:24.908]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[09:28:24.908]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[09:28:24.908]  $ ...          : list()
[09:28:24.908]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:24.908]  - attr(*, "where")=List of 4
[09:28:24.908]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:24.908]   ..$ breaks       :<environment: R_EmptyEnv> 
[09:28:24.908]   ..$ wool         :<environment: R_EmptyEnv> 
[09:28:24.908]   ..$ ...          :<environment: 0x555b0bd18828> 
[09:28:24.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:24.908]  - attr(*, "resolved")= logi FALSE
[09:28:24.908]  - attr(*, "total_size")= num 2320
[09:28:24.911] Packages to be attached in all futures: [n=1] ‘stats’
[09:28:24.911] getGlobalsAndPackagesXApply() ... DONE
[09:28:24.912] Number of futures (= number of chunks): 2
[09:28:24.912] Launching 2 futures (chunks) ...
[09:28:24.912] Chunk #1 of 2 ...
[09:28:24.912]  - Finding globals in 'X' for chunk #1 ...
[09:28:24.912] getGlobalsAndPackages() ...
[09:28:24.912] Searching for globals...
[09:28:24.913] 
[09:28:24.913] Searching for globals ... DONE
[09:28:24.913] - globals: [0] <none>
[09:28:24.913] getGlobalsAndPackages() ... DONE
[09:28:24.913]    + additional globals found: [n=0] 
[09:28:24.913]    + additional namespaces needed: [n=0] 
[09:28:24.913]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:24.913]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:24.913]  - seeds: <none>
[09:28:24.913]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.913] getGlobalsAndPackages() ...
[09:28:24.914] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.914] Resolving globals: FALSE
[09:28:24.914] Tweak future expression to call with '...' arguments ...
[09:28:24.914] {
[09:28:24.914]     do.call(function(...) {
[09:28:24.914]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.914]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.914]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.914]             on.exit(options(oopts), add = TRUE)
[09:28:24.914]         }
[09:28:24.914]         {
[09:28:24.914]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.914]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.914]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.914]             })
[09:28:24.914]         }
[09:28:24.914]     }, args = future.call.arguments)
[09:28:24.914] }
[09:28:24.914] Tweak future expression to call with '...' arguments ... DONE
[09:28:24.914] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.915] 
[09:28:24.915] getGlobalsAndPackages() ... DONE
[09:28:24.915] run() for ‘Future’ ...
[09:28:24.915] - state: ‘created’
[09:28:24.915] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:24.929] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.929] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:24.929]   - Field: ‘node’
[09:28:24.929]   - Field: ‘label’
[09:28:24.929]   - Field: ‘local’
[09:28:24.929]   - Field: ‘owner’
[09:28:24.929]   - Field: ‘envir’
[09:28:24.929]   - Field: ‘workers’
[09:28:24.929]   - Field: ‘packages’
[09:28:24.930]   - Field: ‘gc’
[09:28:24.930]   - Field: ‘conditions’
[09:28:24.930]   - Field: ‘persistent’
[09:28:24.930]   - Field: ‘expr’
[09:28:24.930]   - Field: ‘uuid’
[09:28:24.930]   - Field: ‘seed’
[09:28:24.930]   - Field: ‘version’
[09:28:24.930]   - Field: ‘result’
[09:28:24.930]   - Field: ‘asynchronous’
[09:28:24.930]   - Field: ‘calls’
[09:28:24.930]   - Field: ‘globals’
[09:28:24.930]   - Field: ‘stdout’
[09:28:24.931]   - Field: ‘earlySignal’
[09:28:24.931]   - Field: ‘lazy’
[09:28:24.931]   - Field: ‘state’
[09:28:24.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:24.931] - Launch lazy future ...
[09:28:24.931] Packages needed by the future expression (n = 1): ‘stats’
[09:28:24.931] Packages needed by future strategies (n = 0): <none>
[09:28:24.932] {
[09:28:24.932]     {
[09:28:24.932]         {
[09:28:24.932]             ...future.startTime <- base::Sys.time()
[09:28:24.932]             {
[09:28:24.932]                 {
[09:28:24.932]                   {
[09:28:24.932]                     {
[09:28:24.932]                       {
[09:28:24.932]                         base::local({
[09:28:24.932]                           has_future <- base::requireNamespace("future", 
[09:28:24.932]                             quietly = TRUE)
[09:28:24.932]                           if (has_future) {
[09:28:24.932]                             ns <- base::getNamespace("future")
[09:28:24.932]                             version <- ns[[".package"]][["version"]]
[09:28:24.932]                             if (is.null(version)) 
[09:28:24.932]                               version <- utils::packageVersion("future")
[09:28:24.932]                           }
[09:28:24.932]                           else {
[09:28:24.932]                             version <- NULL
[09:28:24.932]                           }
[09:28:24.932]                           if (!has_future || version < "1.8.0") {
[09:28:24.932]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:24.932]                               "", base::R.version$version.string), 
[09:28:24.932]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:24.932]                                 base::R.version$platform, 8 * 
[09:28:24.932]                                   base::.Machine$sizeof.pointer), 
[09:28:24.932]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:24.932]                                 "release", "version")], collapse = " "), 
[09:28:24.932]                               hostname = base::Sys.info()[["nodename"]])
[09:28:24.932]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:24.932]                               info)
[09:28:24.932]                             info <- base::paste(info, collapse = "; ")
[09:28:24.932]                             if (!has_future) {
[09:28:24.932]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:24.932]                                 info)
[09:28:24.932]                             }
[09:28:24.932]                             else {
[09:28:24.932]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:24.932]                                 info, version)
[09:28:24.932]                             }
[09:28:24.932]                             base::stop(msg)
[09:28:24.932]                           }
[09:28:24.932]                         })
[09:28:24.932]                       }
[09:28:24.932]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:24.932]                       base::options(mc.cores = 1L)
[09:28:24.932]                     }
[09:28:24.932]                     base::local({
[09:28:24.932]                       for (pkg in "stats") {
[09:28:24.932]                         base::loadNamespace(pkg)
[09:28:24.932]                         base::library(pkg, character.only = TRUE)
[09:28:24.932]                       }
[09:28:24.932]                     })
[09:28:24.932]                   }
[09:28:24.932]                   ...future.strategy.old <- future::plan("list")
[09:28:24.932]                   options(future.plan = NULL)
[09:28:24.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:24.932]                 }
[09:28:24.932]                 ...future.workdir <- getwd()
[09:28:24.932]             }
[09:28:24.932]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:24.932]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:24.932]         }
[09:28:24.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:24.932]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:24.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:24.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:24.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:24.932]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:24.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:24.932]             base::names(...future.oldOptions))
[09:28:24.932]     }
[09:28:24.932]     if (FALSE) {
[09:28:24.932]     }
[09:28:24.932]     else {
[09:28:24.932]         if (TRUE) {
[09:28:24.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:24.932]                 open = "w")
[09:28:24.932]         }
[09:28:24.932]         else {
[09:28:24.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:24.932]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:24.932]         }
[09:28:24.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:24.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:24.932]             base::sink(type = "output", split = FALSE)
[09:28:24.932]             base::close(...future.stdout)
[09:28:24.932]         }, add = TRUE)
[09:28:24.932]     }
[09:28:24.932]     ...future.frame <- base::sys.nframe()
[09:28:24.932]     ...future.conditions <- base::list()
[09:28:24.932]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:24.932]     if (FALSE) {
[09:28:24.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:24.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:24.932]     }
[09:28:24.932]     ...future.result <- base::tryCatch({
[09:28:24.932]         base::withCallingHandlers({
[09:28:24.932]             ...future.value <- base::withVisible(base::local({
[09:28:24.932]                 ...future.makeSendCondition <- base::local({
[09:28:24.932]                   sendCondition <- NULL
[09:28:24.932]                   function(frame = 1L) {
[09:28:24.932]                     if (is.function(sendCondition)) 
[09:28:24.932]                       return(sendCondition)
[09:28:24.932]                     ns <- getNamespace("parallel")
[09:28:24.932]                     if (exists("sendData", mode = "function", 
[09:28:24.932]                       envir = ns)) {
[09:28:24.932]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:24.932]                         envir = ns)
[09:28:24.932]                       envir <- sys.frame(frame)
[09:28:24.932]                       master <- NULL
[09:28:24.932]                       while (!identical(envir, .GlobalEnv) && 
[09:28:24.932]                         !identical(envir, emptyenv())) {
[09:28:24.932]                         if (exists("master", mode = "list", envir = envir, 
[09:28:24.932]                           inherits = FALSE)) {
[09:28:24.932]                           master <- get("master", mode = "list", 
[09:28:24.932]                             envir = envir, inherits = FALSE)
[09:28:24.932]                           if (inherits(master, c("SOCKnode", 
[09:28:24.932]                             "SOCK0node"))) {
[09:28:24.932]                             sendCondition <<- function(cond) {
[09:28:24.932]                               data <- list(type = "VALUE", value = cond, 
[09:28:24.932]                                 success = TRUE)
[09:28:24.932]                               parallel_sendData(master, data)
[09:28:24.932]                             }
[09:28:24.932]                             return(sendCondition)
[09:28:24.932]                           }
[09:28:24.932]                         }
[09:28:24.932]                         frame <- frame + 1L
[09:28:24.932]                         envir <- sys.frame(frame)
[09:28:24.932]                       }
[09:28:24.932]                     }
[09:28:24.932]                     sendCondition <<- function(cond) NULL
[09:28:24.932]                   }
[09:28:24.932]                 })
[09:28:24.932]                 withCallingHandlers({
[09:28:24.932]                   {
[09:28:24.932]                     do.call(function(...) {
[09:28:24.932]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.932]                       if (!identical(...future.globals.maxSize.org, 
[09:28:24.932]                         ...future.globals.maxSize)) {
[09:28:24.932]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.932]                         on.exit(options(oopts), add = TRUE)
[09:28:24.932]                       }
[09:28:24.932]                       {
[09:28:24.932]                         lapply(seq_along(...future.elements_ii), 
[09:28:24.932]                           FUN = function(jj) {
[09:28:24.932]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.932]                             ...future.FUN(...future.X_jj, ...)
[09:28:24.932]                           })
[09:28:24.932]                       }
[09:28:24.932]                     }, args = future.call.arguments)
[09:28:24.932]                   }
[09:28:24.932]                 }, immediateCondition = function(cond) {
[09:28:24.932]                   sendCondition <- ...future.makeSendCondition()
[09:28:24.932]                   sendCondition(cond)
[09:28:24.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.932]                   {
[09:28:24.932]                     inherits <- base::inherits
[09:28:24.932]                     invokeRestart <- base::invokeRestart
[09:28:24.932]                     is.null <- base::is.null
[09:28:24.932]                     muffled <- FALSE
[09:28:24.932]                     if (inherits(cond, "message")) {
[09:28:24.932]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:24.932]                       if (muffled) 
[09:28:24.932]                         invokeRestart("muffleMessage")
[09:28:24.932]                     }
[09:28:24.932]                     else if (inherits(cond, "warning")) {
[09:28:24.932]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:24.932]                       if (muffled) 
[09:28:24.932]                         invokeRestart("muffleWarning")
[09:28:24.932]                     }
[09:28:24.932]                     else if (inherits(cond, "condition")) {
[09:28:24.932]                       if (!is.null(pattern)) {
[09:28:24.932]                         computeRestarts <- base::computeRestarts
[09:28:24.932]                         grepl <- base::grepl
[09:28:24.932]                         restarts <- computeRestarts(cond)
[09:28:24.932]                         for (restart in restarts) {
[09:28:24.932]                           name <- restart$name
[09:28:24.932]                           if (is.null(name)) 
[09:28:24.932]                             next
[09:28:24.932]                           if (!grepl(pattern, name)) 
[09:28:24.932]                             next
[09:28:24.932]                           invokeRestart(restart)
[09:28:24.932]                           muffled <- TRUE
[09:28:24.932]                           break
[09:28:24.932]                         }
[09:28:24.932]                       }
[09:28:24.932]                     }
[09:28:24.932]                     invisible(muffled)
[09:28:24.932]                   }
[09:28:24.932]                   muffleCondition(cond)
[09:28:24.932]                 })
[09:28:24.932]             }))
[09:28:24.932]             future::FutureResult(value = ...future.value$value, 
[09:28:24.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.932]                   ...future.rng), globalenv = if (FALSE) 
[09:28:24.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:24.932]                     ...future.globalenv.names))
[09:28:24.932]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:24.932]         }, condition = base::local({
[09:28:24.932]             c <- base::c
[09:28:24.932]             inherits <- base::inherits
[09:28:24.932]             invokeRestart <- base::invokeRestart
[09:28:24.932]             length <- base::length
[09:28:24.932]             list <- base::list
[09:28:24.932]             seq.int <- base::seq.int
[09:28:24.932]             signalCondition <- base::signalCondition
[09:28:24.932]             sys.calls <- base::sys.calls
[09:28:24.932]             `[[` <- base::`[[`
[09:28:24.932]             `+` <- base::`+`
[09:28:24.932]             `<<-` <- base::`<<-`
[09:28:24.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:24.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:24.932]                   3L)]
[09:28:24.932]             }
[09:28:24.932]             function(cond) {
[09:28:24.932]                 is_error <- inherits(cond, "error")
[09:28:24.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:24.932]                   NULL)
[09:28:24.932]                 if (is_error) {
[09:28:24.932]                   sessionInformation <- function() {
[09:28:24.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:24.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:24.932]                       search = base::search(), system = base::Sys.info())
[09:28:24.932]                   }
[09:28:24.932]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:24.932]                     cond$call), session = sessionInformation(), 
[09:28:24.932]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:24.932]                   signalCondition(cond)
[09:28:24.932]                 }
[09:28:24.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:24.932]                 "immediateCondition"))) {
[09:28:24.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:24.932]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:24.932]                   if (TRUE && !signal) {
[09:28:24.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.932]                     {
[09:28:24.932]                       inherits <- base::inherits
[09:28:24.932]                       invokeRestart <- base::invokeRestart
[09:28:24.932]                       is.null <- base::is.null
[09:28:24.932]                       muffled <- FALSE
[09:28:24.932]                       if (inherits(cond, "message")) {
[09:28:24.932]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.932]                         if (muffled) 
[09:28:24.932]                           invokeRestart("muffleMessage")
[09:28:24.932]                       }
[09:28:24.932]                       else if (inherits(cond, "warning")) {
[09:28:24.932]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.932]                         if (muffled) 
[09:28:24.932]                           invokeRestart("muffleWarning")
[09:28:24.932]                       }
[09:28:24.932]                       else if (inherits(cond, "condition")) {
[09:28:24.932]                         if (!is.null(pattern)) {
[09:28:24.932]                           computeRestarts <- base::computeRestarts
[09:28:24.932]                           grepl <- base::grepl
[09:28:24.932]                           restarts <- computeRestarts(cond)
[09:28:24.932]                           for (restart in restarts) {
[09:28:24.932]                             name <- restart$name
[09:28:24.932]                             if (is.null(name)) 
[09:28:24.932]                               next
[09:28:24.932]                             if (!grepl(pattern, name)) 
[09:28:24.932]                               next
[09:28:24.932]                             invokeRestart(restart)
[09:28:24.932]                             muffled <- TRUE
[09:28:24.932]                             break
[09:28:24.932]                           }
[09:28:24.932]                         }
[09:28:24.932]                       }
[09:28:24.932]                       invisible(muffled)
[09:28:24.932]                     }
[09:28:24.932]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.932]                   }
[09:28:24.932]                 }
[09:28:24.932]                 else {
[09:28:24.932]                   if (TRUE) {
[09:28:24.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.932]                     {
[09:28:24.932]                       inherits <- base::inherits
[09:28:24.932]                       invokeRestart <- base::invokeRestart
[09:28:24.932]                       is.null <- base::is.null
[09:28:24.932]                       muffled <- FALSE
[09:28:24.932]                       if (inherits(cond, "message")) {
[09:28:24.932]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.932]                         if (muffled) 
[09:28:24.932]                           invokeRestart("muffleMessage")
[09:28:24.932]                       }
[09:28:24.932]                       else if (inherits(cond, "warning")) {
[09:28:24.932]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.932]                         if (muffled) 
[09:28:24.932]                           invokeRestart("muffleWarning")
[09:28:24.932]                       }
[09:28:24.932]                       else if (inherits(cond, "condition")) {
[09:28:24.932]                         if (!is.null(pattern)) {
[09:28:24.932]                           computeRestarts <- base::computeRestarts
[09:28:24.932]                           grepl <- base::grepl
[09:28:24.932]                           restarts <- computeRestarts(cond)
[09:28:24.932]                           for (restart in restarts) {
[09:28:24.932]                             name <- restart$name
[09:28:24.932]                             if (is.null(name)) 
[09:28:24.932]                               next
[09:28:24.932]                             if (!grepl(pattern, name)) 
[09:28:24.932]                               next
[09:28:24.932]                             invokeRestart(restart)
[09:28:24.932]                             muffled <- TRUE
[09:28:24.932]                             break
[09:28:24.932]                           }
[09:28:24.932]                         }
[09:28:24.932]                       }
[09:28:24.932]                       invisible(muffled)
[09:28:24.932]                     }
[09:28:24.932]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.932]                   }
[09:28:24.932]                 }
[09:28:24.932]             }
[09:28:24.932]         }))
[09:28:24.932]     }, error = function(ex) {
[09:28:24.932]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:24.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.932]                 ...future.rng), started = ...future.startTime, 
[09:28:24.932]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:24.932]             version = "1.8"), class = "FutureResult")
[09:28:24.932]     }, finally = {
[09:28:24.932]         if (!identical(...future.workdir, getwd())) 
[09:28:24.932]             setwd(...future.workdir)
[09:28:24.932]         {
[09:28:24.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:24.932]                 ...future.oldOptions$nwarnings <- NULL
[09:28:24.932]             }
[09:28:24.932]             base::options(...future.oldOptions)
[09:28:24.932]             if (.Platform$OS.type == "windows") {
[09:28:24.932]                 old_names <- names(...future.oldEnvVars)
[09:28:24.932]                 envs <- base::Sys.getenv()
[09:28:24.932]                 names <- names(envs)
[09:28:24.932]                 common <- intersect(names, old_names)
[09:28:24.932]                 added <- setdiff(names, old_names)
[09:28:24.932]                 removed <- setdiff(old_names, names)
[09:28:24.932]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:24.932]                   envs[common]]
[09:28:24.932]                 NAMES <- toupper(changed)
[09:28:24.932]                 args <- list()
[09:28:24.932]                 for (kk in seq_along(NAMES)) {
[09:28:24.932]                   name <- changed[[kk]]
[09:28:24.932]                   NAME <- NAMES[[kk]]
[09:28:24.932]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.932]                     next
[09:28:24.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.932]                 }
[09:28:24.932]                 NAMES <- toupper(added)
[09:28:24.932]                 for (kk in seq_along(NAMES)) {
[09:28:24.932]                   name <- added[[kk]]
[09:28:24.932]                   NAME <- NAMES[[kk]]
[09:28:24.932]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.932]                     next
[09:28:24.932]                   args[[name]] <- ""
[09:28:24.932]                 }
[09:28:24.932]                 NAMES <- toupper(removed)
[09:28:24.932]                 for (kk in seq_along(NAMES)) {
[09:28:24.932]                   name <- removed[[kk]]
[09:28:24.932]                   NAME <- NAMES[[kk]]
[09:28:24.932]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.932]                     next
[09:28:24.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.932]                 }
[09:28:24.932]                 if (length(args) > 0) 
[09:28:24.932]                   base::do.call(base::Sys.setenv, args = args)
[09:28:24.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:24.932]             }
[09:28:24.932]             else {
[09:28:24.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:24.932]             }
[09:28:24.932]             {
[09:28:24.932]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:24.932]                   0L) {
[09:28:24.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:24.932]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:24.932]                   base::options(opts)
[09:28:24.932]                 }
[09:28:24.932]                 {
[09:28:24.932]                   {
[09:28:24.932]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:24.932]                     NULL
[09:28:24.932]                   }
[09:28:24.932]                   options(future.plan = NULL)
[09:28:24.932]                   if (is.na(NA_character_)) 
[09:28:24.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:24.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:24.932]                     .init = FALSE)
[09:28:24.932]                 }
[09:28:24.932]             }
[09:28:24.932]         }
[09:28:24.932]     })
[09:28:24.932]     if (TRUE) {
[09:28:24.932]         base::sink(type = "output", split = FALSE)
[09:28:24.932]         if (TRUE) {
[09:28:24.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:24.932]         }
[09:28:24.932]         else {
[09:28:24.932]             ...future.result["stdout"] <- base::list(NULL)
[09:28:24.932]         }
[09:28:24.932]         base::close(...future.stdout)
[09:28:24.932]         ...future.stdout <- NULL
[09:28:24.932]     }
[09:28:24.932]     ...future.result$conditions <- ...future.conditions
[09:28:24.932]     ...future.result$finished <- base::Sys.time()
[09:28:24.932]     ...future.result
[09:28:24.932] }
[09:28:24.934] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[09:28:24.935] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[09:28:24.935] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[09:28:24.935] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[09:28:24.936] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[09:28:24.936] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[09:28:24.936] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[09:28:24.936] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:24.937] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:24.937] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[09:28:24.937] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[09:28:24.937] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:24.938] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:24.938] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:28:24.938] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:28:24.938] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[09:28:24.939] MultisessionFuture started
[09:28:24.939] - Launch lazy future ... done
[09:28:24.939] run() for ‘MultisessionFuture’ ... done
[09:28:24.939] Created future:
[09:28:24.939] MultisessionFuture:
[09:28:24.939] Label: ‘future_by-1’
[09:28:24.939] Expression:
[09:28:24.939] {
[09:28:24.939]     do.call(function(...) {
[09:28:24.939]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.939]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.939]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.939]             on.exit(options(oopts), add = TRUE)
[09:28:24.939]         }
[09:28:24.939]         {
[09:28:24.939]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.939]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.939]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.939]             })
[09:28:24.939]         }
[09:28:24.939]     }, args = future.call.arguments)
[09:28:24.939] }
[09:28:24.939] Lazy evaluation: FALSE
[09:28:24.939] Asynchronous evaluation: TRUE
[09:28:24.939] Local evaluation: TRUE
[09:28:24.939] Environment: 0x555b0bceef70
[09:28:24.939] Capture standard output: TRUE
[09:28:24.939] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:24.939] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[09:28:24.939] Packages: 1 packages (‘stats’)
[09:28:24.939] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:24.939] Resolved: FALSE
[09:28:24.939] Value: <not collected>
[09:28:24.939] Conditions captured: <none>
[09:28:24.939] Early signaling: FALSE
[09:28:24.939] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:24.939] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.951] Chunk #1 of 2 ... DONE
[09:28:24.951] Chunk #2 of 2 ...
[09:28:24.951]  - Finding globals in 'X' for chunk #2 ...
[09:28:24.951] getGlobalsAndPackages() ...
[09:28:24.952] Searching for globals...
[09:28:24.952] 
[09:28:24.952] Searching for globals ... DONE
[09:28:24.952] - globals: [0] <none>
[09:28:24.952] getGlobalsAndPackages() ... DONE
[09:28:24.952]    + additional globals found: [n=0] 
[09:28:24.952]    + additional namespaces needed: [n=0] 
[09:28:24.953]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:24.953]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:24.953]  - seeds: <none>
[09:28:24.953]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.953] getGlobalsAndPackages() ...
[09:28:24.953] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.953] Resolving globals: FALSE
[09:28:24.953] Tweak future expression to call with '...' arguments ...
[09:28:24.953] {
[09:28:24.953]     do.call(function(...) {
[09:28:24.953]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.953]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.953]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.953]             on.exit(options(oopts), add = TRUE)
[09:28:24.953]         }
[09:28:24.953]         {
[09:28:24.953]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.953]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.953]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.953]             })
[09:28:24.953]         }
[09:28:24.953]     }, args = future.call.arguments)
[09:28:24.953] }
[09:28:24.954] Tweak future expression to call with '...' arguments ... DONE
[09:28:24.954] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:24.954] 
[09:28:24.954] getGlobalsAndPackages() ... DONE
[09:28:24.954] run() for ‘Future’ ...
[09:28:24.955] - state: ‘created’
[09:28:24.955] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:24.968] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.969] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:24.969]   - Field: ‘node’
[09:28:24.969]   - Field: ‘label’
[09:28:24.969]   - Field: ‘local’
[09:28:24.969]   - Field: ‘owner’
[09:28:24.969]   - Field: ‘envir’
[09:28:24.969]   - Field: ‘workers’
[09:28:24.969]   - Field: ‘packages’
[09:28:24.969]   - Field: ‘gc’
[09:28:24.969]   - Field: ‘conditions’
[09:28:24.970]   - Field: ‘persistent’
[09:28:24.970]   - Field: ‘expr’
[09:28:24.970]   - Field: ‘uuid’
[09:28:24.970]   - Field: ‘seed’
[09:28:24.970]   - Field: ‘version’
[09:28:24.970]   - Field: ‘result’
[09:28:24.970]   - Field: ‘asynchronous’
[09:28:24.970]   - Field: ‘calls’
[09:28:24.970]   - Field: ‘globals’
[09:28:24.970]   - Field: ‘stdout’
[09:28:24.973]   - Field: ‘earlySignal’
[09:28:24.973]   - Field: ‘lazy’
[09:28:24.973]   - Field: ‘state’
[09:28:24.973] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:24.973] - Launch lazy future ...
[09:28:24.973] Packages needed by the future expression (n = 1): ‘stats’
[09:28:24.973] Packages needed by future strategies (n = 0): <none>
[09:28:24.974] {
[09:28:24.974]     {
[09:28:24.974]         {
[09:28:24.974]             ...future.startTime <- base::Sys.time()
[09:28:24.974]             {
[09:28:24.974]                 {
[09:28:24.974]                   {
[09:28:24.974]                     {
[09:28:24.974]                       {
[09:28:24.974]                         base::local({
[09:28:24.974]                           has_future <- base::requireNamespace("future", 
[09:28:24.974]                             quietly = TRUE)
[09:28:24.974]                           if (has_future) {
[09:28:24.974]                             ns <- base::getNamespace("future")
[09:28:24.974]                             version <- ns[[".package"]][["version"]]
[09:28:24.974]                             if (is.null(version)) 
[09:28:24.974]                               version <- utils::packageVersion("future")
[09:28:24.974]                           }
[09:28:24.974]                           else {
[09:28:24.974]                             version <- NULL
[09:28:24.974]                           }
[09:28:24.974]                           if (!has_future || version < "1.8.0") {
[09:28:24.974]                             info <- base::c(r_version = base::gsub("R version ", 
[09:28:24.974]                               "", base::R.version$version.string), 
[09:28:24.974]                               platform = base::sprintf("%s (%s-bit)", 
[09:28:24.974]                                 base::R.version$platform, 8 * 
[09:28:24.974]                                   base::.Machine$sizeof.pointer), 
[09:28:24.974]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:24.974]                                 "release", "version")], collapse = " "), 
[09:28:24.974]                               hostname = base::Sys.info()[["nodename"]])
[09:28:24.974]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:28:24.974]                               info)
[09:28:24.974]                             info <- base::paste(info, collapse = "; ")
[09:28:24.974]                             if (!has_future) {
[09:28:24.974]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:24.974]                                 info)
[09:28:24.974]                             }
[09:28:24.974]                             else {
[09:28:24.974]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:24.974]                                 info, version)
[09:28:24.974]                             }
[09:28:24.974]                             base::stop(msg)
[09:28:24.974]                           }
[09:28:24.974]                         })
[09:28:24.974]                       }
[09:28:24.974]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:24.974]                       base::options(mc.cores = 1L)
[09:28:24.974]                     }
[09:28:24.974]                     base::local({
[09:28:24.974]                       for (pkg in "stats") {
[09:28:24.974]                         base::loadNamespace(pkg)
[09:28:24.974]                         base::library(pkg, character.only = TRUE)
[09:28:24.974]                       }
[09:28:24.974]                     })
[09:28:24.974]                   }
[09:28:24.974]                   ...future.strategy.old <- future::plan("list")
[09:28:24.974]                   options(future.plan = NULL)
[09:28:24.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:24.974]                 }
[09:28:24.974]                 ...future.workdir <- getwd()
[09:28:24.974]             }
[09:28:24.974]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:24.974]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:24.974]         }
[09:28:24.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:24.974]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:24.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:24.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:24.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:24.974]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:24.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:24.974]             base::names(...future.oldOptions))
[09:28:24.974]     }
[09:28:24.974]     if (FALSE) {
[09:28:24.974]     }
[09:28:24.974]     else {
[09:28:24.974]         if (TRUE) {
[09:28:24.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:24.974]                 open = "w")
[09:28:24.974]         }
[09:28:24.974]         else {
[09:28:24.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:24.974]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:24.974]         }
[09:28:24.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:24.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:24.974]             base::sink(type = "output", split = FALSE)
[09:28:24.974]             base::close(...future.stdout)
[09:28:24.974]         }, add = TRUE)
[09:28:24.974]     }
[09:28:24.974]     ...future.frame <- base::sys.nframe()
[09:28:24.974]     ...future.conditions <- base::list()
[09:28:24.974]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:24.974]     if (FALSE) {
[09:28:24.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:24.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:24.974]     }
[09:28:24.974]     ...future.result <- base::tryCatch({
[09:28:24.974]         base::withCallingHandlers({
[09:28:24.974]             ...future.value <- base::withVisible(base::local({
[09:28:24.974]                 ...future.makeSendCondition <- base::local({
[09:28:24.974]                   sendCondition <- NULL
[09:28:24.974]                   function(frame = 1L) {
[09:28:24.974]                     if (is.function(sendCondition)) 
[09:28:24.974]                       return(sendCondition)
[09:28:24.974]                     ns <- getNamespace("parallel")
[09:28:24.974]                     if (exists("sendData", mode = "function", 
[09:28:24.974]                       envir = ns)) {
[09:28:24.974]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:24.974]                         envir = ns)
[09:28:24.974]                       envir <- sys.frame(frame)
[09:28:24.974]                       master <- NULL
[09:28:24.974]                       while (!identical(envir, .GlobalEnv) && 
[09:28:24.974]                         !identical(envir, emptyenv())) {
[09:28:24.974]                         if (exists("master", mode = "list", envir = envir, 
[09:28:24.974]                           inherits = FALSE)) {
[09:28:24.974]                           master <- get("master", mode = "list", 
[09:28:24.974]                             envir = envir, inherits = FALSE)
[09:28:24.974]                           if (inherits(master, c("SOCKnode", 
[09:28:24.974]                             "SOCK0node"))) {
[09:28:24.974]                             sendCondition <<- function(cond) {
[09:28:24.974]                               data <- list(type = "VALUE", value = cond, 
[09:28:24.974]                                 success = TRUE)
[09:28:24.974]                               parallel_sendData(master, data)
[09:28:24.974]                             }
[09:28:24.974]                             return(sendCondition)
[09:28:24.974]                           }
[09:28:24.974]                         }
[09:28:24.974]                         frame <- frame + 1L
[09:28:24.974]                         envir <- sys.frame(frame)
[09:28:24.974]                       }
[09:28:24.974]                     }
[09:28:24.974]                     sendCondition <<- function(cond) NULL
[09:28:24.974]                   }
[09:28:24.974]                 })
[09:28:24.974]                 withCallingHandlers({
[09:28:24.974]                   {
[09:28:24.974]                     do.call(function(...) {
[09:28:24.974]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.974]                       if (!identical(...future.globals.maxSize.org, 
[09:28:24.974]                         ...future.globals.maxSize)) {
[09:28:24.974]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.974]                         on.exit(options(oopts), add = TRUE)
[09:28:24.974]                       }
[09:28:24.974]                       {
[09:28:24.974]                         lapply(seq_along(...future.elements_ii), 
[09:28:24.974]                           FUN = function(jj) {
[09:28:24.974]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.974]                             ...future.FUN(...future.X_jj, ...)
[09:28:24.974]                           })
[09:28:24.974]                       }
[09:28:24.974]                     }, args = future.call.arguments)
[09:28:24.974]                   }
[09:28:24.974]                 }, immediateCondition = function(cond) {
[09:28:24.974]                   sendCondition <- ...future.makeSendCondition()
[09:28:24.974]                   sendCondition(cond)
[09:28:24.974]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.974]                   {
[09:28:24.974]                     inherits <- base::inherits
[09:28:24.974]                     invokeRestart <- base::invokeRestart
[09:28:24.974]                     is.null <- base::is.null
[09:28:24.974]                     muffled <- FALSE
[09:28:24.974]                     if (inherits(cond, "message")) {
[09:28:24.974]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:24.974]                       if (muffled) 
[09:28:24.974]                         invokeRestart("muffleMessage")
[09:28:24.974]                     }
[09:28:24.974]                     else if (inherits(cond, "warning")) {
[09:28:24.974]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:24.974]                       if (muffled) 
[09:28:24.974]                         invokeRestart("muffleWarning")
[09:28:24.974]                     }
[09:28:24.974]                     else if (inherits(cond, "condition")) {
[09:28:24.974]                       if (!is.null(pattern)) {
[09:28:24.974]                         computeRestarts <- base::computeRestarts
[09:28:24.974]                         grepl <- base::grepl
[09:28:24.974]                         restarts <- computeRestarts(cond)
[09:28:24.974]                         for (restart in restarts) {
[09:28:24.974]                           name <- restart$name
[09:28:24.974]                           if (is.null(name)) 
[09:28:24.974]                             next
[09:28:24.974]                           if (!grepl(pattern, name)) 
[09:28:24.974]                             next
[09:28:24.974]                           invokeRestart(restart)
[09:28:24.974]                           muffled <- TRUE
[09:28:24.974]                           break
[09:28:24.974]                         }
[09:28:24.974]                       }
[09:28:24.974]                     }
[09:28:24.974]                     invisible(muffled)
[09:28:24.974]                   }
[09:28:24.974]                   muffleCondition(cond)
[09:28:24.974]                 })
[09:28:24.974]             }))
[09:28:24.974]             future::FutureResult(value = ...future.value$value, 
[09:28:24.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.974]                   ...future.rng), globalenv = if (FALSE) 
[09:28:24.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:24.974]                     ...future.globalenv.names))
[09:28:24.974]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:24.974]         }, condition = base::local({
[09:28:24.974]             c <- base::c
[09:28:24.974]             inherits <- base::inherits
[09:28:24.974]             invokeRestart <- base::invokeRestart
[09:28:24.974]             length <- base::length
[09:28:24.974]             list <- base::list
[09:28:24.974]             seq.int <- base::seq.int
[09:28:24.974]             signalCondition <- base::signalCondition
[09:28:24.974]             sys.calls <- base::sys.calls
[09:28:24.974]             `[[` <- base::`[[`
[09:28:24.974]             `+` <- base::`+`
[09:28:24.974]             `<<-` <- base::`<<-`
[09:28:24.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:24.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:24.974]                   3L)]
[09:28:24.974]             }
[09:28:24.974]             function(cond) {
[09:28:24.974]                 is_error <- inherits(cond, "error")
[09:28:24.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:24.974]                   NULL)
[09:28:24.974]                 if (is_error) {
[09:28:24.974]                   sessionInformation <- function() {
[09:28:24.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:24.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:24.974]                       search = base::search(), system = base::Sys.info())
[09:28:24.974]                   }
[09:28:24.974]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:24.974]                     cond$call), session = sessionInformation(), 
[09:28:24.974]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:24.974]                   signalCondition(cond)
[09:28:24.974]                 }
[09:28:24.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:24.974]                 "immediateCondition"))) {
[09:28:24.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:24.974]                   ...future.conditions[[length(...future.conditions) + 
[09:28:24.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:24.974]                   if (TRUE && !signal) {
[09:28:24.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.974]                     {
[09:28:24.974]                       inherits <- base::inherits
[09:28:24.974]                       invokeRestart <- base::invokeRestart
[09:28:24.974]                       is.null <- base::is.null
[09:28:24.974]                       muffled <- FALSE
[09:28:24.974]                       if (inherits(cond, "message")) {
[09:28:24.974]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.974]                         if (muffled) 
[09:28:24.974]                           invokeRestart("muffleMessage")
[09:28:24.974]                       }
[09:28:24.974]                       else if (inherits(cond, "warning")) {
[09:28:24.974]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.974]                         if (muffled) 
[09:28:24.974]                           invokeRestart("muffleWarning")
[09:28:24.974]                       }
[09:28:24.974]                       else if (inherits(cond, "condition")) {
[09:28:24.974]                         if (!is.null(pattern)) {
[09:28:24.974]                           computeRestarts <- base::computeRestarts
[09:28:24.974]                           grepl <- base::grepl
[09:28:24.974]                           restarts <- computeRestarts(cond)
[09:28:24.974]                           for (restart in restarts) {
[09:28:24.974]                             name <- restart$name
[09:28:24.974]                             if (is.null(name)) 
[09:28:24.974]                               next
[09:28:24.974]                             if (!grepl(pattern, name)) 
[09:28:24.974]                               next
[09:28:24.974]                             invokeRestart(restart)
[09:28:24.974]                             muffled <- TRUE
[09:28:24.974]                             break
[09:28:24.974]                           }
[09:28:24.974]                         }
[09:28:24.974]                       }
[09:28:24.974]                       invisible(muffled)
[09:28:24.974]                     }
[09:28:24.974]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.974]                   }
[09:28:24.974]                 }
[09:28:24.974]                 else {
[09:28:24.974]                   if (TRUE) {
[09:28:24.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:24.974]                     {
[09:28:24.974]                       inherits <- base::inherits
[09:28:24.974]                       invokeRestart <- base::invokeRestart
[09:28:24.974]                       is.null <- base::is.null
[09:28:24.974]                       muffled <- FALSE
[09:28:24.974]                       if (inherits(cond, "message")) {
[09:28:24.974]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:24.974]                         if (muffled) 
[09:28:24.974]                           invokeRestart("muffleMessage")
[09:28:24.974]                       }
[09:28:24.974]                       else if (inherits(cond, "warning")) {
[09:28:24.974]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:24.974]                         if (muffled) 
[09:28:24.974]                           invokeRestart("muffleWarning")
[09:28:24.974]                       }
[09:28:24.974]                       else if (inherits(cond, "condition")) {
[09:28:24.974]                         if (!is.null(pattern)) {
[09:28:24.974]                           computeRestarts <- base::computeRestarts
[09:28:24.974]                           grepl <- base::grepl
[09:28:24.974]                           restarts <- computeRestarts(cond)
[09:28:24.974]                           for (restart in restarts) {
[09:28:24.974]                             name <- restart$name
[09:28:24.974]                             if (is.null(name)) 
[09:28:24.974]                               next
[09:28:24.974]                             if (!grepl(pattern, name)) 
[09:28:24.974]                               next
[09:28:24.974]                             invokeRestart(restart)
[09:28:24.974]                             muffled <- TRUE
[09:28:24.974]                             break
[09:28:24.974]                           }
[09:28:24.974]                         }
[09:28:24.974]                       }
[09:28:24.974]                       invisible(muffled)
[09:28:24.974]                     }
[09:28:24.974]                     muffleCondition(cond, pattern = "^muffle")
[09:28:24.974]                   }
[09:28:24.974]                 }
[09:28:24.974]             }
[09:28:24.974]         }))
[09:28:24.974]     }, error = function(ex) {
[09:28:24.974]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:24.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:24.974]                 ...future.rng), started = ...future.startTime, 
[09:28:24.974]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:24.974]             version = "1.8"), class = "FutureResult")
[09:28:24.974]     }, finally = {
[09:28:24.974]         if (!identical(...future.workdir, getwd())) 
[09:28:24.974]             setwd(...future.workdir)
[09:28:24.974]         {
[09:28:24.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:24.974]                 ...future.oldOptions$nwarnings <- NULL
[09:28:24.974]             }
[09:28:24.974]             base::options(...future.oldOptions)
[09:28:24.974]             if (.Platform$OS.type == "windows") {
[09:28:24.974]                 old_names <- names(...future.oldEnvVars)
[09:28:24.974]                 envs <- base::Sys.getenv()
[09:28:24.974]                 names <- names(envs)
[09:28:24.974]                 common <- intersect(names, old_names)
[09:28:24.974]                 added <- setdiff(names, old_names)
[09:28:24.974]                 removed <- setdiff(old_names, names)
[09:28:24.974]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:24.974]                   envs[common]]
[09:28:24.974]                 NAMES <- toupper(changed)
[09:28:24.974]                 args <- list()
[09:28:24.974]                 for (kk in seq_along(NAMES)) {
[09:28:24.974]                   name <- changed[[kk]]
[09:28:24.974]                   NAME <- NAMES[[kk]]
[09:28:24.974]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.974]                     next
[09:28:24.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.974]                 }
[09:28:24.974]                 NAMES <- toupper(added)
[09:28:24.974]                 for (kk in seq_along(NAMES)) {
[09:28:24.974]                   name <- added[[kk]]
[09:28:24.974]                   NAME <- NAMES[[kk]]
[09:28:24.974]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.974]                     next
[09:28:24.974]                   args[[name]] <- ""
[09:28:24.974]                 }
[09:28:24.974]                 NAMES <- toupper(removed)
[09:28:24.974]                 for (kk in seq_along(NAMES)) {
[09:28:24.974]                   name <- removed[[kk]]
[09:28:24.974]                   NAME <- NAMES[[kk]]
[09:28:24.974]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:24.974]                     next
[09:28:24.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:24.974]                 }
[09:28:24.974]                 if (length(args) > 0) 
[09:28:24.974]                   base::do.call(base::Sys.setenv, args = args)
[09:28:24.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:24.974]             }
[09:28:24.974]             else {
[09:28:24.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:24.974]             }
[09:28:24.974]             {
[09:28:24.974]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:24.974]                   0L) {
[09:28:24.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:24.974]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:24.974]                   base::options(opts)
[09:28:24.974]                 }
[09:28:24.974]                 {
[09:28:24.974]                   {
[09:28:24.974]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:24.974]                     NULL
[09:28:24.974]                   }
[09:28:24.974]                   options(future.plan = NULL)
[09:28:24.974]                   if (is.na(NA_character_)) 
[09:28:24.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:24.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:24.974]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:24.974]                     .init = FALSE)
[09:28:24.974]                 }
[09:28:24.974]             }
[09:28:24.974]         }
[09:28:24.974]     })
[09:28:24.974]     if (TRUE) {
[09:28:24.974]         base::sink(type = "output", split = FALSE)
[09:28:24.974]         if (TRUE) {
[09:28:24.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:24.974]         }
[09:28:24.974]         else {
[09:28:24.974]             ...future.result["stdout"] <- base::list(NULL)
[09:28:24.974]         }
[09:28:24.974]         base::close(...future.stdout)
[09:28:24.974]         ...future.stdout <- NULL
[09:28:24.974]     }
[09:28:24.974]     ...future.result$conditions <- ...future.conditions
[09:28:24.974]     ...future.result$finished <- base::Sys.time()
[09:28:24.974]     ...future.result
[09:28:24.974] }
[09:28:24.976] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[09:28:24.977] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[09:28:24.977] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[09:28:24.977] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[09:28:24.977] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[09:28:24.977] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[09:28:24.978] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[09:28:24.978] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:24.978] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:24.978] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[09:28:24.979] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[09:28:24.979] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:24.979] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:24.979] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:28:24.980] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:28:24.980] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[09:28:24.980] MultisessionFuture started
[09:28:24.980] - Launch lazy future ... done
[09:28:24.981] run() for ‘MultisessionFuture’ ... done
[09:28:24.981] Created future:
[09:28:24.981] MultisessionFuture:
[09:28:24.981] Label: ‘future_by-2’
[09:28:24.981] Expression:
[09:28:24.981] {
[09:28:24.981]     do.call(function(...) {
[09:28:24.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:24.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:24.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:24.981]             on.exit(options(oopts), add = TRUE)
[09:28:24.981]         }
[09:28:24.981]         {
[09:28:24.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:24.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:24.981]                 ...future.FUN(...future.X_jj, ...)
[09:28:24.981]             })
[09:28:24.981]         }
[09:28:24.981]     }, args = future.call.arguments)
[09:28:24.981] }
[09:28:24.981] Lazy evaluation: FALSE
[09:28:24.981] Asynchronous evaluation: TRUE
[09:28:24.981] Local evaluation: TRUE
[09:28:24.981] Environment: 0x555b0bceef70
[09:28:24.981] Capture standard output: TRUE
[09:28:24.981] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:24.981] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[09:28:24.981] Packages: 1 packages (‘stats’)
[09:28:24.981] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:24.981] Resolved: FALSE
[09:28:24.981] Value: <not collected>
[09:28:24.981] Conditions captured: <none>
[09:28:24.981] Early signaling: FALSE
[09:28:24.981] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:24.981] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:24.993] Chunk #2 of 2 ... DONE
[09:28:24.993] Launching 2 futures (chunks) ... DONE
[09:28:24.993] Resolving 2 futures (chunks) ...
[09:28:24.994] resolve() on list ...
[09:28:24.994]  recursive: 0
[09:28:24.994]  length: 2
[09:28:24.994] 
[09:28:24.994] receiveMessageFromWorker() for ClusterFuture ...
[09:28:24.994] - Validating connection of MultisessionFuture
[09:28:24.995] - received message: FutureResult
[09:28:24.995] - Received FutureResult
[09:28:24.995] - Erased future from FutureRegistry
[09:28:24.995] result() for ClusterFuture ...
[09:28:24.995] - result already collected: FutureResult
[09:28:24.995] result() for ClusterFuture ... done
[09:28:24.995] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:24.995] Future #1
[09:28:24.995] result() for ClusterFuture ...
[09:28:24.995] - result already collected: FutureResult
[09:28:24.995] result() for ClusterFuture ... done
[09:28:24.996] result() for ClusterFuture ...
[09:28:24.996] - result already collected: FutureResult
[09:28:24.996] result() for ClusterFuture ... done
[09:28:24.996] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:24.996] - nx: 2
[09:28:24.996] - relay: TRUE
[09:28:24.996] - stdout: TRUE
[09:28:24.996] - signal: TRUE
[09:28:24.996] - resignal: FALSE
[09:28:24.996] - force: TRUE
[09:28:24.996] - relayed: [n=2] FALSE, FALSE
[09:28:24.997] - queued futures: [n=2] FALSE, FALSE
[09:28:24.997]  - until=1
[09:28:24.997]  - relaying element #1
[09:28:24.997] result() for ClusterFuture ...
[09:28:24.997] - result already collected: FutureResult
[09:28:24.997] result() for ClusterFuture ... done
[09:28:24.997] result() for ClusterFuture ...
[09:28:24.997] - result already collected: FutureResult
[09:28:24.997] result() for ClusterFuture ... done
[09:28:24.997] result() for ClusterFuture ...
[09:28:24.997] - result already collected: FutureResult
[09:28:24.997] result() for ClusterFuture ... done
[09:28:24.998] result() for ClusterFuture ...
[09:28:24.998] - result already collected: FutureResult
[09:28:24.998] result() for ClusterFuture ... done
[09:28:24.998] - relayed: [n=2] TRUE, FALSE
[09:28:24.998] - queued futures: [n=2] TRUE, FALSE
[09:28:24.998] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:24.998]  length: 1 (resolved future 1)
[09:28:25.027] receiveMessageFromWorker() for ClusterFuture ...
[09:28:25.027] - Validating connection of MultisessionFuture
[09:28:25.027] - received message: FutureResult
[09:28:25.027] - Received FutureResult
[09:28:25.028] - Erased future from FutureRegistry
[09:28:25.028] result() for ClusterFuture ...
[09:28:25.028] - result already collected: FutureResult
[09:28:25.028] result() for ClusterFuture ... done
[09:28:25.028] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:25.028] Future #2
[09:28:25.028] result() for ClusterFuture ...
[09:28:25.028] - result already collected: FutureResult
[09:28:25.028] result() for ClusterFuture ... done
[09:28:25.028] result() for ClusterFuture ...
[09:28:25.028] - result already collected: FutureResult
[09:28:25.029] result() for ClusterFuture ... done
[09:28:25.029] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:25.029] - nx: 2
[09:28:25.029] - relay: TRUE
[09:28:25.029] - stdout: TRUE
[09:28:25.029] - signal: TRUE
[09:28:25.029] - resignal: FALSE
[09:28:25.029] - force: TRUE
[09:28:25.029] - relayed: [n=2] TRUE, FALSE
[09:28:25.029] - queued futures: [n=2] TRUE, FALSE
[09:28:25.029]  - until=2
[09:28:25.029]  - relaying element #2
[09:28:25.030] result() for ClusterFuture ...
[09:28:25.030] - result already collected: FutureResult
[09:28:25.030] result() for ClusterFuture ... done
[09:28:25.030] result() for ClusterFuture ...
[09:28:25.030] - result already collected: FutureResult
[09:28:25.030] result() for ClusterFuture ... done
[09:28:25.030] result() for ClusterFuture ...
[09:28:25.030] - result already collected: FutureResult
[09:28:25.030] result() for ClusterFuture ... done
[09:28:25.030] result() for ClusterFuture ...
[09:28:25.030] - result already collected: FutureResult
[09:28:25.031] result() for ClusterFuture ... done
[09:28:25.031] - relayed: [n=2] TRUE, TRUE
[09:28:25.031] - queued futures: [n=2] TRUE, TRUE
[09:28:25.031] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:25.031]  length: 0 (resolved future 2)
[09:28:25.031] Relaying remaining futures
[09:28:25.031] signalConditionsASAP(NULL, pos=0) ...
[09:28:25.031] - nx: 2
[09:28:25.031] - relay: TRUE
[09:28:25.031] - stdout: TRUE
[09:28:25.031] - signal: TRUE
[09:28:25.031] - resignal: FALSE
[09:28:25.032] - force: TRUE
[09:28:25.032] - relayed: [n=2] TRUE, TRUE
[09:28:25.032] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:25.032] - relayed: [n=2] TRUE, TRUE
[09:28:25.032] - queued futures: [n=2] TRUE, TRUE
[09:28:25.032] signalConditionsASAP(NULL, pos=0) ... done
[09:28:25.032] resolve() on list ... DONE
[09:28:25.032] result() for ClusterFuture ...
[09:28:25.032] - result already collected: FutureResult
[09:28:25.032] result() for ClusterFuture ... done
[09:28:25.032] result() for ClusterFuture ...
[09:28:25.033] - result already collected: FutureResult
[09:28:25.033] result() for ClusterFuture ... done
[09:28:25.033] result() for ClusterFuture ...
[09:28:25.033] - result already collected: FutureResult
[09:28:25.033] result() for ClusterFuture ... done
[09:28:25.033] result() for ClusterFuture ...
[09:28:25.033] - result already collected: FutureResult
[09:28:25.033] result() for ClusterFuture ... done
[09:28:25.033]  - Number of value chunks collected: 2
[09:28:25.033] Resolving 2 futures (chunks) ... DONE
[09:28:25.033] Reducing values from 2 chunks ...
[09:28:25.034]  - Number of values collected after concatenation: 3
[09:28:25.034]  - Number of values expected: 3
[09:28:25.034] Reducing values from 2 chunks ... DONE
[09:28:25.034] future_lapply() ... DONE
[09:28:25.034] future_by_internal() ... DONE
[09:28:25.034] future_by_internal() ...
[09:28:25.035] future_lapply() ...
[09:28:25.038] Number of chunks: 2
[09:28:25.039] getGlobalsAndPackagesXApply() ...
[09:28:25.039]  - future.globals: TRUE
[09:28:25.039] getGlobalsAndPackages() ...
[09:28:25.039] Searching for globals...
[09:28:25.040] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:25.040] Searching for globals ... DONE
[09:28:25.040] Resolving globals: FALSE
[09:28:25.040] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:25.041] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:25.041] - globals: [1] ‘FUN’
[09:28:25.041] 
[09:28:25.041] getGlobalsAndPackages() ... DONE
[09:28:25.041]  - globals found/used: [n=1] ‘FUN’
[09:28:25.041]  - needed namespaces: [n=0] 
[09:28:25.041] Finding globals ... DONE
[09:28:25.042]  - use_args: TRUE
[09:28:25.042]  - Getting '...' globals ...
[09:28:25.042] resolve() on list ...
[09:28:25.042]  recursive: 0
[09:28:25.042]  length: 1
[09:28:25.042]  elements: ‘...’
[09:28:25.042]  length: 0 (resolved future 1)
[09:28:25.042] resolve() on list ... DONE
[09:28:25.042]    - '...' content: [n=0] 
[09:28:25.043] List of 1
[09:28:25.043]  $ ...: list()
[09:28:25.043]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.043]  - attr(*, "where")=List of 1
[09:28:25.043]   ..$ ...:<environment: 0x555b099202b8> 
[09:28:25.043]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.043]  - attr(*, "resolved")= logi TRUE
[09:28:25.043]  - attr(*, "total_size")= num NA
[09:28:25.045]  - Getting '...' globals ... DONE
[09:28:25.045] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:25.045] List of 2
[09:28:25.045]  $ ...future.FUN:function (object, ...)  
[09:28:25.045]  $ ...          : list()
[09:28:25.045]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.045]  - attr(*, "where")=List of 2
[09:28:25.045]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:25.045]   ..$ ...          :<environment: 0x555b099202b8> 
[09:28:25.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.045]  - attr(*, "resolved")= logi FALSE
[09:28:25.045]  - attr(*, "total_size")= num 1240
[09:28:25.048] Packages to be attached in all futures: [n=0] 
[09:28:25.048] getGlobalsAndPackagesXApply() ... DONE
[09:28:25.048] Number of futures (= number of chunks): 2
[09:28:25.048] Launching 2 futures (chunks) ...
[09:28:25.048] Chunk #1 of 2 ...
[09:28:25.049]  - Finding globals in 'X' for chunk #1 ...
[09:28:25.049] getGlobalsAndPackages() ...
[09:28:25.049] Searching for globals...
[09:28:25.049] 
[09:28:25.049] Searching for globals ... DONE
[09:28:25.049] - globals: [0] <none>
[09:28:25.049] getGlobalsAndPackages() ... DONE
[09:28:25.049]    + additional globals found: [n=0] 
[09:28:25.049]    + additional namespaces needed: [n=0] 
[09:28:25.050]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:25.050]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:25.050]  - seeds: <none>
[09:28:25.050]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.050] getGlobalsAndPackages() ...
[09:28:25.050] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.050] Resolving globals: FALSE
[09:28:25.050] Tweak future expression to call with '...' arguments ...
[09:28:25.050] {
[09:28:25.050]     do.call(function(...) {
[09:28:25.050]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.050]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.050]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.050]             on.exit(options(oopts), add = TRUE)
[09:28:25.050]         }
[09:28:25.050]         {
[09:28:25.050]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.050]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.050]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.050]             })
[09:28:25.050]         }
[09:28:25.050]     }, args = future.call.arguments)
[09:28:25.050] }
[09:28:25.051] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.051] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.051] 
[09:28:25.051] getGlobalsAndPackages() ... DONE
[09:28:25.051] run() for ‘Future’ ...
[09:28:25.051] - state: ‘created’
[09:28:25.052] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:25.065] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:25.065]   - Field: ‘node’
[09:28:25.065]   - Field: ‘label’
[09:28:25.065]   - Field: ‘local’
[09:28:25.066]   - Field: ‘owner’
[09:28:25.066]   - Field: ‘envir’
[09:28:25.066]   - Field: ‘workers’
[09:28:25.066]   - Field: ‘packages’
[09:28:25.066]   - Field: ‘gc’
[09:28:25.066]   - Field: ‘conditions’
[09:28:25.066]   - Field: ‘persistent’
[09:28:25.066]   - Field: ‘expr’
[09:28:25.066]   - Field: ‘uuid’
[09:28:25.066]   - Field: ‘seed’
[09:28:25.066]   - Field: ‘version’
[09:28:25.067]   - Field: ‘result’
[09:28:25.067]   - Field: ‘asynchronous’
[09:28:25.067]   - Field: ‘calls’
[09:28:25.067]   - Field: ‘globals’
[09:28:25.067]   - Field: ‘stdout’
[09:28:25.067]   - Field: ‘earlySignal’
[09:28:25.067]   - Field: ‘lazy’
[09:28:25.067]   - Field: ‘state’
[09:28:25.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:25.067] - Launch lazy future ...
[09:28:25.068] Packages needed by the future expression (n = 0): <none>
[09:28:25.068] Packages needed by future strategies (n = 0): <none>
[09:28:25.068] {
[09:28:25.068]     {
[09:28:25.068]         {
[09:28:25.068]             ...future.startTime <- base::Sys.time()
[09:28:25.068]             {
[09:28:25.068]                 {
[09:28:25.068]                   {
[09:28:25.068]                     {
[09:28:25.068]                       base::local({
[09:28:25.068]                         has_future <- base::requireNamespace("future", 
[09:28:25.068]                           quietly = TRUE)
[09:28:25.068]                         if (has_future) {
[09:28:25.068]                           ns <- base::getNamespace("future")
[09:28:25.068]                           version <- ns[[".package"]][["version"]]
[09:28:25.068]                           if (is.null(version)) 
[09:28:25.068]                             version <- utils::packageVersion("future")
[09:28:25.068]                         }
[09:28:25.068]                         else {
[09:28:25.068]                           version <- NULL
[09:28:25.068]                         }
[09:28:25.068]                         if (!has_future || version < "1.8.0") {
[09:28:25.068]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.068]                             "", base::R.version$version.string), 
[09:28:25.068]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:25.068]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:25.068]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.068]                               "release", "version")], collapse = " "), 
[09:28:25.068]                             hostname = base::Sys.info()[["nodename"]])
[09:28:25.068]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.068]                             info)
[09:28:25.068]                           info <- base::paste(info, collapse = "; ")
[09:28:25.068]                           if (!has_future) {
[09:28:25.068]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.068]                               info)
[09:28:25.068]                           }
[09:28:25.068]                           else {
[09:28:25.068]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.068]                               info, version)
[09:28:25.068]                           }
[09:28:25.068]                           base::stop(msg)
[09:28:25.068]                         }
[09:28:25.068]                       })
[09:28:25.068]                     }
[09:28:25.068]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:25.068]                     base::options(mc.cores = 1L)
[09:28:25.068]                   }
[09:28:25.068]                   ...future.strategy.old <- future::plan("list")
[09:28:25.068]                   options(future.plan = NULL)
[09:28:25.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.068]                 }
[09:28:25.068]                 ...future.workdir <- getwd()
[09:28:25.068]             }
[09:28:25.068]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.068]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.068]         }
[09:28:25.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.068]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:25.068]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.068]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.068]             base::names(...future.oldOptions))
[09:28:25.068]     }
[09:28:25.068]     if (FALSE) {
[09:28:25.068]     }
[09:28:25.068]     else {
[09:28:25.068]         if (TRUE) {
[09:28:25.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.068]                 open = "w")
[09:28:25.068]         }
[09:28:25.068]         else {
[09:28:25.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.068]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.068]         }
[09:28:25.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.068]             base::sink(type = "output", split = FALSE)
[09:28:25.068]             base::close(...future.stdout)
[09:28:25.068]         }, add = TRUE)
[09:28:25.068]     }
[09:28:25.068]     ...future.frame <- base::sys.nframe()
[09:28:25.068]     ...future.conditions <- base::list()
[09:28:25.068]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.068]     if (FALSE) {
[09:28:25.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.068]     }
[09:28:25.068]     ...future.result <- base::tryCatch({
[09:28:25.068]         base::withCallingHandlers({
[09:28:25.068]             ...future.value <- base::withVisible(base::local({
[09:28:25.068]                 ...future.makeSendCondition <- base::local({
[09:28:25.068]                   sendCondition <- NULL
[09:28:25.068]                   function(frame = 1L) {
[09:28:25.068]                     if (is.function(sendCondition)) 
[09:28:25.068]                       return(sendCondition)
[09:28:25.068]                     ns <- getNamespace("parallel")
[09:28:25.068]                     if (exists("sendData", mode = "function", 
[09:28:25.068]                       envir = ns)) {
[09:28:25.068]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:25.068]                         envir = ns)
[09:28:25.068]                       envir <- sys.frame(frame)
[09:28:25.068]                       master <- NULL
[09:28:25.068]                       while (!identical(envir, .GlobalEnv) && 
[09:28:25.068]                         !identical(envir, emptyenv())) {
[09:28:25.068]                         if (exists("master", mode = "list", envir = envir, 
[09:28:25.068]                           inherits = FALSE)) {
[09:28:25.068]                           master <- get("master", mode = "list", 
[09:28:25.068]                             envir = envir, inherits = FALSE)
[09:28:25.068]                           if (inherits(master, c("SOCKnode", 
[09:28:25.068]                             "SOCK0node"))) {
[09:28:25.068]                             sendCondition <<- function(cond) {
[09:28:25.068]                               data <- list(type = "VALUE", value = cond, 
[09:28:25.068]                                 success = TRUE)
[09:28:25.068]                               parallel_sendData(master, data)
[09:28:25.068]                             }
[09:28:25.068]                             return(sendCondition)
[09:28:25.068]                           }
[09:28:25.068]                         }
[09:28:25.068]                         frame <- frame + 1L
[09:28:25.068]                         envir <- sys.frame(frame)
[09:28:25.068]                       }
[09:28:25.068]                     }
[09:28:25.068]                     sendCondition <<- function(cond) NULL
[09:28:25.068]                   }
[09:28:25.068]                 })
[09:28:25.068]                 withCallingHandlers({
[09:28:25.068]                   {
[09:28:25.068]                     do.call(function(...) {
[09:28:25.068]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.068]                       if (!identical(...future.globals.maxSize.org, 
[09:28:25.068]                         ...future.globals.maxSize)) {
[09:28:25.068]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.068]                         on.exit(options(oopts), add = TRUE)
[09:28:25.068]                       }
[09:28:25.068]                       {
[09:28:25.068]                         lapply(seq_along(...future.elements_ii), 
[09:28:25.068]                           FUN = function(jj) {
[09:28:25.068]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.068]                             ...future.FUN(...future.X_jj, ...)
[09:28:25.068]                           })
[09:28:25.068]                       }
[09:28:25.068]                     }, args = future.call.arguments)
[09:28:25.068]                   }
[09:28:25.068]                 }, immediateCondition = function(cond) {
[09:28:25.068]                   sendCondition <- ...future.makeSendCondition()
[09:28:25.068]                   sendCondition(cond)
[09:28:25.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.068]                   {
[09:28:25.068]                     inherits <- base::inherits
[09:28:25.068]                     invokeRestart <- base::invokeRestart
[09:28:25.068]                     is.null <- base::is.null
[09:28:25.068]                     muffled <- FALSE
[09:28:25.068]                     if (inherits(cond, "message")) {
[09:28:25.068]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:25.068]                       if (muffled) 
[09:28:25.068]                         invokeRestart("muffleMessage")
[09:28:25.068]                     }
[09:28:25.068]                     else if (inherits(cond, "warning")) {
[09:28:25.068]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:25.068]                       if (muffled) 
[09:28:25.068]                         invokeRestart("muffleWarning")
[09:28:25.068]                     }
[09:28:25.068]                     else if (inherits(cond, "condition")) {
[09:28:25.068]                       if (!is.null(pattern)) {
[09:28:25.068]                         computeRestarts <- base::computeRestarts
[09:28:25.068]                         grepl <- base::grepl
[09:28:25.068]                         restarts <- computeRestarts(cond)
[09:28:25.068]                         for (restart in restarts) {
[09:28:25.068]                           name <- restart$name
[09:28:25.068]                           if (is.null(name)) 
[09:28:25.068]                             next
[09:28:25.068]                           if (!grepl(pattern, name)) 
[09:28:25.068]                             next
[09:28:25.068]                           invokeRestart(restart)
[09:28:25.068]                           muffled <- TRUE
[09:28:25.068]                           break
[09:28:25.068]                         }
[09:28:25.068]                       }
[09:28:25.068]                     }
[09:28:25.068]                     invisible(muffled)
[09:28:25.068]                   }
[09:28:25.068]                   muffleCondition(cond)
[09:28:25.068]                 })
[09:28:25.068]             }))
[09:28:25.068]             future::FutureResult(value = ...future.value$value, 
[09:28:25.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.068]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.068]                     ...future.globalenv.names))
[09:28:25.068]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.068]         }, condition = base::local({
[09:28:25.068]             c <- base::c
[09:28:25.068]             inherits <- base::inherits
[09:28:25.068]             invokeRestart <- base::invokeRestart
[09:28:25.068]             length <- base::length
[09:28:25.068]             list <- base::list
[09:28:25.068]             seq.int <- base::seq.int
[09:28:25.068]             signalCondition <- base::signalCondition
[09:28:25.068]             sys.calls <- base::sys.calls
[09:28:25.068]             `[[` <- base::`[[`
[09:28:25.068]             `+` <- base::`+`
[09:28:25.068]             `<<-` <- base::`<<-`
[09:28:25.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.068]                   3L)]
[09:28:25.068]             }
[09:28:25.068]             function(cond) {
[09:28:25.068]                 is_error <- inherits(cond, "error")
[09:28:25.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.068]                   NULL)
[09:28:25.068]                 if (is_error) {
[09:28:25.068]                   sessionInformation <- function() {
[09:28:25.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.068]                       search = base::search(), system = base::Sys.info())
[09:28:25.068]                   }
[09:28:25.068]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.068]                     cond$call), session = sessionInformation(), 
[09:28:25.068]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.068]                   signalCondition(cond)
[09:28:25.068]                 }
[09:28:25.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.068]                 "immediateCondition"))) {
[09:28:25.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.068]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.068]                   if (TRUE && !signal) {
[09:28:25.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.068]                     {
[09:28:25.068]                       inherits <- base::inherits
[09:28:25.068]                       invokeRestart <- base::invokeRestart
[09:28:25.068]                       is.null <- base::is.null
[09:28:25.068]                       muffled <- FALSE
[09:28:25.068]                       if (inherits(cond, "message")) {
[09:28:25.068]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.068]                         if (muffled) 
[09:28:25.068]                           invokeRestart("muffleMessage")
[09:28:25.068]                       }
[09:28:25.068]                       else if (inherits(cond, "warning")) {
[09:28:25.068]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.068]                         if (muffled) 
[09:28:25.068]                           invokeRestart("muffleWarning")
[09:28:25.068]                       }
[09:28:25.068]                       else if (inherits(cond, "condition")) {
[09:28:25.068]                         if (!is.null(pattern)) {
[09:28:25.068]                           computeRestarts <- base::computeRestarts
[09:28:25.068]                           grepl <- base::grepl
[09:28:25.068]                           restarts <- computeRestarts(cond)
[09:28:25.068]                           for (restart in restarts) {
[09:28:25.068]                             name <- restart$name
[09:28:25.068]                             if (is.null(name)) 
[09:28:25.068]                               next
[09:28:25.068]                             if (!grepl(pattern, name)) 
[09:28:25.068]                               next
[09:28:25.068]                             invokeRestart(restart)
[09:28:25.068]                             muffled <- TRUE
[09:28:25.068]                             break
[09:28:25.068]                           }
[09:28:25.068]                         }
[09:28:25.068]                       }
[09:28:25.068]                       invisible(muffled)
[09:28:25.068]                     }
[09:28:25.068]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.068]                   }
[09:28:25.068]                 }
[09:28:25.068]                 else {
[09:28:25.068]                   if (TRUE) {
[09:28:25.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.068]                     {
[09:28:25.068]                       inherits <- base::inherits
[09:28:25.068]                       invokeRestart <- base::invokeRestart
[09:28:25.068]                       is.null <- base::is.null
[09:28:25.068]                       muffled <- FALSE
[09:28:25.068]                       if (inherits(cond, "message")) {
[09:28:25.068]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.068]                         if (muffled) 
[09:28:25.068]                           invokeRestart("muffleMessage")
[09:28:25.068]                       }
[09:28:25.068]                       else if (inherits(cond, "warning")) {
[09:28:25.068]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.068]                         if (muffled) 
[09:28:25.068]                           invokeRestart("muffleWarning")
[09:28:25.068]                       }
[09:28:25.068]                       else if (inherits(cond, "condition")) {
[09:28:25.068]                         if (!is.null(pattern)) {
[09:28:25.068]                           computeRestarts <- base::computeRestarts
[09:28:25.068]                           grepl <- base::grepl
[09:28:25.068]                           restarts <- computeRestarts(cond)
[09:28:25.068]                           for (restart in restarts) {
[09:28:25.068]                             name <- restart$name
[09:28:25.068]                             if (is.null(name)) 
[09:28:25.068]                               next
[09:28:25.068]                             if (!grepl(pattern, name)) 
[09:28:25.068]                               next
[09:28:25.068]                             invokeRestart(restart)
[09:28:25.068]                             muffled <- TRUE
[09:28:25.068]                             break
[09:28:25.068]                           }
[09:28:25.068]                         }
[09:28:25.068]                       }
[09:28:25.068]                       invisible(muffled)
[09:28:25.068]                     }
[09:28:25.068]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.068]                   }
[09:28:25.068]                 }
[09:28:25.068]             }
[09:28:25.068]         }))
[09:28:25.068]     }, error = function(ex) {
[09:28:25.068]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.068]                 ...future.rng), started = ...future.startTime, 
[09:28:25.068]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.068]             version = "1.8"), class = "FutureResult")
[09:28:25.068]     }, finally = {
[09:28:25.068]         if (!identical(...future.workdir, getwd())) 
[09:28:25.068]             setwd(...future.workdir)
[09:28:25.068]         {
[09:28:25.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.068]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.068]             }
[09:28:25.068]             base::options(...future.oldOptions)
[09:28:25.068]             if (.Platform$OS.type == "windows") {
[09:28:25.068]                 old_names <- names(...future.oldEnvVars)
[09:28:25.068]                 envs <- base::Sys.getenv()
[09:28:25.068]                 names <- names(envs)
[09:28:25.068]                 common <- intersect(names, old_names)
[09:28:25.068]                 added <- setdiff(names, old_names)
[09:28:25.068]                 removed <- setdiff(old_names, names)
[09:28:25.068]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.068]                   envs[common]]
[09:28:25.068]                 NAMES <- toupper(changed)
[09:28:25.068]                 args <- list()
[09:28:25.068]                 for (kk in seq_along(NAMES)) {
[09:28:25.068]                   name <- changed[[kk]]
[09:28:25.068]                   NAME <- NAMES[[kk]]
[09:28:25.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.068]                     next
[09:28:25.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.068]                 }
[09:28:25.068]                 NAMES <- toupper(added)
[09:28:25.068]                 for (kk in seq_along(NAMES)) {
[09:28:25.068]                   name <- added[[kk]]
[09:28:25.068]                   NAME <- NAMES[[kk]]
[09:28:25.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.068]                     next
[09:28:25.068]                   args[[name]] <- ""
[09:28:25.068]                 }
[09:28:25.068]                 NAMES <- toupper(removed)
[09:28:25.068]                 for (kk in seq_along(NAMES)) {
[09:28:25.068]                   name <- removed[[kk]]
[09:28:25.068]                   NAME <- NAMES[[kk]]
[09:28:25.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.068]                     next
[09:28:25.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.068]                 }
[09:28:25.068]                 if (length(args) > 0) 
[09:28:25.068]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.068]             }
[09:28:25.068]             else {
[09:28:25.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.068]             }
[09:28:25.068]             {
[09:28:25.068]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.068]                   0L) {
[09:28:25.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.068]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.068]                   base::options(opts)
[09:28:25.068]                 }
[09:28:25.068]                 {
[09:28:25.068]                   {
[09:28:25.068]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:25.068]                     NULL
[09:28:25.068]                   }
[09:28:25.068]                   options(future.plan = NULL)
[09:28:25.068]                   if (is.na(NA_character_)) 
[09:28:25.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.068]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.068]                     .init = FALSE)
[09:28:25.068]                 }
[09:28:25.068]             }
[09:28:25.068]         }
[09:28:25.068]     })
[09:28:25.068]     if (TRUE) {
[09:28:25.068]         base::sink(type = "output", split = FALSE)
[09:28:25.068]         if (TRUE) {
[09:28:25.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.068]         }
[09:28:25.068]         else {
[09:28:25.068]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.068]         }
[09:28:25.068]         base::close(...future.stdout)
[09:28:25.068]         ...future.stdout <- NULL
[09:28:25.068]     }
[09:28:25.068]     ...future.result$conditions <- ...future.conditions
[09:28:25.068]     ...future.result$finished <- base::Sys.time()
[09:28:25.068]     ...future.result
[09:28:25.068] }
[09:28:25.071] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[09:28:25.071] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[09:28:25.071] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[09:28:25.071] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:25.072] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:25.072] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[09:28:25.072] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[09:28:25.072] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:25.073] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:25.073] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:28:25.073] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:28:25.073] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[09:28:25.074] MultisessionFuture started
[09:28:25.074] - Launch lazy future ... done
[09:28:25.074] run() for ‘MultisessionFuture’ ... done
[09:28:25.074] Created future:
[09:28:25.074] MultisessionFuture:
[09:28:25.074] Label: ‘future_by-1’
[09:28:25.074] Expression:
[09:28:25.074] {
[09:28:25.074]     do.call(function(...) {
[09:28:25.074]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.074]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.074]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.074]             on.exit(options(oopts), add = TRUE)
[09:28:25.074]         }
[09:28:25.074]         {
[09:28:25.074]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.074]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.074]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.074]             })
[09:28:25.074]         }
[09:28:25.074]     }, args = future.call.arguments)
[09:28:25.074] }
[09:28:25.074] Lazy evaluation: FALSE
[09:28:25.074] Asynchronous evaluation: TRUE
[09:28:25.074] Local evaluation: TRUE
[09:28:25.074] Environment: 0x555b08e519d0
[09:28:25.074] Capture standard output: TRUE
[09:28:25.074] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.074] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.074] Packages: <none>
[09:28:25.074] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.074] Resolved: FALSE
[09:28:25.074] Value: <not collected>
[09:28:25.074] Conditions captured: <none>
[09:28:25.074] Early signaling: FALSE
[09:28:25.074] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:25.074] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.086] Chunk #1 of 2 ... DONE
[09:28:25.086] Chunk #2 of 2 ...
[09:28:25.086]  - Finding globals in 'X' for chunk #2 ...
[09:28:25.086] getGlobalsAndPackages() ...
[09:28:25.086] Searching for globals...
[09:28:25.087] 
[09:28:25.087] Searching for globals ... DONE
[09:28:25.087] - globals: [0] <none>
[09:28:25.087] getGlobalsAndPackages() ... DONE
[09:28:25.087]    + additional globals found: [n=0] 
[09:28:25.087]    + additional namespaces needed: [n=0] 
[09:28:25.087]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:25.088]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:25.088]  - seeds: <none>
[09:28:25.088]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.088] getGlobalsAndPackages() ...
[09:28:25.088] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.088] Resolving globals: FALSE
[09:28:25.088] Tweak future expression to call with '...' arguments ...
[09:28:25.088] {
[09:28:25.088]     do.call(function(...) {
[09:28:25.088]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.088]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.088]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.088]             on.exit(options(oopts), add = TRUE)
[09:28:25.088]         }
[09:28:25.088]         {
[09:28:25.088]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.088]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.088]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.088]             })
[09:28:25.088]         }
[09:28:25.088]     }, args = future.call.arguments)
[09:28:25.088] }
[09:28:25.089] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.089] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.089] 
[09:28:25.089] getGlobalsAndPackages() ... DONE
[09:28:25.089] run() for ‘Future’ ...
[09:28:25.089] - state: ‘created’
[09:28:25.090] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:25.103] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:25.103]   - Field: ‘node’
[09:28:25.103]   - Field: ‘label’
[09:28:25.103]   - Field: ‘local’
[09:28:25.104]   - Field: ‘owner’
[09:28:25.104]   - Field: ‘envir’
[09:28:25.104]   - Field: ‘workers’
[09:28:25.104]   - Field: ‘packages’
[09:28:25.104]   - Field: ‘gc’
[09:28:25.104]   - Field: ‘conditions’
[09:28:25.104]   - Field: ‘persistent’
[09:28:25.104]   - Field: ‘expr’
[09:28:25.104]   - Field: ‘uuid’
[09:28:25.104]   - Field: ‘seed’
[09:28:25.104]   - Field: ‘version’
[09:28:25.105]   - Field: ‘result’
[09:28:25.105]   - Field: ‘asynchronous’
[09:28:25.105]   - Field: ‘calls’
[09:28:25.105]   - Field: ‘globals’
[09:28:25.105]   - Field: ‘stdout’
[09:28:25.105]   - Field: ‘earlySignal’
[09:28:25.105]   - Field: ‘lazy’
[09:28:25.105]   - Field: ‘state’
[09:28:25.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:25.105] - Launch lazy future ...
[09:28:25.106] Packages needed by the future expression (n = 0): <none>
[09:28:25.106] Packages needed by future strategies (n = 0): <none>
[09:28:25.106] {
[09:28:25.106]     {
[09:28:25.106]         {
[09:28:25.106]             ...future.startTime <- base::Sys.time()
[09:28:25.106]             {
[09:28:25.106]                 {
[09:28:25.106]                   {
[09:28:25.106]                     {
[09:28:25.106]                       base::local({
[09:28:25.106]                         has_future <- base::requireNamespace("future", 
[09:28:25.106]                           quietly = TRUE)
[09:28:25.106]                         if (has_future) {
[09:28:25.106]                           ns <- base::getNamespace("future")
[09:28:25.106]                           version <- ns[[".package"]][["version"]]
[09:28:25.106]                           if (is.null(version)) 
[09:28:25.106]                             version <- utils::packageVersion("future")
[09:28:25.106]                         }
[09:28:25.106]                         else {
[09:28:25.106]                           version <- NULL
[09:28:25.106]                         }
[09:28:25.106]                         if (!has_future || version < "1.8.0") {
[09:28:25.106]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.106]                             "", base::R.version$version.string), 
[09:28:25.106]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:25.106]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:25.106]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.106]                               "release", "version")], collapse = " "), 
[09:28:25.106]                             hostname = base::Sys.info()[["nodename"]])
[09:28:25.106]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.106]                             info)
[09:28:25.106]                           info <- base::paste(info, collapse = "; ")
[09:28:25.106]                           if (!has_future) {
[09:28:25.106]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.106]                               info)
[09:28:25.106]                           }
[09:28:25.106]                           else {
[09:28:25.106]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.106]                               info, version)
[09:28:25.106]                           }
[09:28:25.106]                           base::stop(msg)
[09:28:25.106]                         }
[09:28:25.106]                       })
[09:28:25.106]                     }
[09:28:25.106]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:25.106]                     base::options(mc.cores = 1L)
[09:28:25.106]                   }
[09:28:25.106]                   ...future.strategy.old <- future::plan("list")
[09:28:25.106]                   options(future.plan = NULL)
[09:28:25.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.106]                 }
[09:28:25.106]                 ...future.workdir <- getwd()
[09:28:25.106]             }
[09:28:25.106]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.106]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.106]         }
[09:28:25.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.106]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:25.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.106]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.106]             base::names(...future.oldOptions))
[09:28:25.106]     }
[09:28:25.106]     if (FALSE) {
[09:28:25.106]     }
[09:28:25.106]     else {
[09:28:25.106]         if (TRUE) {
[09:28:25.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.106]                 open = "w")
[09:28:25.106]         }
[09:28:25.106]         else {
[09:28:25.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.106]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.106]         }
[09:28:25.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.106]             base::sink(type = "output", split = FALSE)
[09:28:25.106]             base::close(...future.stdout)
[09:28:25.106]         }, add = TRUE)
[09:28:25.106]     }
[09:28:25.106]     ...future.frame <- base::sys.nframe()
[09:28:25.106]     ...future.conditions <- base::list()
[09:28:25.106]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.106]     if (FALSE) {
[09:28:25.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.106]     }
[09:28:25.106]     ...future.result <- base::tryCatch({
[09:28:25.106]         base::withCallingHandlers({
[09:28:25.106]             ...future.value <- base::withVisible(base::local({
[09:28:25.106]                 ...future.makeSendCondition <- base::local({
[09:28:25.106]                   sendCondition <- NULL
[09:28:25.106]                   function(frame = 1L) {
[09:28:25.106]                     if (is.function(sendCondition)) 
[09:28:25.106]                       return(sendCondition)
[09:28:25.106]                     ns <- getNamespace("parallel")
[09:28:25.106]                     if (exists("sendData", mode = "function", 
[09:28:25.106]                       envir = ns)) {
[09:28:25.106]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:25.106]                         envir = ns)
[09:28:25.106]                       envir <- sys.frame(frame)
[09:28:25.106]                       master <- NULL
[09:28:25.106]                       while (!identical(envir, .GlobalEnv) && 
[09:28:25.106]                         !identical(envir, emptyenv())) {
[09:28:25.106]                         if (exists("master", mode = "list", envir = envir, 
[09:28:25.106]                           inherits = FALSE)) {
[09:28:25.106]                           master <- get("master", mode = "list", 
[09:28:25.106]                             envir = envir, inherits = FALSE)
[09:28:25.106]                           if (inherits(master, c("SOCKnode", 
[09:28:25.106]                             "SOCK0node"))) {
[09:28:25.106]                             sendCondition <<- function(cond) {
[09:28:25.106]                               data <- list(type = "VALUE", value = cond, 
[09:28:25.106]                                 success = TRUE)
[09:28:25.106]                               parallel_sendData(master, data)
[09:28:25.106]                             }
[09:28:25.106]                             return(sendCondition)
[09:28:25.106]                           }
[09:28:25.106]                         }
[09:28:25.106]                         frame <- frame + 1L
[09:28:25.106]                         envir <- sys.frame(frame)
[09:28:25.106]                       }
[09:28:25.106]                     }
[09:28:25.106]                     sendCondition <<- function(cond) NULL
[09:28:25.106]                   }
[09:28:25.106]                 })
[09:28:25.106]                 withCallingHandlers({
[09:28:25.106]                   {
[09:28:25.106]                     do.call(function(...) {
[09:28:25.106]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.106]                       if (!identical(...future.globals.maxSize.org, 
[09:28:25.106]                         ...future.globals.maxSize)) {
[09:28:25.106]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.106]                         on.exit(options(oopts), add = TRUE)
[09:28:25.106]                       }
[09:28:25.106]                       {
[09:28:25.106]                         lapply(seq_along(...future.elements_ii), 
[09:28:25.106]                           FUN = function(jj) {
[09:28:25.106]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.106]                             ...future.FUN(...future.X_jj, ...)
[09:28:25.106]                           })
[09:28:25.106]                       }
[09:28:25.106]                     }, args = future.call.arguments)
[09:28:25.106]                   }
[09:28:25.106]                 }, immediateCondition = function(cond) {
[09:28:25.106]                   sendCondition <- ...future.makeSendCondition()
[09:28:25.106]                   sendCondition(cond)
[09:28:25.106]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.106]                   {
[09:28:25.106]                     inherits <- base::inherits
[09:28:25.106]                     invokeRestart <- base::invokeRestart
[09:28:25.106]                     is.null <- base::is.null
[09:28:25.106]                     muffled <- FALSE
[09:28:25.106]                     if (inherits(cond, "message")) {
[09:28:25.106]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:25.106]                       if (muffled) 
[09:28:25.106]                         invokeRestart("muffleMessage")
[09:28:25.106]                     }
[09:28:25.106]                     else if (inherits(cond, "warning")) {
[09:28:25.106]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:25.106]                       if (muffled) 
[09:28:25.106]                         invokeRestart("muffleWarning")
[09:28:25.106]                     }
[09:28:25.106]                     else if (inherits(cond, "condition")) {
[09:28:25.106]                       if (!is.null(pattern)) {
[09:28:25.106]                         computeRestarts <- base::computeRestarts
[09:28:25.106]                         grepl <- base::grepl
[09:28:25.106]                         restarts <- computeRestarts(cond)
[09:28:25.106]                         for (restart in restarts) {
[09:28:25.106]                           name <- restart$name
[09:28:25.106]                           if (is.null(name)) 
[09:28:25.106]                             next
[09:28:25.106]                           if (!grepl(pattern, name)) 
[09:28:25.106]                             next
[09:28:25.106]                           invokeRestart(restart)
[09:28:25.106]                           muffled <- TRUE
[09:28:25.106]                           break
[09:28:25.106]                         }
[09:28:25.106]                       }
[09:28:25.106]                     }
[09:28:25.106]                     invisible(muffled)
[09:28:25.106]                   }
[09:28:25.106]                   muffleCondition(cond)
[09:28:25.106]                 })
[09:28:25.106]             }))
[09:28:25.106]             future::FutureResult(value = ...future.value$value, 
[09:28:25.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.106]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.106]                     ...future.globalenv.names))
[09:28:25.106]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.106]         }, condition = base::local({
[09:28:25.106]             c <- base::c
[09:28:25.106]             inherits <- base::inherits
[09:28:25.106]             invokeRestart <- base::invokeRestart
[09:28:25.106]             length <- base::length
[09:28:25.106]             list <- base::list
[09:28:25.106]             seq.int <- base::seq.int
[09:28:25.106]             signalCondition <- base::signalCondition
[09:28:25.106]             sys.calls <- base::sys.calls
[09:28:25.106]             `[[` <- base::`[[`
[09:28:25.106]             `+` <- base::`+`
[09:28:25.106]             `<<-` <- base::`<<-`
[09:28:25.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.106]                   3L)]
[09:28:25.106]             }
[09:28:25.106]             function(cond) {
[09:28:25.106]                 is_error <- inherits(cond, "error")
[09:28:25.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.106]                   NULL)
[09:28:25.106]                 if (is_error) {
[09:28:25.106]                   sessionInformation <- function() {
[09:28:25.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.106]                       search = base::search(), system = base::Sys.info())
[09:28:25.106]                   }
[09:28:25.106]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.106]                     cond$call), session = sessionInformation(), 
[09:28:25.106]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.106]                   signalCondition(cond)
[09:28:25.106]                 }
[09:28:25.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.106]                 "immediateCondition"))) {
[09:28:25.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.106]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.106]                   if (TRUE && !signal) {
[09:28:25.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.106]                     {
[09:28:25.106]                       inherits <- base::inherits
[09:28:25.106]                       invokeRestart <- base::invokeRestart
[09:28:25.106]                       is.null <- base::is.null
[09:28:25.106]                       muffled <- FALSE
[09:28:25.106]                       if (inherits(cond, "message")) {
[09:28:25.106]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.106]                         if (muffled) 
[09:28:25.106]                           invokeRestart("muffleMessage")
[09:28:25.106]                       }
[09:28:25.106]                       else if (inherits(cond, "warning")) {
[09:28:25.106]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.106]                         if (muffled) 
[09:28:25.106]                           invokeRestart("muffleWarning")
[09:28:25.106]                       }
[09:28:25.106]                       else if (inherits(cond, "condition")) {
[09:28:25.106]                         if (!is.null(pattern)) {
[09:28:25.106]                           computeRestarts <- base::computeRestarts
[09:28:25.106]                           grepl <- base::grepl
[09:28:25.106]                           restarts <- computeRestarts(cond)
[09:28:25.106]                           for (restart in restarts) {
[09:28:25.106]                             name <- restart$name
[09:28:25.106]                             if (is.null(name)) 
[09:28:25.106]                               next
[09:28:25.106]                             if (!grepl(pattern, name)) 
[09:28:25.106]                               next
[09:28:25.106]                             invokeRestart(restart)
[09:28:25.106]                             muffled <- TRUE
[09:28:25.106]                             break
[09:28:25.106]                           }
[09:28:25.106]                         }
[09:28:25.106]                       }
[09:28:25.106]                       invisible(muffled)
[09:28:25.106]                     }
[09:28:25.106]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.106]                   }
[09:28:25.106]                 }
[09:28:25.106]                 else {
[09:28:25.106]                   if (TRUE) {
[09:28:25.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.106]                     {
[09:28:25.106]                       inherits <- base::inherits
[09:28:25.106]                       invokeRestart <- base::invokeRestart
[09:28:25.106]                       is.null <- base::is.null
[09:28:25.106]                       muffled <- FALSE
[09:28:25.106]                       if (inherits(cond, "message")) {
[09:28:25.106]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.106]                         if (muffled) 
[09:28:25.106]                           invokeRestart("muffleMessage")
[09:28:25.106]                       }
[09:28:25.106]                       else if (inherits(cond, "warning")) {
[09:28:25.106]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.106]                         if (muffled) 
[09:28:25.106]                           invokeRestart("muffleWarning")
[09:28:25.106]                       }
[09:28:25.106]                       else if (inherits(cond, "condition")) {
[09:28:25.106]                         if (!is.null(pattern)) {
[09:28:25.106]                           computeRestarts <- base::computeRestarts
[09:28:25.106]                           grepl <- base::grepl
[09:28:25.106]                           restarts <- computeRestarts(cond)
[09:28:25.106]                           for (restart in restarts) {
[09:28:25.106]                             name <- restart$name
[09:28:25.106]                             if (is.null(name)) 
[09:28:25.106]                               next
[09:28:25.106]                             if (!grepl(pattern, name)) 
[09:28:25.106]                               next
[09:28:25.106]                             invokeRestart(restart)
[09:28:25.106]                             muffled <- TRUE
[09:28:25.106]                             break
[09:28:25.106]                           }
[09:28:25.106]                         }
[09:28:25.106]                       }
[09:28:25.106]                       invisible(muffled)
[09:28:25.106]                     }
[09:28:25.106]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.106]                   }
[09:28:25.106]                 }
[09:28:25.106]             }
[09:28:25.106]         }))
[09:28:25.106]     }, error = function(ex) {
[09:28:25.106]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.106]                 ...future.rng), started = ...future.startTime, 
[09:28:25.106]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.106]             version = "1.8"), class = "FutureResult")
[09:28:25.106]     }, finally = {
[09:28:25.106]         if (!identical(...future.workdir, getwd())) 
[09:28:25.106]             setwd(...future.workdir)
[09:28:25.106]         {
[09:28:25.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.106]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.106]             }
[09:28:25.106]             base::options(...future.oldOptions)
[09:28:25.106]             if (.Platform$OS.type == "windows") {
[09:28:25.106]                 old_names <- names(...future.oldEnvVars)
[09:28:25.106]                 envs <- base::Sys.getenv()
[09:28:25.106]                 names <- names(envs)
[09:28:25.106]                 common <- intersect(names, old_names)
[09:28:25.106]                 added <- setdiff(names, old_names)
[09:28:25.106]                 removed <- setdiff(old_names, names)
[09:28:25.106]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.106]                   envs[common]]
[09:28:25.106]                 NAMES <- toupper(changed)
[09:28:25.106]                 args <- list()
[09:28:25.106]                 for (kk in seq_along(NAMES)) {
[09:28:25.106]                   name <- changed[[kk]]
[09:28:25.106]                   NAME <- NAMES[[kk]]
[09:28:25.106]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.106]                     next
[09:28:25.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.106]                 }
[09:28:25.106]                 NAMES <- toupper(added)
[09:28:25.106]                 for (kk in seq_along(NAMES)) {
[09:28:25.106]                   name <- added[[kk]]
[09:28:25.106]                   NAME <- NAMES[[kk]]
[09:28:25.106]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.106]                     next
[09:28:25.106]                   args[[name]] <- ""
[09:28:25.106]                 }
[09:28:25.106]                 NAMES <- toupper(removed)
[09:28:25.106]                 for (kk in seq_along(NAMES)) {
[09:28:25.106]                   name <- removed[[kk]]
[09:28:25.106]                   NAME <- NAMES[[kk]]
[09:28:25.106]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.106]                     next
[09:28:25.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.106]                 }
[09:28:25.106]                 if (length(args) > 0) 
[09:28:25.106]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.106]             }
[09:28:25.106]             else {
[09:28:25.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.106]             }
[09:28:25.106]             {
[09:28:25.106]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.106]                   0L) {
[09:28:25.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.106]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.106]                   base::options(opts)
[09:28:25.106]                 }
[09:28:25.106]                 {
[09:28:25.106]                   {
[09:28:25.106]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:25.106]                     NULL
[09:28:25.106]                   }
[09:28:25.106]                   options(future.plan = NULL)
[09:28:25.106]                   if (is.na(NA_character_)) 
[09:28:25.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.106]                     .init = FALSE)
[09:28:25.106]                 }
[09:28:25.106]             }
[09:28:25.106]         }
[09:28:25.106]     })
[09:28:25.106]     if (TRUE) {
[09:28:25.106]         base::sink(type = "output", split = FALSE)
[09:28:25.106]         if (TRUE) {
[09:28:25.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.106]         }
[09:28:25.106]         else {
[09:28:25.106]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.106]         }
[09:28:25.106]         base::close(...future.stdout)
[09:28:25.106]         ...future.stdout <- NULL
[09:28:25.106]     }
[09:28:25.106]     ...future.result$conditions <- ...future.conditions
[09:28:25.106]     ...future.result$finished <- base::Sys.time()
[09:28:25.106]     ...future.result
[09:28:25.106] }
[09:28:25.109] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[09:28:25.109] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[09:28:25.109] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[09:28:25.109] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:28:25.110] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:28:25.110] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[09:28:25.110] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[09:28:25.110] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:28:25.111] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:28:25.111] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:28:25.111] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:28:25.111] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[09:28:25.111] MultisessionFuture started
[09:28:25.112] - Launch lazy future ... done
[09:28:25.112] run() for ‘MultisessionFuture’ ... done
[09:28:25.112] Created future:
[09:28:25.112] MultisessionFuture:
[09:28:25.112] Label: ‘future_by-2’
[09:28:25.112] Expression:
[09:28:25.112] {
[09:28:25.112]     do.call(function(...) {
[09:28:25.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.112]             on.exit(options(oopts), add = TRUE)
[09:28:25.112]         }
[09:28:25.112]         {
[09:28:25.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.112]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.112]             })
[09:28:25.112]         }
[09:28:25.112]     }, args = future.call.arguments)
[09:28:25.112] }
[09:28:25.112] Lazy evaluation: FALSE
[09:28:25.112] Asynchronous evaluation: TRUE
[09:28:25.112] Local evaluation: TRUE
[09:28:25.112] Environment: 0x555b08e519d0
[09:28:25.112] Capture standard output: TRUE
[09:28:25.112] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.112] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.112] Packages: <none>
[09:28:25.112] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.112] Resolved: FALSE
[09:28:25.112] Value: <not collected>
[09:28:25.112] Conditions captured: <none>
[09:28:25.112] Early signaling: FALSE
[09:28:25.112] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:25.112] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.124] Chunk #2 of 2 ... DONE
[09:28:25.124] Launching 2 futures (chunks) ... DONE
[09:28:25.124] Resolving 2 futures (chunks) ...
[09:28:25.124] resolve() on list ...
[09:28:25.124]  recursive: 0
[09:28:25.124]  length: 2
[09:28:25.124] 
[09:28:25.125] receiveMessageFromWorker() for ClusterFuture ...
[09:28:25.125] - Validating connection of MultisessionFuture
[09:28:25.125] - received message: FutureResult
[09:28:25.125] - Received FutureResult
[09:28:25.125] - Erased future from FutureRegistry
[09:28:25.125] result() for ClusterFuture ...
[09:28:25.125] - result already collected: FutureResult
[09:28:25.125] result() for ClusterFuture ... done
[09:28:25.126] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:25.126] Future #1
[09:28:25.126] result() for ClusterFuture ...
[09:28:25.126] - result already collected: FutureResult
[09:28:25.126] result() for ClusterFuture ... done
[09:28:25.126] result() for ClusterFuture ...
[09:28:25.126] - result already collected: FutureResult
[09:28:25.126] result() for ClusterFuture ... done
[09:28:25.126] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:25.126] - nx: 2
[09:28:25.126] - relay: TRUE
[09:28:25.126] - stdout: TRUE
[09:28:25.127] - signal: TRUE
[09:28:25.127] - resignal: FALSE
[09:28:25.127] - force: TRUE
[09:28:25.127] - relayed: [n=2] FALSE, FALSE
[09:28:25.127] - queued futures: [n=2] FALSE, FALSE
[09:28:25.127]  - until=1
[09:28:25.127]  - relaying element #1
[09:28:25.127] result() for ClusterFuture ...
[09:28:25.127] - result already collected: FutureResult
[09:28:25.127] result() for ClusterFuture ... done
[09:28:25.127] result() for ClusterFuture ...
[09:28:25.127] - result already collected: FutureResult
[09:28:25.128] result() for ClusterFuture ... done
[09:28:25.128] result() for ClusterFuture ...
[09:28:25.128] - result already collected: FutureResult
[09:28:25.128] result() for ClusterFuture ... done
[09:28:25.128] result() for ClusterFuture ...
[09:28:25.128] - result already collected: FutureResult
[09:28:25.128] result() for ClusterFuture ... done
[09:28:25.128] - relayed: [n=2] TRUE, FALSE
[09:28:25.128] - queued futures: [n=2] TRUE, FALSE
[09:28:25.128] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:25.129]  length: 1 (resolved future 1)
[09:28:25.154] receiveMessageFromWorker() for ClusterFuture ...
[09:28:25.154] - Validating connection of MultisessionFuture
[09:28:25.155] - received message: FutureResult
[09:28:25.155] - Received FutureResult
[09:28:25.155] - Erased future from FutureRegistry
[09:28:25.155] result() for ClusterFuture ...
[09:28:25.155] - result already collected: FutureResult
[09:28:25.155] result() for ClusterFuture ... done
[09:28:25.155] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:25.155] Future #2
[09:28:25.155] result() for ClusterFuture ...
[09:28:25.156] - result already collected: FutureResult
[09:28:25.156] result() for ClusterFuture ... done
[09:28:25.156] result() for ClusterFuture ...
[09:28:25.156] - result already collected: FutureResult
[09:28:25.156] result() for ClusterFuture ... done
[09:28:25.156] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:25.156] - nx: 2
[09:28:25.156] - relay: TRUE
[09:28:25.156] - stdout: TRUE
[09:28:25.156] - signal: TRUE
[09:28:25.156] - resignal: FALSE
[09:28:25.156] - force: TRUE
[09:28:25.157] - relayed: [n=2] TRUE, FALSE
[09:28:25.157] - queued futures: [n=2] TRUE, FALSE
[09:28:25.157]  - until=2
[09:28:25.157]  - relaying element #2
[09:28:25.157] result() for ClusterFuture ...
[09:28:25.157] - result already collected: FutureResult
[09:28:25.157] result() for ClusterFuture ... done
[09:28:25.157] result() for ClusterFuture ...
[09:28:25.157] - result already collected: FutureResult
[09:28:25.157] result() for ClusterFuture ... done
[09:28:25.157] result() for ClusterFuture ...
[09:28:25.158] - result already collected: FutureResult
[09:28:25.158] result() for ClusterFuture ... done
[09:28:25.158] result() for ClusterFuture ...
[09:28:25.158] - result already collected: FutureResult
[09:28:25.158] result() for ClusterFuture ... done
[09:28:25.158] - relayed: [n=2] TRUE, TRUE
[09:28:25.158] - queued futures: [n=2] TRUE, TRUE
[09:28:25.158] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:25.158]  length: 0 (resolved future 2)
[09:28:25.158] Relaying remaining futures
[09:28:25.158] signalConditionsASAP(NULL, pos=0) ...
[09:28:25.158] - nx: 2
[09:28:25.159] - relay: TRUE
[09:28:25.159] - stdout: TRUE
[09:28:25.159] - signal: TRUE
[09:28:25.159] - resignal: FALSE
[09:28:25.159] - force: TRUE
[09:28:25.159] - relayed: [n=2] TRUE, TRUE
[09:28:25.159] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:25.159] - relayed: [n=2] TRUE, TRUE
[09:28:25.159] - queued futures: [n=2] TRUE, TRUE
[09:28:25.159] signalConditionsASAP(NULL, pos=0) ... done
[09:28:25.159] resolve() on list ... DONE
[09:28:25.159] result() for ClusterFuture ...
[09:28:25.160] - result already collected: FutureResult
[09:28:25.160] result() for ClusterFuture ... done
[09:28:25.160] result() for ClusterFuture ...
[09:28:25.160] - result already collected: FutureResult
[09:28:25.160] result() for ClusterFuture ... done
[09:28:25.160] result() for ClusterFuture ...
[09:28:25.160] - result already collected: FutureResult
[09:28:25.160] result() for ClusterFuture ... done
[09:28:25.160] result() for ClusterFuture ...
[09:28:25.160] - result already collected: FutureResult
[09:28:25.160] result() for ClusterFuture ... done
[09:28:25.161]  - Number of value chunks collected: 2
[09:28:25.161] Resolving 2 futures (chunks) ... DONE
[09:28:25.161] Reducing values from 2 chunks ...
[09:28:25.161]  - Number of values collected after concatenation: 3
[09:28:25.161]  - Number of values expected: 3
[09:28:25.161] Reducing values from 2 chunks ... DONE
[09:28:25.161] future_lapply() ... DONE
[09:28:25.161] future_by_internal() ... DONE
[09:28:25.162] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[09:28:25.162] future_lapply() ...
[09:28:25.166] Number of chunks: 2
[09:28:25.166] getGlobalsAndPackagesXApply() ...
[09:28:25.166]  - future.globals: TRUE
[09:28:25.166] getGlobalsAndPackages() ...
[09:28:25.167] Searching for globals...
[09:28:25.167] - globals found: [2] ‘FUN’, ‘UseMethod’
[09:28:25.168] Searching for globals ... DONE
[09:28:25.168] Resolving globals: FALSE
[09:28:25.168] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[09:28:25.168] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[09:28:25.169] - globals: [1] ‘FUN’
[09:28:25.169] 
[09:28:25.169] getGlobalsAndPackages() ... DONE
[09:28:25.169]  - globals found/used: [n=1] ‘FUN’
[09:28:25.171]  - needed namespaces: [n=0] 
[09:28:25.171] Finding globals ... DONE
[09:28:25.171]  - use_args: TRUE
[09:28:25.171]  - Getting '...' globals ...
[09:28:25.172] resolve() on list ...
[09:28:25.172]  recursive: 0
[09:28:25.172]  length: 1
[09:28:25.172]  elements: ‘...’
[09:28:25.172]  length: 0 (resolved future 1)
[09:28:25.172] resolve() on list ... DONE
[09:28:25.172]    - '...' content: [n=0] 
[09:28:25.172] List of 1
[09:28:25.172]  $ ...: list()
[09:28:25.172]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.172]  - attr(*, "where")=List of 1
[09:28:25.172]   ..$ ...:<environment: 0x555b0ce1cff0> 
[09:28:25.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.172]  - attr(*, "resolved")= logi TRUE
[09:28:25.172]  - attr(*, "total_size")= num NA
[09:28:25.175]  - Getting '...' globals ... DONE
[09:28:25.175] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:28:25.175] List of 2
[09:28:25.175]  $ ...future.FUN:function (object, ...)  
[09:28:25.175]  $ ...          : list()
[09:28:25.175]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:28:25.175]  - attr(*, "where")=List of 2
[09:28:25.175]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:28:25.175]   ..$ ...          :<environment: 0x555b0ce1cff0> 
[09:28:25.175]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:28:25.175]  - attr(*, "resolved")= logi FALSE
[09:28:25.175]  - attr(*, "total_size")= num 1240
[09:28:25.177] Packages to be attached in all futures: [n=0] 
[09:28:25.178] getGlobalsAndPackagesXApply() ... DONE
[09:28:25.178] Number of futures (= number of chunks): 2
[09:28:25.178] Launching 2 futures (chunks) ...
[09:28:25.178] Chunk #1 of 2 ...
[09:28:25.178]  - Finding globals in 'X' for chunk #1 ...
[09:28:25.178] getGlobalsAndPackages() ...
[09:28:25.178] Searching for globals...
[09:28:25.179] 
[09:28:25.179] Searching for globals ... DONE
[09:28:25.179] - globals: [0] <none>
[09:28:25.179] getGlobalsAndPackages() ... DONE
[09:28:25.179]    + additional globals found: [n=0] 
[09:28:25.179]    + additional namespaces needed: [n=0] 
[09:28:25.179]  - Finding globals in 'X' for chunk #1 ... DONE
[09:28:25.179]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:25.179]  - seeds: <none>
[09:28:25.179]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.179] getGlobalsAndPackages() ...
[09:28:25.180] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.180] Resolving globals: FALSE
[09:28:25.180] Tweak future expression to call with '...' arguments ...
[09:28:25.180] {
[09:28:25.180]     do.call(function(...) {
[09:28:25.180]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.180]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.180]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.180]             on.exit(options(oopts), add = TRUE)
[09:28:25.180]         }
[09:28:25.180]         {
[09:28:25.180]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.180]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.180]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.180]             })
[09:28:25.180]         }
[09:28:25.180]     }, args = future.call.arguments)
[09:28:25.180] }
[09:28:25.180] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.181] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.181] 
[09:28:25.181] getGlobalsAndPackages() ... DONE
[09:28:25.181] run() for ‘Future’ ...
[09:28:25.181] - state: ‘created’
[09:28:25.181] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:25.195] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.195] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:25.195]   - Field: ‘node’
[09:28:25.195]   - Field: ‘label’
[09:28:25.195]   - Field: ‘local’
[09:28:25.196]   - Field: ‘owner’
[09:28:25.196]   - Field: ‘envir’
[09:28:25.196]   - Field: ‘workers’
[09:28:25.196]   - Field: ‘packages’
[09:28:25.196]   - Field: ‘gc’
[09:28:25.196]   - Field: ‘conditions’
[09:28:25.196]   - Field: ‘persistent’
[09:28:25.196]   - Field: ‘expr’
[09:28:25.196]   - Field: ‘uuid’
[09:28:25.196]   - Field: ‘seed’
[09:28:25.196]   - Field: ‘version’
[09:28:25.197]   - Field: ‘result’
[09:28:25.197]   - Field: ‘asynchronous’
[09:28:25.197]   - Field: ‘calls’
[09:28:25.197]   - Field: ‘globals’
[09:28:25.197]   - Field: ‘stdout’
[09:28:25.197]   - Field: ‘earlySignal’
[09:28:25.197]   - Field: ‘lazy’
[09:28:25.197]   - Field: ‘state’
[09:28:25.197] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:25.197] - Launch lazy future ...
[09:28:25.198] Packages needed by the future expression (n = 0): <none>
[09:28:25.198] Packages needed by future strategies (n = 0): <none>
[09:28:25.198] {
[09:28:25.198]     {
[09:28:25.198]         {
[09:28:25.198]             ...future.startTime <- base::Sys.time()
[09:28:25.198]             {
[09:28:25.198]                 {
[09:28:25.198]                   {
[09:28:25.198]                     {
[09:28:25.198]                       base::local({
[09:28:25.198]                         has_future <- base::requireNamespace("future", 
[09:28:25.198]                           quietly = TRUE)
[09:28:25.198]                         if (has_future) {
[09:28:25.198]                           ns <- base::getNamespace("future")
[09:28:25.198]                           version <- ns[[".package"]][["version"]]
[09:28:25.198]                           if (is.null(version)) 
[09:28:25.198]                             version <- utils::packageVersion("future")
[09:28:25.198]                         }
[09:28:25.198]                         else {
[09:28:25.198]                           version <- NULL
[09:28:25.198]                         }
[09:28:25.198]                         if (!has_future || version < "1.8.0") {
[09:28:25.198]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.198]                             "", base::R.version$version.string), 
[09:28:25.198]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:25.198]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:25.198]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.198]                               "release", "version")], collapse = " "), 
[09:28:25.198]                             hostname = base::Sys.info()[["nodename"]])
[09:28:25.198]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.198]                             info)
[09:28:25.198]                           info <- base::paste(info, collapse = "; ")
[09:28:25.198]                           if (!has_future) {
[09:28:25.198]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.198]                               info)
[09:28:25.198]                           }
[09:28:25.198]                           else {
[09:28:25.198]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.198]                               info, version)
[09:28:25.198]                           }
[09:28:25.198]                           base::stop(msg)
[09:28:25.198]                         }
[09:28:25.198]                       })
[09:28:25.198]                     }
[09:28:25.198]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:25.198]                     base::options(mc.cores = 1L)
[09:28:25.198]                   }
[09:28:25.198]                   ...future.strategy.old <- future::plan("list")
[09:28:25.198]                   options(future.plan = NULL)
[09:28:25.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.198]                 }
[09:28:25.198]                 ...future.workdir <- getwd()
[09:28:25.198]             }
[09:28:25.198]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.198]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.198]         }
[09:28:25.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.198]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:25.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.198]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.198]             base::names(...future.oldOptions))
[09:28:25.198]     }
[09:28:25.198]     if (FALSE) {
[09:28:25.198]     }
[09:28:25.198]     else {
[09:28:25.198]         if (TRUE) {
[09:28:25.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.198]                 open = "w")
[09:28:25.198]         }
[09:28:25.198]         else {
[09:28:25.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.198]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.198]         }
[09:28:25.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.198]             base::sink(type = "output", split = FALSE)
[09:28:25.198]             base::close(...future.stdout)
[09:28:25.198]         }, add = TRUE)
[09:28:25.198]     }
[09:28:25.198]     ...future.frame <- base::sys.nframe()
[09:28:25.198]     ...future.conditions <- base::list()
[09:28:25.198]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.198]     if (FALSE) {
[09:28:25.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.198]     }
[09:28:25.198]     ...future.result <- base::tryCatch({
[09:28:25.198]         base::withCallingHandlers({
[09:28:25.198]             ...future.value <- base::withVisible(base::local({
[09:28:25.198]                 ...future.makeSendCondition <- base::local({
[09:28:25.198]                   sendCondition <- NULL
[09:28:25.198]                   function(frame = 1L) {
[09:28:25.198]                     if (is.function(sendCondition)) 
[09:28:25.198]                       return(sendCondition)
[09:28:25.198]                     ns <- getNamespace("parallel")
[09:28:25.198]                     if (exists("sendData", mode = "function", 
[09:28:25.198]                       envir = ns)) {
[09:28:25.198]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:25.198]                         envir = ns)
[09:28:25.198]                       envir <- sys.frame(frame)
[09:28:25.198]                       master <- NULL
[09:28:25.198]                       while (!identical(envir, .GlobalEnv) && 
[09:28:25.198]                         !identical(envir, emptyenv())) {
[09:28:25.198]                         if (exists("master", mode = "list", envir = envir, 
[09:28:25.198]                           inherits = FALSE)) {
[09:28:25.198]                           master <- get("master", mode = "list", 
[09:28:25.198]                             envir = envir, inherits = FALSE)
[09:28:25.198]                           if (inherits(master, c("SOCKnode", 
[09:28:25.198]                             "SOCK0node"))) {
[09:28:25.198]                             sendCondition <<- function(cond) {
[09:28:25.198]                               data <- list(type = "VALUE", value = cond, 
[09:28:25.198]                                 success = TRUE)
[09:28:25.198]                               parallel_sendData(master, data)
[09:28:25.198]                             }
[09:28:25.198]                             return(sendCondition)
[09:28:25.198]                           }
[09:28:25.198]                         }
[09:28:25.198]                         frame <- frame + 1L
[09:28:25.198]                         envir <- sys.frame(frame)
[09:28:25.198]                       }
[09:28:25.198]                     }
[09:28:25.198]                     sendCondition <<- function(cond) NULL
[09:28:25.198]                   }
[09:28:25.198]                 })
[09:28:25.198]                 withCallingHandlers({
[09:28:25.198]                   {
[09:28:25.198]                     do.call(function(...) {
[09:28:25.198]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.198]                       if (!identical(...future.globals.maxSize.org, 
[09:28:25.198]                         ...future.globals.maxSize)) {
[09:28:25.198]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.198]                         on.exit(options(oopts), add = TRUE)
[09:28:25.198]                       }
[09:28:25.198]                       {
[09:28:25.198]                         lapply(seq_along(...future.elements_ii), 
[09:28:25.198]                           FUN = function(jj) {
[09:28:25.198]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.198]                             ...future.FUN(...future.X_jj, ...)
[09:28:25.198]                           })
[09:28:25.198]                       }
[09:28:25.198]                     }, args = future.call.arguments)
[09:28:25.198]                   }
[09:28:25.198]                 }, immediateCondition = function(cond) {
[09:28:25.198]                   sendCondition <- ...future.makeSendCondition()
[09:28:25.198]                   sendCondition(cond)
[09:28:25.198]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.198]                   {
[09:28:25.198]                     inherits <- base::inherits
[09:28:25.198]                     invokeRestart <- base::invokeRestart
[09:28:25.198]                     is.null <- base::is.null
[09:28:25.198]                     muffled <- FALSE
[09:28:25.198]                     if (inherits(cond, "message")) {
[09:28:25.198]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:25.198]                       if (muffled) 
[09:28:25.198]                         invokeRestart("muffleMessage")
[09:28:25.198]                     }
[09:28:25.198]                     else if (inherits(cond, "warning")) {
[09:28:25.198]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:25.198]                       if (muffled) 
[09:28:25.198]                         invokeRestart("muffleWarning")
[09:28:25.198]                     }
[09:28:25.198]                     else if (inherits(cond, "condition")) {
[09:28:25.198]                       if (!is.null(pattern)) {
[09:28:25.198]                         computeRestarts <- base::computeRestarts
[09:28:25.198]                         grepl <- base::grepl
[09:28:25.198]                         restarts <- computeRestarts(cond)
[09:28:25.198]                         for (restart in restarts) {
[09:28:25.198]                           name <- restart$name
[09:28:25.198]                           if (is.null(name)) 
[09:28:25.198]                             next
[09:28:25.198]                           if (!grepl(pattern, name)) 
[09:28:25.198]                             next
[09:28:25.198]                           invokeRestart(restart)
[09:28:25.198]                           muffled <- TRUE
[09:28:25.198]                           break
[09:28:25.198]                         }
[09:28:25.198]                       }
[09:28:25.198]                     }
[09:28:25.198]                     invisible(muffled)
[09:28:25.198]                   }
[09:28:25.198]                   muffleCondition(cond)
[09:28:25.198]                 })
[09:28:25.198]             }))
[09:28:25.198]             future::FutureResult(value = ...future.value$value, 
[09:28:25.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.198]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.198]                     ...future.globalenv.names))
[09:28:25.198]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.198]         }, condition = base::local({
[09:28:25.198]             c <- base::c
[09:28:25.198]             inherits <- base::inherits
[09:28:25.198]             invokeRestart <- base::invokeRestart
[09:28:25.198]             length <- base::length
[09:28:25.198]             list <- base::list
[09:28:25.198]             seq.int <- base::seq.int
[09:28:25.198]             signalCondition <- base::signalCondition
[09:28:25.198]             sys.calls <- base::sys.calls
[09:28:25.198]             `[[` <- base::`[[`
[09:28:25.198]             `+` <- base::`+`
[09:28:25.198]             `<<-` <- base::`<<-`
[09:28:25.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.198]                   3L)]
[09:28:25.198]             }
[09:28:25.198]             function(cond) {
[09:28:25.198]                 is_error <- inherits(cond, "error")
[09:28:25.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.198]                   NULL)
[09:28:25.198]                 if (is_error) {
[09:28:25.198]                   sessionInformation <- function() {
[09:28:25.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.198]                       search = base::search(), system = base::Sys.info())
[09:28:25.198]                   }
[09:28:25.198]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.198]                     cond$call), session = sessionInformation(), 
[09:28:25.198]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.198]                   signalCondition(cond)
[09:28:25.198]                 }
[09:28:25.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.198]                 "immediateCondition"))) {
[09:28:25.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.198]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.198]                   if (TRUE && !signal) {
[09:28:25.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.198]                     {
[09:28:25.198]                       inherits <- base::inherits
[09:28:25.198]                       invokeRestart <- base::invokeRestart
[09:28:25.198]                       is.null <- base::is.null
[09:28:25.198]                       muffled <- FALSE
[09:28:25.198]                       if (inherits(cond, "message")) {
[09:28:25.198]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.198]                         if (muffled) 
[09:28:25.198]                           invokeRestart("muffleMessage")
[09:28:25.198]                       }
[09:28:25.198]                       else if (inherits(cond, "warning")) {
[09:28:25.198]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.198]                         if (muffled) 
[09:28:25.198]                           invokeRestart("muffleWarning")
[09:28:25.198]                       }
[09:28:25.198]                       else if (inherits(cond, "condition")) {
[09:28:25.198]                         if (!is.null(pattern)) {
[09:28:25.198]                           computeRestarts <- base::computeRestarts
[09:28:25.198]                           grepl <- base::grepl
[09:28:25.198]                           restarts <- computeRestarts(cond)
[09:28:25.198]                           for (restart in restarts) {
[09:28:25.198]                             name <- restart$name
[09:28:25.198]                             if (is.null(name)) 
[09:28:25.198]                               next
[09:28:25.198]                             if (!grepl(pattern, name)) 
[09:28:25.198]                               next
[09:28:25.198]                             invokeRestart(restart)
[09:28:25.198]                             muffled <- TRUE
[09:28:25.198]                             break
[09:28:25.198]                           }
[09:28:25.198]                         }
[09:28:25.198]                       }
[09:28:25.198]                       invisible(muffled)
[09:28:25.198]                     }
[09:28:25.198]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.198]                   }
[09:28:25.198]                 }
[09:28:25.198]                 else {
[09:28:25.198]                   if (TRUE) {
[09:28:25.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.198]                     {
[09:28:25.198]                       inherits <- base::inherits
[09:28:25.198]                       invokeRestart <- base::invokeRestart
[09:28:25.198]                       is.null <- base::is.null
[09:28:25.198]                       muffled <- FALSE
[09:28:25.198]                       if (inherits(cond, "message")) {
[09:28:25.198]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.198]                         if (muffled) 
[09:28:25.198]                           invokeRestart("muffleMessage")
[09:28:25.198]                       }
[09:28:25.198]                       else if (inherits(cond, "warning")) {
[09:28:25.198]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.198]                         if (muffled) 
[09:28:25.198]                           invokeRestart("muffleWarning")
[09:28:25.198]                       }
[09:28:25.198]                       else if (inherits(cond, "condition")) {
[09:28:25.198]                         if (!is.null(pattern)) {
[09:28:25.198]                           computeRestarts <- base::computeRestarts
[09:28:25.198]                           grepl <- base::grepl
[09:28:25.198]                           restarts <- computeRestarts(cond)
[09:28:25.198]                           for (restart in restarts) {
[09:28:25.198]                             name <- restart$name
[09:28:25.198]                             if (is.null(name)) 
[09:28:25.198]                               next
[09:28:25.198]                             if (!grepl(pattern, name)) 
[09:28:25.198]                               next
[09:28:25.198]                             invokeRestart(restart)
[09:28:25.198]                             muffled <- TRUE
[09:28:25.198]                             break
[09:28:25.198]                           }
[09:28:25.198]                         }
[09:28:25.198]                       }
[09:28:25.198]                       invisible(muffled)
[09:28:25.198]                     }
[09:28:25.198]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.198]                   }
[09:28:25.198]                 }
[09:28:25.198]             }
[09:28:25.198]         }))
[09:28:25.198]     }, error = function(ex) {
[09:28:25.198]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.198]                 ...future.rng), started = ...future.startTime, 
[09:28:25.198]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.198]             version = "1.8"), class = "FutureResult")
[09:28:25.198]     }, finally = {
[09:28:25.198]         if (!identical(...future.workdir, getwd())) 
[09:28:25.198]             setwd(...future.workdir)
[09:28:25.198]         {
[09:28:25.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.198]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.198]             }
[09:28:25.198]             base::options(...future.oldOptions)
[09:28:25.198]             if (.Platform$OS.type == "windows") {
[09:28:25.198]                 old_names <- names(...future.oldEnvVars)
[09:28:25.198]                 envs <- base::Sys.getenv()
[09:28:25.198]                 names <- names(envs)
[09:28:25.198]                 common <- intersect(names, old_names)
[09:28:25.198]                 added <- setdiff(names, old_names)
[09:28:25.198]                 removed <- setdiff(old_names, names)
[09:28:25.198]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.198]                   envs[common]]
[09:28:25.198]                 NAMES <- toupper(changed)
[09:28:25.198]                 args <- list()
[09:28:25.198]                 for (kk in seq_along(NAMES)) {
[09:28:25.198]                   name <- changed[[kk]]
[09:28:25.198]                   NAME <- NAMES[[kk]]
[09:28:25.198]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.198]                     next
[09:28:25.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.198]                 }
[09:28:25.198]                 NAMES <- toupper(added)
[09:28:25.198]                 for (kk in seq_along(NAMES)) {
[09:28:25.198]                   name <- added[[kk]]
[09:28:25.198]                   NAME <- NAMES[[kk]]
[09:28:25.198]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.198]                     next
[09:28:25.198]                   args[[name]] <- ""
[09:28:25.198]                 }
[09:28:25.198]                 NAMES <- toupper(removed)
[09:28:25.198]                 for (kk in seq_along(NAMES)) {
[09:28:25.198]                   name <- removed[[kk]]
[09:28:25.198]                   NAME <- NAMES[[kk]]
[09:28:25.198]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.198]                     next
[09:28:25.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.198]                 }
[09:28:25.198]                 if (length(args) > 0) 
[09:28:25.198]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.198]             }
[09:28:25.198]             else {
[09:28:25.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.198]             }
[09:28:25.198]             {
[09:28:25.198]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.198]                   0L) {
[09:28:25.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.198]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.198]                   base::options(opts)
[09:28:25.198]                 }
[09:28:25.198]                 {
[09:28:25.198]                   {
[09:28:25.198]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:25.198]                     NULL
[09:28:25.198]                   }
[09:28:25.198]                   options(future.plan = NULL)
[09:28:25.198]                   if (is.na(NA_character_)) 
[09:28:25.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.198]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.198]                     .init = FALSE)
[09:28:25.198]                 }
[09:28:25.198]             }
[09:28:25.198]         }
[09:28:25.198]     })
[09:28:25.198]     if (TRUE) {
[09:28:25.198]         base::sink(type = "output", split = FALSE)
[09:28:25.198]         if (TRUE) {
[09:28:25.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.198]         }
[09:28:25.198]         else {
[09:28:25.198]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.198]         }
[09:28:25.198]         base::close(...future.stdout)
[09:28:25.198]         ...future.stdout <- NULL
[09:28:25.198]     }
[09:28:25.198]     ...future.result$conditions <- ...future.conditions
[09:28:25.198]     ...future.result$finished <- base::Sys.time()
[09:28:25.198]     ...future.result
[09:28:25.198] }
[09:28:25.201] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[09:28:25.201] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[09:28:25.201] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[09:28:25.201] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:25.202] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:25.202] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[09:28:25.202] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[09:28:25.203] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:25.203] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:25.203] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:28:25.203] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:28:25.203] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[09:28:25.204] MultisessionFuture started
[09:28:25.204] - Launch lazy future ... done
[09:28:25.204] run() for ‘MultisessionFuture’ ... done
[09:28:25.204] Created future:
[09:28:25.206] receiveMessageFromWorker() for ClusterFuture ...
[09:28:25.206] - Validating connection of MultisessionFuture
[09:28:25.206] - received message: FutureResult
[09:28:25.207] - Received FutureResult
[09:28:25.207] - Erased future from FutureRegistry
[09:28:25.207] result() for ClusterFuture ...
[09:28:25.207] - result already collected: FutureResult
[09:28:25.207] result() for ClusterFuture ... done
[09:28:25.207] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:25.204] MultisessionFuture:
[09:28:25.204] Label: ‘future_by-1’
[09:28:25.204] Expression:
[09:28:25.204] {
[09:28:25.204]     do.call(function(...) {
[09:28:25.204]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.204]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.204]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.204]             on.exit(options(oopts), add = TRUE)
[09:28:25.204]         }
[09:28:25.204]         {
[09:28:25.204]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.204]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.204]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.204]             })
[09:28:25.204]         }
[09:28:25.204]     }, args = future.call.arguments)
[09:28:25.204] }
[09:28:25.204] Lazy evaluation: FALSE
[09:28:25.204] Asynchronous evaluation: TRUE
[09:28:25.204] Local evaluation: TRUE
[09:28:25.204] Environment: 0x555b0cde6b80
[09:28:25.204] Capture standard output: TRUE
[09:28:25.204] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.204] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.204] Packages: <none>
[09:28:25.204] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.204] Resolved: TRUE
[09:28:25.204] Value: <not collected>
[09:28:25.204] Conditions captured: <none>
[09:28:25.204] Early signaling: FALSE
[09:28:25.204] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:25.204] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.207] Chunk #1 of 2 ... DONE
[09:28:25.207] Chunk #2 of 2 ...
[09:28:25.208]  - Finding globals in 'X' for chunk #2 ...
[09:28:25.208] getGlobalsAndPackages() ...
[09:28:25.208] Searching for globals...
[09:28:25.208] 
[09:28:25.208] Searching for globals ... DONE
[09:28:25.208] - globals: [0] <none>
[09:28:25.208] getGlobalsAndPackages() ... DONE
[09:28:25.209]    + additional globals found: [n=0] 
[09:28:25.209]    + additional namespaces needed: [n=0] 
[09:28:25.209]  - Finding globals in 'X' for chunk #2 ... DONE
[09:28:25.209]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:28:25.209]  - seeds: <none>
[09:28:25.209]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.209] getGlobalsAndPackages() ...
[09:28:25.209] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.209] Resolving globals: FALSE
[09:28:25.209] Tweak future expression to call with '...' arguments ...
[09:28:25.210] {
[09:28:25.210]     do.call(function(...) {
[09:28:25.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.210]             on.exit(options(oopts), add = TRUE)
[09:28:25.210]         }
[09:28:25.210]         {
[09:28:25.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.210]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.210]             })
[09:28:25.210]         }
[09:28:25.210]     }, args = future.call.arguments)
[09:28:25.210] }
[09:28:25.210] Tweak future expression to call with '...' arguments ... DONE
[09:28:25.210] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:28:25.210] 
[09:28:25.210] getGlobalsAndPackages() ... DONE
[09:28:25.211] run() for ‘Future’ ...
[09:28:25.211] - state: ‘created’
[09:28:25.211] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:28:25.224] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:28:25.224]   - Field: ‘node’
[09:28:25.224]   - Field: ‘label’
[09:28:25.224]   - Field: ‘local’
[09:28:25.225]   - Field: ‘owner’
[09:28:25.225]   - Field: ‘envir’
[09:28:25.225]   - Field: ‘workers’
[09:28:25.225]   - Field: ‘packages’
[09:28:25.225]   - Field: ‘gc’
[09:28:25.225]   - Field: ‘conditions’
[09:28:25.225]   - Field: ‘persistent’
[09:28:25.225]   - Field: ‘expr’
[09:28:25.225]   - Field: ‘uuid’
[09:28:25.225]   - Field: ‘seed’
[09:28:25.225]   - Field: ‘version’
[09:28:25.226]   - Field: ‘result’
[09:28:25.226]   - Field: ‘asynchronous’
[09:28:25.226]   - Field: ‘calls’
[09:28:25.226]   - Field: ‘globals’
[09:28:25.226]   - Field: ‘stdout’
[09:28:25.226]   - Field: ‘earlySignal’
[09:28:25.226]   - Field: ‘lazy’
[09:28:25.226]   - Field: ‘state’
[09:28:25.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:28:25.226] - Launch lazy future ...
[09:28:25.227] Packages needed by the future expression (n = 0): <none>
[09:28:25.227] Packages needed by future strategies (n = 0): <none>
[09:28:25.227] {
[09:28:25.227]     {
[09:28:25.227]         {
[09:28:25.227]             ...future.startTime <- base::Sys.time()
[09:28:25.227]             {
[09:28:25.227]                 {
[09:28:25.227]                   {
[09:28:25.227]                     {
[09:28:25.227]                       base::local({
[09:28:25.227]                         has_future <- base::requireNamespace("future", 
[09:28:25.227]                           quietly = TRUE)
[09:28:25.227]                         if (has_future) {
[09:28:25.227]                           ns <- base::getNamespace("future")
[09:28:25.227]                           version <- ns[[".package"]][["version"]]
[09:28:25.227]                           if (is.null(version)) 
[09:28:25.227]                             version <- utils::packageVersion("future")
[09:28:25.227]                         }
[09:28:25.227]                         else {
[09:28:25.227]                           version <- NULL
[09:28:25.227]                         }
[09:28:25.227]                         if (!has_future || version < "1.8.0") {
[09:28:25.227]                           info <- base::c(r_version = base::gsub("R version ", 
[09:28:25.227]                             "", base::R.version$version.string), 
[09:28:25.227]                             platform = base::sprintf("%s (%s-bit)", 
[09:28:25.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:28:25.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:28:25.227]                               "release", "version")], collapse = " "), 
[09:28:25.227]                             hostname = base::Sys.info()[["nodename"]])
[09:28:25.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:28:25.227]                             info)
[09:28:25.227]                           info <- base::paste(info, collapse = "; ")
[09:28:25.227]                           if (!has_future) {
[09:28:25.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:28:25.227]                               info)
[09:28:25.227]                           }
[09:28:25.227]                           else {
[09:28:25.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:28:25.227]                               info, version)
[09:28:25.227]                           }
[09:28:25.227]                           base::stop(msg)
[09:28:25.227]                         }
[09:28:25.227]                       })
[09:28:25.227]                     }
[09:28:25.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:28:25.227]                     base::options(mc.cores = 1L)
[09:28:25.227]                   }
[09:28:25.227]                   ...future.strategy.old <- future::plan("list")
[09:28:25.227]                   options(future.plan = NULL)
[09:28:25.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:28:25.227]                 }
[09:28:25.227]                 ...future.workdir <- getwd()
[09:28:25.227]             }
[09:28:25.227]             ...future.oldOptions <- base::as.list(base::.Options)
[09:28:25.227]             ...future.oldEnvVars <- base::Sys.getenv()
[09:28:25.227]         }
[09:28:25.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:28:25.227]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:28:25.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:28:25.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:28:25.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:28:25.227]             future.stdout.windows.reencode = NULL, width = 80L)
[09:28:25.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:28:25.227]             base::names(...future.oldOptions))
[09:28:25.227]     }
[09:28:25.227]     if (FALSE) {
[09:28:25.227]     }
[09:28:25.227]     else {
[09:28:25.227]         if (TRUE) {
[09:28:25.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:28:25.227]                 open = "w")
[09:28:25.227]         }
[09:28:25.227]         else {
[09:28:25.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:28:25.227]                 windows = "NUL", "/dev/null"), open = "w")
[09:28:25.227]         }
[09:28:25.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:28:25.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:28:25.227]             base::sink(type = "output", split = FALSE)
[09:28:25.227]             base::close(...future.stdout)
[09:28:25.227]         }, add = TRUE)
[09:28:25.227]     }
[09:28:25.227]     ...future.frame <- base::sys.nframe()
[09:28:25.227]     ...future.conditions <- base::list()
[09:28:25.227]     ...future.rng <- base::globalenv()$.Random.seed
[09:28:25.227]     if (FALSE) {
[09:28:25.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:28:25.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:28:25.227]     }
[09:28:25.227]     ...future.result <- base::tryCatch({
[09:28:25.227]         base::withCallingHandlers({
[09:28:25.227]             ...future.value <- base::withVisible(base::local({
[09:28:25.227]                 ...future.makeSendCondition <- base::local({
[09:28:25.227]                   sendCondition <- NULL
[09:28:25.227]                   function(frame = 1L) {
[09:28:25.227]                     if (is.function(sendCondition)) 
[09:28:25.227]                       return(sendCondition)
[09:28:25.227]                     ns <- getNamespace("parallel")
[09:28:25.227]                     if (exists("sendData", mode = "function", 
[09:28:25.227]                       envir = ns)) {
[09:28:25.227]                       parallel_sendData <- get("sendData", mode = "function", 
[09:28:25.227]                         envir = ns)
[09:28:25.227]                       envir <- sys.frame(frame)
[09:28:25.227]                       master <- NULL
[09:28:25.227]                       while (!identical(envir, .GlobalEnv) && 
[09:28:25.227]                         !identical(envir, emptyenv())) {
[09:28:25.227]                         if (exists("master", mode = "list", envir = envir, 
[09:28:25.227]                           inherits = FALSE)) {
[09:28:25.227]                           master <- get("master", mode = "list", 
[09:28:25.227]                             envir = envir, inherits = FALSE)
[09:28:25.227]                           if (inherits(master, c("SOCKnode", 
[09:28:25.227]                             "SOCK0node"))) {
[09:28:25.227]                             sendCondition <<- function(cond) {
[09:28:25.227]                               data <- list(type = "VALUE", value = cond, 
[09:28:25.227]                                 success = TRUE)
[09:28:25.227]                               parallel_sendData(master, data)
[09:28:25.227]                             }
[09:28:25.227]                             return(sendCondition)
[09:28:25.227]                           }
[09:28:25.227]                         }
[09:28:25.227]                         frame <- frame + 1L
[09:28:25.227]                         envir <- sys.frame(frame)
[09:28:25.227]                       }
[09:28:25.227]                     }
[09:28:25.227]                     sendCondition <<- function(cond) NULL
[09:28:25.227]                   }
[09:28:25.227]                 })
[09:28:25.227]                 withCallingHandlers({
[09:28:25.227]                   {
[09:28:25.227]                     do.call(function(...) {
[09:28:25.227]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.227]                       if (!identical(...future.globals.maxSize.org, 
[09:28:25.227]                         ...future.globals.maxSize)) {
[09:28:25.227]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.227]                         on.exit(options(oopts), add = TRUE)
[09:28:25.227]                       }
[09:28:25.227]                       {
[09:28:25.227]                         lapply(seq_along(...future.elements_ii), 
[09:28:25.227]                           FUN = function(jj) {
[09:28:25.227]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.227]                             ...future.FUN(...future.X_jj, ...)
[09:28:25.227]                           })
[09:28:25.227]                       }
[09:28:25.227]                     }, args = future.call.arguments)
[09:28:25.227]                   }
[09:28:25.227]                 }, immediateCondition = function(cond) {
[09:28:25.227]                   sendCondition <- ...future.makeSendCondition()
[09:28:25.227]                   sendCondition(cond)
[09:28:25.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.227]                   {
[09:28:25.227]                     inherits <- base::inherits
[09:28:25.227]                     invokeRestart <- base::invokeRestart
[09:28:25.227]                     is.null <- base::is.null
[09:28:25.227]                     muffled <- FALSE
[09:28:25.227]                     if (inherits(cond, "message")) {
[09:28:25.227]                       muffled <- grepl(pattern, "muffleMessage")
[09:28:25.227]                       if (muffled) 
[09:28:25.227]                         invokeRestart("muffleMessage")
[09:28:25.227]                     }
[09:28:25.227]                     else if (inherits(cond, "warning")) {
[09:28:25.227]                       muffled <- grepl(pattern, "muffleWarning")
[09:28:25.227]                       if (muffled) 
[09:28:25.227]                         invokeRestart("muffleWarning")
[09:28:25.227]                     }
[09:28:25.227]                     else if (inherits(cond, "condition")) {
[09:28:25.227]                       if (!is.null(pattern)) {
[09:28:25.227]                         computeRestarts <- base::computeRestarts
[09:28:25.227]                         grepl <- base::grepl
[09:28:25.227]                         restarts <- computeRestarts(cond)
[09:28:25.227]                         for (restart in restarts) {
[09:28:25.227]                           name <- restart$name
[09:28:25.227]                           if (is.null(name)) 
[09:28:25.227]                             next
[09:28:25.227]                           if (!grepl(pattern, name)) 
[09:28:25.227]                             next
[09:28:25.227]                           invokeRestart(restart)
[09:28:25.227]                           muffled <- TRUE
[09:28:25.227]                           break
[09:28:25.227]                         }
[09:28:25.227]                       }
[09:28:25.227]                     }
[09:28:25.227]                     invisible(muffled)
[09:28:25.227]                   }
[09:28:25.227]                   muffleCondition(cond)
[09:28:25.227]                 })
[09:28:25.227]             }))
[09:28:25.227]             future::FutureResult(value = ...future.value$value, 
[09:28:25.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.227]                   ...future.rng), globalenv = if (FALSE) 
[09:28:25.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:28:25.227]                     ...future.globalenv.names))
[09:28:25.227]                 else NULL, started = ...future.startTime, version = "1.8")
[09:28:25.227]         }, condition = base::local({
[09:28:25.227]             c <- base::c
[09:28:25.227]             inherits <- base::inherits
[09:28:25.227]             invokeRestart <- base::invokeRestart
[09:28:25.227]             length <- base::length
[09:28:25.227]             list <- base::list
[09:28:25.227]             seq.int <- base::seq.int
[09:28:25.227]             signalCondition <- base::signalCondition
[09:28:25.227]             sys.calls <- base::sys.calls
[09:28:25.227]             `[[` <- base::`[[`
[09:28:25.227]             `+` <- base::`+`
[09:28:25.227]             `<<-` <- base::`<<-`
[09:28:25.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:28:25.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:28:25.227]                   3L)]
[09:28:25.227]             }
[09:28:25.227]             function(cond) {
[09:28:25.227]                 is_error <- inherits(cond, "error")
[09:28:25.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:28:25.227]                   NULL)
[09:28:25.227]                 if (is_error) {
[09:28:25.227]                   sessionInformation <- function() {
[09:28:25.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:28:25.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:28:25.227]                       search = base::search(), system = base::Sys.info())
[09:28:25.227]                   }
[09:28:25.227]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:28:25.227]                     cond$call), session = sessionInformation(), 
[09:28:25.227]                     timestamp = base::Sys.time(), signaled = 0L)
[09:28:25.227]                   signalCondition(cond)
[09:28:25.227]                 }
[09:28:25.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:28:25.227]                 "immediateCondition"))) {
[09:28:25.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:28:25.227]                   ...future.conditions[[length(...future.conditions) + 
[09:28:25.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:28:25.227]                   if (TRUE && !signal) {
[09:28:25.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.227]                     {
[09:28:25.227]                       inherits <- base::inherits
[09:28:25.227]                       invokeRestart <- base::invokeRestart
[09:28:25.227]                       is.null <- base::is.null
[09:28:25.227]                       muffled <- FALSE
[09:28:25.227]                       if (inherits(cond, "message")) {
[09:28:25.227]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.227]                         if (muffled) 
[09:28:25.227]                           invokeRestart("muffleMessage")
[09:28:25.227]                       }
[09:28:25.227]                       else if (inherits(cond, "warning")) {
[09:28:25.227]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.227]                         if (muffled) 
[09:28:25.227]                           invokeRestart("muffleWarning")
[09:28:25.227]                       }
[09:28:25.227]                       else if (inherits(cond, "condition")) {
[09:28:25.227]                         if (!is.null(pattern)) {
[09:28:25.227]                           computeRestarts <- base::computeRestarts
[09:28:25.227]                           grepl <- base::grepl
[09:28:25.227]                           restarts <- computeRestarts(cond)
[09:28:25.227]                           for (restart in restarts) {
[09:28:25.227]                             name <- restart$name
[09:28:25.227]                             if (is.null(name)) 
[09:28:25.227]                               next
[09:28:25.227]                             if (!grepl(pattern, name)) 
[09:28:25.227]                               next
[09:28:25.227]                             invokeRestart(restart)
[09:28:25.227]                             muffled <- TRUE
[09:28:25.227]                             break
[09:28:25.227]                           }
[09:28:25.227]                         }
[09:28:25.227]                       }
[09:28:25.227]                       invisible(muffled)
[09:28:25.227]                     }
[09:28:25.227]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.227]                   }
[09:28:25.227]                 }
[09:28:25.227]                 else {
[09:28:25.227]                   if (TRUE) {
[09:28:25.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:28:25.227]                     {
[09:28:25.227]                       inherits <- base::inherits
[09:28:25.227]                       invokeRestart <- base::invokeRestart
[09:28:25.227]                       is.null <- base::is.null
[09:28:25.227]                       muffled <- FALSE
[09:28:25.227]                       if (inherits(cond, "message")) {
[09:28:25.227]                         muffled <- grepl(pattern, "muffleMessage")
[09:28:25.227]                         if (muffled) 
[09:28:25.227]                           invokeRestart("muffleMessage")
[09:28:25.227]                       }
[09:28:25.227]                       else if (inherits(cond, "warning")) {
[09:28:25.227]                         muffled <- grepl(pattern, "muffleWarning")
[09:28:25.227]                         if (muffled) 
[09:28:25.227]                           invokeRestart("muffleWarning")
[09:28:25.227]                       }
[09:28:25.227]                       else if (inherits(cond, "condition")) {
[09:28:25.227]                         if (!is.null(pattern)) {
[09:28:25.227]                           computeRestarts <- base::computeRestarts
[09:28:25.227]                           grepl <- base::grepl
[09:28:25.227]                           restarts <- computeRestarts(cond)
[09:28:25.227]                           for (restart in restarts) {
[09:28:25.227]                             name <- restart$name
[09:28:25.227]                             if (is.null(name)) 
[09:28:25.227]                               next
[09:28:25.227]                             if (!grepl(pattern, name)) 
[09:28:25.227]                               next
[09:28:25.227]                             invokeRestart(restart)
[09:28:25.227]                             muffled <- TRUE
[09:28:25.227]                             break
[09:28:25.227]                           }
[09:28:25.227]                         }
[09:28:25.227]                       }
[09:28:25.227]                       invisible(muffled)
[09:28:25.227]                     }
[09:28:25.227]                     muffleCondition(cond, pattern = "^muffle")
[09:28:25.227]                   }
[09:28:25.227]                 }
[09:28:25.227]             }
[09:28:25.227]         }))
[09:28:25.227]     }, error = function(ex) {
[09:28:25.227]         base::structure(base::list(value = NULL, visible = NULL, 
[09:28:25.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:28:25.227]                 ...future.rng), started = ...future.startTime, 
[09:28:25.227]             finished = Sys.time(), session_uuid = NA_character_, 
[09:28:25.227]             version = "1.8"), class = "FutureResult")
[09:28:25.227]     }, finally = {
[09:28:25.227]         if (!identical(...future.workdir, getwd())) 
[09:28:25.227]             setwd(...future.workdir)
[09:28:25.227]         {
[09:28:25.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:28:25.227]                 ...future.oldOptions$nwarnings <- NULL
[09:28:25.227]             }
[09:28:25.227]             base::options(...future.oldOptions)
[09:28:25.227]             if (.Platform$OS.type == "windows") {
[09:28:25.227]                 old_names <- names(...future.oldEnvVars)
[09:28:25.227]                 envs <- base::Sys.getenv()
[09:28:25.227]                 names <- names(envs)
[09:28:25.227]                 common <- intersect(names, old_names)
[09:28:25.227]                 added <- setdiff(names, old_names)
[09:28:25.227]                 removed <- setdiff(old_names, names)
[09:28:25.227]                 changed <- common[...future.oldEnvVars[common] != 
[09:28:25.227]                   envs[common]]
[09:28:25.227]                 NAMES <- toupper(changed)
[09:28:25.227]                 args <- list()
[09:28:25.227]                 for (kk in seq_along(NAMES)) {
[09:28:25.227]                   name <- changed[[kk]]
[09:28:25.227]                   NAME <- NAMES[[kk]]
[09:28:25.227]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.227]                     next
[09:28:25.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.227]                 }
[09:28:25.227]                 NAMES <- toupper(added)
[09:28:25.227]                 for (kk in seq_along(NAMES)) {
[09:28:25.227]                   name <- added[[kk]]
[09:28:25.227]                   NAME <- NAMES[[kk]]
[09:28:25.227]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.227]                     next
[09:28:25.227]                   args[[name]] <- ""
[09:28:25.227]                 }
[09:28:25.227]                 NAMES <- toupper(removed)
[09:28:25.227]                 for (kk in seq_along(NAMES)) {
[09:28:25.227]                   name <- removed[[kk]]
[09:28:25.227]                   NAME <- NAMES[[kk]]
[09:28:25.227]                   if (name != NAME && is.element(NAME, old_names)) 
[09:28:25.227]                     next
[09:28:25.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:28:25.227]                 }
[09:28:25.227]                 if (length(args) > 0) 
[09:28:25.227]                   base::do.call(base::Sys.setenv, args = args)
[09:28:25.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:28:25.227]             }
[09:28:25.227]             else {
[09:28:25.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:28:25.227]             }
[09:28:25.227]             {
[09:28:25.227]                 if (base::length(...future.futureOptionsAdded) > 
[09:28:25.227]                   0L) {
[09:28:25.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:28:25.227]                   base::names(opts) <- ...future.futureOptionsAdded
[09:28:25.227]                   base::options(opts)
[09:28:25.227]                 }
[09:28:25.227]                 {
[09:28:25.227]                   {
[09:28:25.227]                     base::options(mc.cores = ...future.mc.cores.old)
[09:28:25.227]                     NULL
[09:28:25.227]                   }
[09:28:25.227]                   options(future.plan = NULL)
[09:28:25.227]                   if (is.na(NA_character_)) 
[09:28:25.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:28:25.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:28:25.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:28:25.227]                     .init = FALSE)
[09:28:25.227]                 }
[09:28:25.227]             }
[09:28:25.227]         }
[09:28:25.227]     })
[09:28:25.227]     if (TRUE) {
[09:28:25.227]         base::sink(type = "output", split = FALSE)
[09:28:25.227]         if (TRUE) {
[09:28:25.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:28:25.227]         }
[09:28:25.227]         else {
[09:28:25.227]             ...future.result["stdout"] <- base::list(NULL)
[09:28:25.227]         }
[09:28:25.227]         base::close(...future.stdout)
[09:28:25.227]         ...future.stdout <- NULL
[09:28:25.227]     }
[09:28:25.227]     ...future.result$conditions <- ...future.conditions
[09:28:25.227]     ...future.result$finished <- base::Sys.time()
[09:28:25.227]     ...future.result
[09:28:25.227] }
[09:28:25.230] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[09:28:25.230] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[09:28:25.230] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[09:28:25.230] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:28:25.230] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:28:25.231] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #1 ...
[09:28:25.231] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #1 ... DONE
[09:28:25.231] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:28:25.231] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:28:25.232] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:28:25.232] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:28:25.232] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[09:28:25.232] MultisessionFuture started
[09:28:25.233] - Launch lazy future ... done
[09:28:25.233] run() for ‘MultisessionFuture’ ... done
[09:28:25.233] Created future:
[09:28:25.233] MultisessionFuture:
[09:28:25.233] Label: ‘future_by-2’
[09:28:25.233] Expression:
[09:28:25.233] {
[09:28:25.233]     do.call(function(...) {
[09:28:25.233]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:28:25.233]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:28:25.233]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:28:25.233]             on.exit(options(oopts), add = TRUE)
[09:28:25.233]         }
[09:28:25.233]         {
[09:28:25.233]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:28:25.233]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:28:25.233]                 ...future.FUN(...future.X_jj, ...)
[09:28:25.233]             })
[09:28:25.233]         }
[09:28:25.233]     }, args = future.call.arguments)
[09:28:25.233] }
[09:28:25.233] Lazy evaluation: FALSE
[09:28:25.233] Asynchronous evaluation: TRUE
[09:28:25.233] Local evaluation: TRUE
[09:28:25.233] Environment: 0x555b0cde6b80
[09:28:25.233] Capture standard output: TRUE
[09:28:25.233] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:28:25.233] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:28:25.233] Packages: <none>
[09:28:25.233] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:28:25.233] Resolved: FALSE
[09:28:25.233] Value: <not collected>
[09:28:25.233] Conditions captured: <none>
[09:28:25.233] Early signaling: FALSE
[09:28:25.233] Owner process: 03961715-abd4-3bd5-2e3b-113e13bd47bf
[09:28:25.233] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:28:25.244] Chunk #2 of 2 ... DONE
[09:28:25.244] Launching 2 futures (chunks) ... DONE
[09:28:25.245] Resolving 2 futures (chunks) ...
[09:28:25.245] resolve() on list ...
[09:28:25.245]  recursive: 0
[09:28:25.245]  length: 2
[09:28:25.245] 
[09:28:25.245] Future #1
[09:28:25.245] result() for ClusterFuture ...
[09:28:25.245] - result already collected: FutureResult
[09:28:25.245] result() for ClusterFuture ... done
[09:28:25.245] result() for ClusterFuture ...
[09:28:25.245] - result already collected: FutureResult
[09:28:25.246] result() for ClusterFuture ... done
[09:28:25.246] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:28:25.246] - nx: 2
[09:28:25.246] - relay: TRUE
[09:28:25.246] - stdout: TRUE
[09:28:25.246] - signal: TRUE
[09:28:25.246] - resignal: FALSE
[09:28:25.246] - force: TRUE
[09:28:25.246] - relayed: [n=2] FALSE, FALSE
[09:28:25.246] - queued futures: [n=2] FALSE, FALSE
[09:28:25.246]  - until=1
[09:28:25.246]  - relaying element #1
[09:28:25.247] result() for ClusterFuture ...
[09:28:25.247] - result already collected: FutureResult
[09:28:25.247] result() for ClusterFuture ... done
[09:28:25.247] result() for ClusterFuture ...
[09:28:25.247] - result already collected: FutureResult
[09:28:25.247] result() for ClusterFuture ... done
[09:28:25.247] result() for ClusterFuture ...
[09:28:25.247] - result already collected: FutureResult
[09:28:25.247] result() for ClusterFuture ... done
[09:28:25.247] result() for ClusterFuture ...
[09:28:25.247] - result already collected: FutureResult
[09:28:25.247] result() for ClusterFuture ... done
[09:28:25.248] - relayed: [n=2] TRUE, FALSE
[09:28:25.248] - queued futures: [n=2] TRUE, FALSE
[09:28:25.248] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:28:25.248]  length: 1 (resolved future 1)
[09:28:25.278] receiveMessageFromWorker() for ClusterFuture ...
[09:28:25.278] - Validating connection of MultisessionFuture
[09:28:25.278] - received message: FutureResult
[09:28:25.278] - Received FutureResult
[09:28:25.278] - Erased future from FutureRegistry
[09:28:25.279] result() for ClusterFuture ...
[09:28:25.279] - result already collected: FutureResult
[09:28:25.279] result() for ClusterFuture ... done
[09:28:25.279] receiveMessageFromWorker() for ClusterFuture ... done
[09:28:25.279] Future #2
[09:28:25.279] result() for ClusterFuture ...
[09:28:25.279] - result already collected: FutureResult
[09:28:25.279] result() for ClusterFuture ... done
[09:28:25.279] result() for ClusterFuture ...
[09:28:25.279] - result already collected: FutureResult
[09:28:25.280] result() for ClusterFuture ... done
[09:28:25.280] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:28:25.280] - nx: 2
[09:28:25.280] - relay: TRUE
[09:28:25.280] - stdout: TRUE
[09:28:25.280] - signal: TRUE
[09:28:25.280] - resignal: FALSE
[09:28:25.280] - force: TRUE
[09:28:25.280] - relayed: [n=2] TRUE, FALSE
[09:28:25.280] - queued futures: [n=2] TRUE, FALSE
[09:28:25.280]  - until=2
[09:28:25.281]  - relaying element #2
[09:28:25.281] result() for ClusterFuture ...
[09:28:25.281] - result already collected: FutureResult
[09:28:25.281] result() for ClusterFuture ... done
[09:28:25.281] result() for ClusterFuture ...
[09:28:25.281] - result already collected: FutureResult
[09:28:25.281] result() for ClusterFuture ... done
[09:28:25.281] result() for ClusterFuture ...
[09:28:25.281] - result already collected: FutureResult
[09:28:25.281] result() for ClusterFuture ... done
[09:28:25.281] result() for ClusterFuture ...
[09:28:25.281] - result already collected: FutureResult
[09:28:25.282] result() for ClusterFuture ... done
[09:28:25.282] - relayed: [n=2] TRUE, TRUE
[09:28:25.282] - queued futures: [n=2] TRUE, TRUE
[09:28:25.282] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:28:25.282]  length: 0 (resolved future 2)
[09:28:25.282] Relaying remaining futures
[09:28:25.282] signalConditionsASAP(NULL, pos=0) ...
[09:28:25.282] - nx: 2
[09:28:25.282] - relay: TRUE
[09:28:25.282] - stdout: TRUE
[09:28:25.282] - signal: TRUE
[09:28:25.282] - resignal: FALSE
[09:28:25.283] - force: TRUE
[09:28:25.283] - relayed: [n=2] TRUE, TRUE
[09:28:25.283] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:28:25.283] - relayed: [n=2] TRUE, TRUE
[09:28:25.283] - queued futures: [n=2] TRUE, TRUE
[09:28:25.283] signalConditionsASAP(NULL, pos=0) ... done
[09:28:25.283] resolve() on list ... DONE
[09:28:25.283] result() for ClusterFuture ...
[09:28:25.283] - result already collected: FutureResult
[09:28:25.283] result() for ClusterFuture ... done
[09:28:25.283] result() for ClusterFuture ...
[09:28:25.284] - result already collected: FutureResult
[09:28:25.284] result() for ClusterFuture ... done
[09:28:25.284] result() for ClusterFuture ...
[09:28:25.284] - result already collected: FutureResult
[09:28:25.284] result() for ClusterFuture ... done
[09:28:25.284] result() for ClusterFuture ...
[09:28:25.284] - result already collected: FutureResult
[09:28:25.284] result() for ClusterFuture ... done
[09:28:25.284]  - Number of value chunks collected: 2
[09:28:25.284] Resolving 2 futures (chunks) ... DONE
[09:28:25.284] Reducing values from 2 chunks ...
[09:28:25.285]  - Number of values collected after concatenation: 3
[09:28:25.285]  - Number of values expected: 3
[09:28:25.285] Reducing values from 2 chunks ... DONE
[09:28:25.285] future_lapply() ... DONE
[09:28:25.285] future_by_internal() ... DONE
[09:28:25.286] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[09:28:25.287] plan(): Setting new future strategy stack:
[09:28:25.287] List of future strategies:
[09:28:25.287] 1. FutureStrategy:
[09:28:25.287]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:28:25.287]    - tweaked: FALSE
[09:28:25.287]    - call: future::plan(oplan)
[09:28:25.287] plan(): nbrOfWorkers() = 1
> 
