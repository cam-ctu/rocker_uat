
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[09:29:45.411] plan(): Setting new future strategy stack:
[09:29:45.412] List of future strategies:
[09:29:45.412] 1. sequential:
[09:29:45.412]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.412]    - tweaked: FALSE
[09:29:45.412]    - call: future::plan("sequential")
[09:29:45.425] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[09:29:45.529] plan(): Setting new future strategy stack:
[09:29:45.529] List of future strategies:
[09:29:45.529] 1. sequential:
[09:29:45.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.529]    - tweaked: FALSE
[09:29:45.529]    - call: plan(strategy)
[09:29:45.540] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[09:29:45.547] future_lapply() ...
[09:29:45.553] Number of chunks: 1
[09:29:45.553] getGlobalsAndPackagesXApply() ...
[09:29:45.553]  - future.globals: TRUE
[09:29:45.554] getGlobalsAndPackages() ...
[09:29:45.554] Searching for globals...
[09:29:45.558] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:45.558] Searching for globals ... DONE
[09:29:45.558] Resolving globals: FALSE
[09:29:45.559] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[09:29:45.560] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:45.560] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.560] - packages: [1] ‘future.apply’
[09:29:45.560] getGlobalsAndPackages() ... DONE
[09:29:45.560]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.560]  - needed namespaces: [n=1] ‘future.apply’
[09:29:45.561] Finding globals ... DONE
[09:29:45.561]  - use_args: TRUE
[09:29:45.561]  - Getting '...' globals ...
[09:29:45.561] resolve() on list ...
[09:29:45.562]  recursive: 0
[09:29:45.562]  length: 1
[09:29:45.562]  elements: ‘...’
[09:29:45.562]  length: 0 (resolved future 1)
[09:29:45.562] resolve() on list ... DONE
[09:29:45.562]    - '...' content: [n=0] 
[09:29:45.562] List of 1
[09:29:45.562]  $ ...: list()
[09:29:45.562]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.562]  - attr(*, "where")=List of 1
[09:29:45.562]   ..$ ...:<environment: 0x561d35a10280> 
[09:29:45.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.562]  - attr(*, "resolved")= logi TRUE
[09:29:45.562]  - attr(*, "total_size")= num NA
[09:29:45.565]  - Getting '...' globals ... DONE
[09:29:45.565] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:45.565] List of 8
[09:29:45.565]  $ ...future.FUN:function (x, ...)  
[09:29:45.565]  $ x_FUN        :function (x)  
[09:29:45.565]  $ times        : int 1
[09:29:45.565]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.565]  $ stop_if_not  :function (...)  
[09:29:45.565]  $ dim          : NULL
[09:29:45.565]  $ valid_types  : chr "character"
[09:29:45.565]  $ ...          : list()
[09:29:45.565]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.565]  - attr(*, "where")=List of 8
[09:29:45.565]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:45.565]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:45.565]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:45.565]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:45.565]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:45.565]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:45.565]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:45.565]   ..$ ...          :<environment: 0x561d35a10280> 
[09:29:45.565]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.565]  - attr(*, "resolved")= logi FALSE
[09:29:45.565]  - attr(*, "total_size")= num 94208
[09:29:45.570] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:45.570] getGlobalsAndPackagesXApply() ... DONE
[09:29:45.571] Number of futures (= number of chunks): 1
[09:29:45.571] Launching 1 futures (chunks) ...
[09:29:45.571] Chunk #1 of 1 ...
[09:29:45.571]  - Finding globals in 'X' for chunk #1 ...
[09:29:45.571] getGlobalsAndPackages() ...
[09:29:45.571] Searching for globals...
[09:29:45.572] 
[09:29:45.572] Searching for globals ... DONE
[09:29:45.572] - globals: [0] <none>
[09:29:45.572] getGlobalsAndPackages() ... DONE
[09:29:45.572]    + additional globals found: [n=0] 
[09:29:45.572]    + additional namespaces needed: [n=0] 
[09:29:45.572]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:45.572]  - seeds: <none>
[09:29:45.572]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.572] getGlobalsAndPackages() ...
[09:29:45.573] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.573] Resolving globals: FALSE
[09:29:45.573] Tweak future expression to call with '...' arguments ...
[09:29:45.573] {
[09:29:45.573]     do.call(function(...) {
[09:29:45.573]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.573]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.573]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.573]             on.exit(options(oopts), add = TRUE)
[09:29:45.573]         }
[09:29:45.573]         {
[09:29:45.573]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.573]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.573]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.573]             })
[09:29:45.573]         }
[09:29:45.573]     }, args = future.call.arguments)
[09:29:45.573] }
[09:29:45.573] Tweak future expression to call with '...' arguments ... DONE
[09:29:45.574] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.574] - packages: [1] ‘future.apply’
[09:29:45.574] getGlobalsAndPackages() ... DONE
[09:29:45.575] run() for ‘Future’ ...
[09:29:45.575] - state: ‘created’
[09:29:45.575] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:45.575] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.575] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:45.575]   - Field: ‘label’
[09:29:45.575]   - Field: ‘local’
[09:29:45.576]   - Field: ‘owner’
[09:29:45.576]   - Field: ‘envir’
[09:29:45.576]   - Field: ‘packages’
[09:29:45.576]   - Field: ‘gc’
[09:29:45.576]   - Field: ‘conditions’
[09:29:45.576]   - Field: ‘expr’
[09:29:45.576]   - Field: ‘uuid’
[09:29:45.576]   - Field: ‘seed’
[09:29:45.576]   - Field: ‘version’
[09:29:45.576]   - Field: ‘result’
[09:29:45.576]   - Field: ‘asynchronous’
[09:29:45.577]   - Field: ‘calls’
[09:29:45.577]   - Field: ‘globals’
[09:29:45.577]   - Field: ‘stdout’
[09:29:45.577]   - Field: ‘earlySignal’
[09:29:45.577]   - Field: ‘lazy’
[09:29:45.577]   - Field: ‘state’
[09:29:45.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:45.577] - Launch lazy future ...
[09:29:45.578] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:45.580] Packages needed by future strategies (n = 0): <none>
[09:29:45.581] {
[09:29:45.581]     {
[09:29:45.581]         {
[09:29:45.581]             ...future.startTime <- base::Sys.time()
[09:29:45.581]             {
[09:29:45.581]                 {
[09:29:45.581]                   {
[09:29:45.581]                     {
[09:29:45.581]                       base::local({
[09:29:45.581]                         has_future <- base::requireNamespace("future", 
[09:29:45.581]                           quietly = TRUE)
[09:29:45.581]                         if (has_future) {
[09:29:45.581]                           ns <- base::getNamespace("future")
[09:29:45.581]                           version <- ns[[".package"]][["version"]]
[09:29:45.581]                           if (is.null(version)) 
[09:29:45.581]                             version <- utils::packageVersion("future")
[09:29:45.581]                         }
[09:29:45.581]                         else {
[09:29:45.581]                           version <- NULL
[09:29:45.581]                         }
[09:29:45.581]                         if (!has_future || version < "1.8.0") {
[09:29:45.581]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:45.581]                             "", base::R.version$version.string), 
[09:29:45.581]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:45.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:45.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:45.581]                               "release", "version")], collapse = " "), 
[09:29:45.581]                             hostname = base::Sys.info()[["nodename"]])
[09:29:45.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:45.581]                             info)
[09:29:45.581]                           info <- base::paste(info, collapse = "; ")
[09:29:45.581]                           if (!has_future) {
[09:29:45.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:45.581]                               info)
[09:29:45.581]                           }
[09:29:45.581]                           else {
[09:29:45.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:45.581]                               info, version)
[09:29:45.581]                           }
[09:29:45.581]                           base::stop(msg)
[09:29:45.581]                         }
[09:29:45.581]                       })
[09:29:45.581]                     }
[09:29:45.581]                     base::local({
[09:29:45.581]                       for (pkg in "future.apply") {
[09:29:45.581]                         base::loadNamespace(pkg)
[09:29:45.581]                         base::library(pkg, character.only = TRUE)
[09:29:45.581]                       }
[09:29:45.581]                     })
[09:29:45.581]                   }
[09:29:45.581]                   ...future.strategy.old <- future::plan("list")
[09:29:45.581]                   options(future.plan = NULL)
[09:29:45.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:45.581]                 }
[09:29:45.581]                 ...future.workdir <- getwd()
[09:29:45.581]             }
[09:29:45.581]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:45.581]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:45.581]         }
[09:29:45.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:45.581]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:45.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:45.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:45.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:45.581]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:45.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:45.581]             base::names(...future.oldOptions))
[09:29:45.581]     }
[09:29:45.581]     if (FALSE) {
[09:29:45.581]     }
[09:29:45.581]     else {
[09:29:45.581]         if (TRUE) {
[09:29:45.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:45.581]                 open = "w")
[09:29:45.581]         }
[09:29:45.581]         else {
[09:29:45.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:45.581]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:45.581]         }
[09:29:45.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:45.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:45.581]             base::sink(type = "output", split = FALSE)
[09:29:45.581]             base::close(...future.stdout)
[09:29:45.581]         }, add = TRUE)
[09:29:45.581]     }
[09:29:45.581]     ...future.frame <- base::sys.nframe()
[09:29:45.581]     ...future.conditions <- base::list()
[09:29:45.581]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:45.581]     if (FALSE) {
[09:29:45.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:45.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:45.581]     }
[09:29:45.581]     ...future.result <- base::tryCatch({
[09:29:45.581]         base::withCallingHandlers({
[09:29:45.581]             ...future.value <- base::withVisible(base::local({
[09:29:45.581]                 do.call(function(...) {
[09:29:45.581]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.581]                   if (!identical(...future.globals.maxSize.org, 
[09:29:45.581]                     ...future.globals.maxSize)) {
[09:29:45.581]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.581]                     on.exit(options(oopts), add = TRUE)
[09:29:45.581]                   }
[09:29:45.581]                   {
[09:29:45.581]                     lapply(seq_along(...future.elements_ii), 
[09:29:45.581]                       FUN = function(jj) {
[09:29:45.581]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.581]                         ...future.FUN(...future.X_jj, ...)
[09:29:45.581]                       })
[09:29:45.581]                   }
[09:29:45.581]                 }, args = future.call.arguments)
[09:29:45.581]             }))
[09:29:45.581]             future::FutureResult(value = ...future.value$value, 
[09:29:45.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.581]                   ...future.rng), globalenv = if (FALSE) 
[09:29:45.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:45.581]                     ...future.globalenv.names))
[09:29:45.581]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:45.581]         }, condition = base::local({
[09:29:45.581]             c <- base::c
[09:29:45.581]             inherits <- base::inherits
[09:29:45.581]             invokeRestart <- base::invokeRestart
[09:29:45.581]             length <- base::length
[09:29:45.581]             list <- base::list
[09:29:45.581]             seq.int <- base::seq.int
[09:29:45.581]             signalCondition <- base::signalCondition
[09:29:45.581]             sys.calls <- base::sys.calls
[09:29:45.581]             `[[` <- base::`[[`
[09:29:45.581]             `+` <- base::`+`
[09:29:45.581]             `<<-` <- base::`<<-`
[09:29:45.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:45.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:45.581]                   3L)]
[09:29:45.581]             }
[09:29:45.581]             function(cond) {
[09:29:45.581]                 is_error <- inherits(cond, "error")
[09:29:45.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:45.581]                   NULL)
[09:29:45.581]                 if (is_error) {
[09:29:45.581]                   sessionInformation <- function() {
[09:29:45.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:45.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:45.581]                       search = base::search(), system = base::Sys.info())
[09:29:45.581]                   }
[09:29:45.581]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:45.581]                     cond$call), session = sessionInformation(), 
[09:29:45.581]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:45.581]                   signalCondition(cond)
[09:29:45.581]                 }
[09:29:45.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:45.581]                 "immediateCondition"))) {
[09:29:45.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:45.581]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:45.581]                   if (TRUE && !signal) {
[09:29:45.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.581]                     {
[09:29:45.581]                       inherits <- base::inherits
[09:29:45.581]                       invokeRestart <- base::invokeRestart
[09:29:45.581]                       is.null <- base::is.null
[09:29:45.581]                       muffled <- FALSE
[09:29:45.581]                       if (inherits(cond, "message")) {
[09:29:45.581]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.581]                         if (muffled) 
[09:29:45.581]                           invokeRestart("muffleMessage")
[09:29:45.581]                       }
[09:29:45.581]                       else if (inherits(cond, "warning")) {
[09:29:45.581]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.581]                         if (muffled) 
[09:29:45.581]                           invokeRestart("muffleWarning")
[09:29:45.581]                       }
[09:29:45.581]                       else if (inherits(cond, "condition")) {
[09:29:45.581]                         if (!is.null(pattern)) {
[09:29:45.581]                           computeRestarts <- base::computeRestarts
[09:29:45.581]                           grepl <- base::grepl
[09:29:45.581]                           restarts <- computeRestarts(cond)
[09:29:45.581]                           for (restart in restarts) {
[09:29:45.581]                             name <- restart$name
[09:29:45.581]                             if (is.null(name)) 
[09:29:45.581]                               next
[09:29:45.581]                             if (!grepl(pattern, name)) 
[09:29:45.581]                               next
[09:29:45.581]                             invokeRestart(restart)
[09:29:45.581]                             muffled <- TRUE
[09:29:45.581]                             break
[09:29:45.581]                           }
[09:29:45.581]                         }
[09:29:45.581]                       }
[09:29:45.581]                       invisible(muffled)
[09:29:45.581]                     }
[09:29:45.581]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.581]                   }
[09:29:45.581]                 }
[09:29:45.581]                 else {
[09:29:45.581]                   if (TRUE) {
[09:29:45.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.581]                     {
[09:29:45.581]                       inherits <- base::inherits
[09:29:45.581]                       invokeRestart <- base::invokeRestart
[09:29:45.581]                       is.null <- base::is.null
[09:29:45.581]                       muffled <- FALSE
[09:29:45.581]                       if (inherits(cond, "message")) {
[09:29:45.581]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.581]                         if (muffled) 
[09:29:45.581]                           invokeRestart("muffleMessage")
[09:29:45.581]                       }
[09:29:45.581]                       else if (inherits(cond, "warning")) {
[09:29:45.581]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.581]                         if (muffled) 
[09:29:45.581]                           invokeRestart("muffleWarning")
[09:29:45.581]                       }
[09:29:45.581]                       else if (inherits(cond, "condition")) {
[09:29:45.581]                         if (!is.null(pattern)) {
[09:29:45.581]                           computeRestarts <- base::computeRestarts
[09:29:45.581]                           grepl <- base::grepl
[09:29:45.581]                           restarts <- computeRestarts(cond)
[09:29:45.581]                           for (restart in restarts) {
[09:29:45.581]                             name <- restart$name
[09:29:45.581]                             if (is.null(name)) 
[09:29:45.581]                               next
[09:29:45.581]                             if (!grepl(pattern, name)) 
[09:29:45.581]                               next
[09:29:45.581]                             invokeRestart(restart)
[09:29:45.581]                             muffled <- TRUE
[09:29:45.581]                             break
[09:29:45.581]                           }
[09:29:45.581]                         }
[09:29:45.581]                       }
[09:29:45.581]                       invisible(muffled)
[09:29:45.581]                     }
[09:29:45.581]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.581]                   }
[09:29:45.581]                 }
[09:29:45.581]             }
[09:29:45.581]         }))
[09:29:45.581]     }, error = function(ex) {
[09:29:45.581]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:45.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.581]                 ...future.rng), started = ...future.startTime, 
[09:29:45.581]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:45.581]             version = "1.8"), class = "FutureResult")
[09:29:45.581]     }, finally = {
[09:29:45.581]         if (!identical(...future.workdir, getwd())) 
[09:29:45.581]             setwd(...future.workdir)
[09:29:45.581]         {
[09:29:45.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:45.581]                 ...future.oldOptions$nwarnings <- NULL
[09:29:45.581]             }
[09:29:45.581]             base::options(...future.oldOptions)
[09:29:45.581]             if (.Platform$OS.type == "windows") {
[09:29:45.581]                 old_names <- names(...future.oldEnvVars)
[09:29:45.581]                 envs <- base::Sys.getenv()
[09:29:45.581]                 names <- names(envs)
[09:29:45.581]                 common <- intersect(names, old_names)
[09:29:45.581]                 added <- setdiff(names, old_names)
[09:29:45.581]                 removed <- setdiff(old_names, names)
[09:29:45.581]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:45.581]                   envs[common]]
[09:29:45.581]                 NAMES <- toupper(changed)
[09:29:45.581]                 args <- list()
[09:29:45.581]                 for (kk in seq_along(NAMES)) {
[09:29:45.581]                   name <- changed[[kk]]
[09:29:45.581]                   NAME <- NAMES[[kk]]
[09:29:45.581]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.581]                     next
[09:29:45.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.581]                 }
[09:29:45.581]                 NAMES <- toupper(added)
[09:29:45.581]                 for (kk in seq_along(NAMES)) {
[09:29:45.581]                   name <- added[[kk]]
[09:29:45.581]                   NAME <- NAMES[[kk]]
[09:29:45.581]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.581]                     next
[09:29:45.581]                   args[[name]] <- ""
[09:29:45.581]                 }
[09:29:45.581]                 NAMES <- toupper(removed)
[09:29:45.581]                 for (kk in seq_along(NAMES)) {
[09:29:45.581]                   name <- removed[[kk]]
[09:29:45.581]                   NAME <- NAMES[[kk]]
[09:29:45.581]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.581]                     next
[09:29:45.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.581]                 }
[09:29:45.581]                 if (length(args) > 0) 
[09:29:45.581]                   base::do.call(base::Sys.setenv, args = args)
[09:29:45.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:45.581]             }
[09:29:45.581]             else {
[09:29:45.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:45.581]             }
[09:29:45.581]             {
[09:29:45.581]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:45.581]                   0L) {
[09:29:45.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:45.581]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:45.581]                   base::options(opts)
[09:29:45.581]                 }
[09:29:45.581]                 {
[09:29:45.581]                   {
[09:29:45.581]                     NULL
[09:29:45.581]                     RNGkind("Mersenne-Twister")
[09:29:45.581]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:45.581]                       inherits = FALSE)
[09:29:45.581]                   }
[09:29:45.581]                   options(future.plan = NULL)
[09:29:45.581]                   if (is.na(NA_character_)) 
[09:29:45.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:45.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:45.581]                     .init = FALSE)
[09:29:45.581]                 }
[09:29:45.581]             }
[09:29:45.581]         }
[09:29:45.581]     })
[09:29:45.581]     if (TRUE) {
[09:29:45.581]         base::sink(type = "output", split = FALSE)
[09:29:45.581]         if (TRUE) {
[09:29:45.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:45.581]         }
[09:29:45.581]         else {
[09:29:45.581]             ...future.result["stdout"] <- base::list(NULL)
[09:29:45.581]         }
[09:29:45.581]         base::close(...future.stdout)
[09:29:45.581]         ...future.stdout <- NULL
[09:29:45.581]     }
[09:29:45.581]     ...future.result$conditions <- ...future.conditions
[09:29:45.581]     ...future.result$finished <- base::Sys.time()
[09:29:45.581]     ...future.result
[09:29:45.581] }
[09:29:45.583] assign_globals() ...
[09:29:45.583] List of 11
[09:29:45.583]  $ ...future.FUN            :function (x, ...)  
[09:29:45.583]  $ x_FUN                    :function (x)  
[09:29:45.583]  $ times                    : int 1
[09:29:45.583]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.583]  $ stop_if_not              :function (...)  
[09:29:45.583]  $ dim                      : NULL
[09:29:45.583]  $ valid_types              : chr "character"
[09:29:45.583]  $ future.call.arguments    : list()
[09:29:45.583]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.583]  $ ...future.elements_ii    :List of 2
[09:29:45.583]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:29:45.583]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[09:29:45.583]  $ ...future.seeds_ii       : NULL
[09:29:45.583]  $ ...future.globals.maxSize: NULL
[09:29:45.583]  - attr(*, "where")=List of 11
[09:29:45.583]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:45.583]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:45.583]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:45.583]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:45.583]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:45.583]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:45.583]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:45.583]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:45.583]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:45.583]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:45.583]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:45.583]  - attr(*, "resolved")= logi FALSE
[09:29:45.583]  - attr(*, "total_size")= num 94208
[09:29:45.583]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.583]  - attr(*, "already-done")= logi TRUE
[09:29:45.590] - copied ‘...future.FUN’ to environment
[09:29:45.590] - copied ‘x_FUN’ to environment
[09:29:45.590] - copied ‘times’ to environment
[09:29:45.590] - copied ‘stopf’ to environment
[09:29:45.590] - copied ‘stop_if_not’ to environment
[09:29:45.590] - copied ‘dim’ to environment
[09:29:45.590] - copied ‘valid_types’ to environment
[09:29:45.591] - copied ‘future.call.arguments’ to environment
[09:29:45.591] - copied ‘...future.elements_ii’ to environment
[09:29:45.591] - copied ‘...future.seeds_ii’ to environment
[09:29:45.591] - copied ‘...future.globals.maxSize’ to environment
[09:29:45.591] assign_globals() ... done
[09:29:45.591] plan(): Setting new future strategy stack:
[09:29:45.591] List of future strategies:
[09:29:45.591] 1. sequential:
[09:29:45.591]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.591]    - tweaked: FALSE
[09:29:45.591]    - call: NULL
[09:29:45.592] plan(): nbrOfWorkers() = 1
[09:29:45.593] plan(): Setting new future strategy stack:
[09:29:45.593] List of future strategies:
[09:29:45.593] 1. sequential:
[09:29:45.593]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.593]    - tweaked: FALSE
[09:29:45.593]    - call: plan(strategy)
[09:29:45.593] plan(): nbrOfWorkers() = 1
[09:29:45.594] SequentialFuture started (and completed)
[09:29:45.594] - Launch lazy future ... done
[09:29:45.594] run() for ‘SequentialFuture’ ... done
[09:29:45.594] Created future:
[09:29:45.594] SequentialFuture:
[09:29:45.594] Label: ‘future_vapply-1’
[09:29:45.594] Expression:
[09:29:45.594] {
[09:29:45.594]     do.call(function(...) {
[09:29:45.594]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.594]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.594]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.594]             on.exit(options(oopts), add = TRUE)
[09:29:45.594]         }
[09:29:45.594]         {
[09:29:45.594]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.594]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.594]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.594]             })
[09:29:45.594]         }
[09:29:45.594]     }, args = future.call.arguments)
[09:29:45.594] }
[09:29:45.594] Lazy evaluation: FALSE
[09:29:45.594] Asynchronous evaluation: FALSE
[09:29:45.594] Local evaluation: TRUE
[09:29:45.594] Environment: R_GlobalEnv
[09:29:45.594] Capture standard output: TRUE
[09:29:45.594] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:45.594] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:45.594] Packages: 1 packages (‘future.apply’)
[09:29:45.594] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:45.594] Resolved: TRUE
[09:29:45.594] Value: 232 bytes of class ‘list’
[09:29:45.594] Early signaling: FALSE
[09:29:45.594] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:45.594] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.596] Chunk #1 of 1 ... DONE
[09:29:45.596] Launching 1 futures (chunks) ... DONE
[09:29:45.596] Resolving 1 futures (chunks) ...
[09:29:45.596] resolve() on list ...
[09:29:45.596]  recursive: 0
[09:29:45.596]  length: 1
[09:29:45.596] 
[09:29:45.597] resolved() for ‘SequentialFuture’ ...
[09:29:45.597] - state: ‘finished’
[09:29:45.597] - run: TRUE
[09:29:45.597] - result: ‘FutureResult’
[09:29:45.597] resolved() for ‘SequentialFuture’ ... done
[09:29:45.597] Future #1
[09:29:45.597] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:45.598] - nx: 1
[09:29:45.598] - relay: TRUE
[09:29:45.598] - stdout: TRUE
[09:29:45.598] - signal: TRUE
[09:29:45.598] - resignal: FALSE
[09:29:45.598] - force: TRUE
[09:29:45.598] - relayed: [n=1] FALSE
[09:29:45.598] - queued futures: [n=1] FALSE
[09:29:45.598]  - until=1
[09:29:45.598]  - relaying element #1
[09:29:45.598] - relayed: [n=1] TRUE
[09:29:45.599] - queued futures: [n=1] TRUE
[09:29:45.599] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:45.599]  length: 0 (resolved future 1)
[09:29:45.599] Relaying remaining futures
[09:29:45.599] signalConditionsASAP(NULL, pos=0) ...
[09:29:45.599] - nx: 1
[09:29:45.599] - relay: TRUE
[09:29:45.599] - stdout: TRUE
[09:29:45.599] - signal: TRUE
[09:29:45.599] - resignal: FALSE
[09:29:45.599] - force: TRUE
[09:29:45.600] - relayed: [n=1] TRUE
[09:29:45.600] - queued futures: [n=1] TRUE
 - flush all
[09:29:45.600] - relayed: [n=1] TRUE
[09:29:45.600] - queued futures: [n=1] TRUE
[09:29:45.600] signalConditionsASAP(NULL, pos=0) ... done
[09:29:45.600] resolve() on list ... DONE
[09:29:45.600]  - Number of value chunks collected: 1
[09:29:45.600] Resolving 1 futures (chunks) ... DONE
[09:29:45.600] Reducing values from 1 chunks ...
[09:29:45.600]  - Number of values collected after concatenation: 2
[09:29:45.600]  - Number of values expected: 2
[09:29:45.601] Reducing values from 1 chunks ... DONE
[09:29:45.601] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[09:29:45.602] future_lapply() ...
[09:29:45.603] Number of chunks: 1
[09:29:45.603] getGlobalsAndPackagesXApply() ...
[09:29:45.603]  - future.globals: TRUE
[09:29:45.604] getGlobalsAndPackages() ...
[09:29:45.604] Searching for globals...
[09:29:45.608] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[09:29:45.608] Searching for globals ... DONE
[09:29:45.608] Resolving globals: FALSE
[09:29:45.609] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[09:29:45.609] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:45.610] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.610] - packages: [1] ‘future.apply’
[09:29:45.610] getGlobalsAndPackages() ... DONE
[09:29:45.610]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.610]  - needed namespaces: [n=1] ‘future.apply’
[09:29:45.610] Finding globals ... DONE
[09:29:45.610]  - use_args: TRUE
[09:29:45.610]  - Getting '...' globals ...
[09:29:45.611] resolve() on list ...
[09:29:45.611]  recursive: 0
[09:29:45.611]  length: 1
[09:29:45.611]  elements: ‘...’
[09:29:45.611]  length: 0 (resolved future 1)
[09:29:45.611] resolve() on list ... DONE
[09:29:45.611]    - '...' content: [n=0] 
[09:29:45.611] List of 1
[09:29:45.611]  $ ...: list()
[09:29:45.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.611]  - attr(*, "where")=List of 1
[09:29:45.611]   ..$ ...:<environment: 0x561d3682f618> 
[09:29:45.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.611]  - attr(*, "resolved")= logi TRUE
[09:29:45.611]  - attr(*, "total_size")= num NA
[09:29:45.613]  - Getting '...' globals ... DONE
[09:29:45.614] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:45.614] List of 8
[09:29:45.614]  $ ...future.FUN:function (x, ...)  
[09:29:45.614]  $ x_FUN        :function (x)  
[09:29:45.614]  $ times        : int 0
[09:29:45.614]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.614]  $ stop_if_not  :function (...)  
[09:29:45.614]  $ dim          : NULL
[09:29:45.614]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:45.614]  $ ...          : list()
[09:29:45.614]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.614]  - attr(*, "where")=List of 8
[09:29:45.614]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:45.614]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:45.614]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:45.614]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:45.614]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:45.614]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:45.614]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:45.614]   ..$ ...          :<environment: 0x561d3682f618> 
[09:29:45.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.614]  - attr(*, "resolved")= logi FALSE
[09:29:45.614]  - attr(*, "total_size")= num 95472
[09:29:45.619] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:45.619] getGlobalsAndPackagesXApply() ... DONE
[09:29:45.619] Number of futures (= number of chunks): 1
[09:29:45.619] Launching 1 futures (chunks) ...
[09:29:45.619] Chunk #1 of 1 ...
[09:29:45.619]  - Finding globals in 'X' for chunk #1 ...
[09:29:45.619] getGlobalsAndPackages() ...
[09:29:45.619] Searching for globals...
[09:29:45.620] 
[09:29:45.620] Searching for globals ... DONE
[09:29:45.620] - globals: [0] <none>
[09:29:45.620] getGlobalsAndPackages() ... DONE
[09:29:45.620]    + additional globals found: [n=0] 
[09:29:45.620]    + additional namespaces needed: [n=0] 
[09:29:45.620]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:45.620]  - seeds: <none>
[09:29:45.620]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.620] getGlobalsAndPackages() ...
[09:29:45.621] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.621] Resolving globals: FALSE
[09:29:45.621] Tweak future expression to call with '...' arguments ...
[09:29:45.621] {
[09:29:45.621]     do.call(function(...) {
[09:29:45.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.621]             on.exit(options(oopts), add = TRUE)
[09:29:45.621]         }
[09:29:45.621]         {
[09:29:45.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.621]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.621]             })
[09:29:45.621]         }
[09:29:45.621]     }, args = future.call.arguments)
[09:29:45.621] }
[09:29:45.621] Tweak future expression to call with '...' arguments ... DONE
[09:29:45.622] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.622] - packages: [1] ‘future.apply’
[09:29:45.622] getGlobalsAndPackages() ... DONE
[09:29:45.622] run() for ‘Future’ ...
[09:29:45.622] - state: ‘created’
[09:29:45.622] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:45.622] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.623] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:45.623]   - Field: ‘label’
[09:29:45.623]   - Field: ‘local’
[09:29:45.623]   - Field: ‘owner’
[09:29:45.623]   - Field: ‘envir’
[09:29:45.623]   - Field: ‘packages’
[09:29:45.623]   - Field: ‘gc’
[09:29:45.623]   - Field: ‘conditions’
[09:29:45.623]   - Field: ‘expr’
[09:29:45.623]   - Field: ‘uuid’
[09:29:45.623]   - Field: ‘seed’
[09:29:45.624]   - Field: ‘version’
[09:29:45.624]   - Field: ‘result’
[09:29:45.624]   - Field: ‘asynchronous’
[09:29:45.624]   - Field: ‘calls’
[09:29:45.624]   - Field: ‘globals’
[09:29:45.624]   - Field: ‘stdout’
[09:29:45.624]   - Field: ‘earlySignal’
[09:29:45.624]   - Field: ‘lazy’
[09:29:45.624]   - Field: ‘state’
[09:29:45.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:45.624] - Launch lazy future ...
[09:29:45.625] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:45.625] Packages needed by future strategies (n = 0): <none>
[09:29:45.625] {
[09:29:45.625]     {
[09:29:45.625]         {
[09:29:45.625]             ...future.startTime <- base::Sys.time()
[09:29:45.625]             {
[09:29:45.625]                 {
[09:29:45.625]                   {
[09:29:45.625]                     {
[09:29:45.625]                       base::local({
[09:29:45.625]                         has_future <- base::requireNamespace("future", 
[09:29:45.625]                           quietly = TRUE)
[09:29:45.625]                         if (has_future) {
[09:29:45.625]                           ns <- base::getNamespace("future")
[09:29:45.625]                           version <- ns[[".package"]][["version"]]
[09:29:45.625]                           if (is.null(version)) 
[09:29:45.625]                             version <- utils::packageVersion("future")
[09:29:45.625]                         }
[09:29:45.625]                         else {
[09:29:45.625]                           version <- NULL
[09:29:45.625]                         }
[09:29:45.625]                         if (!has_future || version < "1.8.0") {
[09:29:45.625]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:45.625]                             "", base::R.version$version.string), 
[09:29:45.625]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:45.625]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:45.625]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:45.625]                               "release", "version")], collapse = " "), 
[09:29:45.625]                             hostname = base::Sys.info()[["nodename"]])
[09:29:45.625]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:45.625]                             info)
[09:29:45.625]                           info <- base::paste(info, collapse = "; ")
[09:29:45.625]                           if (!has_future) {
[09:29:45.625]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:45.625]                               info)
[09:29:45.625]                           }
[09:29:45.625]                           else {
[09:29:45.625]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:45.625]                               info, version)
[09:29:45.625]                           }
[09:29:45.625]                           base::stop(msg)
[09:29:45.625]                         }
[09:29:45.625]                       })
[09:29:45.625]                     }
[09:29:45.625]                     base::local({
[09:29:45.625]                       for (pkg in "future.apply") {
[09:29:45.625]                         base::loadNamespace(pkg)
[09:29:45.625]                         base::library(pkg, character.only = TRUE)
[09:29:45.625]                       }
[09:29:45.625]                     })
[09:29:45.625]                   }
[09:29:45.625]                   ...future.strategy.old <- future::plan("list")
[09:29:45.625]                   options(future.plan = NULL)
[09:29:45.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:45.625]                 }
[09:29:45.625]                 ...future.workdir <- getwd()
[09:29:45.625]             }
[09:29:45.625]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:45.625]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:45.625]         }
[09:29:45.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:45.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:45.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:45.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:45.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:45.625]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:45.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:45.625]             base::names(...future.oldOptions))
[09:29:45.625]     }
[09:29:45.625]     if (FALSE) {
[09:29:45.625]     }
[09:29:45.625]     else {
[09:29:45.625]         if (TRUE) {
[09:29:45.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:45.625]                 open = "w")
[09:29:45.625]         }
[09:29:45.625]         else {
[09:29:45.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:45.625]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:45.625]         }
[09:29:45.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:45.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:45.625]             base::sink(type = "output", split = FALSE)
[09:29:45.625]             base::close(...future.stdout)
[09:29:45.625]         }, add = TRUE)
[09:29:45.625]     }
[09:29:45.625]     ...future.frame <- base::sys.nframe()
[09:29:45.625]     ...future.conditions <- base::list()
[09:29:45.625]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:45.625]     if (FALSE) {
[09:29:45.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:45.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:45.625]     }
[09:29:45.625]     ...future.result <- base::tryCatch({
[09:29:45.625]         base::withCallingHandlers({
[09:29:45.625]             ...future.value <- base::withVisible(base::local({
[09:29:45.625]                 do.call(function(...) {
[09:29:45.625]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.625]                   if (!identical(...future.globals.maxSize.org, 
[09:29:45.625]                     ...future.globals.maxSize)) {
[09:29:45.625]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.625]                     on.exit(options(oopts), add = TRUE)
[09:29:45.625]                   }
[09:29:45.625]                   {
[09:29:45.625]                     lapply(seq_along(...future.elements_ii), 
[09:29:45.625]                       FUN = function(jj) {
[09:29:45.625]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.625]                         ...future.FUN(...future.X_jj, ...)
[09:29:45.625]                       })
[09:29:45.625]                   }
[09:29:45.625]                 }, args = future.call.arguments)
[09:29:45.625]             }))
[09:29:45.625]             future::FutureResult(value = ...future.value$value, 
[09:29:45.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.625]                   ...future.rng), globalenv = if (FALSE) 
[09:29:45.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:45.625]                     ...future.globalenv.names))
[09:29:45.625]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:45.625]         }, condition = base::local({
[09:29:45.625]             c <- base::c
[09:29:45.625]             inherits <- base::inherits
[09:29:45.625]             invokeRestart <- base::invokeRestart
[09:29:45.625]             length <- base::length
[09:29:45.625]             list <- base::list
[09:29:45.625]             seq.int <- base::seq.int
[09:29:45.625]             signalCondition <- base::signalCondition
[09:29:45.625]             sys.calls <- base::sys.calls
[09:29:45.625]             `[[` <- base::`[[`
[09:29:45.625]             `+` <- base::`+`
[09:29:45.625]             `<<-` <- base::`<<-`
[09:29:45.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:45.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:45.625]                   3L)]
[09:29:45.625]             }
[09:29:45.625]             function(cond) {
[09:29:45.625]                 is_error <- inherits(cond, "error")
[09:29:45.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:45.625]                   NULL)
[09:29:45.625]                 if (is_error) {
[09:29:45.625]                   sessionInformation <- function() {
[09:29:45.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:45.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:45.625]                       search = base::search(), system = base::Sys.info())
[09:29:45.625]                   }
[09:29:45.625]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:45.625]                     cond$call), session = sessionInformation(), 
[09:29:45.625]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:45.625]                   signalCondition(cond)
[09:29:45.625]                 }
[09:29:45.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:45.625]                 "immediateCondition"))) {
[09:29:45.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:45.625]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:45.625]                   if (TRUE && !signal) {
[09:29:45.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.625]                     {
[09:29:45.625]                       inherits <- base::inherits
[09:29:45.625]                       invokeRestart <- base::invokeRestart
[09:29:45.625]                       is.null <- base::is.null
[09:29:45.625]                       muffled <- FALSE
[09:29:45.625]                       if (inherits(cond, "message")) {
[09:29:45.625]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.625]                         if (muffled) 
[09:29:45.625]                           invokeRestart("muffleMessage")
[09:29:45.625]                       }
[09:29:45.625]                       else if (inherits(cond, "warning")) {
[09:29:45.625]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.625]                         if (muffled) 
[09:29:45.625]                           invokeRestart("muffleWarning")
[09:29:45.625]                       }
[09:29:45.625]                       else if (inherits(cond, "condition")) {
[09:29:45.625]                         if (!is.null(pattern)) {
[09:29:45.625]                           computeRestarts <- base::computeRestarts
[09:29:45.625]                           grepl <- base::grepl
[09:29:45.625]                           restarts <- computeRestarts(cond)
[09:29:45.625]                           for (restart in restarts) {
[09:29:45.625]                             name <- restart$name
[09:29:45.625]                             if (is.null(name)) 
[09:29:45.625]                               next
[09:29:45.625]                             if (!grepl(pattern, name)) 
[09:29:45.625]                               next
[09:29:45.625]                             invokeRestart(restart)
[09:29:45.625]                             muffled <- TRUE
[09:29:45.625]                             break
[09:29:45.625]                           }
[09:29:45.625]                         }
[09:29:45.625]                       }
[09:29:45.625]                       invisible(muffled)
[09:29:45.625]                     }
[09:29:45.625]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.625]                   }
[09:29:45.625]                 }
[09:29:45.625]                 else {
[09:29:45.625]                   if (TRUE) {
[09:29:45.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.625]                     {
[09:29:45.625]                       inherits <- base::inherits
[09:29:45.625]                       invokeRestart <- base::invokeRestart
[09:29:45.625]                       is.null <- base::is.null
[09:29:45.625]                       muffled <- FALSE
[09:29:45.625]                       if (inherits(cond, "message")) {
[09:29:45.625]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.625]                         if (muffled) 
[09:29:45.625]                           invokeRestart("muffleMessage")
[09:29:45.625]                       }
[09:29:45.625]                       else if (inherits(cond, "warning")) {
[09:29:45.625]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.625]                         if (muffled) 
[09:29:45.625]                           invokeRestart("muffleWarning")
[09:29:45.625]                       }
[09:29:45.625]                       else if (inherits(cond, "condition")) {
[09:29:45.625]                         if (!is.null(pattern)) {
[09:29:45.625]                           computeRestarts <- base::computeRestarts
[09:29:45.625]                           grepl <- base::grepl
[09:29:45.625]                           restarts <- computeRestarts(cond)
[09:29:45.625]                           for (restart in restarts) {
[09:29:45.625]                             name <- restart$name
[09:29:45.625]                             if (is.null(name)) 
[09:29:45.625]                               next
[09:29:45.625]                             if (!grepl(pattern, name)) 
[09:29:45.625]                               next
[09:29:45.625]                             invokeRestart(restart)
[09:29:45.625]                             muffled <- TRUE
[09:29:45.625]                             break
[09:29:45.625]                           }
[09:29:45.625]                         }
[09:29:45.625]                       }
[09:29:45.625]                       invisible(muffled)
[09:29:45.625]                     }
[09:29:45.625]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.625]                   }
[09:29:45.625]                 }
[09:29:45.625]             }
[09:29:45.625]         }))
[09:29:45.625]     }, error = function(ex) {
[09:29:45.625]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:45.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.625]                 ...future.rng), started = ...future.startTime, 
[09:29:45.625]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:45.625]             version = "1.8"), class = "FutureResult")
[09:29:45.625]     }, finally = {
[09:29:45.625]         if (!identical(...future.workdir, getwd())) 
[09:29:45.625]             setwd(...future.workdir)
[09:29:45.625]         {
[09:29:45.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:45.625]                 ...future.oldOptions$nwarnings <- NULL
[09:29:45.625]             }
[09:29:45.625]             base::options(...future.oldOptions)
[09:29:45.625]             if (.Platform$OS.type == "windows") {
[09:29:45.625]                 old_names <- names(...future.oldEnvVars)
[09:29:45.625]                 envs <- base::Sys.getenv()
[09:29:45.625]                 names <- names(envs)
[09:29:45.625]                 common <- intersect(names, old_names)
[09:29:45.625]                 added <- setdiff(names, old_names)
[09:29:45.625]                 removed <- setdiff(old_names, names)
[09:29:45.625]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:45.625]                   envs[common]]
[09:29:45.625]                 NAMES <- toupper(changed)
[09:29:45.625]                 args <- list()
[09:29:45.625]                 for (kk in seq_along(NAMES)) {
[09:29:45.625]                   name <- changed[[kk]]
[09:29:45.625]                   NAME <- NAMES[[kk]]
[09:29:45.625]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.625]                     next
[09:29:45.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.625]                 }
[09:29:45.625]                 NAMES <- toupper(added)
[09:29:45.625]                 for (kk in seq_along(NAMES)) {
[09:29:45.625]                   name <- added[[kk]]
[09:29:45.625]                   NAME <- NAMES[[kk]]
[09:29:45.625]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.625]                     next
[09:29:45.625]                   args[[name]] <- ""
[09:29:45.625]                 }
[09:29:45.625]                 NAMES <- toupper(removed)
[09:29:45.625]                 for (kk in seq_along(NAMES)) {
[09:29:45.625]                   name <- removed[[kk]]
[09:29:45.625]                   NAME <- NAMES[[kk]]
[09:29:45.625]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.625]                     next
[09:29:45.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.625]                 }
[09:29:45.625]                 if (length(args) > 0) 
[09:29:45.625]                   base::do.call(base::Sys.setenv, args = args)
[09:29:45.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:45.625]             }
[09:29:45.625]             else {
[09:29:45.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:45.625]             }
[09:29:45.625]             {
[09:29:45.625]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:45.625]                   0L) {
[09:29:45.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:45.625]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:45.625]                   base::options(opts)
[09:29:45.625]                 }
[09:29:45.625]                 {
[09:29:45.625]                   {
[09:29:45.625]                     NULL
[09:29:45.625]                     RNGkind("Mersenne-Twister")
[09:29:45.625]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:45.625]                       inherits = FALSE)
[09:29:45.625]                   }
[09:29:45.625]                   options(future.plan = NULL)
[09:29:45.625]                   if (is.na(NA_character_)) 
[09:29:45.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:45.625]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:45.625]                     .init = FALSE)
[09:29:45.625]                 }
[09:29:45.625]             }
[09:29:45.625]         }
[09:29:45.625]     })
[09:29:45.625]     if (TRUE) {
[09:29:45.625]         base::sink(type = "output", split = FALSE)
[09:29:45.625]         if (TRUE) {
[09:29:45.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:45.625]         }
[09:29:45.625]         else {
[09:29:45.625]             ...future.result["stdout"] <- base::list(NULL)
[09:29:45.625]         }
[09:29:45.625]         base::close(...future.stdout)
[09:29:45.625]         ...future.stdout <- NULL
[09:29:45.625]     }
[09:29:45.625]     ...future.result$conditions <- ...future.conditions
[09:29:45.625]     ...future.result$finished <- base::Sys.time()
[09:29:45.625]     ...future.result
[09:29:45.625] }
[09:29:45.627] assign_globals() ...
[09:29:45.627] List of 11
[09:29:45.627]  $ ...future.FUN            :function (x, ...)  
[09:29:45.627]  $ x_FUN                    :function (x)  
[09:29:45.627]  $ times                    : int 0
[09:29:45.627]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.627]  $ stop_if_not              :function (...)  
[09:29:45.627]  $ dim                      : NULL
[09:29:45.627]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:45.627]  $ future.call.arguments    : list()
[09:29:45.627]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.627]  $ ...future.elements_ii    :List of 10
[09:29:45.627]   ..$ : int 1
[09:29:45.627]   ..$ : int 2
[09:29:45.627]   ..$ : int 3
[09:29:45.627]   ..$ : int 4
[09:29:45.627]   ..$ : int 5
[09:29:45.627]   ..$ : int 6
[09:29:45.627]   ..$ : int 7
[09:29:45.627]   ..$ : int 8
[09:29:45.627]   ..$ : int 9
[09:29:45.627]   ..$ : int 10
[09:29:45.627]  $ ...future.seeds_ii       : NULL
[09:29:45.627]  $ ...future.globals.maxSize: NULL
[09:29:45.627]  - attr(*, "where")=List of 11
[09:29:45.627]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:45.627]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:45.627]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:45.627]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:45.627]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:45.627]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:45.627]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:45.627]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:45.627]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:45.627]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:45.627]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:45.627]  - attr(*, "resolved")= logi FALSE
[09:29:45.627]  - attr(*, "total_size")= num 95472
[09:29:45.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.627]  - attr(*, "already-done")= logi TRUE
[09:29:45.637] - copied ‘...future.FUN’ to environment
[09:29:45.637] - reassign environment for ‘x_FUN’
[09:29:45.637] - copied ‘x_FUN’ to environment
[09:29:45.637] - copied ‘times’ to environment
[09:29:45.637] - copied ‘stopf’ to environment
[09:29:45.637] - copied ‘stop_if_not’ to environment
[09:29:45.637] - copied ‘dim’ to environment
[09:29:45.637] - copied ‘valid_types’ to environment
[09:29:45.637] - copied ‘future.call.arguments’ to environment
[09:29:45.638] - copied ‘...future.elements_ii’ to environment
[09:29:45.638] - copied ‘...future.seeds_ii’ to environment
[09:29:45.638] - copied ‘...future.globals.maxSize’ to environment
[09:29:45.638] assign_globals() ... done
[09:29:45.638] plan(): Setting new future strategy stack:
[09:29:45.638] List of future strategies:
[09:29:45.638] 1. sequential:
[09:29:45.638]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.638]    - tweaked: FALSE
[09:29:45.638]    - call: NULL
[09:29:45.639] plan(): nbrOfWorkers() = 1
[09:29:45.639] plan(): Setting new future strategy stack:
[09:29:45.639] List of future strategies:
[09:29:45.639] 1. sequential:
[09:29:45.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.639]    - tweaked: FALSE
[09:29:45.639]    - call: plan(strategy)
[09:29:45.640] plan(): nbrOfWorkers() = 1
[09:29:45.640] SequentialFuture started (and completed)
[09:29:45.640] - Launch lazy future ... done
[09:29:45.640] run() for ‘SequentialFuture’ ... done
[09:29:45.640] Created future:
[09:29:45.640] SequentialFuture:
[09:29:45.640] Label: ‘future_vapply-1’
[09:29:45.640] Expression:
[09:29:45.640] {
[09:29:45.640]     do.call(function(...) {
[09:29:45.640]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.640]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.640]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.640]             on.exit(options(oopts), add = TRUE)
[09:29:45.640]         }
[09:29:45.640]         {
[09:29:45.640]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.640]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.640]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.640]             })
[09:29:45.640]         }
[09:29:45.640]     }, args = future.call.arguments)
[09:29:45.640] }
[09:29:45.640] Lazy evaluation: FALSE
[09:29:45.640] Asynchronous evaluation: FALSE
[09:29:45.640] Local evaluation: TRUE
[09:29:45.640] Environment: R_GlobalEnv
[09:29:45.640] Capture standard output: TRUE
[09:29:45.640] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:45.640] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:45.640] Packages: 1 packages (‘future.apply’)
[09:29:45.640] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:45.640] Resolved: TRUE
[09:29:45.640] Value: 480 bytes of class ‘list’
[09:29:45.640] Early signaling: FALSE
[09:29:45.640] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:45.640] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.641] Chunk #1 of 1 ... DONE
[09:29:45.642] Launching 1 futures (chunks) ... DONE
[09:29:45.642] Resolving 1 futures (chunks) ...
[09:29:45.642] resolve() on list ...
[09:29:45.642]  recursive: 0
[09:29:45.642]  length: 1
[09:29:45.642] 
[09:29:45.642] resolved() for ‘SequentialFuture’ ...
[09:29:45.642] - state: ‘finished’
[09:29:45.642] - run: TRUE
[09:29:45.642] - result: ‘FutureResult’
[09:29:45.642] resolved() for ‘SequentialFuture’ ... done
[09:29:45.642] Future #1
[09:29:45.643] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:45.643] - nx: 1
[09:29:45.643] - relay: TRUE
[09:29:45.643] - stdout: TRUE
[09:29:45.643] - signal: TRUE
[09:29:45.643] - resignal: FALSE
[09:29:45.643] - force: TRUE
[09:29:45.643] - relayed: [n=1] FALSE
[09:29:45.643] - queued futures: [n=1] FALSE
[09:29:45.643]  - until=1
[09:29:45.643]  - relaying element #1
[09:29:45.644] - relayed: [n=1] TRUE
[09:29:45.644] - queued futures: [n=1] TRUE
[09:29:45.644] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:45.644]  length: 0 (resolved future 1)
[09:29:45.644] Relaying remaining futures
[09:29:45.644] signalConditionsASAP(NULL, pos=0) ...
[09:29:45.644] - nx: 1
[09:29:45.644] - relay: TRUE
[09:29:45.644] - stdout: TRUE
[09:29:45.644] - signal: TRUE
[09:29:45.644] - resignal: FALSE
[09:29:45.645] - force: TRUE
[09:29:45.645] - relayed: [n=1] TRUE
[09:29:45.645] - queued futures: [n=1] TRUE
 - flush all
[09:29:45.645] - relayed: [n=1] TRUE
[09:29:45.645] - queued futures: [n=1] TRUE
[09:29:45.645] signalConditionsASAP(NULL, pos=0) ... done
[09:29:45.645] resolve() on list ... DONE
[09:29:45.645]  - Number of value chunks collected: 1
[09:29:45.645] Resolving 1 futures (chunks) ... DONE
[09:29:45.645] Reducing values from 1 chunks ...
[09:29:45.645]  - Number of values collected after concatenation: 10
[09:29:45.645]  - Number of values expected: 10
[09:29:45.646] Reducing values from 1 chunks ... DONE
[09:29:45.646] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[09:29:45.646] future_lapply() ...
[09:29:45.648] Number of chunks: 1
[09:29:45.648] getGlobalsAndPackagesXApply() ...
[09:29:45.648]  - future.globals: TRUE
[09:29:45.648] getGlobalsAndPackages() ...
[09:29:45.648] Searching for globals...
[09:29:45.652] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[09:29:45.652] Searching for globals ... DONE
[09:29:45.653] Resolving globals: FALSE
[09:29:45.653] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[09:29:45.654] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:45.654] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.654] - packages: [1] ‘future.apply’
[09:29:45.654] getGlobalsAndPackages() ... DONE
[09:29:45.654]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.654]  - needed namespaces: [n=1] ‘future.apply’
[09:29:45.654] Finding globals ... DONE
[09:29:45.654]  - use_args: TRUE
[09:29:45.654]  - Getting '...' globals ...
[09:29:45.655] resolve() on list ...
[09:29:45.655]  recursive: 0
[09:29:45.655]  length: 1
[09:29:45.655]  elements: ‘...’
[09:29:45.655]  length: 0 (resolved future 1)
[09:29:45.655] resolve() on list ... DONE
[09:29:45.655]    - '...' content: [n=0] 
[09:29:45.655] List of 1
[09:29:45.655]  $ ...: list()
[09:29:45.655]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.655]  - attr(*, "where")=List of 1
[09:29:45.655]   ..$ ...:<environment: 0x561d368283e0> 
[09:29:45.655]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.655]  - attr(*, "resolved")= logi TRUE
[09:29:45.655]  - attr(*, "total_size")= num NA
[09:29:45.658]  - Getting '...' globals ... DONE
[09:29:45.658] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:45.658] List of 8
[09:29:45.658]  $ ...future.FUN:function (x, ...)  
[09:29:45.658]  $ x_FUN        :function (x)  
[09:29:45.658]  $ times        : int 0
[09:29:45.658]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.658]  $ stop_if_not  :function (...)  
[09:29:45.658]  $ dim          : NULL
[09:29:45.658]  $ valid_types  : chr [1:2] "logical" "integer"
[09:29:45.658]  $ ...          : list()
[09:29:45.658]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.658]  - attr(*, "where")=List of 8
[09:29:45.658]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:45.658]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:45.658]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:45.658]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:45.658]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:45.658]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:45.658]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:45.658]   ..$ ...          :<environment: 0x561d368283e0> 
[09:29:45.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.658]  - attr(*, "resolved")= logi FALSE
[09:29:45.658]  - attr(*, "total_size")= num 95400
[09:29:45.663] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:45.663] getGlobalsAndPackagesXApply() ... DONE
[09:29:45.663] Number of futures (= number of chunks): 1
[09:29:45.663] Launching 1 futures (chunks) ...
[09:29:45.663] Chunk #1 of 1 ...
[09:29:45.663]  - Finding globals in 'X' for chunk #1 ...
[09:29:45.663] getGlobalsAndPackages() ...
[09:29:45.663] Searching for globals...
[09:29:45.664] 
[09:29:45.664] Searching for globals ... DONE
[09:29:45.664] - globals: [0] <none>
[09:29:45.664] getGlobalsAndPackages() ... DONE
[09:29:45.664]    + additional globals found: [n=0] 
[09:29:45.664]    + additional namespaces needed: [n=0] 
[09:29:45.664]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:45.664]  - seeds: <none>
[09:29:45.664]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.664] getGlobalsAndPackages() ...
[09:29:45.665] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.665] Resolving globals: FALSE
[09:29:45.665] Tweak future expression to call with '...' arguments ...
[09:29:45.665] {
[09:29:45.665]     do.call(function(...) {
[09:29:45.665]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.665]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.665]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.665]             on.exit(options(oopts), add = TRUE)
[09:29:45.665]         }
[09:29:45.665]         {
[09:29:45.665]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.665]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.665]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.665]             })
[09:29:45.665]         }
[09:29:45.665]     }, args = future.call.arguments)
[09:29:45.665] }
[09:29:45.665] Tweak future expression to call with '...' arguments ... DONE
[09:29:45.666] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.666] - packages: [1] ‘future.apply’
[09:29:45.666] getGlobalsAndPackages() ... DONE
[09:29:45.666] run() for ‘Future’ ...
[09:29:45.666] - state: ‘created’
[09:29:45.666] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:45.666] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:45.667]   - Field: ‘label’
[09:29:45.667]   - Field: ‘local’
[09:29:45.667]   - Field: ‘owner’
[09:29:45.667]   - Field: ‘envir’
[09:29:45.667]   - Field: ‘packages’
[09:29:45.667]   - Field: ‘gc’
[09:29:45.667]   - Field: ‘conditions’
[09:29:45.667]   - Field: ‘expr’
[09:29:45.667]   - Field: ‘uuid’
[09:29:45.667]   - Field: ‘seed’
[09:29:45.668]   - Field: ‘version’
[09:29:45.668]   - Field: ‘result’
[09:29:45.668]   - Field: ‘asynchronous’
[09:29:45.668]   - Field: ‘calls’
[09:29:45.668]   - Field: ‘globals’
[09:29:45.668]   - Field: ‘stdout’
[09:29:45.668]   - Field: ‘earlySignal’
[09:29:45.668]   - Field: ‘lazy’
[09:29:45.668]   - Field: ‘state’
[09:29:45.668] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:45.668] - Launch lazy future ...
[09:29:45.669] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:45.669] Packages needed by future strategies (n = 0): <none>
[09:29:45.669] {
[09:29:45.669]     {
[09:29:45.669]         {
[09:29:45.669]             ...future.startTime <- base::Sys.time()
[09:29:45.669]             {
[09:29:45.669]                 {
[09:29:45.669]                   {
[09:29:45.669]                     {
[09:29:45.669]                       base::local({
[09:29:45.669]                         has_future <- base::requireNamespace("future", 
[09:29:45.669]                           quietly = TRUE)
[09:29:45.669]                         if (has_future) {
[09:29:45.669]                           ns <- base::getNamespace("future")
[09:29:45.669]                           version <- ns[[".package"]][["version"]]
[09:29:45.669]                           if (is.null(version)) 
[09:29:45.669]                             version <- utils::packageVersion("future")
[09:29:45.669]                         }
[09:29:45.669]                         else {
[09:29:45.669]                           version <- NULL
[09:29:45.669]                         }
[09:29:45.669]                         if (!has_future || version < "1.8.0") {
[09:29:45.669]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:45.669]                             "", base::R.version$version.string), 
[09:29:45.669]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:45.669]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:45.669]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:45.669]                               "release", "version")], collapse = " "), 
[09:29:45.669]                             hostname = base::Sys.info()[["nodename"]])
[09:29:45.669]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:45.669]                             info)
[09:29:45.669]                           info <- base::paste(info, collapse = "; ")
[09:29:45.669]                           if (!has_future) {
[09:29:45.669]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:45.669]                               info)
[09:29:45.669]                           }
[09:29:45.669]                           else {
[09:29:45.669]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:45.669]                               info, version)
[09:29:45.669]                           }
[09:29:45.669]                           base::stop(msg)
[09:29:45.669]                         }
[09:29:45.669]                       })
[09:29:45.669]                     }
[09:29:45.669]                     base::local({
[09:29:45.669]                       for (pkg in "future.apply") {
[09:29:45.669]                         base::loadNamespace(pkg)
[09:29:45.669]                         base::library(pkg, character.only = TRUE)
[09:29:45.669]                       }
[09:29:45.669]                     })
[09:29:45.669]                   }
[09:29:45.669]                   ...future.strategy.old <- future::plan("list")
[09:29:45.669]                   options(future.plan = NULL)
[09:29:45.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:45.669]                 }
[09:29:45.669]                 ...future.workdir <- getwd()
[09:29:45.669]             }
[09:29:45.669]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:45.669]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:45.669]         }
[09:29:45.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:45.669]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:45.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:45.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:45.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:45.669]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:45.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:45.669]             base::names(...future.oldOptions))
[09:29:45.669]     }
[09:29:45.669]     if (FALSE) {
[09:29:45.669]     }
[09:29:45.669]     else {
[09:29:45.669]         if (TRUE) {
[09:29:45.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:45.669]                 open = "w")
[09:29:45.669]         }
[09:29:45.669]         else {
[09:29:45.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:45.669]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:45.669]         }
[09:29:45.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:45.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:45.669]             base::sink(type = "output", split = FALSE)
[09:29:45.669]             base::close(...future.stdout)
[09:29:45.669]         }, add = TRUE)
[09:29:45.669]     }
[09:29:45.669]     ...future.frame <- base::sys.nframe()
[09:29:45.669]     ...future.conditions <- base::list()
[09:29:45.669]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:45.669]     if (FALSE) {
[09:29:45.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:45.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:45.669]     }
[09:29:45.669]     ...future.result <- base::tryCatch({
[09:29:45.669]         base::withCallingHandlers({
[09:29:45.669]             ...future.value <- base::withVisible(base::local({
[09:29:45.669]                 do.call(function(...) {
[09:29:45.669]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.669]                   if (!identical(...future.globals.maxSize.org, 
[09:29:45.669]                     ...future.globals.maxSize)) {
[09:29:45.669]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.669]                     on.exit(options(oopts), add = TRUE)
[09:29:45.669]                   }
[09:29:45.669]                   {
[09:29:45.669]                     lapply(seq_along(...future.elements_ii), 
[09:29:45.669]                       FUN = function(jj) {
[09:29:45.669]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.669]                         ...future.FUN(...future.X_jj, ...)
[09:29:45.669]                       })
[09:29:45.669]                   }
[09:29:45.669]                 }, args = future.call.arguments)
[09:29:45.669]             }))
[09:29:45.669]             future::FutureResult(value = ...future.value$value, 
[09:29:45.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.669]                   ...future.rng), globalenv = if (FALSE) 
[09:29:45.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:45.669]                     ...future.globalenv.names))
[09:29:45.669]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:45.669]         }, condition = base::local({
[09:29:45.669]             c <- base::c
[09:29:45.669]             inherits <- base::inherits
[09:29:45.669]             invokeRestart <- base::invokeRestart
[09:29:45.669]             length <- base::length
[09:29:45.669]             list <- base::list
[09:29:45.669]             seq.int <- base::seq.int
[09:29:45.669]             signalCondition <- base::signalCondition
[09:29:45.669]             sys.calls <- base::sys.calls
[09:29:45.669]             `[[` <- base::`[[`
[09:29:45.669]             `+` <- base::`+`
[09:29:45.669]             `<<-` <- base::`<<-`
[09:29:45.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:45.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:45.669]                   3L)]
[09:29:45.669]             }
[09:29:45.669]             function(cond) {
[09:29:45.669]                 is_error <- inherits(cond, "error")
[09:29:45.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:45.669]                   NULL)
[09:29:45.669]                 if (is_error) {
[09:29:45.669]                   sessionInformation <- function() {
[09:29:45.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:45.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:45.669]                       search = base::search(), system = base::Sys.info())
[09:29:45.669]                   }
[09:29:45.669]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:45.669]                     cond$call), session = sessionInformation(), 
[09:29:45.669]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:45.669]                   signalCondition(cond)
[09:29:45.669]                 }
[09:29:45.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:45.669]                 "immediateCondition"))) {
[09:29:45.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:45.669]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:45.669]                   if (TRUE && !signal) {
[09:29:45.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.669]                     {
[09:29:45.669]                       inherits <- base::inherits
[09:29:45.669]                       invokeRestart <- base::invokeRestart
[09:29:45.669]                       is.null <- base::is.null
[09:29:45.669]                       muffled <- FALSE
[09:29:45.669]                       if (inherits(cond, "message")) {
[09:29:45.669]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.669]                         if (muffled) 
[09:29:45.669]                           invokeRestart("muffleMessage")
[09:29:45.669]                       }
[09:29:45.669]                       else if (inherits(cond, "warning")) {
[09:29:45.669]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.669]                         if (muffled) 
[09:29:45.669]                           invokeRestart("muffleWarning")
[09:29:45.669]                       }
[09:29:45.669]                       else if (inherits(cond, "condition")) {
[09:29:45.669]                         if (!is.null(pattern)) {
[09:29:45.669]                           computeRestarts <- base::computeRestarts
[09:29:45.669]                           grepl <- base::grepl
[09:29:45.669]                           restarts <- computeRestarts(cond)
[09:29:45.669]                           for (restart in restarts) {
[09:29:45.669]                             name <- restart$name
[09:29:45.669]                             if (is.null(name)) 
[09:29:45.669]                               next
[09:29:45.669]                             if (!grepl(pattern, name)) 
[09:29:45.669]                               next
[09:29:45.669]                             invokeRestart(restart)
[09:29:45.669]                             muffled <- TRUE
[09:29:45.669]                             break
[09:29:45.669]                           }
[09:29:45.669]                         }
[09:29:45.669]                       }
[09:29:45.669]                       invisible(muffled)
[09:29:45.669]                     }
[09:29:45.669]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.669]                   }
[09:29:45.669]                 }
[09:29:45.669]                 else {
[09:29:45.669]                   if (TRUE) {
[09:29:45.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.669]                     {
[09:29:45.669]                       inherits <- base::inherits
[09:29:45.669]                       invokeRestart <- base::invokeRestart
[09:29:45.669]                       is.null <- base::is.null
[09:29:45.669]                       muffled <- FALSE
[09:29:45.669]                       if (inherits(cond, "message")) {
[09:29:45.669]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.669]                         if (muffled) 
[09:29:45.669]                           invokeRestart("muffleMessage")
[09:29:45.669]                       }
[09:29:45.669]                       else if (inherits(cond, "warning")) {
[09:29:45.669]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.669]                         if (muffled) 
[09:29:45.669]                           invokeRestart("muffleWarning")
[09:29:45.669]                       }
[09:29:45.669]                       else if (inherits(cond, "condition")) {
[09:29:45.669]                         if (!is.null(pattern)) {
[09:29:45.669]                           computeRestarts <- base::computeRestarts
[09:29:45.669]                           grepl <- base::grepl
[09:29:45.669]                           restarts <- computeRestarts(cond)
[09:29:45.669]                           for (restart in restarts) {
[09:29:45.669]                             name <- restart$name
[09:29:45.669]                             if (is.null(name)) 
[09:29:45.669]                               next
[09:29:45.669]                             if (!grepl(pattern, name)) 
[09:29:45.669]                               next
[09:29:45.669]                             invokeRestart(restart)
[09:29:45.669]                             muffled <- TRUE
[09:29:45.669]                             break
[09:29:45.669]                           }
[09:29:45.669]                         }
[09:29:45.669]                       }
[09:29:45.669]                       invisible(muffled)
[09:29:45.669]                     }
[09:29:45.669]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.669]                   }
[09:29:45.669]                 }
[09:29:45.669]             }
[09:29:45.669]         }))
[09:29:45.669]     }, error = function(ex) {
[09:29:45.669]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:45.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.669]                 ...future.rng), started = ...future.startTime, 
[09:29:45.669]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:45.669]             version = "1.8"), class = "FutureResult")
[09:29:45.669]     }, finally = {
[09:29:45.669]         if (!identical(...future.workdir, getwd())) 
[09:29:45.669]             setwd(...future.workdir)
[09:29:45.669]         {
[09:29:45.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:45.669]                 ...future.oldOptions$nwarnings <- NULL
[09:29:45.669]             }
[09:29:45.669]             base::options(...future.oldOptions)
[09:29:45.669]             if (.Platform$OS.type == "windows") {
[09:29:45.669]                 old_names <- names(...future.oldEnvVars)
[09:29:45.669]                 envs <- base::Sys.getenv()
[09:29:45.669]                 names <- names(envs)
[09:29:45.669]                 common <- intersect(names, old_names)
[09:29:45.669]                 added <- setdiff(names, old_names)
[09:29:45.669]                 removed <- setdiff(old_names, names)
[09:29:45.669]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:45.669]                   envs[common]]
[09:29:45.669]                 NAMES <- toupper(changed)
[09:29:45.669]                 args <- list()
[09:29:45.669]                 for (kk in seq_along(NAMES)) {
[09:29:45.669]                   name <- changed[[kk]]
[09:29:45.669]                   NAME <- NAMES[[kk]]
[09:29:45.669]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.669]                     next
[09:29:45.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.669]                 }
[09:29:45.669]                 NAMES <- toupper(added)
[09:29:45.669]                 for (kk in seq_along(NAMES)) {
[09:29:45.669]                   name <- added[[kk]]
[09:29:45.669]                   NAME <- NAMES[[kk]]
[09:29:45.669]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.669]                     next
[09:29:45.669]                   args[[name]] <- ""
[09:29:45.669]                 }
[09:29:45.669]                 NAMES <- toupper(removed)
[09:29:45.669]                 for (kk in seq_along(NAMES)) {
[09:29:45.669]                   name <- removed[[kk]]
[09:29:45.669]                   NAME <- NAMES[[kk]]
[09:29:45.669]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.669]                     next
[09:29:45.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.669]                 }
[09:29:45.669]                 if (length(args) > 0) 
[09:29:45.669]                   base::do.call(base::Sys.setenv, args = args)
[09:29:45.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:45.669]             }
[09:29:45.669]             else {
[09:29:45.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:45.669]             }
[09:29:45.669]             {
[09:29:45.669]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:45.669]                   0L) {
[09:29:45.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:45.669]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:45.669]                   base::options(opts)
[09:29:45.669]                 }
[09:29:45.669]                 {
[09:29:45.669]                   {
[09:29:45.669]                     NULL
[09:29:45.669]                     RNGkind("Mersenne-Twister")
[09:29:45.669]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:45.669]                       inherits = FALSE)
[09:29:45.669]                   }
[09:29:45.669]                   options(future.plan = NULL)
[09:29:45.669]                   if (is.na(NA_character_)) 
[09:29:45.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:45.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:45.669]                     .init = FALSE)
[09:29:45.669]                 }
[09:29:45.669]             }
[09:29:45.669]         }
[09:29:45.669]     })
[09:29:45.669]     if (TRUE) {
[09:29:45.669]         base::sink(type = "output", split = FALSE)
[09:29:45.669]         if (TRUE) {
[09:29:45.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:45.669]         }
[09:29:45.669]         else {
[09:29:45.669]             ...future.result["stdout"] <- base::list(NULL)
[09:29:45.669]         }
[09:29:45.669]         base::close(...future.stdout)
[09:29:45.669]         ...future.stdout <- NULL
[09:29:45.669]     }
[09:29:45.669]     ...future.result$conditions <- ...future.conditions
[09:29:45.669]     ...future.result$finished <- base::Sys.time()
[09:29:45.669]     ...future.result
[09:29:45.669] }
[09:29:45.671] assign_globals() ...
[09:29:45.671] List of 11
[09:29:45.671]  $ ...future.FUN            :function (x, ...)  
[09:29:45.671]  $ x_FUN                    :function (x)  
[09:29:45.671]  $ times                    : int 0
[09:29:45.671]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.671]  $ stop_if_not              :function (...)  
[09:29:45.671]  $ dim                      : NULL
[09:29:45.671]  $ valid_types              : chr [1:2] "logical" "integer"
[09:29:45.671]  $ future.call.arguments    : list()
[09:29:45.671]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.671]  $ ...future.elements_ii    :List of 10
[09:29:45.671]   ..$ : int 1
[09:29:45.671]   ..$ : int 2
[09:29:45.671]   ..$ : int 3
[09:29:45.671]   ..$ : int 4
[09:29:45.671]   ..$ : int 5
[09:29:45.671]   ..$ : int 6
[09:29:45.671]   ..$ : int 7
[09:29:45.671]   ..$ : int 8
[09:29:45.671]   ..$ : int 9
[09:29:45.671]   ..$ : int 10
[09:29:45.671]  $ ...future.seeds_ii       : NULL
[09:29:45.671]  $ ...future.globals.maxSize: NULL
[09:29:45.671]  - attr(*, "where")=List of 11
[09:29:45.671]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:45.671]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:45.671]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:45.671]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:45.671]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:45.671]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:45.671]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:45.671]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:45.671]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:45.671]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:45.671]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:45.671]  - attr(*, "resolved")= logi FALSE
[09:29:45.671]  - attr(*, "total_size")= num 95400
[09:29:45.671]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.671]  - attr(*, "already-done")= logi TRUE
[09:29:45.681] - copied ‘...future.FUN’ to environment
[09:29:45.681] - reassign environment for ‘x_FUN’
[09:29:45.681] - copied ‘x_FUN’ to environment
[09:29:45.681] - copied ‘times’ to environment
[09:29:45.681] - copied ‘stopf’ to environment
[09:29:45.681] - copied ‘stop_if_not’ to environment
[09:29:45.681] - copied ‘dim’ to environment
[09:29:45.682] - copied ‘valid_types’ to environment
[09:29:45.682] - copied ‘future.call.arguments’ to environment
[09:29:45.682] - copied ‘...future.elements_ii’ to environment
[09:29:45.682] - copied ‘...future.seeds_ii’ to environment
[09:29:45.682] - copied ‘...future.globals.maxSize’ to environment
[09:29:45.682] assign_globals() ... done
[09:29:45.682] plan(): Setting new future strategy stack:
[09:29:45.682] List of future strategies:
[09:29:45.682] 1. sequential:
[09:29:45.682]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.682]    - tweaked: FALSE
[09:29:45.682]    - call: NULL
[09:29:45.683] plan(): nbrOfWorkers() = 1
[09:29:45.684] plan(): Setting new future strategy stack:
[09:29:45.684] List of future strategies:
[09:29:45.684] 1. sequential:
[09:29:45.684]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.684]    - tweaked: FALSE
[09:29:45.684]    - call: plan(strategy)
[09:29:45.684] plan(): nbrOfWorkers() = 1
[09:29:45.684] SequentialFuture started (and completed)
[09:29:45.684] - Launch lazy future ... done
[09:29:45.684] run() for ‘SequentialFuture’ ... done
[09:29:45.685] Created future:
[09:29:45.685] SequentialFuture:
[09:29:45.685] Label: ‘future_vapply-1’
[09:29:45.685] Expression:
[09:29:45.685] {
[09:29:45.685]     do.call(function(...) {
[09:29:45.685]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.685]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.685]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.685]             on.exit(options(oopts), add = TRUE)
[09:29:45.685]         }
[09:29:45.685]         {
[09:29:45.685]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.685]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.685]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.685]             })
[09:29:45.685]         }
[09:29:45.685]     }, args = future.call.arguments)
[09:29:45.685] }
[09:29:45.685] Lazy evaluation: FALSE
[09:29:45.685] Asynchronous evaluation: FALSE
[09:29:45.685] Local evaluation: TRUE
[09:29:45.685] Environment: R_GlobalEnv
[09:29:45.685] Capture standard output: TRUE
[09:29:45.685] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:45.685] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:45.685] Packages: 1 packages (‘future.apply’)
[09:29:45.685] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:45.685] Resolved: TRUE
[09:29:45.685] Value: 480 bytes of class ‘list’
[09:29:45.685] Early signaling: FALSE
[09:29:45.685] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:45.685] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.686] Chunk #1 of 1 ... DONE
[09:29:45.686] Launching 1 futures (chunks) ... DONE
[09:29:45.686] Resolving 1 futures (chunks) ...
[09:29:45.686] resolve() on list ...
[09:29:45.686]  recursive: 0
[09:29:45.686]  length: 1
[09:29:45.686] 
[09:29:45.686] resolved() for ‘SequentialFuture’ ...
[09:29:45.686] - state: ‘finished’
[09:29:45.687] - run: TRUE
[09:29:45.687] - result: ‘FutureResult’
[09:29:45.687] resolved() for ‘SequentialFuture’ ... done
[09:29:45.687] Future #1
[09:29:45.687] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:45.687] - nx: 1
[09:29:45.687] - relay: TRUE
[09:29:45.687] - stdout: TRUE
[09:29:45.687] - signal: TRUE
[09:29:45.687] - resignal: FALSE
[09:29:45.687] - force: TRUE
[09:29:45.687] - relayed: [n=1] FALSE
[09:29:45.688] - queued futures: [n=1] FALSE
[09:29:45.688]  - until=1
[09:29:45.688]  - relaying element #1
[09:29:45.688] - relayed: [n=1] TRUE
[09:29:45.688] - queued futures: [n=1] TRUE
[09:29:45.688] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:45.688]  length: 0 (resolved future 1)
[09:29:45.688] Relaying remaining futures
[09:29:45.688] signalConditionsASAP(NULL, pos=0) ...
[09:29:45.688] - nx: 1
[09:29:45.689] - relay: TRUE
[09:29:45.689] - stdout: TRUE
[09:29:45.689] - signal: TRUE
[09:29:45.689] - resignal: FALSE
[09:29:45.689] - force: TRUE
[09:29:45.689] - relayed: [n=1] TRUE
[09:29:45.689] - queued futures: [n=1] TRUE
 - flush all
[09:29:45.689] - relayed: [n=1] TRUE
[09:29:45.689] - queued futures: [n=1] TRUE
[09:29:45.689] signalConditionsASAP(NULL, pos=0) ... done
[09:29:45.689] resolve() on list ... DONE
[09:29:45.689]  - Number of value chunks collected: 1
[09:29:45.690] Resolving 1 futures (chunks) ... DONE
[09:29:45.690] Reducing values from 1 chunks ...
[09:29:45.690]  - Number of values collected after concatenation: 10
[09:29:45.690]  - Number of values expected: 10
[09:29:45.690] Reducing values from 1 chunks ... DONE
[09:29:45.690] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[09:29:45.691] future_lapply() ...
[09:29:45.692] Number of chunks: 1
[09:29:45.692] getGlobalsAndPackagesXApply() ...
[09:29:45.692]  - future.globals: TRUE
[09:29:45.693] getGlobalsAndPackages() ...
[09:29:45.693] Searching for globals...
[09:29:45.696] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:45.696] Searching for globals ... DONE
[09:29:45.696] Resolving globals: FALSE
[09:29:45.697] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[09:29:45.698] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:45.698] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.698] - packages: [1] ‘future.apply’
[09:29:45.698] getGlobalsAndPackages() ... DONE
[09:29:45.698]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.698]  - needed namespaces: [n=1] ‘future.apply’
[09:29:45.698] Finding globals ... DONE
[09:29:45.698]  - use_args: TRUE
[09:29:45.698]  - Getting '...' globals ...
[09:29:45.699] resolve() on list ...
[09:29:45.699]  recursive: 0
[09:29:45.699]  length: 1
[09:29:45.699]  elements: ‘...’
[09:29:45.699]  length: 0 (resolved future 1)
[09:29:45.699] resolve() on list ... DONE
[09:29:45.699]    - '...' content: [n=0] 
[09:29:45.699] List of 1
[09:29:45.699]  $ ...: list()
[09:29:45.699]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.699]  - attr(*, "where")=List of 1
[09:29:45.699]   ..$ ...:<environment: 0x561d3686b538> 
[09:29:45.699]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.699]  - attr(*, "resolved")= logi TRUE
[09:29:45.699]  - attr(*, "total_size")= num NA
[09:29:45.701]  - Getting '...' globals ... DONE
[09:29:45.702] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:45.702] List of 8
[09:29:45.702]  $ ...future.FUN:function (x, ...)  
[09:29:45.702]  $ x_FUN        :function (x)  
[09:29:45.702]  $ times        : int 1
[09:29:45.702]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.702]  $ stop_if_not  :function (...)  
[09:29:45.702]  $ dim          : NULL
[09:29:45.702]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:45.702]  $ ...          : list()
[09:29:45.702]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.702]  - attr(*, "where")=List of 8
[09:29:45.702]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:45.702]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:45.702]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:45.702]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:45.702]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:45.702]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:45.702]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:45.702]   ..$ ...          :<environment: 0x561d3686b538> 
[09:29:45.702]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.702]  - attr(*, "resolved")= logi FALSE
[09:29:45.702]  - attr(*, "total_size")= num 94336
[09:29:45.707] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:45.707] getGlobalsAndPackagesXApply() ... DONE
[09:29:45.707] Number of futures (= number of chunks): 1
[09:29:45.707] Launching 1 futures (chunks) ...
[09:29:45.707] Chunk #1 of 1 ...
[09:29:45.707]  - Finding globals in 'X' for chunk #1 ...
[09:29:45.707] getGlobalsAndPackages() ...
[09:29:45.707] Searching for globals...
[09:29:45.708] 
[09:29:45.708] Searching for globals ... DONE
[09:29:45.708] - globals: [0] <none>
[09:29:45.708] getGlobalsAndPackages() ... DONE
[09:29:45.708]    + additional globals found: [n=0] 
[09:29:45.708]    + additional namespaces needed: [n=0] 
[09:29:45.708]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:45.708]  - seeds: <none>
[09:29:45.708]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.708] getGlobalsAndPackages() ...
[09:29:45.708] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.709] Resolving globals: FALSE
[09:29:45.709] Tweak future expression to call with '...' arguments ...
[09:29:45.709] {
[09:29:45.709]     do.call(function(...) {
[09:29:45.709]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.709]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.709]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.709]             on.exit(options(oopts), add = TRUE)
[09:29:45.709]         }
[09:29:45.709]         {
[09:29:45.709]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.709]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.709]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.709]             })
[09:29:45.709]         }
[09:29:45.709]     }, args = future.call.arguments)
[09:29:45.709] }
[09:29:45.709] Tweak future expression to call with '...' arguments ... DONE
[09:29:45.709] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.710] - packages: [1] ‘future.apply’
[09:29:45.710] getGlobalsAndPackages() ... DONE
[09:29:45.710] run() for ‘Future’ ...
[09:29:45.710] - state: ‘created’
[09:29:45.710] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:45.710] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.711] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:45.711]   - Field: ‘label’
[09:29:45.711]   - Field: ‘local’
[09:29:45.711]   - Field: ‘owner’
[09:29:45.711]   - Field: ‘envir’
[09:29:45.711]   - Field: ‘packages’
[09:29:45.711]   - Field: ‘gc’
[09:29:45.711]   - Field: ‘conditions’
[09:29:45.711]   - Field: ‘expr’
[09:29:45.711]   - Field: ‘uuid’
[09:29:45.711]   - Field: ‘seed’
[09:29:45.711]   - Field: ‘version’
[09:29:45.712]   - Field: ‘result’
[09:29:45.712]   - Field: ‘asynchronous’
[09:29:45.712]   - Field: ‘calls’
[09:29:45.712]   - Field: ‘globals’
[09:29:45.712]   - Field: ‘stdout’
[09:29:45.712]   - Field: ‘earlySignal’
[09:29:45.712]   - Field: ‘lazy’
[09:29:45.712]   - Field: ‘state’
[09:29:45.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:45.712] - Launch lazy future ...
[09:29:45.713] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:45.713] Packages needed by future strategies (n = 0): <none>
[09:29:45.713] {
[09:29:45.713]     {
[09:29:45.713]         {
[09:29:45.713]             ...future.startTime <- base::Sys.time()
[09:29:45.713]             {
[09:29:45.713]                 {
[09:29:45.713]                   {
[09:29:45.713]                     {
[09:29:45.713]                       base::local({
[09:29:45.713]                         has_future <- base::requireNamespace("future", 
[09:29:45.713]                           quietly = TRUE)
[09:29:45.713]                         if (has_future) {
[09:29:45.713]                           ns <- base::getNamespace("future")
[09:29:45.713]                           version <- ns[[".package"]][["version"]]
[09:29:45.713]                           if (is.null(version)) 
[09:29:45.713]                             version <- utils::packageVersion("future")
[09:29:45.713]                         }
[09:29:45.713]                         else {
[09:29:45.713]                           version <- NULL
[09:29:45.713]                         }
[09:29:45.713]                         if (!has_future || version < "1.8.0") {
[09:29:45.713]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:45.713]                             "", base::R.version$version.string), 
[09:29:45.713]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:45.713]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:45.713]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:45.713]                               "release", "version")], collapse = " "), 
[09:29:45.713]                             hostname = base::Sys.info()[["nodename"]])
[09:29:45.713]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:45.713]                             info)
[09:29:45.713]                           info <- base::paste(info, collapse = "; ")
[09:29:45.713]                           if (!has_future) {
[09:29:45.713]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:45.713]                               info)
[09:29:45.713]                           }
[09:29:45.713]                           else {
[09:29:45.713]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:45.713]                               info, version)
[09:29:45.713]                           }
[09:29:45.713]                           base::stop(msg)
[09:29:45.713]                         }
[09:29:45.713]                       })
[09:29:45.713]                     }
[09:29:45.713]                     base::local({
[09:29:45.713]                       for (pkg in "future.apply") {
[09:29:45.713]                         base::loadNamespace(pkg)
[09:29:45.713]                         base::library(pkg, character.only = TRUE)
[09:29:45.713]                       }
[09:29:45.713]                     })
[09:29:45.713]                   }
[09:29:45.713]                   ...future.strategy.old <- future::plan("list")
[09:29:45.713]                   options(future.plan = NULL)
[09:29:45.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:45.713]                 }
[09:29:45.713]                 ...future.workdir <- getwd()
[09:29:45.713]             }
[09:29:45.713]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:45.713]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:45.713]         }
[09:29:45.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:45.713]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:45.713]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:45.713]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:45.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:45.713]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:45.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:45.713]             base::names(...future.oldOptions))
[09:29:45.713]     }
[09:29:45.713]     if (FALSE) {
[09:29:45.713]     }
[09:29:45.713]     else {
[09:29:45.713]         if (TRUE) {
[09:29:45.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:45.713]                 open = "w")
[09:29:45.713]         }
[09:29:45.713]         else {
[09:29:45.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:45.713]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:45.713]         }
[09:29:45.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:45.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:45.713]             base::sink(type = "output", split = FALSE)
[09:29:45.713]             base::close(...future.stdout)
[09:29:45.713]         }, add = TRUE)
[09:29:45.713]     }
[09:29:45.713]     ...future.frame <- base::sys.nframe()
[09:29:45.713]     ...future.conditions <- base::list()
[09:29:45.713]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:45.713]     if (FALSE) {
[09:29:45.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:45.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:45.713]     }
[09:29:45.713]     ...future.result <- base::tryCatch({
[09:29:45.713]         base::withCallingHandlers({
[09:29:45.713]             ...future.value <- base::withVisible(base::local({
[09:29:45.713]                 do.call(function(...) {
[09:29:45.713]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.713]                   if (!identical(...future.globals.maxSize.org, 
[09:29:45.713]                     ...future.globals.maxSize)) {
[09:29:45.713]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.713]                     on.exit(options(oopts), add = TRUE)
[09:29:45.713]                   }
[09:29:45.713]                   {
[09:29:45.713]                     lapply(seq_along(...future.elements_ii), 
[09:29:45.713]                       FUN = function(jj) {
[09:29:45.713]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.713]                         ...future.FUN(...future.X_jj, ...)
[09:29:45.713]                       })
[09:29:45.713]                   }
[09:29:45.713]                 }, args = future.call.arguments)
[09:29:45.713]             }))
[09:29:45.713]             future::FutureResult(value = ...future.value$value, 
[09:29:45.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.713]                   ...future.rng), globalenv = if (FALSE) 
[09:29:45.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:45.713]                     ...future.globalenv.names))
[09:29:45.713]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:45.713]         }, condition = base::local({
[09:29:45.713]             c <- base::c
[09:29:45.713]             inherits <- base::inherits
[09:29:45.713]             invokeRestart <- base::invokeRestart
[09:29:45.713]             length <- base::length
[09:29:45.713]             list <- base::list
[09:29:45.713]             seq.int <- base::seq.int
[09:29:45.713]             signalCondition <- base::signalCondition
[09:29:45.713]             sys.calls <- base::sys.calls
[09:29:45.713]             `[[` <- base::`[[`
[09:29:45.713]             `+` <- base::`+`
[09:29:45.713]             `<<-` <- base::`<<-`
[09:29:45.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:45.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:45.713]                   3L)]
[09:29:45.713]             }
[09:29:45.713]             function(cond) {
[09:29:45.713]                 is_error <- inherits(cond, "error")
[09:29:45.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:45.713]                   NULL)
[09:29:45.713]                 if (is_error) {
[09:29:45.713]                   sessionInformation <- function() {
[09:29:45.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:45.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:45.713]                       search = base::search(), system = base::Sys.info())
[09:29:45.713]                   }
[09:29:45.713]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:45.713]                     cond$call), session = sessionInformation(), 
[09:29:45.713]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:45.713]                   signalCondition(cond)
[09:29:45.713]                 }
[09:29:45.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:45.713]                 "immediateCondition"))) {
[09:29:45.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:45.713]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:45.713]                   if (TRUE && !signal) {
[09:29:45.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.713]                     {
[09:29:45.713]                       inherits <- base::inherits
[09:29:45.713]                       invokeRestart <- base::invokeRestart
[09:29:45.713]                       is.null <- base::is.null
[09:29:45.713]                       muffled <- FALSE
[09:29:45.713]                       if (inherits(cond, "message")) {
[09:29:45.713]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.713]                         if (muffled) 
[09:29:45.713]                           invokeRestart("muffleMessage")
[09:29:45.713]                       }
[09:29:45.713]                       else if (inherits(cond, "warning")) {
[09:29:45.713]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.713]                         if (muffled) 
[09:29:45.713]                           invokeRestart("muffleWarning")
[09:29:45.713]                       }
[09:29:45.713]                       else if (inherits(cond, "condition")) {
[09:29:45.713]                         if (!is.null(pattern)) {
[09:29:45.713]                           computeRestarts <- base::computeRestarts
[09:29:45.713]                           grepl <- base::grepl
[09:29:45.713]                           restarts <- computeRestarts(cond)
[09:29:45.713]                           for (restart in restarts) {
[09:29:45.713]                             name <- restart$name
[09:29:45.713]                             if (is.null(name)) 
[09:29:45.713]                               next
[09:29:45.713]                             if (!grepl(pattern, name)) 
[09:29:45.713]                               next
[09:29:45.713]                             invokeRestart(restart)
[09:29:45.713]                             muffled <- TRUE
[09:29:45.713]                             break
[09:29:45.713]                           }
[09:29:45.713]                         }
[09:29:45.713]                       }
[09:29:45.713]                       invisible(muffled)
[09:29:45.713]                     }
[09:29:45.713]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.713]                   }
[09:29:45.713]                 }
[09:29:45.713]                 else {
[09:29:45.713]                   if (TRUE) {
[09:29:45.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.713]                     {
[09:29:45.713]                       inherits <- base::inherits
[09:29:45.713]                       invokeRestart <- base::invokeRestart
[09:29:45.713]                       is.null <- base::is.null
[09:29:45.713]                       muffled <- FALSE
[09:29:45.713]                       if (inherits(cond, "message")) {
[09:29:45.713]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.713]                         if (muffled) 
[09:29:45.713]                           invokeRestart("muffleMessage")
[09:29:45.713]                       }
[09:29:45.713]                       else if (inherits(cond, "warning")) {
[09:29:45.713]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.713]                         if (muffled) 
[09:29:45.713]                           invokeRestart("muffleWarning")
[09:29:45.713]                       }
[09:29:45.713]                       else if (inherits(cond, "condition")) {
[09:29:45.713]                         if (!is.null(pattern)) {
[09:29:45.713]                           computeRestarts <- base::computeRestarts
[09:29:45.713]                           grepl <- base::grepl
[09:29:45.713]                           restarts <- computeRestarts(cond)
[09:29:45.713]                           for (restart in restarts) {
[09:29:45.713]                             name <- restart$name
[09:29:45.713]                             if (is.null(name)) 
[09:29:45.713]                               next
[09:29:45.713]                             if (!grepl(pattern, name)) 
[09:29:45.713]                               next
[09:29:45.713]                             invokeRestart(restart)
[09:29:45.713]                             muffled <- TRUE
[09:29:45.713]                             break
[09:29:45.713]                           }
[09:29:45.713]                         }
[09:29:45.713]                       }
[09:29:45.713]                       invisible(muffled)
[09:29:45.713]                     }
[09:29:45.713]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.713]                   }
[09:29:45.713]                 }
[09:29:45.713]             }
[09:29:45.713]         }))
[09:29:45.713]     }, error = function(ex) {
[09:29:45.713]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:45.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.713]                 ...future.rng), started = ...future.startTime, 
[09:29:45.713]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:45.713]             version = "1.8"), class = "FutureResult")
[09:29:45.713]     }, finally = {
[09:29:45.713]         if (!identical(...future.workdir, getwd())) 
[09:29:45.713]             setwd(...future.workdir)
[09:29:45.713]         {
[09:29:45.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:45.713]                 ...future.oldOptions$nwarnings <- NULL
[09:29:45.713]             }
[09:29:45.713]             base::options(...future.oldOptions)
[09:29:45.713]             if (.Platform$OS.type == "windows") {
[09:29:45.713]                 old_names <- names(...future.oldEnvVars)
[09:29:45.713]                 envs <- base::Sys.getenv()
[09:29:45.713]                 names <- names(envs)
[09:29:45.713]                 common <- intersect(names, old_names)
[09:29:45.713]                 added <- setdiff(names, old_names)
[09:29:45.713]                 removed <- setdiff(old_names, names)
[09:29:45.713]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:45.713]                   envs[common]]
[09:29:45.713]                 NAMES <- toupper(changed)
[09:29:45.713]                 args <- list()
[09:29:45.713]                 for (kk in seq_along(NAMES)) {
[09:29:45.713]                   name <- changed[[kk]]
[09:29:45.713]                   NAME <- NAMES[[kk]]
[09:29:45.713]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.713]                     next
[09:29:45.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.713]                 }
[09:29:45.713]                 NAMES <- toupper(added)
[09:29:45.713]                 for (kk in seq_along(NAMES)) {
[09:29:45.713]                   name <- added[[kk]]
[09:29:45.713]                   NAME <- NAMES[[kk]]
[09:29:45.713]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.713]                     next
[09:29:45.713]                   args[[name]] <- ""
[09:29:45.713]                 }
[09:29:45.713]                 NAMES <- toupper(removed)
[09:29:45.713]                 for (kk in seq_along(NAMES)) {
[09:29:45.713]                   name <- removed[[kk]]
[09:29:45.713]                   NAME <- NAMES[[kk]]
[09:29:45.713]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.713]                     next
[09:29:45.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.713]                 }
[09:29:45.713]                 if (length(args) > 0) 
[09:29:45.713]                   base::do.call(base::Sys.setenv, args = args)
[09:29:45.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:45.713]             }
[09:29:45.713]             else {
[09:29:45.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:45.713]             }
[09:29:45.713]             {
[09:29:45.713]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:45.713]                   0L) {
[09:29:45.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:45.713]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:45.713]                   base::options(opts)
[09:29:45.713]                 }
[09:29:45.713]                 {
[09:29:45.713]                   {
[09:29:45.713]                     NULL
[09:29:45.713]                     RNGkind("Mersenne-Twister")
[09:29:45.713]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:45.713]                       inherits = FALSE)
[09:29:45.713]                   }
[09:29:45.713]                   options(future.plan = NULL)
[09:29:45.713]                   if (is.na(NA_character_)) 
[09:29:45.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:45.713]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:45.713]                     .init = FALSE)
[09:29:45.713]                 }
[09:29:45.713]             }
[09:29:45.713]         }
[09:29:45.713]     })
[09:29:45.713]     if (TRUE) {
[09:29:45.713]         base::sink(type = "output", split = FALSE)
[09:29:45.713]         if (TRUE) {
[09:29:45.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:45.713]         }
[09:29:45.713]         else {
[09:29:45.713]             ...future.result["stdout"] <- base::list(NULL)
[09:29:45.713]         }
[09:29:45.713]         base::close(...future.stdout)
[09:29:45.713]         ...future.stdout <- NULL
[09:29:45.713]     }
[09:29:45.713]     ...future.result$conditions <- ...future.conditions
[09:29:45.713]     ...future.result$finished <- base::Sys.time()
[09:29:45.713]     ...future.result
[09:29:45.713] }
[09:29:45.715] assign_globals() ...
[09:29:45.715] List of 11
[09:29:45.715]  $ ...future.FUN            :function (x, ...)  
[09:29:45.715]  $ x_FUN                    :function (x)  
[09:29:45.715]  $ times                    : int 1
[09:29:45.715]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.715]  $ stop_if_not              :function (...)  
[09:29:45.715]  $ dim                      : NULL
[09:29:45.715]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:45.715]  $ future.call.arguments    : list()
[09:29:45.715]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.715]  $ ...future.elements_ii    :List of 10
[09:29:45.715]   ..$ : int 1
[09:29:45.715]   ..$ : int 2
[09:29:45.715]   ..$ : int 3
[09:29:45.715]   ..$ : int 4
[09:29:45.715]   ..$ : int 5
[09:29:45.715]   ..$ : int 6
[09:29:45.715]   ..$ : int 7
[09:29:45.715]   ..$ : int 8
[09:29:45.715]   ..$ : int 9
[09:29:45.715]   ..$ : int 10
[09:29:45.715]  $ ...future.seeds_ii       : NULL
[09:29:45.715]  $ ...future.globals.maxSize: NULL
[09:29:45.715]  - attr(*, "where")=List of 11
[09:29:45.715]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:45.715]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:45.715]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:45.715]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:45.715]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:45.715]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:45.715]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:45.715]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:45.715]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:45.715]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:45.715]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:45.715]  - attr(*, "resolved")= logi FALSE
[09:29:45.715]  - attr(*, "total_size")= num 94336
[09:29:45.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.715]  - attr(*, "already-done")= logi TRUE
[09:29:45.725] - copied ‘...future.FUN’ to environment
[09:29:45.725] - copied ‘x_FUN’ to environment
[09:29:45.725] - copied ‘times’ to environment
[09:29:45.725] - copied ‘stopf’ to environment
[09:29:45.725] - copied ‘stop_if_not’ to environment
[09:29:45.726] - copied ‘dim’ to environment
[09:29:45.726] - copied ‘valid_types’ to environment
[09:29:45.726] - copied ‘future.call.arguments’ to environment
[09:29:45.726] - copied ‘...future.elements_ii’ to environment
[09:29:45.726] - copied ‘...future.seeds_ii’ to environment
[09:29:45.726] - copied ‘...future.globals.maxSize’ to environment
[09:29:45.726] assign_globals() ... done
[09:29:45.726] plan(): Setting new future strategy stack:
[09:29:45.727] List of future strategies:
[09:29:45.727] 1. sequential:
[09:29:45.727]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.727]    - tweaked: FALSE
[09:29:45.727]    - call: NULL
[09:29:45.727] plan(): nbrOfWorkers() = 1
[09:29:45.728] plan(): Setting new future strategy stack:
[09:29:45.728] List of future strategies:
[09:29:45.728] 1. sequential:
[09:29:45.728]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.728]    - tweaked: FALSE
[09:29:45.728]    - call: plan(strategy)
[09:29:45.728] plan(): nbrOfWorkers() = 1
[09:29:45.728] SequentialFuture started (and completed)
[09:29:45.728] - Launch lazy future ... done
[09:29:45.729] run() for ‘SequentialFuture’ ... done
[09:29:45.729] Created future:
[09:29:45.729] SequentialFuture:
[09:29:45.729] Label: ‘future_vapply-1’
[09:29:45.729] Expression:
[09:29:45.729] {
[09:29:45.729]     do.call(function(...) {
[09:29:45.729]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.729]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.729]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.729]             on.exit(options(oopts), add = TRUE)
[09:29:45.729]         }
[09:29:45.729]         {
[09:29:45.729]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.729]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.729]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.729]             })
[09:29:45.729]         }
[09:29:45.729]     }, args = future.call.arguments)
[09:29:45.729] }
[09:29:45.729] Lazy evaluation: FALSE
[09:29:45.729] Asynchronous evaluation: FALSE
[09:29:45.729] Local evaluation: TRUE
[09:29:45.729] Environment: R_GlobalEnv
[09:29:45.729] Capture standard output: TRUE
[09:29:45.729] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:45.729] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:45.729] Packages: 1 packages (‘future.apply’)
[09:29:45.729] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:45.729] Resolved: TRUE
[09:29:45.729] Value: 560 bytes of class ‘list’
[09:29:45.729] Early signaling: FALSE
[09:29:45.729] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:45.729] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.730] Chunk #1 of 1 ... DONE
[09:29:45.730] Launching 1 futures (chunks) ... DONE
[09:29:45.730] Resolving 1 futures (chunks) ...
[09:29:45.730] resolve() on list ...
[09:29:45.730]  recursive: 0
[09:29:45.730]  length: 1
[09:29:45.730] 
[09:29:45.730] resolved() for ‘SequentialFuture’ ...
[09:29:45.731] - state: ‘finished’
[09:29:45.731] - run: TRUE
[09:29:45.731] - result: ‘FutureResult’
[09:29:45.731] resolved() for ‘SequentialFuture’ ... done
[09:29:45.731] Future #1
[09:29:45.731] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:45.731] - nx: 1
[09:29:45.731] - relay: TRUE
[09:29:45.731] - stdout: TRUE
[09:29:45.731] - signal: TRUE
[09:29:45.732] - resignal: FALSE
[09:29:45.732] - force: TRUE
[09:29:45.732] - relayed: [n=1] FALSE
[09:29:45.732] - queued futures: [n=1] FALSE
[09:29:45.732]  - until=1
[09:29:45.732]  - relaying element #1
[09:29:45.732] - relayed: [n=1] TRUE
[09:29:45.732] - queued futures: [n=1] TRUE
[09:29:45.732] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:45.732]  length: 0 (resolved future 1)
[09:29:45.733] Relaying remaining futures
[09:29:45.733] signalConditionsASAP(NULL, pos=0) ...
[09:29:45.733] - nx: 1
[09:29:45.733] - relay: TRUE
[09:29:45.733] - stdout: TRUE
[09:29:45.733] - signal: TRUE
[09:29:45.733] - resignal: FALSE
[09:29:45.733] - force: TRUE
[09:29:45.733] - relayed: [n=1] TRUE
[09:29:45.733] - queued futures: [n=1] TRUE
 - flush all
[09:29:45.733] - relayed: [n=1] TRUE
[09:29:45.733] - queued futures: [n=1] TRUE
[09:29:45.734] signalConditionsASAP(NULL, pos=0) ... done
[09:29:45.734] resolve() on list ... DONE
[09:29:45.734]  - Number of value chunks collected: 1
[09:29:45.734] Resolving 1 futures (chunks) ... DONE
[09:29:45.734] Reducing values from 1 chunks ...
[09:29:45.734]  - Number of values collected after concatenation: 10
[09:29:45.734]  - Number of values expected: 10
[09:29:45.734] Reducing values from 1 chunks ... DONE
[09:29:45.734] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[09:29:45.735] future_lapply() ...
[09:29:45.736] Number of chunks: 1
[09:29:45.737] getGlobalsAndPackagesXApply() ...
[09:29:45.737]  - future.globals: TRUE
[09:29:45.737] getGlobalsAndPackages() ...
[09:29:45.737] Searching for globals...
[09:29:45.741] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[09:29:45.741] Searching for globals ... DONE
[09:29:45.741] Resolving globals: FALSE
[09:29:45.742] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[09:29:45.742] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:45.743] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.743] - packages: [1] ‘future.apply’
[09:29:45.743] getGlobalsAndPackages() ... DONE
[09:29:45.743]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.743]  - needed namespaces: [n=1] ‘future.apply’
[09:29:45.743] Finding globals ... DONE
[09:29:45.743]  - use_args: TRUE
[09:29:45.743]  - Getting '...' globals ...
[09:29:45.743] resolve() on list ...
[09:29:45.744]  recursive: 0
[09:29:45.744]  length: 1
[09:29:45.744]  elements: ‘...’
[09:29:45.744]  length: 0 (resolved future 1)
[09:29:45.744] resolve() on list ... DONE
[09:29:45.744]    - '...' content: [n=0] 
[09:29:45.744] List of 1
[09:29:45.744]  $ ...: list()
[09:29:45.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.744]  - attr(*, "where")=List of 1
[09:29:45.744]   ..$ ...:<environment: 0x561d3689b4c8> 
[09:29:45.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.744]  - attr(*, "resolved")= logi TRUE
[09:29:45.744]  - attr(*, "total_size")= num NA
[09:29:45.746]  - Getting '...' globals ... DONE
[09:29:45.747] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:45.747] List of 8
[09:29:45.747]  $ ...future.FUN:function (x, ...)  
[09:29:45.747]  $ x_FUN        :function (x)  
[09:29:45.747]  $ times        : int 2
[09:29:45.747]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.747]  $ stop_if_not  :function (...)  
[09:29:45.747]  $ dim          : NULL
[09:29:45.747]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:45.747]  $ ...          : list()
[09:29:45.747]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.747]  - attr(*, "where")=List of 8
[09:29:45.747]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:45.747]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:45.747]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:45.747]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:45.747]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:45.747]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:45.747]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:45.747]   ..$ ...          :<environment: 0x561d3689b4c8> 
[09:29:45.747]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.747]  - attr(*, "resolved")= logi FALSE
[09:29:45.747]  - attr(*, "total_size")= num 96456
[09:29:45.752] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:45.752] getGlobalsAndPackagesXApply() ... DONE
[09:29:45.752] Number of futures (= number of chunks): 1
[09:29:45.752] Launching 1 futures (chunks) ...
[09:29:45.752] Chunk #1 of 1 ...
[09:29:45.752]  - Finding globals in 'X' for chunk #1 ...
[09:29:45.752] getGlobalsAndPackages() ...
[09:29:45.752] Searching for globals...
[09:29:45.753] 
[09:29:45.753] Searching for globals ... DONE
[09:29:45.753] - globals: [0] <none>
[09:29:45.753] getGlobalsAndPackages() ... DONE
[09:29:45.753]    + additional globals found: [n=0] 
[09:29:45.753]    + additional namespaces needed: [n=0] 
[09:29:45.753]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:45.753]  - seeds: <none>
[09:29:45.753]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.753] getGlobalsAndPackages() ...
[09:29:45.753] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.754] Resolving globals: FALSE
[09:29:45.754] Tweak future expression to call with '...' arguments ...
[09:29:45.754] {
[09:29:45.754]     do.call(function(...) {
[09:29:45.754]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.754]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.754]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.754]             on.exit(options(oopts), add = TRUE)
[09:29:45.754]         }
[09:29:45.754]         {
[09:29:45.754]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.754]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.754]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.754]             })
[09:29:45.754]         }
[09:29:45.754]     }, args = future.call.arguments)
[09:29:45.754] }
[09:29:45.754] Tweak future expression to call with '...' arguments ... DONE
[09:29:45.754] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.755] - packages: [1] ‘future.apply’
[09:29:45.755] getGlobalsAndPackages() ... DONE
[09:29:45.755] run() for ‘Future’ ...
[09:29:45.755] - state: ‘created’
[09:29:45.755] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:45.755] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.755] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:45.756]   - Field: ‘label’
[09:29:45.756]   - Field: ‘local’
[09:29:45.756]   - Field: ‘owner’
[09:29:45.756]   - Field: ‘envir’
[09:29:45.756]   - Field: ‘packages’
[09:29:45.756]   - Field: ‘gc’
[09:29:45.756]   - Field: ‘conditions’
[09:29:45.756]   - Field: ‘expr’
[09:29:45.756]   - Field: ‘uuid’
[09:29:45.756]   - Field: ‘seed’
[09:29:45.756]   - Field: ‘version’
[09:29:45.757]   - Field: ‘result’
[09:29:45.757]   - Field: ‘asynchronous’
[09:29:45.757]   - Field: ‘calls’
[09:29:45.757]   - Field: ‘globals’
[09:29:45.757]   - Field: ‘stdout’
[09:29:45.757]   - Field: ‘earlySignal’
[09:29:45.757]   - Field: ‘lazy’
[09:29:45.757]   - Field: ‘state’
[09:29:45.757] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:45.757] - Launch lazy future ...
[09:29:45.757] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:45.758] Packages needed by future strategies (n = 0): <none>
[09:29:45.759] {
[09:29:45.759]     {
[09:29:45.759]         {
[09:29:45.759]             ...future.startTime <- base::Sys.time()
[09:29:45.759]             {
[09:29:45.759]                 {
[09:29:45.759]                   {
[09:29:45.759]                     {
[09:29:45.759]                       base::local({
[09:29:45.759]                         has_future <- base::requireNamespace("future", 
[09:29:45.759]                           quietly = TRUE)
[09:29:45.759]                         if (has_future) {
[09:29:45.759]                           ns <- base::getNamespace("future")
[09:29:45.759]                           version <- ns[[".package"]][["version"]]
[09:29:45.759]                           if (is.null(version)) 
[09:29:45.759]                             version <- utils::packageVersion("future")
[09:29:45.759]                         }
[09:29:45.759]                         else {
[09:29:45.759]                           version <- NULL
[09:29:45.759]                         }
[09:29:45.759]                         if (!has_future || version < "1.8.0") {
[09:29:45.759]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:45.759]                             "", base::R.version$version.string), 
[09:29:45.759]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:45.759]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:45.759]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:45.759]                               "release", "version")], collapse = " "), 
[09:29:45.759]                             hostname = base::Sys.info()[["nodename"]])
[09:29:45.759]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:45.759]                             info)
[09:29:45.759]                           info <- base::paste(info, collapse = "; ")
[09:29:45.759]                           if (!has_future) {
[09:29:45.759]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:45.759]                               info)
[09:29:45.759]                           }
[09:29:45.759]                           else {
[09:29:45.759]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:45.759]                               info, version)
[09:29:45.759]                           }
[09:29:45.759]                           base::stop(msg)
[09:29:45.759]                         }
[09:29:45.759]                       })
[09:29:45.759]                     }
[09:29:45.759]                     base::local({
[09:29:45.759]                       for (pkg in "future.apply") {
[09:29:45.759]                         base::loadNamespace(pkg)
[09:29:45.759]                         base::library(pkg, character.only = TRUE)
[09:29:45.759]                       }
[09:29:45.759]                     })
[09:29:45.759]                   }
[09:29:45.759]                   ...future.strategy.old <- future::plan("list")
[09:29:45.759]                   options(future.plan = NULL)
[09:29:45.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:45.759]                 }
[09:29:45.759]                 ...future.workdir <- getwd()
[09:29:45.759]             }
[09:29:45.759]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:45.759]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:45.759]         }
[09:29:45.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:45.759]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:45.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:45.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:45.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:45.759]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:45.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:45.759]             base::names(...future.oldOptions))
[09:29:45.759]     }
[09:29:45.759]     if (FALSE) {
[09:29:45.759]     }
[09:29:45.759]     else {
[09:29:45.759]         if (TRUE) {
[09:29:45.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:45.759]                 open = "w")
[09:29:45.759]         }
[09:29:45.759]         else {
[09:29:45.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:45.759]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:45.759]         }
[09:29:45.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:45.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:45.759]             base::sink(type = "output", split = FALSE)
[09:29:45.759]             base::close(...future.stdout)
[09:29:45.759]         }, add = TRUE)
[09:29:45.759]     }
[09:29:45.759]     ...future.frame <- base::sys.nframe()
[09:29:45.759]     ...future.conditions <- base::list()
[09:29:45.759]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:45.759]     if (FALSE) {
[09:29:45.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:45.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:45.759]     }
[09:29:45.759]     ...future.result <- base::tryCatch({
[09:29:45.759]         base::withCallingHandlers({
[09:29:45.759]             ...future.value <- base::withVisible(base::local({
[09:29:45.759]                 do.call(function(...) {
[09:29:45.759]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.759]                   if (!identical(...future.globals.maxSize.org, 
[09:29:45.759]                     ...future.globals.maxSize)) {
[09:29:45.759]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.759]                     on.exit(options(oopts), add = TRUE)
[09:29:45.759]                   }
[09:29:45.759]                   {
[09:29:45.759]                     lapply(seq_along(...future.elements_ii), 
[09:29:45.759]                       FUN = function(jj) {
[09:29:45.759]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.759]                         ...future.FUN(...future.X_jj, ...)
[09:29:45.759]                       })
[09:29:45.759]                   }
[09:29:45.759]                 }, args = future.call.arguments)
[09:29:45.759]             }))
[09:29:45.759]             future::FutureResult(value = ...future.value$value, 
[09:29:45.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.759]                   ...future.rng), globalenv = if (FALSE) 
[09:29:45.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:45.759]                     ...future.globalenv.names))
[09:29:45.759]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:45.759]         }, condition = base::local({
[09:29:45.759]             c <- base::c
[09:29:45.759]             inherits <- base::inherits
[09:29:45.759]             invokeRestart <- base::invokeRestart
[09:29:45.759]             length <- base::length
[09:29:45.759]             list <- base::list
[09:29:45.759]             seq.int <- base::seq.int
[09:29:45.759]             signalCondition <- base::signalCondition
[09:29:45.759]             sys.calls <- base::sys.calls
[09:29:45.759]             `[[` <- base::`[[`
[09:29:45.759]             `+` <- base::`+`
[09:29:45.759]             `<<-` <- base::`<<-`
[09:29:45.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:45.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:45.759]                   3L)]
[09:29:45.759]             }
[09:29:45.759]             function(cond) {
[09:29:45.759]                 is_error <- inherits(cond, "error")
[09:29:45.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:45.759]                   NULL)
[09:29:45.759]                 if (is_error) {
[09:29:45.759]                   sessionInformation <- function() {
[09:29:45.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:45.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:45.759]                       search = base::search(), system = base::Sys.info())
[09:29:45.759]                   }
[09:29:45.759]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:45.759]                     cond$call), session = sessionInformation(), 
[09:29:45.759]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:45.759]                   signalCondition(cond)
[09:29:45.759]                 }
[09:29:45.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:45.759]                 "immediateCondition"))) {
[09:29:45.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:45.759]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:45.759]                   if (TRUE && !signal) {
[09:29:45.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.759]                     {
[09:29:45.759]                       inherits <- base::inherits
[09:29:45.759]                       invokeRestart <- base::invokeRestart
[09:29:45.759]                       is.null <- base::is.null
[09:29:45.759]                       muffled <- FALSE
[09:29:45.759]                       if (inherits(cond, "message")) {
[09:29:45.759]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.759]                         if (muffled) 
[09:29:45.759]                           invokeRestart("muffleMessage")
[09:29:45.759]                       }
[09:29:45.759]                       else if (inherits(cond, "warning")) {
[09:29:45.759]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.759]                         if (muffled) 
[09:29:45.759]                           invokeRestart("muffleWarning")
[09:29:45.759]                       }
[09:29:45.759]                       else if (inherits(cond, "condition")) {
[09:29:45.759]                         if (!is.null(pattern)) {
[09:29:45.759]                           computeRestarts <- base::computeRestarts
[09:29:45.759]                           grepl <- base::grepl
[09:29:45.759]                           restarts <- computeRestarts(cond)
[09:29:45.759]                           for (restart in restarts) {
[09:29:45.759]                             name <- restart$name
[09:29:45.759]                             if (is.null(name)) 
[09:29:45.759]                               next
[09:29:45.759]                             if (!grepl(pattern, name)) 
[09:29:45.759]                               next
[09:29:45.759]                             invokeRestart(restart)
[09:29:45.759]                             muffled <- TRUE
[09:29:45.759]                             break
[09:29:45.759]                           }
[09:29:45.759]                         }
[09:29:45.759]                       }
[09:29:45.759]                       invisible(muffled)
[09:29:45.759]                     }
[09:29:45.759]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.759]                   }
[09:29:45.759]                 }
[09:29:45.759]                 else {
[09:29:45.759]                   if (TRUE) {
[09:29:45.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.759]                     {
[09:29:45.759]                       inherits <- base::inherits
[09:29:45.759]                       invokeRestart <- base::invokeRestart
[09:29:45.759]                       is.null <- base::is.null
[09:29:45.759]                       muffled <- FALSE
[09:29:45.759]                       if (inherits(cond, "message")) {
[09:29:45.759]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.759]                         if (muffled) 
[09:29:45.759]                           invokeRestart("muffleMessage")
[09:29:45.759]                       }
[09:29:45.759]                       else if (inherits(cond, "warning")) {
[09:29:45.759]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.759]                         if (muffled) 
[09:29:45.759]                           invokeRestart("muffleWarning")
[09:29:45.759]                       }
[09:29:45.759]                       else if (inherits(cond, "condition")) {
[09:29:45.759]                         if (!is.null(pattern)) {
[09:29:45.759]                           computeRestarts <- base::computeRestarts
[09:29:45.759]                           grepl <- base::grepl
[09:29:45.759]                           restarts <- computeRestarts(cond)
[09:29:45.759]                           for (restart in restarts) {
[09:29:45.759]                             name <- restart$name
[09:29:45.759]                             if (is.null(name)) 
[09:29:45.759]                               next
[09:29:45.759]                             if (!grepl(pattern, name)) 
[09:29:45.759]                               next
[09:29:45.759]                             invokeRestart(restart)
[09:29:45.759]                             muffled <- TRUE
[09:29:45.759]                             break
[09:29:45.759]                           }
[09:29:45.759]                         }
[09:29:45.759]                       }
[09:29:45.759]                       invisible(muffled)
[09:29:45.759]                     }
[09:29:45.759]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.759]                   }
[09:29:45.759]                 }
[09:29:45.759]             }
[09:29:45.759]         }))
[09:29:45.759]     }, error = function(ex) {
[09:29:45.759]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:45.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.759]                 ...future.rng), started = ...future.startTime, 
[09:29:45.759]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:45.759]             version = "1.8"), class = "FutureResult")
[09:29:45.759]     }, finally = {
[09:29:45.759]         if (!identical(...future.workdir, getwd())) 
[09:29:45.759]             setwd(...future.workdir)
[09:29:45.759]         {
[09:29:45.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:45.759]                 ...future.oldOptions$nwarnings <- NULL
[09:29:45.759]             }
[09:29:45.759]             base::options(...future.oldOptions)
[09:29:45.759]             if (.Platform$OS.type == "windows") {
[09:29:45.759]                 old_names <- names(...future.oldEnvVars)
[09:29:45.759]                 envs <- base::Sys.getenv()
[09:29:45.759]                 names <- names(envs)
[09:29:45.759]                 common <- intersect(names, old_names)
[09:29:45.759]                 added <- setdiff(names, old_names)
[09:29:45.759]                 removed <- setdiff(old_names, names)
[09:29:45.759]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:45.759]                   envs[common]]
[09:29:45.759]                 NAMES <- toupper(changed)
[09:29:45.759]                 args <- list()
[09:29:45.759]                 for (kk in seq_along(NAMES)) {
[09:29:45.759]                   name <- changed[[kk]]
[09:29:45.759]                   NAME <- NAMES[[kk]]
[09:29:45.759]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.759]                     next
[09:29:45.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.759]                 }
[09:29:45.759]                 NAMES <- toupper(added)
[09:29:45.759]                 for (kk in seq_along(NAMES)) {
[09:29:45.759]                   name <- added[[kk]]
[09:29:45.759]                   NAME <- NAMES[[kk]]
[09:29:45.759]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.759]                     next
[09:29:45.759]                   args[[name]] <- ""
[09:29:45.759]                 }
[09:29:45.759]                 NAMES <- toupper(removed)
[09:29:45.759]                 for (kk in seq_along(NAMES)) {
[09:29:45.759]                   name <- removed[[kk]]
[09:29:45.759]                   NAME <- NAMES[[kk]]
[09:29:45.759]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.759]                     next
[09:29:45.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.759]                 }
[09:29:45.759]                 if (length(args) > 0) 
[09:29:45.759]                   base::do.call(base::Sys.setenv, args = args)
[09:29:45.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:45.759]             }
[09:29:45.759]             else {
[09:29:45.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:45.759]             }
[09:29:45.759]             {
[09:29:45.759]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:45.759]                   0L) {
[09:29:45.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:45.759]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:45.759]                   base::options(opts)
[09:29:45.759]                 }
[09:29:45.759]                 {
[09:29:45.759]                   {
[09:29:45.759]                     NULL
[09:29:45.759]                     RNGkind("Mersenne-Twister")
[09:29:45.759]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:45.759]                       inherits = FALSE)
[09:29:45.759]                   }
[09:29:45.759]                   options(future.plan = NULL)
[09:29:45.759]                   if (is.na(NA_character_)) 
[09:29:45.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:45.759]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:45.759]                     .init = FALSE)
[09:29:45.759]                 }
[09:29:45.759]             }
[09:29:45.759]         }
[09:29:45.759]     })
[09:29:45.759]     if (TRUE) {
[09:29:45.759]         base::sink(type = "output", split = FALSE)
[09:29:45.759]         if (TRUE) {
[09:29:45.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:45.759]         }
[09:29:45.759]         else {
[09:29:45.759]             ...future.result["stdout"] <- base::list(NULL)
[09:29:45.759]         }
[09:29:45.759]         base::close(...future.stdout)
[09:29:45.759]         ...future.stdout <- NULL
[09:29:45.759]     }
[09:29:45.759]     ...future.result$conditions <- ...future.conditions
[09:29:45.759]     ...future.result$finished <- base::Sys.time()
[09:29:45.759]     ...future.result
[09:29:45.759] }
[09:29:45.761] assign_globals() ...
[09:29:45.761] List of 11
[09:29:45.761]  $ ...future.FUN            :function (x, ...)  
[09:29:45.761]  $ x_FUN                    :function (x)  
[09:29:45.761]  $ times                    : int 2
[09:29:45.761]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.761]  $ stop_if_not              :function (...)  
[09:29:45.761]  $ dim                      : NULL
[09:29:45.761]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:45.761]  $ future.call.arguments    : list()
[09:29:45.761]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.761]  $ ...future.elements_ii    :List of 10
[09:29:45.761]   ..$ : int 1
[09:29:45.761]   ..$ : int 2
[09:29:45.761]   ..$ : int 3
[09:29:45.761]   ..$ : int 4
[09:29:45.761]   ..$ : int 5
[09:29:45.761]   ..$ : int 6
[09:29:45.761]   ..$ : int 7
[09:29:45.761]   ..$ : int 8
[09:29:45.761]   ..$ : int 9
[09:29:45.761]   ..$ : int 10
[09:29:45.761]  $ ...future.seeds_ii       : NULL
[09:29:45.761]  $ ...future.globals.maxSize: NULL
[09:29:45.761]  - attr(*, "where")=List of 11
[09:29:45.761]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:45.761]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:45.761]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:45.761]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:45.761]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:45.761]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:45.761]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:45.761]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:45.761]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:45.761]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:45.761]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:45.761]  - attr(*, "resolved")= logi FALSE
[09:29:45.761]  - attr(*, "total_size")= num 96456
[09:29:45.761]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.761]  - attr(*, "already-done")= logi TRUE
[09:29:45.770] - copied ‘...future.FUN’ to environment
[09:29:45.770] - reassign environment for ‘x_FUN’
[09:29:45.770] - copied ‘x_FUN’ to environment
[09:29:45.770] - copied ‘times’ to environment
[09:29:45.770] - copied ‘stopf’ to environment
[09:29:45.770] - copied ‘stop_if_not’ to environment
[09:29:45.770] - copied ‘dim’ to environment
[09:29:45.770] - copied ‘valid_types’ to environment
[09:29:45.770] - copied ‘future.call.arguments’ to environment
[09:29:45.771] - copied ‘...future.elements_ii’ to environment
[09:29:45.771] - copied ‘...future.seeds_ii’ to environment
[09:29:45.771] - copied ‘...future.globals.maxSize’ to environment
[09:29:45.771] assign_globals() ... done
[09:29:45.771] plan(): Setting new future strategy stack:
[09:29:45.771] List of future strategies:
[09:29:45.771] 1. sequential:
[09:29:45.771]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.771]    - tweaked: FALSE
[09:29:45.771]    - call: NULL
[09:29:45.772] plan(): nbrOfWorkers() = 1
[09:29:45.772] plan(): Setting new future strategy stack:
[09:29:45.772] List of future strategies:
[09:29:45.772] 1. sequential:
[09:29:45.772]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.772]    - tweaked: FALSE
[09:29:45.772]    - call: plan(strategy)
[09:29:45.773] plan(): nbrOfWorkers() = 1
[09:29:45.773] SequentialFuture started (and completed)
[09:29:45.773] - Launch lazy future ... done
[09:29:45.773] run() for ‘SequentialFuture’ ... done
[09:29:45.773] Created future:
[09:29:45.773] SequentialFuture:
[09:29:45.773] Label: ‘future_vapply-1’
[09:29:45.773] Expression:
[09:29:45.773] {
[09:29:45.773]     do.call(function(...) {
[09:29:45.773]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.773]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.773]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.773]             on.exit(options(oopts), add = TRUE)
[09:29:45.773]         }
[09:29:45.773]         {
[09:29:45.773]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.773]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.773]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.773]             })
[09:29:45.773]         }
[09:29:45.773]     }, args = future.call.arguments)
[09:29:45.773] }
[09:29:45.773] Lazy evaluation: FALSE
[09:29:45.773] Asynchronous evaluation: FALSE
[09:29:45.773] Local evaluation: TRUE
[09:29:45.773] Environment: R_GlobalEnv
[09:29:45.773] Capture standard output: TRUE
[09:29:45.773] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:45.773] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:45.773] Packages: 1 packages (‘future.apply’)
[09:29:45.773] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:45.773] Resolved: TRUE
[09:29:45.773] Value: 640 bytes of class ‘list’
[09:29:45.773] Early signaling: FALSE
[09:29:45.773] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:45.773] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.775] Chunk #1 of 1 ... DONE
[09:29:45.775] Launching 1 futures (chunks) ... DONE
[09:29:45.775] Resolving 1 futures (chunks) ...
[09:29:45.775] resolve() on list ...
[09:29:45.775]  recursive: 0
[09:29:45.775]  length: 1
[09:29:45.775] 
[09:29:45.775] resolved() for ‘SequentialFuture’ ...
[09:29:45.775] - state: ‘finished’
[09:29:45.775] - run: TRUE
[09:29:45.775] - result: ‘FutureResult’
[09:29:45.776] resolved() for ‘SequentialFuture’ ... done
[09:29:45.776] Future #1
[09:29:45.776] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:45.776] - nx: 1
[09:29:45.776] - relay: TRUE
[09:29:45.776] - stdout: TRUE
[09:29:45.776] - signal: TRUE
[09:29:45.776] - resignal: FALSE
[09:29:45.776] - force: TRUE
[09:29:45.776] - relayed: [n=1] FALSE
[09:29:45.776] - queued futures: [n=1] FALSE
[09:29:45.776]  - until=1
[09:29:45.777]  - relaying element #1
[09:29:45.777] - relayed: [n=1] TRUE
[09:29:45.777] - queued futures: [n=1] TRUE
[09:29:45.777] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:45.777]  length: 0 (resolved future 1)
[09:29:45.777] Relaying remaining futures
[09:29:45.777] signalConditionsASAP(NULL, pos=0) ...
[09:29:45.777] - nx: 1
[09:29:45.777] - relay: TRUE
[09:29:45.777] - stdout: TRUE
[09:29:45.777] - signal: TRUE
[09:29:45.778] - resignal: FALSE
[09:29:45.778] - force: TRUE
[09:29:45.778] - relayed: [n=1] TRUE
[09:29:45.778] - queued futures: [n=1] TRUE
 - flush all
[09:29:45.778] - relayed: [n=1] TRUE
[09:29:45.778] - queued futures: [n=1] TRUE
[09:29:45.778] signalConditionsASAP(NULL, pos=0) ... done
[09:29:45.778] resolve() on list ... DONE
[09:29:45.778]  - Number of value chunks collected: 1
[09:29:45.778] Resolving 1 futures (chunks) ... DONE
[09:29:45.778] Reducing values from 1 chunks ...
[09:29:45.779]  - Number of values collected after concatenation: 10
[09:29:45.779]  - Number of values expected: 10
[09:29:45.779] Reducing values from 1 chunks ... DONE
[09:29:45.779] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[09:29:45.780] future_lapply() ...
[09:29:45.782] Number of chunks: 1
[09:29:45.783] getGlobalsAndPackagesXApply() ...
[09:29:45.783]  - future.globals: TRUE
[09:29:45.783] getGlobalsAndPackages() ...
[09:29:45.783] Searching for globals...
[09:29:45.786] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[09:29:45.786] Searching for globals ... DONE
[09:29:45.786] Resolving globals: FALSE
[09:29:45.787] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[09:29:45.787] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:45.788] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.788] - packages: [1] ‘future.apply’
[09:29:45.788] getGlobalsAndPackages() ... DONE
[09:29:45.788]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.788]  - needed namespaces: [n=1] ‘future.apply’
[09:29:45.788] Finding globals ... DONE
[09:29:45.788]  - use_args: TRUE
[09:29:45.788]  - Getting '...' globals ...
[09:29:45.789] resolve() on list ...
[09:29:45.789]  recursive: 0
[09:29:45.789]  length: 1
[09:29:45.789]  elements: ‘...’
[09:29:45.789]  length: 0 (resolved future 1)
[09:29:45.789] resolve() on list ... DONE
[09:29:45.789]    - '...' content: [n=0] 
[09:29:45.789] List of 1
[09:29:45.789]  $ ...: list()
[09:29:45.789]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.789]  - attr(*, "where")=List of 1
[09:29:45.789]   ..$ ...:<environment: 0x561d36a4c160> 
[09:29:45.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.789]  - attr(*, "resolved")= logi TRUE
[09:29:45.789]  - attr(*, "total_size")= num NA
[09:29:45.792]  - Getting '...' globals ... DONE
[09:29:45.792] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:45.792] List of 8
[09:29:45.792]  $ ...future.FUN:function (x, ...)  
[09:29:45.792]  $ x_FUN        :function (x)  
[09:29:45.792]  $ times        : int 4
[09:29:45.792]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.792]  $ stop_if_not  :function (...)  
[09:29:45.792]  $ dim          : int [1:2] 2 2
[09:29:45.792]  $ valid_types  : chr [1:2] "logical" "integer"
[09:29:45.792]  $ ...          : list()
[09:29:45.792]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.792]  - attr(*, "where")=List of 8
[09:29:45.792]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:45.792]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:45.792]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:45.792]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:45.792]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:45.792]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:45.792]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:45.792]   ..$ ...          :<environment: 0x561d36a4c160> 
[09:29:45.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.792]  - attr(*, "resolved")= logi FALSE
[09:29:45.792]  - attr(*, "total_size")= num 97232
[09:29:45.797] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:45.797] getGlobalsAndPackagesXApply() ... DONE
[09:29:45.798] Number of futures (= number of chunks): 1
[09:29:45.798] Launching 1 futures (chunks) ...
[09:29:45.798] Chunk #1 of 1 ...
[09:29:45.798]  - Finding globals in 'X' for chunk #1 ...
[09:29:45.798] getGlobalsAndPackages() ...
[09:29:45.798] Searching for globals...
[09:29:45.798] 
[09:29:45.798] Searching for globals ... DONE
[09:29:45.798] - globals: [0] <none>
[09:29:45.799] getGlobalsAndPackages() ... DONE
[09:29:45.799]    + additional globals found: [n=0] 
[09:29:45.799]    + additional namespaces needed: [n=0] 
[09:29:45.799]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:45.799]  - seeds: <none>
[09:29:45.799]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.799] getGlobalsAndPackages() ...
[09:29:45.799] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.799] Resolving globals: FALSE
[09:29:45.799] Tweak future expression to call with '...' arguments ...
[09:29:45.800] {
[09:29:45.800]     do.call(function(...) {
[09:29:45.800]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.800]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.800]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.800]             on.exit(options(oopts), add = TRUE)
[09:29:45.800]         }
[09:29:45.800]         {
[09:29:45.800]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.800]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.800]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.800]             })
[09:29:45.800]         }
[09:29:45.800]     }, args = future.call.arguments)
[09:29:45.800] }
[09:29:45.800] Tweak future expression to call with '...' arguments ... DONE
[09:29:45.800] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.800] - packages: [1] ‘future.apply’
[09:29:45.801] getGlobalsAndPackages() ... DONE
[09:29:45.801] run() for ‘Future’ ...
[09:29:45.801] - state: ‘created’
[09:29:45.801] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:45.801] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.803] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:45.803]   - Field: ‘label’
[09:29:45.803]   - Field: ‘local’
[09:29:45.803]   - Field: ‘owner’
[09:29:45.803]   - Field: ‘envir’
[09:29:45.804]   - Field: ‘packages’
[09:29:45.804]   - Field: ‘gc’
[09:29:45.804]   - Field: ‘conditions’
[09:29:45.804]   - Field: ‘expr’
[09:29:45.804]   - Field: ‘uuid’
[09:29:45.804]   - Field: ‘seed’
[09:29:45.804]   - Field: ‘version’
[09:29:45.804]   - Field: ‘result’
[09:29:45.804]   - Field: ‘asynchronous’
[09:29:45.804]   - Field: ‘calls’
[09:29:45.804]   - Field: ‘globals’
[09:29:45.805]   - Field: ‘stdout’
[09:29:45.805]   - Field: ‘earlySignal’
[09:29:45.805]   - Field: ‘lazy’
[09:29:45.805]   - Field: ‘state’
[09:29:45.805] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:45.805] - Launch lazy future ...
[09:29:45.805] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:45.805] Packages needed by future strategies (n = 0): <none>
[09:29:45.806] {
[09:29:45.806]     {
[09:29:45.806]         {
[09:29:45.806]             ...future.startTime <- base::Sys.time()
[09:29:45.806]             {
[09:29:45.806]                 {
[09:29:45.806]                   {
[09:29:45.806]                     {
[09:29:45.806]                       base::local({
[09:29:45.806]                         has_future <- base::requireNamespace("future", 
[09:29:45.806]                           quietly = TRUE)
[09:29:45.806]                         if (has_future) {
[09:29:45.806]                           ns <- base::getNamespace("future")
[09:29:45.806]                           version <- ns[[".package"]][["version"]]
[09:29:45.806]                           if (is.null(version)) 
[09:29:45.806]                             version <- utils::packageVersion("future")
[09:29:45.806]                         }
[09:29:45.806]                         else {
[09:29:45.806]                           version <- NULL
[09:29:45.806]                         }
[09:29:45.806]                         if (!has_future || version < "1.8.0") {
[09:29:45.806]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:45.806]                             "", base::R.version$version.string), 
[09:29:45.806]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:45.806]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:45.806]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:45.806]                               "release", "version")], collapse = " "), 
[09:29:45.806]                             hostname = base::Sys.info()[["nodename"]])
[09:29:45.806]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:45.806]                             info)
[09:29:45.806]                           info <- base::paste(info, collapse = "; ")
[09:29:45.806]                           if (!has_future) {
[09:29:45.806]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:45.806]                               info)
[09:29:45.806]                           }
[09:29:45.806]                           else {
[09:29:45.806]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:45.806]                               info, version)
[09:29:45.806]                           }
[09:29:45.806]                           base::stop(msg)
[09:29:45.806]                         }
[09:29:45.806]                       })
[09:29:45.806]                     }
[09:29:45.806]                     base::local({
[09:29:45.806]                       for (pkg in "future.apply") {
[09:29:45.806]                         base::loadNamespace(pkg)
[09:29:45.806]                         base::library(pkg, character.only = TRUE)
[09:29:45.806]                       }
[09:29:45.806]                     })
[09:29:45.806]                   }
[09:29:45.806]                   ...future.strategy.old <- future::plan("list")
[09:29:45.806]                   options(future.plan = NULL)
[09:29:45.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:45.806]                 }
[09:29:45.806]                 ...future.workdir <- getwd()
[09:29:45.806]             }
[09:29:45.806]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:45.806]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:45.806]         }
[09:29:45.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:45.806]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:45.806]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:45.806]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:45.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:45.806]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:45.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:45.806]             base::names(...future.oldOptions))
[09:29:45.806]     }
[09:29:45.806]     if (FALSE) {
[09:29:45.806]     }
[09:29:45.806]     else {
[09:29:45.806]         if (TRUE) {
[09:29:45.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:45.806]                 open = "w")
[09:29:45.806]         }
[09:29:45.806]         else {
[09:29:45.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:45.806]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:45.806]         }
[09:29:45.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:45.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:45.806]             base::sink(type = "output", split = FALSE)
[09:29:45.806]             base::close(...future.stdout)
[09:29:45.806]         }, add = TRUE)
[09:29:45.806]     }
[09:29:45.806]     ...future.frame <- base::sys.nframe()
[09:29:45.806]     ...future.conditions <- base::list()
[09:29:45.806]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:45.806]     if (FALSE) {
[09:29:45.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:45.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:45.806]     }
[09:29:45.806]     ...future.result <- base::tryCatch({
[09:29:45.806]         base::withCallingHandlers({
[09:29:45.806]             ...future.value <- base::withVisible(base::local({
[09:29:45.806]                 do.call(function(...) {
[09:29:45.806]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.806]                   if (!identical(...future.globals.maxSize.org, 
[09:29:45.806]                     ...future.globals.maxSize)) {
[09:29:45.806]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.806]                     on.exit(options(oopts), add = TRUE)
[09:29:45.806]                   }
[09:29:45.806]                   {
[09:29:45.806]                     lapply(seq_along(...future.elements_ii), 
[09:29:45.806]                       FUN = function(jj) {
[09:29:45.806]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.806]                         ...future.FUN(...future.X_jj, ...)
[09:29:45.806]                       })
[09:29:45.806]                   }
[09:29:45.806]                 }, args = future.call.arguments)
[09:29:45.806]             }))
[09:29:45.806]             future::FutureResult(value = ...future.value$value, 
[09:29:45.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.806]                   ...future.rng), globalenv = if (FALSE) 
[09:29:45.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:45.806]                     ...future.globalenv.names))
[09:29:45.806]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:45.806]         }, condition = base::local({
[09:29:45.806]             c <- base::c
[09:29:45.806]             inherits <- base::inherits
[09:29:45.806]             invokeRestart <- base::invokeRestart
[09:29:45.806]             length <- base::length
[09:29:45.806]             list <- base::list
[09:29:45.806]             seq.int <- base::seq.int
[09:29:45.806]             signalCondition <- base::signalCondition
[09:29:45.806]             sys.calls <- base::sys.calls
[09:29:45.806]             `[[` <- base::`[[`
[09:29:45.806]             `+` <- base::`+`
[09:29:45.806]             `<<-` <- base::`<<-`
[09:29:45.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:45.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:45.806]                   3L)]
[09:29:45.806]             }
[09:29:45.806]             function(cond) {
[09:29:45.806]                 is_error <- inherits(cond, "error")
[09:29:45.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:45.806]                   NULL)
[09:29:45.806]                 if (is_error) {
[09:29:45.806]                   sessionInformation <- function() {
[09:29:45.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:45.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:45.806]                       search = base::search(), system = base::Sys.info())
[09:29:45.806]                   }
[09:29:45.806]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:45.806]                     cond$call), session = sessionInformation(), 
[09:29:45.806]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:45.806]                   signalCondition(cond)
[09:29:45.806]                 }
[09:29:45.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:45.806]                 "immediateCondition"))) {
[09:29:45.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:45.806]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:45.806]                   if (TRUE && !signal) {
[09:29:45.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.806]                     {
[09:29:45.806]                       inherits <- base::inherits
[09:29:45.806]                       invokeRestart <- base::invokeRestart
[09:29:45.806]                       is.null <- base::is.null
[09:29:45.806]                       muffled <- FALSE
[09:29:45.806]                       if (inherits(cond, "message")) {
[09:29:45.806]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.806]                         if (muffled) 
[09:29:45.806]                           invokeRestart("muffleMessage")
[09:29:45.806]                       }
[09:29:45.806]                       else if (inherits(cond, "warning")) {
[09:29:45.806]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.806]                         if (muffled) 
[09:29:45.806]                           invokeRestart("muffleWarning")
[09:29:45.806]                       }
[09:29:45.806]                       else if (inherits(cond, "condition")) {
[09:29:45.806]                         if (!is.null(pattern)) {
[09:29:45.806]                           computeRestarts <- base::computeRestarts
[09:29:45.806]                           grepl <- base::grepl
[09:29:45.806]                           restarts <- computeRestarts(cond)
[09:29:45.806]                           for (restart in restarts) {
[09:29:45.806]                             name <- restart$name
[09:29:45.806]                             if (is.null(name)) 
[09:29:45.806]                               next
[09:29:45.806]                             if (!grepl(pattern, name)) 
[09:29:45.806]                               next
[09:29:45.806]                             invokeRestart(restart)
[09:29:45.806]                             muffled <- TRUE
[09:29:45.806]                             break
[09:29:45.806]                           }
[09:29:45.806]                         }
[09:29:45.806]                       }
[09:29:45.806]                       invisible(muffled)
[09:29:45.806]                     }
[09:29:45.806]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.806]                   }
[09:29:45.806]                 }
[09:29:45.806]                 else {
[09:29:45.806]                   if (TRUE) {
[09:29:45.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.806]                     {
[09:29:45.806]                       inherits <- base::inherits
[09:29:45.806]                       invokeRestart <- base::invokeRestart
[09:29:45.806]                       is.null <- base::is.null
[09:29:45.806]                       muffled <- FALSE
[09:29:45.806]                       if (inherits(cond, "message")) {
[09:29:45.806]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.806]                         if (muffled) 
[09:29:45.806]                           invokeRestart("muffleMessage")
[09:29:45.806]                       }
[09:29:45.806]                       else if (inherits(cond, "warning")) {
[09:29:45.806]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.806]                         if (muffled) 
[09:29:45.806]                           invokeRestart("muffleWarning")
[09:29:45.806]                       }
[09:29:45.806]                       else if (inherits(cond, "condition")) {
[09:29:45.806]                         if (!is.null(pattern)) {
[09:29:45.806]                           computeRestarts <- base::computeRestarts
[09:29:45.806]                           grepl <- base::grepl
[09:29:45.806]                           restarts <- computeRestarts(cond)
[09:29:45.806]                           for (restart in restarts) {
[09:29:45.806]                             name <- restart$name
[09:29:45.806]                             if (is.null(name)) 
[09:29:45.806]                               next
[09:29:45.806]                             if (!grepl(pattern, name)) 
[09:29:45.806]                               next
[09:29:45.806]                             invokeRestart(restart)
[09:29:45.806]                             muffled <- TRUE
[09:29:45.806]                             break
[09:29:45.806]                           }
[09:29:45.806]                         }
[09:29:45.806]                       }
[09:29:45.806]                       invisible(muffled)
[09:29:45.806]                     }
[09:29:45.806]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.806]                   }
[09:29:45.806]                 }
[09:29:45.806]             }
[09:29:45.806]         }))
[09:29:45.806]     }, error = function(ex) {
[09:29:45.806]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:45.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.806]                 ...future.rng), started = ...future.startTime, 
[09:29:45.806]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:45.806]             version = "1.8"), class = "FutureResult")
[09:29:45.806]     }, finally = {
[09:29:45.806]         if (!identical(...future.workdir, getwd())) 
[09:29:45.806]             setwd(...future.workdir)
[09:29:45.806]         {
[09:29:45.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:45.806]                 ...future.oldOptions$nwarnings <- NULL
[09:29:45.806]             }
[09:29:45.806]             base::options(...future.oldOptions)
[09:29:45.806]             if (.Platform$OS.type == "windows") {
[09:29:45.806]                 old_names <- names(...future.oldEnvVars)
[09:29:45.806]                 envs <- base::Sys.getenv()
[09:29:45.806]                 names <- names(envs)
[09:29:45.806]                 common <- intersect(names, old_names)
[09:29:45.806]                 added <- setdiff(names, old_names)
[09:29:45.806]                 removed <- setdiff(old_names, names)
[09:29:45.806]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:45.806]                   envs[common]]
[09:29:45.806]                 NAMES <- toupper(changed)
[09:29:45.806]                 args <- list()
[09:29:45.806]                 for (kk in seq_along(NAMES)) {
[09:29:45.806]                   name <- changed[[kk]]
[09:29:45.806]                   NAME <- NAMES[[kk]]
[09:29:45.806]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.806]                     next
[09:29:45.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.806]                 }
[09:29:45.806]                 NAMES <- toupper(added)
[09:29:45.806]                 for (kk in seq_along(NAMES)) {
[09:29:45.806]                   name <- added[[kk]]
[09:29:45.806]                   NAME <- NAMES[[kk]]
[09:29:45.806]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.806]                     next
[09:29:45.806]                   args[[name]] <- ""
[09:29:45.806]                 }
[09:29:45.806]                 NAMES <- toupper(removed)
[09:29:45.806]                 for (kk in seq_along(NAMES)) {
[09:29:45.806]                   name <- removed[[kk]]
[09:29:45.806]                   NAME <- NAMES[[kk]]
[09:29:45.806]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.806]                     next
[09:29:45.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.806]                 }
[09:29:45.806]                 if (length(args) > 0) 
[09:29:45.806]                   base::do.call(base::Sys.setenv, args = args)
[09:29:45.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:45.806]             }
[09:29:45.806]             else {
[09:29:45.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:45.806]             }
[09:29:45.806]             {
[09:29:45.806]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:45.806]                   0L) {
[09:29:45.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:45.806]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:45.806]                   base::options(opts)
[09:29:45.806]                 }
[09:29:45.806]                 {
[09:29:45.806]                   {
[09:29:45.806]                     NULL
[09:29:45.806]                     RNGkind("Mersenne-Twister")
[09:29:45.806]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:45.806]                       inherits = FALSE)
[09:29:45.806]                   }
[09:29:45.806]                   options(future.plan = NULL)
[09:29:45.806]                   if (is.na(NA_character_)) 
[09:29:45.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:45.806]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:45.806]                     .init = FALSE)
[09:29:45.806]                 }
[09:29:45.806]             }
[09:29:45.806]         }
[09:29:45.806]     })
[09:29:45.806]     if (TRUE) {
[09:29:45.806]         base::sink(type = "output", split = FALSE)
[09:29:45.806]         if (TRUE) {
[09:29:45.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:45.806]         }
[09:29:45.806]         else {
[09:29:45.806]             ...future.result["stdout"] <- base::list(NULL)
[09:29:45.806]         }
[09:29:45.806]         base::close(...future.stdout)
[09:29:45.806]         ...future.stdout <- NULL
[09:29:45.806]     }
[09:29:45.806]     ...future.result$conditions <- ...future.conditions
[09:29:45.806]     ...future.result$finished <- base::Sys.time()
[09:29:45.806]     ...future.result
[09:29:45.806] }
[09:29:45.807] assign_globals() ...
[09:29:45.808] List of 11
[09:29:45.808]  $ ...future.FUN            :function (x, ...)  
[09:29:45.808]  $ x_FUN                    :function (x)  
[09:29:45.808]  $ times                    : int 4
[09:29:45.808]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.808]  $ stop_if_not              :function (...)  
[09:29:45.808]  $ dim                      : int [1:2] 2 2
[09:29:45.808]  $ valid_types              : chr [1:2] "logical" "integer"
[09:29:45.808]  $ future.call.arguments    : list()
[09:29:45.808]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.808]  $ ...future.elements_ii    :List of 10
[09:29:45.808]   ..$ : int 1
[09:29:45.808]   ..$ : int 2
[09:29:45.808]   ..$ : int 3
[09:29:45.808]   ..$ : int 4
[09:29:45.808]   ..$ : int 5
[09:29:45.808]   ..$ : int 6
[09:29:45.808]   ..$ : int 7
[09:29:45.808]   ..$ : int 8
[09:29:45.808]   ..$ : int 9
[09:29:45.808]   ..$ : int 10
[09:29:45.808]  $ ...future.seeds_ii       : NULL
[09:29:45.808]  $ ...future.globals.maxSize: NULL
[09:29:45.808]  - attr(*, "where")=List of 11
[09:29:45.808]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:45.808]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:45.808]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:45.808]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:45.808]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:45.808]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:45.808]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:45.808]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:45.808]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:45.808]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:45.808]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:45.808]  - attr(*, "resolved")= logi FALSE
[09:29:45.808]  - attr(*, "total_size")= num 97232
[09:29:45.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.808]  - attr(*, "already-done")= logi TRUE
[09:29:45.817] - copied ‘...future.FUN’ to environment
[09:29:45.817] - reassign environment for ‘x_FUN’
[09:29:45.817] - copied ‘x_FUN’ to environment
[09:29:45.817] - copied ‘times’ to environment
[09:29:45.817] - copied ‘stopf’ to environment
[09:29:45.818] - copied ‘stop_if_not’ to environment
[09:29:45.818] - copied ‘dim’ to environment
[09:29:45.818] - copied ‘valid_types’ to environment
[09:29:45.818] - copied ‘future.call.arguments’ to environment
[09:29:45.818] - copied ‘...future.elements_ii’ to environment
[09:29:45.818] - copied ‘...future.seeds_ii’ to environment
[09:29:45.818] - copied ‘...future.globals.maxSize’ to environment
[09:29:45.818] assign_globals() ... done
[09:29:45.819] plan(): Setting new future strategy stack:
[09:29:45.819] List of future strategies:
[09:29:45.819] 1. sequential:
[09:29:45.819]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.819]    - tweaked: FALSE
[09:29:45.819]    - call: NULL
[09:29:45.819] plan(): nbrOfWorkers() = 1
[09:29:45.820] plan(): Setting new future strategy stack:
[09:29:45.820] List of future strategies:
[09:29:45.820] 1. sequential:
[09:29:45.820]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.820]    - tweaked: FALSE
[09:29:45.820]    - call: plan(strategy)
[09:29:45.820] plan(): nbrOfWorkers() = 1
[09:29:45.821] SequentialFuture started (and completed)
[09:29:45.821] - Launch lazy future ... done
[09:29:45.821] run() for ‘SequentialFuture’ ... done
[09:29:45.821] Created future:
[09:29:45.821] SequentialFuture:
[09:29:45.821] Label: ‘future_vapply-1’
[09:29:45.821] Expression:
[09:29:45.821] {
[09:29:45.821]     do.call(function(...) {
[09:29:45.821]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.821]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.821]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.821]             on.exit(options(oopts), add = TRUE)
[09:29:45.821]         }
[09:29:45.821]         {
[09:29:45.821]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.821]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.821]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.821]             })
[09:29:45.821]         }
[09:29:45.821]     }, args = future.call.arguments)
[09:29:45.821] }
[09:29:45.821] Lazy evaluation: FALSE
[09:29:45.821] Asynchronous evaluation: FALSE
[09:29:45.821] Local evaluation: TRUE
[09:29:45.821] Environment: R_GlobalEnv
[09:29:45.821] Capture standard output: TRUE
[09:29:45.821] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:45.821] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:45.821] Packages: 1 packages (‘future.apply’)
[09:29:45.821] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:45.821] Resolved: TRUE
[09:29:45.821] Value: 2.27 KiB of class ‘list’
[09:29:45.821] Early signaling: FALSE
[09:29:45.821] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:45.821] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.822] Chunk #1 of 1 ... DONE
[09:29:45.822] Launching 1 futures (chunks) ... DONE
[09:29:45.822] Resolving 1 futures (chunks) ...
[09:29:45.823] resolve() on list ...
[09:29:45.823]  recursive: 0
[09:29:45.823]  length: 1
[09:29:45.823] 
[09:29:45.823] resolved() for ‘SequentialFuture’ ...
[09:29:45.823] - state: ‘finished’
[09:29:45.823] - run: TRUE
[09:29:45.823] - result: ‘FutureResult’
[09:29:45.823] resolved() for ‘SequentialFuture’ ... done
[09:29:45.823] Future #1
[09:29:45.823] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:45.824] - nx: 1
[09:29:45.824] - relay: TRUE
[09:29:45.824] - stdout: TRUE
[09:29:45.824] - signal: TRUE
[09:29:45.824] - resignal: FALSE
[09:29:45.824] - force: TRUE
[09:29:45.824] - relayed: [n=1] FALSE
[09:29:45.824] - queued futures: [n=1] FALSE
[09:29:45.824]  - until=1
[09:29:45.824]  - relaying element #1
[09:29:45.825] - relayed: [n=1] TRUE
[09:29:45.825] - queued futures: [n=1] TRUE
[09:29:45.825] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:45.825]  length: 0 (resolved future 1)
[09:29:45.825] Relaying remaining futures
[09:29:45.826] signalConditionsASAP(NULL, pos=0) ...
[09:29:45.827] - nx: 1
[09:29:45.827] - relay: TRUE
[09:29:45.827] - stdout: TRUE
[09:29:45.827] - signal: TRUE
[09:29:45.827] - resignal: FALSE
[09:29:45.827] - force: TRUE
[09:29:45.827] - relayed: [n=1] TRUE
[09:29:45.827] - queued futures: [n=1] TRUE
 - flush all
[09:29:45.827] - relayed: [n=1] TRUE
[09:29:45.827] - queued futures: [n=1] TRUE
[09:29:45.827] signalConditionsASAP(NULL, pos=0) ... done
[09:29:45.828] resolve() on list ... DONE
[09:29:45.828]  - Number of value chunks collected: 1
[09:29:45.828] Resolving 1 futures (chunks) ... DONE
[09:29:45.828] Reducing values from 1 chunks ...
[09:29:45.828]  - Number of values collected after concatenation: 10
[09:29:45.828]  - Number of values expected: 10
[09:29:45.828] Reducing values from 1 chunks ... DONE
[09:29:45.828] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[09:29:45.829] future_lapply() ...
[09:29:45.831] Number of chunks: 1
[09:29:45.831] getGlobalsAndPackagesXApply() ...
[09:29:45.831]  - future.globals: TRUE
[09:29:45.831] getGlobalsAndPackages() ...
[09:29:45.831] Searching for globals...
[09:29:45.834] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[09:29:45.834] Searching for globals ... DONE
[09:29:45.835] Resolving globals: FALSE
[09:29:45.835] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[09:29:45.836] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:45.836] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.836] - packages: [1] ‘future.apply’
[09:29:45.836] getGlobalsAndPackages() ... DONE
[09:29:45.836]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.836]  - needed namespaces: [n=1] ‘future.apply’
[09:29:45.836] Finding globals ... DONE
[09:29:45.837]  - use_args: TRUE
[09:29:45.837]  - Getting '...' globals ...
[09:29:45.837] resolve() on list ...
[09:29:45.837]  recursive: 0
[09:29:45.837]  length: 1
[09:29:45.837]  elements: ‘...’
[09:29:45.837]  length: 0 (resolved future 1)
[09:29:45.837] resolve() on list ... DONE
[09:29:45.837]    - '...' content: [n=0] 
[09:29:45.838] List of 1
[09:29:45.838]  $ ...: list()
[09:29:45.838]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.838]  - attr(*, "where")=List of 1
[09:29:45.838]   ..$ ...:<environment: 0x561d34311980> 
[09:29:45.838]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.838]  - attr(*, "resolved")= logi TRUE
[09:29:45.838]  - attr(*, "total_size")= num NA
[09:29:45.840]  - Getting '...' globals ... DONE
[09:29:45.840] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:45.840] List of 8
[09:29:45.840]  $ ...future.FUN:function (x, ...)  
[09:29:45.840]  $ x_FUN        :function (x)  
[09:29:45.840]  $ times        : int 4
[09:29:45.840]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.840]  $ stop_if_not  :function (...)  
[09:29:45.840]  $ dim          : int [1:2] 2 2
[09:29:45.840]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:45.840]  $ ...          : list()
[09:29:45.840]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.840]  - attr(*, "where")=List of 8
[09:29:45.840]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:45.840]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:45.840]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:45.840]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:45.840]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:45.840]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:45.840]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:45.840]   ..$ ...          :<environment: 0x561d34311980> 
[09:29:45.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.840]  - attr(*, "resolved")= logi FALSE
[09:29:45.840]  - attr(*, "total_size")= num 97304
[09:29:45.845] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:45.846] getGlobalsAndPackagesXApply() ... DONE
[09:29:45.846] Number of futures (= number of chunks): 1
[09:29:45.846] Launching 1 futures (chunks) ...
[09:29:45.846] Chunk #1 of 1 ...
[09:29:45.846]  - Finding globals in 'X' for chunk #1 ...
[09:29:45.846] getGlobalsAndPackages() ...
[09:29:45.846] Searching for globals...
[09:29:45.848] 
[09:29:45.848] Searching for globals ... DONE
[09:29:45.848] - globals: [0] <none>
[09:29:45.848] getGlobalsAndPackages() ... DONE
[09:29:45.848]    + additional globals found: [n=0] 
[09:29:45.848]    + additional namespaces needed: [n=0] 
[09:29:45.849]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:45.849]  - seeds: <none>
[09:29:45.849]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.849] getGlobalsAndPackages() ...
[09:29:45.849] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.849] Resolving globals: FALSE
[09:29:45.849] Tweak future expression to call with '...' arguments ...
[09:29:45.849] {
[09:29:45.849]     do.call(function(...) {
[09:29:45.849]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.849]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.849]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.849]             on.exit(options(oopts), add = TRUE)
[09:29:45.849]         }
[09:29:45.849]         {
[09:29:45.849]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.849]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.849]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.849]             })
[09:29:45.849]         }
[09:29:45.849]     }, args = future.call.arguments)
[09:29:45.849] }
[09:29:45.849] Tweak future expression to call with '...' arguments ... DONE
[09:29:45.850] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.850] - packages: [1] ‘future.apply’
[09:29:45.850] getGlobalsAndPackages() ... DONE
[09:29:45.850] run() for ‘Future’ ...
[09:29:45.851] - state: ‘created’
[09:29:45.851] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:45.851] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.851] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:45.851]   - Field: ‘label’
[09:29:45.851]   - Field: ‘local’
[09:29:45.851]   - Field: ‘owner’
[09:29:45.851]   - Field: ‘envir’
[09:29:45.852]   - Field: ‘packages’
[09:29:45.852]   - Field: ‘gc’
[09:29:45.852]   - Field: ‘conditions’
[09:29:45.852]   - Field: ‘expr’
[09:29:45.852]   - Field: ‘uuid’
[09:29:45.852]   - Field: ‘seed’
[09:29:45.852]   - Field: ‘version’
[09:29:45.852]   - Field: ‘result’
[09:29:45.852]   - Field: ‘asynchronous’
[09:29:45.852]   - Field: ‘calls’
[09:29:45.852]   - Field: ‘globals’
[09:29:45.853]   - Field: ‘stdout’
[09:29:45.853]   - Field: ‘earlySignal’
[09:29:45.853]   - Field: ‘lazy’
[09:29:45.853]   - Field: ‘state’
[09:29:45.853] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:45.853] - Launch lazy future ...
[09:29:45.853] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:45.853] Packages needed by future strategies (n = 0): <none>
[09:29:45.854] {
[09:29:45.854]     {
[09:29:45.854]         {
[09:29:45.854]             ...future.startTime <- base::Sys.time()
[09:29:45.854]             {
[09:29:45.854]                 {
[09:29:45.854]                   {
[09:29:45.854]                     {
[09:29:45.854]                       base::local({
[09:29:45.854]                         has_future <- base::requireNamespace("future", 
[09:29:45.854]                           quietly = TRUE)
[09:29:45.854]                         if (has_future) {
[09:29:45.854]                           ns <- base::getNamespace("future")
[09:29:45.854]                           version <- ns[[".package"]][["version"]]
[09:29:45.854]                           if (is.null(version)) 
[09:29:45.854]                             version <- utils::packageVersion("future")
[09:29:45.854]                         }
[09:29:45.854]                         else {
[09:29:45.854]                           version <- NULL
[09:29:45.854]                         }
[09:29:45.854]                         if (!has_future || version < "1.8.0") {
[09:29:45.854]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:45.854]                             "", base::R.version$version.string), 
[09:29:45.854]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:45.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:45.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:45.854]                               "release", "version")], collapse = " "), 
[09:29:45.854]                             hostname = base::Sys.info()[["nodename"]])
[09:29:45.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:45.854]                             info)
[09:29:45.854]                           info <- base::paste(info, collapse = "; ")
[09:29:45.854]                           if (!has_future) {
[09:29:45.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:45.854]                               info)
[09:29:45.854]                           }
[09:29:45.854]                           else {
[09:29:45.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:45.854]                               info, version)
[09:29:45.854]                           }
[09:29:45.854]                           base::stop(msg)
[09:29:45.854]                         }
[09:29:45.854]                       })
[09:29:45.854]                     }
[09:29:45.854]                     base::local({
[09:29:45.854]                       for (pkg in "future.apply") {
[09:29:45.854]                         base::loadNamespace(pkg)
[09:29:45.854]                         base::library(pkg, character.only = TRUE)
[09:29:45.854]                       }
[09:29:45.854]                     })
[09:29:45.854]                   }
[09:29:45.854]                   ...future.strategy.old <- future::plan("list")
[09:29:45.854]                   options(future.plan = NULL)
[09:29:45.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:45.854]                 }
[09:29:45.854]                 ...future.workdir <- getwd()
[09:29:45.854]             }
[09:29:45.854]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:45.854]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:45.854]         }
[09:29:45.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:45.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:45.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:45.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:45.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:45.854]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:45.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:45.854]             base::names(...future.oldOptions))
[09:29:45.854]     }
[09:29:45.854]     if (FALSE) {
[09:29:45.854]     }
[09:29:45.854]     else {
[09:29:45.854]         if (TRUE) {
[09:29:45.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:45.854]                 open = "w")
[09:29:45.854]         }
[09:29:45.854]         else {
[09:29:45.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:45.854]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:45.854]         }
[09:29:45.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:45.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:45.854]             base::sink(type = "output", split = FALSE)
[09:29:45.854]             base::close(...future.stdout)
[09:29:45.854]         }, add = TRUE)
[09:29:45.854]     }
[09:29:45.854]     ...future.frame <- base::sys.nframe()
[09:29:45.854]     ...future.conditions <- base::list()
[09:29:45.854]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:45.854]     if (FALSE) {
[09:29:45.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:45.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:45.854]     }
[09:29:45.854]     ...future.result <- base::tryCatch({
[09:29:45.854]         base::withCallingHandlers({
[09:29:45.854]             ...future.value <- base::withVisible(base::local({
[09:29:45.854]                 do.call(function(...) {
[09:29:45.854]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.854]                   if (!identical(...future.globals.maxSize.org, 
[09:29:45.854]                     ...future.globals.maxSize)) {
[09:29:45.854]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.854]                     on.exit(options(oopts), add = TRUE)
[09:29:45.854]                   }
[09:29:45.854]                   {
[09:29:45.854]                     lapply(seq_along(...future.elements_ii), 
[09:29:45.854]                       FUN = function(jj) {
[09:29:45.854]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.854]                         ...future.FUN(...future.X_jj, ...)
[09:29:45.854]                       })
[09:29:45.854]                   }
[09:29:45.854]                 }, args = future.call.arguments)
[09:29:45.854]             }))
[09:29:45.854]             future::FutureResult(value = ...future.value$value, 
[09:29:45.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.854]                   ...future.rng), globalenv = if (FALSE) 
[09:29:45.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:45.854]                     ...future.globalenv.names))
[09:29:45.854]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:45.854]         }, condition = base::local({
[09:29:45.854]             c <- base::c
[09:29:45.854]             inherits <- base::inherits
[09:29:45.854]             invokeRestart <- base::invokeRestart
[09:29:45.854]             length <- base::length
[09:29:45.854]             list <- base::list
[09:29:45.854]             seq.int <- base::seq.int
[09:29:45.854]             signalCondition <- base::signalCondition
[09:29:45.854]             sys.calls <- base::sys.calls
[09:29:45.854]             `[[` <- base::`[[`
[09:29:45.854]             `+` <- base::`+`
[09:29:45.854]             `<<-` <- base::`<<-`
[09:29:45.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:45.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:45.854]                   3L)]
[09:29:45.854]             }
[09:29:45.854]             function(cond) {
[09:29:45.854]                 is_error <- inherits(cond, "error")
[09:29:45.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:45.854]                   NULL)
[09:29:45.854]                 if (is_error) {
[09:29:45.854]                   sessionInformation <- function() {
[09:29:45.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:45.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:45.854]                       search = base::search(), system = base::Sys.info())
[09:29:45.854]                   }
[09:29:45.854]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:45.854]                     cond$call), session = sessionInformation(), 
[09:29:45.854]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:45.854]                   signalCondition(cond)
[09:29:45.854]                 }
[09:29:45.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:45.854]                 "immediateCondition"))) {
[09:29:45.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:45.854]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:45.854]                   if (TRUE && !signal) {
[09:29:45.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.854]                     {
[09:29:45.854]                       inherits <- base::inherits
[09:29:45.854]                       invokeRestart <- base::invokeRestart
[09:29:45.854]                       is.null <- base::is.null
[09:29:45.854]                       muffled <- FALSE
[09:29:45.854]                       if (inherits(cond, "message")) {
[09:29:45.854]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.854]                         if (muffled) 
[09:29:45.854]                           invokeRestart("muffleMessage")
[09:29:45.854]                       }
[09:29:45.854]                       else if (inherits(cond, "warning")) {
[09:29:45.854]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.854]                         if (muffled) 
[09:29:45.854]                           invokeRestart("muffleWarning")
[09:29:45.854]                       }
[09:29:45.854]                       else if (inherits(cond, "condition")) {
[09:29:45.854]                         if (!is.null(pattern)) {
[09:29:45.854]                           computeRestarts <- base::computeRestarts
[09:29:45.854]                           grepl <- base::grepl
[09:29:45.854]                           restarts <- computeRestarts(cond)
[09:29:45.854]                           for (restart in restarts) {
[09:29:45.854]                             name <- restart$name
[09:29:45.854]                             if (is.null(name)) 
[09:29:45.854]                               next
[09:29:45.854]                             if (!grepl(pattern, name)) 
[09:29:45.854]                               next
[09:29:45.854]                             invokeRestart(restart)
[09:29:45.854]                             muffled <- TRUE
[09:29:45.854]                             break
[09:29:45.854]                           }
[09:29:45.854]                         }
[09:29:45.854]                       }
[09:29:45.854]                       invisible(muffled)
[09:29:45.854]                     }
[09:29:45.854]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.854]                   }
[09:29:45.854]                 }
[09:29:45.854]                 else {
[09:29:45.854]                   if (TRUE) {
[09:29:45.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.854]                     {
[09:29:45.854]                       inherits <- base::inherits
[09:29:45.854]                       invokeRestart <- base::invokeRestart
[09:29:45.854]                       is.null <- base::is.null
[09:29:45.854]                       muffled <- FALSE
[09:29:45.854]                       if (inherits(cond, "message")) {
[09:29:45.854]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.854]                         if (muffled) 
[09:29:45.854]                           invokeRestart("muffleMessage")
[09:29:45.854]                       }
[09:29:45.854]                       else if (inherits(cond, "warning")) {
[09:29:45.854]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.854]                         if (muffled) 
[09:29:45.854]                           invokeRestart("muffleWarning")
[09:29:45.854]                       }
[09:29:45.854]                       else if (inherits(cond, "condition")) {
[09:29:45.854]                         if (!is.null(pattern)) {
[09:29:45.854]                           computeRestarts <- base::computeRestarts
[09:29:45.854]                           grepl <- base::grepl
[09:29:45.854]                           restarts <- computeRestarts(cond)
[09:29:45.854]                           for (restart in restarts) {
[09:29:45.854]                             name <- restart$name
[09:29:45.854]                             if (is.null(name)) 
[09:29:45.854]                               next
[09:29:45.854]                             if (!grepl(pattern, name)) 
[09:29:45.854]                               next
[09:29:45.854]                             invokeRestart(restart)
[09:29:45.854]                             muffled <- TRUE
[09:29:45.854]                             break
[09:29:45.854]                           }
[09:29:45.854]                         }
[09:29:45.854]                       }
[09:29:45.854]                       invisible(muffled)
[09:29:45.854]                     }
[09:29:45.854]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.854]                   }
[09:29:45.854]                 }
[09:29:45.854]             }
[09:29:45.854]         }))
[09:29:45.854]     }, error = function(ex) {
[09:29:45.854]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:45.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.854]                 ...future.rng), started = ...future.startTime, 
[09:29:45.854]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:45.854]             version = "1.8"), class = "FutureResult")
[09:29:45.854]     }, finally = {
[09:29:45.854]         if (!identical(...future.workdir, getwd())) 
[09:29:45.854]             setwd(...future.workdir)
[09:29:45.854]         {
[09:29:45.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:45.854]                 ...future.oldOptions$nwarnings <- NULL
[09:29:45.854]             }
[09:29:45.854]             base::options(...future.oldOptions)
[09:29:45.854]             if (.Platform$OS.type == "windows") {
[09:29:45.854]                 old_names <- names(...future.oldEnvVars)
[09:29:45.854]                 envs <- base::Sys.getenv()
[09:29:45.854]                 names <- names(envs)
[09:29:45.854]                 common <- intersect(names, old_names)
[09:29:45.854]                 added <- setdiff(names, old_names)
[09:29:45.854]                 removed <- setdiff(old_names, names)
[09:29:45.854]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:45.854]                   envs[common]]
[09:29:45.854]                 NAMES <- toupper(changed)
[09:29:45.854]                 args <- list()
[09:29:45.854]                 for (kk in seq_along(NAMES)) {
[09:29:45.854]                   name <- changed[[kk]]
[09:29:45.854]                   NAME <- NAMES[[kk]]
[09:29:45.854]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.854]                     next
[09:29:45.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.854]                 }
[09:29:45.854]                 NAMES <- toupper(added)
[09:29:45.854]                 for (kk in seq_along(NAMES)) {
[09:29:45.854]                   name <- added[[kk]]
[09:29:45.854]                   NAME <- NAMES[[kk]]
[09:29:45.854]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.854]                     next
[09:29:45.854]                   args[[name]] <- ""
[09:29:45.854]                 }
[09:29:45.854]                 NAMES <- toupper(removed)
[09:29:45.854]                 for (kk in seq_along(NAMES)) {
[09:29:45.854]                   name <- removed[[kk]]
[09:29:45.854]                   NAME <- NAMES[[kk]]
[09:29:45.854]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.854]                     next
[09:29:45.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.854]                 }
[09:29:45.854]                 if (length(args) > 0) 
[09:29:45.854]                   base::do.call(base::Sys.setenv, args = args)
[09:29:45.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:45.854]             }
[09:29:45.854]             else {
[09:29:45.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:45.854]             }
[09:29:45.854]             {
[09:29:45.854]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:45.854]                   0L) {
[09:29:45.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:45.854]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:45.854]                   base::options(opts)
[09:29:45.854]                 }
[09:29:45.854]                 {
[09:29:45.854]                   {
[09:29:45.854]                     NULL
[09:29:45.854]                     RNGkind("Mersenne-Twister")
[09:29:45.854]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:45.854]                       inherits = FALSE)
[09:29:45.854]                   }
[09:29:45.854]                   options(future.plan = NULL)
[09:29:45.854]                   if (is.na(NA_character_)) 
[09:29:45.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:45.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:45.854]                     .init = FALSE)
[09:29:45.854]                 }
[09:29:45.854]             }
[09:29:45.854]         }
[09:29:45.854]     })
[09:29:45.854]     if (TRUE) {
[09:29:45.854]         base::sink(type = "output", split = FALSE)
[09:29:45.854]         if (TRUE) {
[09:29:45.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:45.854]         }
[09:29:45.854]         else {
[09:29:45.854]             ...future.result["stdout"] <- base::list(NULL)
[09:29:45.854]         }
[09:29:45.854]         base::close(...future.stdout)
[09:29:45.854]         ...future.stdout <- NULL
[09:29:45.854]     }
[09:29:45.854]     ...future.result$conditions <- ...future.conditions
[09:29:45.854]     ...future.result$finished <- base::Sys.time()
[09:29:45.854]     ...future.result
[09:29:45.854] }
[09:29:45.855] assign_globals() ...
[09:29:45.855] List of 11
[09:29:45.855]  $ ...future.FUN            :function (x, ...)  
[09:29:45.855]  $ x_FUN                    :function (x)  
[09:29:45.855]  $ times                    : int 4
[09:29:45.855]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.855]  $ stop_if_not              :function (...)  
[09:29:45.855]  $ dim                      : int [1:2] 2 2
[09:29:45.855]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:45.855]  $ future.call.arguments    : list()
[09:29:45.855]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.855]  $ ...future.elements_ii    :List of 10
[09:29:45.855]   ..$ : int 1
[09:29:45.855]   ..$ : int 2
[09:29:45.855]   ..$ : int 3
[09:29:45.855]   ..$ : int 4
[09:29:45.855]   ..$ : int 5
[09:29:45.855]   ..$ : int 6
[09:29:45.855]   ..$ : int 7
[09:29:45.855]   ..$ : int 8
[09:29:45.855]   ..$ : int 9
[09:29:45.855]   ..$ : int 10
[09:29:45.855]  $ ...future.seeds_ii       : NULL
[09:29:45.855]  $ ...future.globals.maxSize: NULL
[09:29:45.855]  - attr(*, "where")=List of 11
[09:29:45.855]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:45.855]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:45.855]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:45.855]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:45.855]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:45.855]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:45.855]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:45.855]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:45.855]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:45.855]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:45.855]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:45.855]  - attr(*, "resolved")= logi FALSE
[09:29:45.855]  - attr(*, "total_size")= num 97304
[09:29:45.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.855]  - attr(*, "already-done")= logi TRUE
[09:29:45.865] - copied ‘...future.FUN’ to environment
[09:29:45.865] - reassign environment for ‘x_FUN’
[09:29:45.865] - copied ‘x_FUN’ to environment
[09:29:45.865] - copied ‘times’ to environment
[09:29:45.865] - copied ‘stopf’ to environment
[09:29:45.866] - copied ‘stop_if_not’ to environment
[09:29:45.866] - copied ‘dim’ to environment
[09:29:45.866] - copied ‘valid_types’ to environment
[09:29:45.866] - copied ‘future.call.arguments’ to environment
[09:29:45.866] - copied ‘...future.elements_ii’ to environment
[09:29:45.866] - copied ‘...future.seeds_ii’ to environment
[09:29:45.866] - copied ‘...future.globals.maxSize’ to environment
[09:29:45.866] assign_globals() ... done
[09:29:45.867] plan(): Setting new future strategy stack:
[09:29:45.867] List of future strategies:
[09:29:45.867] 1. sequential:
[09:29:45.867]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.867]    - tweaked: FALSE
[09:29:45.867]    - call: NULL
[09:29:45.867] plan(): nbrOfWorkers() = 1
[09:29:45.868] plan(): Setting new future strategy stack:
[09:29:45.868] List of future strategies:
[09:29:45.868] 1. sequential:
[09:29:45.868]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.868]    - tweaked: FALSE
[09:29:45.868]    - call: plan(strategy)
[09:29:45.869] plan(): nbrOfWorkers() = 1
[09:29:45.869] SequentialFuture started (and completed)
[09:29:45.869] - Launch lazy future ... done
[09:29:45.869] run() for ‘SequentialFuture’ ... done
[09:29:45.869] Created future:
[09:29:45.869] SequentialFuture:
[09:29:45.869] Label: ‘future_vapply-1’
[09:29:45.869] Expression:
[09:29:45.869] {
[09:29:45.869]     do.call(function(...) {
[09:29:45.869]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.869]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.869]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.869]             on.exit(options(oopts), add = TRUE)
[09:29:45.869]         }
[09:29:45.869]         {
[09:29:45.869]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.869]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.869]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.869]             })
[09:29:45.869]         }
[09:29:45.869]     }, args = future.call.arguments)
[09:29:45.869] }
[09:29:45.869] Lazy evaluation: FALSE
[09:29:45.869] Asynchronous evaluation: FALSE
[09:29:45.869] Local evaluation: TRUE
[09:29:45.869] Environment: R_GlobalEnv
[09:29:45.869] Capture standard output: TRUE
[09:29:45.869] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:45.869] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:45.869] Packages: 1 packages (‘future.apply’)
[09:29:45.869] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:45.869] Resolved: TRUE
[09:29:45.869] Value: 2.27 KiB of class ‘list’
[09:29:45.869] Early signaling: FALSE
[09:29:45.869] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:45.869] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.872] Chunk #1 of 1 ... DONE
[09:29:45.872] Launching 1 futures (chunks) ... DONE
[09:29:45.872] Resolving 1 futures (chunks) ...
[09:29:45.872] resolve() on list ...
[09:29:45.872]  recursive: 0
[09:29:45.873]  length: 1
[09:29:45.873] 
[09:29:45.873] resolved() for ‘SequentialFuture’ ...
[09:29:45.873] - state: ‘finished’
[09:29:45.873] - run: TRUE
[09:29:45.873] - result: ‘FutureResult’
[09:29:45.873] resolved() for ‘SequentialFuture’ ... done
[09:29:45.873] Future #1
[09:29:45.873] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:45.874] - nx: 1
[09:29:45.874] - relay: TRUE
[09:29:45.874] - stdout: TRUE
[09:29:45.874] - signal: TRUE
[09:29:45.874] - resignal: FALSE
[09:29:45.874] - force: TRUE
[09:29:45.874] - relayed: [n=1] FALSE
[09:29:45.874] - queued futures: [n=1] FALSE
[09:29:45.874]  - until=1
[09:29:45.874]  - relaying element #1
[09:29:45.874] - relayed: [n=1] TRUE
[09:29:45.875] - queued futures: [n=1] TRUE
[09:29:45.875] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:45.875]  length: 0 (resolved future 1)
[09:29:45.875] Relaying remaining futures
[09:29:45.875] signalConditionsASAP(NULL, pos=0) ...
[09:29:45.875] - nx: 1
[09:29:45.875] - relay: TRUE
[09:29:45.875] - stdout: TRUE
[09:29:45.875] - signal: TRUE
[09:29:45.875] - resignal: FALSE
[09:29:45.875] - force: TRUE
[09:29:45.875] - relayed: [n=1] TRUE
[09:29:45.876] - queued futures: [n=1] TRUE
 - flush all
[09:29:45.876] - relayed: [n=1] TRUE
[09:29:45.876] - queued futures: [n=1] TRUE
[09:29:45.876] signalConditionsASAP(NULL, pos=0) ... done
[09:29:45.876] resolve() on list ... DONE
[09:29:45.876]  - Number of value chunks collected: 1
[09:29:45.876] Resolving 1 futures (chunks) ... DONE
[09:29:45.876] Reducing values from 1 chunks ...
[09:29:45.876]  - Number of values collected after concatenation: 10
[09:29:45.877]  - Number of values expected: 10
[09:29:45.877] Reducing values from 1 chunks ... DONE
[09:29:45.877] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[09:29:45.879] future_lapply() ...
[09:29:45.880] Number of chunks: 1
[09:29:45.880] getGlobalsAndPackagesXApply() ...
[09:29:45.881]  - future.globals: TRUE
[09:29:45.881] getGlobalsAndPackages() ...
[09:29:45.881] Searching for globals...
[09:29:45.884] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[09:29:45.884] Searching for globals ... DONE
[09:29:45.885] Resolving globals: FALSE
[09:29:45.885] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[09:29:45.886] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:45.886] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.886] - packages: [1] ‘future.apply’
[09:29:45.886] getGlobalsAndPackages() ... DONE
[09:29:45.886]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.886]  - needed namespaces: [n=1] ‘future.apply’
[09:29:45.886] Finding globals ... DONE
[09:29:45.887]  - use_args: TRUE
[09:29:45.887]  - Getting '...' globals ...
[09:29:45.887] resolve() on list ...
[09:29:45.887]  recursive: 0
[09:29:45.887]  length: 1
[09:29:45.887]  elements: ‘...’
[09:29:45.887]  length: 0 (resolved future 1)
[09:29:45.887] resolve() on list ... DONE
[09:29:45.887]    - '...' content: [n=0] 
[09:29:45.888] List of 1
[09:29:45.888]  $ ...: list()
[09:29:45.888]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.888]  - attr(*, "where")=List of 1
[09:29:45.888]   ..$ ...:<environment: 0x561d34d5dd48> 
[09:29:45.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.888]  - attr(*, "resolved")= logi TRUE
[09:29:45.888]  - attr(*, "total_size")= num NA
[09:29:45.890]  - Getting '...' globals ... DONE
[09:29:45.890] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:45.890] List of 8
[09:29:45.890]  $ ...future.FUN:function (x, ...)  
[09:29:45.890]  $ x_FUN        :function (x)  
[09:29:45.890]  $ times        : int 4
[09:29:45.890]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.890]  $ stop_if_not  :function (...)  
[09:29:45.890]  $ dim          : int [1:2] 2 2
[09:29:45.890]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:45.890]  $ ...          : list()
[09:29:45.890]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.890]  - attr(*, "where")=List of 8
[09:29:45.890]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:45.890]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:45.890]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:45.890]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:45.890]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:45.890]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:45.890]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:45.890]   ..$ ...          :<environment: 0x561d34d5dd48> 
[09:29:45.890]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.890]  - attr(*, "resolved")= logi FALSE
[09:29:45.890]  - attr(*, "total_size")= num 105552
[09:29:45.922] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:45.922] getGlobalsAndPackagesXApply() ... DONE
[09:29:45.923] Number of futures (= number of chunks): 1
[09:29:45.923] Launching 1 futures (chunks) ...
[09:29:45.923] Chunk #1 of 1 ...
[09:29:45.923]  - Finding globals in 'X' for chunk #1 ...
[09:29:45.923] getGlobalsAndPackages() ...
[09:29:45.923] Searching for globals...
[09:29:45.923] 
[09:29:45.923] Searching for globals ... DONE
[09:29:45.923] - globals: [0] <none>
[09:29:45.924] getGlobalsAndPackages() ... DONE
[09:29:45.924]    + additional globals found: [n=0] 
[09:29:45.924]    + additional namespaces needed: [n=0] 
[09:29:45.924]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:45.924]  - seeds: <none>
[09:29:45.924]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.924] getGlobalsAndPackages() ...
[09:29:45.924] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.924] Resolving globals: FALSE
[09:29:45.924] Tweak future expression to call with '...' arguments ...
[09:29:45.925] {
[09:29:45.925]     do.call(function(...) {
[09:29:45.925]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.925]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.925]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.925]             on.exit(options(oopts), add = TRUE)
[09:29:45.925]         }
[09:29:45.925]         {
[09:29:45.925]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.925]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.925]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.925]             })
[09:29:45.925]         }
[09:29:45.925]     }, args = future.call.arguments)
[09:29:45.925] }
[09:29:45.925] Tweak future expression to call with '...' arguments ... DONE
[09:29:45.925] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.925] - packages: [1] ‘future.apply’
[09:29:45.925] getGlobalsAndPackages() ... DONE
[09:29:45.926] run() for ‘Future’ ...
[09:29:45.926] - state: ‘created’
[09:29:45.926] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:45.926] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.926] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:45.926]   - Field: ‘label’
[09:29:45.927]   - Field: ‘local’
[09:29:45.927]   - Field: ‘owner’
[09:29:45.927]   - Field: ‘envir’
[09:29:45.927]   - Field: ‘packages’
[09:29:45.927]   - Field: ‘gc’
[09:29:45.927]   - Field: ‘conditions’
[09:29:45.927]   - Field: ‘expr’
[09:29:45.927]   - Field: ‘uuid’
[09:29:45.927]   - Field: ‘seed’
[09:29:45.927]   - Field: ‘version’
[09:29:45.927]   - Field: ‘result’
[09:29:45.927]   - Field: ‘asynchronous’
[09:29:45.928]   - Field: ‘calls’
[09:29:45.928]   - Field: ‘globals’
[09:29:45.928]   - Field: ‘stdout’
[09:29:45.928]   - Field: ‘earlySignal’
[09:29:45.928]   - Field: ‘lazy’
[09:29:45.928]   - Field: ‘state’
[09:29:45.928] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:45.928] - Launch lazy future ...
[09:29:45.928] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:45.929] Packages needed by future strategies (n = 0): <none>
[09:29:45.929] {
[09:29:45.929]     {
[09:29:45.929]         {
[09:29:45.929]             ...future.startTime <- base::Sys.time()
[09:29:45.929]             {
[09:29:45.929]                 {
[09:29:45.929]                   {
[09:29:45.929]                     {
[09:29:45.929]                       base::local({
[09:29:45.929]                         has_future <- base::requireNamespace("future", 
[09:29:45.929]                           quietly = TRUE)
[09:29:45.929]                         if (has_future) {
[09:29:45.929]                           ns <- base::getNamespace("future")
[09:29:45.929]                           version <- ns[[".package"]][["version"]]
[09:29:45.929]                           if (is.null(version)) 
[09:29:45.929]                             version <- utils::packageVersion("future")
[09:29:45.929]                         }
[09:29:45.929]                         else {
[09:29:45.929]                           version <- NULL
[09:29:45.929]                         }
[09:29:45.929]                         if (!has_future || version < "1.8.0") {
[09:29:45.929]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:45.929]                             "", base::R.version$version.string), 
[09:29:45.929]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:45.929]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:45.929]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:45.929]                               "release", "version")], collapse = " "), 
[09:29:45.929]                             hostname = base::Sys.info()[["nodename"]])
[09:29:45.929]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:45.929]                             info)
[09:29:45.929]                           info <- base::paste(info, collapse = "; ")
[09:29:45.929]                           if (!has_future) {
[09:29:45.929]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:45.929]                               info)
[09:29:45.929]                           }
[09:29:45.929]                           else {
[09:29:45.929]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:45.929]                               info, version)
[09:29:45.929]                           }
[09:29:45.929]                           base::stop(msg)
[09:29:45.929]                         }
[09:29:45.929]                       })
[09:29:45.929]                     }
[09:29:45.929]                     base::local({
[09:29:45.929]                       for (pkg in "future.apply") {
[09:29:45.929]                         base::loadNamespace(pkg)
[09:29:45.929]                         base::library(pkg, character.only = TRUE)
[09:29:45.929]                       }
[09:29:45.929]                     })
[09:29:45.929]                   }
[09:29:45.929]                   ...future.strategy.old <- future::plan("list")
[09:29:45.929]                   options(future.plan = NULL)
[09:29:45.929]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.929]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:45.929]                 }
[09:29:45.929]                 ...future.workdir <- getwd()
[09:29:45.929]             }
[09:29:45.929]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:45.929]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:45.929]         }
[09:29:45.929]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:45.929]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:45.929]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:45.929]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:45.929]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:45.929]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:45.929]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:45.929]             base::names(...future.oldOptions))
[09:29:45.929]     }
[09:29:45.929]     if (FALSE) {
[09:29:45.929]     }
[09:29:45.929]     else {
[09:29:45.929]         if (TRUE) {
[09:29:45.929]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:45.929]                 open = "w")
[09:29:45.929]         }
[09:29:45.929]         else {
[09:29:45.929]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:45.929]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:45.929]         }
[09:29:45.929]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:45.929]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:45.929]             base::sink(type = "output", split = FALSE)
[09:29:45.929]             base::close(...future.stdout)
[09:29:45.929]         }, add = TRUE)
[09:29:45.929]     }
[09:29:45.929]     ...future.frame <- base::sys.nframe()
[09:29:45.929]     ...future.conditions <- base::list()
[09:29:45.929]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:45.929]     if (FALSE) {
[09:29:45.929]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:45.929]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:45.929]     }
[09:29:45.929]     ...future.result <- base::tryCatch({
[09:29:45.929]         base::withCallingHandlers({
[09:29:45.929]             ...future.value <- base::withVisible(base::local({
[09:29:45.929]                 do.call(function(...) {
[09:29:45.929]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.929]                   if (!identical(...future.globals.maxSize.org, 
[09:29:45.929]                     ...future.globals.maxSize)) {
[09:29:45.929]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.929]                     on.exit(options(oopts), add = TRUE)
[09:29:45.929]                   }
[09:29:45.929]                   {
[09:29:45.929]                     lapply(seq_along(...future.elements_ii), 
[09:29:45.929]                       FUN = function(jj) {
[09:29:45.929]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.929]                         ...future.FUN(...future.X_jj, ...)
[09:29:45.929]                       })
[09:29:45.929]                   }
[09:29:45.929]                 }, args = future.call.arguments)
[09:29:45.929]             }))
[09:29:45.929]             future::FutureResult(value = ...future.value$value, 
[09:29:45.929]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.929]                   ...future.rng), globalenv = if (FALSE) 
[09:29:45.929]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:45.929]                     ...future.globalenv.names))
[09:29:45.929]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:45.929]         }, condition = base::local({
[09:29:45.929]             c <- base::c
[09:29:45.929]             inherits <- base::inherits
[09:29:45.929]             invokeRestart <- base::invokeRestart
[09:29:45.929]             length <- base::length
[09:29:45.929]             list <- base::list
[09:29:45.929]             seq.int <- base::seq.int
[09:29:45.929]             signalCondition <- base::signalCondition
[09:29:45.929]             sys.calls <- base::sys.calls
[09:29:45.929]             `[[` <- base::`[[`
[09:29:45.929]             `+` <- base::`+`
[09:29:45.929]             `<<-` <- base::`<<-`
[09:29:45.929]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:45.929]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:45.929]                   3L)]
[09:29:45.929]             }
[09:29:45.929]             function(cond) {
[09:29:45.929]                 is_error <- inherits(cond, "error")
[09:29:45.929]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:45.929]                   NULL)
[09:29:45.929]                 if (is_error) {
[09:29:45.929]                   sessionInformation <- function() {
[09:29:45.929]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:45.929]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:45.929]                       search = base::search(), system = base::Sys.info())
[09:29:45.929]                   }
[09:29:45.929]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.929]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:45.929]                     cond$call), session = sessionInformation(), 
[09:29:45.929]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:45.929]                   signalCondition(cond)
[09:29:45.929]                 }
[09:29:45.929]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:45.929]                 "immediateCondition"))) {
[09:29:45.929]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:45.929]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.929]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:45.929]                   if (TRUE && !signal) {
[09:29:45.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.929]                     {
[09:29:45.929]                       inherits <- base::inherits
[09:29:45.929]                       invokeRestart <- base::invokeRestart
[09:29:45.929]                       is.null <- base::is.null
[09:29:45.929]                       muffled <- FALSE
[09:29:45.929]                       if (inherits(cond, "message")) {
[09:29:45.929]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.929]                         if (muffled) 
[09:29:45.929]                           invokeRestart("muffleMessage")
[09:29:45.929]                       }
[09:29:45.929]                       else if (inherits(cond, "warning")) {
[09:29:45.929]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.929]                         if (muffled) 
[09:29:45.929]                           invokeRestart("muffleWarning")
[09:29:45.929]                       }
[09:29:45.929]                       else if (inherits(cond, "condition")) {
[09:29:45.929]                         if (!is.null(pattern)) {
[09:29:45.929]                           computeRestarts <- base::computeRestarts
[09:29:45.929]                           grepl <- base::grepl
[09:29:45.929]                           restarts <- computeRestarts(cond)
[09:29:45.929]                           for (restart in restarts) {
[09:29:45.929]                             name <- restart$name
[09:29:45.929]                             if (is.null(name)) 
[09:29:45.929]                               next
[09:29:45.929]                             if (!grepl(pattern, name)) 
[09:29:45.929]                               next
[09:29:45.929]                             invokeRestart(restart)
[09:29:45.929]                             muffled <- TRUE
[09:29:45.929]                             break
[09:29:45.929]                           }
[09:29:45.929]                         }
[09:29:45.929]                       }
[09:29:45.929]                       invisible(muffled)
[09:29:45.929]                     }
[09:29:45.929]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.929]                   }
[09:29:45.929]                 }
[09:29:45.929]                 else {
[09:29:45.929]                   if (TRUE) {
[09:29:45.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.929]                     {
[09:29:45.929]                       inherits <- base::inherits
[09:29:45.929]                       invokeRestart <- base::invokeRestart
[09:29:45.929]                       is.null <- base::is.null
[09:29:45.929]                       muffled <- FALSE
[09:29:45.929]                       if (inherits(cond, "message")) {
[09:29:45.929]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.929]                         if (muffled) 
[09:29:45.929]                           invokeRestart("muffleMessage")
[09:29:45.929]                       }
[09:29:45.929]                       else if (inherits(cond, "warning")) {
[09:29:45.929]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.929]                         if (muffled) 
[09:29:45.929]                           invokeRestart("muffleWarning")
[09:29:45.929]                       }
[09:29:45.929]                       else if (inherits(cond, "condition")) {
[09:29:45.929]                         if (!is.null(pattern)) {
[09:29:45.929]                           computeRestarts <- base::computeRestarts
[09:29:45.929]                           grepl <- base::grepl
[09:29:45.929]                           restarts <- computeRestarts(cond)
[09:29:45.929]                           for (restart in restarts) {
[09:29:45.929]                             name <- restart$name
[09:29:45.929]                             if (is.null(name)) 
[09:29:45.929]                               next
[09:29:45.929]                             if (!grepl(pattern, name)) 
[09:29:45.929]                               next
[09:29:45.929]                             invokeRestart(restart)
[09:29:45.929]                             muffled <- TRUE
[09:29:45.929]                             break
[09:29:45.929]                           }
[09:29:45.929]                         }
[09:29:45.929]                       }
[09:29:45.929]                       invisible(muffled)
[09:29:45.929]                     }
[09:29:45.929]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.929]                   }
[09:29:45.929]                 }
[09:29:45.929]             }
[09:29:45.929]         }))
[09:29:45.929]     }, error = function(ex) {
[09:29:45.929]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:45.929]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.929]                 ...future.rng), started = ...future.startTime, 
[09:29:45.929]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:45.929]             version = "1.8"), class = "FutureResult")
[09:29:45.929]     }, finally = {
[09:29:45.929]         if (!identical(...future.workdir, getwd())) 
[09:29:45.929]             setwd(...future.workdir)
[09:29:45.929]         {
[09:29:45.929]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:45.929]                 ...future.oldOptions$nwarnings <- NULL
[09:29:45.929]             }
[09:29:45.929]             base::options(...future.oldOptions)
[09:29:45.929]             if (.Platform$OS.type == "windows") {
[09:29:45.929]                 old_names <- names(...future.oldEnvVars)
[09:29:45.929]                 envs <- base::Sys.getenv()
[09:29:45.929]                 names <- names(envs)
[09:29:45.929]                 common <- intersect(names, old_names)
[09:29:45.929]                 added <- setdiff(names, old_names)
[09:29:45.929]                 removed <- setdiff(old_names, names)
[09:29:45.929]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:45.929]                   envs[common]]
[09:29:45.929]                 NAMES <- toupper(changed)
[09:29:45.929]                 args <- list()
[09:29:45.929]                 for (kk in seq_along(NAMES)) {
[09:29:45.929]                   name <- changed[[kk]]
[09:29:45.929]                   NAME <- NAMES[[kk]]
[09:29:45.929]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.929]                     next
[09:29:45.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.929]                 }
[09:29:45.929]                 NAMES <- toupper(added)
[09:29:45.929]                 for (kk in seq_along(NAMES)) {
[09:29:45.929]                   name <- added[[kk]]
[09:29:45.929]                   NAME <- NAMES[[kk]]
[09:29:45.929]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.929]                     next
[09:29:45.929]                   args[[name]] <- ""
[09:29:45.929]                 }
[09:29:45.929]                 NAMES <- toupper(removed)
[09:29:45.929]                 for (kk in seq_along(NAMES)) {
[09:29:45.929]                   name <- removed[[kk]]
[09:29:45.929]                   NAME <- NAMES[[kk]]
[09:29:45.929]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.929]                     next
[09:29:45.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.929]                 }
[09:29:45.929]                 if (length(args) > 0) 
[09:29:45.929]                   base::do.call(base::Sys.setenv, args = args)
[09:29:45.929]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:45.929]             }
[09:29:45.929]             else {
[09:29:45.929]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:45.929]             }
[09:29:45.929]             {
[09:29:45.929]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:45.929]                   0L) {
[09:29:45.929]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:45.929]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:45.929]                   base::options(opts)
[09:29:45.929]                 }
[09:29:45.929]                 {
[09:29:45.929]                   {
[09:29:45.929]                     NULL
[09:29:45.929]                     RNGkind("Mersenne-Twister")
[09:29:45.929]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:45.929]                       inherits = FALSE)
[09:29:45.929]                   }
[09:29:45.929]                   options(future.plan = NULL)
[09:29:45.929]                   if (is.na(NA_character_)) 
[09:29:45.929]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.929]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:45.929]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:45.929]                     .init = FALSE)
[09:29:45.929]                 }
[09:29:45.929]             }
[09:29:45.929]         }
[09:29:45.929]     })
[09:29:45.929]     if (TRUE) {
[09:29:45.929]         base::sink(type = "output", split = FALSE)
[09:29:45.929]         if (TRUE) {
[09:29:45.929]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:45.929]         }
[09:29:45.929]         else {
[09:29:45.929]             ...future.result["stdout"] <- base::list(NULL)
[09:29:45.929]         }
[09:29:45.929]         base::close(...future.stdout)
[09:29:45.929]         ...future.stdout <- NULL
[09:29:45.929]     }
[09:29:45.929]     ...future.result$conditions <- ...future.conditions
[09:29:45.929]     ...future.result$finished <- base::Sys.time()
[09:29:45.929]     ...future.result
[09:29:45.929] }
[09:29:45.931] assign_globals() ...
[09:29:45.931] List of 11
[09:29:45.931]  $ ...future.FUN            :function (x, ...)  
[09:29:45.931]  $ x_FUN                    :function (x)  
[09:29:45.931]  $ times                    : int 4
[09:29:45.931]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.931]  $ stop_if_not              :function (...)  
[09:29:45.931]  $ dim                      : int [1:2] 2 2
[09:29:45.931]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:45.931]  $ future.call.arguments    : list()
[09:29:45.931]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.931]  $ ...future.elements_ii    :List of 10
[09:29:45.931]   ..$ : int 1
[09:29:45.931]   ..$ : int 2
[09:29:45.931]   ..$ : int 3
[09:29:45.931]   ..$ : int 4
[09:29:45.931]   ..$ : int 5
[09:29:45.931]   ..$ : int 6
[09:29:45.931]   ..$ : int 7
[09:29:45.931]   ..$ : int 8
[09:29:45.931]   ..$ : int 9
[09:29:45.931]   ..$ : int 10
[09:29:45.931]  $ ...future.seeds_ii       : NULL
[09:29:45.931]  $ ...future.globals.maxSize: NULL
[09:29:45.931]  - attr(*, "where")=List of 11
[09:29:45.931]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:45.931]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:45.931]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:45.931]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:45.931]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:45.931]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:45.931]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:45.931]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:45.931]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:45.931]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:45.931]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:45.931]  - attr(*, "resolved")= logi FALSE
[09:29:45.931]  - attr(*, "total_size")= num 105552
[09:29:45.931]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.931]  - attr(*, "already-done")= logi TRUE
[09:29:45.940] - copied ‘...future.FUN’ to environment
[09:29:45.940] - reassign environment for ‘x_FUN’
[09:29:45.940] - copied ‘x_FUN’ to environment
[09:29:45.940] - copied ‘times’ to environment
[09:29:45.940] - copied ‘stopf’ to environment
[09:29:45.941] - copied ‘stop_if_not’ to environment
[09:29:45.941] - copied ‘dim’ to environment
[09:29:45.941] - copied ‘valid_types’ to environment
[09:29:45.941] - copied ‘future.call.arguments’ to environment
[09:29:45.941] - copied ‘...future.elements_ii’ to environment
[09:29:45.941] - copied ‘...future.seeds_ii’ to environment
[09:29:45.941] - copied ‘...future.globals.maxSize’ to environment
[09:29:45.941] assign_globals() ... done
[09:29:45.942] plan(): Setting new future strategy stack:
[09:29:45.942] List of future strategies:
[09:29:45.942] 1. sequential:
[09:29:45.942]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.942]    - tweaked: FALSE
[09:29:45.942]    - call: NULL
[09:29:45.943] plan(): nbrOfWorkers() = 1
[09:29:45.944] plan(): Setting new future strategy stack:
[09:29:45.944] List of future strategies:
[09:29:45.944] 1. sequential:
[09:29:45.944]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.944]    - tweaked: FALSE
[09:29:45.944]    - call: plan(strategy)
[09:29:45.944] plan(): nbrOfWorkers() = 1
[09:29:45.944] SequentialFuture started (and completed)
[09:29:45.945] - Launch lazy future ... done
[09:29:45.945] run() for ‘SequentialFuture’ ... done
[09:29:45.945] Created future:
[09:29:45.945] SequentialFuture:
[09:29:45.945] Label: ‘future_vapply-1’
[09:29:45.945] Expression:
[09:29:45.945] {
[09:29:45.945]     do.call(function(...) {
[09:29:45.945]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.945]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.945]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.945]             on.exit(options(oopts), add = TRUE)
[09:29:45.945]         }
[09:29:45.945]         {
[09:29:45.945]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.945]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.945]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.945]             })
[09:29:45.945]         }
[09:29:45.945]     }, args = future.call.arguments)
[09:29:45.945] }
[09:29:45.945] Lazy evaluation: FALSE
[09:29:45.945] Asynchronous evaluation: FALSE
[09:29:45.945] Local evaluation: TRUE
[09:29:45.945] Environment: R_GlobalEnv
[09:29:45.945] Capture standard output: TRUE
[09:29:45.945] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:45.945] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:45.945] Packages: 1 packages (‘future.apply’)
[09:29:45.945] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:45.945] Resolved: TRUE
[09:29:45.945] Value: 7.42 KiB of class ‘list’
[09:29:45.945] Early signaling: FALSE
[09:29:45.945] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:45.945] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.946] Chunk #1 of 1 ... DONE
[09:29:45.946] Launching 1 futures (chunks) ... DONE
[09:29:45.946] Resolving 1 futures (chunks) ...
[09:29:45.946] resolve() on list ...
[09:29:45.946]  recursive: 0
[09:29:45.946]  length: 1
[09:29:45.946] 
[09:29:45.947] resolved() for ‘SequentialFuture’ ...
[09:29:45.947] - state: ‘finished’
[09:29:45.947] - run: TRUE
[09:29:45.947] - result: ‘FutureResult’
[09:29:45.947] resolved() for ‘SequentialFuture’ ... done
[09:29:45.947] Future #1
[09:29:45.947] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:45.947] - nx: 1
[09:29:45.947] - relay: TRUE
[09:29:45.947] - stdout: TRUE
[09:29:45.947] - signal: TRUE
[09:29:45.948] - resignal: FALSE
[09:29:45.948] - force: TRUE
[09:29:45.948] - relayed: [n=1] FALSE
[09:29:45.948] - queued futures: [n=1] FALSE
[09:29:45.948]  - until=1
[09:29:45.948]  - relaying element #1
[09:29:45.948] - relayed: [n=1] TRUE
[09:29:45.948] - queued futures: [n=1] TRUE
[09:29:45.948] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:45.948]  length: 0 (resolved future 1)
[09:29:45.948] Relaying remaining futures
[09:29:45.949] signalConditionsASAP(NULL, pos=0) ...
[09:29:45.949] - nx: 1
[09:29:45.949] - relay: TRUE
[09:29:45.949] - stdout: TRUE
[09:29:45.949] - signal: TRUE
[09:29:45.949] - resignal: FALSE
[09:29:45.949] - force: TRUE
[09:29:45.949] - relayed: [n=1] TRUE
[09:29:45.949] - queued futures: [n=1] TRUE
 - flush all
[09:29:45.949] - relayed: [n=1] TRUE
[09:29:45.949] - queued futures: [n=1] TRUE
[09:29:45.949] signalConditionsASAP(NULL, pos=0) ... done
[09:29:45.950] resolve() on list ... DONE
[09:29:45.950]  - Number of value chunks collected: 1
[09:29:45.950] Resolving 1 futures (chunks) ... DONE
[09:29:45.950] Reducing values from 1 chunks ...
[09:29:45.950]  - Number of values collected after concatenation: 10
[09:29:45.950]  - Number of values expected: 10
[09:29:45.950] Reducing values from 1 chunks ... DONE
[09:29:45.950] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[09:29:45.954] future_lapply() ...
[09:29:45.955] Number of chunks: 1
[09:29:45.955] getGlobalsAndPackagesXApply() ...
[09:29:45.955]  - future.globals: TRUE
[09:29:45.955] getGlobalsAndPackages() ...
[09:29:45.955] Searching for globals...
[09:29:45.959] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[09:29:45.959] Searching for globals ... DONE
[09:29:45.959] Resolving globals: FALSE
[09:29:45.960] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[09:29:45.960] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:45.960] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.960] - packages: [2] ‘stats’, ‘future.apply’
[09:29:45.960] getGlobalsAndPackages() ... DONE
[09:29:45.960]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:45.960]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[09:29:45.961] Finding globals ... DONE
[09:29:45.961]  - use_args: TRUE
[09:29:45.961]  - Getting '...' globals ...
[09:29:45.961] resolve() on list ...
[09:29:45.961]  recursive: 0
[09:29:45.961]  length: 1
[09:29:45.961]  elements: ‘...’
[09:29:45.961]  length: 0 (resolved future 1)
[09:29:45.961] resolve() on list ... DONE
[09:29:45.962]    - '...' content: [n=0] 
[09:29:45.962] List of 1
[09:29:45.962]  $ ...: list()
[09:29:45.962]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.962]  - attr(*, "where")=List of 1
[09:29:45.962]   ..$ ...:<environment: 0x561d35d7d0a0> 
[09:29:45.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.962]  - attr(*, "resolved")= logi TRUE
[09:29:45.962]  - attr(*, "total_size")= num NA
[09:29:45.964]  - Getting '...' globals ... DONE
[09:29:45.964] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:45.964] List of 8
[09:29:45.964]  $ ...future.FUN:function (x, ...)  
[09:29:45.964]  $ x_FUN        :function (x, ...)  
[09:29:45.964]  $ times        : int 5
[09:29:45.964]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.964]  $ stop_if_not  :function (...)  
[09:29:45.964]  $ dim          : NULL
[09:29:45.964]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:45.964]  $ ...          : list()
[09:29:45.964]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.964]  - attr(*, "where")=List of 8
[09:29:45.964]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:45.964]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:45.964]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:45.964]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:45.964]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:45.964]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:45.964]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:45.964]   ..$ ...          :<environment: 0x561d35d7d0a0> 
[09:29:45.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.964]  - attr(*, "resolved")= logi FALSE
[09:29:45.964]  - attr(*, "total_size")= num 95528
[09:29:45.970] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[09:29:45.970] getGlobalsAndPackagesXApply() ... DONE
[09:29:45.971] Number of futures (= number of chunks): 1
[09:29:45.971] Launching 1 futures (chunks) ...
[09:29:45.971] Chunk #1 of 1 ...
[09:29:45.971]  - Finding globals in 'X' for chunk #1 ...
[09:29:45.971] getGlobalsAndPackages() ...
[09:29:45.971] Searching for globals...
[09:29:45.971] 
[09:29:45.971] Searching for globals ... DONE
[09:29:45.971] - globals: [0] <none>
[09:29:45.972] getGlobalsAndPackages() ... DONE
[09:29:45.972]    + additional globals found: [n=0] 
[09:29:45.972]    + additional namespaces needed: [n=0] 
[09:29:45.972]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:45.972]  - seeds: <none>
[09:29:45.972]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.972] getGlobalsAndPackages() ...
[09:29:45.972] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.972] Resolving globals: FALSE
[09:29:45.972] Tweak future expression to call with '...' arguments ...
[09:29:45.972] {
[09:29:45.972]     do.call(function(...) {
[09:29:45.972]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.972]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.972]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.972]             on.exit(options(oopts), add = TRUE)
[09:29:45.972]         }
[09:29:45.972]         {
[09:29:45.972]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.972]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.972]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.972]             })
[09:29:45.972]         }
[09:29:45.972]     }, args = future.call.arguments)
[09:29:45.972] }
[09:29:45.973] Tweak future expression to call with '...' arguments ... DONE
[09:29:45.973] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:45.973] - packages: [2] ‘stats’, ‘future.apply’
[09:29:45.973] getGlobalsAndPackages() ... DONE
[09:29:45.974] run() for ‘Future’ ...
[09:29:45.974] - state: ‘created’
[09:29:45.974] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:45.974] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:45.974]   - Field: ‘label’
[09:29:45.974]   - Field: ‘local’
[09:29:45.974]   - Field: ‘owner’
[09:29:45.975]   - Field: ‘envir’
[09:29:45.975]   - Field: ‘packages’
[09:29:45.975]   - Field: ‘gc’
[09:29:45.975]   - Field: ‘conditions’
[09:29:45.975]   - Field: ‘expr’
[09:29:45.975]   - Field: ‘uuid’
[09:29:45.975]   - Field: ‘seed’
[09:29:45.975]   - Field: ‘version’
[09:29:45.975]   - Field: ‘result’
[09:29:45.975]   - Field: ‘asynchronous’
[09:29:45.975]   - Field: ‘calls’
[09:29:45.975]   - Field: ‘globals’
[09:29:45.976]   - Field: ‘stdout’
[09:29:45.976]   - Field: ‘earlySignal’
[09:29:45.976]   - Field: ‘lazy’
[09:29:45.976]   - Field: ‘state’
[09:29:45.976] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:45.976] - Launch lazy future ...
[09:29:45.976] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[09:29:45.976] Packages needed by future strategies (n = 0): <none>
[09:29:45.977] {
[09:29:45.977]     {
[09:29:45.977]         {
[09:29:45.977]             ...future.startTime <- base::Sys.time()
[09:29:45.977]             {
[09:29:45.977]                 {
[09:29:45.977]                   {
[09:29:45.977]                     {
[09:29:45.977]                       base::local({
[09:29:45.977]                         has_future <- base::requireNamespace("future", 
[09:29:45.977]                           quietly = TRUE)
[09:29:45.977]                         if (has_future) {
[09:29:45.977]                           ns <- base::getNamespace("future")
[09:29:45.977]                           version <- ns[[".package"]][["version"]]
[09:29:45.977]                           if (is.null(version)) 
[09:29:45.977]                             version <- utils::packageVersion("future")
[09:29:45.977]                         }
[09:29:45.977]                         else {
[09:29:45.977]                           version <- NULL
[09:29:45.977]                         }
[09:29:45.977]                         if (!has_future || version < "1.8.0") {
[09:29:45.977]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:45.977]                             "", base::R.version$version.string), 
[09:29:45.977]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:45.977]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:45.977]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:45.977]                               "release", "version")], collapse = " "), 
[09:29:45.977]                             hostname = base::Sys.info()[["nodename"]])
[09:29:45.977]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:45.977]                             info)
[09:29:45.977]                           info <- base::paste(info, collapse = "; ")
[09:29:45.977]                           if (!has_future) {
[09:29:45.977]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:45.977]                               info)
[09:29:45.977]                           }
[09:29:45.977]                           else {
[09:29:45.977]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:45.977]                               info, version)
[09:29:45.977]                           }
[09:29:45.977]                           base::stop(msg)
[09:29:45.977]                         }
[09:29:45.977]                       })
[09:29:45.977]                     }
[09:29:45.977]                     base::local({
[09:29:45.977]                       for (pkg in c("stats", "future.apply")) {
[09:29:45.977]                         base::loadNamespace(pkg)
[09:29:45.977]                         base::library(pkg, character.only = TRUE)
[09:29:45.977]                       }
[09:29:45.977]                     })
[09:29:45.977]                   }
[09:29:45.977]                   ...future.strategy.old <- future::plan("list")
[09:29:45.977]                   options(future.plan = NULL)
[09:29:45.977]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.977]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:45.977]                 }
[09:29:45.977]                 ...future.workdir <- getwd()
[09:29:45.977]             }
[09:29:45.977]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:45.977]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:45.977]         }
[09:29:45.977]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:45.977]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:45.977]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:45.977]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:45.977]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:45.977]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:45.977]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:45.977]             base::names(...future.oldOptions))
[09:29:45.977]     }
[09:29:45.977]     if (FALSE) {
[09:29:45.977]     }
[09:29:45.977]     else {
[09:29:45.977]         if (TRUE) {
[09:29:45.977]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:45.977]                 open = "w")
[09:29:45.977]         }
[09:29:45.977]         else {
[09:29:45.977]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:45.977]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:45.977]         }
[09:29:45.977]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:45.977]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:45.977]             base::sink(type = "output", split = FALSE)
[09:29:45.977]             base::close(...future.stdout)
[09:29:45.977]         }, add = TRUE)
[09:29:45.977]     }
[09:29:45.977]     ...future.frame <- base::sys.nframe()
[09:29:45.977]     ...future.conditions <- base::list()
[09:29:45.977]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:45.977]     if (FALSE) {
[09:29:45.977]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:45.977]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:45.977]     }
[09:29:45.977]     ...future.result <- base::tryCatch({
[09:29:45.977]         base::withCallingHandlers({
[09:29:45.977]             ...future.value <- base::withVisible(base::local({
[09:29:45.977]                 do.call(function(...) {
[09:29:45.977]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.977]                   if (!identical(...future.globals.maxSize.org, 
[09:29:45.977]                     ...future.globals.maxSize)) {
[09:29:45.977]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.977]                     on.exit(options(oopts), add = TRUE)
[09:29:45.977]                   }
[09:29:45.977]                   {
[09:29:45.977]                     lapply(seq_along(...future.elements_ii), 
[09:29:45.977]                       FUN = function(jj) {
[09:29:45.977]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.977]                         ...future.FUN(...future.X_jj, ...)
[09:29:45.977]                       })
[09:29:45.977]                   }
[09:29:45.977]                 }, args = future.call.arguments)
[09:29:45.977]             }))
[09:29:45.977]             future::FutureResult(value = ...future.value$value, 
[09:29:45.977]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.977]                   ...future.rng), globalenv = if (FALSE) 
[09:29:45.977]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:45.977]                     ...future.globalenv.names))
[09:29:45.977]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:45.977]         }, condition = base::local({
[09:29:45.977]             c <- base::c
[09:29:45.977]             inherits <- base::inherits
[09:29:45.977]             invokeRestart <- base::invokeRestart
[09:29:45.977]             length <- base::length
[09:29:45.977]             list <- base::list
[09:29:45.977]             seq.int <- base::seq.int
[09:29:45.977]             signalCondition <- base::signalCondition
[09:29:45.977]             sys.calls <- base::sys.calls
[09:29:45.977]             `[[` <- base::`[[`
[09:29:45.977]             `+` <- base::`+`
[09:29:45.977]             `<<-` <- base::`<<-`
[09:29:45.977]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:45.977]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:45.977]                   3L)]
[09:29:45.977]             }
[09:29:45.977]             function(cond) {
[09:29:45.977]                 is_error <- inherits(cond, "error")
[09:29:45.977]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:45.977]                   NULL)
[09:29:45.977]                 if (is_error) {
[09:29:45.977]                   sessionInformation <- function() {
[09:29:45.977]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:45.977]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:45.977]                       search = base::search(), system = base::Sys.info())
[09:29:45.977]                   }
[09:29:45.977]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.977]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:45.977]                     cond$call), session = sessionInformation(), 
[09:29:45.977]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:45.977]                   signalCondition(cond)
[09:29:45.977]                 }
[09:29:45.977]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:45.977]                 "immediateCondition"))) {
[09:29:45.977]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:45.977]                   ...future.conditions[[length(...future.conditions) + 
[09:29:45.977]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:45.977]                   if (TRUE && !signal) {
[09:29:45.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.977]                     {
[09:29:45.977]                       inherits <- base::inherits
[09:29:45.977]                       invokeRestart <- base::invokeRestart
[09:29:45.977]                       is.null <- base::is.null
[09:29:45.977]                       muffled <- FALSE
[09:29:45.977]                       if (inherits(cond, "message")) {
[09:29:45.977]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.977]                         if (muffled) 
[09:29:45.977]                           invokeRestart("muffleMessage")
[09:29:45.977]                       }
[09:29:45.977]                       else if (inherits(cond, "warning")) {
[09:29:45.977]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.977]                         if (muffled) 
[09:29:45.977]                           invokeRestart("muffleWarning")
[09:29:45.977]                       }
[09:29:45.977]                       else if (inherits(cond, "condition")) {
[09:29:45.977]                         if (!is.null(pattern)) {
[09:29:45.977]                           computeRestarts <- base::computeRestarts
[09:29:45.977]                           grepl <- base::grepl
[09:29:45.977]                           restarts <- computeRestarts(cond)
[09:29:45.977]                           for (restart in restarts) {
[09:29:45.977]                             name <- restart$name
[09:29:45.977]                             if (is.null(name)) 
[09:29:45.977]                               next
[09:29:45.977]                             if (!grepl(pattern, name)) 
[09:29:45.977]                               next
[09:29:45.977]                             invokeRestart(restart)
[09:29:45.977]                             muffled <- TRUE
[09:29:45.977]                             break
[09:29:45.977]                           }
[09:29:45.977]                         }
[09:29:45.977]                       }
[09:29:45.977]                       invisible(muffled)
[09:29:45.977]                     }
[09:29:45.977]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.977]                   }
[09:29:45.977]                 }
[09:29:45.977]                 else {
[09:29:45.977]                   if (TRUE) {
[09:29:45.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:45.977]                     {
[09:29:45.977]                       inherits <- base::inherits
[09:29:45.977]                       invokeRestart <- base::invokeRestart
[09:29:45.977]                       is.null <- base::is.null
[09:29:45.977]                       muffled <- FALSE
[09:29:45.977]                       if (inherits(cond, "message")) {
[09:29:45.977]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:45.977]                         if (muffled) 
[09:29:45.977]                           invokeRestart("muffleMessage")
[09:29:45.977]                       }
[09:29:45.977]                       else if (inherits(cond, "warning")) {
[09:29:45.977]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:45.977]                         if (muffled) 
[09:29:45.977]                           invokeRestart("muffleWarning")
[09:29:45.977]                       }
[09:29:45.977]                       else if (inherits(cond, "condition")) {
[09:29:45.977]                         if (!is.null(pattern)) {
[09:29:45.977]                           computeRestarts <- base::computeRestarts
[09:29:45.977]                           grepl <- base::grepl
[09:29:45.977]                           restarts <- computeRestarts(cond)
[09:29:45.977]                           for (restart in restarts) {
[09:29:45.977]                             name <- restart$name
[09:29:45.977]                             if (is.null(name)) 
[09:29:45.977]                               next
[09:29:45.977]                             if (!grepl(pattern, name)) 
[09:29:45.977]                               next
[09:29:45.977]                             invokeRestart(restart)
[09:29:45.977]                             muffled <- TRUE
[09:29:45.977]                             break
[09:29:45.977]                           }
[09:29:45.977]                         }
[09:29:45.977]                       }
[09:29:45.977]                       invisible(muffled)
[09:29:45.977]                     }
[09:29:45.977]                     muffleCondition(cond, pattern = "^muffle")
[09:29:45.977]                   }
[09:29:45.977]                 }
[09:29:45.977]             }
[09:29:45.977]         }))
[09:29:45.977]     }, error = function(ex) {
[09:29:45.977]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:45.977]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:45.977]                 ...future.rng), started = ...future.startTime, 
[09:29:45.977]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:45.977]             version = "1.8"), class = "FutureResult")
[09:29:45.977]     }, finally = {
[09:29:45.977]         if (!identical(...future.workdir, getwd())) 
[09:29:45.977]             setwd(...future.workdir)
[09:29:45.977]         {
[09:29:45.977]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:45.977]                 ...future.oldOptions$nwarnings <- NULL
[09:29:45.977]             }
[09:29:45.977]             base::options(...future.oldOptions)
[09:29:45.977]             if (.Platform$OS.type == "windows") {
[09:29:45.977]                 old_names <- names(...future.oldEnvVars)
[09:29:45.977]                 envs <- base::Sys.getenv()
[09:29:45.977]                 names <- names(envs)
[09:29:45.977]                 common <- intersect(names, old_names)
[09:29:45.977]                 added <- setdiff(names, old_names)
[09:29:45.977]                 removed <- setdiff(old_names, names)
[09:29:45.977]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:45.977]                   envs[common]]
[09:29:45.977]                 NAMES <- toupper(changed)
[09:29:45.977]                 args <- list()
[09:29:45.977]                 for (kk in seq_along(NAMES)) {
[09:29:45.977]                   name <- changed[[kk]]
[09:29:45.977]                   NAME <- NAMES[[kk]]
[09:29:45.977]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.977]                     next
[09:29:45.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.977]                 }
[09:29:45.977]                 NAMES <- toupper(added)
[09:29:45.977]                 for (kk in seq_along(NAMES)) {
[09:29:45.977]                   name <- added[[kk]]
[09:29:45.977]                   NAME <- NAMES[[kk]]
[09:29:45.977]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.977]                     next
[09:29:45.977]                   args[[name]] <- ""
[09:29:45.977]                 }
[09:29:45.977]                 NAMES <- toupper(removed)
[09:29:45.977]                 for (kk in seq_along(NAMES)) {
[09:29:45.977]                   name <- removed[[kk]]
[09:29:45.977]                   NAME <- NAMES[[kk]]
[09:29:45.977]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:45.977]                     next
[09:29:45.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:45.977]                 }
[09:29:45.977]                 if (length(args) > 0) 
[09:29:45.977]                   base::do.call(base::Sys.setenv, args = args)
[09:29:45.977]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:45.977]             }
[09:29:45.977]             else {
[09:29:45.977]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:45.977]             }
[09:29:45.977]             {
[09:29:45.977]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:45.977]                   0L) {
[09:29:45.977]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:45.977]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:45.977]                   base::options(opts)
[09:29:45.977]                 }
[09:29:45.977]                 {
[09:29:45.977]                   {
[09:29:45.977]                     NULL
[09:29:45.977]                     RNGkind("Mersenne-Twister")
[09:29:45.977]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:45.977]                       inherits = FALSE)
[09:29:45.977]                   }
[09:29:45.977]                   options(future.plan = NULL)
[09:29:45.977]                   if (is.na(NA_character_)) 
[09:29:45.977]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:45.977]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:45.977]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:45.977]                     .init = FALSE)
[09:29:45.977]                 }
[09:29:45.977]             }
[09:29:45.977]         }
[09:29:45.977]     })
[09:29:45.977]     if (TRUE) {
[09:29:45.977]         base::sink(type = "output", split = FALSE)
[09:29:45.977]         if (TRUE) {
[09:29:45.977]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:45.977]         }
[09:29:45.977]         else {
[09:29:45.977]             ...future.result["stdout"] <- base::list(NULL)
[09:29:45.977]         }
[09:29:45.977]         base::close(...future.stdout)
[09:29:45.977]         ...future.stdout <- NULL
[09:29:45.977]     }
[09:29:45.977]     ...future.result$conditions <- ...future.conditions
[09:29:45.977]     ...future.result$finished <- base::Sys.time()
[09:29:45.977]     ...future.result
[09:29:45.977] }
[09:29:45.979] assign_globals() ...
[09:29:45.979] List of 11
[09:29:45.979]  $ ...future.FUN            :function (x, ...)  
[09:29:45.979]  $ x_FUN                    :function (x, ...)  
[09:29:45.979]  $ times                    : int 5
[09:29:45.979]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:45.979]  $ stop_if_not              :function (...)  
[09:29:45.979]  $ dim                      : NULL
[09:29:45.979]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:45.979]  $ future.call.arguments    : list()
[09:29:45.979]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:45.979]  $ ...future.elements_ii    :List of 3
[09:29:45.979]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:29:45.979]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[09:29:45.979]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[09:29:45.979]  $ ...future.seeds_ii       : NULL
[09:29:45.979]  $ ...future.globals.maxSize: NULL
[09:29:45.979]  - attr(*, "where")=List of 11
[09:29:45.979]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:45.979]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:45.979]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:45.979]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:45.979]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:45.979]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:45.979]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:45.979]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:45.979]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:45.979]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:45.979]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:45.979]  - attr(*, "resolved")= logi FALSE
[09:29:45.979]  - attr(*, "total_size")= num 95528
[09:29:45.979]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:45.979]  - attr(*, "already-done")= logi TRUE
[09:29:45.986] - copied ‘...future.FUN’ to environment
[09:29:45.986] - copied ‘x_FUN’ to environment
[09:29:45.986] - copied ‘times’ to environment
[09:29:45.986] - copied ‘stopf’ to environment
[09:29:45.986] - copied ‘stop_if_not’ to environment
[09:29:45.986] - copied ‘dim’ to environment
[09:29:45.986] - copied ‘valid_types’ to environment
[09:29:45.987] - copied ‘future.call.arguments’ to environment
[09:29:45.987] - copied ‘...future.elements_ii’ to environment
[09:29:45.987] - copied ‘...future.seeds_ii’ to environment
[09:29:45.987] - copied ‘...future.globals.maxSize’ to environment
[09:29:45.987] assign_globals() ... done
[09:29:45.987] plan(): Setting new future strategy stack:
[09:29:45.987] List of future strategies:
[09:29:45.987] 1. sequential:
[09:29:45.987]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.987]    - tweaked: FALSE
[09:29:45.987]    - call: NULL
[09:29:45.988] plan(): nbrOfWorkers() = 1
[09:29:45.990] plan(): Setting new future strategy stack:
[09:29:45.990] List of future strategies:
[09:29:45.990] 1. sequential:
[09:29:45.990]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:45.990]    - tweaked: FALSE
[09:29:45.990]    - call: plan(strategy)
[09:29:45.990] plan(): nbrOfWorkers() = 1
[09:29:45.991] SequentialFuture started (and completed)
[09:29:45.991] - Launch lazy future ... done
[09:29:45.991] run() for ‘SequentialFuture’ ... done
[09:29:45.991] Created future:
[09:29:45.991] SequentialFuture:
[09:29:45.991] Label: ‘future_vapply-1’
[09:29:45.991] Expression:
[09:29:45.991] {
[09:29:45.991]     do.call(function(...) {
[09:29:45.991]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:45.991]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:45.991]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:45.991]             on.exit(options(oopts), add = TRUE)
[09:29:45.991]         }
[09:29:45.991]         {
[09:29:45.991]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:45.991]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:45.991]                 ...future.FUN(...future.X_jj, ...)
[09:29:45.991]             })
[09:29:45.991]         }
[09:29:45.991]     }, args = future.call.arguments)
[09:29:45.991] }
[09:29:45.991] Lazy evaluation: FALSE
[09:29:45.991] Asynchronous evaluation: FALSE
[09:29:45.991] Local evaluation: TRUE
[09:29:45.991] Environment: R_GlobalEnv
[09:29:45.991] Capture standard output: TRUE
[09:29:45.991] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:45.991] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:45.991] Packages: 2 packages (‘stats’, ‘future.apply’)
[09:29:45.991] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:45.991] Resolved: TRUE
[09:29:45.991] Value: 1.71 KiB of class ‘list’
[09:29:45.991] Early signaling: FALSE
[09:29:45.991] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:45.991] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:45.992] Chunk #1 of 1 ... DONE
[09:29:45.992] Launching 1 futures (chunks) ... DONE
[09:29:45.992] Resolving 1 futures (chunks) ...
[09:29:45.992] resolve() on list ...
[09:29:45.992]  recursive: 0
[09:29:45.992]  length: 1
[09:29:45.993] 
[09:29:45.993] resolved() for ‘SequentialFuture’ ...
[09:29:45.993] - state: ‘finished’
[09:29:45.993] - run: TRUE
[09:29:45.993] - result: ‘FutureResult’
[09:29:45.993] resolved() for ‘SequentialFuture’ ... done
[09:29:45.993] Future #1
[09:29:45.993] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:45.993] - nx: 1
[09:29:45.993] - relay: TRUE
[09:29:45.993] - stdout: TRUE
[09:29:45.994] - signal: TRUE
[09:29:45.994] - resignal: FALSE
[09:29:45.994] - force: TRUE
[09:29:45.994] - relayed: [n=1] FALSE
[09:29:45.994] - queued futures: [n=1] FALSE
[09:29:45.994]  - until=1
[09:29:45.994]  - relaying element #1
[09:29:45.994] - relayed: [n=1] TRUE
[09:29:45.994] - queued futures: [n=1] TRUE
[09:29:45.994] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:45.994]  length: 0 (resolved future 1)
[09:29:45.995] Relaying remaining futures
[09:29:45.995] signalConditionsASAP(NULL, pos=0) ...
[09:29:45.995] - nx: 1
[09:29:45.995] - relay: TRUE
[09:29:45.995] - stdout: TRUE
[09:29:45.995] - signal: TRUE
[09:29:45.995] - resignal: FALSE
[09:29:45.995] - force: TRUE
[09:29:45.995] - relayed: [n=1] TRUE
[09:29:45.995] - queued futures: [n=1] TRUE
 - flush all
[09:29:45.995] - relayed: [n=1] TRUE
[09:29:45.995] - queued futures: [n=1] TRUE
[09:29:45.996] signalConditionsASAP(NULL, pos=0) ... done
[09:29:45.996] resolve() on list ... DONE
[09:29:45.996]  - Number of value chunks collected: 1
[09:29:45.996] Resolving 1 futures (chunks) ... DONE
[09:29:45.996] Reducing values from 1 chunks ...
[09:29:45.996]  - Number of values collected after concatenation: 3
[09:29:45.996]  - Number of values expected: 3
[09:29:45.996] Reducing values from 1 chunks ... DONE
[09:29:45.996] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[09:29:45.998] future_lapply() ...
[09:29:46.001] Number of chunks: 1
[09:29:46.002] getGlobalsAndPackagesXApply() ...
[09:29:46.002]  - future.globals: TRUE
[09:29:46.002] getGlobalsAndPackages() ...
[09:29:46.002] Searching for globals...
[09:29:46.006] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[09:29:46.006] Searching for globals ... DONE
[09:29:46.006] Resolving globals: FALSE
[09:29:46.007] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[09:29:46.007] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[09:29:46.007] - globals: [1] ‘FUN’
[09:29:46.008] - packages: [1] ‘stats’
[09:29:46.008] getGlobalsAndPackages() ... DONE
[09:29:46.008]  - globals found/used: [n=1] ‘FUN’
[09:29:46.008]  - needed namespaces: [n=1] ‘stats’
[09:29:46.008] Finding globals ... DONE
[09:29:46.008]  - use_args: TRUE
[09:29:46.008]  - Getting '...' globals ...
[09:29:46.008] resolve() on list ...
[09:29:46.009]  recursive: 0
[09:29:46.009]  length: 1
[09:29:46.009]  elements: ‘...’
[09:29:46.009]  length: 0 (resolved future 1)
[09:29:46.009] resolve() on list ... DONE
[09:29:46.009]    - '...' content: [n=0] 
[09:29:46.009] List of 1
[09:29:46.009]  $ ...: list()
[09:29:46.009]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.009]  - attr(*, "where")=List of 1
[09:29:46.009]   ..$ ...:<environment: 0x561d3499d358> 
[09:29:46.009]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.009]  - attr(*, "resolved")= logi TRUE
[09:29:46.009]  - attr(*, "total_size")= num NA
[09:29:46.013]  - Getting '...' globals ... DONE
[09:29:46.013] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:29:46.013] List of 2
[09:29:46.013]  $ ...future.FUN:function (x, na.rm = TRUE)  
[09:29:46.013]  $ ...          : list()
[09:29:46.013]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.013]  - attr(*, "where")=List of 2
[09:29:46.013]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.013]   ..$ ...          :<environment: 0x561d3499d358> 
[09:29:46.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.013]  - attr(*, "resolved")= logi FALSE
[09:29:46.013]  - attr(*, "total_size")= num 46960
[09:29:46.016] Packages to be attached in all futures: [n=1] ‘stats’
[09:29:46.016] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.016] Number of futures (= number of chunks): 1
[09:29:46.016] Launching 1 futures (chunks) ...
[09:29:46.016] Chunk #1 of 1 ...
[09:29:46.016]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.016] getGlobalsAndPackages() ...
[09:29:46.016] Searching for globals...
[09:29:46.017] 
[09:29:46.017] Searching for globals ... DONE
[09:29:46.017] - globals: [0] <none>
[09:29:46.017] getGlobalsAndPackages() ... DONE
[09:29:46.017]    + additional globals found: [n=0] 
[09:29:46.017]    + additional namespaces needed: [n=0] 
[09:29:46.017]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.017]  - seeds: <none>
[09:29:46.017]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.017] getGlobalsAndPackages() ...
[09:29:46.017] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.018] Resolving globals: FALSE
[09:29:46.018] Tweak future expression to call with '...' arguments ...
[09:29:46.018] {
[09:29:46.018]     do.call(function(...) {
[09:29:46.018]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.018]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.018]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.018]             on.exit(options(oopts), add = TRUE)
[09:29:46.018]         }
[09:29:46.018]         {
[09:29:46.018]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.018]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.018]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.018]             })
[09:29:46.018]         }
[09:29:46.018]     }, args = future.call.arguments)
[09:29:46.018] }
[09:29:46.018] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.018] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.018] - packages: [1] ‘stats’
[09:29:46.018] getGlobalsAndPackages() ... DONE
[09:29:46.019] run() for ‘Future’ ...
[09:29:46.019] - state: ‘created’
[09:29:46.019] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:46.019] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.019] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:46.019]   - Field: ‘label’
[09:29:46.019]   - Field: ‘local’
[09:29:46.020]   - Field: ‘owner’
[09:29:46.020]   - Field: ‘envir’
[09:29:46.020]   - Field: ‘packages’
[09:29:46.020]   - Field: ‘gc’
[09:29:46.020]   - Field: ‘conditions’
[09:29:46.020]   - Field: ‘expr’
[09:29:46.020]   - Field: ‘uuid’
[09:29:46.020]   - Field: ‘seed’
[09:29:46.020]   - Field: ‘version’
[09:29:46.020]   - Field: ‘result’
[09:29:46.020]   - Field: ‘asynchronous’
[09:29:46.021]   - Field: ‘calls’
[09:29:46.021]   - Field: ‘globals’
[09:29:46.021]   - Field: ‘stdout’
[09:29:46.021]   - Field: ‘earlySignal’
[09:29:46.021]   - Field: ‘lazy’
[09:29:46.021]   - Field: ‘state’
[09:29:46.021] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:46.021] - Launch lazy future ...
[09:29:46.021] Packages needed by the future expression (n = 1): ‘stats’
[09:29:46.021] Packages needed by future strategies (n = 0): <none>
[09:29:46.022] {
[09:29:46.022]     {
[09:29:46.022]         {
[09:29:46.022]             ...future.startTime <- base::Sys.time()
[09:29:46.022]             {
[09:29:46.022]                 {
[09:29:46.022]                   {
[09:29:46.022]                     {
[09:29:46.022]                       base::local({
[09:29:46.022]                         has_future <- base::requireNamespace("future", 
[09:29:46.022]                           quietly = TRUE)
[09:29:46.022]                         if (has_future) {
[09:29:46.022]                           ns <- base::getNamespace("future")
[09:29:46.022]                           version <- ns[[".package"]][["version"]]
[09:29:46.022]                           if (is.null(version)) 
[09:29:46.022]                             version <- utils::packageVersion("future")
[09:29:46.022]                         }
[09:29:46.022]                         else {
[09:29:46.022]                           version <- NULL
[09:29:46.022]                         }
[09:29:46.022]                         if (!has_future || version < "1.8.0") {
[09:29:46.022]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.022]                             "", base::R.version$version.string), 
[09:29:46.022]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:46.022]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:46.022]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.022]                               "release", "version")], collapse = " "), 
[09:29:46.022]                             hostname = base::Sys.info()[["nodename"]])
[09:29:46.022]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.022]                             info)
[09:29:46.022]                           info <- base::paste(info, collapse = "; ")
[09:29:46.022]                           if (!has_future) {
[09:29:46.022]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.022]                               info)
[09:29:46.022]                           }
[09:29:46.022]                           else {
[09:29:46.022]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.022]                               info, version)
[09:29:46.022]                           }
[09:29:46.022]                           base::stop(msg)
[09:29:46.022]                         }
[09:29:46.022]                       })
[09:29:46.022]                     }
[09:29:46.022]                     base::local({
[09:29:46.022]                       for (pkg in "stats") {
[09:29:46.022]                         base::loadNamespace(pkg)
[09:29:46.022]                         base::library(pkg, character.only = TRUE)
[09:29:46.022]                       }
[09:29:46.022]                     })
[09:29:46.022]                   }
[09:29:46.022]                   ...future.strategy.old <- future::plan("list")
[09:29:46.022]                   options(future.plan = NULL)
[09:29:46.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.022]                 }
[09:29:46.022]                 ...future.workdir <- getwd()
[09:29:46.022]             }
[09:29:46.022]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.022]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.022]         }
[09:29:46.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.022]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:46.022]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.022]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.022]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.022]             base::names(...future.oldOptions))
[09:29:46.022]     }
[09:29:46.022]     if (FALSE) {
[09:29:46.022]     }
[09:29:46.022]     else {
[09:29:46.022]         if (TRUE) {
[09:29:46.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.022]                 open = "w")
[09:29:46.022]         }
[09:29:46.022]         else {
[09:29:46.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.022]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.022]         }
[09:29:46.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.022]             base::sink(type = "output", split = FALSE)
[09:29:46.022]             base::close(...future.stdout)
[09:29:46.022]         }, add = TRUE)
[09:29:46.022]     }
[09:29:46.022]     ...future.frame <- base::sys.nframe()
[09:29:46.022]     ...future.conditions <- base::list()
[09:29:46.022]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.022]     if (FALSE) {
[09:29:46.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.022]     }
[09:29:46.022]     ...future.result <- base::tryCatch({
[09:29:46.022]         base::withCallingHandlers({
[09:29:46.022]             ...future.value <- base::withVisible(base::local({
[09:29:46.022]                 do.call(function(...) {
[09:29:46.022]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.022]                   if (!identical(...future.globals.maxSize.org, 
[09:29:46.022]                     ...future.globals.maxSize)) {
[09:29:46.022]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.022]                     on.exit(options(oopts), add = TRUE)
[09:29:46.022]                   }
[09:29:46.022]                   {
[09:29:46.022]                     lapply(seq_along(...future.elements_ii), 
[09:29:46.022]                       FUN = function(jj) {
[09:29:46.022]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.022]                         ...future.FUN(...future.X_jj, ...)
[09:29:46.022]                       })
[09:29:46.022]                   }
[09:29:46.022]                 }, args = future.call.arguments)
[09:29:46.022]             }))
[09:29:46.022]             future::FutureResult(value = ...future.value$value, 
[09:29:46.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.022]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.022]                     ...future.globalenv.names))
[09:29:46.022]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.022]         }, condition = base::local({
[09:29:46.022]             c <- base::c
[09:29:46.022]             inherits <- base::inherits
[09:29:46.022]             invokeRestart <- base::invokeRestart
[09:29:46.022]             length <- base::length
[09:29:46.022]             list <- base::list
[09:29:46.022]             seq.int <- base::seq.int
[09:29:46.022]             signalCondition <- base::signalCondition
[09:29:46.022]             sys.calls <- base::sys.calls
[09:29:46.022]             `[[` <- base::`[[`
[09:29:46.022]             `+` <- base::`+`
[09:29:46.022]             `<<-` <- base::`<<-`
[09:29:46.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.022]                   3L)]
[09:29:46.022]             }
[09:29:46.022]             function(cond) {
[09:29:46.022]                 is_error <- inherits(cond, "error")
[09:29:46.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.022]                   NULL)
[09:29:46.022]                 if (is_error) {
[09:29:46.022]                   sessionInformation <- function() {
[09:29:46.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.022]                       search = base::search(), system = base::Sys.info())
[09:29:46.022]                   }
[09:29:46.022]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.022]                     cond$call), session = sessionInformation(), 
[09:29:46.022]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.022]                   signalCondition(cond)
[09:29:46.022]                 }
[09:29:46.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.022]                 "immediateCondition"))) {
[09:29:46.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.022]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.022]                   if (TRUE && !signal) {
[09:29:46.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.022]                     {
[09:29:46.022]                       inherits <- base::inherits
[09:29:46.022]                       invokeRestart <- base::invokeRestart
[09:29:46.022]                       is.null <- base::is.null
[09:29:46.022]                       muffled <- FALSE
[09:29:46.022]                       if (inherits(cond, "message")) {
[09:29:46.022]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.022]                         if (muffled) 
[09:29:46.022]                           invokeRestart("muffleMessage")
[09:29:46.022]                       }
[09:29:46.022]                       else if (inherits(cond, "warning")) {
[09:29:46.022]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.022]                         if (muffled) 
[09:29:46.022]                           invokeRestart("muffleWarning")
[09:29:46.022]                       }
[09:29:46.022]                       else if (inherits(cond, "condition")) {
[09:29:46.022]                         if (!is.null(pattern)) {
[09:29:46.022]                           computeRestarts <- base::computeRestarts
[09:29:46.022]                           grepl <- base::grepl
[09:29:46.022]                           restarts <- computeRestarts(cond)
[09:29:46.022]                           for (restart in restarts) {
[09:29:46.022]                             name <- restart$name
[09:29:46.022]                             if (is.null(name)) 
[09:29:46.022]                               next
[09:29:46.022]                             if (!grepl(pattern, name)) 
[09:29:46.022]                               next
[09:29:46.022]                             invokeRestart(restart)
[09:29:46.022]                             muffled <- TRUE
[09:29:46.022]                             break
[09:29:46.022]                           }
[09:29:46.022]                         }
[09:29:46.022]                       }
[09:29:46.022]                       invisible(muffled)
[09:29:46.022]                     }
[09:29:46.022]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.022]                   }
[09:29:46.022]                 }
[09:29:46.022]                 else {
[09:29:46.022]                   if (TRUE) {
[09:29:46.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.022]                     {
[09:29:46.022]                       inherits <- base::inherits
[09:29:46.022]                       invokeRestart <- base::invokeRestart
[09:29:46.022]                       is.null <- base::is.null
[09:29:46.022]                       muffled <- FALSE
[09:29:46.022]                       if (inherits(cond, "message")) {
[09:29:46.022]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.022]                         if (muffled) 
[09:29:46.022]                           invokeRestart("muffleMessage")
[09:29:46.022]                       }
[09:29:46.022]                       else if (inherits(cond, "warning")) {
[09:29:46.022]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.022]                         if (muffled) 
[09:29:46.022]                           invokeRestart("muffleWarning")
[09:29:46.022]                       }
[09:29:46.022]                       else if (inherits(cond, "condition")) {
[09:29:46.022]                         if (!is.null(pattern)) {
[09:29:46.022]                           computeRestarts <- base::computeRestarts
[09:29:46.022]                           grepl <- base::grepl
[09:29:46.022]                           restarts <- computeRestarts(cond)
[09:29:46.022]                           for (restart in restarts) {
[09:29:46.022]                             name <- restart$name
[09:29:46.022]                             if (is.null(name)) 
[09:29:46.022]                               next
[09:29:46.022]                             if (!grepl(pattern, name)) 
[09:29:46.022]                               next
[09:29:46.022]                             invokeRestart(restart)
[09:29:46.022]                             muffled <- TRUE
[09:29:46.022]                             break
[09:29:46.022]                           }
[09:29:46.022]                         }
[09:29:46.022]                       }
[09:29:46.022]                       invisible(muffled)
[09:29:46.022]                     }
[09:29:46.022]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.022]                   }
[09:29:46.022]                 }
[09:29:46.022]             }
[09:29:46.022]         }))
[09:29:46.022]     }, error = function(ex) {
[09:29:46.022]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.022]                 ...future.rng), started = ...future.startTime, 
[09:29:46.022]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.022]             version = "1.8"), class = "FutureResult")
[09:29:46.022]     }, finally = {
[09:29:46.022]         if (!identical(...future.workdir, getwd())) 
[09:29:46.022]             setwd(...future.workdir)
[09:29:46.022]         {
[09:29:46.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.022]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.022]             }
[09:29:46.022]             base::options(...future.oldOptions)
[09:29:46.022]             if (.Platform$OS.type == "windows") {
[09:29:46.022]                 old_names <- names(...future.oldEnvVars)
[09:29:46.022]                 envs <- base::Sys.getenv()
[09:29:46.022]                 names <- names(envs)
[09:29:46.022]                 common <- intersect(names, old_names)
[09:29:46.022]                 added <- setdiff(names, old_names)
[09:29:46.022]                 removed <- setdiff(old_names, names)
[09:29:46.022]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.022]                   envs[common]]
[09:29:46.022]                 NAMES <- toupper(changed)
[09:29:46.022]                 args <- list()
[09:29:46.022]                 for (kk in seq_along(NAMES)) {
[09:29:46.022]                   name <- changed[[kk]]
[09:29:46.022]                   NAME <- NAMES[[kk]]
[09:29:46.022]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.022]                     next
[09:29:46.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.022]                 }
[09:29:46.022]                 NAMES <- toupper(added)
[09:29:46.022]                 for (kk in seq_along(NAMES)) {
[09:29:46.022]                   name <- added[[kk]]
[09:29:46.022]                   NAME <- NAMES[[kk]]
[09:29:46.022]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.022]                     next
[09:29:46.022]                   args[[name]] <- ""
[09:29:46.022]                 }
[09:29:46.022]                 NAMES <- toupper(removed)
[09:29:46.022]                 for (kk in seq_along(NAMES)) {
[09:29:46.022]                   name <- removed[[kk]]
[09:29:46.022]                   NAME <- NAMES[[kk]]
[09:29:46.022]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.022]                     next
[09:29:46.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.022]                 }
[09:29:46.022]                 if (length(args) > 0) 
[09:29:46.022]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.022]             }
[09:29:46.022]             else {
[09:29:46.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.022]             }
[09:29:46.022]             {
[09:29:46.022]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.022]                   0L) {
[09:29:46.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.022]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.022]                   base::options(opts)
[09:29:46.022]                 }
[09:29:46.022]                 {
[09:29:46.022]                   {
[09:29:46.022]                     NULL
[09:29:46.022]                     RNGkind("Mersenne-Twister")
[09:29:46.022]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:46.022]                       inherits = FALSE)
[09:29:46.022]                   }
[09:29:46.022]                   options(future.plan = NULL)
[09:29:46.022]                   if (is.na(NA_character_)) 
[09:29:46.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.022]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.022]                     .init = FALSE)
[09:29:46.022]                 }
[09:29:46.022]             }
[09:29:46.022]         }
[09:29:46.022]     })
[09:29:46.022]     if (TRUE) {
[09:29:46.022]         base::sink(type = "output", split = FALSE)
[09:29:46.022]         if (TRUE) {
[09:29:46.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.022]         }
[09:29:46.022]         else {
[09:29:46.022]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.022]         }
[09:29:46.022]         base::close(...future.stdout)
[09:29:46.022]         ...future.stdout <- NULL
[09:29:46.022]     }
[09:29:46.022]     ...future.result$conditions <- ...future.conditions
[09:29:46.022]     ...future.result$finished <- base::Sys.time()
[09:29:46.022]     ...future.result
[09:29:46.022] }
[09:29:46.023] assign_globals() ...
[09:29:46.024] List of 5
[09:29:46.024]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[09:29:46.024]  $ future.call.arguments    : list()
[09:29:46.024]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.024]  $ ...future.elements_ii    :List of 7
[09:29:46.024]   ..$ : int [1:3] 1 2 3
[09:29:46.024]   ..$ : int [1:4] 1 2 3 4
[09:29:46.024]   ..$ : int [1:5] 1 2 3 4 5
[09:29:46.024]   ..$ : int [1:6] 1 2 3 4 5 6
[09:29:46.024]   ..$ : int [1:7] 1 2 3 4 5 6 7
[09:29:46.024]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[09:29:46.024]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[09:29:46.024]  $ ...future.seeds_ii       : NULL
[09:29:46.024]  $ ...future.globals.maxSize: NULL
[09:29:46.024]  - attr(*, "where")=List of 5
[09:29:46.024]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.024]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.024]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.024]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.024]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.024]  - attr(*, "resolved")= logi FALSE
[09:29:46.024]  - attr(*, "total_size")= num 46960
[09:29:46.024]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.024]  - attr(*, "already-done")= logi TRUE
[09:29:46.029] - copied ‘...future.FUN’ to environment
[09:29:46.030] - copied ‘future.call.arguments’ to environment
[09:29:46.030] - copied ‘...future.elements_ii’ to environment
[09:29:46.030] - copied ‘...future.seeds_ii’ to environment
[09:29:46.030] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.030] assign_globals() ... done
[09:29:46.030] plan(): Setting new future strategy stack:
[09:29:46.030] List of future strategies:
[09:29:46.030] 1. sequential:
[09:29:46.030]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.030]    - tweaked: FALSE
[09:29:46.030]    - call: NULL
[09:29:46.031] plan(): nbrOfWorkers() = 1
[09:29:46.031] plan(): Setting new future strategy stack:
[09:29:46.032] List of future strategies:
[09:29:46.032] 1. sequential:
[09:29:46.032]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.032]    - tweaked: FALSE
[09:29:46.032]    - call: plan(strategy)
[09:29:46.032] plan(): nbrOfWorkers() = 1
[09:29:46.032] SequentialFuture started (and completed)
[09:29:46.032] - Launch lazy future ... done
[09:29:46.032] run() for ‘SequentialFuture’ ... done
[09:29:46.032] Created future:
[09:29:46.033] SequentialFuture:
[09:29:46.033] Label: ‘future_sapply-1’
[09:29:46.033] Expression:
[09:29:46.033] {
[09:29:46.033]     do.call(function(...) {
[09:29:46.033]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.033]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.033]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.033]             on.exit(options(oopts), add = TRUE)
[09:29:46.033]         }
[09:29:46.033]         {
[09:29:46.033]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.033]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.033]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.033]             })
[09:29:46.033]         }
[09:29:46.033]     }, args = future.call.arguments)
[09:29:46.033] }
[09:29:46.033] Lazy evaluation: FALSE
[09:29:46.033] Asynchronous evaluation: FALSE
[09:29:46.033] Local evaluation: TRUE
[09:29:46.033] Environment: R_GlobalEnv
[09:29:46.033] Capture standard output: TRUE
[09:29:46.033] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.033] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:46.033] Packages: 1 packages (‘stats’)
[09:29:46.033] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.033] Resolved: TRUE
[09:29:46.033] Value: 672 bytes of class ‘list’
[09:29:46.033] Early signaling: FALSE
[09:29:46.033] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.033] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.034] Chunk #1 of 1 ... DONE
[09:29:46.035] Launching 1 futures (chunks) ... DONE
[09:29:46.035] Resolving 1 futures (chunks) ...
[09:29:46.035] resolve() on list ...
[09:29:46.035]  recursive: 0
[09:29:46.035]  length: 1
[09:29:46.035] 
[09:29:46.035] resolved() for ‘SequentialFuture’ ...
[09:29:46.035] - state: ‘finished’
[09:29:46.035] - run: TRUE
[09:29:46.035] - result: ‘FutureResult’
[09:29:46.035] resolved() for ‘SequentialFuture’ ... done
[09:29:46.036] Future #1
[09:29:46.036] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:46.036] - nx: 1
[09:29:46.036] - relay: TRUE
[09:29:46.036] - stdout: TRUE
[09:29:46.036] - signal: TRUE
[09:29:46.036] - resignal: FALSE
[09:29:46.036] - force: TRUE
[09:29:46.036] - relayed: [n=1] FALSE
[09:29:46.036] - queued futures: [n=1] FALSE
[09:29:46.036]  - until=1
[09:29:46.037]  - relaying element #1
[09:29:46.037] - relayed: [n=1] TRUE
[09:29:46.037] - queued futures: [n=1] TRUE
[09:29:46.037] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:46.037]  length: 0 (resolved future 1)
[09:29:46.037] Relaying remaining futures
[09:29:46.037] signalConditionsASAP(NULL, pos=0) ...
[09:29:46.037] - nx: 1
[09:29:46.037] - relay: TRUE
[09:29:46.037] - stdout: TRUE
[09:29:46.037] - signal: TRUE
[09:29:46.037] - resignal: FALSE
[09:29:46.038] - force: TRUE
[09:29:46.038] - relayed: [n=1] TRUE
[09:29:46.038] - queued futures: [n=1] TRUE
 - flush all
[09:29:46.038] - relayed: [n=1] TRUE
[09:29:46.038] - queued futures: [n=1] TRUE
[09:29:46.038] signalConditionsASAP(NULL, pos=0) ... done
[09:29:46.038] resolve() on list ... DONE
[09:29:46.038]  - Number of value chunks collected: 1
[09:29:46.038] Resolving 1 futures (chunks) ... DONE
[09:29:46.038] Reducing values from 1 chunks ...
[09:29:46.038]  - Number of values collected after concatenation: 7
[09:29:46.039]  - Number of values expected: 7
[09:29:46.039] Reducing values from 1 chunks ... DONE
[09:29:46.039] future_lapply() ... DONE
[09:29:46.039] future_lapply() ...
[09:29:46.041] Number of chunks: 1
[09:29:46.041] getGlobalsAndPackagesXApply() ...
[09:29:46.041]  - future.globals: TRUE
[09:29:46.041] getGlobalsAndPackages() ...
[09:29:46.041] Searching for globals...
[09:29:46.047] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[09:29:46.047] Searching for globals ... DONE
[09:29:46.047] Resolving globals: FALSE
[09:29:46.048] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[09:29:46.049] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[09:29:46.049] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.049] - packages: [2] ‘stats’, ‘future.apply’
[09:29:46.049] getGlobalsAndPackages() ... DONE
[09:29:46.049]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.049]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[09:29:46.049] Finding globals ... DONE
[09:29:46.050]  - use_args: TRUE
[09:29:46.050]  - Getting '...' globals ...
[09:29:46.050] resolve() on list ...
[09:29:46.050]  recursive: 0
[09:29:46.050]  length: 1
[09:29:46.050]  elements: ‘...’
[09:29:46.050]  length: 0 (resolved future 1)
[09:29:46.050] resolve() on list ... DONE
[09:29:46.050]    - '...' content: [n=0] 
[09:29:46.051] List of 1
[09:29:46.051]  $ ...: list()
[09:29:46.051]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.051]  - attr(*, "where")=List of 1
[09:29:46.051]   ..$ ...:<environment: 0x561d341c2568> 
[09:29:46.051]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.051]  - attr(*, "resolved")= logi TRUE
[09:29:46.051]  - attr(*, "total_size")= num NA
[09:29:46.053]  - Getting '...' globals ... DONE
[09:29:46.054] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:46.054] List of 8
[09:29:46.054]  $ ...future.FUN:function (x, ...)  
[09:29:46.054]  $ x_FUN        :function (x, na.rm = TRUE)  
[09:29:46.054]  $ times        : int 5
[09:29:46.054]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.054]  $ stop_if_not  :function (...)  
[09:29:46.054]  $ dim          : NULL
[09:29:46.054]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:46.054]  $ ...          : list()
[09:29:46.054]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.054]  - attr(*, "where")=List of 8
[09:29:46.054]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.054]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:46.054]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:46.054]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:46.054]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:46.054]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:46.054]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:46.054]   ..$ ...          :<environment: 0x561d341c2568> 
[09:29:46.054]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.054]  - attr(*, "resolved")= logi FALSE
[09:29:46.054]  - attr(*, "total_size")= num 141240
[09:29:46.059] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[09:29:46.059] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.059] Number of futures (= number of chunks): 1
[09:29:46.059] Launching 1 futures (chunks) ...
[09:29:46.059] Chunk #1 of 1 ...
[09:29:46.060]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.060] getGlobalsAndPackages() ...
[09:29:46.060] Searching for globals...
[09:29:46.060] 
[09:29:46.060] Searching for globals ... DONE
[09:29:46.060] - globals: [0] <none>
[09:29:46.060] getGlobalsAndPackages() ... DONE
[09:29:46.060]    + additional globals found: [n=0] 
[09:29:46.060]    + additional namespaces needed: [n=0] 
[09:29:46.060]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.060]  - seeds: <none>
[09:29:46.061]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.061] getGlobalsAndPackages() ...
[09:29:46.061] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.061] Resolving globals: FALSE
[09:29:46.061] Tweak future expression to call with '...' arguments ...
[09:29:46.061] {
[09:29:46.061]     do.call(function(...) {
[09:29:46.061]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.061]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.061]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.061]             on.exit(options(oopts), add = TRUE)
[09:29:46.061]         }
[09:29:46.061]         {
[09:29:46.061]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.061]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.061]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.061]             })
[09:29:46.061]         }
[09:29:46.061]     }, args = future.call.arguments)
[09:29:46.061] }
[09:29:46.061] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.062] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.062] - packages: [2] ‘stats’, ‘future.apply’
[09:29:46.062] getGlobalsAndPackages() ... DONE
[09:29:46.062] run() for ‘Future’ ...
[09:29:46.062] - state: ‘created’
[09:29:46.062] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:46.063] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:46.063]   - Field: ‘label’
[09:29:46.063]   - Field: ‘local’
[09:29:46.063]   - Field: ‘owner’
[09:29:46.063]   - Field: ‘envir’
[09:29:46.063]   - Field: ‘packages’
[09:29:46.063]   - Field: ‘gc’
[09:29:46.063]   - Field: ‘conditions’
[09:29:46.063]   - Field: ‘expr’
[09:29:46.064]   - Field: ‘uuid’
[09:29:46.064]   - Field: ‘seed’
[09:29:46.064]   - Field: ‘version’
[09:29:46.064]   - Field: ‘result’
[09:29:46.064]   - Field: ‘asynchronous’
[09:29:46.064]   - Field: ‘calls’
[09:29:46.064]   - Field: ‘globals’
[09:29:46.064]   - Field: ‘stdout’
[09:29:46.064]   - Field: ‘earlySignal’
[09:29:46.064]   - Field: ‘lazy’
[09:29:46.064]   - Field: ‘state’
[09:29:46.064] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:46.065] - Launch lazy future ...
[09:29:46.065] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[09:29:46.065] Packages needed by future strategies (n = 0): <none>
[09:29:46.065] {
[09:29:46.065]     {
[09:29:46.065]         {
[09:29:46.065]             ...future.startTime <- base::Sys.time()
[09:29:46.065]             {
[09:29:46.065]                 {
[09:29:46.065]                   {
[09:29:46.065]                     {
[09:29:46.065]                       base::local({
[09:29:46.065]                         has_future <- base::requireNamespace("future", 
[09:29:46.065]                           quietly = TRUE)
[09:29:46.065]                         if (has_future) {
[09:29:46.065]                           ns <- base::getNamespace("future")
[09:29:46.065]                           version <- ns[[".package"]][["version"]]
[09:29:46.065]                           if (is.null(version)) 
[09:29:46.065]                             version <- utils::packageVersion("future")
[09:29:46.065]                         }
[09:29:46.065]                         else {
[09:29:46.065]                           version <- NULL
[09:29:46.065]                         }
[09:29:46.065]                         if (!has_future || version < "1.8.0") {
[09:29:46.065]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.065]                             "", base::R.version$version.string), 
[09:29:46.065]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:46.065]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:46.065]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.065]                               "release", "version")], collapse = " "), 
[09:29:46.065]                             hostname = base::Sys.info()[["nodename"]])
[09:29:46.065]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.065]                             info)
[09:29:46.065]                           info <- base::paste(info, collapse = "; ")
[09:29:46.065]                           if (!has_future) {
[09:29:46.065]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.065]                               info)
[09:29:46.065]                           }
[09:29:46.065]                           else {
[09:29:46.065]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.065]                               info, version)
[09:29:46.065]                           }
[09:29:46.065]                           base::stop(msg)
[09:29:46.065]                         }
[09:29:46.065]                       })
[09:29:46.065]                     }
[09:29:46.065]                     base::local({
[09:29:46.065]                       for (pkg in c("stats", "future.apply")) {
[09:29:46.065]                         base::loadNamespace(pkg)
[09:29:46.065]                         base::library(pkg, character.only = TRUE)
[09:29:46.065]                       }
[09:29:46.065]                     })
[09:29:46.065]                   }
[09:29:46.065]                   ...future.strategy.old <- future::plan("list")
[09:29:46.065]                   options(future.plan = NULL)
[09:29:46.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.065]                 }
[09:29:46.065]                 ...future.workdir <- getwd()
[09:29:46.065]             }
[09:29:46.065]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.065]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.065]         }
[09:29:46.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.065]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:46.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.065]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.065]             base::names(...future.oldOptions))
[09:29:46.065]     }
[09:29:46.065]     if (FALSE) {
[09:29:46.065]     }
[09:29:46.065]     else {
[09:29:46.065]         if (TRUE) {
[09:29:46.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.065]                 open = "w")
[09:29:46.065]         }
[09:29:46.065]         else {
[09:29:46.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.065]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.065]         }
[09:29:46.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.065]             base::sink(type = "output", split = FALSE)
[09:29:46.065]             base::close(...future.stdout)
[09:29:46.065]         }, add = TRUE)
[09:29:46.065]     }
[09:29:46.065]     ...future.frame <- base::sys.nframe()
[09:29:46.065]     ...future.conditions <- base::list()
[09:29:46.065]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.065]     if (FALSE) {
[09:29:46.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.065]     }
[09:29:46.065]     ...future.result <- base::tryCatch({
[09:29:46.065]         base::withCallingHandlers({
[09:29:46.065]             ...future.value <- base::withVisible(base::local({
[09:29:46.065]                 do.call(function(...) {
[09:29:46.065]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.065]                   if (!identical(...future.globals.maxSize.org, 
[09:29:46.065]                     ...future.globals.maxSize)) {
[09:29:46.065]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.065]                     on.exit(options(oopts), add = TRUE)
[09:29:46.065]                   }
[09:29:46.065]                   {
[09:29:46.065]                     lapply(seq_along(...future.elements_ii), 
[09:29:46.065]                       FUN = function(jj) {
[09:29:46.065]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.065]                         ...future.FUN(...future.X_jj, ...)
[09:29:46.065]                       })
[09:29:46.065]                   }
[09:29:46.065]                 }, args = future.call.arguments)
[09:29:46.065]             }))
[09:29:46.065]             future::FutureResult(value = ...future.value$value, 
[09:29:46.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.065]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.065]                     ...future.globalenv.names))
[09:29:46.065]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.065]         }, condition = base::local({
[09:29:46.065]             c <- base::c
[09:29:46.065]             inherits <- base::inherits
[09:29:46.065]             invokeRestart <- base::invokeRestart
[09:29:46.065]             length <- base::length
[09:29:46.065]             list <- base::list
[09:29:46.065]             seq.int <- base::seq.int
[09:29:46.065]             signalCondition <- base::signalCondition
[09:29:46.065]             sys.calls <- base::sys.calls
[09:29:46.065]             `[[` <- base::`[[`
[09:29:46.065]             `+` <- base::`+`
[09:29:46.065]             `<<-` <- base::`<<-`
[09:29:46.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.065]                   3L)]
[09:29:46.065]             }
[09:29:46.065]             function(cond) {
[09:29:46.065]                 is_error <- inherits(cond, "error")
[09:29:46.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.065]                   NULL)
[09:29:46.065]                 if (is_error) {
[09:29:46.065]                   sessionInformation <- function() {
[09:29:46.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.065]                       search = base::search(), system = base::Sys.info())
[09:29:46.065]                   }
[09:29:46.065]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.065]                     cond$call), session = sessionInformation(), 
[09:29:46.065]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.065]                   signalCondition(cond)
[09:29:46.065]                 }
[09:29:46.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.065]                 "immediateCondition"))) {
[09:29:46.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.065]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.065]                   if (TRUE && !signal) {
[09:29:46.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.065]                     {
[09:29:46.065]                       inherits <- base::inherits
[09:29:46.065]                       invokeRestart <- base::invokeRestart
[09:29:46.065]                       is.null <- base::is.null
[09:29:46.065]                       muffled <- FALSE
[09:29:46.065]                       if (inherits(cond, "message")) {
[09:29:46.065]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.065]                         if (muffled) 
[09:29:46.065]                           invokeRestart("muffleMessage")
[09:29:46.065]                       }
[09:29:46.065]                       else if (inherits(cond, "warning")) {
[09:29:46.065]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.065]                         if (muffled) 
[09:29:46.065]                           invokeRestart("muffleWarning")
[09:29:46.065]                       }
[09:29:46.065]                       else if (inherits(cond, "condition")) {
[09:29:46.065]                         if (!is.null(pattern)) {
[09:29:46.065]                           computeRestarts <- base::computeRestarts
[09:29:46.065]                           grepl <- base::grepl
[09:29:46.065]                           restarts <- computeRestarts(cond)
[09:29:46.065]                           for (restart in restarts) {
[09:29:46.065]                             name <- restart$name
[09:29:46.065]                             if (is.null(name)) 
[09:29:46.065]                               next
[09:29:46.065]                             if (!grepl(pattern, name)) 
[09:29:46.065]                               next
[09:29:46.065]                             invokeRestart(restart)
[09:29:46.065]                             muffled <- TRUE
[09:29:46.065]                             break
[09:29:46.065]                           }
[09:29:46.065]                         }
[09:29:46.065]                       }
[09:29:46.065]                       invisible(muffled)
[09:29:46.065]                     }
[09:29:46.065]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.065]                   }
[09:29:46.065]                 }
[09:29:46.065]                 else {
[09:29:46.065]                   if (TRUE) {
[09:29:46.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.065]                     {
[09:29:46.065]                       inherits <- base::inherits
[09:29:46.065]                       invokeRestart <- base::invokeRestart
[09:29:46.065]                       is.null <- base::is.null
[09:29:46.065]                       muffled <- FALSE
[09:29:46.065]                       if (inherits(cond, "message")) {
[09:29:46.065]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.065]                         if (muffled) 
[09:29:46.065]                           invokeRestart("muffleMessage")
[09:29:46.065]                       }
[09:29:46.065]                       else if (inherits(cond, "warning")) {
[09:29:46.065]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.065]                         if (muffled) 
[09:29:46.065]                           invokeRestart("muffleWarning")
[09:29:46.065]                       }
[09:29:46.065]                       else if (inherits(cond, "condition")) {
[09:29:46.065]                         if (!is.null(pattern)) {
[09:29:46.065]                           computeRestarts <- base::computeRestarts
[09:29:46.065]                           grepl <- base::grepl
[09:29:46.065]                           restarts <- computeRestarts(cond)
[09:29:46.065]                           for (restart in restarts) {
[09:29:46.065]                             name <- restart$name
[09:29:46.065]                             if (is.null(name)) 
[09:29:46.065]                               next
[09:29:46.065]                             if (!grepl(pattern, name)) 
[09:29:46.065]                               next
[09:29:46.065]                             invokeRestart(restart)
[09:29:46.065]                             muffled <- TRUE
[09:29:46.065]                             break
[09:29:46.065]                           }
[09:29:46.065]                         }
[09:29:46.065]                       }
[09:29:46.065]                       invisible(muffled)
[09:29:46.065]                     }
[09:29:46.065]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.065]                   }
[09:29:46.065]                 }
[09:29:46.065]             }
[09:29:46.065]         }))
[09:29:46.065]     }, error = function(ex) {
[09:29:46.065]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.065]                 ...future.rng), started = ...future.startTime, 
[09:29:46.065]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.065]             version = "1.8"), class = "FutureResult")
[09:29:46.065]     }, finally = {
[09:29:46.065]         if (!identical(...future.workdir, getwd())) 
[09:29:46.065]             setwd(...future.workdir)
[09:29:46.065]         {
[09:29:46.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.065]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.065]             }
[09:29:46.065]             base::options(...future.oldOptions)
[09:29:46.065]             if (.Platform$OS.type == "windows") {
[09:29:46.065]                 old_names <- names(...future.oldEnvVars)
[09:29:46.065]                 envs <- base::Sys.getenv()
[09:29:46.065]                 names <- names(envs)
[09:29:46.065]                 common <- intersect(names, old_names)
[09:29:46.065]                 added <- setdiff(names, old_names)
[09:29:46.065]                 removed <- setdiff(old_names, names)
[09:29:46.065]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.065]                   envs[common]]
[09:29:46.065]                 NAMES <- toupper(changed)
[09:29:46.065]                 args <- list()
[09:29:46.065]                 for (kk in seq_along(NAMES)) {
[09:29:46.065]                   name <- changed[[kk]]
[09:29:46.065]                   NAME <- NAMES[[kk]]
[09:29:46.065]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.065]                     next
[09:29:46.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.065]                 }
[09:29:46.065]                 NAMES <- toupper(added)
[09:29:46.065]                 for (kk in seq_along(NAMES)) {
[09:29:46.065]                   name <- added[[kk]]
[09:29:46.065]                   NAME <- NAMES[[kk]]
[09:29:46.065]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.065]                     next
[09:29:46.065]                   args[[name]] <- ""
[09:29:46.065]                 }
[09:29:46.065]                 NAMES <- toupper(removed)
[09:29:46.065]                 for (kk in seq_along(NAMES)) {
[09:29:46.065]                   name <- removed[[kk]]
[09:29:46.065]                   NAME <- NAMES[[kk]]
[09:29:46.065]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.065]                     next
[09:29:46.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.065]                 }
[09:29:46.065]                 if (length(args) > 0) 
[09:29:46.065]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.065]             }
[09:29:46.065]             else {
[09:29:46.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.065]             }
[09:29:46.065]             {
[09:29:46.065]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.065]                   0L) {
[09:29:46.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.065]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.065]                   base::options(opts)
[09:29:46.065]                 }
[09:29:46.065]                 {
[09:29:46.065]                   {
[09:29:46.065]                     NULL
[09:29:46.065]                     RNGkind("Mersenne-Twister")
[09:29:46.065]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:46.065]                       inherits = FALSE)
[09:29:46.065]                   }
[09:29:46.065]                   options(future.plan = NULL)
[09:29:46.065]                   if (is.na(NA_character_)) 
[09:29:46.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.065]                     .init = FALSE)
[09:29:46.065]                 }
[09:29:46.065]             }
[09:29:46.065]         }
[09:29:46.065]     })
[09:29:46.065]     if (TRUE) {
[09:29:46.065]         base::sink(type = "output", split = FALSE)
[09:29:46.065]         if (TRUE) {
[09:29:46.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.065]         }
[09:29:46.065]         else {
[09:29:46.065]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.065]         }
[09:29:46.065]         base::close(...future.stdout)
[09:29:46.065]         ...future.stdout <- NULL
[09:29:46.065]     }
[09:29:46.065]     ...future.result$conditions <- ...future.conditions
[09:29:46.065]     ...future.result$finished <- base::Sys.time()
[09:29:46.065]     ...future.result
[09:29:46.065] }
[09:29:46.067] assign_globals() ...
[09:29:46.067] List of 11
[09:29:46.067]  $ ...future.FUN            :function (x, ...)  
[09:29:46.067]  $ x_FUN                    :function (x, na.rm = TRUE)  
[09:29:46.067]  $ times                    : int 5
[09:29:46.067]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.067]  $ stop_if_not              :function (...)  
[09:29:46.067]  $ dim                      : NULL
[09:29:46.067]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:46.067]  $ future.call.arguments    : list()
[09:29:46.067]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.067]  $ ...future.elements_ii    :List of 7
[09:29:46.067]   ..$ : int [1:3] 1 2 3
[09:29:46.067]   ..$ : int [1:4] 1 2 3 4
[09:29:46.067]   ..$ : int [1:5] 1 2 3 4 5
[09:29:46.067]   ..$ : int [1:6] 1 2 3 4 5 6
[09:29:46.067]   ..$ : int [1:7] 1 2 3 4 5 6 7
[09:29:46.067]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[09:29:46.067]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[09:29:46.067]  $ ...future.seeds_ii       : NULL
[09:29:46.067]  $ ...future.globals.maxSize: NULL
[09:29:46.067]  - attr(*, "where")=List of 11
[09:29:46.067]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.067]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.067]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.067]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.067]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.067]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.067]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.067]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.067]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.067]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.067]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.067]  - attr(*, "resolved")= logi FALSE
[09:29:46.067]  - attr(*, "total_size")= num 141240
[09:29:46.067]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.067]  - attr(*, "already-done")= logi TRUE
[09:29:46.076] - copied ‘...future.FUN’ to environment
[09:29:46.076] - copied ‘x_FUN’ to environment
[09:29:46.076] - copied ‘times’ to environment
[09:29:46.077] - copied ‘stopf’ to environment
[09:29:46.077] - copied ‘stop_if_not’ to environment
[09:29:46.077] - copied ‘dim’ to environment
[09:29:46.077] - copied ‘valid_types’ to environment
[09:29:46.077] - copied ‘future.call.arguments’ to environment
[09:29:46.077] - copied ‘...future.elements_ii’ to environment
[09:29:46.077] - copied ‘...future.seeds_ii’ to environment
[09:29:46.077] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.077] assign_globals() ... done
[09:29:46.078] plan(): Setting new future strategy stack:
[09:29:46.078] List of future strategies:
[09:29:46.078] 1. sequential:
[09:29:46.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.078]    - tweaked: FALSE
[09:29:46.078]    - call: NULL
[09:29:46.078] plan(): nbrOfWorkers() = 1
[09:29:46.079] plan(): Setting new future strategy stack:
[09:29:46.079] List of future strategies:
[09:29:46.079] 1. sequential:
[09:29:46.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.079]    - tweaked: FALSE
[09:29:46.079]    - call: plan(strategy)
[09:29:46.079] plan(): nbrOfWorkers() = 1
[09:29:46.080] SequentialFuture started (and completed)
[09:29:46.080] - Launch lazy future ... done
[09:29:46.080] run() for ‘SequentialFuture’ ... done
[09:29:46.080] Created future:
[09:29:46.080] SequentialFuture:
[09:29:46.080] Label: ‘future_vapply-1’
[09:29:46.080] Expression:
[09:29:46.080] {
[09:29:46.080]     do.call(function(...) {
[09:29:46.080]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.080]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.080]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.080]             on.exit(options(oopts), add = TRUE)
[09:29:46.080]         }
[09:29:46.080]         {
[09:29:46.080]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.080]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.080]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.080]             })
[09:29:46.080]         }
[09:29:46.080]     }, args = future.call.arguments)
[09:29:46.080] }
[09:29:46.080] Lazy evaluation: FALSE
[09:29:46.080] Asynchronous evaluation: FALSE
[09:29:46.080] Local evaluation: TRUE
[09:29:46.080] Environment: R_GlobalEnv
[09:29:46.080] Capture standard output: TRUE
[09:29:46.080] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.080] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.080] Packages: 2 packages (‘stats’, ‘future.apply’)
[09:29:46.080] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.080] Resolved: TRUE
[09:29:46.080] Value: 672 bytes of class ‘list’
[09:29:46.080] Early signaling: FALSE
[09:29:46.080] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.080] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.081] Chunk #1 of 1 ... DONE
[09:29:46.081] Launching 1 futures (chunks) ... DONE
[09:29:46.081] Resolving 1 futures (chunks) ...
[09:29:46.081] resolve() on list ...
[09:29:46.082]  recursive: 0
[09:29:46.082]  length: 1
[09:29:46.082] 
[09:29:46.082] resolved() for ‘SequentialFuture’ ...
[09:29:46.082] - state: ‘finished’
[09:29:46.082] - run: TRUE
[09:29:46.082] - result: ‘FutureResult’
[09:29:46.082] resolved() for ‘SequentialFuture’ ... done
[09:29:46.082] Future #1
[09:29:46.082] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:46.083] - nx: 1
[09:29:46.083] - relay: TRUE
[09:29:46.083] - stdout: TRUE
[09:29:46.083] - signal: TRUE
[09:29:46.083] - resignal: FALSE
[09:29:46.083] - force: TRUE
[09:29:46.083] - relayed: [n=1] FALSE
[09:29:46.083] - queued futures: [n=1] FALSE
[09:29:46.083]  - until=1
[09:29:46.083]  - relaying element #1
[09:29:46.083] - relayed: [n=1] TRUE
[09:29:46.084] - queued futures: [n=1] TRUE
[09:29:46.084] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:46.084]  length: 0 (resolved future 1)
[09:29:46.084] Relaying remaining futures
[09:29:46.084] signalConditionsASAP(NULL, pos=0) ...
[09:29:46.084] - nx: 1
[09:29:46.084] - relay: TRUE
[09:29:46.084] - stdout: TRUE
[09:29:46.084] - signal: TRUE
[09:29:46.084] - resignal: FALSE
[09:29:46.084] - force: TRUE
[09:29:46.085] - relayed: [n=1] TRUE
[09:29:46.085] - queued futures: [n=1] TRUE
 - flush all
[09:29:46.085] - relayed: [n=1] TRUE
[09:29:46.085] - queued futures: [n=1] TRUE
[09:29:46.085] signalConditionsASAP(NULL, pos=0) ... done
[09:29:46.085] resolve() on list ... DONE
[09:29:46.085]  - Number of value chunks collected: 1
[09:29:46.085] Resolving 1 futures (chunks) ... DONE
[09:29:46.085] Reducing values from 1 chunks ...
[09:29:46.085]  - Number of values collected after concatenation: 7
[09:29:46.085]  - Number of values expected: 7
[09:29:46.086] Reducing values from 1 chunks ... DONE
[09:29:46.086] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[09:29:46.087] future_lapply() ...
[09:29:46.088] Number of chunks: 1
[09:29:46.088] getGlobalsAndPackagesXApply() ...
[09:29:46.088]  - future.globals: TRUE
[09:29:46.088] getGlobalsAndPackages() ...
[09:29:46.089] Searching for globals...
[09:29:46.090] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[09:29:46.090] Searching for globals ... DONE
[09:29:46.090] Resolving globals: FALSE
[09:29:46.090] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[09:29:46.091] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[09:29:46.091] - globals: [1] ‘FUN’
[09:29:46.091] 
[09:29:46.091] getGlobalsAndPackages() ... DONE
[09:29:46.091]  - globals found/used: [n=1] ‘FUN’
[09:29:46.091]  - needed namespaces: [n=0] 
[09:29:46.091] Finding globals ... DONE
[09:29:46.091]  - use_args: TRUE
[09:29:46.091]  - Getting '...' globals ...
[09:29:46.092] resolve() on list ...
[09:29:46.092]  recursive: 0
[09:29:46.092]  length: 1
[09:29:46.092]  elements: ‘...’
[09:29:46.092]  length: 0 (resolved future 1)
[09:29:46.092] resolve() on list ... DONE
[09:29:46.092]    - '...' content: [n=1] ‘y’
[09:29:46.092] List of 1
[09:29:46.092]  $ ...:List of 1
[09:29:46.092]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:46.092]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.092]  - attr(*, "where")=List of 1
[09:29:46.092]   ..$ ...:<environment: 0x561d36293570> 
[09:29:46.092]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.092]  - attr(*, "resolved")= logi TRUE
[09:29:46.092]  - attr(*, "total_size")= num NA
[09:29:46.095]  - Getting '...' globals ... DONE
[09:29:46.095] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:29:46.096] List of 2
[09:29:46.096]  $ ...future.FUN:function (x, y)  
[09:29:46.096]  $ ...          :List of 1
[09:29:46.096]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:46.096]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.096]  - attr(*, "where")=List of 2
[09:29:46.096]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.096]   ..$ ...          :<environment: 0x561d36293570> 
[09:29:46.096]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.096]  - attr(*, "resolved")= logi FALSE
[09:29:46.096]  - attr(*, "total_size")= num 4264
[09:29:46.100] Packages to be attached in all futures: [n=0] 
[09:29:46.100] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.100] Number of futures (= number of chunks): 1
[09:29:46.101] Launching 1 futures (chunks) ...
[09:29:46.101] Chunk #1 of 1 ...
[09:29:46.101]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.101] getGlobalsAndPackages() ...
[09:29:46.101] Searching for globals...
[09:29:46.101] 
[09:29:46.101] Searching for globals ... DONE
[09:29:46.102] - globals: [0] <none>
[09:29:46.102] getGlobalsAndPackages() ... DONE
[09:29:46.102]    + additional globals found: [n=0] 
[09:29:46.102]    + additional namespaces needed: [n=0] 
[09:29:46.102]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.102]  - seeds: <none>
[09:29:46.102]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.102] getGlobalsAndPackages() ...
[09:29:46.102] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.102] Resolving globals: FALSE
[09:29:46.103] Tweak future expression to call with '...' arguments ...
[09:29:46.103] {
[09:29:46.103]     do.call(function(...) {
[09:29:46.103]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.103]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.103]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.103]             on.exit(options(oopts), add = TRUE)
[09:29:46.103]         }
[09:29:46.103]         {
[09:29:46.103]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.103]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.103]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.103]             })
[09:29:46.103]         }
[09:29:46.103]     }, args = future.call.arguments)
[09:29:46.103] }
[09:29:46.103] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.103] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.103] 
[09:29:46.103] getGlobalsAndPackages() ... DONE
[09:29:46.104] run() for ‘Future’ ...
[09:29:46.104] - state: ‘created’
[09:29:46.104] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:46.104] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:46.104]   - Field: ‘label’
[09:29:46.105]   - Field: ‘local’
[09:29:46.105]   - Field: ‘owner’
[09:29:46.105]   - Field: ‘envir’
[09:29:46.105]   - Field: ‘packages’
[09:29:46.105]   - Field: ‘gc’
[09:29:46.105]   - Field: ‘conditions’
[09:29:46.105]   - Field: ‘expr’
[09:29:46.105]   - Field: ‘uuid’
[09:29:46.105]   - Field: ‘seed’
[09:29:46.105]   - Field: ‘version’
[09:29:46.105]   - Field: ‘result’
[09:29:46.106]   - Field: ‘asynchronous’
[09:29:46.106]   - Field: ‘calls’
[09:29:46.106]   - Field: ‘globals’
[09:29:46.106]   - Field: ‘stdout’
[09:29:46.106]   - Field: ‘earlySignal’
[09:29:46.106]   - Field: ‘lazy’
[09:29:46.106]   - Field: ‘state’
[09:29:46.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:46.106] - Launch lazy future ...
[09:29:46.106] Packages needed by the future expression (n = 0): <none>
[09:29:46.107] Packages needed by future strategies (n = 0): <none>
[09:29:46.107] {
[09:29:46.107]     {
[09:29:46.107]         {
[09:29:46.107]             ...future.startTime <- base::Sys.time()
[09:29:46.107]             {
[09:29:46.107]                 {
[09:29:46.107]                   {
[09:29:46.107]                     base::local({
[09:29:46.107]                       has_future <- base::requireNamespace("future", 
[09:29:46.107]                         quietly = TRUE)
[09:29:46.107]                       if (has_future) {
[09:29:46.107]                         ns <- base::getNamespace("future")
[09:29:46.107]                         version <- ns[[".package"]][["version"]]
[09:29:46.107]                         if (is.null(version)) 
[09:29:46.107]                           version <- utils::packageVersion("future")
[09:29:46.107]                       }
[09:29:46.107]                       else {
[09:29:46.107]                         version <- NULL
[09:29:46.107]                       }
[09:29:46.107]                       if (!has_future || version < "1.8.0") {
[09:29:46.107]                         info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.107]                           "", base::R.version$version.string), 
[09:29:46.107]                           platform = base::sprintf("%s (%s-bit)", 
[09:29:46.107]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:46.107]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.107]                             "release", "version")], collapse = " "), 
[09:29:46.107]                           hostname = base::Sys.info()[["nodename"]])
[09:29:46.107]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.107]                           info)
[09:29:46.107]                         info <- base::paste(info, collapse = "; ")
[09:29:46.107]                         if (!has_future) {
[09:29:46.107]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.107]                             info)
[09:29:46.107]                         }
[09:29:46.107]                         else {
[09:29:46.107]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.107]                             info, version)
[09:29:46.107]                         }
[09:29:46.107]                         base::stop(msg)
[09:29:46.107]                       }
[09:29:46.107]                     })
[09:29:46.107]                   }
[09:29:46.107]                   ...future.strategy.old <- future::plan("list")
[09:29:46.107]                   options(future.plan = NULL)
[09:29:46.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.107]                 }
[09:29:46.107]                 ...future.workdir <- getwd()
[09:29:46.107]             }
[09:29:46.107]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.107]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.107]         }
[09:29:46.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.107]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:46.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.107]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.107]             base::names(...future.oldOptions))
[09:29:46.107]     }
[09:29:46.107]     if (FALSE) {
[09:29:46.107]     }
[09:29:46.107]     else {
[09:29:46.107]         if (TRUE) {
[09:29:46.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.107]                 open = "w")
[09:29:46.107]         }
[09:29:46.107]         else {
[09:29:46.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.107]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.107]         }
[09:29:46.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.107]             base::sink(type = "output", split = FALSE)
[09:29:46.107]             base::close(...future.stdout)
[09:29:46.107]         }, add = TRUE)
[09:29:46.107]     }
[09:29:46.107]     ...future.frame <- base::sys.nframe()
[09:29:46.107]     ...future.conditions <- base::list()
[09:29:46.107]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.107]     if (FALSE) {
[09:29:46.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.107]     }
[09:29:46.107]     ...future.result <- base::tryCatch({
[09:29:46.107]         base::withCallingHandlers({
[09:29:46.107]             ...future.value <- base::withVisible(base::local({
[09:29:46.107]                 do.call(function(...) {
[09:29:46.107]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.107]                   if (!identical(...future.globals.maxSize.org, 
[09:29:46.107]                     ...future.globals.maxSize)) {
[09:29:46.107]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.107]                     on.exit(options(oopts), add = TRUE)
[09:29:46.107]                   }
[09:29:46.107]                   {
[09:29:46.107]                     lapply(seq_along(...future.elements_ii), 
[09:29:46.107]                       FUN = function(jj) {
[09:29:46.107]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.107]                         ...future.FUN(...future.X_jj, ...)
[09:29:46.107]                       })
[09:29:46.107]                   }
[09:29:46.107]                 }, args = future.call.arguments)
[09:29:46.107]             }))
[09:29:46.107]             future::FutureResult(value = ...future.value$value, 
[09:29:46.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.107]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.107]                     ...future.globalenv.names))
[09:29:46.107]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.107]         }, condition = base::local({
[09:29:46.107]             c <- base::c
[09:29:46.107]             inherits <- base::inherits
[09:29:46.107]             invokeRestart <- base::invokeRestart
[09:29:46.107]             length <- base::length
[09:29:46.107]             list <- base::list
[09:29:46.107]             seq.int <- base::seq.int
[09:29:46.107]             signalCondition <- base::signalCondition
[09:29:46.107]             sys.calls <- base::sys.calls
[09:29:46.107]             `[[` <- base::`[[`
[09:29:46.107]             `+` <- base::`+`
[09:29:46.107]             `<<-` <- base::`<<-`
[09:29:46.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.107]                   3L)]
[09:29:46.107]             }
[09:29:46.107]             function(cond) {
[09:29:46.107]                 is_error <- inherits(cond, "error")
[09:29:46.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.107]                   NULL)
[09:29:46.107]                 if (is_error) {
[09:29:46.107]                   sessionInformation <- function() {
[09:29:46.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.107]                       search = base::search(), system = base::Sys.info())
[09:29:46.107]                   }
[09:29:46.107]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.107]                     cond$call), session = sessionInformation(), 
[09:29:46.107]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.107]                   signalCondition(cond)
[09:29:46.107]                 }
[09:29:46.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.107]                 "immediateCondition"))) {
[09:29:46.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.107]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.107]                   if (TRUE && !signal) {
[09:29:46.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.107]                     {
[09:29:46.107]                       inherits <- base::inherits
[09:29:46.107]                       invokeRestart <- base::invokeRestart
[09:29:46.107]                       is.null <- base::is.null
[09:29:46.107]                       muffled <- FALSE
[09:29:46.107]                       if (inherits(cond, "message")) {
[09:29:46.107]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.107]                         if (muffled) 
[09:29:46.107]                           invokeRestart("muffleMessage")
[09:29:46.107]                       }
[09:29:46.107]                       else if (inherits(cond, "warning")) {
[09:29:46.107]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.107]                         if (muffled) 
[09:29:46.107]                           invokeRestart("muffleWarning")
[09:29:46.107]                       }
[09:29:46.107]                       else if (inherits(cond, "condition")) {
[09:29:46.107]                         if (!is.null(pattern)) {
[09:29:46.107]                           computeRestarts <- base::computeRestarts
[09:29:46.107]                           grepl <- base::grepl
[09:29:46.107]                           restarts <- computeRestarts(cond)
[09:29:46.107]                           for (restart in restarts) {
[09:29:46.107]                             name <- restart$name
[09:29:46.107]                             if (is.null(name)) 
[09:29:46.107]                               next
[09:29:46.107]                             if (!grepl(pattern, name)) 
[09:29:46.107]                               next
[09:29:46.107]                             invokeRestart(restart)
[09:29:46.107]                             muffled <- TRUE
[09:29:46.107]                             break
[09:29:46.107]                           }
[09:29:46.107]                         }
[09:29:46.107]                       }
[09:29:46.107]                       invisible(muffled)
[09:29:46.107]                     }
[09:29:46.107]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.107]                   }
[09:29:46.107]                 }
[09:29:46.107]                 else {
[09:29:46.107]                   if (TRUE) {
[09:29:46.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.107]                     {
[09:29:46.107]                       inherits <- base::inherits
[09:29:46.107]                       invokeRestart <- base::invokeRestart
[09:29:46.107]                       is.null <- base::is.null
[09:29:46.107]                       muffled <- FALSE
[09:29:46.107]                       if (inherits(cond, "message")) {
[09:29:46.107]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.107]                         if (muffled) 
[09:29:46.107]                           invokeRestart("muffleMessage")
[09:29:46.107]                       }
[09:29:46.107]                       else if (inherits(cond, "warning")) {
[09:29:46.107]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.107]                         if (muffled) 
[09:29:46.107]                           invokeRestart("muffleWarning")
[09:29:46.107]                       }
[09:29:46.107]                       else if (inherits(cond, "condition")) {
[09:29:46.107]                         if (!is.null(pattern)) {
[09:29:46.107]                           computeRestarts <- base::computeRestarts
[09:29:46.107]                           grepl <- base::grepl
[09:29:46.107]                           restarts <- computeRestarts(cond)
[09:29:46.107]                           for (restart in restarts) {
[09:29:46.107]                             name <- restart$name
[09:29:46.107]                             if (is.null(name)) 
[09:29:46.107]                               next
[09:29:46.107]                             if (!grepl(pattern, name)) 
[09:29:46.107]                               next
[09:29:46.107]                             invokeRestart(restart)
[09:29:46.107]                             muffled <- TRUE
[09:29:46.107]                             break
[09:29:46.107]                           }
[09:29:46.107]                         }
[09:29:46.107]                       }
[09:29:46.107]                       invisible(muffled)
[09:29:46.107]                     }
[09:29:46.107]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.107]                   }
[09:29:46.107]                 }
[09:29:46.107]             }
[09:29:46.107]         }))
[09:29:46.107]     }, error = function(ex) {
[09:29:46.107]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.107]                 ...future.rng), started = ...future.startTime, 
[09:29:46.107]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.107]             version = "1.8"), class = "FutureResult")
[09:29:46.107]     }, finally = {
[09:29:46.107]         if (!identical(...future.workdir, getwd())) 
[09:29:46.107]             setwd(...future.workdir)
[09:29:46.107]         {
[09:29:46.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.107]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.107]             }
[09:29:46.107]             base::options(...future.oldOptions)
[09:29:46.107]             if (.Platform$OS.type == "windows") {
[09:29:46.107]                 old_names <- names(...future.oldEnvVars)
[09:29:46.107]                 envs <- base::Sys.getenv()
[09:29:46.107]                 names <- names(envs)
[09:29:46.107]                 common <- intersect(names, old_names)
[09:29:46.107]                 added <- setdiff(names, old_names)
[09:29:46.107]                 removed <- setdiff(old_names, names)
[09:29:46.107]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.107]                   envs[common]]
[09:29:46.107]                 NAMES <- toupper(changed)
[09:29:46.107]                 args <- list()
[09:29:46.107]                 for (kk in seq_along(NAMES)) {
[09:29:46.107]                   name <- changed[[kk]]
[09:29:46.107]                   NAME <- NAMES[[kk]]
[09:29:46.107]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.107]                     next
[09:29:46.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.107]                 }
[09:29:46.107]                 NAMES <- toupper(added)
[09:29:46.107]                 for (kk in seq_along(NAMES)) {
[09:29:46.107]                   name <- added[[kk]]
[09:29:46.107]                   NAME <- NAMES[[kk]]
[09:29:46.107]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.107]                     next
[09:29:46.107]                   args[[name]] <- ""
[09:29:46.107]                 }
[09:29:46.107]                 NAMES <- toupper(removed)
[09:29:46.107]                 for (kk in seq_along(NAMES)) {
[09:29:46.107]                   name <- removed[[kk]]
[09:29:46.107]                   NAME <- NAMES[[kk]]
[09:29:46.107]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.107]                     next
[09:29:46.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.107]                 }
[09:29:46.107]                 if (length(args) > 0) 
[09:29:46.107]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.107]             }
[09:29:46.107]             else {
[09:29:46.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.107]             }
[09:29:46.107]             {
[09:29:46.107]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.107]                   0L) {
[09:29:46.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.107]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.107]                   base::options(opts)
[09:29:46.107]                 }
[09:29:46.107]                 {
[09:29:46.107]                   {
[09:29:46.107]                     NULL
[09:29:46.107]                     RNGkind("Mersenne-Twister")
[09:29:46.107]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:46.107]                       inherits = FALSE)
[09:29:46.107]                   }
[09:29:46.107]                   options(future.plan = NULL)
[09:29:46.107]                   if (is.na(NA_character_)) 
[09:29:46.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.107]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.107]                     .init = FALSE)
[09:29:46.107]                 }
[09:29:46.107]             }
[09:29:46.107]         }
[09:29:46.107]     })
[09:29:46.107]     if (TRUE) {
[09:29:46.107]         base::sink(type = "output", split = FALSE)
[09:29:46.107]         if (TRUE) {
[09:29:46.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.107]         }
[09:29:46.107]         else {
[09:29:46.107]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.107]         }
[09:29:46.107]         base::close(...future.stdout)
[09:29:46.107]         ...future.stdout <- NULL
[09:29:46.107]     }
[09:29:46.107]     ...future.result$conditions <- ...future.conditions
[09:29:46.107]     ...future.result$finished <- base::Sys.time()
[09:29:46.107]     ...future.result
[09:29:46.107] }
[09:29:46.109] assign_globals() ...
[09:29:46.109] List of 5
[09:29:46.109]  $ ...future.FUN            :function (x, y)  
[09:29:46.109]  $ future.call.arguments    :List of 1
[09:29:46.109]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:46.109]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.109]  $ ...future.elements_ii    :List of 4
[09:29:46.109]   ..$ A: num 50
[09:29:46.109]   ..$ B: num 60
[09:29:46.109]   ..$ C: num 70
[09:29:46.109]   ..$ D: num 80
[09:29:46.109]  $ ...future.seeds_ii       : NULL
[09:29:46.109]  $ ...future.globals.maxSize: NULL
[09:29:46.109]  - attr(*, "where")=List of 5
[09:29:46.109]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.109]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.109]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.109]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.109]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.109]  - attr(*, "resolved")= logi FALSE
[09:29:46.109]  - attr(*, "total_size")= num 4264
[09:29:46.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.109]  - attr(*, "already-done")= logi TRUE
[09:29:46.114] - reassign environment for ‘...future.FUN’
[09:29:46.115] - copied ‘...future.FUN’ to environment
[09:29:46.115] - copied ‘future.call.arguments’ to environment
[09:29:46.115] - copied ‘...future.elements_ii’ to environment
[09:29:46.115] - copied ‘...future.seeds_ii’ to environment
[09:29:46.115] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.115] assign_globals() ... done
[09:29:46.115] plan(): Setting new future strategy stack:
[09:29:46.115] List of future strategies:
[09:29:46.115] 1. sequential:
[09:29:46.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.115]    - tweaked: FALSE
[09:29:46.115]    - call: NULL
[09:29:46.116] plan(): nbrOfWorkers() = 1
[09:29:46.116] plan(): Setting new future strategy stack:
[09:29:46.117] List of future strategies:
[09:29:46.117] 1. sequential:
[09:29:46.117]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.117]    - tweaked: FALSE
[09:29:46.117]    - call: plan(strategy)
[09:29:46.117] plan(): nbrOfWorkers() = 1
[09:29:46.117] SequentialFuture started (and completed)
[09:29:46.117] - Launch lazy future ... done
[09:29:46.117] run() for ‘SequentialFuture’ ... done
[09:29:46.117] Created future:
[09:29:46.118] SequentialFuture:
[09:29:46.118] Label: ‘future_sapply-1’
[09:29:46.118] Expression:
[09:29:46.118] {
[09:29:46.118]     do.call(function(...) {
[09:29:46.118]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.118]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.118]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.118]             on.exit(options(oopts), add = TRUE)
[09:29:46.118]         }
[09:29:46.118]         {
[09:29:46.118]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.118]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.118]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.118]             })
[09:29:46.118]         }
[09:29:46.118]     }, args = future.call.arguments)
[09:29:46.118] }
[09:29:46.118] Lazy evaluation: FALSE
[09:29:46.118] Asynchronous evaluation: FALSE
[09:29:46.118] Local evaluation: TRUE
[09:29:46.118] Environment: R_GlobalEnv
[09:29:46.118] Capture standard output: TRUE
[09:29:46.118] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.118] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:46.118] Packages: <none>
[09:29:46.118] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.118] Resolved: TRUE
[09:29:46.118] Value: 1.34 KiB of class ‘list’
[09:29:46.118] Early signaling: FALSE
[09:29:46.118] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.118] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.119] Chunk #1 of 1 ... DONE
[09:29:46.119] Launching 1 futures (chunks) ... DONE
[09:29:46.119] Resolving 1 futures (chunks) ...
[09:29:46.119] resolve() on list ...
[09:29:46.119]  recursive: 0
[09:29:46.119]  length: 1
[09:29:46.119] 
[09:29:46.119] resolved() for ‘SequentialFuture’ ...
[09:29:46.119] - state: ‘finished’
[09:29:46.119] - run: TRUE
[09:29:46.119] - result: ‘FutureResult’
[09:29:46.120] resolved() for ‘SequentialFuture’ ... done
[09:29:46.120] Future #1
[09:29:46.120] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:46.120] - nx: 1
[09:29:46.120] - relay: TRUE
[09:29:46.120] - stdout: TRUE
[09:29:46.120] - signal: TRUE
[09:29:46.120] - resignal: FALSE
[09:29:46.120] - force: TRUE
[09:29:46.120] - relayed: [n=1] FALSE
[09:29:46.120] - queued futures: [n=1] FALSE
[09:29:46.121]  - until=1
[09:29:46.121]  - relaying element #1
[09:29:46.121] - relayed: [n=1] TRUE
[09:29:46.121] - queued futures: [n=1] TRUE
[09:29:46.121] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:46.121]  length: 0 (resolved future 1)
[09:29:46.121] Relaying remaining futures
[09:29:46.121] signalConditionsASAP(NULL, pos=0) ...
[09:29:46.121] - nx: 1
[09:29:46.121] - relay: TRUE
[09:29:46.121] - stdout: TRUE
[09:29:46.122] - signal: TRUE
[09:29:46.122] - resignal: FALSE
[09:29:46.122] - force: TRUE
[09:29:46.122] - relayed: [n=1] TRUE
[09:29:46.122] - queued futures: [n=1] TRUE
 - flush all
[09:29:46.122] - relayed: [n=1] TRUE
[09:29:46.122] - queued futures: [n=1] TRUE
[09:29:46.122] signalConditionsASAP(NULL, pos=0) ... done
[09:29:46.122] resolve() on list ... DONE
[09:29:46.122]  - Number of value chunks collected: 1
[09:29:46.122] Resolving 1 futures (chunks) ... DONE
[09:29:46.123] Reducing values from 1 chunks ...
[09:29:46.123]  - Number of values collected after concatenation: 4
[09:29:46.123]  - Number of values expected: 4
[09:29:46.123] Reducing values from 1 chunks ... DONE
[09:29:46.123] future_lapply() ... DONE
[09:29:46.124] future_lapply() ...
[09:29:46.126] Number of chunks: 1
[09:29:46.126] getGlobalsAndPackagesXApply() ...
[09:29:46.126]  - future.globals: TRUE
[09:29:46.126] getGlobalsAndPackages() ...
[09:29:46.126] Searching for globals...
[09:29:46.130] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[09:29:46.130] Searching for globals ... DONE
[09:29:46.130] Resolving globals: FALSE
[09:29:46.131] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[09:29:46.131] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:46.131] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.131] - packages: [1] ‘future.apply’
[09:29:46.131] getGlobalsAndPackages() ... DONE
[09:29:46.131]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.131]  - needed namespaces: [n=1] ‘future.apply’
[09:29:46.132] Finding globals ... DONE
[09:29:46.132]  - use_args: TRUE
[09:29:46.132]  - Getting '...' globals ...
[09:29:46.132] resolve() on list ...
[09:29:46.132]  recursive: 0
[09:29:46.132]  length: 1
[09:29:46.132]  elements: ‘...’
[09:29:46.132]  length: 0 (resolved future 1)
[09:29:46.132] resolve() on list ... DONE
[09:29:46.133]    - '...' content: [n=1] ‘y’
[09:29:46.133] List of 1
[09:29:46.133]  $ ...:List of 1
[09:29:46.133]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:46.133]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.133]  - attr(*, "where")=List of 1
[09:29:46.133]   ..$ ...:<environment: 0x561d3714faf8> 
[09:29:46.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.133]  - attr(*, "resolved")= logi TRUE
[09:29:46.133]  - attr(*, "total_size")= num NA
[09:29:46.135]  - Getting '...' globals ... DONE
[09:29:46.135] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:46.136] List of 8
[09:29:46.136]  $ ...future.FUN:function (x, ...)  
[09:29:46.136]  $ x_FUN        :function (x, y)  
[09:29:46.136]  $ times        : int 15
[09:29:46.136]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.136]  $ stop_if_not  :function (...)  
[09:29:46.136]  $ dim          : int [1:2] 3 5
[09:29:46.136]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:46.136]  $ ...          :List of 1
[09:29:46.136]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:46.136]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.136]  - attr(*, "where")=List of 8
[09:29:46.136]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.136]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:46.136]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:46.136]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:46.136]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:46.136]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:46.136]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:46.136]   ..$ ...          :<environment: 0x561d3714faf8> 
[09:29:46.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.136]  - attr(*, "resolved")= logi FALSE
[09:29:46.136]  - attr(*, "total_size")= num 98600
[09:29:46.141] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:46.141] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.141] Number of futures (= number of chunks): 1
[09:29:46.141] Launching 1 futures (chunks) ...
[09:29:46.141] Chunk #1 of 1 ...
[09:29:46.142]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.142] getGlobalsAndPackages() ...
[09:29:46.142] Searching for globals...
[09:29:46.142] 
[09:29:46.142] Searching for globals ... DONE
[09:29:46.142] - globals: [0] <none>
[09:29:46.142] getGlobalsAndPackages() ... DONE
[09:29:46.142]    + additional globals found: [n=0] 
[09:29:46.142]    + additional namespaces needed: [n=0] 
[09:29:46.142]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.143]  - seeds: <none>
[09:29:46.143]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.143] getGlobalsAndPackages() ...
[09:29:46.143] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.143] Resolving globals: FALSE
[09:29:46.143] Tweak future expression to call with '...' arguments ...
[09:29:46.143] {
[09:29:46.143]     do.call(function(...) {
[09:29:46.143]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.143]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.143]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.143]             on.exit(options(oopts), add = TRUE)
[09:29:46.143]         }
[09:29:46.143]         {
[09:29:46.143]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.143]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.143]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.143]             })
[09:29:46.143]         }
[09:29:46.143]     }, args = future.call.arguments)
[09:29:46.143] }
[09:29:46.143] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.145] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.145] - packages: [1] ‘future.apply’
[09:29:46.145] getGlobalsAndPackages() ... DONE
[09:29:46.145] run() for ‘Future’ ...
[09:29:46.145] - state: ‘created’
[09:29:46.145] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:46.146] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.146] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:46.146]   - Field: ‘label’
[09:29:46.146]   - Field: ‘local’
[09:29:46.146]   - Field: ‘owner’
[09:29:46.146]   - Field: ‘envir’
[09:29:46.146]   - Field: ‘packages’
[09:29:46.146]   - Field: ‘gc’
[09:29:46.146]   - Field: ‘conditions’
[09:29:46.146]   - Field: ‘expr’
[09:29:46.146]   - Field: ‘uuid’
[09:29:46.147]   - Field: ‘seed’
[09:29:46.147]   - Field: ‘version’
[09:29:46.147]   - Field: ‘result’
[09:29:46.147]   - Field: ‘asynchronous’
[09:29:46.147]   - Field: ‘calls’
[09:29:46.147]   - Field: ‘globals’
[09:29:46.147]   - Field: ‘stdout’
[09:29:46.147]   - Field: ‘earlySignal’
[09:29:46.147]   - Field: ‘lazy’
[09:29:46.147]   - Field: ‘state’
[09:29:46.147] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:46.148] - Launch lazy future ...
[09:29:46.148] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.148] Packages needed by future strategies (n = 0): <none>
[09:29:46.148] {
[09:29:46.148]     {
[09:29:46.148]         {
[09:29:46.148]             ...future.startTime <- base::Sys.time()
[09:29:46.148]             {
[09:29:46.148]                 {
[09:29:46.148]                   {
[09:29:46.148]                     {
[09:29:46.148]                       base::local({
[09:29:46.148]                         has_future <- base::requireNamespace("future", 
[09:29:46.148]                           quietly = TRUE)
[09:29:46.148]                         if (has_future) {
[09:29:46.148]                           ns <- base::getNamespace("future")
[09:29:46.148]                           version <- ns[[".package"]][["version"]]
[09:29:46.148]                           if (is.null(version)) 
[09:29:46.148]                             version <- utils::packageVersion("future")
[09:29:46.148]                         }
[09:29:46.148]                         else {
[09:29:46.148]                           version <- NULL
[09:29:46.148]                         }
[09:29:46.148]                         if (!has_future || version < "1.8.0") {
[09:29:46.148]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.148]                             "", base::R.version$version.string), 
[09:29:46.148]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:46.148]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:46.148]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.148]                               "release", "version")], collapse = " "), 
[09:29:46.148]                             hostname = base::Sys.info()[["nodename"]])
[09:29:46.148]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.148]                             info)
[09:29:46.148]                           info <- base::paste(info, collapse = "; ")
[09:29:46.148]                           if (!has_future) {
[09:29:46.148]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.148]                               info)
[09:29:46.148]                           }
[09:29:46.148]                           else {
[09:29:46.148]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.148]                               info, version)
[09:29:46.148]                           }
[09:29:46.148]                           base::stop(msg)
[09:29:46.148]                         }
[09:29:46.148]                       })
[09:29:46.148]                     }
[09:29:46.148]                     base::local({
[09:29:46.148]                       for (pkg in "future.apply") {
[09:29:46.148]                         base::loadNamespace(pkg)
[09:29:46.148]                         base::library(pkg, character.only = TRUE)
[09:29:46.148]                       }
[09:29:46.148]                     })
[09:29:46.148]                   }
[09:29:46.148]                   ...future.strategy.old <- future::plan("list")
[09:29:46.148]                   options(future.plan = NULL)
[09:29:46.148]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.148]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.148]                 }
[09:29:46.148]                 ...future.workdir <- getwd()
[09:29:46.148]             }
[09:29:46.148]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.148]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.148]         }
[09:29:46.148]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.148]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:46.148]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.148]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.148]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.148]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.148]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.148]             base::names(...future.oldOptions))
[09:29:46.148]     }
[09:29:46.148]     if (FALSE) {
[09:29:46.148]     }
[09:29:46.148]     else {
[09:29:46.148]         if (TRUE) {
[09:29:46.148]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.148]                 open = "w")
[09:29:46.148]         }
[09:29:46.148]         else {
[09:29:46.148]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.148]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.148]         }
[09:29:46.148]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.148]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.148]             base::sink(type = "output", split = FALSE)
[09:29:46.148]             base::close(...future.stdout)
[09:29:46.148]         }, add = TRUE)
[09:29:46.148]     }
[09:29:46.148]     ...future.frame <- base::sys.nframe()
[09:29:46.148]     ...future.conditions <- base::list()
[09:29:46.148]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.148]     if (FALSE) {
[09:29:46.148]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.148]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.148]     }
[09:29:46.148]     ...future.result <- base::tryCatch({
[09:29:46.148]         base::withCallingHandlers({
[09:29:46.148]             ...future.value <- base::withVisible(base::local({
[09:29:46.148]                 do.call(function(...) {
[09:29:46.148]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.148]                   if (!identical(...future.globals.maxSize.org, 
[09:29:46.148]                     ...future.globals.maxSize)) {
[09:29:46.148]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.148]                     on.exit(options(oopts), add = TRUE)
[09:29:46.148]                   }
[09:29:46.148]                   {
[09:29:46.148]                     lapply(seq_along(...future.elements_ii), 
[09:29:46.148]                       FUN = function(jj) {
[09:29:46.148]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.148]                         ...future.FUN(...future.X_jj, ...)
[09:29:46.148]                       })
[09:29:46.148]                   }
[09:29:46.148]                 }, args = future.call.arguments)
[09:29:46.148]             }))
[09:29:46.148]             future::FutureResult(value = ...future.value$value, 
[09:29:46.148]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.148]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.148]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.148]                     ...future.globalenv.names))
[09:29:46.148]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.148]         }, condition = base::local({
[09:29:46.148]             c <- base::c
[09:29:46.148]             inherits <- base::inherits
[09:29:46.148]             invokeRestart <- base::invokeRestart
[09:29:46.148]             length <- base::length
[09:29:46.148]             list <- base::list
[09:29:46.148]             seq.int <- base::seq.int
[09:29:46.148]             signalCondition <- base::signalCondition
[09:29:46.148]             sys.calls <- base::sys.calls
[09:29:46.148]             `[[` <- base::`[[`
[09:29:46.148]             `+` <- base::`+`
[09:29:46.148]             `<<-` <- base::`<<-`
[09:29:46.148]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.148]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.148]                   3L)]
[09:29:46.148]             }
[09:29:46.148]             function(cond) {
[09:29:46.148]                 is_error <- inherits(cond, "error")
[09:29:46.148]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.148]                   NULL)
[09:29:46.148]                 if (is_error) {
[09:29:46.148]                   sessionInformation <- function() {
[09:29:46.148]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.148]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.148]                       search = base::search(), system = base::Sys.info())
[09:29:46.148]                   }
[09:29:46.148]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.148]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.148]                     cond$call), session = sessionInformation(), 
[09:29:46.148]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.148]                   signalCondition(cond)
[09:29:46.148]                 }
[09:29:46.148]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.148]                 "immediateCondition"))) {
[09:29:46.148]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.148]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.148]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.148]                   if (TRUE && !signal) {
[09:29:46.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.148]                     {
[09:29:46.148]                       inherits <- base::inherits
[09:29:46.148]                       invokeRestart <- base::invokeRestart
[09:29:46.148]                       is.null <- base::is.null
[09:29:46.148]                       muffled <- FALSE
[09:29:46.148]                       if (inherits(cond, "message")) {
[09:29:46.148]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.148]                         if (muffled) 
[09:29:46.148]                           invokeRestart("muffleMessage")
[09:29:46.148]                       }
[09:29:46.148]                       else if (inherits(cond, "warning")) {
[09:29:46.148]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.148]                         if (muffled) 
[09:29:46.148]                           invokeRestart("muffleWarning")
[09:29:46.148]                       }
[09:29:46.148]                       else if (inherits(cond, "condition")) {
[09:29:46.148]                         if (!is.null(pattern)) {
[09:29:46.148]                           computeRestarts <- base::computeRestarts
[09:29:46.148]                           grepl <- base::grepl
[09:29:46.148]                           restarts <- computeRestarts(cond)
[09:29:46.148]                           for (restart in restarts) {
[09:29:46.148]                             name <- restart$name
[09:29:46.148]                             if (is.null(name)) 
[09:29:46.148]                               next
[09:29:46.148]                             if (!grepl(pattern, name)) 
[09:29:46.148]                               next
[09:29:46.148]                             invokeRestart(restart)
[09:29:46.148]                             muffled <- TRUE
[09:29:46.148]                             break
[09:29:46.148]                           }
[09:29:46.148]                         }
[09:29:46.148]                       }
[09:29:46.148]                       invisible(muffled)
[09:29:46.148]                     }
[09:29:46.148]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.148]                   }
[09:29:46.148]                 }
[09:29:46.148]                 else {
[09:29:46.148]                   if (TRUE) {
[09:29:46.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.148]                     {
[09:29:46.148]                       inherits <- base::inherits
[09:29:46.148]                       invokeRestart <- base::invokeRestart
[09:29:46.148]                       is.null <- base::is.null
[09:29:46.148]                       muffled <- FALSE
[09:29:46.148]                       if (inherits(cond, "message")) {
[09:29:46.148]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.148]                         if (muffled) 
[09:29:46.148]                           invokeRestart("muffleMessage")
[09:29:46.148]                       }
[09:29:46.148]                       else if (inherits(cond, "warning")) {
[09:29:46.148]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.148]                         if (muffled) 
[09:29:46.148]                           invokeRestart("muffleWarning")
[09:29:46.148]                       }
[09:29:46.148]                       else if (inherits(cond, "condition")) {
[09:29:46.148]                         if (!is.null(pattern)) {
[09:29:46.148]                           computeRestarts <- base::computeRestarts
[09:29:46.148]                           grepl <- base::grepl
[09:29:46.148]                           restarts <- computeRestarts(cond)
[09:29:46.148]                           for (restart in restarts) {
[09:29:46.148]                             name <- restart$name
[09:29:46.148]                             if (is.null(name)) 
[09:29:46.148]                               next
[09:29:46.148]                             if (!grepl(pattern, name)) 
[09:29:46.148]                               next
[09:29:46.148]                             invokeRestart(restart)
[09:29:46.148]                             muffled <- TRUE
[09:29:46.148]                             break
[09:29:46.148]                           }
[09:29:46.148]                         }
[09:29:46.148]                       }
[09:29:46.148]                       invisible(muffled)
[09:29:46.148]                     }
[09:29:46.148]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.148]                   }
[09:29:46.148]                 }
[09:29:46.148]             }
[09:29:46.148]         }))
[09:29:46.148]     }, error = function(ex) {
[09:29:46.148]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.148]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.148]                 ...future.rng), started = ...future.startTime, 
[09:29:46.148]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.148]             version = "1.8"), class = "FutureResult")
[09:29:46.148]     }, finally = {
[09:29:46.148]         if (!identical(...future.workdir, getwd())) 
[09:29:46.148]             setwd(...future.workdir)
[09:29:46.148]         {
[09:29:46.148]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.148]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.148]             }
[09:29:46.148]             base::options(...future.oldOptions)
[09:29:46.148]             if (.Platform$OS.type == "windows") {
[09:29:46.148]                 old_names <- names(...future.oldEnvVars)
[09:29:46.148]                 envs <- base::Sys.getenv()
[09:29:46.148]                 names <- names(envs)
[09:29:46.148]                 common <- intersect(names, old_names)
[09:29:46.148]                 added <- setdiff(names, old_names)
[09:29:46.148]                 removed <- setdiff(old_names, names)
[09:29:46.148]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.148]                   envs[common]]
[09:29:46.148]                 NAMES <- toupper(changed)
[09:29:46.148]                 args <- list()
[09:29:46.148]                 for (kk in seq_along(NAMES)) {
[09:29:46.148]                   name <- changed[[kk]]
[09:29:46.148]                   NAME <- NAMES[[kk]]
[09:29:46.148]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.148]                     next
[09:29:46.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.148]                 }
[09:29:46.148]                 NAMES <- toupper(added)
[09:29:46.148]                 for (kk in seq_along(NAMES)) {
[09:29:46.148]                   name <- added[[kk]]
[09:29:46.148]                   NAME <- NAMES[[kk]]
[09:29:46.148]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.148]                     next
[09:29:46.148]                   args[[name]] <- ""
[09:29:46.148]                 }
[09:29:46.148]                 NAMES <- toupper(removed)
[09:29:46.148]                 for (kk in seq_along(NAMES)) {
[09:29:46.148]                   name <- removed[[kk]]
[09:29:46.148]                   NAME <- NAMES[[kk]]
[09:29:46.148]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.148]                     next
[09:29:46.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.148]                 }
[09:29:46.148]                 if (length(args) > 0) 
[09:29:46.148]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.148]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.148]             }
[09:29:46.148]             else {
[09:29:46.148]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.148]             }
[09:29:46.148]             {
[09:29:46.148]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.148]                   0L) {
[09:29:46.148]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.148]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.148]                   base::options(opts)
[09:29:46.148]                 }
[09:29:46.148]                 {
[09:29:46.148]                   {
[09:29:46.148]                     NULL
[09:29:46.148]                     RNGkind("Mersenne-Twister")
[09:29:46.148]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:46.148]                       inherits = FALSE)
[09:29:46.148]                   }
[09:29:46.148]                   options(future.plan = NULL)
[09:29:46.148]                   if (is.na(NA_character_)) 
[09:29:46.148]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.148]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.148]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.148]                     .init = FALSE)
[09:29:46.148]                 }
[09:29:46.148]             }
[09:29:46.148]         }
[09:29:46.148]     })
[09:29:46.148]     if (TRUE) {
[09:29:46.148]         base::sink(type = "output", split = FALSE)
[09:29:46.148]         if (TRUE) {
[09:29:46.148]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.148]         }
[09:29:46.148]         else {
[09:29:46.148]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.148]         }
[09:29:46.148]         base::close(...future.stdout)
[09:29:46.148]         ...future.stdout <- NULL
[09:29:46.148]     }
[09:29:46.148]     ...future.result$conditions <- ...future.conditions
[09:29:46.148]     ...future.result$finished <- base::Sys.time()
[09:29:46.148]     ...future.result
[09:29:46.148] }
[09:29:46.150] assign_globals() ...
[09:29:46.150] List of 11
[09:29:46.150]  $ ...future.FUN            :function (x, ...)  
[09:29:46.150]  $ x_FUN                    :function (x, y)  
[09:29:46.150]  $ times                    : int 15
[09:29:46.150]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.150]  $ stop_if_not              :function (...)  
[09:29:46.150]  $ dim                      : int [1:2] 3 5
[09:29:46.150]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:46.150]  $ future.call.arguments    :List of 1
[09:29:46.150]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:46.150]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.150]  $ ...future.elements_ii    :List of 4
[09:29:46.150]   ..$ A: num 50
[09:29:46.150]   ..$ B: num 60
[09:29:46.150]   ..$ C: num 70
[09:29:46.150]   ..$ D: num 80
[09:29:46.150]  $ ...future.seeds_ii       : NULL
[09:29:46.150]  $ ...future.globals.maxSize: NULL
[09:29:46.150]  - attr(*, "where")=List of 11
[09:29:46.150]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.150]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.150]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.150]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.150]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.150]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.150]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.150]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.150]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.150]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.150]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.150]  - attr(*, "resolved")= logi FALSE
[09:29:46.150]  - attr(*, "total_size")= num 98600
[09:29:46.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.150]  - attr(*, "already-done")= logi TRUE
[09:29:46.158] - copied ‘...future.FUN’ to environment
[09:29:46.158] - reassign environment for ‘x_FUN’
[09:29:46.158] - copied ‘x_FUN’ to environment
[09:29:46.158] - copied ‘times’ to environment
[09:29:46.158] - copied ‘stopf’ to environment
[09:29:46.158] - copied ‘stop_if_not’ to environment
[09:29:46.158] - copied ‘dim’ to environment
[09:29:46.159] - copied ‘valid_types’ to environment
[09:29:46.159] - copied ‘future.call.arguments’ to environment
[09:29:46.159] - copied ‘...future.elements_ii’ to environment
[09:29:46.159] - copied ‘...future.seeds_ii’ to environment
[09:29:46.159] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.159] assign_globals() ... done
[09:29:46.159] plan(): Setting new future strategy stack:
[09:29:46.159] List of future strategies:
[09:29:46.159] 1. sequential:
[09:29:46.159]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.159]    - tweaked: FALSE
[09:29:46.159]    - call: NULL
[09:29:46.160] plan(): nbrOfWorkers() = 1
[09:29:46.161] plan(): Setting new future strategy stack:
[09:29:46.161] List of future strategies:
[09:29:46.161] 1. sequential:
[09:29:46.161]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.161]    - tweaked: FALSE
[09:29:46.161]    - call: plan(strategy)
[09:29:46.161] plan(): nbrOfWorkers() = 1
[09:29:46.161] SequentialFuture started (and completed)
[09:29:46.161] - Launch lazy future ... done
[09:29:46.161] run() for ‘SequentialFuture’ ... done
[09:29:46.161] Created future:
[09:29:46.162] SequentialFuture:
[09:29:46.162] Label: ‘future_vapply-1’
[09:29:46.162] Expression:
[09:29:46.162] {
[09:29:46.162]     do.call(function(...) {
[09:29:46.162]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.162]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.162]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.162]             on.exit(options(oopts), add = TRUE)
[09:29:46.162]         }
[09:29:46.162]         {
[09:29:46.162]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.162]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.162]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.162]             })
[09:29:46.162]         }
[09:29:46.162]     }, args = future.call.arguments)
[09:29:46.162] }
[09:29:46.162] Lazy evaluation: FALSE
[09:29:46.162] Asynchronous evaluation: FALSE
[09:29:46.162] Local evaluation: TRUE
[09:29:46.162] Environment: R_GlobalEnv
[09:29:46.162] Capture standard output: TRUE
[09:29:46.162] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.162] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.162] Packages: 1 packages (‘future.apply’)
[09:29:46.162] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.162] Resolved: TRUE
[09:29:46.162] Value: 1.34 KiB of class ‘list’
[09:29:46.162] Early signaling: FALSE
[09:29:46.162] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.162] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.163] Chunk #1 of 1 ... DONE
[09:29:46.163] Launching 1 futures (chunks) ... DONE
[09:29:46.163] Resolving 1 futures (chunks) ...
[09:29:46.163] resolve() on list ...
[09:29:46.163]  recursive: 0
[09:29:46.163]  length: 1
[09:29:46.163] 
[09:29:46.163] resolved() for ‘SequentialFuture’ ...
[09:29:46.163] - state: ‘finished’
[09:29:46.163] - run: TRUE
[09:29:46.163] - result: ‘FutureResult’
[09:29:46.164] resolved() for ‘SequentialFuture’ ... done
[09:29:46.164] Future #1
[09:29:46.164] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:46.164] - nx: 1
[09:29:46.164] - relay: TRUE
[09:29:46.164] - stdout: TRUE
[09:29:46.164] - signal: TRUE
[09:29:46.164] - resignal: FALSE
[09:29:46.164] - force: TRUE
[09:29:46.164] - relayed: [n=1] FALSE
[09:29:46.164] - queued futures: [n=1] FALSE
[09:29:46.165]  - until=1
[09:29:46.165]  - relaying element #1
[09:29:46.165] - relayed: [n=1] TRUE
[09:29:46.165] - queued futures: [n=1] TRUE
[09:29:46.165] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:46.165]  length: 0 (resolved future 1)
[09:29:46.165] Relaying remaining futures
[09:29:46.165] signalConditionsASAP(NULL, pos=0) ...
[09:29:46.165] - nx: 1
[09:29:46.165] - relay: TRUE
[09:29:46.165] - stdout: TRUE
[09:29:46.166] - signal: TRUE
[09:29:46.166] - resignal: FALSE
[09:29:46.166] - force: TRUE
[09:29:46.166] - relayed: [n=1] TRUE
[09:29:46.167] - queued futures: [n=1] TRUE
 - flush all
[09:29:46.167] - relayed: [n=1] TRUE
[09:29:46.167] - queued futures: [n=1] TRUE
[09:29:46.167] signalConditionsASAP(NULL, pos=0) ... done
[09:29:46.167] resolve() on list ... DONE
[09:29:46.167]  - Number of value chunks collected: 1
[09:29:46.167] Resolving 1 futures (chunks) ... DONE
[09:29:46.168] Reducing values from 1 chunks ...
[09:29:46.168]  - Number of values collected after concatenation: 4
[09:29:46.168]  - Number of values expected: 4
[09:29:46.168] Reducing values from 1 chunks ... DONE
[09:29:46.168] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[09:29:46.170] future_lapply() ...
[09:29:46.171] Number of chunks: 1
[09:29:46.171] getGlobalsAndPackagesXApply() ...
[09:29:46.171]  - future.globals: TRUE
[09:29:46.172] getGlobalsAndPackages() ...
[09:29:46.172] Searching for globals...
[09:29:46.174] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:46.174] Searching for globals ... DONE
[09:29:46.175] Resolving globals: FALSE
[09:29:46.175] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[09:29:46.176] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:46.176] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.176] - packages: [1] ‘future.apply’
[09:29:46.176] getGlobalsAndPackages() ... DONE
[09:29:46.176]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.176]  - needed namespaces: [n=1] ‘future.apply’
[09:29:46.176] Finding globals ... DONE
[09:29:46.176]  - use_args: TRUE
[09:29:46.176]  - Getting '...' globals ...
[09:29:46.177] resolve() on list ...
[09:29:46.177]  recursive: 0
[09:29:46.177]  length: 1
[09:29:46.177]  elements: ‘...’
[09:29:46.177]  length: 0 (resolved future 1)
[09:29:46.177] resolve() on list ... DONE
[09:29:46.177]    - '...' content: [n=0] 
[09:29:46.177] List of 1
[09:29:46.177]  $ ...: list()
[09:29:46.177]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.177]  - attr(*, "where")=List of 1
[09:29:46.177]   ..$ ...:<environment: 0x561d34e18a50> 
[09:29:46.177]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.177]  - attr(*, "resolved")= logi TRUE
[09:29:46.177]  - attr(*, "total_size")= num NA
[09:29:46.180]  - Getting '...' globals ... DONE
[09:29:46.180] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:46.180] List of 8
[09:29:46.180]  $ ...future.FUN:function (x, ...)  
[09:29:46.180]  $ x_FUN        :function (x)  
[09:29:46.180]  $ times        : int 1
[09:29:46.180]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.180]  $ stop_if_not  :function (...)  
[09:29:46.180]  $ dim          : NULL
[09:29:46.180]  $ valid_types  : chr "logical"
[09:29:46.180]  $ ...          : list()
[09:29:46.180]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.180]  - attr(*, "where")=List of 8
[09:29:46.180]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.180]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:46.180]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:46.180]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:46.180]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:46.180]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:46.180]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:46.180]   ..$ ...          :<environment: 0x561d34e18a50> 
[09:29:46.180]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.180]  - attr(*, "resolved")= logi FALSE
[09:29:46.180]  - attr(*, "total_size")= num 94200
[09:29:46.185] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:46.185] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.185] Number of futures (= number of chunks): 1
[09:29:46.185] Launching 1 futures (chunks) ...
[09:29:46.185] Chunk #1 of 1 ...
[09:29:46.185]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.185] getGlobalsAndPackages() ...
[09:29:46.186] Searching for globals...
[09:29:46.186] 
[09:29:46.186] Searching for globals ... DONE
[09:29:46.186] - globals: [0] <none>
[09:29:46.186] getGlobalsAndPackages() ... DONE
[09:29:46.186]    + additional globals found: [n=0] 
[09:29:46.186]    + additional namespaces needed: [n=0] 
[09:29:46.186]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.186]  - seeds: <none>
[09:29:46.187]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.187] getGlobalsAndPackages() ...
[09:29:46.187] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.188] Resolving globals: FALSE
[09:29:46.188] Tweak future expression to call with '...' arguments ...
[09:29:46.188] {
[09:29:46.188]     do.call(function(...) {
[09:29:46.188]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.188]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.188]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.188]             on.exit(options(oopts), add = TRUE)
[09:29:46.188]         }
[09:29:46.188]         {
[09:29:46.188]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.188]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.188]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.188]             })
[09:29:46.188]         }
[09:29:46.188]     }, args = future.call.arguments)
[09:29:46.188] }
[09:29:46.188] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.189] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.189] - packages: [1] ‘future.apply’
[09:29:46.189] getGlobalsAndPackages() ... DONE
[09:29:46.189] run() for ‘Future’ ...
[09:29:46.189] - state: ‘created’
[09:29:46.189] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:46.190] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.190] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:46.190]   - Field: ‘label’
[09:29:46.190]   - Field: ‘local’
[09:29:46.190]   - Field: ‘owner’
[09:29:46.190]   - Field: ‘envir’
[09:29:46.190]   - Field: ‘packages’
[09:29:46.190]   - Field: ‘gc’
[09:29:46.190]   - Field: ‘conditions’
[09:29:46.190]   - Field: ‘expr’
[09:29:46.190]   - Field: ‘uuid’
[09:29:46.191]   - Field: ‘seed’
[09:29:46.191]   - Field: ‘version’
[09:29:46.191]   - Field: ‘result’
[09:29:46.191]   - Field: ‘asynchronous’
[09:29:46.191]   - Field: ‘calls’
[09:29:46.191]   - Field: ‘globals’
[09:29:46.191]   - Field: ‘stdout’
[09:29:46.191]   - Field: ‘earlySignal’
[09:29:46.191]   - Field: ‘lazy’
[09:29:46.191]   - Field: ‘state’
[09:29:46.191] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:46.191] - Launch lazy future ...
[09:29:46.192] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.192] Packages needed by future strategies (n = 0): <none>
[09:29:46.192] {
[09:29:46.192]     {
[09:29:46.192]         {
[09:29:46.192]             ...future.startTime <- base::Sys.time()
[09:29:46.192]             {
[09:29:46.192]                 {
[09:29:46.192]                   {
[09:29:46.192]                     {
[09:29:46.192]                       base::local({
[09:29:46.192]                         has_future <- base::requireNamespace("future", 
[09:29:46.192]                           quietly = TRUE)
[09:29:46.192]                         if (has_future) {
[09:29:46.192]                           ns <- base::getNamespace("future")
[09:29:46.192]                           version <- ns[[".package"]][["version"]]
[09:29:46.192]                           if (is.null(version)) 
[09:29:46.192]                             version <- utils::packageVersion("future")
[09:29:46.192]                         }
[09:29:46.192]                         else {
[09:29:46.192]                           version <- NULL
[09:29:46.192]                         }
[09:29:46.192]                         if (!has_future || version < "1.8.0") {
[09:29:46.192]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.192]                             "", base::R.version$version.string), 
[09:29:46.192]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:46.192]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:46.192]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.192]                               "release", "version")], collapse = " "), 
[09:29:46.192]                             hostname = base::Sys.info()[["nodename"]])
[09:29:46.192]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.192]                             info)
[09:29:46.192]                           info <- base::paste(info, collapse = "; ")
[09:29:46.192]                           if (!has_future) {
[09:29:46.192]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.192]                               info)
[09:29:46.192]                           }
[09:29:46.192]                           else {
[09:29:46.192]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.192]                               info, version)
[09:29:46.192]                           }
[09:29:46.192]                           base::stop(msg)
[09:29:46.192]                         }
[09:29:46.192]                       })
[09:29:46.192]                     }
[09:29:46.192]                     base::local({
[09:29:46.192]                       for (pkg in "future.apply") {
[09:29:46.192]                         base::loadNamespace(pkg)
[09:29:46.192]                         base::library(pkg, character.only = TRUE)
[09:29:46.192]                       }
[09:29:46.192]                     })
[09:29:46.192]                   }
[09:29:46.192]                   ...future.strategy.old <- future::plan("list")
[09:29:46.192]                   options(future.plan = NULL)
[09:29:46.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.192]                 }
[09:29:46.192]                 ...future.workdir <- getwd()
[09:29:46.192]             }
[09:29:46.192]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.192]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.192]         }
[09:29:46.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.192]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:46.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.192]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.192]             base::names(...future.oldOptions))
[09:29:46.192]     }
[09:29:46.192]     if (FALSE) {
[09:29:46.192]     }
[09:29:46.192]     else {
[09:29:46.192]         if (TRUE) {
[09:29:46.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.192]                 open = "w")
[09:29:46.192]         }
[09:29:46.192]         else {
[09:29:46.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.192]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.192]         }
[09:29:46.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.192]             base::sink(type = "output", split = FALSE)
[09:29:46.192]             base::close(...future.stdout)
[09:29:46.192]         }, add = TRUE)
[09:29:46.192]     }
[09:29:46.192]     ...future.frame <- base::sys.nframe()
[09:29:46.192]     ...future.conditions <- base::list()
[09:29:46.192]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.192]     if (FALSE) {
[09:29:46.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.192]     }
[09:29:46.192]     ...future.result <- base::tryCatch({
[09:29:46.192]         base::withCallingHandlers({
[09:29:46.192]             ...future.value <- base::withVisible(base::local({
[09:29:46.192]                 do.call(function(...) {
[09:29:46.192]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.192]                   if (!identical(...future.globals.maxSize.org, 
[09:29:46.192]                     ...future.globals.maxSize)) {
[09:29:46.192]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.192]                     on.exit(options(oopts), add = TRUE)
[09:29:46.192]                   }
[09:29:46.192]                   {
[09:29:46.192]                     lapply(seq_along(...future.elements_ii), 
[09:29:46.192]                       FUN = function(jj) {
[09:29:46.192]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.192]                         ...future.FUN(...future.X_jj, ...)
[09:29:46.192]                       })
[09:29:46.192]                   }
[09:29:46.192]                 }, args = future.call.arguments)
[09:29:46.192]             }))
[09:29:46.192]             future::FutureResult(value = ...future.value$value, 
[09:29:46.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.192]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.192]                     ...future.globalenv.names))
[09:29:46.192]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.192]         }, condition = base::local({
[09:29:46.192]             c <- base::c
[09:29:46.192]             inherits <- base::inherits
[09:29:46.192]             invokeRestart <- base::invokeRestart
[09:29:46.192]             length <- base::length
[09:29:46.192]             list <- base::list
[09:29:46.192]             seq.int <- base::seq.int
[09:29:46.192]             signalCondition <- base::signalCondition
[09:29:46.192]             sys.calls <- base::sys.calls
[09:29:46.192]             `[[` <- base::`[[`
[09:29:46.192]             `+` <- base::`+`
[09:29:46.192]             `<<-` <- base::`<<-`
[09:29:46.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.192]                   3L)]
[09:29:46.192]             }
[09:29:46.192]             function(cond) {
[09:29:46.192]                 is_error <- inherits(cond, "error")
[09:29:46.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.192]                   NULL)
[09:29:46.192]                 if (is_error) {
[09:29:46.192]                   sessionInformation <- function() {
[09:29:46.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.192]                       search = base::search(), system = base::Sys.info())
[09:29:46.192]                   }
[09:29:46.192]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.192]                     cond$call), session = sessionInformation(), 
[09:29:46.192]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.192]                   signalCondition(cond)
[09:29:46.192]                 }
[09:29:46.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.192]                 "immediateCondition"))) {
[09:29:46.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.192]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.192]                   if (TRUE && !signal) {
[09:29:46.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.192]                     {
[09:29:46.192]                       inherits <- base::inherits
[09:29:46.192]                       invokeRestart <- base::invokeRestart
[09:29:46.192]                       is.null <- base::is.null
[09:29:46.192]                       muffled <- FALSE
[09:29:46.192]                       if (inherits(cond, "message")) {
[09:29:46.192]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.192]                         if (muffled) 
[09:29:46.192]                           invokeRestart("muffleMessage")
[09:29:46.192]                       }
[09:29:46.192]                       else if (inherits(cond, "warning")) {
[09:29:46.192]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.192]                         if (muffled) 
[09:29:46.192]                           invokeRestart("muffleWarning")
[09:29:46.192]                       }
[09:29:46.192]                       else if (inherits(cond, "condition")) {
[09:29:46.192]                         if (!is.null(pattern)) {
[09:29:46.192]                           computeRestarts <- base::computeRestarts
[09:29:46.192]                           grepl <- base::grepl
[09:29:46.192]                           restarts <- computeRestarts(cond)
[09:29:46.192]                           for (restart in restarts) {
[09:29:46.192]                             name <- restart$name
[09:29:46.192]                             if (is.null(name)) 
[09:29:46.192]                               next
[09:29:46.192]                             if (!grepl(pattern, name)) 
[09:29:46.192]                               next
[09:29:46.192]                             invokeRestart(restart)
[09:29:46.192]                             muffled <- TRUE
[09:29:46.192]                             break
[09:29:46.192]                           }
[09:29:46.192]                         }
[09:29:46.192]                       }
[09:29:46.192]                       invisible(muffled)
[09:29:46.192]                     }
[09:29:46.192]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.192]                   }
[09:29:46.192]                 }
[09:29:46.192]                 else {
[09:29:46.192]                   if (TRUE) {
[09:29:46.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.192]                     {
[09:29:46.192]                       inherits <- base::inherits
[09:29:46.192]                       invokeRestart <- base::invokeRestart
[09:29:46.192]                       is.null <- base::is.null
[09:29:46.192]                       muffled <- FALSE
[09:29:46.192]                       if (inherits(cond, "message")) {
[09:29:46.192]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.192]                         if (muffled) 
[09:29:46.192]                           invokeRestart("muffleMessage")
[09:29:46.192]                       }
[09:29:46.192]                       else if (inherits(cond, "warning")) {
[09:29:46.192]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.192]                         if (muffled) 
[09:29:46.192]                           invokeRestart("muffleWarning")
[09:29:46.192]                       }
[09:29:46.192]                       else if (inherits(cond, "condition")) {
[09:29:46.192]                         if (!is.null(pattern)) {
[09:29:46.192]                           computeRestarts <- base::computeRestarts
[09:29:46.192]                           grepl <- base::grepl
[09:29:46.192]                           restarts <- computeRestarts(cond)
[09:29:46.192]                           for (restart in restarts) {
[09:29:46.192]                             name <- restart$name
[09:29:46.192]                             if (is.null(name)) 
[09:29:46.192]                               next
[09:29:46.192]                             if (!grepl(pattern, name)) 
[09:29:46.192]                               next
[09:29:46.192]                             invokeRestart(restart)
[09:29:46.192]                             muffled <- TRUE
[09:29:46.192]                             break
[09:29:46.192]                           }
[09:29:46.192]                         }
[09:29:46.192]                       }
[09:29:46.192]                       invisible(muffled)
[09:29:46.192]                     }
[09:29:46.192]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.192]                   }
[09:29:46.192]                 }
[09:29:46.192]             }
[09:29:46.192]         }))
[09:29:46.192]     }, error = function(ex) {
[09:29:46.192]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.192]                 ...future.rng), started = ...future.startTime, 
[09:29:46.192]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.192]             version = "1.8"), class = "FutureResult")
[09:29:46.192]     }, finally = {
[09:29:46.192]         if (!identical(...future.workdir, getwd())) 
[09:29:46.192]             setwd(...future.workdir)
[09:29:46.192]         {
[09:29:46.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.192]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.192]             }
[09:29:46.192]             base::options(...future.oldOptions)
[09:29:46.192]             if (.Platform$OS.type == "windows") {
[09:29:46.192]                 old_names <- names(...future.oldEnvVars)
[09:29:46.192]                 envs <- base::Sys.getenv()
[09:29:46.192]                 names <- names(envs)
[09:29:46.192]                 common <- intersect(names, old_names)
[09:29:46.192]                 added <- setdiff(names, old_names)
[09:29:46.192]                 removed <- setdiff(old_names, names)
[09:29:46.192]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.192]                   envs[common]]
[09:29:46.192]                 NAMES <- toupper(changed)
[09:29:46.192]                 args <- list()
[09:29:46.192]                 for (kk in seq_along(NAMES)) {
[09:29:46.192]                   name <- changed[[kk]]
[09:29:46.192]                   NAME <- NAMES[[kk]]
[09:29:46.192]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.192]                     next
[09:29:46.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.192]                 }
[09:29:46.192]                 NAMES <- toupper(added)
[09:29:46.192]                 for (kk in seq_along(NAMES)) {
[09:29:46.192]                   name <- added[[kk]]
[09:29:46.192]                   NAME <- NAMES[[kk]]
[09:29:46.192]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.192]                     next
[09:29:46.192]                   args[[name]] <- ""
[09:29:46.192]                 }
[09:29:46.192]                 NAMES <- toupper(removed)
[09:29:46.192]                 for (kk in seq_along(NAMES)) {
[09:29:46.192]                   name <- removed[[kk]]
[09:29:46.192]                   NAME <- NAMES[[kk]]
[09:29:46.192]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.192]                     next
[09:29:46.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.192]                 }
[09:29:46.192]                 if (length(args) > 0) 
[09:29:46.192]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.192]             }
[09:29:46.192]             else {
[09:29:46.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.192]             }
[09:29:46.192]             {
[09:29:46.192]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.192]                   0L) {
[09:29:46.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.192]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.192]                   base::options(opts)
[09:29:46.192]                 }
[09:29:46.192]                 {
[09:29:46.192]                   {
[09:29:46.192]                     NULL
[09:29:46.192]                     RNGkind("Mersenne-Twister")
[09:29:46.192]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:46.192]                       inherits = FALSE)
[09:29:46.192]                   }
[09:29:46.192]                   options(future.plan = NULL)
[09:29:46.192]                   if (is.na(NA_character_)) 
[09:29:46.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.192]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.192]                     .init = FALSE)
[09:29:46.192]                 }
[09:29:46.192]             }
[09:29:46.192]         }
[09:29:46.192]     })
[09:29:46.192]     if (TRUE) {
[09:29:46.192]         base::sink(type = "output", split = FALSE)
[09:29:46.192]         if (TRUE) {
[09:29:46.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.192]         }
[09:29:46.192]         else {
[09:29:46.192]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.192]         }
[09:29:46.192]         base::close(...future.stdout)
[09:29:46.192]         ...future.stdout <- NULL
[09:29:46.192]     }
[09:29:46.192]     ...future.result$conditions <- ...future.conditions
[09:29:46.192]     ...future.result$finished <- base::Sys.time()
[09:29:46.192]     ...future.result
[09:29:46.192] }
[09:29:46.194] assign_globals() ...
[09:29:46.194] List of 11
[09:29:46.194]  $ ...future.FUN            :function (x, ...)  
[09:29:46.194]  $ x_FUN                    :function (x)  
[09:29:46.194]  $ times                    : int 1
[09:29:46.194]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.194]  $ stop_if_not              :function (...)  
[09:29:46.194]  $ dim                      : NULL
[09:29:46.194]  $ valid_types              : chr "logical"
[09:29:46.194]  $ future.call.arguments    : list()
[09:29:46.194]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.194]  $ ...future.elements_ii    :List of 11
[09:29:46.194]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[09:29:46.194]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[09:29:46.194]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[09:29:46.194]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[09:29:46.194]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[09:29:46.194]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[09:29:46.194]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[09:29:46.194]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[09:29:46.194]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[09:29:46.194]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[09:29:46.194]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[09:29:46.194]  $ ...future.seeds_ii       : NULL
[09:29:46.194]  $ ...future.globals.maxSize: NULL
[09:29:46.194]  - attr(*, "where")=List of 11
[09:29:46.194]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.194]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.194]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.194]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.194]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.194]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.194]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.194]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.194]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.194]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.194]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.194]  - attr(*, "resolved")= logi FALSE
[09:29:46.194]  - attr(*, "total_size")= num 94200
[09:29:46.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.194]  - attr(*, "already-done")= logi TRUE
[09:29:46.203] - copied ‘...future.FUN’ to environment
[09:29:46.204] - copied ‘x_FUN’ to environment
[09:29:46.204] - copied ‘times’ to environment
[09:29:46.204] - copied ‘stopf’ to environment
[09:29:46.204] - copied ‘stop_if_not’ to environment
[09:29:46.204] - copied ‘dim’ to environment
[09:29:46.204] - copied ‘valid_types’ to environment
[09:29:46.204] - copied ‘future.call.arguments’ to environment
[09:29:46.204] - copied ‘...future.elements_ii’ to environment
[09:29:46.204] - copied ‘...future.seeds_ii’ to environment
[09:29:46.204] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.204] assign_globals() ... done
[09:29:46.205] plan(): Setting new future strategy stack:
[09:29:46.205] List of future strategies:
[09:29:46.205] 1. sequential:
[09:29:46.205]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.205]    - tweaked: FALSE
[09:29:46.205]    - call: NULL
[09:29:46.205] plan(): nbrOfWorkers() = 1
[09:29:46.206] plan(): Setting new future strategy stack:
[09:29:46.206] List of future strategies:
[09:29:46.206] 1. sequential:
[09:29:46.206]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.206]    - tweaked: FALSE
[09:29:46.206]    - call: plan(strategy)
[09:29:46.206] plan(): nbrOfWorkers() = 1
[09:29:46.207] SequentialFuture started (and completed)
[09:29:46.207] - Launch lazy future ... done
[09:29:46.207] run() for ‘SequentialFuture’ ... done
[09:29:46.207] Created future:
[09:29:46.207] SequentialFuture:
[09:29:46.207] Label: ‘future_vapply-1’
[09:29:46.207] Expression:
[09:29:46.207] {
[09:29:46.207]     do.call(function(...) {
[09:29:46.207]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.207]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.207]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.207]             on.exit(options(oopts), add = TRUE)
[09:29:46.207]         }
[09:29:46.207]         {
[09:29:46.207]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.207]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.207]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.207]             })
[09:29:46.207]         }
[09:29:46.207]     }, args = future.call.arguments)
[09:29:46.207] }
[09:29:46.207] Lazy evaluation: FALSE
[09:29:46.207] Asynchronous evaluation: FALSE
[09:29:46.207] Local evaluation: TRUE
[09:29:46.207] Environment: R_GlobalEnv
[09:29:46.207] Capture standard output: TRUE
[09:29:46.207] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.207] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.207] Packages: 1 packages (‘future.apply’)
[09:29:46.207] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.207] Resolved: TRUE
[09:29:46.207] Value: 616 bytes of class ‘list’
[09:29:46.207] Early signaling: FALSE
[09:29:46.207] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.207] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.208] Chunk #1 of 1 ... DONE
[09:29:46.208] Launching 1 futures (chunks) ... DONE
[09:29:46.208] Resolving 1 futures (chunks) ...
[09:29:46.208] resolve() on list ...
[09:29:46.209]  recursive: 0
[09:29:46.209]  length: 1
[09:29:46.209] 
[09:29:46.210] resolved() for ‘SequentialFuture’ ...
[09:29:46.210] - state: ‘finished’
[09:29:46.210] - run: TRUE
[09:29:46.210] - result: ‘FutureResult’
[09:29:46.210] resolved() for ‘SequentialFuture’ ... done
[09:29:46.210] Future #1
[09:29:46.210] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:46.210] - nx: 1
[09:29:46.210] - relay: TRUE
[09:29:46.210] - stdout: TRUE
[09:29:46.211] - signal: TRUE
[09:29:46.211] - resignal: FALSE
[09:29:46.211] - force: TRUE
[09:29:46.211] - relayed: [n=1] FALSE
[09:29:46.211] - queued futures: [n=1] FALSE
[09:29:46.211]  - until=1
[09:29:46.211]  - relaying element #1
[09:29:46.211] - relayed: [n=1] TRUE
[09:29:46.211] - queued futures: [n=1] TRUE
[09:29:46.211] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:46.211]  length: 0 (resolved future 1)
[09:29:46.212] Relaying remaining futures
[09:29:46.212] signalConditionsASAP(NULL, pos=0) ...
[09:29:46.212] - nx: 1
[09:29:46.212] - relay: TRUE
[09:29:46.212] - stdout: TRUE
[09:29:46.212] - signal: TRUE
[09:29:46.212] - resignal: FALSE
[09:29:46.212] - force: TRUE
[09:29:46.212] - relayed: [n=1] TRUE
[09:29:46.212] - queued futures: [n=1] TRUE
 - flush all
[09:29:46.212] - relayed: [n=1] TRUE
[09:29:46.212] - queued futures: [n=1] TRUE
[09:29:46.213] signalConditionsASAP(NULL, pos=0) ... done
[09:29:46.213] resolve() on list ... DONE
[09:29:46.213]  - Number of value chunks collected: 1
[09:29:46.213] Resolving 1 futures (chunks) ... DONE
[09:29:46.213] Reducing values from 1 chunks ...
[09:29:46.213]  - Number of values collected after concatenation: 11
[09:29:46.213]  - Number of values expected: 11
[09:29:46.213] Reducing values from 1 chunks ... DONE
[09:29:46.213] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[09:29:46.214] future_lapply() ...
[09:29:46.216] Number of chunks: 1
[09:29:46.216] getGlobalsAndPackagesXApply() ...
[09:29:46.216]  - future.globals: TRUE
[09:29:46.216] getGlobalsAndPackages() ...
[09:29:46.216] Searching for globals...
[09:29:46.219] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:46.219] Searching for globals ... DONE
[09:29:46.219] Resolving globals: FALSE
[09:29:46.219] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[09:29:46.220] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:46.220] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.220] - packages: [1] ‘future.apply’
[09:29:46.220] getGlobalsAndPackages() ... DONE
[09:29:46.220]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.220]  - needed namespaces: [n=1] ‘future.apply’
[09:29:46.220] Finding globals ... DONE
[09:29:46.221]  - use_args: TRUE
[09:29:46.221]  - Getting '...' globals ...
[09:29:46.221] resolve() on list ...
[09:29:46.221]  recursive: 0
[09:29:46.221]  length: 1
[09:29:46.221]  elements: ‘...’
[09:29:46.221]  length: 0 (resolved future 1)
[09:29:46.221] resolve() on list ... DONE
[09:29:46.222]    - '...' content: [n=0] 
[09:29:46.222] List of 1
[09:29:46.222]  $ ...: list()
[09:29:46.222]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.222]  - attr(*, "where")=List of 1
[09:29:46.222]   ..$ ...:<environment: 0x561d341c7768> 
[09:29:46.222]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.222]  - attr(*, "resolved")= logi TRUE
[09:29:46.222]  - attr(*, "total_size")= num NA
[09:29:46.224]  - Getting '...' globals ... DONE
[09:29:46.224] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:46.224] List of 8
[09:29:46.224]  $ ...future.FUN:function (x, ...)  
[09:29:46.224]  $ x_FUN        :function (x)  
[09:29:46.224]  $ times        : int 1
[09:29:46.224]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.224]  $ stop_if_not  :function (...)  
[09:29:46.224]  $ dim          : NULL
[09:29:46.224]  $ valid_types  : chr [1:2] "logical" "integer"
[09:29:46.224]  $ ...          : list()
[09:29:46.224]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.224]  - attr(*, "where")=List of 8
[09:29:46.224]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.224]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:46.224]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:46.224]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:46.224]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:46.224]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:46.224]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:46.224]   ..$ ...          :<environment: 0x561d341c7768> 
[09:29:46.224]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.224]  - attr(*, "resolved")= logi FALSE
[09:29:46.224]  - attr(*, "total_size")= num 94264
[09:29:46.230] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:46.230] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.230] Number of futures (= number of chunks): 1
[09:29:46.230] Launching 1 futures (chunks) ...
[09:29:46.230] Chunk #1 of 1 ...
[09:29:46.231]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.231] getGlobalsAndPackages() ...
[09:29:46.231] Searching for globals...
[09:29:46.231] 
[09:29:46.231] Searching for globals ... DONE
[09:29:46.231] - globals: [0] <none>
[09:29:46.231] getGlobalsAndPackages() ... DONE
[09:29:46.231]    + additional globals found: [n=0] 
[09:29:46.231]    + additional namespaces needed: [n=0] 
[09:29:46.231]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.232]  - seeds: <none>
[09:29:46.232]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.232] getGlobalsAndPackages() ...
[09:29:46.232] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.232] Resolving globals: FALSE
[09:29:46.232] Tweak future expression to call with '...' arguments ...
[09:29:46.232] {
[09:29:46.232]     do.call(function(...) {
[09:29:46.232]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.232]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.232]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.232]             on.exit(options(oopts), add = TRUE)
[09:29:46.232]         }
[09:29:46.232]         {
[09:29:46.232]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.232]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.232]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.232]             })
[09:29:46.232]         }
[09:29:46.232]     }, args = future.call.arguments)
[09:29:46.232] }
[09:29:46.232] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.233] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.233] - packages: [1] ‘future.apply’
[09:29:46.233] getGlobalsAndPackages() ... DONE
[09:29:46.233] run() for ‘Future’ ...
[09:29:46.233] - state: ‘created’
[09:29:46.233] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:46.234] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:46.234]   - Field: ‘label’
[09:29:46.234]   - Field: ‘local’
[09:29:46.234]   - Field: ‘owner’
[09:29:46.234]   - Field: ‘envir’
[09:29:46.234]   - Field: ‘packages’
[09:29:46.234]   - Field: ‘gc’
[09:29:46.234]   - Field: ‘conditions’
[09:29:46.235]   - Field: ‘expr’
[09:29:46.235]   - Field: ‘uuid’
[09:29:46.235]   - Field: ‘seed’
[09:29:46.235]   - Field: ‘version’
[09:29:46.235]   - Field: ‘result’
[09:29:46.235]   - Field: ‘asynchronous’
[09:29:46.235]   - Field: ‘calls’
[09:29:46.235]   - Field: ‘globals’
[09:29:46.235]   - Field: ‘stdout’
[09:29:46.235]   - Field: ‘earlySignal’
[09:29:46.235]   - Field: ‘lazy’
[09:29:46.235]   - Field: ‘state’
[09:29:46.236] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:46.236] - Launch lazy future ...
[09:29:46.236] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.236] Packages needed by future strategies (n = 0): <none>
[09:29:46.236] {
[09:29:46.236]     {
[09:29:46.236]         {
[09:29:46.236]             ...future.startTime <- base::Sys.time()
[09:29:46.236]             {
[09:29:46.236]                 {
[09:29:46.236]                   {
[09:29:46.236]                     {
[09:29:46.236]                       base::local({
[09:29:46.236]                         has_future <- base::requireNamespace("future", 
[09:29:46.236]                           quietly = TRUE)
[09:29:46.236]                         if (has_future) {
[09:29:46.236]                           ns <- base::getNamespace("future")
[09:29:46.236]                           version <- ns[[".package"]][["version"]]
[09:29:46.236]                           if (is.null(version)) 
[09:29:46.236]                             version <- utils::packageVersion("future")
[09:29:46.236]                         }
[09:29:46.236]                         else {
[09:29:46.236]                           version <- NULL
[09:29:46.236]                         }
[09:29:46.236]                         if (!has_future || version < "1.8.0") {
[09:29:46.236]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.236]                             "", base::R.version$version.string), 
[09:29:46.236]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:46.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:46.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.236]                               "release", "version")], collapse = " "), 
[09:29:46.236]                             hostname = base::Sys.info()[["nodename"]])
[09:29:46.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.236]                             info)
[09:29:46.236]                           info <- base::paste(info, collapse = "; ")
[09:29:46.236]                           if (!has_future) {
[09:29:46.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.236]                               info)
[09:29:46.236]                           }
[09:29:46.236]                           else {
[09:29:46.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.236]                               info, version)
[09:29:46.236]                           }
[09:29:46.236]                           base::stop(msg)
[09:29:46.236]                         }
[09:29:46.236]                       })
[09:29:46.236]                     }
[09:29:46.236]                     base::local({
[09:29:46.236]                       for (pkg in "future.apply") {
[09:29:46.236]                         base::loadNamespace(pkg)
[09:29:46.236]                         base::library(pkg, character.only = TRUE)
[09:29:46.236]                       }
[09:29:46.236]                     })
[09:29:46.236]                   }
[09:29:46.236]                   ...future.strategy.old <- future::plan("list")
[09:29:46.236]                   options(future.plan = NULL)
[09:29:46.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.236]                 }
[09:29:46.236]                 ...future.workdir <- getwd()
[09:29:46.236]             }
[09:29:46.236]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.236]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.236]         }
[09:29:46.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.236]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:46.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.236]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.236]             base::names(...future.oldOptions))
[09:29:46.236]     }
[09:29:46.236]     if (FALSE) {
[09:29:46.236]     }
[09:29:46.236]     else {
[09:29:46.236]         if (TRUE) {
[09:29:46.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.236]                 open = "w")
[09:29:46.236]         }
[09:29:46.236]         else {
[09:29:46.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.236]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.236]         }
[09:29:46.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.236]             base::sink(type = "output", split = FALSE)
[09:29:46.236]             base::close(...future.stdout)
[09:29:46.236]         }, add = TRUE)
[09:29:46.236]     }
[09:29:46.236]     ...future.frame <- base::sys.nframe()
[09:29:46.236]     ...future.conditions <- base::list()
[09:29:46.236]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.236]     if (FALSE) {
[09:29:46.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.236]     }
[09:29:46.236]     ...future.result <- base::tryCatch({
[09:29:46.236]         base::withCallingHandlers({
[09:29:46.236]             ...future.value <- base::withVisible(base::local({
[09:29:46.236]                 do.call(function(...) {
[09:29:46.236]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.236]                   if (!identical(...future.globals.maxSize.org, 
[09:29:46.236]                     ...future.globals.maxSize)) {
[09:29:46.236]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.236]                     on.exit(options(oopts), add = TRUE)
[09:29:46.236]                   }
[09:29:46.236]                   {
[09:29:46.236]                     lapply(seq_along(...future.elements_ii), 
[09:29:46.236]                       FUN = function(jj) {
[09:29:46.236]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.236]                         ...future.FUN(...future.X_jj, ...)
[09:29:46.236]                       })
[09:29:46.236]                   }
[09:29:46.236]                 }, args = future.call.arguments)
[09:29:46.236]             }))
[09:29:46.236]             future::FutureResult(value = ...future.value$value, 
[09:29:46.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.236]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.236]                     ...future.globalenv.names))
[09:29:46.236]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.236]         }, condition = base::local({
[09:29:46.236]             c <- base::c
[09:29:46.236]             inherits <- base::inherits
[09:29:46.236]             invokeRestart <- base::invokeRestart
[09:29:46.236]             length <- base::length
[09:29:46.236]             list <- base::list
[09:29:46.236]             seq.int <- base::seq.int
[09:29:46.236]             signalCondition <- base::signalCondition
[09:29:46.236]             sys.calls <- base::sys.calls
[09:29:46.236]             `[[` <- base::`[[`
[09:29:46.236]             `+` <- base::`+`
[09:29:46.236]             `<<-` <- base::`<<-`
[09:29:46.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.236]                   3L)]
[09:29:46.236]             }
[09:29:46.236]             function(cond) {
[09:29:46.236]                 is_error <- inherits(cond, "error")
[09:29:46.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.236]                   NULL)
[09:29:46.236]                 if (is_error) {
[09:29:46.236]                   sessionInformation <- function() {
[09:29:46.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.236]                       search = base::search(), system = base::Sys.info())
[09:29:46.236]                   }
[09:29:46.236]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.236]                     cond$call), session = sessionInformation(), 
[09:29:46.236]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.236]                   signalCondition(cond)
[09:29:46.236]                 }
[09:29:46.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.236]                 "immediateCondition"))) {
[09:29:46.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.236]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.236]                   if (TRUE && !signal) {
[09:29:46.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.236]                     {
[09:29:46.236]                       inherits <- base::inherits
[09:29:46.236]                       invokeRestart <- base::invokeRestart
[09:29:46.236]                       is.null <- base::is.null
[09:29:46.236]                       muffled <- FALSE
[09:29:46.236]                       if (inherits(cond, "message")) {
[09:29:46.236]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.236]                         if (muffled) 
[09:29:46.236]                           invokeRestart("muffleMessage")
[09:29:46.236]                       }
[09:29:46.236]                       else if (inherits(cond, "warning")) {
[09:29:46.236]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.236]                         if (muffled) 
[09:29:46.236]                           invokeRestart("muffleWarning")
[09:29:46.236]                       }
[09:29:46.236]                       else if (inherits(cond, "condition")) {
[09:29:46.236]                         if (!is.null(pattern)) {
[09:29:46.236]                           computeRestarts <- base::computeRestarts
[09:29:46.236]                           grepl <- base::grepl
[09:29:46.236]                           restarts <- computeRestarts(cond)
[09:29:46.236]                           for (restart in restarts) {
[09:29:46.236]                             name <- restart$name
[09:29:46.236]                             if (is.null(name)) 
[09:29:46.236]                               next
[09:29:46.236]                             if (!grepl(pattern, name)) 
[09:29:46.236]                               next
[09:29:46.236]                             invokeRestart(restart)
[09:29:46.236]                             muffled <- TRUE
[09:29:46.236]                             break
[09:29:46.236]                           }
[09:29:46.236]                         }
[09:29:46.236]                       }
[09:29:46.236]                       invisible(muffled)
[09:29:46.236]                     }
[09:29:46.236]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.236]                   }
[09:29:46.236]                 }
[09:29:46.236]                 else {
[09:29:46.236]                   if (TRUE) {
[09:29:46.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.236]                     {
[09:29:46.236]                       inherits <- base::inherits
[09:29:46.236]                       invokeRestart <- base::invokeRestart
[09:29:46.236]                       is.null <- base::is.null
[09:29:46.236]                       muffled <- FALSE
[09:29:46.236]                       if (inherits(cond, "message")) {
[09:29:46.236]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.236]                         if (muffled) 
[09:29:46.236]                           invokeRestart("muffleMessage")
[09:29:46.236]                       }
[09:29:46.236]                       else if (inherits(cond, "warning")) {
[09:29:46.236]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.236]                         if (muffled) 
[09:29:46.236]                           invokeRestart("muffleWarning")
[09:29:46.236]                       }
[09:29:46.236]                       else if (inherits(cond, "condition")) {
[09:29:46.236]                         if (!is.null(pattern)) {
[09:29:46.236]                           computeRestarts <- base::computeRestarts
[09:29:46.236]                           grepl <- base::grepl
[09:29:46.236]                           restarts <- computeRestarts(cond)
[09:29:46.236]                           for (restart in restarts) {
[09:29:46.236]                             name <- restart$name
[09:29:46.236]                             if (is.null(name)) 
[09:29:46.236]                               next
[09:29:46.236]                             if (!grepl(pattern, name)) 
[09:29:46.236]                               next
[09:29:46.236]                             invokeRestart(restart)
[09:29:46.236]                             muffled <- TRUE
[09:29:46.236]                             break
[09:29:46.236]                           }
[09:29:46.236]                         }
[09:29:46.236]                       }
[09:29:46.236]                       invisible(muffled)
[09:29:46.236]                     }
[09:29:46.236]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.236]                   }
[09:29:46.236]                 }
[09:29:46.236]             }
[09:29:46.236]         }))
[09:29:46.236]     }, error = function(ex) {
[09:29:46.236]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.236]                 ...future.rng), started = ...future.startTime, 
[09:29:46.236]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.236]             version = "1.8"), class = "FutureResult")
[09:29:46.236]     }, finally = {
[09:29:46.236]         if (!identical(...future.workdir, getwd())) 
[09:29:46.236]             setwd(...future.workdir)
[09:29:46.236]         {
[09:29:46.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.236]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.236]             }
[09:29:46.236]             base::options(...future.oldOptions)
[09:29:46.236]             if (.Platform$OS.type == "windows") {
[09:29:46.236]                 old_names <- names(...future.oldEnvVars)
[09:29:46.236]                 envs <- base::Sys.getenv()
[09:29:46.236]                 names <- names(envs)
[09:29:46.236]                 common <- intersect(names, old_names)
[09:29:46.236]                 added <- setdiff(names, old_names)
[09:29:46.236]                 removed <- setdiff(old_names, names)
[09:29:46.236]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.236]                   envs[common]]
[09:29:46.236]                 NAMES <- toupper(changed)
[09:29:46.236]                 args <- list()
[09:29:46.236]                 for (kk in seq_along(NAMES)) {
[09:29:46.236]                   name <- changed[[kk]]
[09:29:46.236]                   NAME <- NAMES[[kk]]
[09:29:46.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.236]                     next
[09:29:46.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.236]                 }
[09:29:46.236]                 NAMES <- toupper(added)
[09:29:46.236]                 for (kk in seq_along(NAMES)) {
[09:29:46.236]                   name <- added[[kk]]
[09:29:46.236]                   NAME <- NAMES[[kk]]
[09:29:46.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.236]                     next
[09:29:46.236]                   args[[name]] <- ""
[09:29:46.236]                 }
[09:29:46.236]                 NAMES <- toupper(removed)
[09:29:46.236]                 for (kk in seq_along(NAMES)) {
[09:29:46.236]                   name <- removed[[kk]]
[09:29:46.236]                   NAME <- NAMES[[kk]]
[09:29:46.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.236]                     next
[09:29:46.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.236]                 }
[09:29:46.236]                 if (length(args) > 0) 
[09:29:46.236]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.236]             }
[09:29:46.236]             else {
[09:29:46.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.236]             }
[09:29:46.236]             {
[09:29:46.236]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.236]                   0L) {
[09:29:46.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.236]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.236]                   base::options(opts)
[09:29:46.236]                 }
[09:29:46.236]                 {
[09:29:46.236]                   {
[09:29:46.236]                     NULL
[09:29:46.236]                     RNGkind("Mersenne-Twister")
[09:29:46.236]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:46.236]                       inherits = FALSE)
[09:29:46.236]                   }
[09:29:46.236]                   options(future.plan = NULL)
[09:29:46.236]                   if (is.na(NA_character_)) 
[09:29:46.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.236]                     .init = FALSE)
[09:29:46.236]                 }
[09:29:46.236]             }
[09:29:46.236]         }
[09:29:46.236]     })
[09:29:46.236]     if (TRUE) {
[09:29:46.236]         base::sink(type = "output", split = FALSE)
[09:29:46.236]         if (TRUE) {
[09:29:46.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.236]         }
[09:29:46.236]         else {
[09:29:46.236]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.236]         }
[09:29:46.236]         base::close(...future.stdout)
[09:29:46.236]         ...future.stdout <- NULL
[09:29:46.236]     }
[09:29:46.236]     ...future.result$conditions <- ...future.conditions
[09:29:46.236]     ...future.result$finished <- base::Sys.time()
[09:29:46.236]     ...future.result
[09:29:46.236] }
[09:29:46.238] assign_globals() ...
[09:29:46.238] List of 11
[09:29:46.238]  $ ...future.FUN            :function (x, ...)  
[09:29:46.238]  $ x_FUN                    :function (x)  
[09:29:46.238]  $ times                    : int 1
[09:29:46.238]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.238]  $ stop_if_not              :function (...)  
[09:29:46.238]  $ dim                      : NULL
[09:29:46.238]  $ valid_types              : chr [1:2] "logical" "integer"
[09:29:46.238]  $ future.call.arguments    : list()
[09:29:46.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.238]  $ ...future.elements_ii    :List of 3
[09:29:46.238]   ..$ a: num 1
[09:29:46.238]   ..$ b: num 2
[09:29:46.238]   ..$ c: num 3
[09:29:46.238]  $ ...future.seeds_ii       : NULL
[09:29:46.238]  $ ...future.globals.maxSize: NULL
[09:29:46.238]  - attr(*, "where")=List of 11
[09:29:46.238]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.238]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.238]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.238]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.238]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.238]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.238]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.238]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.238]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.238]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.238]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.238]  - attr(*, "resolved")= logi FALSE
[09:29:46.238]  - attr(*, "total_size")= num 94264
[09:29:46.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.238]  - attr(*, "already-done")= logi TRUE
[09:29:46.245] - copied ‘...future.FUN’ to environment
[09:29:46.245] - copied ‘x_FUN’ to environment
[09:29:46.245] - copied ‘times’ to environment
[09:29:46.245] - copied ‘stopf’ to environment
[09:29:46.245] - copied ‘stop_if_not’ to environment
[09:29:46.246] - copied ‘dim’ to environment
[09:29:46.246] - copied ‘valid_types’ to environment
[09:29:46.246] - copied ‘future.call.arguments’ to environment
[09:29:46.246] - copied ‘...future.elements_ii’ to environment
[09:29:46.246] - copied ‘...future.seeds_ii’ to environment
[09:29:46.246] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.246] assign_globals() ... done
[09:29:46.246] plan(): Setting new future strategy stack:
[09:29:46.246] List of future strategies:
[09:29:46.246] 1. sequential:
[09:29:46.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.246]    - tweaked: FALSE
[09:29:46.246]    - call: NULL
[09:29:46.247] plan(): nbrOfWorkers() = 1
[09:29:46.248] plan(): Setting new future strategy stack:
[09:29:46.248] List of future strategies:
[09:29:46.248] 1. sequential:
[09:29:46.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.248]    - tweaked: FALSE
[09:29:46.248]    - call: plan(strategy)
[09:29:46.248] plan(): nbrOfWorkers() = 1
[09:29:46.248] SequentialFuture started (and completed)
[09:29:46.248] - Launch lazy future ... done
[09:29:46.248] run() for ‘SequentialFuture’ ... done
[09:29:46.249] Created future:
[09:29:46.249] SequentialFuture:
[09:29:46.249] Label: ‘future_vapply-1’
[09:29:46.249] Expression:
[09:29:46.249] {
[09:29:46.249]     do.call(function(...) {
[09:29:46.249]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.249]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.249]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.249]             on.exit(options(oopts), add = TRUE)
[09:29:46.249]         }
[09:29:46.249]         {
[09:29:46.249]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.249]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.249]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.249]             })
[09:29:46.249]         }
[09:29:46.249]     }, args = future.call.arguments)
[09:29:46.249] }
[09:29:46.249] Lazy evaluation: FALSE
[09:29:46.249] Asynchronous evaluation: FALSE
[09:29:46.249] Local evaluation: TRUE
[09:29:46.249] Environment: R_GlobalEnv
[09:29:46.249] Capture standard output: TRUE
[09:29:46.249] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.249] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.249] Packages: 1 packages (‘future.apply’)
[09:29:46.249] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.249] Resolved: TRUE
[09:29:46.249] Value: 168 bytes of class ‘list’
[09:29:46.249] Early signaling: FALSE
[09:29:46.249] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.249] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.250] Chunk #1 of 1 ... DONE
[09:29:46.250] Launching 1 futures (chunks) ... DONE
[09:29:46.250] Resolving 1 futures (chunks) ...
[09:29:46.250] resolve() on list ...
[09:29:46.250]  recursive: 0
[09:29:46.250]  length: 1
[09:29:46.251] 
[09:29:46.251] resolved() for ‘SequentialFuture’ ...
[09:29:46.252] - state: ‘finished’
[09:29:46.252] - run: TRUE
[09:29:46.252] - result: ‘FutureResult’
[09:29:46.252] resolved() for ‘SequentialFuture’ ... done
[09:29:46.252] Future #1
[09:29:46.252] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:46.252] - nx: 1
[09:29:46.252] - relay: TRUE
[09:29:46.252] - stdout: TRUE
[09:29:46.252] - signal: TRUE
[09:29:46.253] - resignal: FALSE
[09:29:46.253] - force: TRUE
[09:29:46.253] - relayed: [n=1] FALSE
[09:29:46.253] - queued futures: [n=1] FALSE
[09:29:46.253]  - until=1
[09:29:46.253]  - relaying element #1
[09:29:46.253] - relayed: [n=1] TRUE
[09:29:46.253] - queued futures: [n=1] TRUE
[09:29:46.253] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:46.253]  length: 0 (resolved future 1)
[09:29:46.254] Relaying remaining futures
[09:29:46.254] signalConditionsASAP(NULL, pos=0) ...
[09:29:46.254] - nx: 1
[09:29:46.254] - relay: TRUE
[09:29:46.254] - stdout: TRUE
[09:29:46.254] - signal: TRUE
[09:29:46.254] - resignal: FALSE
[09:29:46.254] - force: TRUE
[09:29:46.254] - relayed: [n=1] TRUE
[09:29:46.254] - queued futures: [n=1] TRUE
 - flush all
[09:29:46.254] - relayed: [n=1] TRUE
[09:29:46.254] - queued futures: [n=1] TRUE
[09:29:46.254] signalConditionsASAP(NULL, pos=0) ... done
[09:29:46.255] resolve() on list ... DONE
[09:29:46.255]  - Number of value chunks collected: 1
[09:29:46.255] Resolving 1 futures (chunks) ... DONE
[09:29:46.255] Reducing values from 1 chunks ...
[09:29:46.255]  - Number of values collected after concatenation: 3
[09:29:46.255]  - Number of values expected: 3
[09:29:46.255] Reducing values from 1 chunks ... DONE
[09:29:46.255] future_lapply() ... DONE
- exceptions ...
[09:29:46.255] future_lapply() ...
[09:29:46.257] Number of chunks: 1
[09:29:46.257] getGlobalsAndPackagesXApply() ...
[09:29:46.257]  - future.globals: TRUE
[09:29:46.257] getGlobalsAndPackages() ...
[09:29:46.257] Searching for globals...
[09:29:46.260] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:46.261] Searching for globals ... DONE
[09:29:46.261] Resolving globals: FALSE
[09:29:46.261] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[09:29:46.262] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:46.262] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.262] - packages: [1] ‘future.apply’
[09:29:46.262] getGlobalsAndPackages() ... DONE
[09:29:46.262]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.262]  - needed namespaces: [n=1] ‘future.apply’
[09:29:46.262] Finding globals ... DONE
[09:29:46.263]  - use_args: TRUE
[09:29:46.263]  - Getting '...' globals ...
[09:29:46.263] resolve() on list ...
[09:29:46.263]  recursive: 0
[09:29:46.263]  length: 1
[09:29:46.263]  elements: ‘...’
[09:29:46.263]  length: 0 (resolved future 1)
[09:29:46.263] resolve() on list ... DONE
[09:29:46.263]    - '...' content: [n=0] 
[09:29:46.264] List of 1
[09:29:46.264]  $ ...: list()
[09:29:46.264]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.264]  - attr(*, "where")=List of 1
[09:29:46.264]   ..$ ...:<environment: 0x561d342e6810> 
[09:29:46.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.264]  - attr(*, "resolved")= logi TRUE
[09:29:46.264]  - attr(*, "total_size")= num NA
[09:29:46.266]  - Getting '...' globals ... DONE
[09:29:46.266] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:46.266] List of 8
[09:29:46.266]  $ ...future.FUN:function (x, ...)  
[09:29:46.266]  $ x_FUN        :function (x)  
[09:29:46.266]  $ times        : int 2
[09:29:46.266]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.266]  $ stop_if_not  :function (...)  
[09:29:46.266]  $ dim          : NULL
[09:29:46.266]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:46.266]  $ ...          : list()
[09:29:46.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.266]  - attr(*, "where")=List of 8
[09:29:46.266]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.266]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:46.266]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:46.266]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:46.266]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:46.266]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:46.266]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:46.266]   ..$ ...          :<environment: 0x561d342e6810> 
[09:29:46.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.266]  - attr(*, "resolved")= logi FALSE
[09:29:46.266]  - attr(*, "total_size")= num 95128
[09:29:46.272] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:46.272] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.272] Number of futures (= number of chunks): 1
[09:29:46.272] Launching 1 futures (chunks) ...
[09:29:46.272] Chunk #1 of 1 ...
[09:29:46.273]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.273] getGlobalsAndPackages() ...
[09:29:46.273] Searching for globals...
[09:29:46.273] 
[09:29:46.273] Searching for globals ... DONE
[09:29:46.273] - globals: [0] <none>
[09:29:46.273] getGlobalsAndPackages() ... DONE
[09:29:46.273]    + additional globals found: [n=0] 
[09:29:46.274]    + additional namespaces needed: [n=0] 
[09:29:46.274]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.274]  - seeds: <none>
[09:29:46.274]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.274] getGlobalsAndPackages() ...
[09:29:46.274] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.274] Resolving globals: FALSE
[09:29:46.274] Tweak future expression to call with '...' arguments ...
[09:29:46.274] {
[09:29:46.274]     do.call(function(...) {
[09:29:46.274]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.274]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.274]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.274]             on.exit(options(oopts), add = TRUE)
[09:29:46.274]         }
[09:29:46.274]         {
[09:29:46.274]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.274]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.274]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.274]             })
[09:29:46.274]         }
[09:29:46.274]     }, args = future.call.arguments)
[09:29:46.274] }
[09:29:46.275] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.275] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.275] - packages: [1] ‘future.apply’
[09:29:46.275] getGlobalsAndPackages() ... DONE
[09:29:46.275] run() for ‘Future’ ...
[09:29:46.276] - state: ‘created’
[09:29:46.276] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:29:46.276] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.276] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:29:46.276]   - Field: ‘label’
[09:29:46.276]   - Field: ‘local’
[09:29:46.276]   - Field: ‘owner’
[09:29:46.276]   - Field: ‘envir’
[09:29:46.277]   - Field: ‘packages’
[09:29:46.277]   - Field: ‘gc’
[09:29:46.277]   - Field: ‘conditions’
[09:29:46.277]   - Field: ‘expr’
[09:29:46.277]   - Field: ‘uuid’
[09:29:46.277]   - Field: ‘seed’
[09:29:46.277]   - Field: ‘version’
[09:29:46.277]   - Field: ‘result’
[09:29:46.277]   - Field: ‘asynchronous’
[09:29:46.277]   - Field: ‘calls’
[09:29:46.277]   - Field: ‘globals’
[09:29:46.277]   - Field: ‘stdout’
[09:29:46.278]   - Field: ‘earlySignal’
[09:29:46.278]   - Field: ‘lazy’
[09:29:46.278]   - Field: ‘state’
[09:29:46.278] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:29:46.278] - Launch lazy future ...
[09:29:46.278] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.278] Packages needed by future strategies (n = 0): <none>
[09:29:46.279] {
[09:29:46.279]     {
[09:29:46.279]         {
[09:29:46.279]             ...future.startTime <- base::Sys.time()
[09:29:46.279]             {
[09:29:46.279]                 {
[09:29:46.279]                   {
[09:29:46.279]                     {
[09:29:46.279]                       base::local({
[09:29:46.279]                         has_future <- base::requireNamespace("future", 
[09:29:46.279]                           quietly = TRUE)
[09:29:46.279]                         if (has_future) {
[09:29:46.279]                           ns <- base::getNamespace("future")
[09:29:46.279]                           version <- ns[[".package"]][["version"]]
[09:29:46.279]                           if (is.null(version)) 
[09:29:46.279]                             version <- utils::packageVersion("future")
[09:29:46.279]                         }
[09:29:46.279]                         else {
[09:29:46.279]                           version <- NULL
[09:29:46.279]                         }
[09:29:46.279]                         if (!has_future || version < "1.8.0") {
[09:29:46.279]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.279]                             "", base::R.version$version.string), 
[09:29:46.279]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:46.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:46.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.279]                               "release", "version")], collapse = " "), 
[09:29:46.279]                             hostname = base::Sys.info()[["nodename"]])
[09:29:46.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.279]                             info)
[09:29:46.279]                           info <- base::paste(info, collapse = "; ")
[09:29:46.279]                           if (!has_future) {
[09:29:46.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.279]                               info)
[09:29:46.279]                           }
[09:29:46.279]                           else {
[09:29:46.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.279]                               info, version)
[09:29:46.279]                           }
[09:29:46.279]                           base::stop(msg)
[09:29:46.279]                         }
[09:29:46.279]                       })
[09:29:46.279]                     }
[09:29:46.279]                     base::local({
[09:29:46.279]                       for (pkg in "future.apply") {
[09:29:46.279]                         base::loadNamespace(pkg)
[09:29:46.279]                         base::library(pkg, character.only = TRUE)
[09:29:46.279]                       }
[09:29:46.279]                     })
[09:29:46.279]                   }
[09:29:46.279]                   ...future.strategy.old <- future::plan("list")
[09:29:46.279]                   options(future.plan = NULL)
[09:29:46.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.279]                 }
[09:29:46.279]                 ...future.workdir <- getwd()
[09:29:46.279]             }
[09:29:46.279]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.279]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.279]         }
[09:29:46.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.279]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:46.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.279]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.279]             base::names(...future.oldOptions))
[09:29:46.279]     }
[09:29:46.279]     if (FALSE) {
[09:29:46.279]     }
[09:29:46.279]     else {
[09:29:46.279]         if (TRUE) {
[09:29:46.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.279]                 open = "w")
[09:29:46.279]         }
[09:29:46.279]         else {
[09:29:46.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.279]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.279]         }
[09:29:46.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.279]             base::sink(type = "output", split = FALSE)
[09:29:46.279]             base::close(...future.stdout)
[09:29:46.279]         }, add = TRUE)
[09:29:46.279]     }
[09:29:46.279]     ...future.frame <- base::sys.nframe()
[09:29:46.279]     ...future.conditions <- base::list()
[09:29:46.279]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.279]     if (FALSE) {
[09:29:46.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.279]     }
[09:29:46.279]     ...future.result <- base::tryCatch({
[09:29:46.279]         base::withCallingHandlers({
[09:29:46.279]             ...future.value <- base::withVisible(base::local({
[09:29:46.279]                 do.call(function(...) {
[09:29:46.279]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.279]                   if (!identical(...future.globals.maxSize.org, 
[09:29:46.279]                     ...future.globals.maxSize)) {
[09:29:46.279]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.279]                     on.exit(options(oopts), add = TRUE)
[09:29:46.279]                   }
[09:29:46.279]                   {
[09:29:46.279]                     lapply(seq_along(...future.elements_ii), 
[09:29:46.279]                       FUN = function(jj) {
[09:29:46.279]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.279]                         ...future.FUN(...future.X_jj, ...)
[09:29:46.279]                       })
[09:29:46.279]                   }
[09:29:46.279]                 }, args = future.call.arguments)
[09:29:46.279]             }))
[09:29:46.279]             future::FutureResult(value = ...future.value$value, 
[09:29:46.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.279]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.279]                     ...future.globalenv.names))
[09:29:46.279]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.279]         }, condition = base::local({
[09:29:46.279]             c <- base::c
[09:29:46.279]             inherits <- base::inherits
[09:29:46.279]             invokeRestart <- base::invokeRestart
[09:29:46.279]             length <- base::length
[09:29:46.279]             list <- base::list
[09:29:46.279]             seq.int <- base::seq.int
[09:29:46.279]             signalCondition <- base::signalCondition
[09:29:46.279]             sys.calls <- base::sys.calls
[09:29:46.279]             `[[` <- base::`[[`
[09:29:46.279]             `+` <- base::`+`
[09:29:46.279]             `<<-` <- base::`<<-`
[09:29:46.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.279]                   3L)]
[09:29:46.279]             }
[09:29:46.279]             function(cond) {
[09:29:46.279]                 is_error <- inherits(cond, "error")
[09:29:46.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.279]                   NULL)
[09:29:46.279]                 if (is_error) {
[09:29:46.279]                   sessionInformation <- function() {
[09:29:46.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.279]                       search = base::search(), system = base::Sys.info())
[09:29:46.279]                   }
[09:29:46.279]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.279]                     cond$call), session = sessionInformation(), 
[09:29:46.279]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.279]                   signalCondition(cond)
[09:29:46.279]                 }
[09:29:46.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.279]                 "immediateCondition"))) {
[09:29:46.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.279]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.279]                   if (TRUE && !signal) {
[09:29:46.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.279]                     {
[09:29:46.279]                       inherits <- base::inherits
[09:29:46.279]                       invokeRestart <- base::invokeRestart
[09:29:46.279]                       is.null <- base::is.null
[09:29:46.279]                       muffled <- FALSE
[09:29:46.279]                       if (inherits(cond, "message")) {
[09:29:46.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.279]                         if (muffled) 
[09:29:46.279]                           invokeRestart("muffleMessage")
[09:29:46.279]                       }
[09:29:46.279]                       else if (inherits(cond, "warning")) {
[09:29:46.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.279]                         if (muffled) 
[09:29:46.279]                           invokeRestart("muffleWarning")
[09:29:46.279]                       }
[09:29:46.279]                       else if (inherits(cond, "condition")) {
[09:29:46.279]                         if (!is.null(pattern)) {
[09:29:46.279]                           computeRestarts <- base::computeRestarts
[09:29:46.279]                           grepl <- base::grepl
[09:29:46.279]                           restarts <- computeRestarts(cond)
[09:29:46.279]                           for (restart in restarts) {
[09:29:46.279]                             name <- restart$name
[09:29:46.279]                             if (is.null(name)) 
[09:29:46.279]                               next
[09:29:46.279]                             if (!grepl(pattern, name)) 
[09:29:46.279]                               next
[09:29:46.279]                             invokeRestart(restart)
[09:29:46.279]                             muffled <- TRUE
[09:29:46.279]                             break
[09:29:46.279]                           }
[09:29:46.279]                         }
[09:29:46.279]                       }
[09:29:46.279]                       invisible(muffled)
[09:29:46.279]                     }
[09:29:46.279]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.279]                   }
[09:29:46.279]                 }
[09:29:46.279]                 else {
[09:29:46.279]                   if (TRUE) {
[09:29:46.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.279]                     {
[09:29:46.279]                       inherits <- base::inherits
[09:29:46.279]                       invokeRestart <- base::invokeRestart
[09:29:46.279]                       is.null <- base::is.null
[09:29:46.279]                       muffled <- FALSE
[09:29:46.279]                       if (inherits(cond, "message")) {
[09:29:46.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.279]                         if (muffled) 
[09:29:46.279]                           invokeRestart("muffleMessage")
[09:29:46.279]                       }
[09:29:46.279]                       else if (inherits(cond, "warning")) {
[09:29:46.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.279]                         if (muffled) 
[09:29:46.279]                           invokeRestart("muffleWarning")
[09:29:46.279]                       }
[09:29:46.279]                       else if (inherits(cond, "condition")) {
[09:29:46.279]                         if (!is.null(pattern)) {
[09:29:46.279]                           computeRestarts <- base::computeRestarts
[09:29:46.279]                           grepl <- base::grepl
[09:29:46.279]                           restarts <- computeRestarts(cond)
[09:29:46.279]                           for (restart in restarts) {
[09:29:46.279]                             name <- restart$name
[09:29:46.279]                             if (is.null(name)) 
[09:29:46.279]                               next
[09:29:46.279]                             if (!grepl(pattern, name)) 
[09:29:46.279]                               next
[09:29:46.279]                             invokeRestart(restart)
[09:29:46.279]                             muffled <- TRUE
[09:29:46.279]                             break
[09:29:46.279]                           }
[09:29:46.279]                         }
[09:29:46.279]                       }
[09:29:46.279]                       invisible(muffled)
[09:29:46.279]                     }
[09:29:46.279]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.279]                   }
[09:29:46.279]                 }
[09:29:46.279]             }
[09:29:46.279]         }))
[09:29:46.279]     }, error = function(ex) {
[09:29:46.279]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.279]                 ...future.rng), started = ...future.startTime, 
[09:29:46.279]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.279]             version = "1.8"), class = "FutureResult")
[09:29:46.279]     }, finally = {
[09:29:46.279]         if (!identical(...future.workdir, getwd())) 
[09:29:46.279]             setwd(...future.workdir)
[09:29:46.279]         {
[09:29:46.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.279]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.279]             }
[09:29:46.279]             base::options(...future.oldOptions)
[09:29:46.279]             if (.Platform$OS.type == "windows") {
[09:29:46.279]                 old_names <- names(...future.oldEnvVars)
[09:29:46.279]                 envs <- base::Sys.getenv()
[09:29:46.279]                 names <- names(envs)
[09:29:46.279]                 common <- intersect(names, old_names)
[09:29:46.279]                 added <- setdiff(names, old_names)
[09:29:46.279]                 removed <- setdiff(old_names, names)
[09:29:46.279]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.279]                   envs[common]]
[09:29:46.279]                 NAMES <- toupper(changed)
[09:29:46.279]                 args <- list()
[09:29:46.279]                 for (kk in seq_along(NAMES)) {
[09:29:46.279]                   name <- changed[[kk]]
[09:29:46.279]                   NAME <- NAMES[[kk]]
[09:29:46.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.279]                     next
[09:29:46.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.279]                 }
[09:29:46.279]                 NAMES <- toupper(added)
[09:29:46.279]                 for (kk in seq_along(NAMES)) {
[09:29:46.279]                   name <- added[[kk]]
[09:29:46.279]                   NAME <- NAMES[[kk]]
[09:29:46.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.279]                     next
[09:29:46.279]                   args[[name]] <- ""
[09:29:46.279]                 }
[09:29:46.279]                 NAMES <- toupper(removed)
[09:29:46.279]                 for (kk in seq_along(NAMES)) {
[09:29:46.279]                   name <- removed[[kk]]
[09:29:46.279]                   NAME <- NAMES[[kk]]
[09:29:46.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.279]                     next
[09:29:46.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.279]                 }
[09:29:46.279]                 if (length(args) > 0) 
[09:29:46.279]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.279]             }
[09:29:46.279]             else {
[09:29:46.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.279]             }
[09:29:46.279]             {
[09:29:46.279]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.279]                   0L) {
[09:29:46.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.279]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.279]                   base::options(opts)
[09:29:46.279]                 }
[09:29:46.279]                 {
[09:29:46.279]                   {
[09:29:46.279]                     NULL
[09:29:46.279]                     RNGkind("Mersenne-Twister")
[09:29:46.279]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:29:46.279]                       inherits = FALSE)
[09:29:46.279]                   }
[09:29:46.279]                   options(future.plan = NULL)
[09:29:46.279]                   if (is.na(NA_character_)) 
[09:29:46.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.279]                     .init = FALSE)
[09:29:46.279]                 }
[09:29:46.279]             }
[09:29:46.279]         }
[09:29:46.279]     })
[09:29:46.279]     if (TRUE) {
[09:29:46.279]         base::sink(type = "output", split = FALSE)
[09:29:46.279]         if (TRUE) {
[09:29:46.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.279]         }
[09:29:46.279]         else {
[09:29:46.279]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.279]         }
[09:29:46.279]         base::close(...future.stdout)
[09:29:46.279]         ...future.stdout <- NULL
[09:29:46.279]     }
[09:29:46.279]     ...future.result$conditions <- ...future.conditions
[09:29:46.279]     ...future.result$finished <- base::Sys.time()
[09:29:46.279]     ...future.result
[09:29:46.279] }
[09:29:46.280] assign_globals() ...
[09:29:46.280] List of 11
[09:29:46.280]  $ ...future.FUN            :function (x, ...)  
[09:29:46.280]  $ x_FUN                    :function (x)  
[09:29:46.280]  $ times                    : int 2
[09:29:46.280]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.280]  $ stop_if_not              :function (...)  
[09:29:46.280]  $ dim                      : NULL
[09:29:46.280]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:46.280]  $ future.call.arguments    : list()
[09:29:46.280]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.280]  $ ...future.elements_ii    :List of 3
[09:29:46.280]   ..$ : int 1
[09:29:46.280]   ..$ : int 2
[09:29:46.280]   ..$ : int 3
[09:29:46.280]  $ ...future.seeds_ii       : NULL
[09:29:46.280]  $ ...future.globals.maxSize: NULL
[09:29:46.280]  - attr(*, "where")=List of 11
[09:29:46.280]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.280]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.280]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.280]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.280]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.280]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.280]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.280]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.280]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.280]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.280]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.280]  - attr(*, "resolved")= logi FALSE
[09:29:46.280]  - attr(*, "total_size")= num 95128
[09:29:46.280]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.280]  - attr(*, "already-done")= logi TRUE
[09:29:46.287] - copied ‘...future.FUN’ to environment
[09:29:46.288] - copied ‘x_FUN’ to environment
[09:29:46.288] - copied ‘times’ to environment
[09:29:46.288] - copied ‘stopf’ to environment
[09:29:46.288] - copied ‘stop_if_not’ to environment
[09:29:46.288] - copied ‘dim’ to environment
[09:29:46.288] - copied ‘valid_types’ to environment
[09:29:46.288] - copied ‘future.call.arguments’ to environment
[09:29:46.288] - copied ‘...future.elements_ii’ to environment
[09:29:46.288] - copied ‘...future.seeds_ii’ to environment
[09:29:46.288] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.288] assign_globals() ... done
[09:29:46.289] plan(): Setting new future strategy stack:
[09:29:46.289] List of future strategies:
[09:29:46.289] 1. sequential:
[09:29:46.289]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.289]    - tweaked: FALSE
[09:29:46.289]    - call: NULL
[09:29:46.289] plan(): nbrOfWorkers() = 1
[09:29:46.290] plan(): Setting new future strategy stack:
[09:29:46.290] List of future strategies:
[09:29:46.290] 1. sequential:
[09:29:46.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.290]    - tweaked: FALSE
[09:29:46.290]    - call: plan(strategy)
[09:29:46.291] plan(): nbrOfWorkers() = 1
[09:29:46.291] SequentialFuture started (and completed)
[09:29:46.291] signalConditions() ...
[09:29:46.291]  - include = ‘immediateCondition’
[09:29:46.291]  - exclude = 
[09:29:46.291]  - resignal = FALSE
[09:29:46.291]  - Number of conditions: 1
[09:29:46.291] signalConditions() ... done
[09:29:46.291] - Launch lazy future ... done
[09:29:46.292] run() for ‘SequentialFuture’ ... done
[09:29:46.292] Created future:
[09:29:46.292] SequentialFuture:
[09:29:46.292] Label: ‘future_vapply-1’
[09:29:46.292] Expression:
[09:29:46.292] {
[09:29:46.292]     do.call(function(...) {
[09:29:46.292]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.292]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.292]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.292]             on.exit(options(oopts), add = TRUE)
[09:29:46.292]         }
[09:29:46.292]         {
[09:29:46.292]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.292]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.292]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.292]             })
[09:29:46.292]         }
[09:29:46.292]     }, args = future.call.arguments)
[09:29:46.292] }
[09:29:46.292] Lazy evaluation: FALSE
[09:29:46.292] Asynchronous evaluation: FALSE
[09:29:46.292] Local evaluation: TRUE
[09:29:46.292] Environment: R_GlobalEnv
[09:29:46.292] Capture standard output: TRUE
[09:29:46.292] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.292] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.292] Packages: 1 packages (‘future.apply’)
[09:29:46.292] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.292] Resolved: TRUE
[09:29:46.292] Value: 0 bytes of class ‘NULL’
[09:29:46.292] Conditions captured: [n=1] ‘simpleError’
[09:29:46.292] Early signaling: FALSE
[09:29:46.292] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.292] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:29:46.294] Chunk #1 of 1 ... DONE
[09:29:46.294] Launching 1 futures (chunks) ... DONE
[09:29:46.294] Resolving 1 futures (chunks) ...
[09:29:46.294] resolve() on list ...
[09:29:46.294]  recursive: 0
[09:29:46.294]  length: 1
[09:29:46.295] 
[09:29:46.295] resolved() for ‘SequentialFuture’ ...
[09:29:46.295] - state: ‘finished’
[09:29:46.295] - run: TRUE
[09:29:46.295] - result: ‘FutureResult’
[09:29:46.295] resolved() for ‘SequentialFuture’ ... done
[09:29:46.295] Future #1
[09:29:46.295] signalConditions() ...
[09:29:46.295]  - include = ‘immediateCondition’
[09:29:46.295]  - exclude = 
[09:29:46.296]  - resignal = FALSE
[09:29:46.296]  - Number of conditions: 1
[09:29:46.296] signalConditions() ... done
[09:29:46.296] signalConditionsASAP(SequentialFuture, pos=1) ...
[09:29:46.296] - nx: 1
[09:29:46.296] - relay: TRUE
[09:29:46.296] - stdout: TRUE
[09:29:46.296] - signal: TRUE
[09:29:46.296] - resignal: FALSE
[09:29:46.296] - force: TRUE
[09:29:46.296] - relayed: [n=1] FALSE
[09:29:46.296] - queued futures: [n=1] FALSE
[09:29:46.297]  - until=1
[09:29:46.297]  - relaying element #1
[09:29:46.297] signalConditions() ...
[09:29:46.297]  - include = ‘immediateCondition’
[09:29:46.297]  - exclude = 
[09:29:46.297]  - resignal = FALSE
[09:29:46.297]  - Number of conditions: 1
[09:29:46.297] signalConditions() ... done
[09:29:46.297] signalConditions() ...
[09:29:46.297]  - include = ‘immediateCondition’
[09:29:46.297]  - exclude = 
[09:29:46.298]  - resignal = FALSE
[09:29:46.298]  - Number of conditions: 1
[09:29:46.298] signalConditions() ... done
[09:29:46.298] signalConditions() ...
[09:29:46.298]  - include = ‘condition’
[09:29:46.298]  - exclude = ‘immediateCondition’
[09:29:46.298]  - resignal = TRUE
[09:29:46.298]  - Number of conditions: 1
[09:29:46.298]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[09:29:46.298] signalConditions() ... done
[09:29:46.298] - relayed: [n=1] FALSE
[09:29:46.298] - queued futures: [n=1] TRUE
[09:29:46.299] signalConditionsASAP(SequentialFuture, pos=1) ... done
[09:29:46.299] plan(): Setting new future strategy stack:
[09:29:46.299] List of future strategies:
[09:29:46.299] 1. sequential:
[09:29:46.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.299]    - tweaked: FALSE
[09:29:46.299]    - call: plan(sequential)
[09:29:46.299] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[09:29:46.300] plan(): Setting new future strategy stack:
[09:29:46.300] List of future strategies:
[09:29:46.300] 1. multicore:
[09:29:46.300]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.300]    - tweaked: FALSE
[09:29:46.300]    - call: plan(strategy)
[09:29:46.303] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[09:29:46.305] future_lapply() ...
[09:29:46.310] Number of chunks: 2
[09:29:46.311] getGlobalsAndPackagesXApply() ...
[09:29:46.311]  - future.globals: TRUE
[09:29:46.311] getGlobalsAndPackages() ...
[09:29:46.311] Searching for globals...
[09:29:46.313] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:46.314] Searching for globals ... DONE
[09:29:46.314] Resolving globals: FALSE
[09:29:46.314] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[09:29:46.315] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:46.315] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.315] - packages: [1] ‘future.apply’
[09:29:46.315] getGlobalsAndPackages() ... DONE
[09:29:46.315]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.315]  - needed namespaces: [n=1] ‘future.apply’
[09:29:46.315] Finding globals ... DONE
[09:29:46.316]  - use_args: TRUE
[09:29:46.316]  - Getting '...' globals ...
[09:29:46.316] resolve() on list ...
[09:29:46.316]  recursive: 0
[09:29:46.316]  length: 1
[09:29:46.316]  elements: ‘...’
[09:29:46.316]  length: 0 (resolved future 1)
[09:29:46.316] resolve() on list ... DONE
[09:29:46.317]    - '...' content: [n=0] 
[09:29:46.317] List of 1
[09:29:46.317]  $ ...: list()
[09:29:46.317]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.317]  - attr(*, "where")=List of 1
[09:29:46.317]   ..$ ...:<environment: 0x561d35de2070> 
[09:29:46.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.317]  - attr(*, "resolved")= logi TRUE
[09:29:46.317]  - attr(*, "total_size")= num NA
[09:29:46.320]  - Getting '...' globals ... DONE
[09:29:46.321] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:46.321] List of 8
[09:29:46.321]  $ ...future.FUN:function (x, ...)  
[09:29:46.321]  $ x_FUN        :function (x)  
[09:29:46.321]  $ times        : int 1
[09:29:46.321]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.321]  $ stop_if_not  :function (...)  
[09:29:46.321]  $ dim          : NULL
[09:29:46.321]  $ valid_types  : chr "character"
[09:29:46.321]  $ ...          : list()
[09:29:46.321]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.321]  - attr(*, "where")=List of 8
[09:29:46.321]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.321]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:46.321]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:46.321]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:46.321]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:46.321]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:46.321]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:46.321]   ..$ ...          :<environment: 0x561d35de2070> 
[09:29:46.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.321]  - attr(*, "resolved")= logi FALSE
[09:29:46.321]  - attr(*, "total_size")= num 94208
[09:29:46.326] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:46.326] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.326] Number of futures (= number of chunks): 2
[09:29:46.326] Launching 2 futures (chunks) ...
[09:29:46.326] Chunk #1 of 2 ...
[09:29:46.326]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.326] getGlobalsAndPackages() ...
[09:29:46.326] Searching for globals...
[09:29:46.327] 
[09:29:46.327] Searching for globals ... DONE
[09:29:46.327] - globals: [0] <none>
[09:29:46.327] getGlobalsAndPackages() ... DONE
[09:29:46.327]    + additional globals found: [n=0] 
[09:29:46.327]    + additional namespaces needed: [n=0] 
[09:29:46.327]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.327]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.327]  - seeds: <none>
[09:29:46.327]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.328] getGlobalsAndPackages() ...
[09:29:46.328] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.328] Resolving globals: FALSE
[09:29:46.328] Tweak future expression to call with '...' arguments ...
[09:29:46.328] {
[09:29:46.328]     do.call(function(...) {
[09:29:46.328]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.328]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.328]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.328]             on.exit(options(oopts), add = TRUE)
[09:29:46.328]         }
[09:29:46.328]         {
[09:29:46.328]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.328]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.328]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.328]             })
[09:29:46.328]         }
[09:29:46.328]     }, args = future.call.arguments)
[09:29:46.328] }
[09:29:46.328] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.329] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.329] - packages: [1] ‘future.apply’
[09:29:46.329] getGlobalsAndPackages() ... DONE
[09:29:46.329] run() for ‘Future’ ...
[09:29:46.329] - state: ‘created’
[09:29:46.329] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:46.333] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:46.333]   - Field: ‘label’
[09:29:46.333]   - Field: ‘local’
[09:29:46.333]   - Field: ‘owner’
[09:29:46.333]   - Field: ‘envir’
[09:29:46.333]   - Field: ‘workers’
[09:29:46.333]   - Field: ‘packages’
[09:29:46.334]   - Field: ‘gc’
[09:29:46.334]   - Field: ‘job’
[09:29:46.334]   - Field: ‘conditions’
[09:29:46.334]   - Field: ‘expr’
[09:29:46.334]   - Field: ‘uuid’
[09:29:46.334]   - Field: ‘seed’
[09:29:46.334]   - Field: ‘version’
[09:29:46.334]   - Field: ‘result’
[09:29:46.334]   - Field: ‘asynchronous’
[09:29:46.334]   - Field: ‘calls’
[09:29:46.334]   - Field: ‘globals’
[09:29:46.334]   - Field: ‘stdout’
[09:29:46.335]   - Field: ‘earlySignal’
[09:29:46.335]   - Field: ‘lazy’
[09:29:46.335]   - Field: ‘state’
[09:29:46.335] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:46.335] - Launch lazy future ...
[09:29:46.336] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.336] Packages needed by future strategies (n = 0): <none>
[09:29:46.336] {
[09:29:46.336]     {
[09:29:46.336]         {
[09:29:46.336]             ...future.startTime <- base::Sys.time()
[09:29:46.336]             {
[09:29:46.336]                 {
[09:29:46.336]                   {
[09:29:46.336]                     {
[09:29:46.336]                       {
[09:29:46.336]                         base::local({
[09:29:46.336]                           has_future <- base::requireNamespace("future", 
[09:29:46.336]                             quietly = TRUE)
[09:29:46.336]                           if (has_future) {
[09:29:46.336]                             ns <- base::getNamespace("future")
[09:29:46.336]                             version <- ns[[".package"]][["version"]]
[09:29:46.336]                             if (is.null(version)) 
[09:29:46.336]                               version <- utils::packageVersion("future")
[09:29:46.336]                           }
[09:29:46.336]                           else {
[09:29:46.336]                             version <- NULL
[09:29:46.336]                           }
[09:29:46.336]                           if (!has_future || version < "1.8.0") {
[09:29:46.336]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.336]                               "", base::R.version$version.string), 
[09:29:46.336]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:46.336]                                 base::R.version$platform, 8 * 
[09:29:46.336]                                   base::.Machine$sizeof.pointer), 
[09:29:46.336]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.336]                                 "release", "version")], collapse = " "), 
[09:29:46.336]                               hostname = base::Sys.info()[["nodename"]])
[09:29:46.336]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.336]                               info)
[09:29:46.336]                             info <- base::paste(info, collapse = "; ")
[09:29:46.336]                             if (!has_future) {
[09:29:46.336]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.336]                                 info)
[09:29:46.336]                             }
[09:29:46.336]                             else {
[09:29:46.336]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.336]                                 info, version)
[09:29:46.336]                             }
[09:29:46.336]                             base::stop(msg)
[09:29:46.336]                           }
[09:29:46.336]                         })
[09:29:46.336]                       }
[09:29:46.336]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:46.336]                       base::options(mc.cores = 1L)
[09:29:46.336]                     }
[09:29:46.336]                     base::local({
[09:29:46.336]                       for (pkg in "future.apply") {
[09:29:46.336]                         base::loadNamespace(pkg)
[09:29:46.336]                         base::library(pkg, character.only = TRUE)
[09:29:46.336]                       }
[09:29:46.336]                     })
[09:29:46.336]                   }
[09:29:46.336]                   ...future.strategy.old <- future::plan("list")
[09:29:46.336]                   options(future.plan = NULL)
[09:29:46.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.336]                 }
[09:29:46.336]                 ...future.workdir <- getwd()
[09:29:46.336]             }
[09:29:46.336]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.336]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.336]         }
[09:29:46.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.336]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:46.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.336]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.336]             base::names(...future.oldOptions))
[09:29:46.336]     }
[09:29:46.336]     if (FALSE) {
[09:29:46.336]     }
[09:29:46.336]     else {
[09:29:46.336]         if (TRUE) {
[09:29:46.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.336]                 open = "w")
[09:29:46.336]         }
[09:29:46.336]         else {
[09:29:46.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.336]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.336]         }
[09:29:46.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.336]             base::sink(type = "output", split = FALSE)
[09:29:46.336]             base::close(...future.stdout)
[09:29:46.336]         }, add = TRUE)
[09:29:46.336]     }
[09:29:46.336]     ...future.frame <- base::sys.nframe()
[09:29:46.336]     ...future.conditions <- base::list()
[09:29:46.336]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.336]     if (FALSE) {
[09:29:46.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.336]     }
[09:29:46.336]     ...future.result <- base::tryCatch({
[09:29:46.336]         base::withCallingHandlers({
[09:29:46.336]             ...future.value <- base::withVisible(base::local({
[09:29:46.336]                 withCallingHandlers({
[09:29:46.336]                   {
[09:29:46.336]                     do.call(function(...) {
[09:29:46.336]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.336]                       if (!identical(...future.globals.maxSize.org, 
[09:29:46.336]                         ...future.globals.maxSize)) {
[09:29:46.336]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.336]                         on.exit(options(oopts), add = TRUE)
[09:29:46.336]                       }
[09:29:46.336]                       {
[09:29:46.336]                         lapply(seq_along(...future.elements_ii), 
[09:29:46.336]                           FUN = function(jj) {
[09:29:46.336]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.336]                             ...future.FUN(...future.X_jj, ...)
[09:29:46.336]                           })
[09:29:46.336]                       }
[09:29:46.336]                     }, args = future.call.arguments)
[09:29:46.336]                   }
[09:29:46.336]                 }, immediateCondition = function(cond) {
[09:29:46.336]                   save_rds <- function (object, pathname, ...) 
[09:29:46.336]                   {
[09:29:46.336]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:46.336]                     if (file_test("-f", pathname_tmp)) {
[09:29:46.336]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.336]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:46.336]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.336]                         fi_tmp[["mtime"]])
[09:29:46.336]                     }
[09:29:46.336]                     tryCatch({
[09:29:46.336]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:46.336]                     }, error = function(ex) {
[09:29:46.336]                       msg <- conditionMessage(ex)
[09:29:46.336]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.336]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:46.336]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.336]                         fi_tmp[["mtime"]], msg)
[09:29:46.336]                       ex$message <- msg
[09:29:46.336]                       stop(ex)
[09:29:46.336]                     })
[09:29:46.336]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:46.336]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:46.336]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:46.336]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.336]                       fi <- file.info(pathname)
[09:29:46.336]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:46.336]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.336]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:46.336]                         fi[["size"]], fi[["mtime"]])
[09:29:46.336]                       stop(msg)
[09:29:46.336]                     }
[09:29:46.336]                     invisible(pathname)
[09:29:46.336]                   }
[09:29:46.336]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:46.336]                     rootPath = tempdir()) 
[09:29:46.336]                   {
[09:29:46.336]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:46.336]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:46.336]                       tmpdir = path, fileext = ".rds")
[09:29:46.336]                     save_rds(obj, file)
[09:29:46.336]                   }
[09:29:46.336]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:46.336]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.336]                   {
[09:29:46.336]                     inherits <- base::inherits
[09:29:46.336]                     invokeRestart <- base::invokeRestart
[09:29:46.336]                     is.null <- base::is.null
[09:29:46.336]                     muffled <- FALSE
[09:29:46.336]                     if (inherits(cond, "message")) {
[09:29:46.336]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:46.336]                       if (muffled) 
[09:29:46.336]                         invokeRestart("muffleMessage")
[09:29:46.336]                     }
[09:29:46.336]                     else if (inherits(cond, "warning")) {
[09:29:46.336]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:46.336]                       if (muffled) 
[09:29:46.336]                         invokeRestart("muffleWarning")
[09:29:46.336]                     }
[09:29:46.336]                     else if (inherits(cond, "condition")) {
[09:29:46.336]                       if (!is.null(pattern)) {
[09:29:46.336]                         computeRestarts <- base::computeRestarts
[09:29:46.336]                         grepl <- base::grepl
[09:29:46.336]                         restarts <- computeRestarts(cond)
[09:29:46.336]                         for (restart in restarts) {
[09:29:46.336]                           name <- restart$name
[09:29:46.336]                           if (is.null(name)) 
[09:29:46.336]                             next
[09:29:46.336]                           if (!grepl(pattern, name)) 
[09:29:46.336]                             next
[09:29:46.336]                           invokeRestart(restart)
[09:29:46.336]                           muffled <- TRUE
[09:29:46.336]                           break
[09:29:46.336]                         }
[09:29:46.336]                       }
[09:29:46.336]                     }
[09:29:46.336]                     invisible(muffled)
[09:29:46.336]                   }
[09:29:46.336]                   muffleCondition(cond)
[09:29:46.336]                 })
[09:29:46.336]             }))
[09:29:46.336]             future::FutureResult(value = ...future.value$value, 
[09:29:46.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.336]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.336]                     ...future.globalenv.names))
[09:29:46.336]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.336]         }, condition = base::local({
[09:29:46.336]             c <- base::c
[09:29:46.336]             inherits <- base::inherits
[09:29:46.336]             invokeRestart <- base::invokeRestart
[09:29:46.336]             length <- base::length
[09:29:46.336]             list <- base::list
[09:29:46.336]             seq.int <- base::seq.int
[09:29:46.336]             signalCondition <- base::signalCondition
[09:29:46.336]             sys.calls <- base::sys.calls
[09:29:46.336]             `[[` <- base::`[[`
[09:29:46.336]             `+` <- base::`+`
[09:29:46.336]             `<<-` <- base::`<<-`
[09:29:46.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.336]                   3L)]
[09:29:46.336]             }
[09:29:46.336]             function(cond) {
[09:29:46.336]                 is_error <- inherits(cond, "error")
[09:29:46.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.336]                   NULL)
[09:29:46.336]                 if (is_error) {
[09:29:46.336]                   sessionInformation <- function() {
[09:29:46.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.336]                       search = base::search(), system = base::Sys.info())
[09:29:46.336]                   }
[09:29:46.336]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.336]                     cond$call), session = sessionInformation(), 
[09:29:46.336]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.336]                   signalCondition(cond)
[09:29:46.336]                 }
[09:29:46.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.336]                 "immediateCondition"))) {
[09:29:46.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.336]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.336]                   if (TRUE && !signal) {
[09:29:46.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.336]                     {
[09:29:46.336]                       inherits <- base::inherits
[09:29:46.336]                       invokeRestart <- base::invokeRestart
[09:29:46.336]                       is.null <- base::is.null
[09:29:46.336]                       muffled <- FALSE
[09:29:46.336]                       if (inherits(cond, "message")) {
[09:29:46.336]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.336]                         if (muffled) 
[09:29:46.336]                           invokeRestart("muffleMessage")
[09:29:46.336]                       }
[09:29:46.336]                       else if (inherits(cond, "warning")) {
[09:29:46.336]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.336]                         if (muffled) 
[09:29:46.336]                           invokeRestart("muffleWarning")
[09:29:46.336]                       }
[09:29:46.336]                       else if (inherits(cond, "condition")) {
[09:29:46.336]                         if (!is.null(pattern)) {
[09:29:46.336]                           computeRestarts <- base::computeRestarts
[09:29:46.336]                           grepl <- base::grepl
[09:29:46.336]                           restarts <- computeRestarts(cond)
[09:29:46.336]                           for (restart in restarts) {
[09:29:46.336]                             name <- restart$name
[09:29:46.336]                             if (is.null(name)) 
[09:29:46.336]                               next
[09:29:46.336]                             if (!grepl(pattern, name)) 
[09:29:46.336]                               next
[09:29:46.336]                             invokeRestart(restart)
[09:29:46.336]                             muffled <- TRUE
[09:29:46.336]                             break
[09:29:46.336]                           }
[09:29:46.336]                         }
[09:29:46.336]                       }
[09:29:46.336]                       invisible(muffled)
[09:29:46.336]                     }
[09:29:46.336]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.336]                   }
[09:29:46.336]                 }
[09:29:46.336]                 else {
[09:29:46.336]                   if (TRUE) {
[09:29:46.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.336]                     {
[09:29:46.336]                       inherits <- base::inherits
[09:29:46.336]                       invokeRestart <- base::invokeRestart
[09:29:46.336]                       is.null <- base::is.null
[09:29:46.336]                       muffled <- FALSE
[09:29:46.336]                       if (inherits(cond, "message")) {
[09:29:46.336]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.336]                         if (muffled) 
[09:29:46.336]                           invokeRestart("muffleMessage")
[09:29:46.336]                       }
[09:29:46.336]                       else if (inherits(cond, "warning")) {
[09:29:46.336]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.336]                         if (muffled) 
[09:29:46.336]                           invokeRestart("muffleWarning")
[09:29:46.336]                       }
[09:29:46.336]                       else if (inherits(cond, "condition")) {
[09:29:46.336]                         if (!is.null(pattern)) {
[09:29:46.336]                           computeRestarts <- base::computeRestarts
[09:29:46.336]                           grepl <- base::grepl
[09:29:46.336]                           restarts <- computeRestarts(cond)
[09:29:46.336]                           for (restart in restarts) {
[09:29:46.336]                             name <- restart$name
[09:29:46.336]                             if (is.null(name)) 
[09:29:46.336]                               next
[09:29:46.336]                             if (!grepl(pattern, name)) 
[09:29:46.336]                               next
[09:29:46.336]                             invokeRestart(restart)
[09:29:46.336]                             muffled <- TRUE
[09:29:46.336]                             break
[09:29:46.336]                           }
[09:29:46.336]                         }
[09:29:46.336]                       }
[09:29:46.336]                       invisible(muffled)
[09:29:46.336]                     }
[09:29:46.336]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.336]                   }
[09:29:46.336]                 }
[09:29:46.336]             }
[09:29:46.336]         }))
[09:29:46.336]     }, error = function(ex) {
[09:29:46.336]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.336]                 ...future.rng), started = ...future.startTime, 
[09:29:46.336]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.336]             version = "1.8"), class = "FutureResult")
[09:29:46.336]     }, finally = {
[09:29:46.336]         if (!identical(...future.workdir, getwd())) 
[09:29:46.336]             setwd(...future.workdir)
[09:29:46.336]         {
[09:29:46.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.336]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.336]             }
[09:29:46.336]             base::options(...future.oldOptions)
[09:29:46.336]             if (.Platform$OS.type == "windows") {
[09:29:46.336]                 old_names <- names(...future.oldEnvVars)
[09:29:46.336]                 envs <- base::Sys.getenv()
[09:29:46.336]                 names <- names(envs)
[09:29:46.336]                 common <- intersect(names, old_names)
[09:29:46.336]                 added <- setdiff(names, old_names)
[09:29:46.336]                 removed <- setdiff(old_names, names)
[09:29:46.336]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.336]                   envs[common]]
[09:29:46.336]                 NAMES <- toupper(changed)
[09:29:46.336]                 args <- list()
[09:29:46.336]                 for (kk in seq_along(NAMES)) {
[09:29:46.336]                   name <- changed[[kk]]
[09:29:46.336]                   NAME <- NAMES[[kk]]
[09:29:46.336]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.336]                     next
[09:29:46.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.336]                 }
[09:29:46.336]                 NAMES <- toupper(added)
[09:29:46.336]                 for (kk in seq_along(NAMES)) {
[09:29:46.336]                   name <- added[[kk]]
[09:29:46.336]                   NAME <- NAMES[[kk]]
[09:29:46.336]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.336]                     next
[09:29:46.336]                   args[[name]] <- ""
[09:29:46.336]                 }
[09:29:46.336]                 NAMES <- toupper(removed)
[09:29:46.336]                 for (kk in seq_along(NAMES)) {
[09:29:46.336]                   name <- removed[[kk]]
[09:29:46.336]                   NAME <- NAMES[[kk]]
[09:29:46.336]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.336]                     next
[09:29:46.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.336]                 }
[09:29:46.336]                 if (length(args) > 0) 
[09:29:46.336]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.336]             }
[09:29:46.336]             else {
[09:29:46.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.336]             }
[09:29:46.336]             {
[09:29:46.336]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.336]                   0L) {
[09:29:46.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.336]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.336]                   base::options(opts)
[09:29:46.336]                 }
[09:29:46.336]                 {
[09:29:46.336]                   {
[09:29:46.336]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:46.336]                     NULL
[09:29:46.336]                   }
[09:29:46.336]                   options(future.plan = NULL)
[09:29:46.336]                   if (is.na(NA_character_)) 
[09:29:46.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.336]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.336]                     .init = FALSE)
[09:29:46.336]                 }
[09:29:46.336]             }
[09:29:46.336]         }
[09:29:46.336]     })
[09:29:46.336]     if (TRUE) {
[09:29:46.336]         base::sink(type = "output", split = FALSE)
[09:29:46.336]         if (TRUE) {
[09:29:46.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.336]         }
[09:29:46.336]         else {
[09:29:46.336]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.336]         }
[09:29:46.336]         base::close(...future.stdout)
[09:29:46.336]         ...future.stdout <- NULL
[09:29:46.336]     }
[09:29:46.336]     ...future.result$conditions <- ...future.conditions
[09:29:46.336]     ...future.result$finished <- base::Sys.time()
[09:29:46.336]     ...future.result
[09:29:46.336] }
[09:29:46.339] assign_globals() ...
[09:29:46.339] List of 11
[09:29:46.339]  $ ...future.FUN            :function (x, ...)  
[09:29:46.339]  $ x_FUN                    :function (x)  
[09:29:46.339]  $ times                    : int 1
[09:29:46.339]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.339]  $ stop_if_not              :function (...)  
[09:29:46.339]  $ dim                      : NULL
[09:29:46.339]  $ valid_types              : chr "character"
[09:29:46.339]  $ future.call.arguments    : list()
[09:29:46.339]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.339]  $ ...future.elements_ii    :List of 1
[09:29:46.339]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:29:46.339]  $ ...future.seeds_ii       : NULL
[09:29:46.339]  $ ...future.globals.maxSize: NULL
[09:29:46.339]  - attr(*, "where")=List of 11
[09:29:46.339]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.339]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.339]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.339]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.339]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.339]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.339]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.339]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.339]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.339]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.339]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.339]  - attr(*, "resolved")= logi FALSE
[09:29:46.339]  - attr(*, "total_size")= num 94208
[09:29:46.339]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.339]  - attr(*, "already-done")= logi TRUE
[09:29:46.347] - copied ‘...future.FUN’ to environment
[09:29:46.347] - copied ‘x_FUN’ to environment
[09:29:46.347] - copied ‘times’ to environment
[09:29:46.347] - copied ‘stopf’ to environment
[09:29:46.347] - copied ‘stop_if_not’ to environment
[09:29:46.347] - copied ‘dim’ to environment
[09:29:46.347] - copied ‘valid_types’ to environment
[09:29:46.348] - copied ‘future.call.arguments’ to environment
[09:29:46.348] - copied ‘...future.elements_ii’ to environment
[09:29:46.348] - copied ‘...future.seeds_ii’ to environment
[09:29:46.348] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.348] assign_globals() ... done
[09:29:46.348] requestCore(): workers = 2
[09:29:46.351] MulticoreFuture started
[09:29:46.352] - Launch lazy future ... done
[09:29:46.352] run() for ‘MulticoreFuture’ ... done
[09:29:46.352] Created future:
[09:29:46.352] plan(): Setting new future strategy stack:
[09:29:46.353] List of future strategies:
[09:29:46.353] 1. sequential:
[09:29:46.353]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.353]    - tweaked: FALSE
[09:29:46.353]    - call: NULL
[09:29:46.354] plan(): nbrOfWorkers() = 1
[09:29:46.356] plan(): Setting new future strategy stack:
[09:29:46.356] List of future strategies:
[09:29:46.356] 1. multicore:
[09:29:46.356]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.356]    - tweaked: FALSE
[09:29:46.356]    - call: plan(strategy)
[09:29:46.360] plan(): nbrOfWorkers() = 2
[09:29:46.353] MulticoreFuture:
[09:29:46.353] Label: ‘future_vapply-1’
[09:29:46.353] Expression:
[09:29:46.353] {
[09:29:46.353]     do.call(function(...) {
[09:29:46.353]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.353]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.353]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.353]             on.exit(options(oopts), add = TRUE)
[09:29:46.353]         }
[09:29:46.353]         {
[09:29:46.353]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.353]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.353]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.353]             })
[09:29:46.353]         }
[09:29:46.353]     }, args = future.call.arguments)
[09:29:46.353] }
[09:29:46.353] Lazy evaluation: FALSE
[09:29:46.353] Asynchronous evaluation: TRUE
[09:29:46.353] Local evaluation: TRUE
[09:29:46.353] Environment: R_GlobalEnv
[09:29:46.353] Capture standard output: TRUE
[09:29:46.353] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.353] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.353] Packages: 1 packages (‘future.apply’)
[09:29:46.353] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.353] Resolved: TRUE
[09:29:46.353] Value: <not collected>
[09:29:46.353] Conditions captured: <none>
[09:29:46.353] Early signaling: FALSE
[09:29:46.353] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.353] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.362] Chunk #1 of 2 ... DONE
[09:29:46.362] Chunk #2 of 2 ...
[09:29:46.362]  - Finding globals in 'X' for chunk #2 ...
[09:29:46.362] getGlobalsAndPackages() ...
[09:29:46.362] Searching for globals...
[09:29:46.363] 
[09:29:46.363] Searching for globals ... DONE
[09:29:46.363] - globals: [0] <none>
[09:29:46.363] getGlobalsAndPackages() ... DONE
[09:29:46.363]    + additional globals found: [n=0] 
[09:29:46.363]    + additional namespaces needed: [n=0] 
[09:29:46.364]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:46.364]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.364]  - seeds: <none>
[09:29:46.364]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.364] getGlobalsAndPackages() ...
[09:29:46.364] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.365] Resolving globals: FALSE
[09:29:46.365] Tweak future expression to call with '...' arguments ...
[09:29:46.365] {
[09:29:46.365]     do.call(function(...) {
[09:29:46.365]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.365]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.365]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.365]             on.exit(options(oopts), add = TRUE)
[09:29:46.365]         }
[09:29:46.365]         {
[09:29:46.365]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.365]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.365]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.365]             })
[09:29:46.365]         }
[09:29:46.365]     }, args = future.call.arguments)
[09:29:46.365] }
[09:29:46.365] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.366] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.366] - packages: [1] ‘future.apply’
[09:29:46.367] getGlobalsAndPackages() ... DONE
[09:29:46.367] run() for ‘Future’ ...
[09:29:46.367] - state: ‘created’
[09:29:46.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:46.372] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:46.372]   - Field: ‘label’
[09:29:46.372]   - Field: ‘local’
[09:29:46.372]   - Field: ‘owner’
[09:29:46.373]   - Field: ‘envir’
[09:29:46.373]   - Field: ‘workers’
[09:29:46.373]   - Field: ‘packages’
[09:29:46.373]   - Field: ‘gc’
[09:29:46.373]   - Field: ‘job’
[09:29:46.373]   - Field: ‘conditions’
[09:29:46.373]   - Field: ‘expr’
[09:29:46.373]   - Field: ‘uuid’
[09:29:46.374]   - Field: ‘seed’
[09:29:46.374]   - Field: ‘version’
[09:29:46.374]   - Field: ‘result’
[09:29:46.374]   - Field: ‘asynchronous’
[09:29:46.374]   - Field: ‘calls’
[09:29:46.374]   - Field: ‘globals’
[09:29:46.374]   - Field: ‘stdout’
[09:29:46.375]   - Field: ‘earlySignal’
[09:29:46.375]   - Field: ‘lazy’
[09:29:46.375]   - Field: ‘state’
[09:29:46.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:46.375] - Launch lazy future ...
[09:29:46.375] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.376] Packages needed by future strategies (n = 0): <none>
[09:29:46.377] {
[09:29:46.377]     {
[09:29:46.377]         {
[09:29:46.377]             ...future.startTime <- base::Sys.time()
[09:29:46.377]             {
[09:29:46.377]                 {
[09:29:46.377]                   {
[09:29:46.377]                     {
[09:29:46.377]                       {
[09:29:46.377]                         base::local({
[09:29:46.377]                           has_future <- base::requireNamespace("future", 
[09:29:46.377]                             quietly = TRUE)
[09:29:46.377]                           if (has_future) {
[09:29:46.377]                             ns <- base::getNamespace("future")
[09:29:46.377]                             version <- ns[[".package"]][["version"]]
[09:29:46.377]                             if (is.null(version)) 
[09:29:46.377]                               version <- utils::packageVersion("future")
[09:29:46.377]                           }
[09:29:46.377]                           else {
[09:29:46.377]                             version <- NULL
[09:29:46.377]                           }
[09:29:46.377]                           if (!has_future || version < "1.8.0") {
[09:29:46.377]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.377]                               "", base::R.version$version.string), 
[09:29:46.377]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:46.377]                                 base::R.version$platform, 8 * 
[09:29:46.377]                                   base::.Machine$sizeof.pointer), 
[09:29:46.377]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.377]                                 "release", "version")], collapse = " "), 
[09:29:46.377]                               hostname = base::Sys.info()[["nodename"]])
[09:29:46.377]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.377]                               info)
[09:29:46.377]                             info <- base::paste(info, collapse = "; ")
[09:29:46.377]                             if (!has_future) {
[09:29:46.377]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.377]                                 info)
[09:29:46.377]                             }
[09:29:46.377]                             else {
[09:29:46.377]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.377]                                 info, version)
[09:29:46.377]                             }
[09:29:46.377]                             base::stop(msg)
[09:29:46.377]                           }
[09:29:46.377]                         })
[09:29:46.377]                       }
[09:29:46.377]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:46.377]                       base::options(mc.cores = 1L)
[09:29:46.377]                     }
[09:29:46.377]                     base::local({
[09:29:46.377]                       for (pkg in "future.apply") {
[09:29:46.377]                         base::loadNamespace(pkg)
[09:29:46.377]                         base::library(pkg, character.only = TRUE)
[09:29:46.377]                       }
[09:29:46.377]                     })
[09:29:46.377]                   }
[09:29:46.377]                   ...future.strategy.old <- future::plan("list")
[09:29:46.377]                   options(future.plan = NULL)
[09:29:46.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.377]                 }
[09:29:46.377]                 ...future.workdir <- getwd()
[09:29:46.377]             }
[09:29:46.377]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.377]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.377]         }
[09:29:46.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.377]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:46.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.377]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.377]             base::names(...future.oldOptions))
[09:29:46.377]     }
[09:29:46.377]     if (FALSE) {
[09:29:46.377]     }
[09:29:46.377]     else {
[09:29:46.377]         if (TRUE) {
[09:29:46.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.377]                 open = "w")
[09:29:46.377]         }
[09:29:46.377]         else {
[09:29:46.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.377]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.377]         }
[09:29:46.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.377]             base::sink(type = "output", split = FALSE)
[09:29:46.377]             base::close(...future.stdout)
[09:29:46.377]         }, add = TRUE)
[09:29:46.377]     }
[09:29:46.377]     ...future.frame <- base::sys.nframe()
[09:29:46.377]     ...future.conditions <- base::list()
[09:29:46.377]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.377]     if (FALSE) {
[09:29:46.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.377]     }
[09:29:46.377]     ...future.result <- base::tryCatch({
[09:29:46.377]         base::withCallingHandlers({
[09:29:46.377]             ...future.value <- base::withVisible(base::local({
[09:29:46.377]                 withCallingHandlers({
[09:29:46.377]                   {
[09:29:46.377]                     do.call(function(...) {
[09:29:46.377]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.377]                       if (!identical(...future.globals.maxSize.org, 
[09:29:46.377]                         ...future.globals.maxSize)) {
[09:29:46.377]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.377]                         on.exit(options(oopts), add = TRUE)
[09:29:46.377]                       }
[09:29:46.377]                       {
[09:29:46.377]                         lapply(seq_along(...future.elements_ii), 
[09:29:46.377]                           FUN = function(jj) {
[09:29:46.377]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.377]                             ...future.FUN(...future.X_jj, ...)
[09:29:46.377]                           })
[09:29:46.377]                       }
[09:29:46.377]                     }, args = future.call.arguments)
[09:29:46.377]                   }
[09:29:46.377]                 }, immediateCondition = function(cond) {
[09:29:46.377]                   save_rds <- function (object, pathname, ...) 
[09:29:46.377]                   {
[09:29:46.377]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:46.377]                     if (file_test("-f", pathname_tmp)) {
[09:29:46.377]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.377]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:46.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.377]                         fi_tmp[["mtime"]])
[09:29:46.377]                     }
[09:29:46.377]                     tryCatch({
[09:29:46.377]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:46.377]                     }, error = function(ex) {
[09:29:46.377]                       msg <- conditionMessage(ex)
[09:29:46.377]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.377]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:46.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.377]                         fi_tmp[["mtime"]], msg)
[09:29:46.377]                       ex$message <- msg
[09:29:46.377]                       stop(ex)
[09:29:46.377]                     })
[09:29:46.377]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:46.377]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:46.377]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:46.377]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.377]                       fi <- file.info(pathname)
[09:29:46.377]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:46.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.377]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:46.377]                         fi[["size"]], fi[["mtime"]])
[09:29:46.377]                       stop(msg)
[09:29:46.377]                     }
[09:29:46.377]                     invisible(pathname)
[09:29:46.377]                   }
[09:29:46.377]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:46.377]                     rootPath = tempdir()) 
[09:29:46.377]                   {
[09:29:46.377]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:46.377]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:46.377]                       tmpdir = path, fileext = ".rds")
[09:29:46.377]                     save_rds(obj, file)
[09:29:46.377]                   }
[09:29:46.377]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:46.377]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.377]                   {
[09:29:46.377]                     inherits <- base::inherits
[09:29:46.377]                     invokeRestart <- base::invokeRestart
[09:29:46.377]                     is.null <- base::is.null
[09:29:46.377]                     muffled <- FALSE
[09:29:46.377]                     if (inherits(cond, "message")) {
[09:29:46.377]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:46.377]                       if (muffled) 
[09:29:46.377]                         invokeRestart("muffleMessage")
[09:29:46.377]                     }
[09:29:46.377]                     else if (inherits(cond, "warning")) {
[09:29:46.377]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:46.377]                       if (muffled) 
[09:29:46.377]                         invokeRestart("muffleWarning")
[09:29:46.377]                     }
[09:29:46.377]                     else if (inherits(cond, "condition")) {
[09:29:46.377]                       if (!is.null(pattern)) {
[09:29:46.377]                         computeRestarts <- base::computeRestarts
[09:29:46.377]                         grepl <- base::grepl
[09:29:46.377]                         restarts <- computeRestarts(cond)
[09:29:46.377]                         for (restart in restarts) {
[09:29:46.377]                           name <- restart$name
[09:29:46.377]                           if (is.null(name)) 
[09:29:46.377]                             next
[09:29:46.377]                           if (!grepl(pattern, name)) 
[09:29:46.377]                             next
[09:29:46.377]                           invokeRestart(restart)
[09:29:46.377]                           muffled <- TRUE
[09:29:46.377]                           break
[09:29:46.377]                         }
[09:29:46.377]                       }
[09:29:46.377]                     }
[09:29:46.377]                     invisible(muffled)
[09:29:46.377]                   }
[09:29:46.377]                   muffleCondition(cond)
[09:29:46.377]                 })
[09:29:46.377]             }))
[09:29:46.377]             future::FutureResult(value = ...future.value$value, 
[09:29:46.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.377]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.377]                     ...future.globalenv.names))
[09:29:46.377]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.377]         }, condition = base::local({
[09:29:46.377]             c <- base::c
[09:29:46.377]             inherits <- base::inherits
[09:29:46.377]             invokeRestart <- base::invokeRestart
[09:29:46.377]             length <- base::length
[09:29:46.377]             list <- base::list
[09:29:46.377]             seq.int <- base::seq.int
[09:29:46.377]             signalCondition <- base::signalCondition
[09:29:46.377]             sys.calls <- base::sys.calls
[09:29:46.377]             `[[` <- base::`[[`
[09:29:46.377]             `+` <- base::`+`
[09:29:46.377]             `<<-` <- base::`<<-`
[09:29:46.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.377]                   3L)]
[09:29:46.377]             }
[09:29:46.377]             function(cond) {
[09:29:46.377]                 is_error <- inherits(cond, "error")
[09:29:46.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.377]                   NULL)
[09:29:46.377]                 if (is_error) {
[09:29:46.377]                   sessionInformation <- function() {
[09:29:46.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.377]                       search = base::search(), system = base::Sys.info())
[09:29:46.377]                   }
[09:29:46.377]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.377]                     cond$call), session = sessionInformation(), 
[09:29:46.377]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.377]                   signalCondition(cond)
[09:29:46.377]                 }
[09:29:46.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.377]                 "immediateCondition"))) {
[09:29:46.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.377]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.377]                   if (TRUE && !signal) {
[09:29:46.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.377]                     {
[09:29:46.377]                       inherits <- base::inherits
[09:29:46.377]                       invokeRestart <- base::invokeRestart
[09:29:46.377]                       is.null <- base::is.null
[09:29:46.377]                       muffled <- FALSE
[09:29:46.377]                       if (inherits(cond, "message")) {
[09:29:46.377]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.377]                         if (muffled) 
[09:29:46.377]                           invokeRestart("muffleMessage")
[09:29:46.377]                       }
[09:29:46.377]                       else if (inherits(cond, "warning")) {
[09:29:46.377]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.377]                         if (muffled) 
[09:29:46.377]                           invokeRestart("muffleWarning")
[09:29:46.377]                       }
[09:29:46.377]                       else if (inherits(cond, "condition")) {
[09:29:46.377]                         if (!is.null(pattern)) {
[09:29:46.377]                           computeRestarts <- base::computeRestarts
[09:29:46.377]                           grepl <- base::grepl
[09:29:46.377]                           restarts <- computeRestarts(cond)
[09:29:46.377]                           for (restart in restarts) {
[09:29:46.377]                             name <- restart$name
[09:29:46.377]                             if (is.null(name)) 
[09:29:46.377]                               next
[09:29:46.377]                             if (!grepl(pattern, name)) 
[09:29:46.377]                               next
[09:29:46.377]                             invokeRestart(restart)
[09:29:46.377]                             muffled <- TRUE
[09:29:46.377]                             break
[09:29:46.377]                           }
[09:29:46.377]                         }
[09:29:46.377]                       }
[09:29:46.377]                       invisible(muffled)
[09:29:46.377]                     }
[09:29:46.377]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.377]                   }
[09:29:46.377]                 }
[09:29:46.377]                 else {
[09:29:46.377]                   if (TRUE) {
[09:29:46.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.377]                     {
[09:29:46.377]                       inherits <- base::inherits
[09:29:46.377]                       invokeRestart <- base::invokeRestart
[09:29:46.377]                       is.null <- base::is.null
[09:29:46.377]                       muffled <- FALSE
[09:29:46.377]                       if (inherits(cond, "message")) {
[09:29:46.377]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.377]                         if (muffled) 
[09:29:46.377]                           invokeRestart("muffleMessage")
[09:29:46.377]                       }
[09:29:46.377]                       else if (inherits(cond, "warning")) {
[09:29:46.377]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.377]                         if (muffled) 
[09:29:46.377]                           invokeRestart("muffleWarning")
[09:29:46.377]                       }
[09:29:46.377]                       else if (inherits(cond, "condition")) {
[09:29:46.377]                         if (!is.null(pattern)) {
[09:29:46.377]                           computeRestarts <- base::computeRestarts
[09:29:46.377]                           grepl <- base::grepl
[09:29:46.377]                           restarts <- computeRestarts(cond)
[09:29:46.377]                           for (restart in restarts) {
[09:29:46.377]                             name <- restart$name
[09:29:46.377]                             if (is.null(name)) 
[09:29:46.377]                               next
[09:29:46.377]                             if (!grepl(pattern, name)) 
[09:29:46.377]                               next
[09:29:46.377]                             invokeRestart(restart)
[09:29:46.377]                             muffled <- TRUE
[09:29:46.377]                             break
[09:29:46.377]                           }
[09:29:46.377]                         }
[09:29:46.377]                       }
[09:29:46.377]                       invisible(muffled)
[09:29:46.377]                     }
[09:29:46.377]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.377]                   }
[09:29:46.377]                 }
[09:29:46.377]             }
[09:29:46.377]         }))
[09:29:46.377]     }, error = function(ex) {
[09:29:46.377]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.377]                 ...future.rng), started = ...future.startTime, 
[09:29:46.377]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.377]             version = "1.8"), class = "FutureResult")
[09:29:46.377]     }, finally = {
[09:29:46.377]         if (!identical(...future.workdir, getwd())) 
[09:29:46.377]             setwd(...future.workdir)
[09:29:46.377]         {
[09:29:46.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.377]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.377]             }
[09:29:46.377]             base::options(...future.oldOptions)
[09:29:46.377]             if (.Platform$OS.type == "windows") {
[09:29:46.377]                 old_names <- names(...future.oldEnvVars)
[09:29:46.377]                 envs <- base::Sys.getenv()
[09:29:46.377]                 names <- names(envs)
[09:29:46.377]                 common <- intersect(names, old_names)
[09:29:46.377]                 added <- setdiff(names, old_names)
[09:29:46.377]                 removed <- setdiff(old_names, names)
[09:29:46.377]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.377]                   envs[common]]
[09:29:46.377]                 NAMES <- toupper(changed)
[09:29:46.377]                 args <- list()
[09:29:46.377]                 for (kk in seq_along(NAMES)) {
[09:29:46.377]                   name <- changed[[kk]]
[09:29:46.377]                   NAME <- NAMES[[kk]]
[09:29:46.377]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.377]                     next
[09:29:46.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.377]                 }
[09:29:46.377]                 NAMES <- toupper(added)
[09:29:46.377]                 for (kk in seq_along(NAMES)) {
[09:29:46.377]                   name <- added[[kk]]
[09:29:46.377]                   NAME <- NAMES[[kk]]
[09:29:46.377]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.377]                     next
[09:29:46.377]                   args[[name]] <- ""
[09:29:46.377]                 }
[09:29:46.377]                 NAMES <- toupper(removed)
[09:29:46.377]                 for (kk in seq_along(NAMES)) {
[09:29:46.377]                   name <- removed[[kk]]
[09:29:46.377]                   NAME <- NAMES[[kk]]
[09:29:46.377]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.377]                     next
[09:29:46.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.377]                 }
[09:29:46.377]                 if (length(args) > 0) 
[09:29:46.377]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.377]             }
[09:29:46.377]             else {
[09:29:46.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.377]             }
[09:29:46.377]             {
[09:29:46.377]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.377]                   0L) {
[09:29:46.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.377]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.377]                   base::options(opts)
[09:29:46.377]                 }
[09:29:46.377]                 {
[09:29:46.377]                   {
[09:29:46.377]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:46.377]                     NULL
[09:29:46.377]                   }
[09:29:46.377]                   options(future.plan = NULL)
[09:29:46.377]                   if (is.na(NA_character_)) 
[09:29:46.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.377]                     .init = FALSE)
[09:29:46.377]                 }
[09:29:46.377]             }
[09:29:46.377]         }
[09:29:46.377]     })
[09:29:46.377]     if (TRUE) {
[09:29:46.377]         base::sink(type = "output", split = FALSE)
[09:29:46.377]         if (TRUE) {
[09:29:46.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.377]         }
[09:29:46.377]         else {
[09:29:46.377]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.377]         }
[09:29:46.377]         base::close(...future.stdout)
[09:29:46.377]         ...future.stdout <- NULL
[09:29:46.377]     }
[09:29:46.377]     ...future.result$conditions <- ...future.conditions
[09:29:46.377]     ...future.result$finished <- base::Sys.time()
[09:29:46.377]     ...future.result
[09:29:46.377] }
[09:29:46.380] assign_globals() ...
[09:29:46.380] List of 11
[09:29:46.380]  $ ...future.FUN            :function (x, ...)  
[09:29:46.380]  $ x_FUN                    :function (x)  
[09:29:46.380]  $ times                    : int 1
[09:29:46.380]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.380]  $ stop_if_not              :function (...)  
[09:29:46.380]  $ dim                      : NULL
[09:29:46.380]  $ valid_types              : chr "character"
[09:29:46.380]  $ future.call.arguments    : list()
[09:29:46.380]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.380]  $ ...future.elements_ii    :List of 1
[09:29:46.380]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[09:29:46.380]  $ ...future.seeds_ii       : NULL
[09:29:46.380]  $ ...future.globals.maxSize: NULL
[09:29:46.380]  - attr(*, "where")=List of 11
[09:29:46.380]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.380]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.380]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.380]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.380]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.380]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.380]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.380]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.380]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.380]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.380]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.380]  - attr(*, "resolved")= logi FALSE
[09:29:46.380]  - attr(*, "total_size")= num 94208
[09:29:46.380]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.380]  - attr(*, "already-done")= logi TRUE
[09:29:46.394] - copied ‘...future.FUN’ to environment
[09:29:46.394] - copied ‘x_FUN’ to environment
[09:29:46.394] - copied ‘times’ to environment
[09:29:46.394] - copied ‘stopf’ to environment
[09:29:46.395] - copied ‘stop_if_not’ to environment
[09:29:46.395] - copied ‘dim’ to environment
[09:29:46.395] - copied ‘valid_types’ to environment
[09:29:46.395] - copied ‘future.call.arguments’ to environment
[09:29:46.395] - copied ‘...future.elements_ii’ to environment
[09:29:46.395] - copied ‘...future.seeds_ii’ to environment
[09:29:46.395] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.396] assign_globals() ... done
[09:29:46.396] requestCore(): workers = 2
[09:29:46.401] MulticoreFuture started
[09:29:46.401] - Launch lazy future ... done
[09:29:46.401] run() for ‘MulticoreFuture’ ... done
[09:29:46.402] Created future:
[09:29:46.402] plan(): Setting new future strategy stack:
[09:29:46.402] List of future strategies:
[09:29:46.402] 1. sequential:
[09:29:46.402]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.402]    - tweaked: FALSE
[09:29:46.402]    - call: NULL
[09:29:46.403] plan(): nbrOfWorkers() = 1
[09:29:46.405] plan(): Setting new future strategy stack:
[09:29:46.405] List of future strategies:
[09:29:46.405] 1. multicore:
[09:29:46.405]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.405]    - tweaked: FALSE
[09:29:46.405]    - call: plan(strategy)
[09:29:46.411] plan(): nbrOfWorkers() = 2
[09:29:46.402] MulticoreFuture:
[09:29:46.402] Label: ‘future_vapply-2’
[09:29:46.402] Expression:
[09:29:46.402] {
[09:29:46.402]     do.call(function(...) {
[09:29:46.402]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.402]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.402]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.402]             on.exit(options(oopts), add = TRUE)
[09:29:46.402]         }
[09:29:46.402]         {
[09:29:46.402]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.402]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.402]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.402]             })
[09:29:46.402]         }
[09:29:46.402]     }, args = future.call.arguments)
[09:29:46.402] }
[09:29:46.402] Lazy evaluation: FALSE
[09:29:46.402] Asynchronous evaluation: TRUE
[09:29:46.402] Local evaluation: TRUE
[09:29:46.402] Environment: R_GlobalEnv
[09:29:46.402] Capture standard output: TRUE
[09:29:46.402] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.402] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.402] Packages: 1 packages (‘future.apply’)
[09:29:46.402] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.402] Resolved: TRUE
[09:29:46.402] Value: <not collected>
[09:29:46.402] Conditions captured: <none>
[09:29:46.402] Early signaling: FALSE
[09:29:46.402] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.402] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.412] Chunk #2 of 2 ... DONE
[09:29:46.412] Launching 2 futures (chunks) ... DONE
[09:29:46.412] Resolving 2 futures (chunks) ...
[09:29:46.412] resolve() on list ...
[09:29:46.412]  recursive: 0
[09:29:46.412]  length: 2
[09:29:46.413] 
[09:29:46.413] Future #1
[09:29:46.413] result() for MulticoreFuture ...
[09:29:46.415] result() for MulticoreFuture ...
[09:29:46.415] result() for MulticoreFuture ... done
[09:29:46.416] result() for MulticoreFuture ... done
[09:29:46.416] result() for MulticoreFuture ...
[09:29:46.416] result() for MulticoreFuture ... done
[09:29:46.416] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:46.416] - nx: 2
[09:29:46.417] - relay: TRUE
[09:29:46.417] - stdout: TRUE
[09:29:46.417] - signal: TRUE
[09:29:46.417] - resignal: FALSE
[09:29:46.417] - force: TRUE
[09:29:46.417] - relayed: [n=2] FALSE, FALSE
[09:29:46.418] - queued futures: [n=2] FALSE, FALSE
[09:29:46.418]  - until=1
[09:29:46.418]  - relaying element #1
[09:29:46.418] result() for MulticoreFuture ...
[09:29:46.418] result() for MulticoreFuture ... done
[09:29:46.419] result() for MulticoreFuture ...
[09:29:46.419] result() for MulticoreFuture ... done
[09:29:46.419] result() for MulticoreFuture ...
[09:29:46.419] result() for MulticoreFuture ... done
[09:29:46.419] result() for MulticoreFuture ...
[09:29:46.420] result() for MulticoreFuture ... done
[09:29:46.420] - relayed: [n=2] TRUE, FALSE
[09:29:46.420] - queued futures: [n=2] TRUE, FALSE
[09:29:46.420] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:46.420]  length: 1 (resolved future 1)
[09:29:46.421] Future #2
[09:29:46.421] result() for MulticoreFuture ...
[09:29:46.421] result() for MulticoreFuture ...
[09:29:46.421] result() for MulticoreFuture ... done
[09:29:46.422] result() for MulticoreFuture ... done
[09:29:46.422] result() for MulticoreFuture ...
[09:29:46.422] result() for MulticoreFuture ... done
[09:29:46.422] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:46.422] - nx: 2
[09:29:46.422] - relay: TRUE
[09:29:46.422] - stdout: TRUE
[09:29:46.422] - signal: TRUE
[09:29:46.423] - resignal: FALSE
[09:29:46.423] - force: TRUE
[09:29:46.423] - relayed: [n=2] TRUE, FALSE
[09:29:46.423] - queued futures: [n=2] TRUE, FALSE
[09:29:46.423]  - until=2
[09:29:46.423]  - relaying element #2
[09:29:46.423] result() for MulticoreFuture ...
[09:29:46.423] result() for MulticoreFuture ... done
[09:29:46.423] result() for MulticoreFuture ...
[09:29:46.424] result() for MulticoreFuture ... done
[09:29:46.424] result() for MulticoreFuture ...
[09:29:46.424] result() for MulticoreFuture ... done
[09:29:46.424] result() for MulticoreFuture ...
[09:29:46.424] result() for MulticoreFuture ... done
[09:29:46.424] - relayed: [n=2] TRUE, TRUE
[09:29:46.424] - queued futures: [n=2] TRUE, TRUE
[09:29:46.424] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:46.425]  length: 0 (resolved future 2)
[09:29:46.425] Relaying remaining futures
[09:29:46.425] signalConditionsASAP(NULL, pos=0) ...
[09:29:46.425] - nx: 2
[09:29:46.425] - relay: TRUE
[09:29:46.425] - stdout: TRUE
[09:29:46.425] - signal: TRUE
[09:29:46.425] - resignal: FALSE
[09:29:46.425] - force: TRUE
[09:29:46.425] - relayed: [n=2] TRUE, TRUE
[09:29:46.425] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:46.426] - relayed: [n=2] TRUE, TRUE
[09:29:46.426] - queued futures: [n=2] TRUE, TRUE
[09:29:46.426] signalConditionsASAP(NULL, pos=0) ... done
[09:29:46.426] resolve() on list ... DONE
[09:29:46.426] result() for MulticoreFuture ...
[09:29:46.426] result() for MulticoreFuture ... done
[09:29:46.426] result() for MulticoreFuture ...
[09:29:46.426] result() for MulticoreFuture ... done
[09:29:46.427] result() for MulticoreFuture ...
[09:29:46.427] result() for MulticoreFuture ... done
[09:29:46.427] result() for MulticoreFuture ...
[09:29:46.427] result() for MulticoreFuture ... done
[09:29:46.427]  - Number of value chunks collected: 2
[09:29:46.427] Resolving 2 futures (chunks) ... DONE
[09:29:46.427] Reducing values from 2 chunks ...
[09:29:46.427]  - Number of values collected after concatenation: 2
[09:29:46.427]  - Number of values expected: 2
[09:29:46.427] Reducing values from 2 chunks ... DONE
[09:29:46.428] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[09:29:46.429] future_lapply() ...
[09:29:46.440] Number of chunks: 2
[09:29:46.440] getGlobalsAndPackagesXApply() ...
[09:29:46.440]  - future.globals: TRUE
[09:29:46.440] getGlobalsAndPackages() ...
[09:29:46.440] Searching for globals...
[09:29:46.444] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[09:29:46.444] Searching for globals ... DONE
[09:29:46.445] Resolving globals: FALSE
[09:29:46.445] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[09:29:46.446] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:46.446] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.446] - packages: [1] ‘future.apply’
[09:29:46.446] getGlobalsAndPackages() ... DONE
[09:29:46.446]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.446]  - needed namespaces: [n=1] ‘future.apply’
[09:29:46.446] Finding globals ... DONE
[09:29:46.447]  - use_args: TRUE
[09:29:46.447]  - Getting '...' globals ...
[09:29:46.447] resolve() on list ...
[09:29:46.447]  recursive: 0
[09:29:46.447]  length: 1
[09:29:46.447]  elements: ‘...’
[09:29:46.447]  length: 0 (resolved future 1)
[09:29:46.447] resolve() on list ... DONE
[09:29:46.448]    - '...' content: [n=0] 
[09:29:46.448] List of 1
[09:29:46.448]  $ ...: list()
[09:29:46.448]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.448]  - attr(*, "where")=List of 1
[09:29:46.448]   ..$ ...:<environment: 0x561d36873fb8> 
[09:29:46.448]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.448]  - attr(*, "resolved")= logi TRUE
[09:29:46.448]  - attr(*, "total_size")= num NA
[09:29:46.450]  - Getting '...' globals ... DONE
[09:29:46.450] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:46.450] List of 8
[09:29:46.450]  $ ...future.FUN:function (x, ...)  
[09:29:46.450]  $ x_FUN        :function (x)  
[09:29:46.450]  $ times        : int 0
[09:29:46.450]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.450]  $ stop_if_not  :function (...)  
[09:29:46.450]  $ dim          : NULL
[09:29:46.450]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:46.450]  $ ...          : list()
[09:29:46.450]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.450]  - attr(*, "where")=List of 8
[09:29:46.450]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.450]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:46.450]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:46.450]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:46.450]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:46.450]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:46.450]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:46.450]   ..$ ...          :<environment: 0x561d36873fb8> 
[09:29:46.450]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.450]  - attr(*, "resolved")= logi FALSE
[09:29:46.450]  - attr(*, "total_size")= num 95472
[09:29:46.455] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:46.455] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.456] Number of futures (= number of chunks): 2
[09:29:46.456] Launching 2 futures (chunks) ...
[09:29:46.456] Chunk #1 of 2 ...
[09:29:46.456]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.456] getGlobalsAndPackages() ...
[09:29:46.456] Searching for globals...
[09:29:46.456] 
[09:29:46.457] Searching for globals ... DONE
[09:29:46.457] - globals: [0] <none>
[09:29:46.457] getGlobalsAndPackages() ... DONE
[09:29:46.457]    + additional globals found: [n=0] 
[09:29:46.457]    + additional namespaces needed: [n=0] 
[09:29:46.457]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.457]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.457]  - seeds: <none>
[09:29:46.457]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.457] getGlobalsAndPackages() ...
[09:29:46.457] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.458] Resolving globals: FALSE
[09:29:46.458] Tweak future expression to call with '...' arguments ...
[09:29:46.458] {
[09:29:46.458]     do.call(function(...) {
[09:29:46.458]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.458]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.458]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.458]             on.exit(options(oopts), add = TRUE)
[09:29:46.458]         }
[09:29:46.458]         {
[09:29:46.458]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.458]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.458]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.458]             })
[09:29:46.458]         }
[09:29:46.458]     }, args = future.call.arguments)
[09:29:46.458] }
[09:29:46.458] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.458] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.459] - packages: [1] ‘future.apply’
[09:29:46.460] getGlobalsAndPackages() ... DONE
[09:29:46.460] run() for ‘Future’ ...
[09:29:46.460] - state: ‘created’
[09:29:46.460] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:46.464] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.464] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:46.464]   - Field: ‘label’
[09:29:46.464]   - Field: ‘local’
[09:29:46.464]   - Field: ‘owner’
[09:29:46.464]   - Field: ‘envir’
[09:29:46.464]   - Field: ‘workers’
[09:29:46.464]   - Field: ‘packages’
[09:29:46.464]   - Field: ‘gc’
[09:29:46.465]   - Field: ‘job’
[09:29:46.465]   - Field: ‘conditions’
[09:29:46.465]   - Field: ‘expr’
[09:29:46.465]   - Field: ‘uuid’
[09:29:46.465]   - Field: ‘seed’
[09:29:46.465]   - Field: ‘version’
[09:29:46.465]   - Field: ‘result’
[09:29:46.465]   - Field: ‘asynchronous’
[09:29:46.465]   - Field: ‘calls’
[09:29:46.465]   - Field: ‘globals’
[09:29:46.465]   - Field: ‘stdout’
[09:29:46.466]   - Field: ‘earlySignal’
[09:29:46.466]   - Field: ‘lazy’
[09:29:46.466]   - Field: ‘state’
[09:29:46.466] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:46.466] - Launch lazy future ...
[09:29:46.466] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.466] Packages needed by future strategies (n = 0): <none>
[09:29:46.467] {
[09:29:46.467]     {
[09:29:46.467]         {
[09:29:46.467]             ...future.startTime <- base::Sys.time()
[09:29:46.467]             {
[09:29:46.467]                 {
[09:29:46.467]                   {
[09:29:46.467]                     {
[09:29:46.467]                       {
[09:29:46.467]                         base::local({
[09:29:46.467]                           has_future <- base::requireNamespace("future", 
[09:29:46.467]                             quietly = TRUE)
[09:29:46.467]                           if (has_future) {
[09:29:46.467]                             ns <- base::getNamespace("future")
[09:29:46.467]                             version <- ns[[".package"]][["version"]]
[09:29:46.467]                             if (is.null(version)) 
[09:29:46.467]                               version <- utils::packageVersion("future")
[09:29:46.467]                           }
[09:29:46.467]                           else {
[09:29:46.467]                             version <- NULL
[09:29:46.467]                           }
[09:29:46.467]                           if (!has_future || version < "1.8.0") {
[09:29:46.467]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.467]                               "", base::R.version$version.string), 
[09:29:46.467]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:46.467]                                 base::R.version$platform, 8 * 
[09:29:46.467]                                   base::.Machine$sizeof.pointer), 
[09:29:46.467]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.467]                                 "release", "version")], collapse = " "), 
[09:29:46.467]                               hostname = base::Sys.info()[["nodename"]])
[09:29:46.467]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.467]                               info)
[09:29:46.467]                             info <- base::paste(info, collapse = "; ")
[09:29:46.467]                             if (!has_future) {
[09:29:46.467]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.467]                                 info)
[09:29:46.467]                             }
[09:29:46.467]                             else {
[09:29:46.467]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.467]                                 info, version)
[09:29:46.467]                             }
[09:29:46.467]                             base::stop(msg)
[09:29:46.467]                           }
[09:29:46.467]                         })
[09:29:46.467]                       }
[09:29:46.467]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:46.467]                       base::options(mc.cores = 1L)
[09:29:46.467]                     }
[09:29:46.467]                     base::local({
[09:29:46.467]                       for (pkg in "future.apply") {
[09:29:46.467]                         base::loadNamespace(pkg)
[09:29:46.467]                         base::library(pkg, character.only = TRUE)
[09:29:46.467]                       }
[09:29:46.467]                     })
[09:29:46.467]                   }
[09:29:46.467]                   ...future.strategy.old <- future::plan("list")
[09:29:46.467]                   options(future.plan = NULL)
[09:29:46.467]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.467]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.467]                 }
[09:29:46.467]                 ...future.workdir <- getwd()
[09:29:46.467]             }
[09:29:46.467]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.467]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.467]         }
[09:29:46.467]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.467]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:46.467]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.467]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.467]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.467]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.467]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.467]             base::names(...future.oldOptions))
[09:29:46.467]     }
[09:29:46.467]     if (FALSE) {
[09:29:46.467]     }
[09:29:46.467]     else {
[09:29:46.467]         if (TRUE) {
[09:29:46.467]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.467]                 open = "w")
[09:29:46.467]         }
[09:29:46.467]         else {
[09:29:46.467]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.467]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.467]         }
[09:29:46.467]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.467]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.467]             base::sink(type = "output", split = FALSE)
[09:29:46.467]             base::close(...future.stdout)
[09:29:46.467]         }, add = TRUE)
[09:29:46.467]     }
[09:29:46.467]     ...future.frame <- base::sys.nframe()
[09:29:46.467]     ...future.conditions <- base::list()
[09:29:46.467]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.467]     if (FALSE) {
[09:29:46.467]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.467]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.467]     }
[09:29:46.467]     ...future.result <- base::tryCatch({
[09:29:46.467]         base::withCallingHandlers({
[09:29:46.467]             ...future.value <- base::withVisible(base::local({
[09:29:46.467]                 withCallingHandlers({
[09:29:46.467]                   {
[09:29:46.467]                     do.call(function(...) {
[09:29:46.467]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.467]                       if (!identical(...future.globals.maxSize.org, 
[09:29:46.467]                         ...future.globals.maxSize)) {
[09:29:46.467]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.467]                         on.exit(options(oopts), add = TRUE)
[09:29:46.467]                       }
[09:29:46.467]                       {
[09:29:46.467]                         lapply(seq_along(...future.elements_ii), 
[09:29:46.467]                           FUN = function(jj) {
[09:29:46.467]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.467]                             ...future.FUN(...future.X_jj, ...)
[09:29:46.467]                           })
[09:29:46.467]                       }
[09:29:46.467]                     }, args = future.call.arguments)
[09:29:46.467]                   }
[09:29:46.467]                 }, immediateCondition = function(cond) {
[09:29:46.467]                   save_rds <- function (object, pathname, ...) 
[09:29:46.467]                   {
[09:29:46.467]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:46.467]                     if (file_test("-f", pathname_tmp)) {
[09:29:46.467]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.467]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:46.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.467]                         fi_tmp[["mtime"]])
[09:29:46.467]                     }
[09:29:46.467]                     tryCatch({
[09:29:46.467]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:46.467]                     }, error = function(ex) {
[09:29:46.467]                       msg <- conditionMessage(ex)
[09:29:46.467]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.467]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:46.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.467]                         fi_tmp[["mtime"]], msg)
[09:29:46.467]                       ex$message <- msg
[09:29:46.467]                       stop(ex)
[09:29:46.467]                     })
[09:29:46.467]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:46.467]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:46.467]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:46.467]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.467]                       fi <- file.info(pathname)
[09:29:46.467]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:46.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.467]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:46.467]                         fi[["size"]], fi[["mtime"]])
[09:29:46.467]                       stop(msg)
[09:29:46.467]                     }
[09:29:46.467]                     invisible(pathname)
[09:29:46.467]                   }
[09:29:46.467]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:46.467]                     rootPath = tempdir()) 
[09:29:46.467]                   {
[09:29:46.467]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:46.467]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:46.467]                       tmpdir = path, fileext = ".rds")
[09:29:46.467]                     save_rds(obj, file)
[09:29:46.467]                   }
[09:29:46.467]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:46.467]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.467]                   {
[09:29:46.467]                     inherits <- base::inherits
[09:29:46.467]                     invokeRestart <- base::invokeRestart
[09:29:46.467]                     is.null <- base::is.null
[09:29:46.467]                     muffled <- FALSE
[09:29:46.467]                     if (inherits(cond, "message")) {
[09:29:46.467]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:46.467]                       if (muffled) 
[09:29:46.467]                         invokeRestart("muffleMessage")
[09:29:46.467]                     }
[09:29:46.467]                     else if (inherits(cond, "warning")) {
[09:29:46.467]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:46.467]                       if (muffled) 
[09:29:46.467]                         invokeRestart("muffleWarning")
[09:29:46.467]                     }
[09:29:46.467]                     else if (inherits(cond, "condition")) {
[09:29:46.467]                       if (!is.null(pattern)) {
[09:29:46.467]                         computeRestarts <- base::computeRestarts
[09:29:46.467]                         grepl <- base::grepl
[09:29:46.467]                         restarts <- computeRestarts(cond)
[09:29:46.467]                         for (restart in restarts) {
[09:29:46.467]                           name <- restart$name
[09:29:46.467]                           if (is.null(name)) 
[09:29:46.467]                             next
[09:29:46.467]                           if (!grepl(pattern, name)) 
[09:29:46.467]                             next
[09:29:46.467]                           invokeRestart(restart)
[09:29:46.467]                           muffled <- TRUE
[09:29:46.467]                           break
[09:29:46.467]                         }
[09:29:46.467]                       }
[09:29:46.467]                     }
[09:29:46.467]                     invisible(muffled)
[09:29:46.467]                   }
[09:29:46.467]                   muffleCondition(cond)
[09:29:46.467]                 })
[09:29:46.467]             }))
[09:29:46.467]             future::FutureResult(value = ...future.value$value, 
[09:29:46.467]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.467]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.467]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.467]                     ...future.globalenv.names))
[09:29:46.467]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.467]         }, condition = base::local({
[09:29:46.467]             c <- base::c
[09:29:46.467]             inherits <- base::inherits
[09:29:46.467]             invokeRestart <- base::invokeRestart
[09:29:46.467]             length <- base::length
[09:29:46.467]             list <- base::list
[09:29:46.467]             seq.int <- base::seq.int
[09:29:46.467]             signalCondition <- base::signalCondition
[09:29:46.467]             sys.calls <- base::sys.calls
[09:29:46.467]             `[[` <- base::`[[`
[09:29:46.467]             `+` <- base::`+`
[09:29:46.467]             `<<-` <- base::`<<-`
[09:29:46.467]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.467]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.467]                   3L)]
[09:29:46.467]             }
[09:29:46.467]             function(cond) {
[09:29:46.467]                 is_error <- inherits(cond, "error")
[09:29:46.467]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.467]                   NULL)
[09:29:46.467]                 if (is_error) {
[09:29:46.467]                   sessionInformation <- function() {
[09:29:46.467]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.467]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.467]                       search = base::search(), system = base::Sys.info())
[09:29:46.467]                   }
[09:29:46.467]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.467]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.467]                     cond$call), session = sessionInformation(), 
[09:29:46.467]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.467]                   signalCondition(cond)
[09:29:46.467]                 }
[09:29:46.467]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.467]                 "immediateCondition"))) {
[09:29:46.467]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.467]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.467]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.467]                   if (TRUE && !signal) {
[09:29:46.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.467]                     {
[09:29:46.467]                       inherits <- base::inherits
[09:29:46.467]                       invokeRestart <- base::invokeRestart
[09:29:46.467]                       is.null <- base::is.null
[09:29:46.467]                       muffled <- FALSE
[09:29:46.467]                       if (inherits(cond, "message")) {
[09:29:46.467]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.467]                         if (muffled) 
[09:29:46.467]                           invokeRestart("muffleMessage")
[09:29:46.467]                       }
[09:29:46.467]                       else if (inherits(cond, "warning")) {
[09:29:46.467]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.467]                         if (muffled) 
[09:29:46.467]                           invokeRestart("muffleWarning")
[09:29:46.467]                       }
[09:29:46.467]                       else if (inherits(cond, "condition")) {
[09:29:46.467]                         if (!is.null(pattern)) {
[09:29:46.467]                           computeRestarts <- base::computeRestarts
[09:29:46.467]                           grepl <- base::grepl
[09:29:46.467]                           restarts <- computeRestarts(cond)
[09:29:46.467]                           for (restart in restarts) {
[09:29:46.467]                             name <- restart$name
[09:29:46.467]                             if (is.null(name)) 
[09:29:46.467]                               next
[09:29:46.467]                             if (!grepl(pattern, name)) 
[09:29:46.467]                               next
[09:29:46.467]                             invokeRestart(restart)
[09:29:46.467]                             muffled <- TRUE
[09:29:46.467]                             break
[09:29:46.467]                           }
[09:29:46.467]                         }
[09:29:46.467]                       }
[09:29:46.467]                       invisible(muffled)
[09:29:46.467]                     }
[09:29:46.467]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.467]                   }
[09:29:46.467]                 }
[09:29:46.467]                 else {
[09:29:46.467]                   if (TRUE) {
[09:29:46.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.467]                     {
[09:29:46.467]                       inherits <- base::inherits
[09:29:46.467]                       invokeRestart <- base::invokeRestart
[09:29:46.467]                       is.null <- base::is.null
[09:29:46.467]                       muffled <- FALSE
[09:29:46.467]                       if (inherits(cond, "message")) {
[09:29:46.467]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.467]                         if (muffled) 
[09:29:46.467]                           invokeRestart("muffleMessage")
[09:29:46.467]                       }
[09:29:46.467]                       else if (inherits(cond, "warning")) {
[09:29:46.467]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.467]                         if (muffled) 
[09:29:46.467]                           invokeRestart("muffleWarning")
[09:29:46.467]                       }
[09:29:46.467]                       else if (inherits(cond, "condition")) {
[09:29:46.467]                         if (!is.null(pattern)) {
[09:29:46.467]                           computeRestarts <- base::computeRestarts
[09:29:46.467]                           grepl <- base::grepl
[09:29:46.467]                           restarts <- computeRestarts(cond)
[09:29:46.467]                           for (restart in restarts) {
[09:29:46.467]                             name <- restart$name
[09:29:46.467]                             if (is.null(name)) 
[09:29:46.467]                               next
[09:29:46.467]                             if (!grepl(pattern, name)) 
[09:29:46.467]                               next
[09:29:46.467]                             invokeRestart(restart)
[09:29:46.467]                             muffled <- TRUE
[09:29:46.467]                             break
[09:29:46.467]                           }
[09:29:46.467]                         }
[09:29:46.467]                       }
[09:29:46.467]                       invisible(muffled)
[09:29:46.467]                     }
[09:29:46.467]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.467]                   }
[09:29:46.467]                 }
[09:29:46.467]             }
[09:29:46.467]         }))
[09:29:46.467]     }, error = function(ex) {
[09:29:46.467]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.467]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.467]                 ...future.rng), started = ...future.startTime, 
[09:29:46.467]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.467]             version = "1.8"), class = "FutureResult")
[09:29:46.467]     }, finally = {
[09:29:46.467]         if (!identical(...future.workdir, getwd())) 
[09:29:46.467]             setwd(...future.workdir)
[09:29:46.467]         {
[09:29:46.467]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.467]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.467]             }
[09:29:46.467]             base::options(...future.oldOptions)
[09:29:46.467]             if (.Platform$OS.type == "windows") {
[09:29:46.467]                 old_names <- names(...future.oldEnvVars)
[09:29:46.467]                 envs <- base::Sys.getenv()
[09:29:46.467]                 names <- names(envs)
[09:29:46.467]                 common <- intersect(names, old_names)
[09:29:46.467]                 added <- setdiff(names, old_names)
[09:29:46.467]                 removed <- setdiff(old_names, names)
[09:29:46.467]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.467]                   envs[common]]
[09:29:46.467]                 NAMES <- toupper(changed)
[09:29:46.467]                 args <- list()
[09:29:46.467]                 for (kk in seq_along(NAMES)) {
[09:29:46.467]                   name <- changed[[kk]]
[09:29:46.467]                   NAME <- NAMES[[kk]]
[09:29:46.467]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.467]                     next
[09:29:46.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.467]                 }
[09:29:46.467]                 NAMES <- toupper(added)
[09:29:46.467]                 for (kk in seq_along(NAMES)) {
[09:29:46.467]                   name <- added[[kk]]
[09:29:46.467]                   NAME <- NAMES[[kk]]
[09:29:46.467]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.467]                     next
[09:29:46.467]                   args[[name]] <- ""
[09:29:46.467]                 }
[09:29:46.467]                 NAMES <- toupper(removed)
[09:29:46.467]                 for (kk in seq_along(NAMES)) {
[09:29:46.467]                   name <- removed[[kk]]
[09:29:46.467]                   NAME <- NAMES[[kk]]
[09:29:46.467]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.467]                     next
[09:29:46.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.467]                 }
[09:29:46.467]                 if (length(args) > 0) 
[09:29:46.467]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.467]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.467]             }
[09:29:46.467]             else {
[09:29:46.467]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.467]             }
[09:29:46.467]             {
[09:29:46.467]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.467]                   0L) {
[09:29:46.467]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.467]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.467]                   base::options(opts)
[09:29:46.467]                 }
[09:29:46.467]                 {
[09:29:46.467]                   {
[09:29:46.467]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:46.467]                     NULL
[09:29:46.467]                   }
[09:29:46.467]                   options(future.plan = NULL)
[09:29:46.467]                   if (is.na(NA_character_)) 
[09:29:46.467]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.467]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.467]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.467]                     .init = FALSE)
[09:29:46.467]                 }
[09:29:46.467]             }
[09:29:46.467]         }
[09:29:46.467]     })
[09:29:46.467]     if (TRUE) {
[09:29:46.467]         base::sink(type = "output", split = FALSE)
[09:29:46.467]         if (TRUE) {
[09:29:46.467]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.467]         }
[09:29:46.467]         else {
[09:29:46.467]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.467]         }
[09:29:46.467]         base::close(...future.stdout)
[09:29:46.467]         ...future.stdout <- NULL
[09:29:46.467]     }
[09:29:46.467]     ...future.result$conditions <- ...future.conditions
[09:29:46.467]     ...future.result$finished <- base::Sys.time()
[09:29:46.467]     ...future.result
[09:29:46.467] }
[09:29:46.469] assign_globals() ...
[09:29:46.469] List of 11
[09:29:46.469]  $ ...future.FUN            :function (x, ...)  
[09:29:46.469]  $ x_FUN                    :function (x)  
[09:29:46.469]  $ times                    : int 0
[09:29:46.469]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.469]  $ stop_if_not              :function (...)  
[09:29:46.469]  $ dim                      : NULL
[09:29:46.469]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:46.469]  $ future.call.arguments    : list()
[09:29:46.469]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.469]  $ ...future.elements_ii    :List of 5
[09:29:46.469]   ..$ : int 1
[09:29:46.469]   ..$ : int 2
[09:29:46.469]   ..$ : int 3
[09:29:46.469]   ..$ : int 4
[09:29:46.469]   ..$ : int 5
[09:29:46.469]  $ ...future.seeds_ii       : NULL
[09:29:46.469]  $ ...future.globals.maxSize: NULL
[09:29:46.469]  - attr(*, "where")=List of 11
[09:29:46.469]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.469]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.469]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.469]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.469]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.469]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.469]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.469]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.469]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.469]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.469]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.469]  - attr(*, "resolved")= logi FALSE
[09:29:46.469]  - attr(*, "total_size")= num 95472
[09:29:46.469]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.469]  - attr(*, "already-done")= logi TRUE
[09:29:46.477] - copied ‘...future.FUN’ to environment
[09:29:46.478] - reassign environment for ‘x_FUN’
[09:29:46.478] - copied ‘x_FUN’ to environment
[09:29:46.478] - copied ‘times’ to environment
[09:29:46.478] - copied ‘stopf’ to environment
[09:29:46.478] - copied ‘stop_if_not’ to environment
[09:29:46.478] - copied ‘dim’ to environment
[09:29:46.478] - copied ‘valid_types’ to environment
[09:29:46.478] - copied ‘future.call.arguments’ to environment
[09:29:46.478] - copied ‘...future.elements_ii’ to environment
[09:29:46.478] - copied ‘...future.seeds_ii’ to environment
[09:29:46.478] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.479] assign_globals() ... done
[09:29:46.479] requestCore(): workers = 2
[09:29:46.481] MulticoreFuture started
[09:29:46.481] - Launch lazy future ... done
[09:29:46.481] run() for ‘MulticoreFuture’ ... done
[09:29:46.481] Created future:
[09:29:46.482] plan(): Setting new future strategy stack:
[09:29:46.482] List of future strategies:
[09:29:46.482] 1. sequential:
[09:29:46.482]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.482]    - tweaked: FALSE
[09:29:46.482]    - call: NULL
[09:29:46.483] plan(): nbrOfWorkers() = 1
[09:29:46.485] plan(): Setting new future strategy stack:
[09:29:46.485] List of future strategies:
[09:29:46.485] 1. multicore:
[09:29:46.485]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.485]    - tweaked: FALSE
[09:29:46.485]    - call: plan(strategy)
[09:29:46.490] plan(): nbrOfWorkers() = 2
[09:29:46.482] MulticoreFuture:
[09:29:46.482] Label: ‘future_vapply-1’
[09:29:46.482] Expression:
[09:29:46.482] {
[09:29:46.482]     do.call(function(...) {
[09:29:46.482]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.482]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.482]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.482]             on.exit(options(oopts), add = TRUE)
[09:29:46.482]         }
[09:29:46.482]         {
[09:29:46.482]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.482]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.482]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.482]             })
[09:29:46.482]         }
[09:29:46.482]     }, args = future.call.arguments)
[09:29:46.482] }
[09:29:46.482] Lazy evaluation: FALSE
[09:29:46.482] Asynchronous evaluation: TRUE
[09:29:46.482] Local evaluation: TRUE
[09:29:46.482] Environment: R_GlobalEnv
[09:29:46.482] Capture standard output: TRUE
[09:29:46.482] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.482] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.482] Packages: 1 packages (‘future.apply’)
[09:29:46.482] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.482] Resolved: TRUE
[09:29:46.482] Value: <not collected>
[09:29:46.482] Conditions captured: <none>
[09:29:46.482] Early signaling: FALSE
[09:29:46.482] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.482] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.491] Chunk #1 of 2 ... DONE
[09:29:46.491] Chunk #2 of 2 ...
[09:29:46.492]  - Finding globals in 'X' for chunk #2 ...
[09:29:46.492] getGlobalsAndPackages() ...
[09:29:46.492] Searching for globals...
[09:29:46.492] 
[09:29:46.493] Searching for globals ... DONE
[09:29:46.493] - globals: [0] <none>
[09:29:46.493] getGlobalsAndPackages() ... DONE
[09:29:46.493]    + additional globals found: [n=0] 
[09:29:46.493]    + additional namespaces needed: [n=0] 
[09:29:46.493]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:46.493]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.493]  - seeds: <none>
[09:29:46.494]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.494] getGlobalsAndPackages() ...
[09:29:46.494] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.494] Resolving globals: FALSE
[09:29:46.494] Tweak future expression to call with '...' arguments ...
[09:29:46.494] {
[09:29:46.494]     do.call(function(...) {
[09:29:46.494]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.494]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.494]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.494]             on.exit(options(oopts), add = TRUE)
[09:29:46.494]         }
[09:29:46.494]         {
[09:29:46.494]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.494]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.494]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.494]             })
[09:29:46.494]         }
[09:29:46.494]     }, args = future.call.arguments)
[09:29:46.494] }
[09:29:46.495] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.496] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.496] - packages: [1] ‘future.apply’
[09:29:46.496] getGlobalsAndPackages() ... DONE
[09:29:46.497] run() for ‘Future’ ...
[09:29:46.497] - state: ‘created’
[09:29:46.497] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:46.506] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.506] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:46.507]   - Field: ‘label’
[09:29:46.507]   - Field: ‘local’
[09:29:46.507]   - Field: ‘owner’
[09:29:46.507]   - Field: ‘envir’
[09:29:46.508]   - Field: ‘workers’
[09:29:46.508]   - Field: ‘packages’
[09:29:46.508]   - Field: ‘gc’
[09:29:46.508]   - Field: ‘job’
[09:29:46.509]   - Field: ‘conditions’
[09:29:46.509]   - Field: ‘expr’
[09:29:46.509]   - Field: ‘uuid’
[09:29:46.509]   - Field: ‘seed’
[09:29:46.509]   - Field: ‘version’
[09:29:46.510]   - Field: ‘result’
[09:29:46.510]   - Field: ‘asynchronous’
[09:29:46.510]   - Field: ‘calls’
[09:29:46.510]   - Field: ‘globals’
[09:29:46.510]   - Field: ‘stdout’
[09:29:46.511]   - Field: ‘earlySignal’
[09:29:46.511]   - Field: ‘lazy’
[09:29:46.511]   - Field: ‘state’
[09:29:46.511] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:46.511] - Launch lazy future ...
[09:29:46.512] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.512] Packages needed by future strategies (n = 0): <none>
[09:29:46.513] {
[09:29:46.513]     {
[09:29:46.513]         {
[09:29:46.513]             ...future.startTime <- base::Sys.time()
[09:29:46.513]             {
[09:29:46.513]                 {
[09:29:46.513]                   {
[09:29:46.513]                     {
[09:29:46.513]                       {
[09:29:46.513]                         base::local({
[09:29:46.513]                           has_future <- base::requireNamespace("future", 
[09:29:46.513]                             quietly = TRUE)
[09:29:46.513]                           if (has_future) {
[09:29:46.513]                             ns <- base::getNamespace("future")
[09:29:46.513]                             version <- ns[[".package"]][["version"]]
[09:29:46.513]                             if (is.null(version)) 
[09:29:46.513]                               version <- utils::packageVersion("future")
[09:29:46.513]                           }
[09:29:46.513]                           else {
[09:29:46.513]                             version <- NULL
[09:29:46.513]                           }
[09:29:46.513]                           if (!has_future || version < "1.8.0") {
[09:29:46.513]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.513]                               "", base::R.version$version.string), 
[09:29:46.513]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:46.513]                                 base::R.version$platform, 8 * 
[09:29:46.513]                                   base::.Machine$sizeof.pointer), 
[09:29:46.513]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.513]                                 "release", "version")], collapse = " "), 
[09:29:46.513]                               hostname = base::Sys.info()[["nodename"]])
[09:29:46.513]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.513]                               info)
[09:29:46.513]                             info <- base::paste(info, collapse = "; ")
[09:29:46.513]                             if (!has_future) {
[09:29:46.513]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.513]                                 info)
[09:29:46.513]                             }
[09:29:46.513]                             else {
[09:29:46.513]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.513]                                 info, version)
[09:29:46.513]                             }
[09:29:46.513]                             base::stop(msg)
[09:29:46.513]                           }
[09:29:46.513]                         })
[09:29:46.513]                       }
[09:29:46.513]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:46.513]                       base::options(mc.cores = 1L)
[09:29:46.513]                     }
[09:29:46.513]                     base::local({
[09:29:46.513]                       for (pkg in "future.apply") {
[09:29:46.513]                         base::loadNamespace(pkg)
[09:29:46.513]                         base::library(pkg, character.only = TRUE)
[09:29:46.513]                       }
[09:29:46.513]                     })
[09:29:46.513]                   }
[09:29:46.513]                   ...future.strategy.old <- future::plan("list")
[09:29:46.513]                   options(future.plan = NULL)
[09:29:46.513]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.513]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.513]                 }
[09:29:46.513]                 ...future.workdir <- getwd()
[09:29:46.513]             }
[09:29:46.513]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.513]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.513]         }
[09:29:46.513]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.513]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:46.513]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.513]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.513]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.513]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.513]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.513]             base::names(...future.oldOptions))
[09:29:46.513]     }
[09:29:46.513]     if (FALSE) {
[09:29:46.513]     }
[09:29:46.513]     else {
[09:29:46.513]         if (TRUE) {
[09:29:46.513]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.513]                 open = "w")
[09:29:46.513]         }
[09:29:46.513]         else {
[09:29:46.513]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.513]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.513]         }
[09:29:46.513]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.513]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.513]             base::sink(type = "output", split = FALSE)
[09:29:46.513]             base::close(...future.stdout)
[09:29:46.513]         }, add = TRUE)
[09:29:46.513]     }
[09:29:46.513]     ...future.frame <- base::sys.nframe()
[09:29:46.513]     ...future.conditions <- base::list()
[09:29:46.513]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.513]     if (FALSE) {
[09:29:46.513]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.513]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.513]     }
[09:29:46.513]     ...future.result <- base::tryCatch({
[09:29:46.513]         base::withCallingHandlers({
[09:29:46.513]             ...future.value <- base::withVisible(base::local({
[09:29:46.513]                 withCallingHandlers({
[09:29:46.513]                   {
[09:29:46.513]                     do.call(function(...) {
[09:29:46.513]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.513]                       if (!identical(...future.globals.maxSize.org, 
[09:29:46.513]                         ...future.globals.maxSize)) {
[09:29:46.513]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.513]                         on.exit(options(oopts), add = TRUE)
[09:29:46.513]                       }
[09:29:46.513]                       {
[09:29:46.513]                         lapply(seq_along(...future.elements_ii), 
[09:29:46.513]                           FUN = function(jj) {
[09:29:46.513]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.513]                             ...future.FUN(...future.X_jj, ...)
[09:29:46.513]                           })
[09:29:46.513]                       }
[09:29:46.513]                     }, args = future.call.arguments)
[09:29:46.513]                   }
[09:29:46.513]                 }, immediateCondition = function(cond) {
[09:29:46.513]                   save_rds <- function (object, pathname, ...) 
[09:29:46.513]                   {
[09:29:46.513]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:46.513]                     if (file_test("-f", pathname_tmp)) {
[09:29:46.513]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.513]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:46.513]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.513]                         fi_tmp[["mtime"]])
[09:29:46.513]                     }
[09:29:46.513]                     tryCatch({
[09:29:46.513]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:46.513]                     }, error = function(ex) {
[09:29:46.513]                       msg <- conditionMessage(ex)
[09:29:46.513]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.513]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:46.513]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.513]                         fi_tmp[["mtime"]], msg)
[09:29:46.513]                       ex$message <- msg
[09:29:46.513]                       stop(ex)
[09:29:46.513]                     })
[09:29:46.513]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:46.513]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:46.513]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:46.513]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.513]                       fi <- file.info(pathname)
[09:29:46.513]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:46.513]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.513]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:46.513]                         fi[["size"]], fi[["mtime"]])
[09:29:46.513]                       stop(msg)
[09:29:46.513]                     }
[09:29:46.513]                     invisible(pathname)
[09:29:46.513]                   }
[09:29:46.513]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:46.513]                     rootPath = tempdir()) 
[09:29:46.513]                   {
[09:29:46.513]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:46.513]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:46.513]                       tmpdir = path, fileext = ".rds")
[09:29:46.513]                     save_rds(obj, file)
[09:29:46.513]                   }
[09:29:46.513]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:46.513]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.513]                   {
[09:29:46.513]                     inherits <- base::inherits
[09:29:46.513]                     invokeRestart <- base::invokeRestart
[09:29:46.513]                     is.null <- base::is.null
[09:29:46.513]                     muffled <- FALSE
[09:29:46.513]                     if (inherits(cond, "message")) {
[09:29:46.513]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:46.513]                       if (muffled) 
[09:29:46.513]                         invokeRestart("muffleMessage")
[09:29:46.513]                     }
[09:29:46.513]                     else if (inherits(cond, "warning")) {
[09:29:46.513]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:46.513]                       if (muffled) 
[09:29:46.513]                         invokeRestart("muffleWarning")
[09:29:46.513]                     }
[09:29:46.513]                     else if (inherits(cond, "condition")) {
[09:29:46.513]                       if (!is.null(pattern)) {
[09:29:46.513]                         computeRestarts <- base::computeRestarts
[09:29:46.513]                         grepl <- base::grepl
[09:29:46.513]                         restarts <- computeRestarts(cond)
[09:29:46.513]                         for (restart in restarts) {
[09:29:46.513]                           name <- restart$name
[09:29:46.513]                           if (is.null(name)) 
[09:29:46.513]                             next
[09:29:46.513]                           if (!grepl(pattern, name)) 
[09:29:46.513]                             next
[09:29:46.513]                           invokeRestart(restart)
[09:29:46.513]                           muffled <- TRUE
[09:29:46.513]                           break
[09:29:46.513]                         }
[09:29:46.513]                       }
[09:29:46.513]                     }
[09:29:46.513]                     invisible(muffled)
[09:29:46.513]                   }
[09:29:46.513]                   muffleCondition(cond)
[09:29:46.513]                 })
[09:29:46.513]             }))
[09:29:46.513]             future::FutureResult(value = ...future.value$value, 
[09:29:46.513]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.513]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.513]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.513]                     ...future.globalenv.names))
[09:29:46.513]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.513]         }, condition = base::local({
[09:29:46.513]             c <- base::c
[09:29:46.513]             inherits <- base::inherits
[09:29:46.513]             invokeRestart <- base::invokeRestart
[09:29:46.513]             length <- base::length
[09:29:46.513]             list <- base::list
[09:29:46.513]             seq.int <- base::seq.int
[09:29:46.513]             signalCondition <- base::signalCondition
[09:29:46.513]             sys.calls <- base::sys.calls
[09:29:46.513]             `[[` <- base::`[[`
[09:29:46.513]             `+` <- base::`+`
[09:29:46.513]             `<<-` <- base::`<<-`
[09:29:46.513]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.513]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.513]                   3L)]
[09:29:46.513]             }
[09:29:46.513]             function(cond) {
[09:29:46.513]                 is_error <- inherits(cond, "error")
[09:29:46.513]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.513]                   NULL)
[09:29:46.513]                 if (is_error) {
[09:29:46.513]                   sessionInformation <- function() {
[09:29:46.513]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.513]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.513]                       search = base::search(), system = base::Sys.info())
[09:29:46.513]                   }
[09:29:46.513]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.513]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.513]                     cond$call), session = sessionInformation(), 
[09:29:46.513]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.513]                   signalCondition(cond)
[09:29:46.513]                 }
[09:29:46.513]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.513]                 "immediateCondition"))) {
[09:29:46.513]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.513]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.513]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.513]                   if (TRUE && !signal) {
[09:29:46.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.513]                     {
[09:29:46.513]                       inherits <- base::inherits
[09:29:46.513]                       invokeRestart <- base::invokeRestart
[09:29:46.513]                       is.null <- base::is.null
[09:29:46.513]                       muffled <- FALSE
[09:29:46.513]                       if (inherits(cond, "message")) {
[09:29:46.513]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.513]                         if (muffled) 
[09:29:46.513]                           invokeRestart("muffleMessage")
[09:29:46.513]                       }
[09:29:46.513]                       else if (inherits(cond, "warning")) {
[09:29:46.513]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.513]                         if (muffled) 
[09:29:46.513]                           invokeRestart("muffleWarning")
[09:29:46.513]                       }
[09:29:46.513]                       else if (inherits(cond, "condition")) {
[09:29:46.513]                         if (!is.null(pattern)) {
[09:29:46.513]                           computeRestarts <- base::computeRestarts
[09:29:46.513]                           grepl <- base::grepl
[09:29:46.513]                           restarts <- computeRestarts(cond)
[09:29:46.513]                           for (restart in restarts) {
[09:29:46.513]                             name <- restart$name
[09:29:46.513]                             if (is.null(name)) 
[09:29:46.513]                               next
[09:29:46.513]                             if (!grepl(pattern, name)) 
[09:29:46.513]                               next
[09:29:46.513]                             invokeRestart(restart)
[09:29:46.513]                             muffled <- TRUE
[09:29:46.513]                             break
[09:29:46.513]                           }
[09:29:46.513]                         }
[09:29:46.513]                       }
[09:29:46.513]                       invisible(muffled)
[09:29:46.513]                     }
[09:29:46.513]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.513]                   }
[09:29:46.513]                 }
[09:29:46.513]                 else {
[09:29:46.513]                   if (TRUE) {
[09:29:46.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.513]                     {
[09:29:46.513]                       inherits <- base::inherits
[09:29:46.513]                       invokeRestart <- base::invokeRestart
[09:29:46.513]                       is.null <- base::is.null
[09:29:46.513]                       muffled <- FALSE
[09:29:46.513]                       if (inherits(cond, "message")) {
[09:29:46.513]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.513]                         if (muffled) 
[09:29:46.513]                           invokeRestart("muffleMessage")
[09:29:46.513]                       }
[09:29:46.513]                       else if (inherits(cond, "warning")) {
[09:29:46.513]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.513]                         if (muffled) 
[09:29:46.513]                           invokeRestart("muffleWarning")
[09:29:46.513]                       }
[09:29:46.513]                       else if (inherits(cond, "condition")) {
[09:29:46.513]                         if (!is.null(pattern)) {
[09:29:46.513]                           computeRestarts <- base::computeRestarts
[09:29:46.513]                           grepl <- base::grepl
[09:29:46.513]                           restarts <- computeRestarts(cond)
[09:29:46.513]                           for (restart in restarts) {
[09:29:46.513]                             name <- restart$name
[09:29:46.513]                             if (is.null(name)) 
[09:29:46.513]                               next
[09:29:46.513]                             if (!grepl(pattern, name)) 
[09:29:46.513]                               next
[09:29:46.513]                             invokeRestart(restart)
[09:29:46.513]                             muffled <- TRUE
[09:29:46.513]                             break
[09:29:46.513]                           }
[09:29:46.513]                         }
[09:29:46.513]                       }
[09:29:46.513]                       invisible(muffled)
[09:29:46.513]                     }
[09:29:46.513]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.513]                   }
[09:29:46.513]                 }
[09:29:46.513]             }
[09:29:46.513]         }))
[09:29:46.513]     }, error = function(ex) {
[09:29:46.513]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.513]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.513]                 ...future.rng), started = ...future.startTime, 
[09:29:46.513]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.513]             version = "1.8"), class = "FutureResult")
[09:29:46.513]     }, finally = {
[09:29:46.513]         if (!identical(...future.workdir, getwd())) 
[09:29:46.513]             setwd(...future.workdir)
[09:29:46.513]         {
[09:29:46.513]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.513]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.513]             }
[09:29:46.513]             base::options(...future.oldOptions)
[09:29:46.513]             if (.Platform$OS.type == "windows") {
[09:29:46.513]                 old_names <- names(...future.oldEnvVars)
[09:29:46.513]                 envs <- base::Sys.getenv()
[09:29:46.513]                 names <- names(envs)
[09:29:46.513]                 common <- intersect(names, old_names)
[09:29:46.513]                 added <- setdiff(names, old_names)
[09:29:46.513]                 removed <- setdiff(old_names, names)
[09:29:46.513]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.513]                   envs[common]]
[09:29:46.513]                 NAMES <- toupper(changed)
[09:29:46.513]                 args <- list()
[09:29:46.513]                 for (kk in seq_along(NAMES)) {
[09:29:46.513]                   name <- changed[[kk]]
[09:29:46.513]                   NAME <- NAMES[[kk]]
[09:29:46.513]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.513]                     next
[09:29:46.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.513]                 }
[09:29:46.513]                 NAMES <- toupper(added)
[09:29:46.513]                 for (kk in seq_along(NAMES)) {
[09:29:46.513]                   name <- added[[kk]]
[09:29:46.513]                   NAME <- NAMES[[kk]]
[09:29:46.513]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.513]                     next
[09:29:46.513]                   args[[name]] <- ""
[09:29:46.513]                 }
[09:29:46.513]                 NAMES <- toupper(removed)
[09:29:46.513]                 for (kk in seq_along(NAMES)) {
[09:29:46.513]                   name <- removed[[kk]]
[09:29:46.513]                   NAME <- NAMES[[kk]]
[09:29:46.513]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.513]                     next
[09:29:46.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.513]                 }
[09:29:46.513]                 if (length(args) > 0) 
[09:29:46.513]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.513]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.513]             }
[09:29:46.513]             else {
[09:29:46.513]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.513]             }
[09:29:46.513]             {
[09:29:46.513]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.513]                   0L) {
[09:29:46.513]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.513]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.513]                   base::options(opts)
[09:29:46.513]                 }
[09:29:46.513]                 {
[09:29:46.513]                   {
[09:29:46.513]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:46.513]                     NULL
[09:29:46.513]                   }
[09:29:46.513]                   options(future.plan = NULL)
[09:29:46.513]                   if (is.na(NA_character_)) 
[09:29:46.513]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.513]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.513]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.513]                     .init = FALSE)
[09:29:46.513]                 }
[09:29:46.513]             }
[09:29:46.513]         }
[09:29:46.513]     })
[09:29:46.513]     if (TRUE) {
[09:29:46.513]         base::sink(type = "output", split = FALSE)
[09:29:46.513]         if (TRUE) {
[09:29:46.513]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.513]         }
[09:29:46.513]         else {
[09:29:46.513]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.513]         }
[09:29:46.513]         base::close(...future.stdout)
[09:29:46.513]         ...future.stdout <- NULL
[09:29:46.513]     }
[09:29:46.513]     ...future.result$conditions <- ...future.conditions
[09:29:46.513]     ...future.result$finished <- base::Sys.time()
[09:29:46.513]     ...future.result
[09:29:46.513] }
[09:29:46.515] assign_globals() ...
[09:29:46.515] List of 11
[09:29:46.515]  $ ...future.FUN            :function (x, ...)  
[09:29:46.515]  $ x_FUN                    :function (x)  
[09:29:46.515]  $ times                    : int 0
[09:29:46.515]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.515]  $ stop_if_not              :function (...)  
[09:29:46.515]  $ dim                      : NULL
[09:29:46.515]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:46.515]  $ future.call.arguments    : list()
[09:29:46.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.515]  $ ...future.elements_ii    :List of 5
[09:29:46.515]   ..$ : int 6
[09:29:46.515]   ..$ : int 7
[09:29:46.515]   ..$ : int 8
[09:29:46.515]   ..$ : int 9
[09:29:46.515]   ..$ : int 10
[09:29:46.515]  $ ...future.seeds_ii       : NULL
[09:29:46.515]  $ ...future.globals.maxSize: NULL
[09:29:46.515]  - attr(*, "where")=List of 11
[09:29:46.515]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.515]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.515]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.515]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.515]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.515]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.515]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.515]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.515]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.515]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.515]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.515]  - attr(*, "resolved")= logi FALSE
[09:29:46.515]  - attr(*, "total_size")= num 95472
[09:29:46.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.515]  - attr(*, "already-done")= logi TRUE
[09:29:46.526] - copied ‘...future.FUN’ to environment
[09:29:46.526] - reassign environment for ‘x_FUN’
[09:29:46.526] - copied ‘x_FUN’ to environment
[09:29:46.526] - copied ‘times’ to environment
[09:29:46.526] - copied ‘stopf’ to environment
[09:29:46.527] - copied ‘stop_if_not’ to environment
[09:29:46.527] - copied ‘dim’ to environment
[09:29:46.527] - copied ‘valid_types’ to environment
[09:29:46.527] - copied ‘future.call.arguments’ to environment
[09:29:46.527] - copied ‘...future.elements_ii’ to environment
[09:29:46.527] - copied ‘...future.seeds_ii’ to environment
[09:29:46.527] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.527] assign_globals() ... done
[09:29:46.528] requestCore(): workers = 2
[09:29:46.530] MulticoreFuture started
[09:29:46.530] - Launch lazy future ... done
[09:29:46.530] run() for ‘MulticoreFuture’ ... done
[09:29:46.530] Created future:
[09:29:46.531] plan(): Setting new future strategy stack:
[09:29:46.531] List of future strategies:
[09:29:46.531] 1. sequential:
[09:29:46.531]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.531]    - tweaked: FALSE
[09:29:46.531]    - call: NULL
[09:29:46.532] plan(): nbrOfWorkers() = 1
[09:29:46.534] plan(): Setting new future strategy stack:
[09:29:46.534] List of future strategies:
[09:29:46.534] 1. multicore:
[09:29:46.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.534]    - tweaked: FALSE
[09:29:46.534]    - call: plan(strategy)
[09:29:46.539] plan(): nbrOfWorkers() = 2
[09:29:46.531] MulticoreFuture:
[09:29:46.531] Label: ‘future_vapply-2’
[09:29:46.531] Expression:
[09:29:46.531] {
[09:29:46.531]     do.call(function(...) {
[09:29:46.531]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.531]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.531]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.531]             on.exit(options(oopts), add = TRUE)
[09:29:46.531]         }
[09:29:46.531]         {
[09:29:46.531]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.531]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.531]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.531]             })
[09:29:46.531]         }
[09:29:46.531]     }, args = future.call.arguments)
[09:29:46.531] }
[09:29:46.531] Lazy evaluation: FALSE
[09:29:46.531] Asynchronous evaluation: TRUE
[09:29:46.531] Local evaluation: TRUE
[09:29:46.531] Environment: R_GlobalEnv
[09:29:46.531] Capture standard output: TRUE
[09:29:46.531] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.531] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.531] Packages: 1 packages (‘future.apply’)
[09:29:46.531] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.531] Resolved: TRUE
[09:29:46.531] Value: <not collected>
[09:29:46.531] Conditions captured: <none>
[09:29:46.531] Early signaling: FALSE
[09:29:46.531] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.531] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.540] Chunk #2 of 2 ... DONE
[09:29:46.540] Launching 2 futures (chunks) ... DONE
[09:29:46.540] Resolving 2 futures (chunks) ...
[09:29:46.540] resolve() on list ...
[09:29:46.540]  recursive: 0
[09:29:46.541]  length: 2
[09:29:46.541] 
[09:29:46.541] Future #1
[09:29:46.541] result() for MulticoreFuture ...
[09:29:46.542] result() for MulticoreFuture ...
[09:29:46.542] result() for MulticoreFuture ... done
[09:29:46.542] result() for MulticoreFuture ... done
[09:29:46.542] result() for MulticoreFuture ...
[09:29:46.542] result() for MulticoreFuture ... done
[09:29:46.543] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:46.543] - nx: 2
[09:29:46.543] - relay: TRUE
[09:29:46.543] - stdout: TRUE
[09:29:46.543] - signal: TRUE
[09:29:46.543] - resignal: FALSE
[09:29:46.543] - force: TRUE
[09:29:46.544] - relayed: [n=2] FALSE, FALSE
[09:29:46.544] - queued futures: [n=2] FALSE, FALSE
[09:29:46.544]  - until=1
[09:29:46.544]  - relaying element #1
[09:29:46.544] result() for MulticoreFuture ...
[09:29:46.544] result() for MulticoreFuture ... done
[09:29:46.544] result() for MulticoreFuture ...
[09:29:46.545] result() for MulticoreFuture ... done
[09:29:46.545] result() for MulticoreFuture ...
[09:29:46.545] result() for MulticoreFuture ... done
[09:29:46.545] result() for MulticoreFuture ...
[09:29:46.545] result() for MulticoreFuture ... done
[09:29:46.545] - relayed: [n=2] TRUE, FALSE
[09:29:46.546] - queued futures: [n=2] TRUE, FALSE
[09:29:46.546] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:46.546]  length: 1 (resolved future 1)
[09:29:46.546] Future #2
[09:29:46.546] result() for MulticoreFuture ...
[09:29:46.550] result() for MulticoreFuture ...
[09:29:46.550] result() for MulticoreFuture ... done
[09:29:46.550] result() for MulticoreFuture ... done
[09:29:46.550] result() for MulticoreFuture ...
[09:29:46.550] result() for MulticoreFuture ... done
[09:29:46.551] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:46.551] - nx: 2
[09:29:46.551] - relay: TRUE
[09:29:46.551] - stdout: TRUE
[09:29:46.551] - signal: TRUE
[09:29:46.551] - resignal: FALSE
[09:29:46.552] - force: TRUE
[09:29:46.552] - relayed: [n=2] TRUE, FALSE
[09:29:46.552] - queued futures: [n=2] TRUE, FALSE
[09:29:46.552]  - until=2
[09:29:46.552]  - relaying element #2
[09:29:46.552] result() for MulticoreFuture ...
[09:29:46.552] result() for MulticoreFuture ... done
[09:29:46.553] result() for MulticoreFuture ...
[09:29:46.553] result() for MulticoreFuture ... done
[09:29:46.553] result() for MulticoreFuture ...
[09:29:46.553] result() for MulticoreFuture ... done
[09:29:46.553] result() for MulticoreFuture ...
[09:29:46.553] result() for MulticoreFuture ... done
[09:29:46.554] - relayed: [n=2] TRUE, TRUE
[09:29:46.554] - queued futures: [n=2] TRUE, TRUE
[09:29:46.554] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:46.554]  length: 0 (resolved future 2)
[09:29:46.554] Relaying remaining futures
[09:29:46.554] signalConditionsASAP(NULL, pos=0) ...
[09:29:46.554] - nx: 2
[09:29:46.555] - relay: TRUE
[09:29:46.555] - stdout: TRUE
[09:29:46.555] - signal: TRUE
[09:29:46.555] - resignal: FALSE
[09:29:46.555] - force: TRUE
[09:29:46.555] - relayed: [n=2] TRUE, TRUE
[09:29:46.555] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:46.555] - relayed: [n=2] TRUE, TRUE
[09:29:46.555] - queued futures: [n=2] TRUE, TRUE
[09:29:46.556] signalConditionsASAP(NULL, pos=0) ... done
[09:29:46.556] resolve() on list ... DONE
[09:29:46.556] result() for MulticoreFuture ...
[09:29:46.556] result() for MulticoreFuture ... done
[09:29:46.556] result() for MulticoreFuture ...
[09:29:46.556] result() for MulticoreFuture ... done
[09:29:46.556] result() for MulticoreFuture ...
[09:29:46.556] result() for MulticoreFuture ... done
[09:29:46.557] result() for MulticoreFuture ...
[09:29:46.557] result() for MulticoreFuture ... done
[09:29:46.557]  - Number of value chunks collected: 2
[09:29:46.557] Resolving 2 futures (chunks) ... DONE
[09:29:46.557] Reducing values from 2 chunks ...
[09:29:46.557]  - Number of values collected after concatenation: 10
[09:29:46.557]  - Number of values expected: 10
[09:29:46.557] Reducing values from 2 chunks ... DONE
[09:29:46.557] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[09:29:46.558] future_lapply() ...
[09:29:46.564] Number of chunks: 2
[09:29:46.564] getGlobalsAndPackagesXApply() ...
[09:29:46.564]  - future.globals: TRUE
[09:29:46.564] getGlobalsAndPackages() ...
[09:29:46.564] Searching for globals...
[09:29:46.568] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[09:29:46.568] Searching for globals ... DONE
[09:29:46.568] Resolving globals: FALSE
[09:29:46.569] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[09:29:46.569] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:46.570] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.570] - packages: [1] ‘future.apply’
[09:29:46.570] getGlobalsAndPackages() ... DONE
[09:29:46.570]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.570]  - needed namespaces: [n=1] ‘future.apply’
[09:29:46.570] Finding globals ... DONE
[09:29:46.570]  - use_args: TRUE
[09:29:46.570]  - Getting '...' globals ...
[09:29:46.571] resolve() on list ...
[09:29:46.571]  recursive: 0
[09:29:46.571]  length: 1
[09:29:46.571]  elements: ‘...’
[09:29:46.571]  length: 0 (resolved future 1)
[09:29:46.571] resolve() on list ... DONE
[09:29:46.571]    - '...' content: [n=0] 
[09:29:46.571] List of 1
[09:29:46.571]  $ ...: list()
[09:29:46.571]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.571]  - attr(*, "where")=List of 1
[09:29:46.571]   ..$ ...:<environment: 0x561d34205cc0> 
[09:29:46.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.571]  - attr(*, "resolved")= logi TRUE
[09:29:46.571]  - attr(*, "total_size")= num NA
[09:29:46.574]  - Getting '...' globals ... DONE
[09:29:46.574] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:46.574] List of 8
[09:29:46.574]  $ ...future.FUN:function (x, ...)  
[09:29:46.574]  $ x_FUN        :function (x)  
[09:29:46.574]  $ times        : int 0
[09:29:46.574]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.574]  $ stop_if_not  :function (...)  
[09:29:46.574]  $ dim          : NULL
[09:29:46.574]  $ valid_types  : chr [1:2] "logical" "integer"
[09:29:46.574]  $ ...          : list()
[09:29:46.574]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.574]  - attr(*, "where")=List of 8
[09:29:46.574]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.574]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:46.574]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:46.574]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:46.574]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:46.574]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:46.574]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:46.574]   ..$ ...          :<environment: 0x561d34205cc0> 
[09:29:46.574]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.574]  - attr(*, "resolved")= logi FALSE
[09:29:46.574]  - attr(*, "total_size")= num 95400
[09:29:46.581] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:46.581] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.581] Number of futures (= number of chunks): 2
[09:29:46.581] Launching 2 futures (chunks) ...
[09:29:46.581] Chunk #1 of 2 ...
[09:29:46.581]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.581] getGlobalsAndPackages() ...
[09:29:46.581] Searching for globals...
[09:29:46.582] 
[09:29:46.582] Searching for globals ... DONE
[09:29:46.582] - globals: [0] <none>
[09:29:46.582] getGlobalsAndPackages() ... DONE
[09:29:46.582]    + additional globals found: [n=0] 
[09:29:46.582]    + additional namespaces needed: [n=0] 
[09:29:46.582]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.582]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.582]  - seeds: <none>
[09:29:46.582]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.583] getGlobalsAndPackages() ...
[09:29:46.583] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.583] Resolving globals: FALSE
[09:29:46.583] Tweak future expression to call with '...' arguments ...
[09:29:46.583] {
[09:29:46.583]     do.call(function(...) {
[09:29:46.583]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.583]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.583]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.583]             on.exit(options(oopts), add = TRUE)
[09:29:46.583]         }
[09:29:46.583]         {
[09:29:46.583]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.583]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.583]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.583]             })
[09:29:46.583]         }
[09:29:46.583]     }, args = future.call.arguments)
[09:29:46.583] }
[09:29:46.583] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.584] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.584] - packages: [1] ‘future.apply’
[09:29:46.584] getGlobalsAndPackages() ... DONE
[09:29:46.584] run() for ‘Future’ ...
[09:29:46.584] - state: ‘created’
[09:29:46.585] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:46.588] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:46.588]   - Field: ‘label’
[09:29:46.588]   - Field: ‘local’
[09:29:46.588]   - Field: ‘owner’
[09:29:46.589]   - Field: ‘envir’
[09:29:46.589]   - Field: ‘workers’
[09:29:46.589]   - Field: ‘packages’
[09:29:46.589]   - Field: ‘gc’
[09:29:46.589]   - Field: ‘job’
[09:29:46.589]   - Field: ‘conditions’
[09:29:46.589]   - Field: ‘expr’
[09:29:46.589]   - Field: ‘uuid’
[09:29:46.589]   - Field: ‘seed’
[09:29:46.589]   - Field: ‘version’
[09:29:46.589]   - Field: ‘result’
[09:29:46.589]   - Field: ‘asynchronous’
[09:29:46.590]   - Field: ‘calls’
[09:29:46.590]   - Field: ‘globals’
[09:29:46.590]   - Field: ‘stdout’
[09:29:46.590]   - Field: ‘earlySignal’
[09:29:46.590]   - Field: ‘lazy’
[09:29:46.590]   - Field: ‘state’
[09:29:46.590] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:46.590] - Launch lazy future ...
[09:29:46.590] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.591] Packages needed by future strategies (n = 0): <none>
[09:29:46.591] {
[09:29:46.591]     {
[09:29:46.591]         {
[09:29:46.591]             ...future.startTime <- base::Sys.time()
[09:29:46.591]             {
[09:29:46.591]                 {
[09:29:46.591]                   {
[09:29:46.591]                     {
[09:29:46.591]                       {
[09:29:46.591]                         base::local({
[09:29:46.591]                           has_future <- base::requireNamespace("future", 
[09:29:46.591]                             quietly = TRUE)
[09:29:46.591]                           if (has_future) {
[09:29:46.591]                             ns <- base::getNamespace("future")
[09:29:46.591]                             version <- ns[[".package"]][["version"]]
[09:29:46.591]                             if (is.null(version)) 
[09:29:46.591]                               version <- utils::packageVersion("future")
[09:29:46.591]                           }
[09:29:46.591]                           else {
[09:29:46.591]                             version <- NULL
[09:29:46.591]                           }
[09:29:46.591]                           if (!has_future || version < "1.8.0") {
[09:29:46.591]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.591]                               "", base::R.version$version.string), 
[09:29:46.591]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:46.591]                                 base::R.version$platform, 8 * 
[09:29:46.591]                                   base::.Machine$sizeof.pointer), 
[09:29:46.591]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.591]                                 "release", "version")], collapse = " "), 
[09:29:46.591]                               hostname = base::Sys.info()[["nodename"]])
[09:29:46.591]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.591]                               info)
[09:29:46.591]                             info <- base::paste(info, collapse = "; ")
[09:29:46.591]                             if (!has_future) {
[09:29:46.591]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.591]                                 info)
[09:29:46.591]                             }
[09:29:46.591]                             else {
[09:29:46.591]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.591]                                 info, version)
[09:29:46.591]                             }
[09:29:46.591]                             base::stop(msg)
[09:29:46.591]                           }
[09:29:46.591]                         })
[09:29:46.591]                       }
[09:29:46.591]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:46.591]                       base::options(mc.cores = 1L)
[09:29:46.591]                     }
[09:29:46.591]                     base::local({
[09:29:46.591]                       for (pkg in "future.apply") {
[09:29:46.591]                         base::loadNamespace(pkg)
[09:29:46.591]                         base::library(pkg, character.only = TRUE)
[09:29:46.591]                       }
[09:29:46.591]                     })
[09:29:46.591]                   }
[09:29:46.591]                   ...future.strategy.old <- future::plan("list")
[09:29:46.591]                   options(future.plan = NULL)
[09:29:46.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.591]                 }
[09:29:46.591]                 ...future.workdir <- getwd()
[09:29:46.591]             }
[09:29:46.591]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.591]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.591]         }
[09:29:46.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.591]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:46.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.591]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.591]             base::names(...future.oldOptions))
[09:29:46.591]     }
[09:29:46.591]     if (FALSE) {
[09:29:46.591]     }
[09:29:46.591]     else {
[09:29:46.591]         if (TRUE) {
[09:29:46.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.591]                 open = "w")
[09:29:46.591]         }
[09:29:46.591]         else {
[09:29:46.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.591]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.591]         }
[09:29:46.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.591]             base::sink(type = "output", split = FALSE)
[09:29:46.591]             base::close(...future.stdout)
[09:29:46.591]         }, add = TRUE)
[09:29:46.591]     }
[09:29:46.591]     ...future.frame <- base::sys.nframe()
[09:29:46.591]     ...future.conditions <- base::list()
[09:29:46.591]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.591]     if (FALSE) {
[09:29:46.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.591]     }
[09:29:46.591]     ...future.result <- base::tryCatch({
[09:29:46.591]         base::withCallingHandlers({
[09:29:46.591]             ...future.value <- base::withVisible(base::local({
[09:29:46.591]                 withCallingHandlers({
[09:29:46.591]                   {
[09:29:46.591]                     do.call(function(...) {
[09:29:46.591]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.591]                       if (!identical(...future.globals.maxSize.org, 
[09:29:46.591]                         ...future.globals.maxSize)) {
[09:29:46.591]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.591]                         on.exit(options(oopts), add = TRUE)
[09:29:46.591]                       }
[09:29:46.591]                       {
[09:29:46.591]                         lapply(seq_along(...future.elements_ii), 
[09:29:46.591]                           FUN = function(jj) {
[09:29:46.591]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.591]                             ...future.FUN(...future.X_jj, ...)
[09:29:46.591]                           })
[09:29:46.591]                       }
[09:29:46.591]                     }, args = future.call.arguments)
[09:29:46.591]                   }
[09:29:46.591]                 }, immediateCondition = function(cond) {
[09:29:46.591]                   save_rds <- function (object, pathname, ...) 
[09:29:46.591]                   {
[09:29:46.591]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:46.591]                     if (file_test("-f", pathname_tmp)) {
[09:29:46.591]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.591]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:46.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.591]                         fi_tmp[["mtime"]])
[09:29:46.591]                     }
[09:29:46.591]                     tryCatch({
[09:29:46.591]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:46.591]                     }, error = function(ex) {
[09:29:46.591]                       msg <- conditionMessage(ex)
[09:29:46.591]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.591]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:46.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.591]                         fi_tmp[["mtime"]], msg)
[09:29:46.591]                       ex$message <- msg
[09:29:46.591]                       stop(ex)
[09:29:46.591]                     })
[09:29:46.591]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:46.591]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:46.591]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:46.591]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.591]                       fi <- file.info(pathname)
[09:29:46.591]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:46.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.591]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:46.591]                         fi[["size"]], fi[["mtime"]])
[09:29:46.591]                       stop(msg)
[09:29:46.591]                     }
[09:29:46.591]                     invisible(pathname)
[09:29:46.591]                   }
[09:29:46.591]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:46.591]                     rootPath = tempdir()) 
[09:29:46.591]                   {
[09:29:46.591]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:46.591]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:46.591]                       tmpdir = path, fileext = ".rds")
[09:29:46.591]                     save_rds(obj, file)
[09:29:46.591]                   }
[09:29:46.591]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:46.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.591]                   {
[09:29:46.591]                     inherits <- base::inherits
[09:29:46.591]                     invokeRestart <- base::invokeRestart
[09:29:46.591]                     is.null <- base::is.null
[09:29:46.591]                     muffled <- FALSE
[09:29:46.591]                     if (inherits(cond, "message")) {
[09:29:46.591]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:46.591]                       if (muffled) 
[09:29:46.591]                         invokeRestart("muffleMessage")
[09:29:46.591]                     }
[09:29:46.591]                     else if (inherits(cond, "warning")) {
[09:29:46.591]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:46.591]                       if (muffled) 
[09:29:46.591]                         invokeRestart("muffleWarning")
[09:29:46.591]                     }
[09:29:46.591]                     else if (inherits(cond, "condition")) {
[09:29:46.591]                       if (!is.null(pattern)) {
[09:29:46.591]                         computeRestarts <- base::computeRestarts
[09:29:46.591]                         grepl <- base::grepl
[09:29:46.591]                         restarts <- computeRestarts(cond)
[09:29:46.591]                         for (restart in restarts) {
[09:29:46.591]                           name <- restart$name
[09:29:46.591]                           if (is.null(name)) 
[09:29:46.591]                             next
[09:29:46.591]                           if (!grepl(pattern, name)) 
[09:29:46.591]                             next
[09:29:46.591]                           invokeRestart(restart)
[09:29:46.591]                           muffled <- TRUE
[09:29:46.591]                           break
[09:29:46.591]                         }
[09:29:46.591]                       }
[09:29:46.591]                     }
[09:29:46.591]                     invisible(muffled)
[09:29:46.591]                   }
[09:29:46.591]                   muffleCondition(cond)
[09:29:46.591]                 })
[09:29:46.591]             }))
[09:29:46.591]             future::FutureResult(value = ...future.value$value, 
[09:29:46.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.591]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.591]                     ...future.globalenv.names))
[09:29:46.591]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.591]         }, condition = base::local({
[09:29:46.591]             c <- base::c
[09:29:46.591]             inherits <- base::inherits
[09:29:46.591]             invokeRestart <- base::invokeRestart
[09:29:46.591]             length <- base::length
[09:29:46.591]             list <- base::list
[09:29:46.591]             seq.int <- base::seq.int
[09:29:46.591]             signalCondition <- base::signalCondition
[09:29:46.591]             sys.calls <- base::sys.calls
[09:29:46.591]             `[[` <- base::`[[`
[09:29:46.591]             `+` <- base::`+`
[09:29:46.591]             `<<-` <- base::`<<-`
[09:29:46.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.591]                   3L)]
[09:29:46.591]             }
[09:29:46.591]             function(cond) {
[09:29:46.591]                 is_error <- inherits(cond, "error")
[09:29:46.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.591]                   NULL)
[09:29:46.591]                 if (is_error) {
[09:29:46.591]                   sessionInformation <- function() {
[09:29:46.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.591]                       search = base::search(), system = base::Sys.info())
[09:29:46.591]                   }
[09:29:46.591]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.591]                     cond$call), session = sessionInformation(), 
[09:29:46.591]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.591]                   signalCondition(cond)
[09:29:46.591]                 }
[09:29:46.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.591]                 "immediateCondition"))) {
[09:29:46.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.591]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.591]                   if (TRUE && !signal) {
[09:29:46.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.591]                     {
[09:29:46.591]                       inherits <- base::inherits
[09:29:46.591]                       invokeRestart <- base::invokeRestart
[09:29:46.591]                       is.null <- base::is.null
[09:29:46.591]                       muffled <- FALSE
[09:29:46.591]                       if (inherits(cond, "message")) {
[09:29:46.591]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.591]                         if (muffled) 
[09:29:46.591]                           invokeRestart("muffleMessage")
[09:29:46.591]                       }
[09:29:46.591]                       else if (inherits(cond, "warning")) {
[09:29:46.591]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.591]                         if (muffled) 
[09:29:46.591]                           invokeRestart("muffleWarning")
[09:29:46.591]                       }
[09:29:46.591]                       else if (inherits(cond, "condition")) {
[09:29:46.591]                         if (!is.null(pattern)) {
[09:29:46.591]                           computeRestarts <- base::computeRestarts
[09:29:46.591]                           grepl <- base::grepl
[09:29:46.591]                           restarts <- computeRestarts(cond)
[09:29:46.591]                           for (restart in restarts) {
[09:29:46.591]                             name <- restart$name
[09:29:46.591]                             if (is.null(name)) 
[09:29:46.591]                               next
[09:29:46.591]                             if (!grepl(pattern, name)) 
[09:29:46.591]                               next
[09:29:46.591]                             invokeRestart(restart)
[09:29:46.591]                             muffled <- TRUE
[09:29:46.591]                             break
[09:29:46.591]                           }
[09:29:46.591]                         }
[09:29:46.591]                       }
[09:29:46.591]                       invisible(muffled)
[09:29:46.591]                     }
[09:29:46.591]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.591]                   }
[09:29:46.591]                 }
[09:29:46.591]                 else {
[09:29:46.591]                   if (TRUE) {
[09:29:46.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.591]                     {
[09:29:46.591]                       inherits <- base::inherits
[09:29:46.591]                       invokeRestart <- base::invokeRestart
[09:29:46.591]                       is.null <- base::is.null
[09:29:46.591]                       muffled <- FALSE
[09:29:46.591]                       if (inherits(cond, "message")) {
[09:29:46.591]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.591]                         if (muffled) 
[09:29:46.591]                           invokeRestart("muffleMessage")
[09:29:46.591]                       }
[09:29:46.591]                       else if (inherits(cond, "warning")) {
[09:29:46.591]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.591]                         if (muffled) 
[09:29:46.591]                           invokeRestart("muffleWarning")
[09:29:46.591]                       }
[09:29:46.591]                       else if (inherits(cond, "condition")) {
[09:29:46.591]                         if (!is.null(pattern)) {
[09:29:46.591]                           computeRestarts <- base::computeRestarts
[09:29:46.591]                           grepl <- base::grepl
[09:29:46.591]                           restarts <- computeRestarts(cond)
[09:29:46.591]                           for (restart in restarts) {
[09:29:46.591]                             name <- restart$name
[09:29:46.591]                             if (is.null(name)) 
[09:29:46.591]                               next
[09:29:46.591]                             if (!grepl(pattern, name)) 
[09:29:46.591]                               next
[09:29:46.591]                             invokeRestart(restart)
[09:29:46.591]                             muffled <- TRUE
[09:29:46.591]                             break
[09:29:46.591]                           }
[09:29:46.591]                         }
[09:29:46.591]                       }
[09:29:46.591]                       invisible(muffled)
[09:29:46.591]                     }
[09:29:46.591]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.591]                   }
[09:29:46.591]                 }
[09:29:46.591]             }
[09:29:46.591]         }))
[09:29:46.591]     }, error = function(ex) {
[09:29:46.591]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.591]                 ...future.rng), started = ...future.startTime, 
[09:29:46.591]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.591]             version = "1.8"), class = "FutureResult")
[09:29:46.591]     }, finally = {
[09:29:46.591]         if (!identical(...future.workdir, getwd())) 
[09:29:46.591]             setwd(...future.workdir)
[09:29:46.591]         {
[09:29:46.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.591]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.591]             }
[09:29:46.591]             base::options(...future.oldOptions)
[09:29:46.591]             if (.Platform$OS.type == "windows") {
[09:29:46.591]                 old_names <- names(...future.oldEnvVars)
[09:29:46.591]                 envs <- base::Sys.getenv()
[09:29:46.591]                 names <- names(envs)
[09:29:46.591]                 common <- intersect(names, old_names)
[09:29:46.591]                 added <- setdiff(names, old_names)
[09:29:46.591]                 removed <- setdiff(old_names, names)
[09:29:46.591]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.591]                   envs[common]]
[09:29:46.591]                 NAMES <- toupper(changed)
[09:29:46.591]                 args <- list()
[09:29:46.591]                 for (kk in seq_along(NAMES)) {
[09:29:46.591]                   name <- changed[[kk]]
[09:29:46.591]                   NAME <- NAMES[[kk]]
[09:29:46.591]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.591]                     next
[09:29:46.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.591]                 }
[09:29:46.591]                 NAMES <- toupper(added)
[09:29:46.591]                 for (kk in seq_along(NAMES)) {
[09:29:46.591]                   name <- added[[kk]]
[09:29:46.591]                   NAME <- NAMES[[kk]]
[09:29:46.591]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.591]                     next
[09:29:46.591]                   args[[name]] <- ""
[09:29:46.591]                 }
[09:29:46.591]                 NAMES <- toupper(removed)
[09:29:46.591]                 for (kk in seq_along(NAMES)) {
[09:29:46.591]                   name <- removed[[kk]]
[09:29:46.591]                   NAME <- NAMES[[kk]]
[09:29:46.591]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.591]                     next
[09:29:46.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.591]                 }
[09:29:46.591]                 if (length(args) > 0) 
[09:29:46.591]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.591]             }
[09:29:46.591]             else {
[09:29:46.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.591]             }
[09:29:46.591]             {
[09:29:46.591]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.591]                   0L) {
[09:29:46.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.591]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.591]                   base::options(opts)
[09:29:46.591]                 }
[09:29:46.591]                 {
[09:29:46.591]                   {
[09:29:46.591]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:46.591]                     NULL
[09:29:46.591]                   }
[09:29:46.591]                   options(future.plan = NULL)
[09:29:46.591]                   if (is.na(NA_character_)) 
[09:29:46.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.591]                     .init = FALSE)
[09:29:46.591]                 }
[09:29:46.591]             }
[09:29:46.591]         }
[09:29:46.591]     })
[09:29:46.591]     if (TRUE) {
[09:29:46.591]         base::sink(type = "output", split = FALSE)
[09:29:46.591]         if (TRUE) {
[09:29:46.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.591]         }
[09:29:46.591]         else {
[09:29:46.591]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.591]         }
[09:29:46.591]         base::close(...future.stdout)
[09:29:46.591]         ...future.stdout <- NULL
[09:29:46.591]     }
[09:29:46.591]     ...future.result$conditions <- ...future.conditions
[09:29:46.591]     ...future.result$finished <- base::Sys.time()
[09:29:46.591]     ...future.result
[09:29:46.591] }
[09:29:46.593] assign_globals() ...
[09:29:46.593] List of 11
[09:29:46.593]  $ ...future.FUN            :function (x, ...)  
[09:29:46.593]  $ x_FUN                    :function (x)  
[09:29:46.593]  $ times                    : int 0
[09:29:46.593]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.593]  $ stop_if_not              :function (...)  
[09:29:46.593]  $ dim                      : NULL
[09:29:46.593]  $ valid_types              : chr [1:2] "logical" "integer"
[09:29:46.593]  $ future.call.arguments    : list()
[09:29:46.593]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.593]  $ ...future.elements_ii    :List of 5
[09:29:46.593]   ..$ : int 1
[09:29:46.593]   ..$ : int 2
[09:29:46.593]   ..$ : int 3
[09:29:46.593]   ..$ : int 4
[09:29:46.593]   ..$ : int 5
[09:29:46.593]  $ ...future.seeds_ii       : NULL
[09:29:46.593]  $ ...future.globals.maxSize: NULL
[09:29:46.593]  - attr(*, "where")=List of 11
[09:29:46.593]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.593]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.593]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.593]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.593]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.593]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.593]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.593]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.593]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.593]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.593]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.593]  - attr(*, "resolved")= logi FALSE
[09:29:46.593]  - attr(*, "total_size")= num 95400
[09:29:46.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.593]  - attr(*, "already-done")= logi TRUE
[09:29:46.603] - copied ‘...future.FUN’ to environment
[09:29:46.603] - reassign environment for ‘x_FUN’
[09:29:46.603] - copied ‘x_FUN’ to environment
[09:29:46.603] - copied ‘times’ to environment
[09:29:46.603] - copied ‘stopf’ to environment
[09:29:46.603] - copied ‘stop_if_not’ to environment
[09:29:46.603] - copied ‘dim’ to environment
[09:29:46.603] - copied ‘valid_types’ to environment
[09:29:46.603] - copied ‘future.call.arguments’ to environment
[09:29:46.603] - copied ‘...future.elements_ii’ to environment
[09:29:46.604] - copied ‘...future.seeds_ii’ to environment
[09:29:46.604] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.604] assign_globals() ... done
[09:29:46.604] requestCore(): workers = 2
[09:29:46.606] MulticoreFuture started
[09:29:46.607] - Launch lazy future ... done
[09:29:46.607] run() for ‘MulticoreFuture’ ... done
[09:29:46.608] Created future:
[09:29:46.608] plan(): Setting new future strategy stack:
[09:29:46.608] List of future strategies:
[09:29:46.608] 1. sequential:
[09:29:46.608]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.608]    - tweaked: FALSE
[09:29:46.608]    - call: NULL
[09:29:46.609] plan(): nbrOfWorkers() = 1
[09:29:46.612] plan(): Setting new future strategy stack:
[09:29:46.612] List of future strategies:
[09:29:46.612] 1. multicore:
[09:29:46.612]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.612]    - tweaked: FALSE
[09:29:46.612]    - call: plan(strategy)
[09:29:46.617] plan(): nbrOfWorkers() = 2
[09:29:46.608] MulticoreFuture:
[09:29:46.608] Label: ‘future_vapply-1’
[09:29:46.608] Expression:
[09:29:46.608] {
[09:29:46.608]     do.call(function(...) {
[09:29:46.608]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.608]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.608]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.608]             on.exit(options(oopts), add = TRUE)
[09:29:46.608]         }
[09:29:46.608]         {
[09:29:46.608]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.608]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.608]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.608]             })
[09:29:46.608]         }
[09:29:46.608]     }, args = future.call.arguments)
[09:29:46.608] }
[09:29:46.608] Lazy evaluation: FALSE
[09:29:46.608] Asynchronous evaluation: TRUE
[09:29:46.608] Local evaluation: TRUE
[09:29:46.608] Environment: R_GlobalEnv
[09:29:46.608] Capture standard output: TRUE
[09:29:46.608] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.608] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.608] Packages: 1 packages (‘future.apply’)
[09:29:46.608] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.608] Resolved: TRUE
[09:29:46.608] Value: <not collected>
[09:29:46.608] Conditions captured: <none>
[09:29:46.608] Early signaling: FALSE
[09:29:46.608] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.608] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.618] Chunk #1 of 2 ... DONE
[09:29:46.618] Chunk #2 of 2 ...
[09:29:46.619]  - Finding globals in 'X' for chunk #2 ...
[09:29:46.619] getGlobalsAndPackages() ...
[09:29:46.619] Searching for globals...
[09:29:46.619] 
[09:29:46.620] Searching for globals ... DONE
[09:29:46.620] - globals: [0] <none>
[09:29:46.620] getGlobalsAndPackages() ... DONE
[09:29:46.620]    + additional globals found: [n=0] 
[09:29:46.620]    + additional namespaces needed: [n=0] 
[09:29:46.620]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:46.620]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.621]  - seeds: <none>
[09:29:46.621]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.621] getGlobalsAndPackages() ...
[09:29:46.621] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.621] Resolving globals: FALSE
[09:29:46.621] Tweak future expression to call with '...' arguments ...
[09:29:46.622] {
[09:29:46.622]     do.call(function(...) {
[09:29:46.622]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.622]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.622]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.622]             on.exit(options(oopts), add = TRUE)
[09:29:46.622]         }
[09:29:46.622]         {
[09:29:46.622]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.622]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.622]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.622]             })
[09:29:46.622]         }
[09:29:46.622]     }, args = future.call.arguments)
[09:29:46.622] }
[09:29:46.622] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.623] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.623] - packages: [1] ‘future.apply’
[09:29:46.623] getGlobalsAndPackages() ... DONE
[09:29:46.624] run() for ‘Future’ ...
[09:29:46.624] - state: ‘created’
[09:29:46.624] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:46.628] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.629] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:46.629]   - Field: ‘label’
[09:29:46.629]   - Field: ‘local’
[09:29:46.629]   - Field: ‘owner’
[09:29:46.629]   - Field: ‘envir’
[09:29:46.629]   - Field: ‘workers’
[09:29:46.629]   - Field: ‘packages’
[09:29:46.630]   - Field: ‘gc’
[09:29:46.630]   - Field: ‘job’
[09:29:46.630]   - Field: ‘conditions’
[09:29:46.630]   - Field: ‘expr’
[09:29:46.630]   - Field: ‘uuid’
[09:29:46.630]   - Field: ‘seed’
[09:29:46.630]   - Field: ‘version’
[09:29:46.631]   - Field: ‘result’
[09:29:46.631]   - Field: ‘asynchronous’
[09:29:46.631]   - Field: ‘calls’
[09:29:46.631]   - Field: ‘globals’
[09:29:46.631]   - Field: ‘stdout’
[09:29:46.631]   - Field: ‘earlySignal’
[09:29:46.631]   - Field: ‘lazy’
[09:29:46.631]   - Field: ‘state’
[09:29:46.632] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:46.632] - Launch lazy future ...
[09:29:46.632] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.632] Packages needed by future strategies (n = 0): <none>
[09:29:46.633] {
[09:29:46.633]     {
[09:29:46.633]         {
[09:29:46.633]             ...future.startTime <- base::Sys.time()
[09:29:46.633]             {
[09:29:46.633]                 {
[09:29:46.633]                   {
[09:29:46.633]                     {
[09:29:46.633]                       {
[09:29:46.633]                         base::local({
[09:29:46.633]                           has_future <- base::requireNamespace("future", 
[09:29:46.633]                             quietly = TRUE)
[09:29:46.633]                           if (has_future) {
[09:29:46.633]                             ns <- base::getNamespace("future")
[09:29:46.633]                             version <- ns[[".package"]][["version"]]
[09:29:46.633]                             if (is.null(version)) 
[09:29:46.633]                               version <- utils::packageVersion("future")
[09:29:46.633]                           }
[09:29:46.633]                           else {
[09:29:46.633]                             version <- NULL
[09:29:46.633]                           }
[09:29:46.633]                           if (!has_future || version < "1.8.0") {
[09:29:46.633]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.633]                               "", base::R.version$version.string), 
[09:29:46.633]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:46.633]                                 base::R.version$platform, 8 * 
[09:29:46.633]                                   base::.Machine$sizeof.pointer), 
[09:29:46.633]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.633]                                 "release", "version")], collapse = " "), 
[09:29:46.633]                               hostname = base::Sys.info()[["nodename"]])
[09:29:46.633]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.633]                               info)
[09:29:46.633]                             info <- base::paste(info, collapse = "; ")
[09:29:46.633]                             if (!has_future) {
[09:29:46.633]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.633]                                 info)
[09:29:46.633]                             }
[09:29:46.633]                             else {
[09:29:46.633]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.633]                                 info, version)
[09:29:46.633]                             }
[09:29:46.633]                             base::stop(msg)
[09:29:46.633]                           }
[09:29:46.633]                         })
[09:29:46.633]                       }
[09:29:46.633]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:46.633]                       base::options(mc.cores = 1L)
[09:29:46.633]                     }
[09:29:46.633]                     base::local({
[09:29:46.633]                       for (pkg in "future.apply") {
[09:29:46.633]                         base::loadNamespace(pkg)
[09:29:46.633]                         base::library(pkg, character.only = TRUE)
[09:29:46.633]                       }
[09:29:46.633]                     })
[09:29:46.633]                   }
[09:29:46.633]                   ...future.strategy.old <- future::plan("list")
[09:29:46.633]                   options(future.plan = NULL)
[09:29:46.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.633]                 }
[09:29:46.633]                 ...future.workdir <- getwd()
[09:29:46.633]             }
[09:29:46.633]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.633]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.633]         }
[09:29:46.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.633]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:46.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.633]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.633]             base::names(...future.oldOptions))
[09:29:46.633]     }
[09:29:46.633]     if (FALSE) {
[09:29:46.633]     }
[09:29:46.633]     else {
[09:29:46.633]         if (TRUE) {
[09:29:46.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.633]                 open = "w")
[09:29:46.633]         }
[09:29:46.633]         else {
[09:29:46.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.633]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.633]         }
[09:29:46.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.633]             base::sink(type = "output", split = FALSE)
[09:29:46.633]             base::close(...future.stdout)
[09:29:46.633]         }, add = TRUE)
[09:29:46.633]     }
[09:29:46.633]     ...future.frame <- base::sys.nframe()
[09:29:46.633]     ...future.conditions <- base::list()
[09:29:46.633]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.633]     if (FALSE) {
[09:29:46.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.633]     }
[09:29:46.633]     ...future.result <- base::tryCatch({
[09:29:46.633]         base::withCallingHandlers({
[09:29:46.633]             ...future.value <- base::withVisible(base::local({
[09:29:46.633]                 withCallingHandlers({
[09:29:46.633]                   {
[09:29:46.633]                     do.call(function(...) {
[09:29:46.633]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.633]                       if (!identical(...future.globals.maxSize.org, 
[09:29:46.633]                         ...future.globals.maxSize)) {
[09:29:46.633]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.633]                         on.exit(options(oopts), add = TRUE)
[09:29:46.633]                       }
[09:29:46.633]                       {
[09:29:46.633]                         lapply(seq_along(...future.elements_ii), 
[09:29:46.633]                           FUN = function(jj) {
[09:29:46.633]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.633]                             ...future.FUN(...future.X_jj, ...)
[09:29:46.633]                           })
[09:29:46.633]                       }
[09:29:46.633]                     }, args = future.call.arguments)
[09:29:46.633]                   }
[09:29:46.633]                 }, immediateCondition = function(cond) {
[09:29:46.633]                   save_rds <- function (object, pathname, ...) 
[09:29:46.633]                   {
[09:29:46.633]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:46.633]                     if (file_test("-f", pathname_tmp)) {
[09:29:46.633]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.633]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:46.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.633]                         fi_tmp[["mtime"]])
[09:29:46.633]                     }
[09:29:46.633]                     tryCatch({
[09:29:46.633]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:46.633]                     }, error = function(ex) {
[09:29:46.633]                       msg <- conditionMessage(ex)
[09:29:46.633]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.633]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:46.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.633]                         fi_tmp[["mtime"]], msg)
[09:29:46.633]                       ex$message <- msg
[09:29:46.633]                       stop(ex)
[09:29:46.633]                     })
[09:29:46.633]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:46.633]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:46.633]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:46.633]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.633]                       fi <- file.info(pathname)
[09:29:46.633]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:46.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.633]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:46.633]                         fi[["size"]], fi[["mtime"]])
[09:29:46.633]                       stop(msg)
[09:29:46.633]                     }
[09:29:46.633]                     invisible(pathname)
[09:29:46.633]                   }
[09:29:46.633]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:46.633]                     rootPath = tempdir()) 
[09:29:46.633]                   {
[09:29:46.633]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:46.633]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:46.633]                       tmpdir = path, fileext = ".rds")
[09:29:46.633]                     save_rds(obj, file)
[09:29:46.633]                   }
[09:29:46.633]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:46.633]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.633]                   {
[09:29:46.633]                     inherits <- base::inherits
[09:29:46.633]                     invokeRestart <- base::invokeRestart
[09:29:46.633]                     is.null <- base::is.null
[09:29:46.633]                     muffled <- FALSE
[09:29:46.633]                     if (inherits(cond, "message")) {
[09:29:46.633]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:46.633]                       if (muffled) 
[09:29:46.633]                         invokeRestart("muffleMessage")
[09:29:46.633]                     }
[09:29:46.633]                     else if (inherits(cond, "warning")) {
[09:29:46.633]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:46.633]                       if (muffled) 
[09:29:46.633]                         invokeRestart("muffleWarning")
[09:29:46.633]                     }
[09:29:46.633]                     else if (inherits(cond, "condition")) {
[09:29:46.633]                       if (!is.null(pattern)) {
[09:29:46.633]                         computeRestarts <- base::computeRestarts
[09:29:46.633]                         grepl <- base::grepl
[09:29:46.633]                         restarts <- computeRestarts(cond)
[09:29:46.633]                         for (restart in restarts) {
[09:29:46.633]                           name <- restart$name
[09:29:46.633]                           if (is.null(name)) 
[09:29:46.633]                             next
[09:29:46.633]                           if (!grepl(pattern, name)) 
[09:29:46.633]                             next
[09:29:46.633]                           invokeRestart(restart)
[09:29:46.633]                           muffled <- TRUE
[09:29:46.633]                           break
[09:29:46.633]                         }
[09:29:46.633]                       }
[09:29:46.633]                     }
[09:29:46.633]                     invisible(muffled)
[09:29:46.633]                   }
[09:29:46.633]                   muffleCondition(cond)
[09:29:46.633]                 })
[09:29:46.633]             }))
[09:29:46.633]             future::FutureResult(value = ...future.value$value, 
[09:29:46.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.633]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.633]                     ...future.globalenv.names))
[09:29:46.633]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.633]         }, condition = base::local({
[09:29:46.633]             c <- base::c
[09:29:46.633]             inherits <- base::inherits
[09:29:46.633]             invokeRestart <- base::invokeRestart
[09:29:46.633]             length <- base::length
[09:29:46.633]             list <- base::list
[09:29:46.633]             seq.int <- base::seq.int
[09:29:46.633]             signalCondition <- base::signalCondition
[09:29:46.633]             sys.calls <- base::sys.calls
[09:29:46.633]             `[[` <- base::`[[`
[09:29:46.633]             `+` <- base::`+`
[09:29:46.633]             `<<-` <- base::`<<-`
[09:29:46.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.633]                   3L)]
[09:29:46.633]             }
[09:29:46.633]             function(cond) {
[09:29:46.633]                 is_error <- inherits(cond, "error")
[09:29:46.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.633]                   NULL)
[09:29:46.633]                 if (is_error) {
[09:29:46.633]                   sessionInformation <- function() {
[09:29:46.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.633]                       search = base::search(), system = base::Sys.info())
[09:29:46.633]                   }
[09:29:46.633]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.633]                     cond$call), session = sessionInformation(), 
[09:29:46.633]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.633]                   signalCondition(cond)
[09:29:46.633]                 }
[09:29:46.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.633]                 "immediateCondition"))) {
[09:29:46.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.633]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.633]                   if (TRUE && !signal) {
[09:29:46.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.633]                     {
[09:29:46.633]                       inherits <- base::inherits
[09:29:46.633]                       invokeRestart <- base::invokeRestart
[09:29:46.633]                       is.null <- base::is.null
[09:29:46.633]                       muffled <- FALSE
[09:29:46.633]                       if (inherits(cond, "message")) {
[09:29:46.633]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.633]                         if (muffled) 
[09:29:46.633]                           invokeRestart("muffleMessage")
[09:29:46.633]                       }
[09:29:46.633]                       else if (inherits(cond, "warning")) {
[09:29:46.633]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.633]                         if (muffled) 
[09:29:46.633]                           invokeRestart("muffleWarning")
[09:29:46.633]                       }
[09:29:46.633]                       else if (inherits(cond, "condition")) {
[09:29:46.633]                         if (!is.null(pattern)) {
[09:29:46.633]                           computeRestarts <- base::computeRestarts
[09:29:46.633]                           grepl <- base::grepl
[09:29:46.633]                           restarts <- computeRestarts(cond)
[09:29:46.633]                           for (restart in restarts) {
[09:29:46.633]                             name <- restart$name
[09:29:46.633]                             if (is.null(name)) 
[09:29:46.633]                               next
[09:29:46.633]                             if (!grepl(pattern, name)) 
[09:29:46.633]                               next
[09:29:46.633]                             invokeRestart(restart)
[09:29:46.633]                             muffled <- TRUE
[09:29:46.633]                             break
[09:29:46.633]                           }
[09:29:46.633]                         }
[09:29:46.633]                       }
[09:29:46.633]                       invisible(muffled)
[09:29:46.633]                     }
[09:29:46.633]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.633]                   }
[09:29:46.633]                 }
[09:29:46.633]                 else {
[09:29:46.633]                   if (TRUE) {
[09:29:46.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.633]                     {
[09:29:46.633]                       inherits <- base::inherits
[09:29:46.633]                       invokeRestart <- base::invokeRestart
[09:29:46.633]                       is.null <- base::is.null
[09:29:46.633]                       muffled <- FALSE
[09:29:46.633]                       if (inherits(cond, "message")) {
[09:29:46.633]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.633]                         if (muffled) 
[09:29:46.633]                           invokeRestart("muffleMessage")
[09:29:46.633]                       }
[09:29:46.633]                       else if (inherits(cond, "warning")) {
[09:29:46.633]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.633]                         if (muffled) 
[09:29:46.633]                           invokeRestart("muffleWarning")
[09:29:46.633]                       }
[09:29:46.633]                       else if (inherits(cond, "condition")) {
[09:29:46.633]                         if (!is.null(pattern)) {
[09:29:46.633]                           computeRestarts <- base::computeRestarts
[09:29:46.633]                           grepl <- base::grepl
[09:29:46.633]                           restarts <- computeRestarts(cond)
[09:29:46.633]                           for (restart in restarts) {
[09:29:46.633]                             name <- restart$name
[09:29:46.633]                             if (is.null(name)) 
[09:29:46.633]                               next
[09:29:46.633]                             if (!grepl(pattern, name)) 
[09:29:46.633]                               next
[09:29:46.633]                             invokeRestart(restart)
[09:29:46.633]                             muffled <- TRUE
[09:29:46.633]                             break
[09:29:46.633]                           }
[09:29:46.633]                         }
[09:29:46.633]                       }
[09:29:46.633]                       invisible(muffled)
[09:29:46.633]                     }
[09:29:46.633]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.633]                   }
[09:29:46.633]                 }
[09:29:46.633]             }
[09:29:46.633]         }))
[09:29:46.633]     }, error = function(ex) {
[09:29:46.633]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.633]                 ...future.rng), started = ...future.startTime, 
[09:29:46.633]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.633]             version = "1.8"), class = "FutureResult")
[09:29:46.633]     }, finally = {
[09:29:46.633]         if (!identical(...future.workdir, getwd())) 
[09:29:46.633]             setwd(...future.workdir)
[09:29:46.633]         {
[09:29:46.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.633]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.633]             }
[09:29:46.633]             base::options(...future.oldOptions)
[09:29:46.633]             if (.Platform$OS.type == "windows") {
[09:29:46.633]                 old_names <- names(...future.oldEnvVars)
[09:29:46.633]                 envs <- base::Sys.getenv()
[09:29:46.633]                 names <- names(envs)
[09:29:46.633]                 common <- intersect(names, old_names)
[09:29:46.633]                 added <- setdiff(names, old_names)
[09:29:46.633]                 removed <- setdiff(old_names, names)
[09:29:46.633]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.633]                   envs[common]]
[09:29:46.633]                 NAMES <- toupper(changed)
[09:29:46.633]                 args <- list()
[09:29:46.633]                 for (kk in seq_along(NAMES)) {
[09:29:46.633]                   name <- changed[[kk]]
[09:29:46.633]                   NAME <- NAMES[[kk]]
[09:29:46.633]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.633]                     next
[09:29:46.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.633]                 }
[09:29:46.633]                 NAMES <- toupper(added)
[09:29:46.633]                 for (kk in seq_along(NAMES)) {
[09:29:46.633]                   name <- added[[kk]]
[09:29:46.633]                   NAME <- NAMES[[kk]]
[09:29:46.633]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.633]                     next
[09:29:46.633]                   args[[name]] <- ""
[09:29:46.633]                 }
[09:29:46.633]                 NAMES <- toupper(removed)
[09:29:46.633]                 for (kk in seq_along(NAMES)) {
[09:29:46.633]                   name <- removed[[kk]]
[09:29:46.633]                   NAME <- NAMES[[kk]]
[09:29:46.633]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.633]                     next
[09:29:46.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.633]                 }
[09:29:46.633]                 if (length(args) > 0) 
[09:29:46.633]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.633]             }
[09:29:46.633]             else {
[09:29:46.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.633]             }
[09:29:46.633]             {
[09:29:46.633]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.633]                   0L) {
[09:29:46.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.633]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.633]                   base::options(opts)
[09:29:46.633]                 }
[09:29:46.633]                 {
[09:29:46.633]                   {
[09:29:46.633]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:46.633]                     NULL
[09:29:46.633]                   }
[09:29:46.633]                   options(future.plan = NULL)
[09:29:46.633]                   if (is.na(NA_character_)) 
[09:29:46.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.633]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.633]                     .init = FALSE)
[09:29:46.633]                 }
[09:29:46.633]             }
[09:29:46.633]         }
[09:29:46.633]     })
[09:29:46.633]     if (TRUE) {
[09:29:46.633]         base::sink(type = "output", split = FALSE)
[09:29:46.633]         if (TRUE) {
[09:29:46.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.633]         }
[09:29:46.633]         else {
[09:29:46.633]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.633]         }
[09:29:46.633]         base::close(...future.stdout)
[09:29:46.633]         ...future.stdout <- NULL
[09:29:46.633]     }
[09:29:46.633]     ...future.result$conditions <- ...future.conditions
[09:29:46.633]     ...future.result$finished <- base::Sys.time()
[09:29:46.633]     ...future.result
[09:29:46.633] }
[09:29:46.637] assign_globals() ...
[09:29:46.637] List of 11
[09:29:46.637]  $ ...future.FUN            :function (x, ...)  
[09:29:46.637]  $ x_FUN                    :function (x)  
[09:29:46.637]  $ times                    : int 0
[09:29:46.637]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.637]  $ stop_if_not              :function (...)  
[09:29:46.637]  $ dim                      : NULL
[09:29:46.637]  $ valid_types              : chr [1:2] "logical" "integer"
[09:29:46.637]  $ future.call.arguments    : list()
[09:29:46.637]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.637]  $ ...future.elements_ii    :List of 5
[09:29:46.637]   ..$ : int 6
[09:29:46.637]   ..$ : int 7
[09:29:46.637]   ..$ : int 8
[09:29:46.637]   ..$ : int 9
[09:29:46.637]   ..$ : int 10
[09:29:46.637]  $ ...future.seeds_ii       : NULL
[09:29:46.637]  $ ...future.globals.maxSize: NULL
[09:29:46.637]  - attr(*, "where")=List of 11
[09:29:46.637]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.637]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.637]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.637]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.637]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.637]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.637]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.637]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.637]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.637]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.637]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.637]  - attr(*, "resolved")= logi FALSE
[09:29:46.637]  - attr(*, "total_size")= num 95400
[09:29:46.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.637]  - attr(*, "already-done")= logi TRUE
[09:29:46.651] - copied ‘...future.FUN’ to environment
[09:29:46.651] - reassign environment for ‘x_FUN’
[09:29:46.651] - copied ‘x_FUN’ to environment
[09:29:46.651] - copied ‘times’ to environment
[09:29:46.651] - copied ‘stopf’ to environment
[09:29:46.651] - copied ‘stop_if_not’ to environment
[09:29:46.651] - copied ‘dim’ to environment
[09:29:46.652] - copied ‘valid_types’ to environment
[09:29:46.652] - copied ‘future.call.arguments’ to environment
[09:29:46.652] - copied ‘...future.elements_ii’ to environment
[09:29:46.652] - copied ‘...future.seeds_ii’ to environment
[09:29:46.652] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.652] assign_globals() ... done
[09:29:46.653] requestCore(): workers = 2
[09:29:46.655] MulticoreFuture started
[09:29:46.656] - Launch lazy future ... done
[09:29:46.656] run() for ‘MulticoreFuture’ ... done
[09:29:46.657] Created future:
[09:29:46.657] plan(): Setting new future strategy stack:
[09:29:46.658] List of future strategies:
[09:29:46.658] 1. sequential:
[09:29:46.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.658]    - tweaked: FALSE
[09:29:46.658]    - call: NULL
[09:29:46.659] plan(): nbrOfWorkers() = 1
[09:29:46.661] plan(): Setting new future strategy stack:
[09:29:46.661] List of future strategies:
[09:29:46.661] 1. multicore:
[09:29:46.661]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.661]    - tweaked: FALSE
[09:29:46.661]    - call: plan(strategy)
[09:29:46.667] plan(): nbrOfWorkers() = 2
[09:29:46.657] MulticoreFuture:
[09:29:46.657] Label: ‘future_vapply-2’
[09:29:46.657] Expression:
[09:29:46.657] {
[09:29:46.657]     do.call(function(...) {
[09:29:46.657]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.657]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.657]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.657]             on.exit(options(oopts), add = TRUE)
[09:29:46.657]         }
[09:29:46.657]         {
[09:29:46.657]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.657]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.657]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.657]             })
[09:29:46.657]         }
[09:29:46.657]     }, args = future.call.arguments)
[09:29:46.657] }
[09:29:46.657] Lazy evaluation: FALSE
[09:29:46.657] Asynchronous evaluation: TRUE
[09:29:46.657] Local evaluation: TRUE
[09:29:46.657] Environment: R_GlobalEnv
[09:29:46.657] Capture standard output: TRUE
[09:29:46.657] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.657] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.657] Packages: 1 packages (‘future.apply’)
[09:29:46.657] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.657] Resolved: TRUE
[09:29:46.657] Value: <not collected>
[09:29:46.657] Conditions captured: <none>
[09:29:46.657] Early signaling: FALSE
[09:29:46.657] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.657] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.668] Chunk #2 of 2 ... DONE
[09:29:46.668] Launching 2 futures (chunks) ... DONE
[09:29:46.668] Resolving 2 futures (chunks) ...
[09:29:46.669] resolve() on list ...
[09:29:46.669]  recursive: 0
[09:29:46.669]  length: 2
[09:29:46.669] 
[09:29:46.669] Future #1
[09:29:46.669] result() for MulticoreFuture ...
[09:29:46.670] result() for MulticoreFuture ...
[09:29:46.670] result() for MulticoreFuture ... done
[09:29:46.671] result() for MulticoreFuture ... done
[09:29:46.671] result() for MulticoreFuture ...
[09:29:46.671] result() for MulticoreFuture ... done
[09:29:46.671] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:46.671] - nx: 2
[09:29:46.671] - relay: TRUE
[09:29:46.671] - stdout: TRUE
[09:29:46.672] - signal: TRUE
[09:29:46.672] - resignal: FALSE
[09:29:46.672] - force: TRUE
[09:29:46.672] - relayed: [n=2] FALSE, FALSE
[09:29:46.672] - queued futures: [n=2] FALSE, FALSE
[09:29:46.672]  - until=1
[09:29:46.672]  - relaying element #1
[09:29:46.673] result() for MulticoreFuture ...
[09:29:46.673] result() for MulticoreFuture ... done
[09:29:46.673] result() for MulticoreFuture ...
[09:29:46.673] result() for MulticoreFuture ... done
[09:29:46.673] result() for MulticoreFuture ...
[09:29:46.673] result() for MulticoreFuture ... done
[09:29:46.673] result() for MulticoreFuture ...
[09:29:46.674] result() for MulticoreFuture ... done
[09:29:46.674] - relayed: [n=2] TRUE, FALSE
[09:29:46.674] - queued futures: [n=2] TRUE, FALSE
[09:29:46.674] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:46.674]  length: 1 (resolved future 1)
[09:29:46.674] Future #2
[09:29:46.675] result() for MulticoreFuture ...
[09:29:46.675] result() for MulticoreFuture ...
[09:29:46.675] result() for MulticoreFuture ... done
[09:29:46.675] result() for MulticoreFuture ... done
[09:29:46.676] result() for MulticoreFuture ...
[09:29:46.676] result() for MulticoreFuture ... done
[09:29:46.676] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:46.676] - nx: 2
[09:29:46.676] - relay: TRUE
[09:29:46.676] - stdout: TRUE
[09:29:46.676] - signal: TRUE
[09:29:46.676] - resignal: FALSE
[09:29:46.677] - force: TRUE
[09:29:46.677] - relayed: [n=2] TRUE, FALSE
[09:29:46.677] - queued futures: [n=2] TRUE, FALSE
[09:29:46.677]  - until=2
[09:29:46.677]  - relaying element #2
[09:29:46.677] result() for MulticoreFuture ...
[09:29:46.677] result() for MulticoreFuture ... done
[09:29:46.677] result() for MulticoreFuture ...
[09:29:46.678] result() for MulticoreFuture ... done
[09:29:46.678] result() for MulticoreFuture ...
[09:29:46.678] result() for MulticoreFuture ... done
[09:29:46.678] result() for MulticoreFuture ...
[09:29:46.678] result() for MulticoreFuture ... done
[09:29:46.678] - relayed: [n=2] TRUE, TRUE
[09:29:46.678] - queued futures: [n=2] TRUE, TRUE
[09:29:46.678] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:46.678]  length: 0 (resolved future 2)
[09:29:46.678] Relaying remaining futures
[09:29:46.679] signalConditionsASAP(NULL, pos=0) ...
[09:29:46.679] - nx: 2
[09:29:46.679] - relay: TRUE
[09:29:46.679] - stdout: TRUE
[09:29:46.679] - signal: TRUE
[09:29:46.679] - resignal: FALSE
[09:29:46.679] - force: TRUE
[09:29:46.679] - relayed: [n=2] TRUE, TRUE
[09:29:46.679] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:46.680] - relayed: [n=2] TRUE, TRUE
[09:29:46.680] - queued futures: [n=2] TRUE, TRUE
[09:29:46.680] signalConditionsASAP(NULL, pos=0) ... done
[09:29:46.680] resolve() on list ... DONE
[09:29:46.680] result() for MulticoreFuture ...
[09:29:46.680] result() for MulticoreFuture ... done
[09:29:46.680] result() for MulticoreFuture ...
[09:29:46.680] result() for MulticoreFuture ... done
[09:29:46.681] result() for MulticoreFuture ...
[09:29:46.681] result() for MulticoreFuture ... done
[09:29:46.681] result() for MulticoreFuture ...
[09:29:46.681] result() for MulticoreFuture ... done
[09:29:46.681]  - Number of value chunks collected: 2
[09:29:46.681] Resolving 2 futures (chunks) ... DONE
[09:29:46.681] Reducing values from 2 chunks ...
[09:29:46.681]  - Number of values collected after concatenation: 10
[09:29:46.681]  - Number of values expected: 10
[09:29:46.682] Reducing values from 2 chunks ... DONE
[09:29:46.682] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[09:29:46.683] future_lapply() ...
[09:29:46.688] Number of chunks: 2
[09:29:46.689] getGlobalsAndPackagesXApply() ...
[09:29:46.689]  - future.globals: TRUE
[09:29:46.689] getGlobalsAndPackages() ...
[09:29:46.689] Searching for globals...
[09:29:46.694] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:46.694] Searching for globals ... DONE
[09:29:46.694] Resolving globals: FALSE
[09:29:46.696] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[09:29:46.696] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:46.696] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.696] - packages: [1] ‘future.apply’
[09:29:46.697] getGlobalsAndPackages() ... DONE
[09:29:46.697]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.697]  - needed namespaces: [n=1] ‘future.apply’
[09:29:46.697] Finding globals ... DONE
[09:29:46.697]  - use_args: TRUE
[09:29:46.697]  - Getting '...' globals ...
[09:29:46.697] resolve() on list ...
[09:29:46.698]  recursive: 0
[09:29:46.698]  length: 1
[09:29:46.698]  elements: ‘...’
[09:29:46.698]  length: 0 (resolved future 1)
[09:29:46.698] resolve() on list ... DONE
[09:29:46.698]    - '...' content: [n=0] 
[09:29:46.698] List of 1
[09:29:46.698]  $ ...: list()
[09:29:46.698]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.698]  - attr(*, "where")=List of 1
[09:29:46.698]   ..$ ...:<environment: 0x561d364c40d8> 
[09:29:46.698]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.698]  - attr(*, "resolved")= logi TRUE
[09:29:46.698]  - attr(*, "total_size")= num NA
[09:29:46.701]  - Getting '...' globals ... DONE
[09:29:46.701] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:46.701] List of 8
[09:29:46.701]  $ ...future.FUN:function (x, ...)  
[09:29:46.701]  $ x_FUN        :function (x)  
[09:29:46.701]  $ times        : int 1
[09:29:46.701]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.701]  $ stop_if_not  :function (...)  
[09:29:46.701]  $ dim          : NULL
[09:29:46.701]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:46.701]  $ ...          : list()
[09:29:46.701]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.701]  - attr(*, "where")=List of 8
[09:29:46.701]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.701]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:46.701]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:46.701]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:46.701]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:46.701]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:46.701]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:46.701]   ..$ ...          :<environment: 0x561d364c40d8> 
[09:29:46.701]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.701]  - attr(*, "resolved")= logi FALSE
[09:29:46.701]  - attr(*, "total_size")= num 94336
[09:29:46.706] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:46.706] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.706] Number of futures (= number of chunks): 2
[09:29:46.706] Launching 2 futures (chunks) ...
[09:29:46.707] Chunk #1 of 2 ...
[09:29:46.707]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.707] getGlobalsAndPackages() ...
[09:29:46.707] Searching for globals...
[09:29:46.707] 
[09:29:46.707] Searching for globals ... DONE
[09:29:46.707] - globals: [0] <none>
[09:29:46.707] getGlobalsAndPackages() ... DONE
[09:29:46.707]    + additional globals found: [n=0] 
[09:29:46.708]    + additional namespaces needed: [n=0] 
[09:29:46.708]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.708]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.708]  - seeds: <none>
[09:29:46.708]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.708] getGlobalsAndPackages() ...
[09:29:46.708] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.708] Resolving globals: FALSE
[09:29:46.708] Tweak future expression to call with '...' arguments ...
[09:29:46.708] {
[09:29:46.708]     do.call(function(...) {
[09:29:46.708]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.708]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.708]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.708]             on.exit(options(oopts), add = TRUE)
[09:29:46.708]         }
[09:29:46.708]         {
[09:29:46.708]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.708]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.708]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.708]             })
[09:29:46.708]         }
[09:29:46.708]     }, args = future.call.arguments)
[09:29:46.708] }
[09:29:46.709] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.709] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.709] - packages: [1] ‘future.apply’
[09:29:46.709] getGlobalsAndPackages() ... DONE
[09:29:46.710] run() for ‘Future’ ...
[09:29:46.710] - state: ‘created’
[09:29:46.710] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:46.713] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:46.714]   - Field: ‘label’
[09:29:46.714]   - Field: ‘local’
[09:29:46.714]   - Field: ‘owner’
[09:29:46.714]   - Field: ‘envir’
[09:29:46.714]   - Field: ‘workers’
[09:29:46.714]   - Field: ‘packages’
[09:29:46.714]   - Field: ‘gc’
[09:29:46.714]   - Field: ‘job’
[09:29:46.714]   - Field: ‘conditions’
[09:29:46.715]   - Field: ‘expr’
[09:29:46.715]   - Field: ‘uuid’
[09:29:46.715]   - Field: ‘seed’
[09:29:46.715]   - Field: ‘version’
[09:29:46.715]   - Field: ‘result’
[09:29:46.715]   - Field: ‘asynchronous’
[09:29:46.715]   - Field: ‘calls’
[09:29:46.715]   - Field: ‘globals’
[09:29:46.715]   - Field: ‘stdout’
[09:29:46.715]   - Field: ‘earlySignal’
[09:29:46.715]   - Field: ‘lazy’
[09:29:46.716]   - Field: ‘state’
[09:29:46.716] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:46.716] - Launch lazy future ...
[09:29:46.716] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.716] Packages needed by future strategies (n = 0): <none>
[09:29:46.718] {
[09:29:46.718]     {
[09:29:46.718]         {
[09:29:46.718]             ...future.startTime <- base::Sys.time()
[09:29:46.718]             {
[09:29:46.718]                 {
[09:29:46.718]                   {
[09:29:46.718]                     {
[09:29:46.718]                       {
[09:29:46.718]                         base::local({
[09:29:46.718]                           has_future <- base::requireNamespace("future", 
[09:29:46.718]                             quietly = TRUE)
[09:29:46.718]                           if (has_future) {
[09:29:46.718]                             ns <- base::getNamespace("future")
[09:29:46.718]                             version <- ns[[".package"]][["version"]]
[09:29:46.718]                             if (is.null(version)) 
[09:29:46.718]                               version <- utils::packageVersion("future")
[09:29:46.718]                           }
[09:29:46.718]                           else {
[09:29:46.718]                             version <- NULL
[09:29:46.718]                           }
[09:29:46.718]                           if (!has_future || version < "1.8.0") {
[09:29:46.718]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.718]                               "", base::R.version$version.string), 
[09:29:46.718]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:46.718]                                 base::R.version$platform, 8 * 
[09:29:46.718]                                   base::.Machine$sizeof.pointer), 
[09:29:46.718]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.718]                                 "release", "version")], collapse = " "), 
[09:29:46.718]                               hostname = base::Sys.info()[["nodename"]])
[09:29:46.718]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.718]                               info)
[09:29:46.718]                             info <- base::paste(info, collapse = "; ")
[09:29:46.718]                             if (!has_future) {
[09:29:46.718]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.718]                                 info)
[09:29:46.718]                             }
[09:29:46.718]                             else {
[09:29:46.718]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.718]                                 info, version)
[09:29:46.718]                             }
[09:29:46.718]                             base::stop(msg)
[09:29:46.718]                           }
[09:29:46.718]                         })
[09:29:46.718]                       }
[09:29:46.718]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:46.718]                       base::options(mc.cores = 1L)
[09:29:46.718]                     }
[09:29:46.718]                     base::local({
[09:29:46.718]                       for (pkg in "future.apply") {
[09:29:46.718]                         base::loadNamespace(pkg)
[09:29:46.718]                         base::library(pkg, character.only = TRUE)
[09:29:46.718]                       }
[09:29:46.718]                     })
[09:29:46.718]                   }
[09:29:46.718]                   ...future.strategy.old <- future::plan("list")
[09:29:46.718]                   options(future.plan = NULL)
[09:29:46.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.718]                 }
[09:29:46.718]                 ...future.workdir <- getwd()
[09:29:46.718]             }
[09:29:46.718]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.718]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.718]         }
[09:29:46.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.718]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:46.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.718]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.718]             base::names(...future.oldOptions))
[09:29:46.718]     }
[09:29:46.718]     if (FALSE) {
[09:29:46.718]     }
[09:29:46.718]     else {
[09:29:46.718]         if (TRUE) {
[09:29:46.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.718]                 open = "w")
[09:29:46.718]         }
[09:29:46.718]         else {
[09:29:46.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.718]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.718]         }
[09:29:46.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.718]             base::sink(type = "output", split = FALSE)
[09:29:46.718]             base::close(...future.stdout)
[09:29:46.718]         }, add = TRUE)
[09:29:46.718]     }
[09:29:46.718]     ...future.frame <- base::sys.nframe()
[09:29:46.718]     ...future.conditions <- base::list()
[09:29:46.718]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.718]     if (FALSE) {
[09:29:46.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.718]     }
[09:29:46.718]     ...future.result <- base::tryCatch({
[09:29:46.718]         base::withCallingHandlers({
[09:29:46.718]             ...future.value <- base::withVisible(base::local({
[09:29:46.718]                 withCallingHandlers({
[09:29:46.718]                   {
[09:29:46.718]                     do.call(function(...) {
[09:29:46.718]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.718]                       if (!identical(...future.globals.maxSize.org, 
[09:29:46.718]                         ...future.globals.maxSize)) {
[09:29:46.718]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.718]                         on.exit(options(oopts), add = TRUE)
[09:29:46.718]                       }
[09:29:46.718]                       {
[09:29:46.718]                         lapply(seq_along(...future.elements_ii), 
[09:29:46.718]                           FUN = function(jj) {
[09:29:46.718]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.718]                             ...future.FUN(...future.X_jj, ...)
[09:29:46.718]                           })
[09:29:46.718]                       }
[09:29:46.718]                     }, args = future.call.arguments)
[09:29:46.718]                   }
[09:29:46.718]                 }, immediateCondition = function(cond) {
[09:29:46.718]                   save_rds <- function (object, pathname, ...) 
[09:29:46.718]                   {
[09:29:46.718]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:46.718]                     if (file_test("-f", pathname_tmp)) {
[09:29:46.718]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.718]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:46.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.718]                         fi_tmp[["mtime"]])
[09:29:46.718]                     }
[09:29:46.718]                     tryCatch({
[09:29:46.718]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:46.718]                     }, error = function(ex) {
[09:29:46.718]                       msg <- conditionMessage(ex)
[09:29:46.718]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.718]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:46.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.718]                         fi_tmp[["mtime"]], msg)
[09:29:46.718]                       ex$message <- msg
[09:29:46.718]                       stop(ex)
[09:29:46.718]                     })
[09:29:46.718]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:46.718]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:46.718]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:46.718]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.718]                       fi <- file.info(pathname)
[09:29:46.718]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:46.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.718]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:46.718]                         fi[["size"]], fi[["mtime"]])
[09:29:46.718]                       stop(msg)
[09:29:46.718]                     }
[09:29:46.718]                     invisible(pathname)
[09:29:46.718]                   }
[09:29:46.718]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:46.718]                     rootPath = tempdir()) 
[09:29:46.718]                   {
[09:29:46.718]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:46.718]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:46.718]                       tmpdir = path, fileext = ".rds")
[09:29:46.718]                     save_rds(obj, file)
[09:29:46.718]                   }
[09:29:46.718]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:46.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.718]                   {
[09:29:46.718]                     inherits <- base::inherits
[09:29:46.718]                     invokeRestart <- base::invokeRestart
[09:29:46.718]                     is.null <- base::is.null
[09:29:46.718]                     muffled <- FALSE
[09:29:46.718]                     if (inherits(cond, "message")) {
[09:29:46.718]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:46.718]                       if (muffled) 
[09:29:46.718]                         invokeRestart("muffleMessage")
[09:29:46.718]                     }
[09:29:46.718]                     else if (inherits(cond, "warning")) {
[09:29:46.718]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:46.718]                       if (muffled) 
[09:29:46.718]                         invokeRestart("muffleWarning")
[09:29:46.718]                     }
[09:29:46.718]                     else if (inherits(cond, "condition")) {
[09:29:46.718]                       if (!is.null(pattern)) {
[09:29:46.718]                         computeRestarts <- base::computeRestarts
[09:29:46.718]                         grepl <- base::grepl
[09:29:46.718]                         restarts <- computeRestarts(cond)
[09:29:46.718]                         for (restart in restarts) {
[09:29:46.718]                           name <- restart$name
[09:29:46.718]                           if (is.null(name)) 
[09:29:46.718]                             next
[09:29:46.718]                           if (!grepl(pattern, name)) 
[09:29:46.718]                             next
[09:29:46.718]                           invokeRestart(restart)
[09:29:46.718]                           muffled <- TRUE
[09:29:46.718]                           break
[09:29:46.718]                         }
[09:29:46.718]                       }
[09:29:46.718]                     }
[09:29:46.718]                     invisible(muffled)
[09:29:46.718]                   }
[09:29:46.718]                   muffleCondition(cond)
[09:29:46.718]                 })
[09:29:46.718]             }))
[09:29:46.718]             future::FutureResult(value = ...future.value$value, 
[09:29:46.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.718]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.718]                     ...future.globalenv.names))
[09:29:46.718]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.718]         }, condition = base::local({
[09:29:46.718]             c <- base::c
[09:29:46.718]             inherits <- base::inherits
[09:29:46.718]             invokeRestart <- base::invokeRestart
[09:29:46.718]             length <- base::length
[09:29:46.718]             list <- base::list
[09:29:46.718]             seq.int <- base::seq.int
[09:29:46.718]             signalCondition <- base::signalCondition
[09:29:46.718]             sys.calls <- base::sys.calls
[09:29:46.718]             `[[` <- base::`[[`
[09:29:46.718]             `+` <- base::`+`
[09:29:46.718]             `<<-` <- base::`<<-`
[09:29:46.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.718]                   3L)]
[09:29:46.718]             }
[09:29:46.718]             function(cond) {
[09:29:46.718]                 is_error <- inherits(cond, "error")
[09:29:46.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.718]                   NULL)
[09:29:46.718]                 if (is_error) {
[09:29:46.718]                   sessionInformation <- function() {
[09:29:46.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.718]                       search = base::search(), system = base::Sys.info())
[09:29:46.718]                   }
[09:29:46.718]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.718]                     cond$call), session = sessionInformation(), 
[09:29:46.718]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.718]                   signalCondition(cond)
[09:29:46.718]                 }
[09:29:46.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.718]                 "immediateCondition"))) {
[09:29:46.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.718]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.718]                   if (TRUE && !signal) {
[09:29:46.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.718]                     {
[09:29:46.718]                       inherits <- base::inherits
[09:29:46.718]                       invokeRestart <- base::invokeRestart
[09:29:46.718]                       is.null <- base::is.null
[09:29:46.718]                       muffled <- FALSE
[09:29:46.718]                       if (inherits(cond, "message")) {
[09:29:46.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.718]                         if (muffled) 
[09:29:46.718]                           invokeRestart("muffleMessage")
[09:29:46.718]                       }
[09:29:46.718]                       else if (inherits(cond, "warning")) {
[09:29:46.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.718]                         if (muffled) 
[09:29:46.718]                           invokeRestart("muffleWarning")
[09:29:46.718]                       }
[09:29:46.718]                       else if (inherits(cond, "condition")) {
[09:29:46.718]                         if (!is.null(pattern)) {
[09:29:46.718]                           computeRestarts <- base::computeRestarts
[09:29:46.718]                           grepl <- base::grepl
[09:29:46.718]                           restarts <- computeRestarts(cond)
[09:29:46.718]                           for (restart in restarts) {
[09:29:46.718]                             name <- restart$name
[09:29:46.718]                             if (is.null(name)) 
[09:29:46.718]                               next
[09:29:46.718]                             if (!grepl(pattern, name)) 
[09:29:46.718]                               next
[09:29:46.718]                             invokeRestart(restart)
[09:29:46.718]                             muffled <- TRUE
[09:29:46.718]                             break
[09:29:46.718]                           }
[09:29:46.718]                         }
[09:29:46.718]                       }
[09:29:46.718]                       invisible(muffled)
[09:29:46.718]                     }
[09:29:46.718]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.718]                   }
[09:29:46.718]                 }
[09:29:46.718]                 else {
[09:29:46.718]                   if (TRUE) {
[09:29:46.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.718]                     {
[09:29:46.718]                       inherits <- base::inherits
[09:29:46.718]                       invokeRestart <- base::invokeRestart
[09:29:46.718]                       is.null <- base::is.null
[09:29:46.718]                       muffled <- FALSE
[09:29:46.718]                       if (inherits(cond, "message")) {
[09:29:46.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.718]                         if (muffled) 
[09:29:46.718]                           invokeRestart("muffleMessage")
[09:29:46.718]                       }
[09:29:46.718]                       else if (inherits(cond, "warning")) {
[09:29:46.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.718]                         if (muffled) 
[09:29:46.718]                           invokeRestart("muffleWarning")
[09:29:46.718]                       }
[09:29:46.718]                       else if (inherits(cond, "condition")) {
[09:29:46.718]                         if (!is.null(pattern)) {
[09:29:46.718]                           computeRestarts <- base::computeRestarts
[09:29:46.718]                           grepl <- base::grepl
[09:29:46.718]                           restarts <- computeRestarts(cond)
[09:29:46.718]                           for (restart in restarts) {
[09:29:46.718]                             name <- restart$name
[09:29:46.718]                             if (is.null(name)) 
[09:29:46.718]                               next
[09:29:46.718]                             if (!grepl(pattern, name)) 
[09:29:46.718]                               next
[09:29:46.718]                             invokeRestart(restart)
[09:29:46.718]                             muffled <- TRUE
[09:29:46.718]                             break
[09:29:46.718]                           }
[09:29:46.718]                         }
[09:29:46.718]                       }
[09:29:46.718]                       invisible(muffled)
[09:29:46.718]                     }
[09:29:46.718]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.718]                   }
[09:29:46.718]                 }
[09:29:46.718]             }
[09:29:46.718]         }))
[09:29:46.718]     }, error = function(ex) {
[09:29:46.718]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.718]                 ...future.rng), started = ...future.startTime, 
[09:29:46.718]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.718]             version = "1.8"), class = "FutureResult")
[09:29:46.718]     }, finally = {
[09:29:46.718]         if (!identical(...future.workdir, getwd())) 
[09:29:46.718]             setwd(...future.workdir)
[09:29:46.718]         {
[09:29:46.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.718]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.718]             }
[09:29:46.718]             base::options(...future.oldOptions)
[09:29:46.718]             if (.Platform$OS.type == "windows") {
[09:29:46.718]                 old_names <- names(...future.oldEnvVars)
[09:29:46.718]                 envs <- base::Sys.getenv()
[09:29:46.718]                 names <- names(envs)
[09:29:46.718]                 common <- intersect(names, old_names)
[09:29:46.718]                 added <- setdiff(names, old_names)
[09:29:46.718]                 removed <- setdiff(old_names, names)
[09:29:46.718]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.718]                   envs[common]]
[09:29:46.718]                 NAMES <- toupper(changed)
[09:29:46.718]                 args <- list()
[09:29:46.718]                 for (kk in seq_along(NAMES)) {
[09:29:46.718]                   name <- changed[[kk]]
[09:29:46.718]                   NAME <- NAMES[[kk]]
[09:29:46.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.718]                     next
[09:29:46.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.718]                 }
[09:29:46.718]                 NAMES <- toupper(added)
[09:29:46.718]                 for (kk in seq_along(NAMES)) {
[09:29:46.718]                   name <- added[[kk]]
[09:29:46.718]                   NAME <- NAMES[[kk]]
[09:29:46.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.718]                     next
[09:29:46.718]                   args[[name]] <- ""
[09:29:46.718]                 }
[09:29:46.718]                 NAMES <- toupper(removed)
[09:29:46.718]                 for (kk in seq_along(NAMES)) {
[09:29:46.718]                   name <- removed[[kk]]
[09:29:46.718]                   NAME <- NAMES[[kk]]
[09:29:46.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.718]                     next
[09:29:46.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.718]                 }
[09:29:46.718]                 if (length(args) > 0) 
[09:29:46.718]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.718]             }
[09:29:46.718]             else {
[09:29:46.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.718]             }
[09:29:46.718]             {
[09:29:46.718]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.718]                   0L) {
[09:29:46.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.718]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.718]                   base::options(opts)
[09:29:46.718]                 }
[09:29:46.718]                 {
[09:29:46.718]                   {
[09:29:46.718]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:46.718]                     NULL
[09:29:46.718]                   }
[09:29:46.718]                   options(future.plan = NULL)
[09:29:46.718]                   if (is.na(NA_character_)) 
[09:29:46.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.718]                     .init = FALSE)
[09:29:46.718]                 }
[09:29:46.718]             }
[09:29:46.718]         }
[09:29:46.718]     })
[09:29:46.718]     if (TRUE) {
[09:29:46.718]         base::sink(type = "output", split = FALSE)
[09:29:46.718]         if (TRUE) {
[09:29:46.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.718]         }
[09:29:46.718]         else {
[09:29:46.718]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.718]         }
[09:29:46.718]         base::close(...future.stdout)
[09:29:46.718]         ...future.stdout <- NULL
[09:29:46.718]     }
[09:29:46.718]     ...future.result$conditions <- ...future.conditions
[09:29:46.718]     ...future.result$finished <- base::Sys.time()
[09:29:46.718]     ...future.result
[09:29:46.718] }
[09:29:46.720] assign_globals() ...
[09:29:46.720] List of 11
[09:29:46.720]  $ ...future.FUN            :function (x, ...)  
[09:29:46.720]  $ x_FUN                    :function (x)  
[09:29:46.720]  $ times                    : int 1
[09:29:46.720]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.720]  $ stop_if_not              :function (...)  
[09:29:46.720]  $ dim                      : NULL
[09:29:46.720]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:46.720]  $ future.call.arguments    : list()
[09:29:46.720]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.720]  $ ...future.elements_ii    :List of 5
[09:29:46.720]   ..$ : int 1
[09:29:46.720]   ..$ : int 2
[09:29:46.720]   ..$ : int 3
[09:29:46.720]   ..$ : int 4
[09:29:46.720]   ..$ : int 5
[09:29:46.720]  $ ...future.seeds_ii       : NULL
[09:29:46.720]  $ ...future.globals.maxSize: NULL
[09:29:46.720]  - attr(*, "where")=List of 11
[09:29:46.720]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.720]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.720]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.720]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.720]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.720]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.720]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.720]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.720]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.720]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.720]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.720]  - attr(*, "resolved")= logi FALSE
[09:29:46.720]  - attr(*, "total_size")= num 94336
[09:29:46.720]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.720]  - attr(*, "already-done")= logi TRUE
[09:29:46.729] - copied ‘...future.FUN’ to environment
[09:29:46.729] - copied ‘x_FUN’ to environment
[09:29:46.729] - copied ‘times’ to environment
[09:29:46.729] - copied ‘stopf’ to environment
[09:29:46.729] - copied ‘stop_if_not’ to environment
[09:29:46.729] - copied ‘dim’ to environment
[09:29:46.729] - copied ‘valid_types’ to environment
[09:29:46.729] - copied ‘future.call.arguments’ to environment
[09:29:46.729] - copied ‘...future.elements_ii’ to environment
[09:29:46.729] - copied ‘...future.seeds_ii’ to environment
[09:29:46.729] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.730] assign_globals() ... done
[09:29:46.730] requestCore(): workers = 2
[09:29:46.732] MulticoreFuture started
[09:29:46.732] - Launch lazy future ... done
[09:29:46.732] run() for ‘MulticoreFuture’ ... done
[09:29:46.732] Created future:
[09:29:46.733] plan(): Setting new future strategy stack:
[09:29:46.733] List of future strategies:
[09:29:46.733] 1. sequential:
[09:29:46.733]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.733]    - tweaked: FALSE
[09:29:46.733]    - call: NULL
[09:29:46.734] plan(): nbrOfWorkers() = 1
[09:29:46.736] plan(): Setting new future strategy stack:
[09:29:46.737] List of future strategies:
[09:29:46.737] 1. multicore:
[09:29:46.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.737]    - tweaked: FALSE
[09:29:46.737]    - call: plan(strategy)
[09:29:46.742] plan(): nbrOfWorkers() = 2
[09:29:46.733] MulticoreFuture:
[09:29:46.733] Label: ‘future_vapply-1’
[09:29:46.733] Expression:
[09:29:46.733] {
[09:29:46.733]     do.call(function(...) {
[09:29:46.733]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.733]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.733]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.733]             on.exit(options(oopts), add = TRUE)
[09:29:46.733]         }
[09:29:46.733]         {
[09:29:46.733]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.733]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.733]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.733]             })
[09:29:46.733]         }
[09:29:46.733]     }, args = future.call.arguments)
[09:29:46.733] }
[09:29:46.733] Lazy evaluation: FALSE
[09:29:46.733] Asynchronous evaluation: TRUE
[09:29:46.733] Local evaluation: TRUE
[09:29:46.733] Environment: R_GlobalEnv
[09:29:46.733] Capture standard output: TRUE
[09:29:46.733] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.733] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.733] Packages: 1 packages (‘future.apply’)
[09:29:46.733] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.733] Resolved: TRUE
[09:29:46.733] Value: <not collected>
[09:29:46.733] Conditions captured: <none>
[09:29:46.733] Early signaling: FALSE
[09:29:46.733] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.733] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.743] Chunk #1 of 2 ... DONE
[09:29:46.743] Chunk #2 of 2 ...
[09:29:46.743]  - Finding globals in 'X' for chunk #2 ...
[09:29:46.743] getGlobalsAndPackages() ...
[09:29:46.743] Searching for globals...
[09:29:46.744] 
[09:29:46.744] Searching for globals ... DONE
[09:29:46.744] - globals: [0] <none>
[09:29:46.744] getGlobalsAndPackages() ... DONE
[09:29:46.744]    + additional globals found: [n=0] 
[09:29:46.744]    + additional namespaces needed: [n=0] 
[09:29:46.744]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:46.745]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.745]  - seeds: <none>
[09:29:46.745]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.745] getGlobalsAndPackages() ...
[09:29:46.745] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.745] Resolving globals: FALSE
[09:29:46.745] Tweak future expression to call with '...' arguments ...
[09:29:46.746] {
[09:29:46.746]     do.call(function(...) {
[09:29:46.746]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.746]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.746]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.746]             on.exit(options(oopts), add = TRUE)
[09:29:46.746]         }
[09:29:46.746]         {
[09:29:46.746]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.746]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.746]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.746]             })
[09:29:46.746]         }
[09:29:46.746]     }, args = future.call.arguments)
[09:29:46.746] }
[09:29:46.746] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.747] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.747] - packages: [1] ‘future.apply’
[09:29:46.747] getGlobalsAndPackages() ... DONE
[09:29:46.748] run() for ‘Future’ ...
[09:29:46.748] - state: ‘created’
[09:29:46.748] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:46.752] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:46.753]   - Field: ‘label’
[09:29:46.753]   - Field: ‘local’
[09:29:46.753]   - Field: ‘owner’
[09:29:46.753]   - Field: ‘envir’
[09:29:46.753]   - Field: ‘workers’
[09:29:46.753]   - Field: ‘packages’
[09:29:46.754]   - Field: ‘gc’
[09:29:46.754]   - Field: ‘job’
[09:29:46.754]   - Field: ‘conditions’
[09:29:46.754]   - Field: ‘expr’
[09:29:46.754]   - Field: ‘uuid’
[09:29:46.754]   - Field: ‘seed’
[09:29:46.754]   - Field: ‘version’
[09:29:46.755]   - Field: ‘result’
[09:29:46.755]   - Field: ‘asynchronous’
[09:29:46.755]   - Field: ‘calls’
[09:29:46.755]   - Field: ‘globals’
[09:29:46.755]   - Field: ‘stdout’
[09:29:46.755]   - Field: ‘earlySignal’
[09:29:46.755]   - Field: ‘lazy’
[09:29:46.755]   - Field: ‘state’
[09:29:46.756] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:46.756] - Launch lazy future ...
[09:29:46.756] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.759] Packages needed by future strategies (n = 0): <none>
[09:29:46.761] {
[09:29:46.761]     {
[09:29:46.761]         {
[09:29:46.761]             ...future.startTime <- base::Sys.time()
[09:29:46.761]             {
[09:29:46.761]                 {
[09:29:46.761]                   {
[09:29:46.761]                     {
[09:29:46.761]                       {
[09:29:46.761]                         base::local({
[09:29:46.761]                           has_future <- base::requireNamespace("future", 
[09:29:46.761]                             quietly = TRUE)
[09:29:46.761]                           if (has_future) {
[09:29:46.761]                             ns <- base::getNamespace("future")
[09:29:46.761]                             version <- ns[[".package"]][["version"]]
[09:29:46.761]                             if (is.null(version)) 
[09:29:46.761]                               version <- utils::packageVersion("future")
[09:29:46.761]                           }
[09:29:46.761]                           else {
[09:29:46.761]                             version <- NULL
[09:29:46.761]                           }
[09:29:46.761]                           if (!has_future || version < "1.8.0") {
[09:29:46.761]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.761]                               "", base::R.version$version.string), 
[09:29:46.761]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:46.761]                                 base::R.version$platform, 8 * 
[09:29:46.761]                                   base::.Machine$sizeof.pointer), 
[09:29:46.761]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.761]                                 "release", "version")], collapse = " "), 
[09:29:46.761]                               hostname = base::Sys.info()[["nodename"]])
[09:29:46.761]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.761]                               info)
[09:29:46.761]                             info <- base::paste(info, collapse = "; ")
[09:29:46.761]                             if (!has_future) {
[09:29:46.761]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.761]                                 info)
[09:29:46.761]                             }
[09:29:46.761]                             else {
[09:29:46.761]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.761]                                 info, version)
[09:29:46.761]                             }
[09:29:46.761]                             base::stop(msg)
[09:29:46.761]                           }
[09:29:46.761]                         })
[09:29:46.761]                       }
[09:29:46.761]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:46.761]                       base::options(mc.cores = 1L)
[09:29:46.761]                     }
[09:29:46.761]                     base::local({
[09:29:46.761]                       for (pkg in "future.apply") {
[09:29:46.761]                         base::loadNamespace(pkg)
[09:29:46.761]                         base::library(pkg, character.only = TRUE)
[09:29:46.761]                       }
[09:29:46.761]                     })
[09:29:46.761]                   }
[09:29:46.761]                   ...future.strategy.old <- future::plan("list")
[09:29:46.761]                   options(future.plan = NULL)
[09:29:46.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.761]                 }
[09:29:46.761]                 ...future.workdir <- getwd()
[09:29:46.761]             }
[09:29:46.761]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.761]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.761]         }
[09:29:46.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.761]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:46.761]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.761]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.761]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.761]             base::names(...future.oldOptions))
[09:29:46.761]     }
[09:29:46.761]     if (FALSE) {
[09:29:46.761]     }
[09:29:46.761]     else {
[09:29:46.761]         if (TRUE) {
[09:29:46.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.761]                 open = "w")
[09:29:46.761]         }
[09:29:46.761]         else {
[09:29:46.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.761]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.761]         }
[09:29:46.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.761]             base::sink(type = "output", split = FALSE)
[09:29:46.761]             base::close(...future.stdout)
[09:29:46.761]         }, add = TRUE)
[09:29:46.761]     }
[09:29:46.761]     ...future.frame <- base::sys.nframe()
[09:29:46.761]     ...future.conditions <- base::list()
[09:29:46.761]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.761]     if (FALSE) {
[09:29:46.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.761]     }
[09:29:46.761]     ...future.result <- base::tryCatch({
[09:29:46.761]         base::withCallingHandlers({
[09:29:46.761]             ...future.value <- base::withVisible(base::local({
[09:29:46.761]                 withCallingHandlers({
[09:29:46.761]                   {
[09:29:46.761]                     do.call(function(...) {
[09:29:46.761]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.761]                       if (!identical(...future.globals.maxSize.org, 
[09:29:46.761]                         ...future.globals.maxSize)) {
[09:29:46.761]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.761]                         on.exit(options(oopts), add = TRUE)
[09:29:46.761]                       }
[09:29:46.761]                       {
[09:29:46.761]                         lapply(seq_along(...future.elements_ii), 
[09:29:46.761]                           FUN = function(jj) {
[09:29:46.761]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.761]                             ...future.FUN(...future.X_jj, ...)
[09:29:46.761]                           })
[09:29:46.761]                       }
[09:29:46.761]                     }, args = future.call.arguments)
[09:29:46.761]                   }
[09:29:46.761]                 }, immediateCondition = function(cond) {
[09:29:46.761]                   save_rds <- function (object, pathname, ...) 
[09:29:46.761]                   {
[09:29:46.761]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:46.761]                     if (file_test("-f", pathname_tmp)) {
[09:29:46.761]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.761]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:46.761]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.761]                         fi_tmp[["mtime"]])
[09:29:46.761]                     }
[09:29:46.761]                     tryCatch({
[09:29:46.761]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:46.761]                     }, error = function(ex) {
[09:29:46.761]                       msg <- conditionMessage(ex)
[09:29:46.761]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.761]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:46.761]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.761]                         fi_tmp[["mtime"]], msg)
[09:29:46.761]                       ex$message <- msg
[09:29:46.761]                       stop(ex)
[09:29:46.761]                     })
[09:29:46.761]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:46.761]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:46.761]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:46.761]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.761]                       fi <- file.info(pathname)
[09:29:46.761]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:46.761]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.761]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:46.761]                         fi[["size"]], fi[["mtime"]])
[09:29:46.761]                       stop(msg)
[09:29:46.761]                     }
[09:29:46.761]                     invisible(pathname)
[09:29:46.761]                   }
[09:29:46.761]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:46.761]                     rootPath = tempdir()) 
[09:29:46.761]                   {
[09:29:46.761]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:46.761]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:46.761]                       tmpdir = path, fileext = ".rds")
[09:29:46.761]                     save_rds(obj, file)
[09:29:46.761]                   }
[09:29:46.761]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:46.761]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.761]                   {
[09:29:46.761]                     inherits <- base::inherits
[09:29:46.761]                     invokeRestart <- base::invokeRestart
[09:29:46.761]                     is.null <- base::is.null
[09:29:46.761]                     muffled <- FALSE
[09:29:46.761]                     if (inherits(cond, "message")) {
[09:29:46.761]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:46.761]                       if (muffled) 
[09:29:46.761]                         invokeRestart("muffleMessage")
[09:29:46.761]                     }
[09:29:46.761]                     else if (inherits(cond, "warning")) {
[09:29:46.761]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:46.761]                       if (muffled) 
[09:29:46.761]                         invokeRestart("muffleWarning")
[09:29:46.761]                     }
[09:29:46.761]                     else if (inherits(cond, "condition")) {
[09:29:46.761]                       if (!is.null(pattern)) {
[09:29:46.761]                         computeRestarts <- base::computeRestarts
[09:29:46.761]                         grepl <- base::grepl
[09:29:46.761]                         restarts <- computeRestarts(cond)
[09:29:46.761]                         for (restart in restarts) {
[09:29:46.761]                           name <- restart$name
[09:29:46.761]                           if (is.null(name)) 
[09:29:46.761]                             next
[09:29:46.761]                           if (!grepl(pattern, name)) 
[09:29:46.761]                             next
[09:29:46.761]                           invokeRestart(restart)
[09:29:46.761]                           muffled <- TRUE
[09:29:46.761]                           break
[09:29:46.761]                         }
[09:29:46.761]                       }
[09:29:46.761]                     }
[09:29:46.761]                     invisible(muffled)
[09:29:46.761]                   }
[09:29:46.761]                   muffleCondition(cond)
[09:29:46.761]                 })
[09:29:46.761]             }))
[09:29:46.761]             future::FutureResult(value = ...future.value$value, 
[09:29:46.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.761]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.761]                     ...future.globalenv.names))
[09:29:46.761]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.761]         }, condition = base::local({
[09:29:46.761]             c <- base::c
[09:29:46.761]             inherits <- base::inherits
[09:29:46.761]             invokeRestart <- base::invokeRestart
[09:29:46.761]             length <- base::length
[09:29:46.761]             list <- base::list
[09:29:46.761]             seq.int <- base::seq.int
[09:29:46.761]             signalCondition <- base::signalCondition
[09:29:46.761]             sys.calls <- base::sys.calls
[09:29:46.761]             `[[` <- base::`[[`
[09:29:46.761]             `+` <- base::`+`
[09:29:46.761]             `<<-` <- base::`<<-`
[09:29:46.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.761]                   3L)]
[09:29:46.761]             }
[09:29:46.761]             function(cond) {
[09:29:46.761]                 is_error <- inherits(cond, "error")
[09:29:46.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.761]                   NULL)
[09:29:46.761]                 if (is_error) {
[09:29:46.761]                   sessionInformation <- function() {
[09:29:46.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.761]                       search = base::search(), system = base::Sys.info())
[09:29:46.761]                   }
[09:29:46.761]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.761]                     cond$call), session = sessionInformation(), 
[09:29:46.761]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.761]                   signalCondition(cond)
[09:29:46.761]                 }
[09:29:46.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.761]                 "immediateCondition"))) {
[09:29:46.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.761]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.761]                   if (TRUE && !signal) {
[09:29:46.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.761]                     {
[09:29:46.761]                       inherits <- base::inherits
[09:29:46.761]                       invokeRestart <- base::invokeRestart
[09:29:46.761]                       is.null <- base::is.null
[09:29:46.761]                       muffled <- FALSE
[09:29:46.761]                       if (inherits(cond, "message")) {
[09:29:46.761]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.761]                         if (muffled) 
[09:29:46.761]                           invokeRestart("muffleMessage")
[09:29:46.761]                       }
[09:29:46.761]                       else if (inherits(cond, "warning")) {
[09:29:46.761]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.761]                         if (muffled) 
[09:29:46.761]                           invokeRestart("muffleWarning")
[09:29:46.761]                       }
[09:29:46.761]                       else if (inherits(cond, "condition")) {
[09:29:46.761]                         if (!is.null(pattern)) {
[09:29:46.761]                           computeRestarts <- base::computeRestarts
[09:29:46.761]                           grepl <- base::grepl
[09:29:46.761]                           restarts <- computeRestarts(cond)
[09:29:46.761]                           for (restart in restarts) {
[09:29:46.761]                             name <- restart$name
[09:29:46.761]                             if (is.null(name)) 
[09:29:46.761]                               next
[09:29:46.761]                             if (!grepl(pattern, name)) 
[09:29:46.761]                               next
[09:29:46.761]                             invokeRestart(restart)
[09:29:46.761]                             muffled <- TRUE
[09:29:46.761]                             break
[09:29:46.761]                           }
[09:29:46.761]                         }
[09:29:46.761]                       }
[09:29:46.761]                       invisible(muffled)
[09:29:46.761]                     }
[09:29:46.761]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.761]                   }
[09:29:46.761]                 }
[09:29:46.761]                 else {
[09:29:46.761]                   if (TRUE) {
[09:29:46.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.761]                     {
[09:29:46.761]                       inherits <- base::inherits
[09:29:46.761]                       invokeRestart <- base::invokeRestart
[09:29:46.761]                       is.null <- base::is.null
[09:29:46.761]                       muffled <- FALSE
[09:29:46.761]                       if (inherits(cond, "message")) {
[09:29:46.761]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.761]                         if (muffled) 
[09:29:46.761]                           invokeRestart("muffleMessage")
[09:29:46.761]                       }
[09:29:46.761]                       else if (inherits(cond, "warning")) {
[09:29:46.761]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.761]                         if (muffled) 
[09:29:46.761]                           invokeRestart("muffleWarning")
[09:29:46.761]                       }
[09:29:46.761]                       else if (inherits(cond, "condition")) {
[09:29:46.761]                         if (!is.null(pattern)) {
[09:29:46.761]                           computeRestarts <- base::computeRestarts
[09:29:46.761]                           grepl <- base::grepl
[09:29:46.761]                           restarts <- computeRestarts(cond)
[09:29:46.761]                           for (restart in restarts) {
[09:29:46.761]                             name <- restart$name
[09:29:46.761]                             if (is.null(name)) 
[09:29:46.761]                               next
[09:29:46.761]                             if (!grepl(pattern, name)) 
[09:29:46.761]                               next
[09:29:46.761]                             invokeRestart(restart)
[09:29:46.761]                             muffled <- TRUE
[09:29:46.761]                             break
[09:29:46.761]                           }
[09:29:46.761]                         }
[09:29:46.761]                       }
[09:29:46.761]                       invisible(muffled)
[09:29:46.761]                     }
[09:29:46.761]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.761]                   }
[09:29:46.761]                 }
[09:29:46.761]             }
[09:29:46.761]         }))
[09:29:46.761]     }, error = function(ex) {
[09:29:46.761]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.761]                 ...future.rng), started = ...future.startTime, 
[09:29:46.761]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.761]             version = "1.8"), class = "FutureResult")
[09:29:46.761]     }, finally = {
[09:29:46.761]         if (!identical(...future.workdir, getwd())) 
[09:29:46.761]             setwd(...future.workdir)
[09:29:46.761]         {
[09:29:46.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.761]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.761]             }
[09:29:46.761]             base::options(...future.oldOptions)
[09:29:46.761]             if (.Platform$OS.type == "windows") {
[09:29:46.761]                 old_names <- names(...future.oldEnvVars)
[09:29:46.761]                 envs <- base::Sys.getenv()
[09:29:46.761]                 names <- names(envs)
[09:29:46.761]                 common <- intersect(names, old_names)
[09:29:46.761]                 added <- setdiff(names, old_names)
[09:29:46.761]                 removed <- setdiff(old_names, names)
[09:29:46.761]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.761]                   envs[common]]
[09:29:46.761]                 NAMES <- toupper(changed)
[09:29:46.761]                 args <- list()
[09:29:46.761]                 for (kk in seq_along(NAMES)) {
[09:29:46.761]                   name <- changed[[kk]]
[09:29:46.761]                   NAME <- NAMES[[kk]]
[09:29:46.761]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.761]                     next
[09:29:46.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.761]                 }
[09:29:46.761]                 NAMES <- toupper(added)
[09:29:46.761]                 for (kk in seq_along(NAMES)) {
[09:29:46.761]                   name <- added[[kk]]
[09:29:46.761]                   NAME <- NAMES[[kk]]
[09:29:46.761]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.761]                     next
[09:29:46.761]                   args[[name]] <- ""
[09:29:46.761]                 }
[09:29:46.761]                 NAMES <- toupper(removed)
[09:29:46.761]                 for (kk in seq_along(NAMES)) {
[09:29:46.761]                   name <- removed[[kk]]
[09:29:46.761]                   NAME <- NAMES[[kk]]
[09:29:46.761]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.761]                     next
[09:29:46.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.761]                 }
[09:29:46.761]                 if (length(args) > 0) 
[09:29:46.761]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.761]             }
[09:29:46.761]             else {
[09:29:46.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.761]             }
[09:29:46.761]             {
[09:29:46.761]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.761]                   0L) {
[09:29:46.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.761]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.761]                   base::options(opts)
[09:29:46.761]                 }
[09:29:46.761]                 {
[09:29:46.761]                   {
[09:29:46.761]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:46.761]                     NULL
[09:29:46.761]                   }
[09:29:46.761]                   options(future.plan = NULL)
[09:29:46.761]                   if (is.na(NA_character_)) 
[09:29:46.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.761]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.761]                     .init = FALSE)
[09:29:46.761]                 }
[09:29:46.761]             }
[09:29:46.761]         }
[09:29:46.761]     })
[09:29:46.761]     if (TRUE) {
[09:29:46.761]         base::sink(type = "output", split = FALSE)
[09:29:46.761]         if (TRUE) {
[09:29:46.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.761]         }
[09:29:46.761]         else {
[09:29:46.761]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.761]         }
[09:29:46.761]         base::close(...future.stdout)
[09:29:46.761]         ...future.stdout <- NULL
[09:29:46.761]     }
[09:29:46.761]     ...future.result$conditions <- ...future.conditions
[09:29:46.761]     ...future.result$finished <- base::Sys.time()
[09:29:46.761]     ...future.result
[09:29:46.761] }
[09:29:46.764] assign_globals() ...
[09:29:46.764] List of 11
[09:29:46.764]  $ ...future.FUN            :function (x, ...)  
[09:29:46.764]  $ x_FUN                    :function (x)  
[09:29:46.764]  $ times                    : int 1
[09:29:46.764]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.764]  $ stop_if_not              :function (...)  
[09:29:46.764]  $ dim                      : NULL
[09:29:46.764]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:46.764]  $ future.call.arguments    : list()
[09:29:46.764]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.764]  $ ...future.elements_ii    :List of 5
[09:29:46.764]   ..$ : int 6
[09:29:46.764]   ..$ : int 7
[09:29:46.764]   ..$ : int 8
[09:29:46.764]   ..$ : int 9
[09:29:46.764]   ..$ : int 10
[09:29:46.764]  $ ...future.seeds_ii       : NULL
[09:29:46.764]  $ ...future.globals.maxSize: NULL
[09:29:46.764]  - attr(*, "where")=List of 11
[09:29:46.764]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.764]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.764]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.764]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.764]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.764]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.764]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.764]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.764]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.764]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.764]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.764]  - attr(*, "resolved")= logi FALSE
[09:29:46.764]  - attr(*, "total_size")= num 94336
[09:29:46.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.764]  - attr(*, "already-done")= logi TRUE
[09:29:46.777] - copied ‘...future.FUN’ to environment
[09:29:46.777] - copied ‘x_FUN’ to environment
[09:29:46.777] - copied ‘times’ to environment
[09:29:46.777] - copied ‘stopf’ to environment
[09:29:46.777] - copied ‘stop_if_not’ to environment
[09:29:46.778] - copied ‘dim’ to environment
[09:29:46.778] - copied ‘valid_types’ to environment
[09:29:46.778] - copied ‘future.call.arguments’ to environment
[09:29:46.778] - copied ‘...future.elements_ii’ to environment
[09:29:46.778] - copied ‘...future.seeds_ii’ to environment
[09:29:46.778] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.778] assign_globals() ... done
[09:29:46.778] requestCore(): workers = 2
[09:29:46.780] MulticoreFuture started
[09:29:46.781] - Launch lazy future ... done
[09:29:46.781] run() for ‘MulticoreFuture’ ... done
[09:29:46.781] Created future:
[09:29:46.782] plan(): Setting new future strategy stack:
[09:29:46.782] List of future strategies:
[09:29:46.782] 1. sequential:
[09:29:46.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.782]    - tweaked: FALSE
[09:29:46.782]    - call: NULL
[09:29:46.783] plan(): nbrOfWorkers() = 1
[09:29:46.785] plan(): Setting new future strategy stack:
[09:29:46.785] List of future strategies:
[09:29:46.785] 1. multicore:
[09:29:46.785]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.785]    - tweaked: FALSE
[09:29:46.785]    - call: plan(strategy)
[09:29:46.791] plan(): nbrOfWorkers() = 2
[09:29:46.781] MulticoreFuture:
[09:29:46.781] Label: ‘future_vapply-2’
[09:29:46.781] Expression:
[09:29:46.781] {
[09:29:46.781]     do.call(function(...) {
[09:29:46.781]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.781]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.781]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.781]             on.exit(options(oopts), add = TRUE)
[09:29:46.781]         }
[09:29:46.781]         {
[09:29:46.781]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.781]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.781]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.781]             })
[09:29:46.781]         }
[09:29:46.781]     }, args = future.call.arguments)
[09:29:46.781] }
[09:29:46.781] Lazy evaluation: FALSE
[09:29:46.781] Asynchronous evaluation: TRUE
[09:29:46.781] Local evaluation: TRUE
[09:29:46.781] Environment: R_GlobalEnv
[09:29:46.781] Capture standard output: TRUE
[09:29:46.781] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.781] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.781] Packages: 1 packages (‘future.apply’)
[09:29:46.781] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.781] Resolved: TRUE
[09:29:46.781] Value: <not collected>
[09:29:46.781] Conditions captured: <none>
[09:29:46.781] Early signaling: FALSE
[09:29:46.781] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.781] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.792] Chunk #2 of 2 ... DONE
[09:29:46.792] Launching 2 futures (chunks) ... DONE
[09:29:46.792] Resolving 2 futures (chunks) ...
[09:29:46.792] resolve() on list ...
[09:29:46.792]  recursive: 0
[09:29:46.792]  length: 2
[09:29:46.792] 
[09:29:46.793] Future #1
[09:29:46.793] result() for MulticoreFuture ...
[09:29:46.794] result() for MulticoreFuture ...
[09:29:46.794] result() for MulticoreFuture ... done
[09:29:46.794] result() for MulticoreFuture ... done
[09:29:46.794] result() for MulticoreFuture ...
[09:29:46.794] result() for MulticoreFuture ... done
[09:29:46.794] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:46.795] - nx: 2
[09:29:46.795] - relay: TRUE
[09:29:46.795] - stdout: TRUE
[09:29:46.795] - signal: TRUE
[09:29:46.795] - resignal: FALSE
[09:29:46.795] - force: TRUE
[09:29:46.795] - relayed: [n=2] FALSE, FALSE
[09:29:46.795] - queued futures: [n=2] FALSE, FALSE
[09:29:46.796]  - until=1
[09:29:46.796]  - relaying element #1
[09:29:46.796] result() for MulticoreFuture ...
[09:29:46.796] result() for MulticoreFuture ... done
[09:29:46.796] result() for MulticoreFuture ...
[09:29:46.796] result() for MulticoreFuture ... done
[09:29:46.796] result() for MulticoreFuture ...
[09:29:46.797] result() for MulticoreFuture ... done
[09:29:46.797] result() for MulticoreFuture ...
[09:29:46.797] result() for MulticoreFuture ... done
[09:29:46.797] - relayed: [n=2] TRUE, FALSE
[09:29:46.797] - queued futures: [n=2] TRUE, FALSE
[09:29:46.797] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:46.797]  length: 1 (resolved future 1)
[09:29:46.798] Future #2
[09:29:46.798] result() for MulticoreFuture ...
[09:29:46.799] result() for MulticoreFuture ...
[09:29:46.799] result() for MulticoreFuture ... done
[09:29:46.799] result() for MulticoreFuture ... done
[09:29:46.799] result() for MulticoreFuture ...
[09:29:46.799] result() for MulticoreFuture ... done
[09:29:46.799] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:46.799] - nx: 2
[09:29:46.799] - relay: TRUE
[09:29:46.800] - stdout: TRUE
[09:29:46.800] - signal: TRUE
[09:29:46.800] - resignal: FALSE
[09:29:46.800] - force: TRUE
[09:29:46.800] - relayed: [n=2] TRUE, FALSE
[09:29:46.800] - queued futures: [n=2] TRUE, FALSE
[09:29:46.800]  - until=2
[09:29:46.800]  - relaying element #2
[09:29:46.801] result() for MulticoreFuture ...
[09:29:46.801] result() for MulticoreFuture ... done
[09:29:46.801] result() for MulticoreFuture ...
[09:29:46.801] result() for MulticoreFuture ... done
[09:29:46.801] result() for MulticoreFuture ...
[09:29:46.801] result() for MulticoreFuture ... done
[09:29:46.801] result() for MulticoreFuture ...
[09:29:46.801] result() for MulticoreFuture ... done
[09:29:46.802] - relayed: [n=2] TRUE, TRUE
[09:29:46.802] - queued futures: [n=2] TRUE, TRUE
[09:29:46.802] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:46.802]  length: 0 (resolved future 2)
[09:29:46.804] Relaying remaining futures
[09:29:46.805] signalConditionsASAP(NULL, pos=0) ...
[09:29:46.805] - nx: 2
[09:29:46.805] - relay: TRUE
[09:29:46.805] - stdout: TRUE
[09:29:46.805] - signal: TRUE
[09:29:46.805] - resignal: FALSE
[09:29:46.806] - force: TRUE
[09:29:46.806] - relayed: [n=2] TRUE, TRUE
[09:29:46.806] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:46.806] - relayed: [n=2] TRUE, TRUE
[09:29:46.806] - queued futures: [n=2] TRUE, TRUE
[09:29:46.806] signalConditionsASAP(NULL, pos=0) ... done
[09:29:46.806] resolve() on list ... DONE
[09:29:46.807] result() for MulticoreFuture ...
[09:29:46.807] result() for MulticoreFuture ... done
[09:29:46.807] result() for MulticoreFuture ...
[09:29:46.807] result() for MulticoreFuture ... done
[09:29:46.807] result() for MulticoreFuture ...
[09:29:46.807] result() for MulticoreFuture ... done
[09:29:46.808] result() for MulticoreFuture ...
[09:29:46.808] result() for MulticoreFuture ... done
[09:29:46.808]  - Number of value chunks collected: 2
[09:29:46.808] Resolving 2 futures (chunks) ... DONE
[09:29:46.808] Reducing values from 2 chunks ...
[09:29:46.808]  - Number of values collected after concatenation: 10
[09:29:46.809]  - Number of values expected: 10
[09:29:46.809] Reducing values from 2 chunks ... DONE
[09:29:46.809] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[09:29:46.810] future_lapply() ...
[09:29:46.816] Number of chunks: 2
[09:29:46.816] getGlobalsAndPackagesXApply() ...
[09:29:46.816]  - future.globals: TRUE
[09:29:46.817] getGlobalsAndPackages() ...
[09:29:46.817] Searching for globals...
[09:29:46.821] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[09:29:46.821] Searching for globals ... DONE
[09:29:46.821] Resolving globals: FALSE
[09:29:46.822] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[09:29:46.822] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:46.822] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.823] - packages: [1] ‘future.apply’
[09:29:46.823] getGlobalsAndPackages() ... DONE
[09:29:46.823]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.823]  - needed namespaces: [n=1] ‘future.apply’
[09:29:46.823] Finding globals ... DONE
[09:29:46.823]  - use_args: TRUE
[09:29:46.823]  - Getting '...' globals ...
[09:29:46.823] resolve() on list ...
[09:29:46.824]  recursive: 0
[09:29:46.824]  length: 1
[09:29:46.824]  elements: ‘...’
[09:29:46.824]  length: 0 (resolved future 1)
[09:29:46.824] resolve() on list ... DONE
[09:29:46.824]    - '...' content: [n=0] 
[09:29:46.824] List of 1
[09:29:46.824]  $ ...: list()
[09:29:46.824]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.824]  - attr(*, "where")=List of 1
[09:29:46.824]   ..$ ...:<environment: 0x561d35948ba0> 
[09:29:46.824]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.824]  - attr(*, "resolved")= logi TRUE
[09:29:46.824]  - attr(*, "total_size")= num NA
[09:29:46.827]  - Getting '...' globals ... DONE
[09:29:46.827] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:46.827] List of 8
[09:29:46.827]  $ ...future.FUN:function (x, ...)  
[09:29:46.827]  $ x_FUN        :function (x)  
[09:29:46.827]  $ times        : int 2
[09:29:46.827]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.827]  $ stop_if_not  :function (...)  
[09:29:46.827]  $ dim          : NULL
[09:29:46.827]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:46.827]  $ ...          : list()
[09:29:46.827]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.827]  - attr(*, "where")=List of 8
[09:29:46.827]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.827]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:46.827]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:46.827]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:46.827]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:46.827]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:46.827]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:46.827]   ..$ ...          :<environment: 0x561d35948ba0> 
[09:29:46.827]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.827]  - attr(*, "resolved")= logi FALSE
[09:29:46.827]  - attr(*, "total_size")= num 96456
[09:29:46.834] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:46.834] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.834] Number of futures (= number of chunks): 2
[09:29:46.834] Launching 2 futures (chunks) ...
[09:29:46.834] Chunk #1 of 2 ...
[09:29:46.834]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.834] getGlobalsAndPackages() ...
[09:29:46.835] Searching for globals...
[09:29:46.835] 
[09:29:46.835] Searching for globals ... DONE
[09:29:46.835] - globals: [0] <none>
[09:29:46.835] getGlobalsAndPackages() ... DONE
[09:29:46.835]    + additional globals found: [n=0] 
[09:29:46.835]    + additional namespaces needed: [n=0] 
[09:29:46.835]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.835]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.836]  - seeds: <none>
[09:29:46.836]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.836] getGlobalsAndPackages() ...
[09:29:46.836] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.836] Resolving globals: FALSE
[09:29:46.836] Tweak future expression to call with '...' arguments ...
[09:29:46.836] {
[09:29:46.836]     do.call(function(...) {
[09:29:46.836]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.836]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.836]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.836]             on.exit(options(oopts), add = TRUE)
[09:29:46.836]         }
[09:29:46.836]         {
[09:29:46.836]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.836]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.836]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.836]             })
[09:29:46.836]         }
[09:29:46.836]     }, args = future.call.arguments)
[09:29:46.836] }
[09:29:46.836] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.837] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.837] - packages: [1] ‘future.apply’
[09:29:46.837] getGlobalsAndPackages() ... DONE
[09:29:46.837] run() for ‘Future’ ...
[09:29:46.838] - state: ‘created’
[09:29:46.838] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:46.841] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.841] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:46.841]   - Field: ‘label’
[09:29:46.841]   - Field: ‘local’
[09:29:46.842]   - Field: ‘owner’
[09:29:46.842]   - Field: ‘envir’
[09:29:46.842]   - Field: ‘workers’
[09:29:46.842]   - Field: ‘packages’
[09:29:46.842]   - Field: ‘gc’
[09:29:46.842]   - Field: ‘job’
[09:29:46.842]   - Field: ‘conditions’
[09:29:46.842]   - Field: ‘expr’
[09:29:46.842]   - Field: ‘uuid’
[09:29:46.842]   - Field: ‘seed’
[09:29:46.842]   - Field: ‘version’
[09:29:46.843]   - Field: ‘result’
[09:29:46.843]   - Field: ‘asynchronous’
[09:29:46.843]   - Field: ‘calls’
[09:29:46.843]   - Field: ‘globals’
[09:29:46.843]   - Field: ‘stdout’
[09:29:46.843]   - Field: ‘earlySignal’
[09:29:46.843]   - Field: ‘lazy’
[09:29:46.843]   - Field: ‘state’
[09:29:46.843] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:46.843] - Launch lazy future ...
[09:29:46.844] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.844] Packages needed by future strategies (n = 0): <none>
[09:29:46.844] {
[09:29:46.844]     {
[09:29:46.844]         {
[09:29:46.844]             ...future.startTime <- base::Sys.time()
[09:29:46.844]             {
[09:29:46.844]                 {
[09:29:46.844]                   {
[09:29:46.844]                     {
[09:29:46.844]                       {
[09:29:46.844]                         base::local({
[09:29:46.844]                           has_future <- base::requireNamespace("future", 
[09:29:46.844]                             quietly = TRUE)
[09:29:46.844]                           if (has_future) {
[09:29:46.844]                             ns <- base::getNamespace("future")
[09:29:46.844]                             version <- ns[[".package"]][["version"]]
[09:29:46.844]                             if (is.null(version)) 
[09:29:46.844]                               version <- utils::packageVersion("future")
[09:29:46.844]                           }
[09:29:46.844]                           else {
[09:29:46.844]                             version <- NULL
[09:29:46.844]                           }
[09:29:46.844]                           if (!has_future || version < "1.8.0") {
[09:29:46.844]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.844]                               "", base::R.version$version.string), 
[09:29:46.844]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:46.844]                                 base::R.version$platform, 8 * 
[09:29:46.844]                                   base::.Machine$sizeof.pointer), 
[09:29:46.844]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.844]                                 "release", "version")], collapse = " "), 
[09:29:46.844]                               hostname = base::Sys.info()[["nodename"]])
[09:29:46.844]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.844]                               info)
[09:29:46.844]                             info <- base::paste(info, collapse = "; ")
[09:29:46.844]                             if (!has_future) {
[09:29:46.844]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.844]                                 info)
[09:29:46.844]                             }
[09:29:46.844]                             else {
[09:29:46.844]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.844]                                 info, version)
[09:29:46.844]                             }
[09:29:46.844]                             base::stop(msg)
[09:29:46.844]                           }
[09:29:46.844]                         })
[09:29:46.844]                       }
[09:29:46.844]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:46.844]                       base::options(mc.cores = 1L)
[09:29:46.844]                     }
[09:29:46.844]                     base::local({
[09:29:46.844]                       for (pkg in "future.apply") {
[09:29:46.844]                         base::loadNamespace(pkg)
[09:29:46.844]                         base::library(pkg, character.only = TRUE)
[09:29:46.844]                       }
[09:29:46.844]                     })
[09:29:46.844]                   }
[09:29:46.844]                   ...future.strategy.old <- future::plan("list")
[09:29:46.844]                   options(future.plan = NULL)
[09:29:46.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.844]                 }
[09:29:46.844]                 ...future.workdir <- getwd()
[09:29:46.844]             }
[09:29:46.844]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.844]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.844]         }
[09:29:46.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.844]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:46.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.844]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.844]             base::names(...future.oldOptions))
[09:29:46.844]     }
[09:29:46.844]     if (FALSE) {
[09:29:46.844]     }
[09:29:46.844]     else {
[09:29:46.844]         if (TRUE) {
[09:29:46.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.844]                 open = "w")
[09:29:46.844]         }
[09:29:46.844]         else {
[09:29:46.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.844]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.844]         }
[09:29:46.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.844]             base::sink(type = "output", split = FALSE)
[09:29:46.844]             base::close(...future.stdout)
[09:29:46.844]         }, add = TRUE)
[09:29:46.844]     }
[09:29:46.844]     ...future.frame <- base::sys.nframe()
[09:29:46.844]     ...future.conditions <- base::list()
[09:29:46.844]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.844]     if (FALSE) {
[09:29:46.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.844]     }
[09:29:46.844]     ...future.result <- base::tryCatch({
[09:29:46.844]         base::withCallingHandlers({
[09:29:46.844]             ...future.value <- base::withVisible(base::local({
[09:29:46.844]                 withCallingHandlers({
[09:29:46.844]                   {
[09:29:46.844]                     do.call(function(...) {
[09:29:46.844]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.844]                       if (!identical(...future.globals.maxSize.org, 
[09:29:46.844]                         ...future.globals.maxSize)) {
[09:29:46.844]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.844]                         on.exit(options(oopts), add = TRUE)
[09:29:46.844]                       }
[09:29:46.844]                       {
[09:29:46.844]                         lapply(seq_along(...future.elements_ii), 
[09:29:46.844]                           FUN = function(jj) {
[09:29:46.844]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.844]                             ...future.FUN(...future.X_jj, ...)
[09:29:46.844]                           })
[09:29:46.844]                       }
[09:29:46.844]                     }, args = future.call.arguments)
[09:29:46.844]                   }
[09:29:46.844]                 }, immediateCondition = function(cond) {
[09:29:46.844]                   save_rds <- function (object, pathname, ...) 
[09:29:46.844]                   {
[09:29:46.844]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:46.844]                     if (file_test("-f", pathname_tmp)) {
[09:29:46.844]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.844]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:46.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.844]                         fi_tmp[["mtime"]])
[09:29:46.844]                     }
[09:29:46.844]                     tryCatch({
[09:29:46.844]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:46.844]                     }, error = function(ex) {
[09:29:46.844]                       msg <- conditionMessage(ex)
[09:29:46.844]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.844]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:46.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.844]                         fi_tmp[["mtime"]], msg)
[09:29:46.844]                       ex$message <- msg
[09:29:46.844]                       stop(ex)
[09:29:46.844]                     })
[09:29:46.844]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:46.844]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:46.844]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:46.844]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.844]                       fi <- file.info(pathname)
[09:29:46.844]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:46.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.844]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:46.844]                         fi[["size"]], fi[["mtime"]])
[09:29:46.844]                       stop(msg)
[09:29:46.844]                     }
[09:29:46.844]                     invisible(pathname)
[09:29:46.844]                   }
[09:29:46.844]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:46.844]                     rootPath = tempdir()) 
[09:29:46.844]                   {
[09:29:46.844]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:46.844]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:46.844]                       tmpdir = path, fileext = ".rds")
[09:29:46.844]                     save_rds(obj, file)
[09:29:46.844]                   }
[09:29:46.844]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:46.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.844]                   {
[09:29:46.844]                     inherits <- base::inherits
[09:29:46.844]                     invokeRestart <- base::invokeRestart
[09:29:46.844]                     is.null <- base::is.null
[09:29:46.844]                     muffled <- FALSE
[09:29:46.844]                     if (inherits(cond, "message")) {
[09:29:46.844]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:46.844]                       if (muffled) 
[09:29:46.844]                         invokeRestart("muffleMessage")
[09:29:46.844]                     }
[09:29:46.844]                     else if (inherits(cond, "warning")) {
[09:29:46.844]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:46.844]                       if (muffled) 
[09:29:46.844]                         invokeRestart("muffleWarning")
[09:29:46.844]                     }
[09:29:46.844]                     else if (inherits(cond, "condition")) {
[09:29:46.844]                       if (!is.null(pattern)) {
[09:29:46.844]                         computeRestarts <- base::computeRestarts
[09:29:46.844]                         grepl <- base::grepl
[09:29:46.844]                         restarts <- computeRestarts(cond)
[09:29:46.844]                         for (restart in restarts) {
[09:29:46.844]                           name <- restart$name
[09:29:46.844]                           if (is.null(name)) 
[09:29:46.844]                             next
[09:29:46.844]                           if (!grepl(pattern, name)) 
[09:29:46.844]                             next
[09:29:46.844]                           invokeRestart(restart)
[09:29:46.844]                           muffled <- TRUE
[09:29:46.844]                           break
[09:29:46.844]                         }
[09:29:46.844]                       }
[09:29:46.844]                     }
[09:29:46.844]                     invisible(muffled)
[09:29:46.844]                   }
[09:29:46.844]                   muffleCondition(cond)
[09:29:46.844]                 })
[09:29:46.844]             }))
[09:29:46.844]             future::FutureResult(value = ...future.value$value, 
[09:29:46.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.844]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.844]                     ...future.globalenv.names))
[09:29:46.844]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.844]         }, condition = base::local({
[09:29:46.844]             c <- base::c
[09:29:46.844]             inherits <- base::inherits
[09:29:46.844]             invokeRestart <- base::invokeRestart
[09:29:46.844]             length <- base::length
[09:29:46.844]             list <- base::list
[09:29:46.844]             seq.int <- base::seq.int
[09:29:46.844]             signalCondition <- base::signalCondition
[09:29:46.844]             sys.calls <- base::sys.calls
[09:29:46.844]             `[[` <- base::`[[`
[09:29:46.844]             `+` <- base::`+`
[09:29:46.844]             `<<-` <- base::`<<-`
[09:29:46.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.844]                   3L)]
[09:29:46.844]             }
[09:29:46.844]             function(cond) {
[09:29:46.844]                 is_error <- inherits(cond, "error")
[09:29:46.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.844]                   NULL)
[09:29:46.844]                 if (is_error) {
[09:29:46.844]                   sessionInformation <- function() {
[09:29:46.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.844]                       search = base::search(), system = base::Sys.info())
[09:29:46.844]                   }
[09:29:46.844]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.844]                     cond$call), session = sessionInformation(), 
[09:29:46.844]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.844]                   signalCondition(cond)
[09:29:46.844]                 }
[09:29:46.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.844]                 "immediateCondition"))) {
[09:29:46.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.844]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.844]                   if (TRUE && !signal) {
[09:29:46.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.844]                     {
[09:29:46.844]                       inherits <- base::inherits
[09:29:46.844]                       invokeRestart <- base::invokeRestart
[09:29:46.844]                       is.null <- base::is.null
[09:29:46.844]                       muffled <- FALSE
[09:29:46.844]                       if (inherits(cond, "message")) {
[09:29:46.844]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.844]                         if (muffled) 
[09:29:46.844]                           invokeRestart("muffleMessage")
[09:29:46.844]                       }
[09:29:46.844]                       else if (inherits(cond, "warning")) {
[09:29:46.844]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.844]                         if (muffled) 
[09:29:46.844]                           invokeRestart("muffleWarning")
[09:29:46.844]                       }
[09:29:46.844]                       else if (inherits(cond, "condition")) {
[09:29:46.844]                         if (!is.null(pattern)) {
[09:29:46.844]                           computeRestarts <- base::computeRestarts
[09:29:46.844]                           grepl <- base::grepl
[09:29:46.844]                           restarts <- computeRestarts(cond)
[09:29:46.844]                           for (restart in restarts) {
[09:29:46.844]                             name <- restart$name
[09:29:46.844]                             if (is.null(name)) 
[09:29:46.844]                               next
[09:29:46.844]                             if (!grepl(pattern, name)) 
[09:29:46.844]                               next
[09:29:46.844]                             invokeRestart(restart)
[09:29:46.844]                             muffled <- TRUE
[09:29:46.844]                             break
[09:29:46.844]                           }
[09:29:46.844]                         }
[09:29:46.844]                       }
[09:29:46.844]                       invisible(muffled)
[09:29:46.844]                     }
[09:29:46.844]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.844]                   }
[09:29:46.844]                 }
[09:29:46.844]                 else {
[09:29:46.844]                   if (TRUE) {
[09:29:46.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.844]                     {
[09:29:46.844]                       inherits <- base::inherits
[09:29:46.844]                       invokeRestart <- base::invokeRestart
[09:29:46.844]                       is.null <- base::is.null
[09:29:46.844]                       muffled <- FALSE
[09:29:46.844]                       if (inherits(cond, "message")) {
[09:29:46.844]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.844]                         if (muffled) 
[09:29:46.844]                           invokeRestart("muffleMessage")
[09:29:46.844]                       }
[09:29:46.844]                       else if (inherits(cond, "warning")) {
[09:29:46.844]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.844]                         if (muffled) 
[09:29:46.844]                           invokeRestart("muffleWarning")
[09:29:46.844]                       }
[09:29:46.844]                       else if (inherits(cond, "condition")) {
[09:29:46.844]                         if (!is.null(pattern)) {
[09:29:46.844]                           computeRestarts <- base::computeRestarts
[09:29:46.844]                           grepl <- base::grepl
[09:29:46.844]                           restarts <- computeRestarts(cond)
[09:29:46.844]                           for (restart in restarts) {
[09:29:46.844]                             name <- restart$name
[09:29:46.844]                             if (is.null(name)) 
[09:29:46.844]                               next
[09:29:46.844]                             if (!grepl(pattern, name)) 
[09:29:46.844]                               next
[09:29:46.844]                             invokeRestart(restart)
[09:29:46.844]                             muffled <- TRUE
[09:29:46.844]                             break
[09:29:46.844]                           }
[09:29:46.844]                         }
[09:29:46.844]                       }
[09:29:46.844]                       invisible(muffled)
[09:29:46.844]                     }
[09:29:46.844]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.844]                   }
[09:29:46.844]                 }
[09:29:46.844]             }
[09:29:46.844]         }))
[09:29:46.844]     }, error = function(ex) {
[09:29:46.844]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.844]                 ...future.rng), started = ...future.startTime, 
[09:29:46.844]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.844]             version = "1.8"), class = "FutureResult")
[09:29:46.844]     }, finally = {
[09:29:46.844]         if (!identical(...future.workdir, getwd())) 
[09:29:46.844]             setwd(...future.workdir)
[09:29:46.844]         {
[09:29:46.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.844]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.844]             }
[09:29:46.844]             base::options(...future.oldOptions)
[09:29:46.844]             if (.Platform$OS.type == "windows") {
[09:29:46.844]                 old_names <- names(...future.oldEnvVars)
[09:29:46.844]                 envs <- base::Sys.getenv()
[09:29:46.844]                 names <- names(envs)
[09:29:46.844]                 common <- intersect(names, old_names)
[09:29:46.844]                 added <- setdiff(names, old_names)
[09:29:46.844]                 removed <- setdiff(old_names, names)
[09:29:46.844]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.844]                   envs[common]]
[09:29:46.844]                 NAMES <- toupper(changed)
[09:29:46.844]                 args <- list()
[09:29:46.844]                 for (kk in seq_along(NAMES)) {
[09:29:46.844]                   name <- changed[[kk]]
[09:29:46.844]                   NAME <- NAMES[[kk]]
[09:29:46.844]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.844]                     next
[09:29:46.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.844]                 }
[09:29:46.844]                 NAMES <- toupper(added)
[09:29:46.844]                 for (kk in seq_along(NAMES)) {
[09:29:46.844]                   name <- added[[kk]]
[09:29:46.844]                   NAME <- NAMES[[kk]]
[09:29:46.844]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.844]                     next
[09:29:46.844]                   args[[name]] <- ""
[09:29:46.844]                 }
[09:29:46.844]                 NAMES <- toupper(removed)
[09:29:46.844]                 for (kk in seq_along(NAMES)) {
[09:29:46.844]                   name <- removed[[kk]]
[09:29:46.844]                   NAME <- NAMES[[kk]]
[09:29:46.844]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.844]                     next
[09:29:46.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.844]                 }
[09:29:46.844]                 if (length(args) > 0) 
[09:29:46.844]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.844]             }
[09:29:46.844]             else {
[09:29:46.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.844]             }
[09:29:46.844]             {
[09:29:46.844]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.844]                   0L) {
[09:29:46.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.844]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.844]                   base::options(opts)
[09:29:46.844]                 }
[09:29:46.844]                 {
[09:29:46.844]                   {
[09:29:46.844]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:46.844]                     NULL
[09:29:46.844]                   }
[09:29:46.844]                   options(future.plan = NULL)
[09:29:46.844]                   if (is.na(NA_character_)) 
[09:29:46.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.844]                     .init = FALSE)
[09:29:46.844]                 }
[09:29:46.844]             }
[09:29:46.844]         }
[09:29:46.844]     })
[09:29:46.844]     if (TRUE) {
[09:29:46.844]         base::sink(type = "output", split = FALSE)
[09:29:46.844]         if (TRUE) {
[09:29:46.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.844]         }
[09:29:46.844]         else {
[09:29:46.844]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.844]         }
[09:29:46.844]         base::close(...future.stdout)
[09:29:46.844]         ...future.stdout <- NULL
[09:29:46.844]     }
[09:29:46.844]     ...future.result$conditions <- ...future.conditions
[09:29:46.844]     ...future.result$finished <- base::Sys.time()
[09:29:46.844]     ...future.result
[09:29:46.844] }
[09:29:46.846] assign_globals() ...
[09:29:46.847] List of 11
[09:29:46.847]  $ ...future.FUN            :function (x, ...)  
[09:29:46.847]  $ x_FUN                    :function (x)  
[09:29:46.847]  $ times                    : int 2
[09:29:46.847]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.847]  $ stop_if_not              :function (...)  
[09:29:46.847]  $ dim                      : NULL
[09:29:46.847]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:46.847]  $ future.call.arguments    : list()
[09:29:46.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.847]  $ ...future.elements_ii    :List of 5
[09:29:46.847]   ..$ : int 1
[09:29:46.847]   ..$ : int 2
[09:29:46.847]   ..$ : int 3
[09:29:46.847]   ..$ : int 4
[09:29:46.847]   ..$ : int 5
[09:29:46.847]  $ ...future.seeds_ii       : NULL
[09:29:46.847]  $ ...future.globals.maxSize: NULL
[09:29:46.847]  - attr(*, "where")=List of 11
[09:29:46.847]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.847]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.847]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.847]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.847]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.847]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.847]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.847]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.847]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.847]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.847]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.847]  - attr(*, "resolved")= logi FALSE
[09:29:46.847]  - attr(*, "total_size")= num 96456
[09:29:46.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.847]  - attr(*, "already-done")= logi TRUE
[09:29:46.856] - copied ‘...future.FUN’ to environment
[09:29:46.856] - reassign environment for ‘x_FUN’
[09:29:46.856] - copied ‘x_FUN’ to environment
[09:29:46.856] - copied ‘times’ to environment
[09:29:46.856] - copied ‘stopf’ to environment
[09:29:46.856] - copied ‘stop_if_not’ to environment
[09:29:46.856] - copied ‘dim’ to environment
[09:29:46.856] - copied ‘valid_types’ to environment
[09:29:46.856] - copied ‘future.call.arguments’ to environment
[09:29:46.857] - copied ‘...future.elements_ii’ to environment
[09:29:46.857] - copied ‘...future.seeds_ii’ to environment
[09:29:46.857] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.857] assign_globals() ... done
[09:29:46.857] requestCore(): workers = 2
[09:29:46.859] MulticoreFuture started
[09:29:46.860] - Launch lazy future ... done
[09:29:46.860] run() for ‘MulticoreFuture’ ... done
[09:29:46.861] Created future:
[09:29:46.861] plan(): Setting new future strategy stack:
[09:29:46.862] List of future strategies:
[09:29:46.862] 1. sequential:
[09:29:46.862]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.862]    - tweaked: FALSE
[09:29:46.862]    - call: NULL
[09:29:46.863] plan(): nbrOfWorkers() = 1
[09:29:46.865] plan(): Setting new future strategy stack:
[09:29:46.865] List of future strategies:
[09:29:46.865] 1. multicore:
[09:29:46.865]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.865]    - tweaked: FALSE
[09:29:46.865]    - call: plan(strategy)
[09:29:46.871] plan(): nbrOfWorkers() = 2
[09:29:46.861] MulticoreFuture:
[09:29:46.861] Label: ‘future_vapply-1’
[09:29:46.861] Expression:
[09:29:46.861] {
[09:29:46.861]     do.call(function(...) {
[09:29:46.861]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.861]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.861]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.861]             on.exit(options(oopts), add = TRUE)
[09:29:46.861]         }
[09:29:46.861]         {
[09:29:46.861]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.861]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.861]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.861]             })
[09:29:46.861]         }
[09:29:46.861]     }, args = future.call.arguments)
[09:29:46.861] }
[09:29:46.861] Lazy evaluation: FALSE
[09:29:46.861] Asynchronous evaluation: TRUE
[09:29:46.861] Local evaluation: TRUE
[09:29:46.861] Environment: R_GlobalEnv
[09:29:46.861] Capture standard output: TRUE
[09:29:46.861] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.861] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.861] Packages: 1 packages (‘future.apply’)
[09:29:46.861] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.861] Resolved: TRUE
[09:29:46.861] Value: <not collected>
[09:29:46.861] Conditions captured: <none>
[09:29:46.861] Early signaling: FALSE
[09:29:46.861] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.861] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.872] Chunk #1 of 2 ... DONE
[09:29:46.872] Chunk #2 of 2 ...
[09:29:46.872]  - Finding globals in 'X' for chunk #2 ...
[09:29:46.872] getGlobalsAndPackages() ...
[09:29:46.872] Searching for globals...
[09:29:46.873] 
[09:29:46.873] Searching for globals ... DONE
[09:29:46.873] - globals: [0] <none>
[09:29:46.873] getGlobalsAndPackages() ... DONE
[09:29:46.873]    + additional globals found: [n=0] 
[09:29:46.874]    + additional namespaces needed: [n=0] 
[09:29:46.874]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:46.874]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.874]  - seeds: <none>
[09:29:46.874]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.874] getGlobalsAndPackages() ...
[09:29:46.874] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.875] Resolving globals: FALSE
[09:29:46.875] Tweak future expression to call with '...' arguments ...
[09:29:46.875] {
[09:29:46.875]     do.call(function(...) {
[09:29:46.875]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.875]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.875]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.875]             on.exit(options(oopts), add = TRUE)
[09:29:46.875]         }
[09:29:46.875]         {
[09:29:46.875]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.875]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.875]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.875]             })
[09:29:46.875]         }
[09:29:46.875]     }, args = future.call.arguments)
[09:29:46.875] }
[09:29:46.875] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.876] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.876] - packages: [1] ‘future.apply’
[09:29:46.877] getGlobalsAndPackages() ... DONE
[09:29:46.877] run() for ‘Future’ ...
[09:29:46.877] - state: ‘created’
[09:29:46.877] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:46.882] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:46.882]   - Field: ‘label’
[09:29:46.882]   - Field: ‘local’
[09:29:46.882]   - Field: ‘owner’
[09:29:46.883]   - Field: ‘envir’
[09:29:46.883]   - Field: ‘workers’
[09:29:46.883]   - Field: ‘packages’
[09:29:46.883]   - Field: ‘gc’
[09:29:46.883]   - Field: ‘job’
[09:29:46.883]   - Field: ‘conditions’
[09:29:46.883]   - Field: ‘expr’
[09:29:46.884]   - Field: ‘uuid’
[09:29:46.884]   - Field: ‘seed’
[09:29:46.884]   - Field: ‘version’
[09:29:46.884]   - Field: ‘result’
[09:29:46.884]   - Field: ‘asynchronous’
[09:29:46.884]   - Field: ‘calls’
[09:29:46.884]   - Field: ‘globals’
[09:29:46.885]   - Field: ‘stdout’
[09:29:46.885]   - Field: ‘earlySignal’
[09:29:46.885]   - Field: ‘lazy’
[09:29:46.885]   - Field: ‘state’
[09:29:46.885] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:46.885] - Launch lazy future ...
[09:29:46.886] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.886] Packages needed by future strategies (n = 0): <none>
[09:29:46.887] {
[09:29:46.887]     {
[09:29:46.887]         {
[09:29:46.887]             ...future.startTime <- base::Sys.time()
[09:29:46.887]             {
[09:29:46.887]                 {
[09:29:46.887]                   {
[09:29:46.887]                     {
[09:29:46.887]                       {
[09:29:46.887]                         base::local({
[09:29:46.887]                           has_future <- base::requireNamespace("future", 
[09:29:46.887]                             quietly = TRUE)
[09:29:46.887]                           if (has_future) {
[09:29:46.887]                             ns <- base::getNamespace("future")
[09:29:46.887]                             version <- ns[[".package"]][["version"]]
[09:29:46.887]                             if (is.null(version)) 
[09:29:46.887]                               version <- utils::packageVersion("future")
[09:29:46.887]                           }
[09:29:46.887]                           else {
[09:29:46.887]                             version <- NULL
[09:29:46.887]                           }
[09:29:46.887]                           if (!has_future || version < "1.8.0") {
[09:29:46.887]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.887]                               "", base::R.version$version.string), 
[09:29:46.887]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:46.887]                                 base::R.version$platform, 8 * 
[09:29:46.887]                                   base::.Machine$sizeof.pointer), 
[09:29:46.887]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.887]                                 "release", "version")], collapse = " "), 
[09:29:46.887]                               hostname = base::Sys.info()[["nodename"]])
[09:29:46.887]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.887]                               info)
[09:29:46.887]                             info <- base::paste(info, collapse = "; ")
[09:29:46.887]                             if (!has_future) {
[09:29:46.887]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.887]                                 info)
[09:29:46.887]                             }
[09:29:46.887]                             else {
[09:29:46.887]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.887]                                 info, version)
[09:29:46.887]                             }
[09:29:46.887]                             base::stop(msg)
[09:29:46.887]                           }
[09:29:46.887]                         })
[09:29:46.887]                       }
[09:29:46.887]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:46.887]                       base::options(mc.cores = 1L)
[09:29:46.887]                     }
[09:29:46.887]                     base::local({
[09:29:46.887]                       for (pkg in "future.apply") {
[09:29:46.887]                         base::loadNamespace(pkg)
[09:29:46.887]                         base::library(pkg, character.only = TRUE)
[09:29:46.887]                       }
[09:29:46.887]                     })
[09:29:46.887]                   }
[09:29:46.887]                   ...future.strategy.old <- future::plan("list")
[09:29:46.887]                   options(future.plan = NULL)
[09:29:46.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.887]                 }
[09:29:46.887]                 ...future.workdir <- getwd()
[09:29:46.887]             }
[09:29:46.887]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.887]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.887]         }
[09:29:46.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.887]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:46.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.887]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.887]             base::names(...future.oldOptions))
[09:29:46.887]     }
[09:29:46.887]     if (FALSE) {
[09:29:46.887]     }
[09:29:46.887]     else {
[09:29:46.887]         if (TRUE) {
[09:29:46.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.887]                 open = "w")
[09:29:46.887]         }
[09:29:46.887]         else {
[09:29:46.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.887]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.887]         }
[09:29:46.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.887]             base::sink(type = "output", split = FALSE)
[09:29:46.887]             base::close(...future.stdout)
[09:29:46.887]         }, add = TRUE)
[09:29:46.887]     }
[09:29:46.887]     ...future.frame <- base::sys.nframe()
[09:29:46.887]     ...future.conditions <- base::list()
[09:29:46.887]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.887]     if (FALSE) {
[09:29:46.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.887]     }
[09:29:46.887]     ...future.result <- base::tryCatch({
[09:29:46.887]         base::withCallingHandlers({
[09:29:46.887]             ...future.value <- base::withVisible(base::local({
[09:29:46.887]                 withCallingHandlers({
[09:29:46.887]                   {
[09:29:46.887]                     do.call(function(...) {
[09:29:46.887]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.887]                       if (!identical(...future.globals.maxSize.org, 
[09:29:46.887]                         ...future.globals.maxSize)) {
[09:29:46.887]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.887]                         on.exit(options(oopts), add = TRUE)
[09:29:46.887]                       }
[09:29:46.887]                       {
[09:29:46.887]                         lapply(seq_along(...future.elements_ii), 
[09:29:46.887]                           FUN = function(jj) {
[09:29:46.887]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.887]                             ...future.FUN(...future.X_jj, ...)
[09:29:46.887]                           })
[09:29:46.887]                       }
[09:29:46.887]                     }, args = future.call.arguments)
[09:29:46.887]                   }
[09:29:46.887]                 }, immediateCondition = function(cond) {
[09:29:46.887]                   save_rds <- function (object, pathname, ...) 
[09:29:46.887]                   {
[09:29:46.887]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:46.887]                     if (file_test("-f", pathname_tmp)) {
[09:29:46.887]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.887]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:46.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.887]                         fi_tmp[["mtime"]])
[09:29:46.887]                     }
[09:29:46.887]                     tryCatch({
[09:29:46.887]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:46.887]                     }, error = function(ex) {
[09:29:46.887]                       msg <- conditionMessage(ex)
[09:29:46.887]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.887]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:46.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.887]                         fi_tmp[["mtime"]], msg)
[09:29:46.887]                       ex$message <- msg
[09:29:46.887]                       stop(ex)
[09:29:46.887]                     })
[09:29:46.887]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:46.887]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:46.887]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:46.887]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.887]                       fi <- file.info(pathname)
[09:29:46.887]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:46.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.887]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:46.887]                         fi[["size"]], fi[["mtime"]])
[09:29:46.887]                       stop(msg)
[09:29:46.887]                     }
[09:29:46.887]                     invisible(pathname)
[09:29:46.887]                   }
[09:29:46.887]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:46.887]                     rootPath = tempdir()) 
[09:29:46.887]                   {
[09:29:46.887]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:46.887]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:46.887]                       tmpdir = path, fileext = ".rds")
[09:29:46.887]                     save_rds(obj, file)
[09:29:46.887]                   }
[09:29:46.887]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:46.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.887]                   {
[09:29:46.887]                     inherits <- base::inherits
[09:29:46.887]                     invokeRestart <- base::invokeRestart
[09:29:46.887]                     is.null <- base::is.null
[09:29:46.887]                     muffled <- FALSE
[09:29:46.887]                     if (inherits(cond, "message")) {
[09:29:46.887]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:46.887]                       if (muffled) 
[09:29:46.887]                         invokeRestart("muffleMessage")
[09:29:46.887]                     }
[09:29:46.887]                     else if (inherits(cond, "warning")) {
[09:29:46.887]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:46.887]                       if (muffled) 
[09:29:46.887]                         invokeRestart("muffleWarning")
[09:29:46.887]                     }
[09:29:46.887]                     else if (inherits(cond, "condition")) {
[09:29:46.887]                       if (!is.null(pattern)) {
[09:29:46.887]                         computeRestarts <- base::computeRestarts
[09:29:46.887]                         grepl <- base::grepl
[09:29:46.887]                         restarts <- computeRestarts(cond)
[09:29:46.887]                         for (restart in restarts) {
[09:29:46.887]                           name <- restart$name
[09:29:46.887]                           if (is.null(name)) 
[09:29:46.887]                             next
[09:29:46.887]                           if (!grepl(pattern, name)) 
[09:29:46.887]                             next
[09:29:46.887]                           invokeRestart(restart)
[09:29:46.887]                           muffled <- TRUE
[09:29:46.887]                           break
[09:29:46.887]                         }
[09:29:46.887]                       }
[09:29:46.887]                     }
[09:29:46.887]                     invisible(muffled)
[09:29:46.887]                   }
[09:29:46.887]                   muffleCondition(cond)
[09:29:46.887]                 })
[09:29:46.887]             }))
[09:29:46.887]             future::FutureResult(value = ...future.value$value, 
[09:29:46.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.887]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.887]                     ...future.globalenv.names))
[09:29:46.887]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.887]         }, condition = base::local({
[09:29:46.887]             c <- base::c
[09:29:46.887]             inherits <- base::inherits
[09:29:46.887]             invokeRestart <- base::invokeRestart
[09:29:46.887]             length <- base::length
[09:29:46.887]             list <- base::list
[09:29:46.887]             seq.int <- base::seq.int
[09:29:46.887]             signalCondition <- base::signalCondition
[09:29:46.887]             sys.calls <- base::sys.calls
[09:29:46.887]             `[[` <- base::`[[`
[09:29:46.887]             `+` <- base::`+`
[09:29:46.887]             `<<-` <- base::`<<-`
[09:29:46.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.887]                   3L)]
[09:29:46.887]             }
[09:29:46.887]             function(cond) {
[09:29:46.887]                 is_error <- inherits(cond, "error")
[09:29:46.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.887]                   NULL)
[09:29:46.887]                 if (is_error) {
[09:29:46.887]                   sessionInformation <- function() {
[09:29:46.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.887]                       search = base::search(), system = base::Sys.info())
[09:29:46.887]                   }
[09:29:46.887]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.887]                     cond$call), session = sessionInformation(), 
[09:29:46.887]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.887]                   signalCondition(cond)
[09:29:46.887]                 }
[09:29:46.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.887]                 "immediateCondition"))) {
[09:29:46.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.887]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.887]                   if (TRUE && !signal) {
[09:29:46.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.887]                     {
[09:29:46.887]                       inherits <- base::inherits
[09:29:46.887]                       invokeRestart <- base::invokeRestart
[09:29:46.887]                       is.null <- base::is.null
[09:29:46.887]                       muffled <- FALSE
[09:29:46.887]                       if (inherits(cond, "message")) {
[09:29:46.887]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.887]                         if (muffled) 
[09:29:46.887]                           invokeRestart("muffleMessage")
[09:29:46.887]                       }
[09:29:46.887]                       else if (inherits(cond, "warning")) {
[09:29:46.887]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.887]                         if (muffled) 
[09:29:46.887]                           invokeRestart("muffleWarning")
[09:29:46.887]                       }
[09:29:46.887]                       else if (inherits(cond, "condition")) {
[09:29:46.887]                         if (!is.null(pattern)) {
[09:29:46.887]                           computeRestarts <- base::computeRestarts
[09:29:46.887]                           grepl <- base::grepl
[09:29:46.887]                           restarts <- computeRestarts(cond)
[09:29:46.887]                           for (restart in restarts) {
[09:29:46.887]                             name <- restart$name
[09:29:46.887]                             if (is.null(name)) 
[09:29:46.887]                               next
[09:29:46.887]                             if (!grepl(pattern, name)) 
[09:29:46.887]                               next
[09:29:46.887]                             invokeRestart(restart)
[09:29:46.887]                             muffled <- TRUE
[09:29:46.887]                             break
[09:29:46.887]                           }
[09:29:46.887]                         }
[09:29:46.887]                       }
[09:29:46.887]                       invisible(muffled)
[09:29:46.887]                     }
[09:29:46.887]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.887]                   }
[09:29:46.887]                 }
[09:29:46.887]                 else {
[09:29:46.887]                   if (TRUE) {
[09:29:46.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.887]                     {
[09:29:46.887]                       inherits <- base::inherits
[09:29:46.887]                       invokeRestart <- base::invokeRestart
[09:29:46.887]                       is.null <- base::is.null
[09:29:46.887]                       muffled <- FALSE
[09:29:46.887]                       if (inherits(cond, "message")) {
[09:29:46.887]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.887]                         if (muffled) 
[09:29:46.887]                           invokeRestart("muffleMessage")
[09:29:46.887]                       }
[09:29:46.887]                       else if (inherits(cond, "warning")) {
[09:29:46.887]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.887]                         if (muffled) 
[09:29:46.887]                           invokeRestart("muffleWarning")
[09:29:46.887]                       }
[09:29:46.887]                       else if (inherits(cond, "condition")) {
[09:29:46.887]                         if (!is.null(pattern)) {
[09:29:46.887]                           computeRestarts <- base::computeRestarts
[09:29:46.887]                           grepl <- base::grepl
[09:29:46.887]                           restarts <- computeRestarts(cond)
[09:29:46.887]                           for (restart in restarts) {
[09:29:46.887]                             name <- restart$name
[09:29:46.887]                             if (is.null(name)) 
[09:29:46.887]                               next
[09:29:46.887]                             if (!grepl(pattern, name)) 
[09:29:46.887]                               next
[09:29:46.887]                             invokeRestart(restart)
[09:29:46.887]                             muffled <- TRUE
[09:29:46.887]                             break
[09:29:46.887]                           }
[09:29:46.887]                         }
[09:29:46.887]                       }
[09:29:46.887]                       invisible(muffled)
[09:29:46.887]                     }
[09:29:46.887]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.887]                   }
[09:29:46.887]                 }
[09:29:46.887]             }
[09:29:46.887]         }))
[09:29:46.887]     }, error = function(ex) {
[09:29:46.887]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.887]                 ...future.rng), started = ...future.startTime, 
[09:29:46.887]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.887]             version = "1.8"), class = "FutureResult")
[09:29:46.887]     }, finally = {
[09:29:46.887]         if (!identical(...future.workdir, getwd())) 
[09:29:46.887]             setwd(...future.workdir)
[09:29:46.887]         {
[09:29:46.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.887]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.887]             }
[09:29:46.887]             base::options(...future.oldOptions)
[09:29:46.887]             if (.Platform$OS.type == "windows") {
[09:29:46.887]                 old_names <- names(...future.oldEnvVars)
[09:29:46.887]                 envs <- base::Sys.getenv()
[09:29:46.887]                 names <- names(envs)
[09:29:46.887]                 common <- intersect(names, old_names)
[09:29:46.887]                 added <- setdiff(names, old_names)
[09:29:46.887]                 removed <- setdiff(old_names, names)
[09:29:46.887]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.887]                   envs[common]]
[09:29:46.887]                 NAMES <- toupper(changed)
[09:29:46.887]                 args <- list()
[09:29:46.887]                 for (kk in seq_along(NAMES)) {
[09:29:46.887]                   name <- changed[[kk]]
[09:29:46.887]                   NAME <- NAMES[[kk]]
[09:29:46.887]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.887]                     next
[09:29:46.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.887]                 }
[09:29:46.887]                 NAMES <- toupper(added)
[09:29:46.887]                 for (kk in seq_along(NAMES)) {
[09:29:46.887]                   name <- added[[kk]]
[09:29:46.887]                   NAME <- NAMES[[kk]]
[09:29:46.887]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.887]                     next
[09:29:46.887]                   args[[name]] <- ""
[09:29:46.887]                 }
[09:29:46.887]                 NAMES <- toupper(removed)
[09:29:46.887]                 for (kk in seq_along(NAMES)) {
[09:29:46.887]                   name <- removed[[kk]]
[09:29:46.887]                   NAME <- NAMES[[kk]]
[09:29:46.887]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.887]                     next
[09:29:46.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.887]                 }
[09:29:46.887]                 if (length(args) > 0) 
[09:29:46.887]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.887]             }
[09:29:46.887]             else {
[09:29:46.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.887]             }
[09:29:46.887]             {
[09:29:46.887]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.887]                   0L) {
[09:29:46.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.887]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.887]                   base::options(opts)
[09:29:46.887]                 }
[09:29:46.887]                 {
[09:29:46.887]                   {
[09:29:46.887]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:46.887]                     NULL
[09:29:46.887]                   }
[09:29:46.887]                   options(future.plan = NULL)
[09:29:46.887]                   if (is.na(NA_character_)) 
[09:29:46.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.887]                     .init = FALSE)
[09:29:46.887]                 }
[09:29:46.887]             }
[09:29:46.887]         }
[09:29:46.887]     })
[09:29:46.887]     if (TRUE) {
[09:29:46.887]         base::sink(type = "output", split = FALSE)
[09:29:46.887]         if (TRUE) {
[09:29:46.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.887]         }
[09:29:46.887]         else {
[09:29:46.887]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.887]         }
[09:29:46.887]         base::close(...future.stdout)
[09:29:46.887]         ...future.stdout <- NULL
[09:29:46.887]     }
[09:29:46.887]     ...future.result$conditions <- ...future.conditions
[09:29:46.887]     ...future.result$finished <- base::Sys.time()
[09:29:46.887]     ...future.result
[09:29:46.887] }
[09:29:46.890] assign_globals() ...
[09:29:46.890] List of 11
[09:29:46.890]  $ ...future.FUN            :function (x, ...)  
[09:29:46.890]  $ x_FUN                    :function (x)  
[09:29:46.890]  $ times                    : int 2
[09:29:46.890]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.890]  $ stop_if_not              :function (...)  
[09:29:46.890]  $ dim                      : NULL
[09:29:46.890]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:46.890]  $ future.call.arguments    : list()
[09:29:46.890]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.890]  $ ...future.elements_ii    :List of 5
[09:29:46.890]   ..$ : int 6
[09:29:46.890]   ..$ : int 7
[09:29:46.890]   ..$ : int 8
[09:29:46.890]   ..$ : int 9
[09:29:46.890]   ..$ : int 10
[09:29:46.890]  $ ...future.seeds_ii       : NULL
[09:29:46.890]  $ ...future.globals.maxSize: NULL
[09:29:46.890]  - attr(*, "where")=List of 11
[09:29:46.890]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.890]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.890]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.890]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.890]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.890]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.890]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.890]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.890]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.890]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.890]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.890]  - attr(*, "resolved")= logi FALSE
[09:29:46.890]  - attr(*, "total_size")= num 96456
[09:29:46.890]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.890]  - attr(*, "already-done")= logi TRUE
[09:29:46.904] - copied ‘...future.FUN’ to environment
[09:29:46.905] - reassign environment for ‘x_FUN’
[09:29:46.905] - copied ‘x_FUN’ to environment
[09:29:46.905] - copied ‘times’ to environment
[09:29:46.905] - copied ‘stopf’ to environment
[09:29:46.905] - copied ‘stop_if_not’ to environment
[09:29:46.905] - copied ‘dim’ to environment
[09:29:46.905] - copied ‘valid_types’ to environment
[09:29:46.905] - copied ‘future.call.arguments’ to environment
[09:29:46.906] - copied ‘...future.elements_ii’ to environment
[09:29:46.906] - copied ‘...future.seeds_ii’ to environment
[09:29:46.906] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.906] assign_globals() ... done
[09:29:46.906] requestCore(): workers = 2
[09:29:46.908] MulticoreFuture started
[09:29:46.909] - Launch lazy future ... done
[09:29:46.910] run() for ‘MulticoreFuture’ ... done
[09:29:46.910] Created future:
[09:29:46.910] plan(): Setting new future strategy stack:
[09:29:46.911] List of future strategies:
[09:29:46.911] 1. sequential:
[09:29:46.911]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.911]    - tweaked: FALSE
[09:29:46.911]    - call: NULL
[09:29:46.912] plan(): nbrOfWorkers() = 1
[09:29:46.915] plan(): Setting new future strategy stack:
[09:29:46.915] List of future strategies:
[09:29:46.915] 1. multicore:
[09:29:46.915]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.915]    - tweaked: FALSE
[09:29:46.915]    - call: plan(strategy)
[09:29:46.921] plan(): nbrOfWorkers() = 2
[09:29:46.910] MulticoreFuture:
[09:29:46.910] Label: ‘future_vapply-2’
[09:29:46.910] Expression:
[09:29:46.910] {
[09:29:46.910]     do.call(function(...) {
[09:29:46.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.910]             on.exit(options(oopts), add = TRUE)
[09:29:46.910]         }
[09:29:46.910]         {
[09:29:46.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.910]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.910]             })
[09:29:46.910]         }
[09:29:46.910]     }, args = future.call.arguments)
[09:29:46.910] }
[09:29:46.910] Lazy evaluation: FALSE
[09:29:46.910] Asynchronous evaluation: TRUE
[09:29:46.910] Local evaluation: TRUE
[09:29:46.910] Environment: R_GlobalEnv
[09:29:46.910] Capture standard output: TRUE
[09:29:46.910] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.910] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.910] Packages: 1 packages (‘future.apply’)
[09:29:46.910] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.910] Resolved: TRUE
[09:29:46.910] Value: <not collected>
[09:29:46.910] Conditions captured: <none>
[09:29:46.910] Early signaling: FALSE
[09:29:46.910] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.910] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.922] Chunk #2 of 2 ... DONE
[09:29:46.922] Launching 2 futures (chunks) ... DONE
[09:29:46.922] Resolving 2 futures (chunks) ...
[09:29:46.922] resolve() on list ...
[09:29:46.922]  recursive: 0
[09:29:46.922]  length: 2
[09:29:46.923] 
[09:29:46.923] Future #1
[09:29:46.923] result() for MulticoreFuture ...
[09:29:46.924] result() for MulticoreFuture ...
[09:29:46.924] result() for MulticoreFuture ... done
[09:29:46.924] result() for MulticoreFuture ... done
[09:29:46.924] result() for MulticoreFuture ...
[09:29:46.924] result() for MulticoreFuture ... done
[09:29:46.925] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:46.925] - nx: 2
[09:29:46.925] - relay: TRUE
[09:29:46.925] - stdout: TRUE
[09:29:46.925] - signal: TRUE
[09:29:46.925] - resignal: FALSE
[09:29:46.925] - force: TRUE
[09:29:46.926] - relayed: [n=2] FALSE, FALSE
[09:29:46.926] - queued futures: [n=2] FALSE, FALSE
[09:29:46.926]  - until=1
[09:29:46.926]  - relaying element #1
[09:29:46.926] result() for MulticoreFuture ...
[09:29:46.926] result() for MulticoreFuture ... done
[09:29:46.926] result() for MulticoreFuture ...
[09:29:46.927] result() for MulticoreFuture ... done
[09:29:46.927] result() for MulticoreFuture ...
[09:29:46.927] result() for MulticoreFuture ... done
[09:29:46.927] result() for MulticoreFuture ...
[09:29:46.927] result() for MulticoreFuture ... done
[09:29:46.927] - relayed: [n=2] TRUE, FALSE
[09:29:46.927] - queued futures: [n=2] TRUE, FALSE
[09:29:46.928] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:46.928]  length: 1 (resolved future 1)
[09:29:46.928] Future #2
[09:29:46.928] result() for MulticoreFuture ...
[09:29:46.929] result() for MulticoreFuture ...
[09:29:46.929] result() for MulticoreFuture ... done
[09:29:46.929] result() for MulticoreFuture ... done
[09:29:46.929] result() for MulticoreFuture ...
[09:29:46.930] result() for MulticoreFuture ... done
[09:29:46.930] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:46.930] - nx: 2
[09:29:46.930] - relay: TRUE
[09:29:46.930] - stdout: TRUE
[09:29:46.930] - signal: TRUE
[09:29:46.930] - resignal: FALSE
[09:29:46.930] - force: TRUE
[09:29:46.931] - relayed: [n=2] TRUE, FALSE
[09:29:46.931] - queued futures: [n=2] TRUE, FALSE
[09:29:46.931]  - until=2
[09:29:46.931]  - relaying element #2
[09:29:46.931] result() for MulticoreFuture ...
[09:29:46.931] result() for MulticoreFuture ... done
[09:29:46.931] result() for MulticoreFuture ...
[09:29:46.931] result() for MulticoreFuture ... done
[09:29:46.932] result() for MulticoreFuture ...
[09:29:46.932] result() for MulticoreFuture ... done
[09:29:46.932] result() for MulticoreFuture ...
[09:29:46.932] result() for MulticoreFuture ... done
[09:29:46.932] - relayed: [n=2] TRUE, TRUE
[09:29:46.932] - queued futures: [n=2] TRUE, TRUE
[09:29:46.932] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:46.932]  length: 0 (resolved future 2)
[09:29:46.933] Relaying remaining futures
[09:29:46.933] signalConditionsASAP(NULL, pos=0) ...
[09:29:46.933] - nx: 2
[09:29:46.933] - relay: TRUE
[09:29:46.933] - stdout: TRUE
[09:29:46.933] - signal: TRUE
[09:29:46.933] - resignal: FALSE
[09:29:46.933] - force: TRUE
[09:29:46.933] - relayed: [n=2] TRUE, TRUE
[09:29:46.933] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:46.934] - relayed: [n=2] TRUE, TRUE
[09:29:46.934] - queued futures: [n=2] TRUE, TRUE
[09:29:46.934] signalConditionsASAP(NULL, pos=0) ... done
[09:29:46.934] resolve() on list ... DONE
[09:29:46.934] result() for MulticoreFuture ...
[09:29:46.934] result() for MulticoreFuture ... done
[09:29:46.934] result() for MulticoreFuture ...
[09:29:46.934] result() for MulticoreFuture ... done
[09:29:46.934] result() for MulticoreFuture ...
[09:29:46.935] result() for MulticoreFuture ... done
[09:29:46.935] result() for MulticoreFuture ...
[09:29:46.935] result() for MulticoreFuture ... done
[09:29:46.935]  - Number of value chunks collected: 2
[09:29:46.935] Resolving 2 futures (chunks) ... DONE
[09:29:46.935] Reducing values from 2 chunks ...
[09:29:46.935]  - Number of values collected after concatenation: 10
[09:29:46.935]  - Number of values expected: 10
[09:29:46.935] Reducing values from 2 chunks ... DONE
[09:29:46.935] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[09:29:46.937] future_lapply() ...
[09:29:46.943] Number of chunks: 2
[09:29:46.943] getGlobalsAndPackagesXApply() ...
[09:29:46.943]  - future.globals: TRUE
[09:29:46.943] getGlobalsAndPackages() ...
[09:29:46.943] Searching for globals...
[09:29:46.950] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[09:29:46.950] Searching for globals ... DONE
[09:29:46.950] Resolving globals: FALSE
[09:29:46.951] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[09:29:46.951] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:46.951] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.952] - packages: [1] ‘future.apply’
[09:29:46.952] getGlobalsAndPackages() ... DONE
[09:29:46.952]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:46.952]  - needed namespaces: [n=1] ‘future.apply’
[09:29:46.952] Finding globals ... DONE
[09:29:46.952]  - use_args: TRUE
[09:29:46.952]  - Getting '...' globals ...
[09:29:46.953] resolve() on list ...
[09:29:46.953]  recursive: 0
[09:29:46.953]  length: 1
[09:29:46.953]  elements: ‘...’
[09:29:46.953]  length: 0 (resolved future 1)
[09:29:46.953] resolve() on list ... DONE
[09:29:46.953]    - '...' content: [n=0] 
[09:29:46.953] List of 1
[09:29:46.953]  $ ...: list()
[09:29:46.953]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.953]  - attr(*, "where")=List of 1
[09:29:46.953]   ..$ ...:<environment: 0x561d365b7c98> 
[09:29:46.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.953]  - attr(*, "resolved")= logi TRUE
[09:29:46.953]  - attr(*, "total_size")= num NA
[09:29:46.956]  - Getting '...' globals ... DONE
[09:29:46.956] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:46.956] List of 8
[09:29:46.956]  $ ...future.FUN:function (x, ...)  
[09:29:46.956]  $ x_FUN        :function (x)  
[09:29:46.956]  $ times        : int 4
[09:29:46.956]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.956]  $ stop_if_not  :function (...)  
[09:29:46.956]  $ dim          : int [1:2] 2 2
[09:29:46.956]  $ valid_types  : chr [1:2] "logical" "integer"
[09:29:46.956]  $ ...          : list()
[09:29:46.956]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.956]  - attr(*, "where")=List of 8
[09:29:46.956]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:46.956]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:46.956]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:46.956]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:46.956]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:46.956]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:46.956]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:46.956]   ..$ ...          :<environment: 0x561d365b7c98> 
[09:29:46.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.956]  - attr(*, "resolved")= logi FALSE
[09:29:46.956]  - attr(*, "total_size")= num 97232
[09:29:46.961] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:46.961] getGlobalsAndPackagesXApply() ... DONE
[09:29:46.961] Number of futures (= number of chunks): 2
[09:29:46.962] Launching 2 futures (chunks) ...
[09:29:46.962] Chunk #1 of 2 ...
[09:29:46.962]  - Finding globals in 'X' for chunk #1 ...
[09:29:46.962] getGlobalsAndPackages() ...
[09:29:46.962] Searching for globals...
[09:29:46.962] 
[09:29:46.962] Searching for globals ... DONE
[09:29:46.962] - globals: [0] <none>
[09:29:46.962] getGlobalsAndPackages() ... DONE
[09:29:46.963]    + additional globals found: [n=0] 
[09:29:46.963]    + additional namespaces needed: [n=0] 
[09:29:46.963]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:46.963]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.963]  - seeds: <none>
[09:29:46.963]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.963] getGlobalsAndPackages() ...
[09:29:46.963] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.963] Resolving globals: FALSE
[09:29:46.963] Tweak future expression to call with '...' arguments ...
[09:29:46.964] {
[09:29:46.964]     do.call(function(...) {
[09:29:46.964]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.964]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.964]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.964]             on.exit(options(oopts), add = TRUE)
[09:29:46.964]         }
[09:29:46.964]         {
[09:29:46.964]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.964]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.964]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.964]             })
[09:29:46.964]         }
[09:29:46.964]     }, args = future.call.arguments)
[09:29:46.964] }
[09:29:46.964] Tweak future expression to call with '...' arguments ... DONE
[09:29:46.964] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:46.964] - packages: [1] ‘future.apply’
[09:29:46.965] getGlobalsAndPackages() ... DONE
[09:29:46.965] run() for ‘Future’ ...
[09:29:46.965] - state: ‘created’
[09:29:46.965] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:46.970] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.970] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:46.970]   - Field: ‘label’
[09:29:46.970]   - Field: ‘local’
[09:29:46.970]   - Field: ‘owner’
[09:29:46.970]   - Field: ‘envir’
[09:29:46.970]   - Field: ‘workers’
[09:29:46.970]   - Field: ‘packages’
[09:29:46.971]   - Field: ‘gc’
[09:29:46.971]   - Field: ‘job’
[09:29:46.971]   - Field: ‘conditions’
[09:29:46.971]   - Field: ‘expr’
[09:29:46.971]   - Field: ‘uuid’
[09:29:46.971]   - Field: ‘seed’
[09:29:46.971]   - Field: ‘version’
[09:29:46.971]   - Field: ‘result’
[09:29:46.971]   - Field: ‘asynchronous’
[09:29:46.971]   - Field: ‘calls’
[09:29:46.972]   - Field: ‘globals’
[09:29:46.972]   - Field: ‘stdout’
[09:29:46.972]   - Field: ‘earlySignal’
[09:29:46.972]   - Field: ‘lazy’
[09:29:46.972]   - Field: ‘state’
[09:29:46.972] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:46.972] - Launch lazy future ...
[09:29:46.972] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:46.972] Packages needed by future strategies (n = 0): <none>
[09:29:46.973] {
[09:29:46.973]     {
[09:29:46.973]         {
[09:29:46.973]             ...future.startTime <- base::Sys.time()
[09:29:46.973]             {
[09:29:46.973]                 {
[09:29:46.973]                   {
[09:29:46.973]                     {
[09:29:46.973]                       {
[09:29:46.973]                         base::local({
[09:29:46.973]                           has_future <- base::requireNamespace("future", 
[09:29:46.973]                             quietly = TRUE)
[09:29:46.973]                           if (has_future) {
[09:29:46.973]                             ns <- base::getNamespace("future")
[09:29:46.973]                             version <- ns[[".package"]][["version"]]
[09:29:46.973]                             if (is.null(version)) 
[09:29:46.973]                               version <- utils::packageVersion("future")
[09:29:46.973]                           }
[09:29:46.973]                           else {
[09:29:46.973]                             version <- NULL
[09:29:46.973]                           }
[09:29:46.973]                           if (!has_future || version < "1.8.0") {
[09:29:46.973]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:46.973]                               "", base::R.version$version.string), 
[09:29:46.973]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:46.973]                                 base::R.version$platform, 8 * 
[09:29:46.973]                                   base::.Machine$sizeof.pointer), 
[09:29:46.973]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:46.973]                                 "release", "version")], collapse = " "), 
[09:29:46.973]                               hostname = base::Sys.info()[["nodename"]])
[09:29:46.973]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:46.973]                               info)
[09:29:46.973]                             info <- base::paste(info, collapse = "; ")
[09:29:46.973]                             if (!has_future) {
[09:29:46.973]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:46.973]                                 info)
[09:29:46.973]                             }
[09:29:46.973]                             else {
[09:29:46.973]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:46.973]                                 info, version)
[09:29:46.973]                             }
[09:29:46.973]                             base::stop(msg)
[09:29:46.973]                           }
[09:29:46.973]                         })
[09:29:46.973]                       }
[09:29:46.973]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:46.973]                       base::options(mc.cores = 1L)
[09:29:46.973]                     }
[09:29:46.973]                     base::local({
[09:29:46.973]                       for (pkg in "future.apply") {
[09:29:46.973]                         base::loadNamespace(pkg)
[09:29:46.973]                         base::library(pkg, character.only = TRUE)
[09:29:46.973]                       }
[09:29:46.973]                     })
[09:29:46.973]                   }
[09:29:46.973]                   ...future.strategy.old <- future::plan("list")
[09:29:46.973]                   options(future.plan = NULL)
[09:29:46.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:46.973]                 }
[09:29:46.973]                 ...future.workdir <- getwd()
[09:29:46.973]             }
[09:29:46.973]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:46.973]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:46.973]         }
[09:29:46.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:46.973]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:46.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:46.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:46.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:46.973]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:46.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:46.973]             base::names(...future.oldOptions))
[09:29:46.973]     }
[09:29:46.973]     if (FALSE) {
[09:29:46.973]     }
[09:29:46.973]     else {
[09:29:46.973]         if (TRUE) {
[09:29:46.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:46.973]                 open = "w")
[09:29:46.973]         }
[09:29:46.973]         else {
[09:29:46.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:46.973]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:46.973]         }
[09:29:46.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:46.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:46.973]             base::sink(type = "output", split = FALSE)
[09:29:46.973]             base::close(...future.stdout)
[09:29:46.973]         }, add = TRUE)
[09:29:46.973]     }
[09:29:46.973]     ...future.frame <- base::sys.nframe()
[09:29:46.973]     ...future.conditions <- base::list()
[09:29:46.973]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:46.973]     if (FALSE) {
[09:29:46.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:46.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:46.973]     }
[09:29:46.973]     ...future.result <- base::tryCatch({
[09:29:46.973]         base::withCallingHandlers({
[09:29:46.973]             ...future.value <- base::withVisible(base::local({
[09:29:46.973]                 withCallingHandlers({
[09:29:46.973]                   {
[09:29:46.973]                     do.call(function(...) {
[09:29:46.973]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.973]                       if (!identical(...future.globals.maxSize.org, 
[09:29:46.973]                         ...future.globals.maxSize)) {
[09:29:46.973]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.973]                         on.exit(options(oopts), add = TRUE)
[09:29:46.973]                       }
[09:29:46.973]                       {
[09:29:46.973]                         lapply(seq_along(...future.elements_ii), 
[09:29:46.973]                           FUN = function(jj) {
[09:29:46.973]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.973]                             ...future.FUN(...future.X_jj, ...)
[09:29:46.973]                           })
[09:29:46.973]                       }
[09:29:46.973]                     }, args = future.call.arguments)
[09:29:46.973]                   }
[09:29:46.973]                 }, immediateCondition = function(cond) {
[09:29:46.973]                   save_rds <- function (object, pathname, ...) 
[09:29:46.973]                   {
[09:29:46.973]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:46.973]                     if (file_test("-f", pathname_tmp)) {
[09:29:46.973]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.973]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:46.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.973]                         fi_tmp[["mtime"]])
[09:29:46.973]                     }
[09:29:46.973]                     tryCatch({
[09:29:46.973]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:46.973]                     }, error = function(ex) {
[09:29:46.973]                       msg <- conditionMessage(ex)
[09:29:46.973]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.973]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:46.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.973]                         fi_tmp[["mtime"]], msg)
[09:29:46.973]                       ex$message <- msg
[09:29:46.973]                       stop(ex)
[09:29:46.973]                     })
[09:29:46.973]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:46.973]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:46.973]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:46.973]                       fi_tmp <- file.info(pathname_tmp)
[09:29:46.973]                       fi <- file.info(pathname)
[09:29:46.973]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:46.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:46.973]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:46.973]                         fi[["size"]], fi[["mtime"]])
[09:29:46.973]                       stop(msg)
[09:29:46.973]                     }
[09:29:46.973]                     invisible(pathname)
[09:29:46.973]                   }
[09:29:46.973]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:46.973]                     rootPath = tempdir()) 
[09:29:46.973]                   {
[09:29:46.973]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:46.973]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:46.973]                       tmpdir = path, fileext = ".rds")
[09:29:46.973]                     save_rds(obj, file)
[09:29:46.973]                   }
[09:29:46.973]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:46.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.973]                   {
[09:29:46.973]                     inherits <- base::inherits
[09:29:46.973]                     invokeRestart <- base::invokeRestart
[09:29:46.973]                     is.null <- base::is.null
[09:29:46.973]                     muffled <- FALSE
[09:29:46.973]                     if (inherits(cond, "message")) {
[09:29:46.973]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:46.973]                       if (muffled) 
[09:29:46.973]                         invokeRestart("muffleMessage")
[09:29:46.973]                     }
[09:29:46.973]                     else if (inherits(cond, "warning")) {
[09:29:46.973]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:46.973]                       if (muffled) 
[09:29:46.973]                         invokeRestart("muffleWarning")
[09:29:46.973]                     }
[09:29:46.973]                     else if (inherits(cond, "condition")) {
[09:29:46.973]                       if (!is.null(pattern)) {
[09:29:46.973]                         computeRestarts <- base::computeRestarts
[09:29:46.973]                         grepl <- base::grepl
[09:29:46.973]                         restarts <- computeRestarts(cond)
[09:29:46.973]                         for (restart in restarts) {
[09:29:46.973]                           name <- restart$name
[09:29:46.973]                           if (is.null(name)) 
[09:29:46.973]                             next
[09:29:46.973]                           if (!grepl(pattern, name)) 
[09:29:46.973]                             next
[09:29:46.973]                           invokeRestart(restart)
[09:29:46.973]                           muffled <- TRUE
[09:29:46.973]                           break
[09:29:46.973]                         }
[09:29:46.973]                       }
[09:29:46.973]                     }
[09:29:46.973]                     invisible(muffled)
[09:29:46.973]                   }
[09:29:46.973]                   muffleCondition(cond)
[09:29:46.973]                 })
[09:29:46.973]             }))
[09:29:46.973]             future::FutureResult(value = ...future.value$value, 
[09:29:46.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.973]                   ...future.rng), globalenv = if (FALSE) 
[09:29:46.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:46.973]                     ...future.globalenv.names))
[09:29:46.973]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:46.973]         }, condition = base::local({
[09:29:46.973]             c <- base::c
[09:29:46.973]             inherits <- base::inherits
[09:29:46.973]             invokeRestart <- base::invokeRestart
[09:29:46.973]             length <- base::length
[09:29:46.973]             list <- base::list
[09:29:46.973]             seq.int <- base::seq.int
[09:29:46.973]             signalCondition <- base::signalCondition
[09:29:46.973]             sys.calls <- base::sys.calls
[09:29:46.973]             `[[` <- base::`[[`
[09:29:46.973]             `+` <- base::`+`
[09:29:46.973]             `<<-` <- base::`<<-`
[09:29:46.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:46.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:46.973]                   3L)]
[09:29:46.973]             }
[09:29:46.973]             function(cond) {
[09:29:46.973]                 is_error <- inherits(cond, "error")
[09:29:46.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:46.973]                   NULL)
[09:29:46.973]                 if (is_error) {
[09:29:46.973]                   sessionInformation <- function() {
[09:29:46.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:46.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:46.973]                       search = base::search(), system = base::Sys.info())
[09:29:46.973]                   }
[09:29:46.973]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:46.973]                     cond$call), session = sessionInformation(), 
[09:29:46.973]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:46.973]                   signalCondition(cond)
[09:29:46.973]                 }
[09:29:46.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:46.973]                 "immediateCondition"))) {
[09:29:46.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:46.973]                   ...future.conditions[[length(...future.conditions) + 
[09:29:46.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:46.973]                   if (TRUE && !signal) {
[09:29:46.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.973]                     {
[09:29:46.973]                       inherits <- base::inherits
[09:29:46.973]                       invokeRestart <- base::invokeRestart
[09:29:46.973]                       is.null <- base::is.null
[09:29:46.973]                       muffled <- FALSE
[09:29:46.973]                       if (inherits(cond, "message")) {
[09:29:46.973]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.973]                         if (muffled) 
[09:29:46.973]                           invokeRestart("muffleMessage")
[09:29:46.973]                       }
[09:29:46.973]                       else if (inherits(cond, "warning")) {
[09:29:46.973]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.973]                         if (muffled) 
[09:29:46.973]                           invokeRestart("muffleWarning")
[09:29:46.973]                       }
[09:29:46.973]                       else if (inherits(cond, "condition")) {
[09:29:46.973]                         if (!is.null(pattern)) {
[09:29:46.973]                           computeRestarts <- base::computeRestarts
[09:29:46.973]                           grepl <- base::grepl
[09:29:46.973]                           restarts <- computeRestarts(cond)
[09:29:46.973]                           for (restart in restarts) {
[09:29:46.973]                             name <- restart$name
[09:29:46.973]                             if (is.null(name)) 
[09:29:46.973]                               next
[09:29:46.973]                             if (!grepl(pattern, name)) 
[09:29:46.973]                               next
[09:29:46.973]                             invokeRestart(restart)
[09:29:46.973]                             muffled <- TRUE
[09:29:46.973]                             break
[09:29:46.973]                           }
[09:29:46.973]                         }
[09:29:46.973]                       }
[09:29:46.973]                       invisible(muffled)
[09:29:46.973]                     }
[09:29:46.973]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.973]                   }
[09:29:46.973]                 }
[09:29:46.973]                 else {
[09:29:46.973]                   if (TRUE) {
[09:29:46.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:46.973]                     {
[09:29:46.973]                       inherits <- base::inherits
[09:29:46.973]                       invokeRestart <- base::invokeRestart
[09:29:46.973]                       is.null <- base::is.null
[09:29:46.973]                       muffled <- FALSE
[09:29:46.973]                       if (inherits(cond, "message")) {
[09:29:46.973]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:46.973]                         if (muffled) 
[09:29:46.973]                           invokeRestart("muffleMessage")
[09:29:46.973]                       }
[09:29:46.973]                       else if (inherits(cond, "warning")) {
[09:29:46.973]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:46.973]                         if (muffled) 
[09:29:46.973]                           invokeRestart("muffleWarning")
[09:29:46.973]                       }
[09:29:46.973]                       else if (inherits(cond, "condition")) {
[09:29:46.973]                         if (!is.null(pattern)) {
[09:29:46.973]                           computeRestarts <- base::computeRestarts
[09:29:46.973]                           grepl <- base::grepl
[09:29:46.973]                           restarts <- computeRestarts(cond)
[09:29:46.973]                           for (restart in restarts) {
[09:29:46.973]                             name <- restart$name
[09:29:46.973]                             if (is.null(name)) 
[09:29:46.973]                               next
[09:29:46.973]                             if (!grepl(pattern, name)) 
[09:29:46.973]                               next
[09:29:46.973]                             invokeRestart(restart)
[09:29:46.973]                             muffled <- TRUE
[09:29:46.973]                             break
[09:29:46.973]                           }
[09:29:46.973]                         }
[09:29:46.973]                       }
[09:29:46.973]                       invisible(muffled)
[09:29:46.973]                     }
[09:29:46.973]                     muffleCondition(cond, pattern = "^muffle")
[09:29:46.973]                   }
[09:29:46.973]                 }
[09:29:46.973]             }
[09:29:46.973]         }))
[09:29:46.973]     }, error = function(ex) {
[09:29:46.973]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:46.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:46.973]                 ...future.rng), started = ...future.startTime, 
[09:29:46.973]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:46.973]             version = "1.8"), class = "FutureResult")
[09:29:46.973]     }, finally = {
[09:29:46.973]         if (!identical(...future.workdir, getwd())) 
[09:29:46.973]             setwd(...future.workdir)
[09:29:46.973]         {
[09:29:46.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:46.973]                 ...future.oldOptions$nwarnings <- NULL
[09:29:46.973]             }
[09:29:46.973]             base::options(...future.oldOptions)
[09:29:46.973]             if (.Platform$OS.type == "windows") {
[09:29:46.973]                 old_names <- names(...future.oldEnvVars)
[09:29:46.973]                 envs <- base::Sys.getenv()
[09:29:46.973]                 names <- names(envs)
[09:29:46.973]                 common <- intersect(names, old_names)
[09:29:46.973]                 added <- setdiff(names, old_names)
[09:29:46.973]                 removed <- setdiff(old_names, names)
[09:29:46.973]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:46.973]                   envs[common]]
[09:29:46.973]                 NAMES <- toupper(changed)
[09:29:46.973]                 args <- list()
[09:29:46.973]                 for (kk in seq_along(NAMES)) {
[09:29:46.973]                   name <- changed[[kk]]
[09:29:46.973]                   NAME <- NAMES[[kk]]
[09:29:46.973]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.973]                     next
[09:29:46.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.973]                 }
[09:29:46.973]                 NAMES <- toupper(added)
[09:29:46.973]                 for (kk in seq_along(NAMES)) {
[09:29:46.973]                   name <- added[[kk]]
[09:29:46.973]                   NAME <- NAMES[[kk]]
[09:29:46.973]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.973]                     next
[09:29:46.973]                   args[[name]] <- ""
[09:29:46.973]                 }
[09:29:46.973]                 NAMES <- toupper(removed)
[09:29:46.973]                 for (kk in seq_along(NAMES)) {
[09:29:46.973]                   name <- removed[[kk]]
[09:29:46.973]                   NAME <- NAMES[[kk]]
[09:29:46.973]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:46.973]                     next
[09:29:46.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:46.973]                 }
[09:29:46.973]                 if (length(args) > 0) 
[09:29:46.973]                   base::do.call(base::Sys.setenv, args = args)
[09:29:46.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:46.973]             }
[09:29:46.973]             else {
[09:29:46.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:46.973]             }
[09:29:46.973]             {
[09:29:46.973]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:46.973]                   0L) {
[09:29:46.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:46.973]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:46.973]                   base::options(opts)
[09:29:46.973]                 }
[09:29:46.973]                 {
[09:29:46.973]                   {
[09:29:46.973]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:46.973]                     NULL
[09:29:46.973]                   }
[09:29:46.973]                   options(future.plan = NULL)
[09:29:46.973]                   if (is.na(NA_character_)) 
[09:29:46.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:46.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:46.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:46.973]                     .init = FALSE)
[09:29:46.973]                 }
[09:29:46.973]             }
[09:29:46.973]         }
[09:29:46.973]     })
[09:29:46.973]     if (TRUE) {
[09:29:46.973]         base::sink(type = "output", split = FALSE)
[09:29:46.973]         if (TRUE) {
[09:29:46.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:46.973]         }
[09:29:46.973]         else {
[09:29:46.973]             ...future.result["stdout"] <- base::list(NULL)
[09:29:46.973]         }
[09:29:46.973]         base::close(...future.stdout)
[09:29:46.973]         ...future.stdout <- NULL
[09:29:46.973]     }
[09:29:46.973]     ...future.result$conditions <- ...future.conditions
[09:29:46.973]     ...future.result$finished <- base::Sys.time()
[09:29:46.973]     ...future.result
[09:29:46.973] }
[09:29:46.975] assign_globals() ...
[09:29:46.976] List of 11
[09:29:46.976]  $ ...future.FUN            :function (x, ...)  
[09:29:46.976]  $ x_FUN                    :function (x)  
[09:29:46.976]  $ times                    : int 4
[09:29:46.976]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:46.976]  $ stop_if_not              :function (...)  
[09:29:46.976]  $ dim                      : int [1:2] 2 2
[09:29:46.976]  $ valid_types              : chr [1:2] "logical" "integer"
[09:29:46.976]  $ future.call.arguments    : list()
[09:29:46.976]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:46.976]  $ ...future.elements_ii    :List of 5
[09:29:46.976]   ..$ : int 1
[09:29:46.976]   ..$ : int 2
[09:29:46.976]   ..$ : int 3
[09:29:46.976]   ..$ : int 4
[09:29:46.976]   ..$ : int 5
[09:29:46.976]  $ ...future.seeds_ii       : NULL
[09:29:46.976]  $ ...future.globals.maxSize: NULL
[09:29:46.976]  - attr(*, "where")=List of 11
[09:29:46.976]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:46.976]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:46.976]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:46.976]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:46.976]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:46.976]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:46.976]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:46.976]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:46.976]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:46.976]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:46.976]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:46.976]  - attr(*, "resolved")= logi FALSE
[09:29:46.976]  - attr(*, "total_size")= num 97232
[09:29:46.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:46.976]  - attr(*, "already-done")= logi TRUE
[09:29:46.984] - copied ‘...future.FUN’ to environment
[09:29:46.984] - reassign environment for ‘x_FUN’
[09:29:46.984] - copied ‘x_FUN’ to environment
[09:29:46.984] - copied ‘times’ to environment
[09:29:46.984] - copied ‘stopf’ to environment
[09:29:46.984] - copied ‘stop_if_not’ to environment
[09:29:46.984] - copied ‘dim’ to environment
[09:29:46.984] - copied ‘valid_types’ to environment
[09:29:46.984] - copied ‘future.call.arguments’ to environment
[09:29:46.984] - copied ‘...future.elements_ii’ to environment
[09:29:46.985] - copied ‘...future.seeds_ii’ to environment
[09:29:46.985] - copied ‘...future.globals.maxSize’ to environment
[09:29:46.985] assign_globals() ... done
[09:29:46.985] requestCore(): workers = 2
[09:29:46.987] MulticoreFuture started
[09:29:46.987] - Launch lazy future ... done
[09:29:46.987] run() for ‘MulticoreFuture’ ... done
[09:29:46.988] Created future:
[09:29:46.988] plan(): Setting new future strategy stack:
[09:29:46.989] List of future strategies:
[09:29:46.989] 1. sequential:
[09:29:46.989]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:46.989]    - tweaked: FALSE
[09:29:46.989]    - call: NULL
[09:29:46.989] plan(): nbrOfWorkers() = 1
[09:29:46.991] plan(): Setting new future strategy stack:
[09:29:46.992] List of future strategies:
[09:29:46.992] 1. multicore:
[09:29:46.992]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:46.992]    - tweaked: FALSE
[09:29:46.992]    - call: plan(strategy)
[09:29:46.996] plan(): nbrOfWorkers() = 2
[09:29:46.988] MulticoreFuture:
[09:29:46.988] Label: ‘future_vapply-1’
[09:29:46.988] Expression:
[09:29:46.988] {
[09:29:46.988]     do.call(function(...) {
[09:29:46.988]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:46.988]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:46.988]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:46.988]             on.exit(options(oopts), add = TRUE)
[09:29:46.988]         }
[09:29:46.988]         {
[09:29:46.988]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:46.988]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:46.988]                 ...future.FUN(...future.X_jj, ...)
[09:29:46.988]             })
[09:29:46.988]         }
[09:29:46.988]     }, args = future.call.arguments)
[09:29:46.988] }
[09:29:46.988] Lazy evaluation: FALSE
[09:29:46.988] Asynchronous evaluation: TRUE
[09:29:46.988] Local evaluation: TRUE
[09:29:46.988] Environment: R_GlobalEnv
[09:29:46.988] Capture standard output: TRUE
[09:29:46.988] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:46.988] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:46.988] Packages: 1 packages (‘future.apply’)
[09:29:46.988] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:46.988] Resolved: TRUE
[09:29:46.988] Value: <not collected>
[09:29:46.988] Conditions captured: <none>
[09:29:46.988] Early signaling: FALSE
[09:29:46.988] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:46.988] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:46.997] Chunk #1 of 2 ... DONE
[09:29:46.997] Chunk #2 of 2 ...
[09:29:46.998]  - Finding globals in 'X' for chunk #2 ...
[09:29:46.998] getGlobalsAndPackages() ...
[09:29:46.998] Searching for globals...
[09:29:46.998] 
[09:29:46.998] Searching for globals ... DONE
[09:29:46.998] - globals: [0] <none>
[09:29:46.999] getGlobalsAndPackages() ... DONE
[09:29:46.999]    + additional globals found: [n=0] 
[09:29:46.999]    + additional namespaces needed: [n=0] 
[09:29:46.999]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:46.999]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:46.999]  - seeds: <none>
[09:29:46.999]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.000] getGlobalsAndPackages() ...
[09:29:47.000] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.000] Resolving globals: FALSE
[09:29:47.000] Tweak future expression to call with '...' arguments ...
[09:29:47.000] {
[09:29:47.000]     do.call(function(...) {
[09:29:47.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.000]             on.exit(options(oopts), add = TRUE)
[09:29:47.000]         }
[09:29:47.000]         {
[09:29:47.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.000]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.000]             })
[09:29:47.000]         }
[09:29:47.000]     }, args = future.call.arguments)
[09:29:47.000] }
[09:29:47.001] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.006] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.006] - packages: [1] ‘future.apply’
[09:29:47.007] getGlobalsAndPackages() ... DONE
[09:29:47.007] run() for ‘Future’ ...
[09:29:47.008] - state: ‘created’
[09:29:47.008] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.014] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.014] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.015]   - Field: ‘label’
[09:29:47.015]   - Field: ‘local’
[09:29:47.015]   - Field: ‘owner’
[09:29:47.015]   - Field: ‘envir’
[09:29:47.015]   - Field: ‘workers’
[09:29:47.016]   - Field: ‘packages’
[09:29:47.016]   - Field: ‘gc’
[09:29:47.016]   - Field: ‘job’
[09:29:47.016]   - Field: ‘conditions’
[09:29:47.016]   - Field: ‘expr’
[09:29:47.016]   - Field: ‘uuid’
[09:29:47.016]   - Field: ‘seed’
[09:29:47.017]   - Field: ‘version’
[09:29:47.017]   - Field: ‘result’
[09:29:47.017]   - Field: ‘asynchronous’
[09:29:47.017]   - Field: ‘calls’
[09:29:47.017]   - Field: ‘globals’
[09:29:47.017]   - Field: ‘stdout’
[09:29:47.017]   - Field: ‘earlySignal’
[09:29:47.018]   - Field: ‘lazy’
[09:29:47.018]   - Field: ‘state’
[09:29:47.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.018] - Launch lazy future ...
[09:29:47.019] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:47.019] Packages needed by future strategies (n = 0): <none>
[09:29:47.019] {
[09:29:47.019]     {
[09:29:47.019]         {
[09:29:47.019]             ...future.startTime <- base::Sys.time()
[09:29:47.019]             {
[09:29:47.019]                 {
[09:29:47.019]                   {
[09:29:47.019]                     {
[09:29:47.019]                       {
[09:29:47.019]                         base::local({
[09:29:47.019]                           has_future <- base::requireNamespace("future", 
[09:29:47.019]                             quietly = TRUE)
[09:29:47.019]                           if (has_future) {
[09:29:47.019]                             ns <- base::getNamespace("future")
[09:29:47.019]                             version <- ns[[".package"]][["version"]]
[09:29:47.019]                             if (is.null(version)) 
[09:29:47.019]                               version <- utils::packageVersion("future")
[09:29:47.019]                           }
[09:29:47.019]                           else {
[09:29:47.019]                             version <- NULL
[09:29:47.019]                           }
[09:29:47.019]                           if (!has_future || version < "1.8.0") {
[09:29:47.019]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.019]                               "", base::R.version$version.string), 
[09:29:47.019]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.019]                                 base::R.version$platform, 8 * 
[09:29:47.019]                                   base::.Machine$sizeof.pointer), 
[09:29:47.019]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.019]                                 "release", "version")], collapse = " "), 
[09:29:47.019]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.019]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.019]                               info)
[09:29:47.019]                             info <- base::paste(info, collapse = "; ")
[09:29:47.019]                             if (!has_future) {
[09:29:47.019]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.019]                                 info)
[09:29:47.019]                             }
[09:29:47.019]                             else {
[09:29:47.019]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.019]                                 info, version)
[09:29:47.019]                             }
[09:29:47.019]                             base::stop(msg)
[09:29:47.019]                           }
[09:29:47.019]                         })
[09:29:47.019]                       }
[09:29:47.019]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.019]                       base::options(mc.cores = 1L)
[09:29:47.019]                     }
[09:29:47.019]                     base::local({
[09:29:47.019]                       for (pkg in "future.apply") {
[09:29:47.019]                         base::loadNamespace(pkg)
[09:29:47.019]                         base::library(pkg, character.only = TRUE)
[09:29:47.019]                       }
[09:29:47.019]                     })
[09:29:47.019]                   }
[09:29:47.019]                   ...future.strategy.old <- future::plan("list")
[09:29:47.019]                   options(future.plan = NULL)
[09:29:47.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.019]                 }
[09:29:47.019]                 ...future.workdir <- getwd()
[09:29:47.019]             }
[09:29:47.019]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.019]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.019]         }
[09:29:47.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.019]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.019]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.019]             base::names(...future.oldOptions))
[09:29:47.019]     }
[09:29:47.019]     if (FALSE) {
[09:29:47.019]     }
[09:29:47.019]     else {
[09:29:47.019]         if (TRUE) {
[09:29:47.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.019]                 open = "w")
[09:29:47.019]         }
[09:29:47.019]         else {
[09:29:47.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.019]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.019]         }
[09:29:47.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.019]             base::sink(type = "output", split = FALSE)
[09:29:47.019]             base::close(...future.stdout)
[09:29:47.019]         }, add = TRUE)
[09:29:47.019]     }
[09:29:47.019]     ...future.frame <- base::sys.nframe()
[09:29:47.019]     ...future.conditions <- base::list()
[09:29:47.019]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.019]     if (FALSE) {
[09:29:47.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.019]     }
[09:29:47.019]     ...future.result <- base::tryCatch({
[09:29:47.019]         base::withCallingHandlers({
[09:29:47.019]             ...future.value <- base::withVisible(base::local({
[09:29:47.019]                 withCallingHandlers({
[09:29:47.019]                   {
[09:29:47.019]                     do.call(function(...) {
[09:29:47.019]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.019]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.019]                         ...future.globals.maxSize)) {
[09:29:47.019]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.019]                         on.exit(options(oopts), add = TRUE)
[09:29:47.019]                       }
[09:29:47.019]                       {
[09:29:47.019]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.019]                           FUN = function(jj) {
[09:29:47.019]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.019]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.019]                           })
[09:29:47.019]                       }
[09:29:47.019]                     }, args = future.call.arguments)
[09:29:47.019]                   }
[09:29:47.019]                 }, immediateCondition = function(cond) {
[09:29:47.019]                   save_rds <- function (object, pathname, ...) 
[09:29:47.019]                   {
[09:29:47.019]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.019]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.019]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.019]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.019]                         fi_tmp[["mtime"]])
[09:29:47.019]                     }
[09:29:47.019]                     tryCatch({
[09:29:47.019]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.019]                     }, error = function(ex) {
[09:29:47.019]                       msg <- conditionMessage(ex)
[09:29:47.019]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.019]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.019]                         fi_tmp[["mtime"]], msg)
[09:29:47.019]                       ex$message <- msg
[09:29:47.019]                       stop(ex)
[09:29:47.019]                     })
[09:29:47.019]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.019]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.019]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.019]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.019]                       fi <- file.info(pathname)
[09:29:47.019]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.019]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.019]                         fi[["size"]], fi[["mtime"]])
[09:29:47.019]                       stop(msg)
[09:29:47.019]                     }
[09:29:47.019]                     invisible(pathname)
[09:29:47.019]                   }
[09:29:47.019]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.019]                     rootPath = tempdir()) 
[09:29:47.019]                   {
[09:29:47.019]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.019]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.019]                       tmpdir = path, fileext = ".rds")
[09:29:47.019]                     save_rds(obj, file)
[09:29:47.019]                   }
[09:29:47.019]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.019]                   {
[09:29:47.019]                     inherits <- base::inherits
[09:29:47.019]                     invokeRestart <- base::invokeRestart
[09:29:47.019]                     is.null <- base::is.null
[09:29:47.019]                     muffled <- FALSE
[09:29:47.019]                     if (inherits(cond, "message")) {
[09:29:47.019]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.019]                       if (muffled) 
[09:29:47.019]                         invokeRestart("muffleMessage")
[09:29:47.019]                     }
[09:29:47.019]                     else if (inherits(cond, "warning")) {
[09:29:47.019]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.019]                       if (muffled) 
[09:29:47.019]                         invokeRestart("muffleWarning")
[09:29:47.019]                     }
[09:29:47.019]                     else if (inherits(cond, "condition")) {
[09:29:47.019]                       if (!is.null(pattern)) {
[09:29:47.019]                         computeRestarts <- base::computeRestarts
[09:29:47.019]                         grepl <- base::grepl
[09:29:47.019]                         restarts <- computeRestarts(cond)
[09:29:47.019]                         for (restart in restarts) {
[09:29:47.019]                           name <- restart$name
[09:29:47.019]                           if (is.null(name)) 
[09:29:47.019]                             next
[09:29:47.019]                           if (!grepl(pattern, name)) 
[09:29:47.019]                             next
[09:29:47.019]                           invokeRestart(restart)
[09:29:47.019]                           muffled <- TRUE
[09:29:47.019]                           break
[09:29:47.019]                         }
[09:29:47.019]                       }
[09:29:47.019]                     }
[09:29:47.019]                     invisible(muffled)
[09:29:47.019]                   }
[09:29:47.019]                   muffleCondition(cond)
[09:29:47.019]                 })
[09:29:47.019]             }))
[09:29:47.019]             future::FutureResult(value = ...future.value$value, 
[09:29:47.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.019]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.019]                     ...future.globalenv.names))
[09:29:47.019]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.019]         }, condition = base::local({
[09:29:47.019]             c <- base::c
[09:29:47.019]             inherits <- base::inherits
[09:29:47.019]             invokeRestart <- base::invokeRestart
[09:29:47.019]             length <- base::length
[09:29:47.019]             list <- base::list
[09:29:47.019]             seq.int <- base::seq.int
[09:29:47.019]             signalCondition <- base::signalCondition
[09:29:47.019]             sys.calls <- base::sys.calls
[09:29:47.019]             `[[` <- base::`[[`
[09:29:47.019]             `+` <- base::`+`
[09:29:47.019]             `<<-` <- base::`<<-`
[09:29:47.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.019]                   3L)]
[09:29:47.019]             }
[09:29:47.019]             function(cond) {
[09:29:47.019]                 is_error <- inherits(cond, "error")
[09:29:47.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.019]                   NULL)
[09:29:47.019]                 if (is_error) {
[09:29:47.019]                   sessionInformation <- function() {
[09:29:47.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.019]                       search = base::search(), system = base::Sys.info())
[09:29:47.019]                   }
[09:29:47.019]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.019]                     cond$call), session = sessionInformation(), 
[09:29:47.019]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.019]                   signalCondition(cond)
[09:29:47.019]                 }
[09:29:47.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.019]                 "immediateCondition"))) {
[09:29:47.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.019]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.019]                   if (TRUE && !signal) {
[09:29:47.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.019]                     {
[09:29:47.019]                       inherits <- base::inherits
[09:29:47.019]                       invokeRestart <- base::invokeRestart
[09:29:47.019]                       is.null <- base::is.null
[09:29:47.019]                       muffled <- FALSE
[09:29:47.019]                       if (inherits(cond, "message")) {
[09:29:47.019]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.019]                         if (muffled) 
[09:29:47.019]                           invokeRestart("muffleMessage")
[09:29:47.019]                       }
[09:29:47.019]                       else if (inherits(cond, "warning")) {
[09:29:47.019]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.019]                         if (muffled) 
[09:29:47.019]                           invokeRestart("muffleWarning")
[09:29:47.019]                       }
[09:29:47.019]                       else if (inherits(cond, "condition")) {
[09:29:47.019]                         if (!is.null(pattern)) {
[09:29:47.019]                           computeRestarts <- base::computeRestarts
[09:29:47.019]                           grepl <- base::grepl
[09:29:47.019]                           restarts <- computeRestarts(cond)
[09:29:47.019]                           for (restart in restarts) {
[09:29:47.019]                             name <- restart$name
[09:29:47.019]                             if (is.null(name)) 
[09:29:47.019]                               next
[09:29:47.019]                             if (!grepl(pattern, name)) 
[09:29:47.019]                               next
[09:29:47.019]                             invokeRestart(restart)
[09:29:47.019]                             muffled <- TRUE
[09:29:47.019]                             break
[09:29:47.019]                           }
[09:29:47.019]                         }
[09:29:47.019]                       }
[09:29:47.019]                       invisible(muffled)
[09:29:47.019]                     }
[09:29:47.019]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.019]                   }
[09:29:47.019]                 }
[09:29:47.019]                 else {
[09:29:47.019]                   if (TRUE) {
[09:29:47.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.019]                     {
[09:29:47.019]                       inherits <- base::inherits
[09:29:47.019]                       invokeRestart <- base::invokeRestart
[09:29:47.019]                       is.null <- base::is.null
[09:29:47.019]                       muffled <- FALSE
[09:29:47.019]                       if (inherits(cond, "message")) {
[09:29:47.019]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.019]                         if (muffled) 
[09:29:47.019]                           invokeRestart("muffleMessage")
[09:29:47.019]                       }
[09:29:47.019]                       else if (inherits(cond, "warning")) {
[09:29:47.019]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.019]                         if (muffled) 
[09:29:47.019]                           invokeRestart("muffleWarning")
[09:29:47.019]                       }
[09:29:47.019]                       else if (inherits(cond, "condition")) {
[09:29:47.019]                         if (!is.null(pattern)) {
[09:29:47.019]                           computeRestarts <- base::computeRestarts
[09:29:47.019]                           grepl <- base::grepl
[09:29:47.019]                           restarts <- computeRestarts(cond)
[09:29:47.019]                           for (restart in restarts) {
[09:29:47.019]                             name <- restart$name
[09:29:47.019]                             if (is.null(name)) 
[09:29:47.019]                               next
[09:29:47.019]                             if (!grepl(pattern, name)) 
[09:29:47.019]                               next
[09:29:47.019]                             invokeRestart(restart)
[09:29:47.019]                             muffled <- TRUE
[09:29:47.019]                             break
[09:29:47.019]                           }
[09:29:47.019]                         }
[09:29:47.019]                       }
[09:29:47.019]                       invisible(muffled)
[09:29:47.019]                     }
[09:29:47.019]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.019]                   }
[09:29:47.019]                 }
[09:29:47.019]             }
[09:29:47.019]         }))
[09:29:47.019]     }, error = function(ex) {
[09:29:47.019]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.019]                 ...future.rng), started = ...future.startTime, 
[09:29:47.019]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.019]             version = "1.8"), class = "FutureResult")
[09:29:47.019]     }, finally = {
[09:29:47.019]         if (!identical(...future.workdir, getwd())) 
[09:29:47.019]             setwd(...future.workdir)
[09:29:47.019]         {
[09:29:47.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.019]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.019]             }
[09:29:47.019]             base::options(...future.oldOptions)
[09:29:47.019]             if (.Platform$OS.type == "windows") {
[09:29:47.019]                 old_names <- names(...future.oldEnvVars)
[09:29:47.019]                 envs <- base::Sys.getenv()
[09:29:47.019]                 names <- names(envs)
[09:29:47.019]                 common <- intersect(names, old_names)
[09:29:47.019]                 added <- setdiff(names, old_names)
[09:29:47.019]                 removed <- setdiff(old_names, names)
[09:29:47.019]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.019]                   envs[common]]
[09:29:47.019]                 NAMES <- toupper(changed)
[09:29:47.019]                 args <- list()
[09:29:47.019]                 for (kk in seq_along(NAMES)) {
[09:29:47.019]                   name <- changed[[kk]]
[09:29:47.019]                   NAME <- NAMES[[kk]]
[09:29:47.019]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.019]                     next
[09:29:47.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.019]                 }
[09:29:47.019]                 NAMES <- toupper(added)
[09:29:47.019]                 for (kk in seq_along(NAMES)) {
[09:29:47.019]                   name <- added[[kk]]
[09:29:47.019]                   NAME <- NAMES[[kk]]
[09:29:47.019]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.019]                     next
[09:29:47.019]                   args[[name]] <- ""
[09:29:47.019]                 }
[09:29:47.019]                 NAMES <- toupper(removed)
[09:29:47.019]                 for (kk in seq_along(NAMES)) {
[09:29:47.019]                   name <- removed[[kk]]
[09:29:47.019]                   NAME <- NAMES[[kk]]
[09:29:47.019]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.019]                     next
[09:29:47.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.019]                 }
[09:29:47.019]                 if (length(args) > 0) 
[09:29:47.019]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.019]             }
[09:29:47.019]             else {
[09:29:47.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.019]             }
[09:29:47.019]             {
[09:29:47.019]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.019]                   0L) {
[09:29:47.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.019]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.019]                   base::options(opts)
[09:29:47.019]                 }
[09:29:47.019]                 {
[09:29:47.019]                   {
[09:29:47.019]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.019]                     NULL
[09:29:47.019]                   }
[09:29:47.019]                   options(future.plan = NULL)
[09:29:47.019]                   if (is.na(NA_character_)) 
[09:29:47.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.019]                     .init = FALSE)
[09:29:47.019]                 }
[09:29:47.019]             }
[09:29:47.019]         }
[09:29:47.019]     })
[09:29:47.019]     if (TRUE) {
[09:29:47.019]         base::sink(type = "output", split = FALSE)
[09:29:47.019]         if (TRUE) {
[09:29:47.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.019]         }
[09:29:47.019]         else {
[09:29:47.019]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.019]         }
[09:29:47.019]         base::close(...future.stdout)
[09:29:47.019]         ...future.stdout <- NULL
[09:29:47.019]     }
[09:29:47.019]     ...future.result$conditions <- ...future.conditions
[09:29:47.019]     ...future.result$finished <- base::Sys.time()
[09:29:47.019]     ...future.result
[09:29:47.019] }
[09:29:47.022] assign_globals() ...
[09:29:47.022] List of 11
[09:29:47.022]  $ ...future.FUN            :function (x, ...)  
[09:29:47.022]  $ x_FUN                    :function (x)  
[09:29:47.022]  $ times                    : int 4
[09:29:47.022]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.022]  $ stop_if_not              :function (...)  
[09:29:47.022]  $ dim                      : int [1:2] 2 2
[09:29:47.022]  $ valid_types              : chr [1:2] "logical" "integer"
[09:29:47.022]  $ future.call.arguments    : list()
[09:29:47.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.022]  $ ...future.elements_ii    :List of 5
[09:29:47.022]   ..$ : int 6
[09:29:47.022]   ..$ : int 7
[09:29:47.022]   ..$ : int 8
[09:29:47.022]   ..$ : int 9
[09:29:47.022]   ..$ : int 10
[09:29:47.022]  $ ...future.seeds_ii       : NULL
[09:29:47.022]  $ ...future.globals.maxSize: NULL
[09:29:47.022]  - attr(*, "where")=List of 11
[09:29:47.022]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.022]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:47.022]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:47.022]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:47.022]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:47.022]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:47.022]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:47.022]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.022]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.022]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.022]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.022]  - attr(*, "resolved")= logi FALSE
[09:29:47.022]  - attr(*, "total_size")= num 97232
[09:29:47.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.022]  - attr(*, "already-done")= logi TRUE
[09:29:47.033] - copied ‘...future.FUN’ to environment
[09:29:47.033] - reassign environment for ‘x_FUN’
[09:29:47.033] - copied ‘x_FUN’ to environment
[09:29:47.033] - copied ‘times’ to environment
[09:29:47.033] - copied ‘stopf’ to environment
[09:29:47.033] - copied ‘stop_if_not’ to environment
[09:29:47.034] - copied ‘dim’ to environment
[09:29:47.034] - copied ‘valid_types’ to environment
[09:29:47.034] - copied ‘future.call.arguments’ to environment
[09:29:47.034] - copied ‘...future.elements_ii’ to environment
[09:29:47.034] - copied ‘...future.seeds_ii’ to environment
[09:29:47.034] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.034] assign_globals() ... done
[09:29:47.034] requestCore(): workers = 2
[09:29:47.036] MulticoreFuture started
[09:29:47.037] - Launch lazy future ... done
[09:29:47.037] run() for ‘MulticoreFuture’ ... done
[09:29:47.037] Created future:
[09:29:47.038] plan(): Setting new future strategy stack:
[09:29:47.038] List of future strategies:
[09:29:47.038] 1. sequential:
[09:29:47.038]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.038]    - tweaked: FALSE
[09:29:47.038]    - call: NULL
[09:29:47.039] plan(): nbrOfWorkers() = 1
[09:29:47.041] plan(): Setting new future strategy stack:
[09:29:47.041] List of future strategies:
[09:29:47.041] 1. multicore:
[09:29:47.041]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.041]    - tweaked: FALSE
[09:29:47.041]    - call: plan(strategy)
[09:29:47.037] MulticoreFuture:
[09:29:47.037] Label: ‘future_vapply-2’
[09:29:47.037] Expression:
[09:29:47.037] {
[09:29:47.037]     do.call(function(...) {
[09:29:47.037]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.037]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.037]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.037]             on.exit(options(oopts), add = TRUE)
[09:29:47.037]         }
[09:29:47.037]         {
[09:29:47.037]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.037]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.037]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.037]             })
[09:29:47.037]         }
[09:29:47.037]     }, args = future.call.arguments)
[09:29:47.037] }
[09:29:47.037] Lazy evaluation: FALSE
[09:29:47.037] Asynchronous evaluation: TRUE
[09:29:47.037] Local evaluation: TRUE
[09:29:47.037] Environment: R_GlobalEnv
[09:29:47.037] Capture standard output: TRUE
[09:29:47.037] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.037] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:47.037] Packages: 1 packages (‘future.apply’)
[09:29:47.037] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.037] Resolved: FALSE
[09:29:47.037] Value: <not collected>
[09:29:47.037] Conditions captured: <none>
[09:29:47.037] Early signaling: FALSE
[09:29:47.037] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.037] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.050] Chunk #2 of 2 ... DONE
[09:29:47.050] Launching 2 futures (chunks) ... DONE
[09:29:47.051] Resolving 2 futures (chunks) ...
[09:29:47.051] resolve() on list ...
[09:29:47.051]  recursive: 0
[09:29:47.051]  length: 2
[09:29:47.051] plan(): nbrOfWorkers() = 2
[09:29:47.051] 
[09:29:47.051] Future #1
[09:29:47.054] result() for MulticoreFuture ...
[09:29:47.055] result() for MulticoreFuture ...
[09:29:47.055] result() for MulticoreFuture ... done
[09:29:47.055] result() for MulticoreFuture ... done
[09:29:47.056] result() for MulticoreFuture ...
[09:29:47.056] result() for MulticoreFuture ... done
[09:29:47.056] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:47.057] - nx: 2
[09:29:47.057] - relay: TRUE
[09:29:47.057] - stdout: TRUE
[09:29:47.057] - signal: TRUE
[09:29:47.058] - resignal: FALSE
[09:29:47.058] - force: TRUE
[09:29:47.058] - relayed: [n=2] FALSE, FALSE
[09:29:47.058] - queued futures: [n=2] FALSE, FALSE
[09:29:47.059]  - until=1
[09:29:47.059]  - relaying element #1
[09:29:47.059] result() for MulticoreFuture ...
[09:29:47.059] result() for MulticoreFuture ... done
[09:29:47.060] result() for MulticoreFuture ...
[09:29:47.060] result() for MulticoreFuture ... done
[09:29:47.060] result() for MulticoreFuture ...
[09:29:47.061] result() for MulticoreFuture ... done
[09:29:47.061] result() for MulticoreFuture ...
[09:29:47.061] result() for MulticoreFuture ... done
[09:29:47.061] - relayed: [n=2] TRUE, FALSE
[09:29:47.061] - queued futures: [n=2] TRUE, FALSE
[09:29:47.062] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:47.062]  length: 1 (resolved future 1)
[09:29:47.062] Future #2
[09:29:47.062] result() for MulticoreFuture ...
[09:29:47.063] result() for MulticoreFuture ...
[09:29:47.063] result() for MulticoreFuture ... done
[09:29:47.063] result() for MulticoreFuture ... done
[09:29:47.063] result() for MulticoreFuture ...
[09:29:47.064] result() for MulticoreFuture ... done
[09:29:47.064] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:47.064] - nx: 2
[09:29:47.064] - relay: TRUE
[09:29:47.064] - stdout: TRUE
[09:29:47.064] - signal: TRUE
[09:29:47.064] - resignal: FALSE
[09:29:47.065] - force: TRUE
[09:29:47.065] - relayed: [n=2] TRUE, FALSE
[09:29:47.065] - queued futures: [n=2] TRUE, FALSE
[09:29:47.065]  - until=2
[09:29:47.065]  - relaying element #2
[09:29:47.065] result() for MulticoreFuture ...
[09:29:47.065] result() for MulticoreFuture ... done
[09:29:47.065] result() for MulticoreFuture ...
[09:29:47.065] result() for MulticoreFuture ... done
[09:29:47.066] result() for MulticoreFuture ...
[09:29:47.066] result() for MulticoreFuture ... done
[09:29:47.066] result() for MulticoreFuture ...
[09:29:47.066] result() for MulticoreFuture ... done
[09:29:47.066] - relayed: [n=2] TRUE, TRUE
[09:29:47.066] - queued futures: [n=2] TRUE, TRUE
[09:29:47.066] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:47.066]  length: 0 (resolved future 2)
[09:29:47.066] Relaying remaining futures
[09:29:47.067] signalConditionsASAP(NULL, pos=0) ...
[09:29:47.067] - nx: 2
[09:29:47.067] - relay: TRUE
[09:29:47.067] - stdout: TRUE
[09:29:47.067] - signal: TRUE
[09:29:47.067] - resignal: FALSE
[09:29:47.067] - force: TRUE
[09:29:47.067] - relayed: [n=2] TRUE, TRUE
[09:29:47.067] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:47.067] - relayed: [n=2] TRUE, TRUE
[09:29:47.068] - queued futures: [n=2] TRUE, TRUE
[09:29:47.068] signalConditionsASAP(NULL, pos=0) ... done
[09:29:47.068] resolve() on list ... DONE
[09:29:47.068] result() for MulticoreFuture ...
[09:29:47.068] result() for MulticoreFuture ... done
[09:29:47.068] result() for MulticoreFuture ...
[09:29:47.068] result() for MulticoreFuture ... done
[09:29:47.068] result() for MulticoreFuture ...
[09:29:47.068] result() for MulticoreFuture ... done
[09:29:47.068] result() for MulticoreFuture ...
[09:29:47.069] result() for MulticoreFuture ... done
[09:29:47.069]  - Number of value chunks collected: 2
[09:29:47.069] Resolving 2 futures (chunks) ... DONE
[09:29:47.069] Reducing values from 2 chunks ...
[09:29:47.069]  - Number of values collected after concatenation: 10
[09:29:47.069]  - Number of values expected: 10
[09:29:47.069] Reducing values from 2 chunks ... DONE
[09:29:47.069] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[09:29:47.070] future_lapply() ...
[09:29:47.076] Number of chunks: 2
[09:29:47.076] getGlobalsAndPackagesXApply() ...
[09:29:47.076]  - future.globals: TRUE
[09:29:47.076] getGlobalsAndPackages() ...
[09:29:47.076] Searching for globals...
[09:29:47.080] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[09:29:47.080] Searching for globals ... DONE
[09:29:47.080] Resolving globals: FALSE
[09:29:47.081] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[09:29:47.081] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:47.082] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.082] - packages: [1] ‘future.apply’
[09:29:47.082] getGlobalsAndPackages() ... DONE
[09:29:47.082]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.082]  - needed namespaces: [n=1] ‘future.apply’
[09:29:47.084] Finding globals ... DONE
[09:29:47.084]  - use_args: TRUE
[09:29:47.084]  - Getting '...' globals ...
[09:29:47.084] resolve() on list ...
[09:29:47.084]  recursive: 0
[09:29:47.084]  length: 1
[09:29:47.085]  elements: ‘...’
[09:29:47.085]  length: 0 (resolved future 1)
[09:29:47.085] resolve() on list ... DONE
[09:29:47.085]    - '...' content: [n=0] 
[09:29:47.085] List of 1
[09:29:47.085]  $ ...: list()
[09:29:47.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.085]  - attr(*, "where")=List of 1
[09:29:47.085]   ..$ ...:<environment: 0x561d35d3b300> 
[09:29:47.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.085]  - attr(*, "resolved")= logi TRUE
[09:29:47.085]  - attr(*, "total_size")= num NA
[09:29:47.088]  - Getting '...' globals ... DONE
[09:29:47.088] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:47.088] List of 8
[09:29:47.088]  $ ...future.FUN:function (x, ...)  
[09:29:47.088]  $ x_FUN        :function (x)  
[09:29:47.088]  $ times        : int 4
[09:29:47.088]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.088]  $ stop_if_not  :function (...)  
[09:29:47.088]  $ dim          : int [1:2] 2 2
[09:29:47.088]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:47.088]  $ ...          : list()
[09:29:47.088]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.088]  - attr(*, "where")=List of 8
[09:29:47.088]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:47.088]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:47.088]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:47.088]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:47.088]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:47.088]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:47.088]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:47.088]   ..$ ...          :<environment: 0x561d35d3b300> 
[09:29:47.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.088]  - attr(*, "resolved")= logi FALSE
[09:29:47.088]  - attr(*, "total_size")= num 97304
[09:29:47.093] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:47.093] getGlobalsAndPackagesXApply() ... DONE
[09:29:47.093] Number of futures (= number of chunks): 2
[09:29:47.093] Launching 2 futures (chunks) ...
[09:29:47.094] Chunk #1 of 2 ...
[09:29:47.094]  - Finding globals in 'X' for chunk #1 ...
[09:29:47.094] getGlobalsAndPackages() ...
[09:29:47.094] Searching for globals...
[09:29:47.094] 
[09:29:47.094] Searching for globals ... DONE
[09:29:47.094] - globals: [0] <none>
[09:29:47.094] getGlobalsAndPackages() ... DONE
[09:29:47.094]    + additional globals found: [n=0] 
[09:29:47.095]    + additional namespaces needed: [n=0] 
[09:29:47.095]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:47.095]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.095]  - seeds: <none>
[09:29:47.095]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.095] getGlobalsAndPackages() ...
[09:29:47.095] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.095] Resolving globals: FALSE
[09:29:47.095] Tweak future expression to call with '...' arguments ...
[09:29:47.095] {
[09:29:47.095]     do.call(function(...) {
[09:29:47.095]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.095]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.095]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.095]             on.exit(options(oopts), add = TRUE)
[09:29:47.095]         }
[09:29:47.095]         {
[09:29:47.095]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.095]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.095]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.095]             })
[09:29:47.095]         }
[09:29:47.095]     }, args = future.call.arguments)
[09:29:47.095] }
[09:29:47.096] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.096] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.096] - packages: [1] ‘future.apply’
[09:29:47.096] getGlobalsAndPackages() ... DONE
[09:29:47.097] run() for ‘Future’ ...
[09:29:47.097] - state: ‘created’
[09:29:47.097] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.100] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.101] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.101]   - Field: ‘label’
[09:29:47.101]   - Field: ‘local’
[09:29:47.101]   - Field: ‘owner’
[09:29:47.101]   - Field: ‘envir’
[09:29:47.101]   - Field: ‘workers’
[09:29:47.101]   - Field: ‘packages’
[09:29:47.101]   - Field: ‘gc’
[09:29:47.101]   - Field: ‘job’
[09:29:47.101]   - Field: ‘conditions’
[09:29:47.101]   - Field: ‘expr’
[09:29:47.102]   - Field: ‘uuid’
[09:29:47.102]   - Field: ‘seed’
[09:29:47.102]   - Field: ‘version’
[09:29:47.102]   - Field: ‘result’
[09:29:47.102]   - Field: ‘asynchronous’
[09:29:47.102]   - Field: ‘calls’
[09:29:47.102]   - Field: ‘globals’
[09:29:47.102]   - Field: ‘stdout’
[09:29:47.102]   - Field: ‘earlySignal’
[09:29:47.102]   - Field: ‘lazy’
[09:29:47.102]   - Field: ‘state’
[09:29:47.102] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.103] - Launch lazy future ...
[09:29:47.103] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:47.103] Packages needed by future strategies (n = 0): <none>
[09:29:47.103] {
[09:29:47.103]     {
[09:29:47.103]         {
[09:29:47.103]             ...future.startTime <- base::Sys.time()
[09:29:47.103]             {
[09:29:47.103]                 {
[09:29:47.103]                   {
[09:29:47.103]                     {
[09:29:47.103]                       {
[09:29:47.103]                         base::local({
[09:29:47.103]                           has_future <- base::requireNamespace("future", 
[09:29:47.103]                             quietly = TRUE)
[09:29:47.103]                           if (has_future) {
[09:29:47.103]                             ns <- base::getNamespace("future")
[09:29:47.103]                             version <- ns[[".package"]][["version"]]
[09:29:47.103]                             if (is.null(version)) 
[09:29:47.103]                               version <- utils::packageVersion("future")
[09:29:47.103]                           }
[09:29:47.103]                           else {
[09:29:47.103]                             version <- NULL
[09:29:47.103]                           }
[09:29:47.103]                           if (!has_future || version < "1.8.0") {
[09:29:47.103]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.103]                               "", base::R.version$version.string), 
[09:29:47.103]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.103]                                 base::R.version$platform, 8 * 
[09:29:47.103]                                   base::.Machine$sizeof.pointer), 
[09:29:47.103]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.103]                                 "release", "version")], collapse = " "), 
[09:29:47.103]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.103]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.103]                               info)
[09:29:47.103]                             info <- base::paste(info, collapse = "; ")
[09:29:47.103]                             if (!has_future) {
[09:29:47.103]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.103]                                 info)
[09:29:47.103]                             }
[09:29:47.103]                             else {
[09:29:47.103]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.103]                                 info, version)
[09:29:47.103]                             }
[09:29:47.103]                             base::stop(msg)
[09:29:47.103]                           }
[09:29:47.103]                         })
[09:29:47.103]                       }
[09:29:47.103]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.103]                       base::options(mc.cores = 1L)
[09:29:47.103]                     }
[09:29:47.103]                     base::local({
[09:29:47.103]                       for (pkg in "future.apply") {
[09:29:47.103]                         base::loadNamespace(pkg)
[09:29:47.103]                         base::library(pkg, character.only = TRUE)
[09:29:47.103]                       }
[09:29:47.103]                     })
[09:29:47.103]                   }
[09:29:47.103]                   ...future.strategy.old <- future::plan("list")
[09:29:47.103]                   options(future.plan = NULL)
[09:29:47.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.103]                 }
[09:29:47.103]                 ...future.workdir <- getwd()
[09:29:47.103]             }
[09:29:47.103]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.103]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.103]         }
[09:29:47.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.103]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.103]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.103]             base::names(...future.oldOptions))
[09:29:47.103]     }
[09:29:47.103]     if (FALSE) {
[09:29:47.103]     }
[09:29:47.103]     else {
[09:29:47.103]         if (TRUE) {
[09:29:47.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.103]                 open = "w")
[09:29:47.103]         }
[09:29:47.103]         else {
[09:29:47.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.103]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.103]         }
[09:29:47.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.103]             base::sink(type = "output", split = FALSE)
[09:29:47.103]             base::close(...future.stdout)
[09:29:47.103]         }, add = TRUE)
[09:29:47.103]     }
[09:29:47.103]     ...future.frame <- base::sys.nframe()
[09:29:47.103]     ...future.conditions <- base::list()
[09:29:47.103]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.103]     if (FALSE) {
[09:29:47.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.103]     }
[09:29:47.103]     ...future.result <- base::tryCatch({
[09:29:47.103]         base::withCallingHandlers({
[09:29:47.103]             ...future.value <- base::withVisible(base::local({
[09:29:47.103]                 withCallingHandlers({
[09:29:47.103]                   {
[09:29:47.103]                     do.call(function(...) {
[09:29:47.103]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.103]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.103]                         ...future.globals.maxSize)) {
[09:29:47.103]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.103]                         on.exit(options(oopts), add = TRUE)
[09:29:47.103]                       }
[09:29:47.103]                       {
[09:29:47.103]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.103]                           FUN = function(jj) {
[09:29:47.103]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.103]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.103]                           })
[09:29:47.103]                       }
[09:29:47.103]                     }, args = future.call.arguments)
[09:29:47.103]                   }
[09:29:47.103]                 }, immediateCondition = function(cond) {
[09:29:47.103]                   save_rds <- function (object, pathname, ...) 
[09:29:47.103]                   {
[09:29:47.103]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.103]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.103]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.103]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.103]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.103]                         fi_tmp[["mtime"]])
[09:29:47.103]                     }
[09:29:47.103]                     tryCatch({
[09:29:47.103]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.103]                     }, error = function(ex) {
[09:29:47.103]                       msg <- conditionMessage(ex)
[09:29:47.103]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.103]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.103]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.103]                         fi_tmp[["mtime"]], msg)
[09:29:47.103]                       ex$message <- msg
[09:29:47.103]                       stop(ex)
[09:29:47.103]                     })
[09:29:47.103]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.103]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.103]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.103]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.103]                       fi <- file.info(pathname)
[09:29:47.103]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.103]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.103]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.103]                         fi[["size"]], fi[["mtime"]])
[09:29:47.103]                       stop(msg)
[09:29:47.103]                     }
[09:29:47.103]                     invisible(pathname)
[09:29:47.103]                   }
[09:29:47.103]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.103]                     rootPath = tempdir()) 
[09:29:47.103]                   {
[09:29:47.103]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.103]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.103]                       tmpdir = path, fileext = ".rds")
[09:29:47.103]                     save_rds(obj, file)
[09:29:47.103]                   }
[09:29:47.103]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.103]                   {
[09:29:47.103]                     inherits <- base::inherits
[09:29:47.103]                     invokeRestart <- base::invokeRestart
[09:29:47.103]                     is.null <- base::is.null
[09:29:47.103]                     muffled <- FALSE
[09:29:47.103]                     if (inherits(cond, "message")) {
[09:29:47.103]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.103]                       if (muffled) 
[09:29:47.103]                         invokeRestart("muffleMessage")
[09:29:47.103]                     }
[09:29:47.103]                     else if (inherits(cond, "warning")) {
[09:29:47.103]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.103]                       if (muffled) 
[09:29:47.103]                         invokeRestart("muffleWarning")
[09:29:47.103]                     }
[09:29:47.103]                     else if (inherits(cond, "condition")) {
[09:29:47.103]                       if (!is.null(pattern)) {
[09:29:47.103]                         computeRestarts <- base::computeRestarts
[09:29:47.103]                         grepl <- base::grepl
[09:29:47.103]                         restarts <- computeRestarts(cond)
[09:29:47.103]                         for (restart in restarts) {
[09:29:47.103]                           name <- restart$name
[09:29:47.103]                           if (is.null(name)) 
[09:29:47.103]                             next
[09:29:47.103]                           if (!grepl(pattern, name)) 
[09:29:47.103]                             next
[09:29:47.103]                           invokeRestart(restart)
[09:29:47.103]                           muffled <- TRUE
[09:29:47.103]                           break
[09:29:47.103]                         }
[09:29:47.103]                       }
[09:29:47.103]                     }
[09:29:47.103]                     invisible(muffled)
[09:29:47.103]                   }
[09:29:47.103]                   muffleCondition(cond)
[09:29:47.103]                 })
[09:29:47.103]             }))
[09:29:47.103]             future::FutureResult(value = ...future.value$value, 
[09:29:47.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.103]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.103]                     ...future.globalenv.names))
[09:29:47.103]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.103]         }, condition = base::local({
[09:29:47.103]             c <- base::c
[09:29:47.103]             inherits <- base::inherits
[09:29:47.103]             invokeRestart <- base::invokeRestart
[09:29:47.103]             length <- base::length
[09:29:47.103]             list <- base::list
[09:29:47.103]             seq.int <- base::seq.int
[09:29:47.103]             signalCondition <- base::signalCondition
[09:29:47.103]             sys.calls <- base::sys.calls
[09:29:47.103]             `[[` <- base::`[[`
[09:29:47.103]             `+` <- base::`+`
[09:29:47.103]             `<<-` <- base::`<<-`
[09:29:47.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.103]                   3L)]
[09:29:47.103]             }
[09:29:47.103]             function(cond) {
[09:29:47.103]                 is_error <- inherits(cond, "error")
[09:29:47.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.103]                   NULL)
[09:29:47.103]                 if (is_error) {
[09:29:47.103]                   sessionInformation <- function() {
[09:29:47.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.103]                       search = base::search(), system = base::Sys.info())
[09:29:47.103]                   }
[09:29:47.103]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.103]                     cond$call), session = sessionInformation(), 
[09:29:47.103]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.103]                   signalCondition(cond)
[09:29:47.103]                 }
[09:29:47.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.103]                 "immediateCondition"))) {
[09:29:47.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.103]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.103]                   if (TRUE && !signal) {
[09:29:47.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.103]                     {
[09:29:47.103]                       inherits <- base::inherits
[09:29:47.103]                       invokeRestart <- base::invokeRestart
[09:29:47.103]                       is.null <- base::is.null
[09:29:47.103]                       muffled <- FALSE
[09:29:47.103]                       if (inherits(cond, "message")) {
[09:29:47.103]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.103]                         if (muffled) 
[09:29:47.103]                           invokeRestart("muffleMessage")
[09:29:47.103]                       }
[09:29:47.103]                       else if (inherits(cond, "warning")) {
[09:29:47.103]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.103]                         if (muffled) 
[09:29:47.103]                           invokeRestart("muffleWarning")
[09:29:47.103]                       }
[09:29:47.103]                       else if (inherits(cond, "condition")) {
[09:29:47.103]                         if (!is.null(pattern)) {
[09:29:47.103]                           computeRestarts <- base::computeRestarts
[09:29:47.103]                           grepl <- base::grepl
[09:29:47.103]                           restarts <- computeRestarts(cond)
[09:29:47.103]                           for (restart in restarts) {
[09:29:47.103]                             name <- restart$name
[09:29:47.103]                             if (is.null(name)) 
[09:29:47.103]                               next
[09:29:47.103]                             if (!grepl(pattern, name)) 
[09:29:47.103]                               next
[09:29:47.103]                             invokeRestart(restart)
[09:29:47.103]                             muffled <- TRUE
[09:29:47.103]                             break
[09:29:47.103]                           }
[09:29:47.103]                         }
[09:29:47.103]                       }
[09:29:47.103]                       invisible(muffled)
[09:29:47.103]                     }
[09:29:47.103]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.103]                   }
[09:29:47.103]                 }
[09:29:47.103]                 else {
[09:29:47.103]                   if (TRUE) {
[09:29:47.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.103]                     {
[09:29:47.103]                       inherits <- base::inherits
[09:29:47.103]                       invokeRestart <- base::invokeRestart
[09:29:47.103]                       is.null <- base::is.null
[09:29:47.103]                       muffled <- FALSE
[09:29:47.103]                       if (inherits(cond, "message")) {
[09:29:47.103]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.103]                         if (muffled) 
[09:29:47.103]                           invokeRestart("muffleMessage")
[09:29:47.103]                       }
[09:29:47.103]                       else if (inherits(cond, "warning")) {
[09:29:47.103]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.103]                         if (muffled) 
[09:29:47.103]                           invokeRestart("muffleWarning")
[09:29:47.103]                       }
[09:29:47.103]                       else if (inherits(cond, "condition")) {
[09:29:47.103]                         if (!is.null(pattern)) {
[09:29:47.103]                           computeRestarts <- base::computeRestarts
[09:29:47.103]                           grepl <- base::grepl
[09:29:47.103]                           restarts <- computeRestarts(cond)
[09:29:47.103]                           for (restart in restarts) {
[09:29:47.103]                             name <- restart$name
[09:29:47.103]                             if (is.null(name)) 
[09:29:47.103]                               next
[09:29:47.103]                             if (!grepl(pattern, name)) 
[09:29:47.103]                               next
[09:29:47.103]                             invokeRestart(restart)
[09:29:47.103]                             muffled <- TRUE
[09:29:47.103]                             break
[09:29:47.103]                           }
[09:29:47.103]                         }
[09:29:47.103]                       }
[09:29:47.103]                       invisible(muffled)
[09:29:47.103]                     }
[09:29:47.103]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.103]                   }
[09:29:47.103]                 }
[09:29:47.103]             }
[09:29:47.103]         }))
[09:29:47.103]     }, error = function(ex) {
[09:29:47.103]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.103]                 ...future.rng), started = ...future.startTime, 
[09:29:47.103]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.103]             version = "1.8"), class = "FutureResult")
[09:29:47.103]     }, finally = {
[09:29:47.103]         if (!identical(...future.workdir, getwd())) 
[09:29:47.103]             setwd(...future.workdir)
[09:29:47.103]         {
[09:29:47.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.103]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.103]             }
[09:29:47.103]             base::options(...future.oldOptions)
[09:29:47.103]             if (.Platform$OS.type == "windows") {
[09:29:47.103]                 old_names <- names(...future.oldEnvVars)
[09:29:47.103]                 envs <- base::Sys.getenv()
[09:29:47.103]                 names <- names(envs)
[09:29:47.103]                 common <- intersect(names, old_names)
[09:29:47.103]                 added <- setdiff(names, old_names)
[09:29:47.103]                 removed <- setdiff(old_names, names)
[09:29:47.103]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.103]                   envs[common]]
[09:29:47.103]                 NAMES <- toupper(changed)
[09:29:47.103]                 args <- list()
[09:29:47.103]                 for (kk in seq_along(NAMES)) {
[09:29:47.103]                   name <- changed[[kk]]
[09:29:47.103]                   NAME <- NAMES[[kk]]
[09:29:47.103]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.103]                     next
[09:29:47.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.103]                 }
[09:29:47.103]                 NAMES <- toupper(added)
[09:29:47.103]                 for (kk in seq_along(NAMES)) {
[09:29:47.103]                   name <- added[[kk]]
[09:29:47.103]                   NAME <- NAMES[[kk]]
[09:29:47.103]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.103]                     next
[09:29:47.103]                   args[[name]] <- ""
[09:29:47.103]                 }
[09:29:47.103]                 NAMES <- toupper(removed)
[09:29:47.103]                 for (kk in seq_along(NAMES)) {
[09:29:47.103]                   name <- removed[[kk]]
[09:29:47.103]                   NAME <- NAMES[[kk]]
[09:29:47.103]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.103]                     next
[09:29:47.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.103]                 }
[09:29:47.103]                 if (length(args) > 0) 
[09:29:47.103]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.103]             }
[09:29:47.103]             else {
[09:29:47.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.103]             }
[09:29:47.103]             {
[09:29:47.103]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.103]                   0L) {
[09:29:47.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.103]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.103]                   base::options(opts)
[09:29:47.103]                 }
[09:29:47.103]                 {
[09:29:47.103]                   {
[09:29:47.103]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.103]                     NULL
[09:29:47.103]                   }
[09:29:47.103]                   options(future.plan = NULL)
[09:29:47.103]                   if (is.na(NA_character_)) 
[09:29:47.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.103]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.103]                     .init = FALSE)
[09:29:47.103]                 }
[09:29:47.103]             }
[09:29:47.103]         }
[09:29:47.103]     })
[09:29:47.103]     if (TRUE) {
[09:29:47.103]         base::sink(type = "output", split = FALSE)
[09:29:47.103]         if (TRUE) {
[09:29:47.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.103]         }
[09:29:47.103]         else {
[09:29:47.103]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.103]         }
[09:29:47.103]         base::close(...future.stdout)
[09:29:47.103]         ...future.stdout <- NULL
[09:29:47.103]     }
[09:29:47.103]     ...future.result$conditions <- ...future.conditions
[09:29:47.103]     ...future.result$finished <- base::Sys.time()
[09:29:47.103]     ...future.result
[09:29:47.103] }
[09:29:47.106] assign_globals() ...
[09:29:47.106] List of 11
[09:29:47.106]  $ ...future.FUN            :function (x, ...)  
[09:29:47.106]  $ x_FUN                    :function (x)  
[09:29:47.106]  $ times                    : int 4
[09:29:47.106]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.106]  $ stop_if_not              :function (...)  
[09:29:47.106]  $ dim                      : int [1:2] 2 2
[09:29:47.106]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:47.106]  $ future.call.arguments    : list()
[09:29:47.106]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.106]  $ ...future.elements_ii    :List of 5
[09:29:47.106]   ..$ : int 1
[09:29:47.106]   ..$ : int 2
[09:29:47.106]   ..$ : int 3
[09:29:47.106]   ..$ : int 4
[09:29:47.106]   ..$ : int 5
[09:29:47.106]  $ ...future.seeds_ii       : NULL
[09:29:47.106]  $ ...future.globals.maxSize: NULL
[09:29:47.106]  - attr(*, "where")=List of 11
[09:29:47.106]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.106]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:47.106]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:47.106]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:47.106]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:47.106]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:47.106]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:47.106]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.106]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.106]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.106]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.106]  - attr(*, "resolved")= logi FALSE
[09:29:47.106]  - attr(*, "total_size")= num 97304
[09:29:47.106]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.106]  - attr(*, "already-done")= logi TRUE
[09:29:47.116] - copied ‘...future.FUN’ to environment
[09:29:47.116] - reassign environment for ‘x_FUN’
[09:29:47.116] - copied ‘x_FUN’ to environment
[09:29:47.116] - copied ‘times’ to environment
[09:29:47.116] - copied ‘stopf’ to environment
[09:29:47.116] - copied ‘stop_if_not’ to environment
[09:29:47.116] - copied ‘dim’ to environment
[09:29:47.116] - copied ‘valid_types’ to environment
[09:29:47.116] - copied ‘future.call.arguments’ to environment
[09:29:47.117] - copied ‘...future.elements_ii’ to environment
[09:29:47.117] - copied ‘...future.seeds_ii’ to environment
[09:29:47.117] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.117] assign_globals() ... done
[09:29:47.117] requestCore(): workers = 2
[09:29:47.119] MulticoreFuture started
[09:29:47.119] - Launch lazy future ... done
[09:29:47.120] run() for ‘MulticoreFuture’ ... done
[09:29:47.120] Created future:
[09:29:47.120] plan(): Setting new future strategy stack:
[09:29:47.121] List of future strategies:
[09:29:47.121] 1. sequential:
[09:29:47.121]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.121]    - tweaked: FALSE
[09:29:47.121]    - call: NULL
[09:29:47.122] plan(): nbrOfWorkers() = 1
[09:29:47.124] plan(): Setting new future strategy stack:
[09:29:47.124] List of future strategies:
[09:29:47.124] 1. multicore:
[09:29:47.124]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.124]    - tweaked: FALSE
[09:29:47.124]    - call: plan(strategy)
[09:29:47.129] plan(): nbrOfWorkers() = 2
[09:29:47.120] MulticoreFuture:
[09:29:47.120] Label: ‘future_vapply-1’
[09:29:47.120] Expression:
[09:29:47.120] {
[09:29:47.120]     do.call(function(...) {
[09:29:47.120]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.120]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.120]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.120]             on.exit(options(oopts), add = TRUE)
[09:29:47.120]         }
[09:29:47.120]         {
[09:29:47.120]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.120]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.120]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.120]             })
[09:29:47.120]         }
[09:29:47.120]     }, args = future.call.arguments)
[09:29:47.120] }
[09:29:47.120] Lazy evaluation: FALSE
[09:29:47.120] Asynchronous evaluation: TRUE
[09:29:47.120] Local evaluation: TRUE
[09:29:47.120] Environment: R_GlobalEnv
[09:29:47.120] Capture standard output: TRUE
[09:29:47.120] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.120] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:47.120] Packages: 1 packages (‘future.apply’)
[09:29:47.120] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.120] Resolved: TRUE
[09:29:47.120] Value: <not collected>
[09:29:47.120] Conditions captured: <none>
[09:29:47.120] Early signaling: FALSE
[09:29:47.120] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.120] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.130] Chunk #1 of 2 ... DONE
[09:29:47.130] Chunk #2 of 2 ...
[09:29:47.130]  - Finding globals in 'X' for chunk #2 ...
[09:29:47.130] getGlobalsAndPackages() ...
[09:29:47.130] Searching for globals...
[09:29:47.131] 
[09:29:47.131] Searching for globals ... DONE
[09:29:47.131] - globals: [0] <none>
[09:29:47.131] getGlobalsAndPackages() ... DONE
[09:29:47.131]    + additional globals found: [n=0] 
[09:29:47.131]    + additional namespaces needed: [n=0] 
[09:29:47.131]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:47.132]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.132]  - seeds: <none>
[09:29:47.132]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.132] getGlobalsAndPackages() ...
[09:29:47.132] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.132] Resolving globals: FALSE
[09:29:47.132] Tweak future expression to call with '...' arguments ...
[09:29:47.133] {
[09:29:47.133]     do.call(function(...) {
[09:29:47.133]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.133]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.133]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.133]             on.exit(options(oopts), add = TRUE)
[09:29:47.133]         }
[09:29:47.133]         {
[09:29:47.133]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.133]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.133]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.133]             })
[09:29:47.133]         }
[09:29:47.133]     }, args = future.call.arguments)
[09:29:47.133] }
[09:29:47.133] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.134] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.134] - packages: [1] ‘future.apply’
[09:29:47.134] getGlobalsAndPackages() ... DONE
[09:29:47.135] run() for ‘Future’ ...
[09:29:47.135] - state: ‘created’
[09:29:47.135] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.140] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.140] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.140]   - Field: ‘label’
[09:29:47.140]   - Field: ‘local’
[09:29:47.140]   - Field: ‘owner’
[09:29:47.140]   - Field: ‘envir’
[09:29:47.141]   - Field: ‘workers’
[09:29:47.141]   - Field: ‘packages’
[09:29:47.141]   - Field: ‘gc’
[09:29:47.141]   - Field: ‘job’
[09:29:47.141]   - Field: ‘conditions’
[09:29:47.141]   - Field: ‘expr’
[09:29:47.141]   - Field: ‘uuid’
[09:29:47.141]   - Field: ‘seed’
[09:29:47.142]   - Field: ‘version’
[09:29:47.142]   - Field: ‘result’
[09:29:47.142]   - Field: ‘asynchronous’
[09:29:47.142]   - Field: ‘calls’
[09:29:47.142]   - Field: ‘globals’
[09:29:47.142]   - Field: ‘stdout’
[09:29:47.142]   - Field: ‘earlySignal’
[09:29:47.145]   - Field: ‘lazy’
[09:29:47.145]   - Field: ‘state’
[09:29:47.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.146] - Launch lazy future ...
[09:29:47.147] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:47.147] Packages needed by future strategies (n = 0): <none>
[09:29:47.149] {
[09:29:47.149]     {
[09:29:47.149]         {
[09:29:47.149]             ...future.startTime <- base::Sys.time()
[09:29:47.149]             {
[09:29:47.149]                 {
[09:29:47.149]                   {
[09:29:47.149]                     {
[09:29:47.149]                       {
[09:29:47.149]                         base::local({
[09:29:47.149]                           has_future <- base::requireNamespace("future", 
[09:29:47.149]                             quietly = TRUE)
[09:29:47.149]                           if (has_future) {
[09:29:47.149]                             ns <- base::getNamespace("future")
[09:29:47.149]                             version <- ns[[".package"]][["version"]]
[09:29:47.149]                             if (is.null(version)) 
[09:29:47.149]                               version <- utils::packageVersion("future")
[09:29:47.149]                           }
[09:29:47.149]                           else {
[09:29:47.149]                             version <- NULL
[09:29:47.149]                           }
[09:29:47.149]                           if (!has_future || version < "1.8.0") {
[09:29:47.149]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.149]                               "", base::R.version$version.string), 
[09:29:47.149]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.149]                                 base::R.version$platform, 8 * 
[09:29:47.149]                                   base::.Machine$sizeof.pointer), 
[09:29:47.149]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.149]                                 "release", "version")], collapse = " "), 
[09:29:47.149]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.149]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.149]                               info)
[09:29:47.149]                             info <- base::paste(info, collapse = "; ")
[09:29:47.149]                             if (!has_future) {
[09:29:47.149]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.149]                                 info)
[09:29:47.149]                             }
[09:29:47.149]                             else {
[09:29:47.149]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.149]                                 info, version)
[09:29:47.149]                             }
[09:29:47.149]                             base::stop(msg)
[09:29:47.149]                           }
[09:29:47.149]                         })
[09:29:47.149]                       }
[09:29:47.149]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.149]                       base::options(mc.cores = 1L)
[09:29:47.149]                     }
[09:29:47.149]                     base::local({
[09:29:47.149]                       for (pkg in "future.apply") {
[09:29:47.149]                         base::loadNamespace(pkg)
[09:29:47.149]                         base::library(pkg, character.only = TRUE)
[09:29:47.149]                       }
[09:29:47.149]                     })
[09:29:47.149]                   }
[09:29:47.149]                   ...future.strategy.old <- future::plan("list")
[09:29:47.149]                   options(future.plan = NULL)
[09:29:47.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.149]                 }
[09:29:47.149]                 ...future.workdir <- getwd()
[09:29:47.149]             }
[09:29:47.149]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.149]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.149]         }
[09:29:47.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.149]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.149]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.149]             base::names(...future.oldOptions))
[09:29:47.149]     }
[09:29:47.149]     if (FALSE) {
[09:29:47.149]     }
[09:29:47.149]     else {
[09:29:47.149]         if (TRUE) {
[09:29:47.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.149]                 open = "w")
[09:29:47.149]         }
[09:29:47.149]         else {
[09:29:47.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.149]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.149]         }
[09:29:47.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.149]             base::sink(type = "output", split = FALSE)
[09:29:47.149]             base::close(...future.stdout)
[09:29:47.149]         }, add = TRUE)
[09:29:47.149]     }
[09:29:47.149]     ...future.frame <- base::sys.nframe()
[09:29:47.149]     ...future.conditions <- base::list()
[09:29:47.149]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.149]     if (FALSE) {
[09:29:47.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.149]     }
[09:29:47.149]     ...future.result <- base::tryCatch({
[09:29:47.149]         base::withCallingHandlers({
[09:29:47.149]             ...future.value <- base::withVisible(base::local({
[09:29:47.149]                 withCallingHandlers({
[09:29:47.149]                   {
[09:29:47.149]                     do.call(function(...) {
[09:29:47.149]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.149]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.149]                         ...future.globals.maxSize)) {
[09:29:47.149]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.149]                         on.exit(options(oopts), add = TRUE)
[09:29:47.149]                       }
[09:29:47.149]                       {
[09:29:47.149]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.149]                           FUN = function(jj) {
[09:29:47.149]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.149]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.149]                           })
[09:29:47.149]                       }
[09:29:47.149]                     }, args = future.call.arguments)
[09:29:47.149]                   }
[09:29:47.149]                 }, immediateCondition = function(cond) {
[09:29:47.149]                   save_rds <- function (object, pathname, ...) 
[09:29:47.149]                   {
[09:29:47.149]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.149]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.149]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.149]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.149]                         fi_tmp[["mtime"]])
[09:29:47.149]                     }
[09:29:47.149]                     tryCatch({
[09:29:47.149]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.149]                     }, error = function(ex) {
[09:29:47.149]                       msg <- conditionMessage(ex)
[09:29:47.149]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.149]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.149]                         fi_tmp[["mtime"]], msg)
[09:29:47.149]                       ex$message <- msg
[09:29:47.149]                       stop(ex)
[09:29:47.149]                     })
[09:29:47.149]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.149]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.149]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.149]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.149]                       fi <- file.info(pathname)
[09:29:47.149]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.149]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.149]                         fi[["size"]], fi[["mtime"]])
[09:29:47.149]                       stop(msg)
[09:29:47.149]                     }
[09:29:47.149]                     invisible(pathname)
[09:29:47.149]                   }
[09:29:47.149]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.149]                     rootPath = tempdir()) 
[09:29:47.149]                   {
[09:29:47.149]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.149]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.149]                       tmpdir = path, fileext = ".rds")
[09:29:47.149]                     save_rds(obj, file)
[09:29:47.149]                   }
[09:29:47.149]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.149]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.149]                   {
[09:29:47.149]                     inherits <- base::inherits
[09:29:47.149]                     invokeRestart <- base::invokeRestart
[09:29:47.149]                     is.null <- base::is.null
[09:29:47.149]                     muffled <- FALSE
[09:29:47.149]                     if (inherits(cond, "message")) {
[09:29:47.149]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.149]                       if (muffled) 
[09:29:47.149]                         invokeRestart("muffleMessage")
[09:29:47.149]                     }
[09:29:47.149]                     else if (inherits(cond, "warning")) {
[09:29:47.149]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.149]                       if (muffled) 
[09:29:47.149]                         invokeRestart("muffleWarning")
[09:29:47.149]                     }
[09:29:47.149]                     else if (inherits(cond, "condition")) {
[09:29:47.149]                       if (!is.null(pattern)) {
[09:29:47.149]                         computeRestarts <- base::computeRestarts
[09:29:47.149]                         grepl <- base::grepl
[09:29:47.149]                         restarts <- computeRestarts(cond)
[09:29:47.149]                         for (restart in restarts) {
[09:29:47.149]                           name <- restart$name
[09:29:47.149]                           if (is.null(name)) 
[09:29:47.149]                             next
[09:29:47.149]                           if (!grepl(pattern, name)) 
[09:29:47.149]                             next
[09:29:47.149]                           invokeRestart(restart)
[09:29:47.149]                           muffled <- TRUE
[09:29:47.149]                           break
[09:29:47.149]                         }
[09:29:47.149]                       }
[09:29:47.149]                     }
[09:29:47.149]                     invisible(muffled)
[09:29:47.149]                   }
[09:29:47.149]                   muffleCondition(cond)
[09:29:47.149]                 })
[09:29:47.149]             }))
[09:29:47.149]             future::FutureResult(value = ...future.value$value, 
[09:29:47.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.149]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.149]                     ...future.globalenv.names))
[09:29:47.149]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.149]         }, condition = base::local({
[09:29:47.149]             c <- base::c
[09:29:47.149]             inherits <- base::inherits
[09:29:47.149]             invokeRestart <- base::invokeRestart
[09:29:47.149]             length <- base::length
[09:29:47.149]             list <- base::list
[09:29:47.149]             seq.int <- base::seq.int
[09:29:47.149]             signalCondition <- base::signalCondition
[09:29:47.149]             sys.calls <- base::sys.calls
[09:29:47.149]             `[[` <- base::`[[`
[09:29:47.149]             `+` <- base::`+`
[09:29:47.149]             `<<-` <- base::`<<-`
[09:29:47.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.149]                   3L)]
[09:29:47.149]             }
[09:29:47.149]             function(cond) {
[09:29:47.149]                 is_error <- inherits(cond, "error")
[09:29:47.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.149]                   NULL)
[09:29:47.149]                 if (is_error) {
[09:29:47.149]                   sessionInformation <- function() {
[09:29:47.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.149]                       search = base::search(), system = base::Sys.info())
[09:29:47.149]                   }
[09:29:47.149]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.149]                     cond$call), session = sessionInformation(), 
[09:29:47.149]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.149]                   signalCondition(cond)
[09:29:47.149]                 }
[09:29:47.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.149]                 "immediateCondition"))) {
[09:29:47.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.149]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.149]                   if (TRUE && !signal) {
[09:29:47.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.149]                     {
[09:29:47.149]                       inherits <- base::inherits
[09:29:47.149]                       invokeRestart <- base::invokeRestart
[09:29:47.149]                       is.null <- base::is.null
[09:29:47.149]                       muffled <- FALSE
[09:29:47.149]                       if (inherits(cond, "message")) {
[09:29:47.149]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.149]                         if (muffled) 
[09:29:47.149]                           invokeRestart("muffleMessage")
[09:29:47.149]                       }
[09:29:47.149]                       else if (inherits(cond, "warning")) {
[09:29:47.149]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.149]                         if (muffled) 
[09:29:47.149]                           invokeRestart("muffleWarning")
[09:29:47.149]                       }
[09:29:47.149]                       else if (inherits(cond, "condition")) {
[09:29:47.149]                         if (!is.null(pattern)) {
[09:29:47.149]                           computeRestarts <- base::computeRestarts
[09:29:47.149]                           grepl <- base::grepl
[09:29:47.149]                           restarts <- computeRestarts(cond)
[09:29:47.149]                           for (restart in restarts) {
[09:29:47.149]                             name <- restart$name
[09:29:47.149]                             if (is.null(name)) 
[09:29:47.149]                               next
[09:29:47.149]                             if (!grepl(pattern, name)) 
[09:29:47.149]                               next
[09:29:47.149]                             invokeRestart(restart)
[09:29:47.149]                             muffled <- TRUE
[09:29:47.149]                             break
[09:29:47.149]                           }
[09:29:47.149]                         }
[09:29:47.149]                       }
[09:29:47.149]                       invisible(muffled)
[09:29:47.149]                     }
[09:29:47.149]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.149]                   }
[09:29:47.149]                 }
[09:29:47.149]                 else {
[09:29:47.149]                   if (TRUE) {
[09:29:47.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.149]                     {
[09:29:47.149]                       inherits <- base::inherits
[09:29:47.149]                       invokeRestart <- base::invokeRestart
[09:29:47.149]                       is.null <- base::is.null
[09:29:47.149]                       muffled <- FALSE
[09:29:47.149]                       if (inherits(cond, "message")) {
[09:29:47.149]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.149]                         if (muffled) 
[09:29:47.149]                           invokeRestart("muffleMessage")
[09:29:47.149]                       }
[09:29:47.149]                       else if (inherits(cond, "warning")) {
[09:29:47.149]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.149]                         if (muffled) 
[09:29:47.149]                           invokeRestart("muffleWarning")
[09:29:47.149]                       }
[09:29:47.149]                       else if (inherits(cond, "condition")) {
[09:29:47.149]                         if (!is.null(pattern)) {
[09:29:47.149]                           computeRestarts <- base::computeRestarts
[09:29:47.149]                           grepl <- base::grepl
[09:29:47.149]                           restarts <- computeRestarts(cond)
[09:29:47.149]                           for (restart in restarts) {
[09:29:47.149]                             name <- restart$name
[09:29:47.149]                             if (is.null(name)) 
[09:29:47.149]                               next
[09:29:47.149]                             if (!grepl(pattern, name)) 
[09:29:47.149]                               next
[09:29:47.149]                             invokeRestart(restart)
[09:29:47.149]                             muffled <- TRUE
[09:29:47.149]                             break
[09:29:47.149]                           }
[09:29:47.149]                         }
[09:29:47.149]                       }
[09:29:47.149]                       invisible(muffled)
[09:29:47.149]                     }
[09:29:47.149]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.149]                   }
[09:29:47.149]                 }
[09:29:47.149]             }
[09:29:47.149]         }))
[09:29:47.149]     }, error = function(ex) {
[09:29:47.149]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.149]                 ...future.rng), started = ...future.startTime, 
[09:29:47.149]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.149]             version = "1.8"), class = "FutureResult")
[09:29:47.149]     }, finally = {
[09:29:47.149]         if (!identical(...future.workdir, getwd())) 
[09:29:47.149]             setwd(...future.workdir)
[09:29:47.149]         {
[09:29:47.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.149]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.149]             }
[09:29:47.149]             base::options(...future.oldOptions)
[09:29:47.149]             if (.Platform$OS.type == "windows") {
[09:29:47.149]                 old_names <- names(...future.oldEnvVars)
[09:29:47.149]                 envs <- base::Sys.getenv()
[09:29:47.149]                 names <- names(envs)
[09:29:47.149]                 common <- intersect(names, old_names)
[09:29:47.149]                 added <- setdiff(names, old_names)
[09:29:47.149]                 removed <- setdiff(old_names, names)
[09:29:47.149]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.149]                   envs[common]]
[09:29:47.149]                 NAMES <- toupper(changed)
[09:29:47.149]                 args <- list()
[09:29:47.149]                 for (kk in seq_along(NAMES)) {
[09:29:47.149]                   name <- changed[[kk]]
[09:29:47.149]                   NAME <- NAMES[[kk]]
[09:29:47.149]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.149]                     next
[09:29:47.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.149]                 }
[09:29:47.149]                 NAMES <- toupper(added)
[09:29:47.149]                 for (kk in seq_along(NAMES)) {
[09:29:47.149]                   name <- added[[kk]]
[09:29:47.149]                   NAME <- NAMES[[kk]]
[09:29:47.149]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.149]                     next
[09:29:47.149]                   args[[name]] <- ""
[09:29:47.149]                 }
[09:29:47.149]                 NAMES <- toupper(removed)
[09:29:47.149]                 for (kk in seq_along(NAMES)) {
[09:29:47.149]                   name <- removed[[kk]]
[09:29:47.149]                   NAME <- NAMES[[kk]]
[09:29:47.149]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.149]                     next
[09:29:47.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.149]                 }
[09:29:47.149]                 if (length(args) > 0) 
[09:29:47.149]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.149]             }
[09:29:47.149]             else {
[09:29:47.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.149]             }
[09:29:47.149]             {
[09:29:47.149]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.149]                   0L) {
[09:29:47.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.149]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.149]                   base::options(opts)
[09:29:47.149]                 }
[09:29:47.149]                 {
[09:29:47.149]                   {
[09:29:47.149]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.149]                     NULL
[09:29:47.149]                   }
[09:29:47.149]                   options(future.plan = NULL)
[09:29:47.149]                   if (is.na(NA_character_)) 
[09:29:47.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.149]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.149]                     .init = FALSE)
[09:29:47.149]                 }
[09:29:47.149]             }
[09:29:47.149]         }
[09:29:47.149]     })
[09:29:47.149]     if (TRUE) {
[09:29:47.149]         base::sink(type = "output", split = FALSE)
[09:29:47.149]         if (TRUE) {
[09:29:47.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.149]         }
[09:29:47.149]         else {
[09:29:47.149]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.149]         }
[09:29:47.149]         base::close(...future.stdout)
[09:29:47.149]         ...future.stdout <- NULL
[09:29:47.149]     }
[09:29:47.149]     ...future.result$conditions <- ...future.conditions
[09:29:47.149]     ...future.result$finished <- base::Sys.time()
[09:29:47.149]     ...future.result
[09:29:47.149] }
[09:29:47.152] assign_globals() ...
[09:29:47.152] List of 11
[09:29:47.152]  $ ...future.FUN            :function (x, ...)  
[09:29:47.152]  $ x_FUN                    :function (x)  
[09:29:47.152]  $ times                    : int 4
[09:29:47.152]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.152]  $ stop_if_not              :function (...)  
[09:29:47.152]  $ dim                      : int [1:2] 2 2
[09:29:47.152]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:47.152]  $ future.call.arguments    : list()
[09:29:47.152]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.152]  $ ...future.elements_ii    :List of 5
[09:29:47.152]   ..$ : int 6
[09:29:47.152]   ..$ : int 7
[09:29:47.152]   ..$ : int 8
[09:29:47.152]   ..$ : int 9
[09:29:47.152]   ..$ : int 10
[09:29:47.152]  $ ...future.seeds_ii       : NULL
[09:29:47.152]  $ ...future.globals.maxSize: NULL
[09:29:47.152]  - attr(*, "where")=List of 11
[09:29:47.152]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.152]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:47.152]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:47.152]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:47.152]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:47.152]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:47.152]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:47.152]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.152]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.152]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.152]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.152]  - attr(*, "resolved")= logi FALSE
[09:29:47.152]  - attr(*, "total_size")= num 97304
[09:29:47.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.152]  - attr(*, "already-done")= logi TRUE
[09:29:47.165] - copied ‘...future.FUN’ to environment
[09:29:47.165] - reassign environment for ‘x_FUN’
[09:29:47.165] - copied ‘x_FUN’ to environment
[09:29:47.165] - copied ‘times’ to environment
[09:29:47.165] - copied ‘stopf’ to environment
[09:29:47.165] - copied ‘stop_if_not’ to environment
[09:29:47.165] - copied ‘dim’ to environment
[09:29:47.165] - copied ‘valid_types’ to environment
[09:29:47.165] - copied ‘future.call.arguments’ to environment
[09:29:47.166] - copied ‘...future.elements_ii’ to environment
[09:29:47.166] - copied ‘...future.seeds_ii’ to environment
[09:29:47.166] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.166] assign_globals() ... done
[09:29:47.166] requestCore(): workers = 2
[09:29:47.168] MulticoreFuture started
[09:29:47.169] - Launch lazy future ... done
[09:29:47.169] run() for ‘MulticoreFuture’ ... done
[09:29:47.169] Created future:
[09:29:47.170] plan(): Setting new future strategy stack:
[09:29:47.170] List of future strategies:
[09:29:47.170] 1. sequential:
[09:29:47.170]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.170]    - tweaked: FALSE
[09:29:47.170]    - call: NULL
[09:29:47.171] plan(): nbrOfWorkers() = 1
[09:29:47.173] plan(): Setting new future strategy stack:
[09:29:47.173] List of future strategies:
[09:29:47.173] 1. multicore:
[09:29:47.173]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.173]    - tweaked: FALSE
[09:29:47.173]    - call: plan(strategy)
[09:29:47.178] plan(): nbrOfWorkers() = 2
[09:29:47.169] MulticoreFuture:
[09:29:47.169] Label: ‘future_vapply-2’
[09:29:47.169] Expression:
[09:29:47.169] {
[09:29:47.169]     do.call(function(...) {
[09:29:47.169]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.169]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.169]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.169]             on.exit(options(oopts), add = TRUE)
[09:29:47.169]         }
[09:29:47.169]         {
[09:29:47.169]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.169]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.169]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.169]             })
[09:29:47.169]         }
[09:29:47.169]     }, args = future.call.arguments)
[09:29:47.169] }
[09:29:47.169] Lazy evaluation: FALSE
[09:29:47.169] Asynchronous evaluation: TRUE
[09:29:47.169] Local evaluation: TRUE
[09:29:47.169] Environment: R_GlobalEnv
[09:29:47.169] Capture standard output: TRUE
[09:29:47.169] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.169] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:47.169] Packages: 1 packages (‘future.apply’)
[09:29:47.169] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.169] Resolved: TRUE
[09:29:47.169] Value: <not collected>
[09:29:47.169] Conditions captured: <none>
[09:29:47.169] Early signaling: FALSE
[09:29:47.169] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.169] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.179] Chunk #2 of 2 ... DONE
[09:29:47.179] Launching 2 futures (chunks) ... DONE
[09:29:47.180] Resolving 2 futures (chunks) ...
[09:29:47.180] resolve() on list ...
[09:29:47.180]  recursive: 0
[09:29:47.180]  length: 2
[09:29:47.180] 
[09:29:47.180] Future #1
[09:29:47.181] result() for MulticoreFuture ...
[09:29:47.181] result() for MulticoreFuture ...
[09:29:47.182] result() for MulticoreFuture ... done
[09:29:47.182] result() for MulticoreFuture ... done
[09:29:47.182] result() for MulticoreFuture ...
[09:29:47.182] result() for MulticoreFuture ... done
[09:29:47.182] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:47.182] - nx: 2
[09:29:47.182] - relay: TRUE
[09:29:47.183] - stdout: TRUE
[09:29:47.183] - signal: TRUE
[09:29:47.183] - resignal: FALSE
[09:29:47.183] - force: TRUE
[09:29:47.183] - relayed: [n=2] FALSE, FALSE
[09:29:47.183] - queued futures: [n=2] FALSE, FALSE
[09:29:47.183]  - until=1
[09:29:47.183]  - relaying element #1
[09:29:47.184] result() for MulticoreFuture ...
[09:29:47.184] result() for MulticoreFuture ... done
[09:29:47.184] result() for MulticoreFuture ...
[09:29:47.184] result() for MulticoreFuture ... done
[09:29:47.184] result() for MulticoreFuture ...
[09:29:47.184] result() for MulticoreFuture ... done
[09:29:47.184] result() for MulticoreFuture ...
[09:29:47.185] result() for MulticoreFuture ... done
[09:29:47.185] - relayed: [n=2] TRUE, FALSE
[09:29:47.185] - queued futures: [n=2] TRUE, FALSE
[09:29:47.185] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:47.185]  length: 1 (resolved future 1)
[09:29:47.185] Future #2
[09:29:47.186] result() for MulticoreFuture ...
[09:29:47.186] result() for MulticoreFuture ...
[09:29:47.186] result() for MulticoreFuture ... done
[09:29:47.187] result() for MulticoreFuture ... done
[09:29:47.187] result() for MulticoreFuture ...
[09:29:47.192] result() for MulticoreFuture ... done
[09:29:47.193] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:47.193] - nx: 2
[09:29:47.193] - relay: TRUE
[09:29:47.193] - stdout: TRUE
[09:29:47.193] - signal: TRUE
[09:29:47.193] - resignal: FALSE
[09:29:47.193] - force: TRUE
[09:29:47.193] - relayed: [n=2] TRUE, FALSE
[09:29:47.193] - queued futures: [n=2] TRUE, FALSE
[09:29:47.193]  - until=2
[09:29:47.193]  - relaying element #2
[09:29:47.193] result() for MulticoreFuture ...
[09:29:47.194] result() for MulticoreFuture ... done
[09:29:47.194] result() for MulticoreFuture ...
[09:29:47.194] result() for MulticoreFuture ... done
[09:29:47.194] result() for MulticoreFuture ...
[09:29:47.194] result() for MulticoreFuture ... done
[09:29:47.194] result() for MulticoreFuture ...
[09:29:47.194] result() for MulticoreFuture ... done
[09:29:47.194] - relayed: [n=2] TRUE, TRUE
[09:29:47.195] - queued futures: [n=2] TRUE, TRUE
[09:29:47.195] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:47.195]  length: 0 (resolved future 2)
[09:29:47.195] Relaying remaining futures
[09:29:47.195] signalConditionsASAP(NULL, pos=0) ...
[09:29:47.195] - nx: 2
[09:29:47.195] - relay: TRUE
[09:29:47.196] - stdout: TRUE
[09:29:47.196] - signal: TRUE
[09:29:47.196] - resignal: FALSE
[09:29:47.196] - force: TRUE
[09:29:47.196] - relayed: [n=2] TRUE, TRUE
[09:29:47.196] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:47.196] - relayed: [n=2] TRUE, TRUE
[09:29:47.197] - queued futures: [n=2] TRUE, TRUE
[09:29:47.197] signalConditionsASAP(NULL, pos=0) ... done
[09:29:47.197] resolve() on list ... DONE
[09:29:47.197] result() for MulticoreFuture ...
[09:29:47.197] result() for MulticoreFuture ... done
[09:29:47.197] result() for MulticoreFuture ...
[09:29:47.197] result() for MulticoreFuture ... done
[09:29:47.197] result() for MulticoreFuture ...
[09:29:47.198] result() for MulticoreFuture ... done
[09:29:47.198] result() for MulticoreFuture ...
[09:29:47.198] result() for MulticoreFuture ... done
[09:29:47.198]  - Number of value chunks collected: 2
[09:29:47.198] Resolving 2 futures (chunks) ... DONE
[09:29:47.198] Reducing values from 2 chunks ...
[09:29:47.198]  - Number of values collected after concatenation: 10
[09:29:47.198]  - Number of values expected: 10
[09:29:47.199] Reducing values from 2 chunks ... DONE
[09:29:47.199] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[09:29:47.201] future_lapply() ...
[09:29:47.206] Number of chunks: 2
[09:29:47.206] getGlobalsAndPackagesXApply() ...
[09:29:47.207]  - future.globals: TRUE
[09:29:47.207] getGlobalsAndPackages() ...
[09:29:47.207] Searching for globals...
[09:29:47.211] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[09:29:47.211] Searching for globals ... DONE
[09:29:47.211] Resolving globals: FALSE
[09:29:47.212] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[09:29:47.212] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:47.212] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.212] - packages: [1] ‘future.apply’
[09:29:47.212] getGlobalsAndPackages() ... DONE
[09:29:47.213]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.213]  - needed namespaces: [n=1] ‘future.apply’
[09:29:47.213] Finding globals ... DONE
[09:29:47.213]  - use_args: TRUE
[09:29:47.213]  - Getting '...' globals ...
[09:29:47.213] resolve() on list ...
[09:29:47.213]  recursive: 0
[09:29:47.213]  length: 1
[09:29:47.214]  elements: ‘...’
[09:29:47.214]  length: 0 (resolved future 1)
[09:29:47.214] resolve() on list ... DONE
[09:29:47.214]    - '...' content: [n=0] 
[09:29:47.214] List of 1
[09:29:47.214]  $ ...: list()
[09:29:47.214]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.214]  - attr(*, "where")=List of 1
[09:29:47.214]   ..$ ...:<environment: 0x561d34718b78> 
[09:29:47.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.214]  - attr(*, "resolved")= logi TRUE
[09:29:47.214]  - attr(*, "total_size")= num NA
[09:29:47.218]  - Getting '...' globals ... DONE
[09:29:47.218] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:47.218] List of 8
[09:29:47.218]  $ ...future.FUN:function (x, ...)  
[09:29:47.218]  $ x_FUN        :function (x)  
[09:29:47.218]  $ times        : int 4
[09:29:47.218]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.218]  $ stop_if_not  :function (...)  
[09:29:47.218]  $ dim          : int [1:2] 2 2
[09:29:47.218]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:47.218]  $ ...          : list()
[09:29:47.218]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.218]  - attr(*, "where")=List of 8
[09:29:47.218]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:47.218]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:47.218]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:47.218]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:47.218]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:47.218]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:47.218]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:47.218]   ..$ ...          :<environment: 0x561d34718b78> 
[09:29:47.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.218]  - attr(*, "resolved")= logi FALSE
[09:29:47.218]  - attr(*, "total_size")= num 105552
[09:29:47.223] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:47.224] getGlobalsAndPackagesXApply() ... DONE
[09:29:47.224] Number of futures (= number of chunks): 2
[09:29:47.224] Launching 2 futures (chunks) ...
[09:29:47.224] Chunk #1 of 2 ...
[09:29:47.224]  - Finding globals in 'X' for chunk #1 ...
[09:29:47.224] getGlobalsAndPackages() ...
[09:29:47.224] Searching for globals...
[09:29:47.225] 
[09:29:47.225] Searching for globals ... DONE
[09:29:47.225] - globals: [0] <none>
[09:29:47.225] getGlobalsAndPackages() ... DONE
[09:29:47.225]    + additional globals found: [n=0] 
[09:29:47.225]    + additional namespaces needed: [n=0] 
[09:29:47.225]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:47.225]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.225]  - seeds: <none>
[09:29:47.225]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.226] getGlobalsAndPackages() ...
[09:29:47.226] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.226] Resolving globals: FALSE
[09:29:47.226] Tweak future expression to call with '...' arguments ...
[09:29:47.226] {
[09:29:47.226]     do.call(function(...) {
[09:29:47.226]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.226]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.226]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.226]             on.exit(options(oopts), add = TRUE)
[09:29:47.226]         }
[09:29:47.226]         {
[09:29:47.226]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.226]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.226]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.226]             })
[09:29:47.226]         }
[09:29:47.226]     }, args = future.call.arguments)
[09:29:47.226] }
[09:29:47.226] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.227] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.227] - packages: [1] ‘future.apply’
[09:29:47.227] getGlobalsAndPackages() ... DONE
[09:29:47.227] run() for ‘Future’ ...
[09:29:47.227] - state: ‘created’
[09:29:47.227] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.231] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.231] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.231]   - Field: ‘label’
[09:29:47.231]   - Field: ‘local’
[09:29:47.231]   - Field: ‘owner’
[09:29:47.231]   - Field: ‘envir’
[09:29:47.231]   - Field: ‘workers’
[09:29:47.231]   - Field: ‘packages’
[09:29:47.232]   - Field: ‘gc’
[09:29:47.232]   - Field: ‘job’
[09:29:47.232]   - Field: ‘conditions’
[09:29:47.232]   - Field: ‘expr’
[09:29:47.232]   - Field: ‘uuid’
[09:29:47.232]   - Field: ‘seed’
[09:29:47.232]   - Field: ‘version’
[09:29:47.232]   - Field: ‘result’
[09:29:47.232]   - Field: ‘asynchronous’
[09:29:47.232]   - Field: ‘calls’
[09:29:47.232]   - Field: ‘globals’
[09:29:47.233]   - Field: ‘stdout’
[09:29:47.233]   - Field: ‘earlySignal’
[09:29:47.233]   - Field: ‘lazy’
[09:29:47.233]   - Field: ‘state’
[09:29:47.233] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.233] - Launch lazy future ...
[09:29:47.233] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:47.233] Packages needed by future strategies (n = 0): <none>
[09:29:47.234] {
[09:29:47.234]     {
[09:29:47.234]         {
[09:29:47.234]             ...future.startTime <- base::Sys.time()
[09:29:47.234]             {
[09:29:47.234]                 {
[09:29:47.234]                   {
[09:29:47.234]                     {
[09:29:47.234]                       {
[09:29:47.234]                         base::local({
[09:29:47.234]                           has_future <- base::requireNamespace("future", 
[09:29:47.234]                             quietly = TRUE)
[09:29:47.234]                           if (has_future) {
[09:29:47.234]                             ns <- base::getNamespace("future")
[09:29:47.234]                             version <- ns[[".package"]][["version"]]
[09:29:47.234]                             if (is.null(version)) 
[09:29:47.234]                               version <- utils::packageVersion("future")
[09:29:47.234]                           }
[09:29:47.234]                           else {
[09:29:47.234]                             version <- NULL
[09:29:47.234]                           }
[09:29:47.234]                           if (!has_future || version < "1.8.0") {
[09:29:47.234]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.234]                               "", base::R.version$version.string), 
[09:29:47.234]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.234]                                 base::R.version$platform, 8 * 
[09:29:47.234]                                   base::.Machine$sizeof.pointer), 
[09:29:47.234]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.234]                                 "release", "version")], collapse = " "), 
[09:29:47.234]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.234]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.234]                               info)
[09:29:47.234]                             info <- base::paste(info, collapse = "; ")
[09:29:47.234]                             if (!has_future) {
[09:29:47.234]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.234]                                 info)
[09:29:47.234]                             }
[09:29:47.234]                             else {
[09:29:47.234]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.234]                                 info, version)
[09:29:47.234]                             }
[09:29:47.234]                             base::stop(msg)
[09:29:47.234]                           }
[09:29:47.234]                         })
[09:29:47.234]                       }
[09:29:47.234]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.234]                       base::options(mc.cores = 1L)
[09:29:47.234]                     }
[09:29:47.234]                     base::local({
[09:29:47.234]                       for (pkg in "future.apply") {
[09:29:47.234]                         base::loadNamespace(pkg)
[09:29:47.234]                         base::library(pkg, character.only = TRUE)
[09:29:47.234]                       }
[09:29:47.234]                     })
[09:29:47.234]                   }
[09:29:47.234]                   ...future.strategy.old <- future::plan("list")
[09:29:47.234]                   options(future.plan = NULL)
[09:29:47.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.234]                 }
[09:29:47.234]                 ...future.workdir <- getwd()
[09:29:47.234]             }
[09:29:47.234]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.234]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.234]         }
[09:29:47.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.234]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.234]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.234]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.234]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.234]             base::names(...future.oldOptions))
[09:29:47.234]     }
[09:29:47.234]     if (FALSE) {
[09:29:47.234]     }
[09:29:47.234]     else {
[09:29:47.234]         if (TRUE) {
[09:29:47.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.234]                 open = "w")
[09:29:47.234]         }
[09:29:47.234]         else {
[09:29:47.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.234]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.234]         }
[09:29:47.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.234]             base::sink(type = "output", split = FALSE)
[09:29:47.234]             base::close(...future.stdout)
[09:29:47.234]         }, add = TRUE)
[09:29:47.234]     }
[09:29:47.234]     ...future.frame <- base::sys.nframe()
[09:29:47.234]     ...future.conditions <- base::list()
[09:29:47.234]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.234]     if (FALSE) {
[09:29:47.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.234]     }
[09:29:47.234]     ...future.result <- base::tryCatch({
[09:29:47.234]         base::withCallingHandlers({
[09:29:47.234]             ...future.value <- base::withVisible(base::local({
[09:29:47.234]                 withCallingHandlers({
[09:29:47.234]                   {
[09:29:47.234]                     do.call(function(...) {
[09:29:47.234]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.234]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.234]                         ...future.globals.maxSize)) {
[09:29:47.234]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.234]                         on.exit(options(oopts), add = TRUE)
[09:29:47.234]                       }
[09:29:47.234]                       {
[09:29:47.234]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.234]                           FUN = function(jj) {
[09:29:47.234]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.234]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.234]                           })
[09:29:47.234]                       }
[09:29:47.234]                     }, args = future.call.arguments)
[09:29:47.234]                   }
[09:29:47.234]                 }, immediateCondition = function(cond) {
[09:29:47.234]                   save_rds <- function (object, pathname, ...) 
[09:29:47.234]                   {
[09:29:47.234]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.234]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.234]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.234]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.234]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.234]                         fi_tmp[["mtime"]])
[09:29:47.234]                     }
[09:29:47.234]                     tryCatch({
[09:29:47.234]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.234]                     }, error = function(ex) {
[09:29:47.234]                       msg <- conditionMessage(ex)
[09:29:47.234]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.234]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.234]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.234]                         fi_tmp[["mtime"]], msg)
[09:29:47.234]                       ex$message <- msg
[09:29:47.234]                       stop(ex)
[09:29:47.234]                     })
[09:29:47.234]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.234]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.234]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.234]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.234]                       fi <- file.info(pathname)
[09:29:47.234]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.234]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.234]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.234]                         fi[["size"]], fi[["mtime"]])
[09:29:47.234]                       stop(msg)
[09:29:47.234]                     }
[09:29:47.234]                     invisible(pathname)
[09:29:47.234]                   }
[09:29:47.234]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.234]                     rootPath = tempdir()) 
[09:29:47.234]                   {
[09:29:47.234]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.234]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.234]                       tmpdir = path, fileext = ".rds")
[09:29:47.234]                     save_rds(obj, file)
[09:29:47.234]                   }
[09:29:47.234]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.234]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.234]                   {
[09:29:47.234]                     inherits <- base::inherits
[09:29:47.234]                     invokeRestart <- base::invokeRestart
[09:29:47.234]                     is.null <- base::is.null
[09:29:47.234]                     muffled <- FALSE
[09:29:47.234]                     if (inherits(cond, "message")) {
[09:29:47.234]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.234]                       if (muffled) 
[09:29:47.234]                         invokeRestart("muffleMessage")
[09:29:47.234]                     }
[09:29:47.234]                     else if (inherits(cond, "warning")) {
[09:29:47.234]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.234]                       if (muffled) 
[09:29:47.234]                         invokeRestart("muffleWarning")
[09:29:47.234]                     }
[09:29:47.234]                     else if (inherits(cond, "condition")) {
[09:29:47.234]                       if (!is.null(pattern)) {
[09:29:47.234]                         computeRestarts <- base::computeRestarts
[09:29:47.234]                         grepl <- base::grepl
[09:29:47.234]                         restarts <- computeRestarts(cond)
[09:29:47.234]                         for (restart in restarts) {
[09:29:47.234]                           name <- restart$name
[09:29:47.234]                           if (is.null(name)) 
[09:29:47.234]                             next
[09:29:47.234]                           if (!grepl(pattern, name)) 
[09:29:47.234]                             next
[09:29:47.234]                           invokeRestart(restart)
[09:29:47.234]                           muffled <- TRUE
[09:29:47.234]                           break
[09:29:47.234]                         }
[09:29:47.234]                       }
[09:29:47.234]                     }
[09:29:47.234]                     invisible(muffled)
[09:29:47.234]                   }
[09:29:47.234]                   muffleCondition(cond)
[09:29:47.234]                 })
[09:29:47.234]             }))
[09:29:47.234]             future::FutureResult(value = ...future.value$value, 
[09:29:47.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.234]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.234]                     ...future.globalenv.names))
[09:29:47.234]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.234]         }, condition = base::local({
[09:29:47.234]             c <- base::c
[09:29:47.234]             inherits <- base::inherits
[09:29:47.234]             invokeRestart <- base::invokeRestart
[09:29:47.234]             length <- base::length
[09:29:47.234]             list <- base::list
[09:29:47.234]             seq.int <- base::seq.int
[09:29:47.234]             signalCondition <- base::signalCondition
[09:29:47.234]             sys.calls <- base::sys.calls
[09:29:47.234]             `[[` <- base::`[[`
[09:29:47.234]             `+` <- base::`+`
[09:29:47.234]             `<<-` <- base::`<<-`
[09:29:47.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.234]                   3L)]
[09:29:47.234]             }
[09:29:47.234]             function(cond) {
[09:29:47.234]                 is_error <- inherits(cond, "error")
[09:29:47.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.234]                   NULL)
[09:29:47.234]                 if (is_error) {
[09:29:47.234]                   sessionInformation <- function() {
[09:29:47.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.234]                       search = base::search(), system = base::Sys.info())
[09:29:47.234]                   }
[09:29:47.234]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.234]                     cond$call), session = sessionInformation(), 
[09:29:47.234]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.234]                   signalCondition(cond)
[09:29:47.234]                 }
[09:29:47.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.234]                 "immediateCondition"))) {
[09:29:47.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.234]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.234]                   if (TRUE && !signal) {
[09:29:47.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.234]                     {
[09:29:47.234]                       inherits <- base::inherits
[09:29:47.234]                       invokeRestart <- base::invokeRestart
[09:29:47.234]                       is.null <- base::is.null
[09:29:47.234]                       muffled <- FALSE
[09:29:47.234]                       if (inherits(cond, "message")) {
[09:29:47.234]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.234]                         if (muffled) 
[09:29:47.234]                           invokeRestart("muffleMessage")
[09:29:47.234]                       }
[09:29:47.234]                       else if (inherits(cond, "warning")) {
[09:29:47.234]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.234]                         if (muffled) 
[09:29:47.234]                           invokeRestart("muffleWarning")
[09:29:47.234]                       }
[09:29:47.234]                       else if (inherits(cond, "condition")) {
[09:29:47.234]                         if (!is.null(pattern)) {
[09:29:47.234]                           computeRestarts <- base::computeRestarts
[09:29:47.234]                           grepl <- base::grepl
[09:29:47.234]                           restarts <- computeRestarts(cond)
[09:29:47.234]                           for (restart in restarts) {
[09:29:47.234]                             name <- restart$name
[09:29:47.234]                             if (is.null(name)) 
[09:29:47.234]                               next
[09:29:47.234]                             if (!grepl(pattern, name)) 
[09:29:47.234]                               next
[09:29:47.234]                             invokeRestart(restart)
[09:29:47.234]                             muffled <- TRUE
[09:29:47.234]                             break
[09:29:47.234]                           }
[09:29:47.234]                         }
[09:29:47.234]                       }
[09:29:47.234]                       invisible(muffled)
[09:29:47.234]                     }
[09:29:47.234]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.234]                   }
[09:29:47.234]                 }
[09:29:47.234]                 else {
[09:29:47.234]                   if (TRUE) {
[09:29:47.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.234]                     {
[09:29:47.234]                       inherits <- base::inherits
[09:29:47.234]                       invokeRestart <- base::invokeRestart
[09:29:47.234]                       is.null <- base::is.null
[09:29:47.234]                       muffled <- FALSE
[09:29:47.234]                       if (inherits(cond, "message")) {
[09:29:47.234]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.234]                         if (muffled) 
[09:29:47.234]                           invokeRestart("muffleMessage")
[09:29:47.234]                       }
[09:29:47.234]                       else if (inherits(cond, "warning")) {
[09:29:47.234]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.234]                         if (muffled) 
[09:29:47.234]                           invokeRestart("muffleWarning")
[09:29:47.234]                       }
[09:29:47.234]                       else if (inherits(cond, "condition")) {
[09:29:47.234]                         if (!is.null(pattern)) {
[09:29:47.234]                           computeRestarts <- base::computeRestarts
[09:29:47.234]                           grepl <- base::grepl
[09:29:47.234]                           restarts <- computeRestarts(cond)
[09:29:47.234]                           for (restart in restarts) {
[09:29:47.234]                             name <- restart$name
[09:29:47.234]                             if (is.null(name)) 
[09:29:47.234]                               next
[09:29:47.234]                             if (!grepl(pattern, name)) 
[09:29:47.234]                               next
[09:29:47.234]                             invokeRestart(restart)
[09:29:47.234]                             muffled <- TRUE
[09:29:47.234]                             break
[09:29:47.234]                           }
[09:29:47.234]                         }
[09:29:47.234]                       }
[09:29:47.234]                       invisible(muffled)
[09:29:47.234]                     }
[09:29:47.234]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.234]                   }
[09:29:47.234]                 }
[09:29:47.234]             }
[09:29:47.234]         }))
[09:29:47.234]     }, error = function(ex) {
[09:29:47.234]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.234]                 ...future.rng), started = ...future.startTime, 
[09:29:47.234]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.234]             version = "1.8"), class = "FutureResult")
[09:29:47.234]     }, finally = {
[09:29:47.234]         if (!identical(...future.workdir, getwd())) 
[09:29:47.234]             setwd(...future.workdir)
[09:29:47.234]         {
[09:29:47.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.234]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.234]             }
[09:29:47.234]             base::options(...future.oldOptions)
[09:29:47.234]             if (.Platform$OS.type == "windows") {
[09:29:47.234]                 old_names <- names(...future.oldEnvVars)
[09:29:47.234]                 envs <- base::Sys.getenv()
[09:29:47.234]                 names <- names(envs)
[09:29:47.234]                 common <- intersect(names, old_names)
[09:29:47.234]                 added <- setdiff(names, old_names)
[09:29:47.234]                 removed <- setdiff(old_names, names)
[09:29:47.234]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.234]                   envs[common]]
[09:29:47.234]                 NAMES <- toupper(changed)
[09:29:47.234]                 args <- list()
[09:29:47.234]                 for (kk in seq_along(NAMES)) {
[09:29:47.234]                   name <- changed[[kk]]
[09:29:47.234]                   NAME <- NAMES[[kk]]
[09:29:47.234]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.234]                     next
[09:29:47.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.234]                 }
[09:29:47.234]                 NAMES <- toupper(added)
[09:29:47.234]                 for (kk in seq_along(NAMES)) {
[09:29:47.234]                   name <- added[[kk]]
[09:29:47.234]                   NAME <- NAMES[[kk]]
[09:29:47.234]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.234]                     next
[09:29:47.234]                   args[[name]] <- ""
[09:29:47.234]                 }
[09:29:47.234]                 NAMES <- toupper(removed)
[09:29:47.234]                 for (kk in seq_along(NAMES)) {
[09:29:47.234]                   name <- removed[[kk]]
[09:29:47.234]                   NAME <- NAMES[[kk]]
[09:29:47.234]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.234]                     next
[09:29:47.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.234]                 }
[09:29:47.234]                 if (length(args) > 0) 
[09:29:47.234]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.234]             }
[09:29:47.234]             else {
[09:29:47.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.234]             }
[09:29:47.234]             {
[09:29:47.234]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.234]                   0L) {
[09:29:47.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.234]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.234]                   base::options(opts)
[09:29:47.234]                 }
[09:29:47.234]                 {
[09:29:47.234]                   {
[09:29:47.234]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.234]                     NULL
[09:29:47.234]                   }
[09:29:47.234]                   options(future.plan = NULL)
[09:29:47.234]                   if (is.na(NA_character_)) 
[09:29:47.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.234]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.234]                     .init = FALSE)
[09:29:47.234]                 }
[09:29:47.234]             }
[09:29:47.234]         }
[09:29:47.234]     })
[09:29:47.234]     if (TRUE) {
[09:29:47.234]         base::sink(type = "output", split = FALSE)
[09:29:47.234]         if (TRUE) {
[09:29:47.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.234]         }
[09:29:47.234]         else {
[09:29:47.234]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.234]         }
[09:29:47.234]         base::close(...future.stdout)
[09:29:47.234]         ...future.stdout <- NULL
[09:29:47.234]     }
[09:29:47.234]     ...future.result$conditions <- ...future.conditions
[09:29:47.234]     ...future.result$finished <- base::Sys.time()
[09:29:47.234]     ...future.result
[09:29:47.234] }
[09:29:47.236] assign_globals() ...
[09:29:47.236] List of 11
[09:29:47.236]  $ ...future.FUN            :function (x, ...)  
[09:29:47.236]  $ x_FUN                    :function (x)  
[09:29:47.236]  $ times                    : int 4
[09:29:47.236]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.236]  $ stop_if_not              :function (...)  
[09:29:47.236]  $ dim                      : int [1:2] 2 2
[09:29:47.236]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:47.236]  $ future.call.arguments    : list()
[09:29:47.236]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.236]  $ ...future.elements_ii    :List of 5
[09:29:47.236]   ..$ : int 1
[09:29:47.236]   ..$ : int 2
[09:29:47.236]   ..$ : int 3
[09:29:47.236]   ..$ : int 4
[09:29:47.236]   ..$ : int 5
[09:29:47.236]  $ ...future.seeds_ii       : NULL
[09:29:47.236]  $ ...future.globals.maxSize: NULL
[09:29:47.236]  - attr(*, "where")=List of 11
[09:29:47.236]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.236]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:47.236]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:47.236]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:47.236]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:47.236]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:47.236]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:47.236]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.236]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.236]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.236]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.236]  - attr(*, "resolved")= logi FALSE
[09:29:47.236]  - attr(*, "total_size")= num 105552
[09:29:47.236]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.236]  - attr(*, "already-done")= logi TRUE
[09:29:47.246] - copied ‘...future.FUN’ to environment
[09:29:47.246] - reassign environment for ‘x_FUN’
[09:29:47.246] - copied ‘x_FUN’ to environment
[09:29:47.246] - copied ‘times’ to environment
[09:29:47.246] - copied ‘stopf’ to environment
[09:29:47.246] - copied ‘stop_if_not’ to environment
[09:29:47.246] - copied ‘dim’ to environment
[09:29:47.247] - copied ‘valid_types’ to environment
[09:29:47.247] - copied ‘future.call.arguments’ to environment
[09:29:47.247] - copied ‘...future.elements_ii’ to environment
[09:29:47.247] - copied ‘...future.seeds_ii’ to environment
[09:29:47.247] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.247] assign_globals() ... done
[09:29:47.247] requestCore(): workers = 2
[09:29:47.249] MulticoreFuture started
[09:29:47.250] - Launch lazy future ... done
[09:29:47.250] run() for ‘MulticoreFuture’ ... done
[09:29:47.250] Created future:
[09:29:47.251] plan(): Setting new future strategy stack:
[09:29:47.251] List of future strategies:
[09:29:47.251] 1. sequential:
[09:29:47.251]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.251]    - tweaked: FALSE
[09:29:47.251]    - call: NULL
[09:29:47.252] plan(): nbrOfWorkers() = 1
[09:29:47.255] plan(): Setting new future strategy stack:
[09:29:47.255] List of future strategies:
[09:29:47.255] 1. multicore:
[09:29:47.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.255]    - tweaked: FALSE
[09:29:47.255]    - call: plan(strategy)
[09:29:47.260] plan(): nbrOfWorkers() = 2
[09:29:47.251] MulticoreFuture:
[09:29:47.251] Label: ‘future_vapply-1’
[09:29:47.251] Expression:
[09:29:47.251] {
[09:29:47.251]     do.call(function(...) {
[09:29:47.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.251]             on.exit(options(oopts), add = TRUE)
[09:29:47.251]         }
[09:29:47.251]         {
[09:29:47.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.251]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.251]             })
[09:29:47.251]         }
[09:29:47.251]     }, args = future.call.arguments)
[09:29:47.251] }
[09:29:47.251] Lazy evaluation: FALSE
[09:29:47.251] Asynchronous evaluation: TRUE
[09:29:47.251] Local evaluation: TRUE
[09:29:47.251] Environment: R_GlobalEnv
[09:29:47.251] Capture standard output: TRUE
[09:29:47.251] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.251] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:47.251] Packages: 1 packages (‘future.apply’)
[09:29:47.251] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.251] Resolved: TRUE
[09:29:47.251] Value: <not collected>
[09:29:47.251] Conditions captured: <none>
[09:29:47.251] Early signaling: FALSE
[09:29:47.251] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.251] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.261] Chunk #1 of 2 ... DONE
[09:29:47.261] Chunk #2 of 2 ...
[09:29:47.262]  - Finding globals in 'X' for chunk #2 ...
[09:29:47.262] getGlobalsAndPackages() ...
[09:29:47.262] Searching for globals...
[09:29:47.262] 
[09:29:47.262] Searching for globals ... DONE
[09:29:47.263] - globals: [0] <none>
[09:29:47.263] getGlobalsAndPackages() ... DONE
[09:29:47.263]    + additional globals found: [n=0] 
[09:29:47.263]    + additional namespaces needed: [n=0] 
[09:29:47.263]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:47.263]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.263]  - seeds: <none>
[09:29:47.263]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.264] getGlobalsAndPackages() ...
[09:29:47.264] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.264] Resolving globals: FALSE
[09:29:47.264] Tweak future expression to call with '...' arguments ...
[09:29:47.264] {
[09:29:47.264]     do.call(function(...) {
[09:29:47.264]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.264]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.264]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.264]             on.exit(options(oopts), add = TRUE)
[09:29:47.264]         }
[09:29:47.264]         {
[09:29:47.264]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.264]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.264]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.264]             })
[09:29:47.264]         }
[09:29:47.264]     }, args = future.call.arguments)
[09:29:47.264] }
[09:29:47.265] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.266] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.266] - packages: [1] ‘future.apply’
[09:29:47.266] getGlobalsAndPackages() ... DONE
[09:29:47.267] run() for ‘Future’ ...
[09:29:47.267] - state: ‘created’
[09:29:47.267] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.271] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.271] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.272]   - Field: ‘label’
[09:29:47.272]   - Field: ‘local’
[09:29:47.272]   - Field: ‘owner’
[09:29:47.272]   - Field: ‘envir’
[09:29:47.272]   - Field: ‘workers’
[09:29:47.272]   - Field: ‘packages’
[09:29:47.272]   - Field: ‘gc’
[09:29:47.273]   - Field: ‘job’
[09:29:47.273]   - Field: ‘conditions’
[09:29:47.273]   - Field: ‘expr’
[09:29:47.273]   - Field: ‘uuid’
[09:29:47.273]   - Field: ‘seed’
[09:29:47.273]   - Field: ‘version’
[09:29:47.274]   - Field: ‘result’
[09:29:47.274]   - Field: ‘asynchronous’
[09:29:47.274]   - Field: ‘calls’
[09:29:47.274]   - Field: ‘globals’
[09:29:47.274]   - Field: ‘stdout’
[09:29:47.274]   - Field: ‘earlySignal’
[09:29:47.274]   - Field: ‘lazy’
[09:29:47.274]   - Field: ‘state’
[09:29:47.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.275] - Launch lazy future ...
[09:29:47.275] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:47.275] Packages needed by future strategies (n = 0): <none>
[09:29:47.276] {
[09:29:47.276]     {
[09:29:47.276]         {
[09:29:47.276]             ...future.startTime <- base::Sys.time()
[09:29:47.276]             {
[09:29:47.276]                 {
[09:29:47.276]                   {
[09:29:47.276]                     {
[09:29:47.276]                       {
[09:29:47.276]                         base::local({
[09:29:47.276]                           has_future <- base::requireNamespace("future", 
[09:29:47.276]                             quietly = TRUE)
[09:29:47.276]                           if (has_future) {
[09:29:47.276]                             ns <- base::getNamespace("future")
[09:29:47.276]                             version <- ns[[".package"]][["version"]]
[09:29:47.276]                             if (is.null(version)) 
[09:29:47.276]                               version <- utils::packageVersion("future")
[09:29:47.276]                           }
[09:29:47.276]                           else {
[09:29:47.276]                             version <- NULL
[09:29:47.276]                           }
[09:29:47.276]                           if (!has_future || version < "1.8.0") {
[09:29:47.276]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.276]                               "", base::R.version$version.string), 
[09:29:47.276]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.276]                                 base::R.version$platform, 8 * 
[09:29:47.276]                                   base::.Machine$sizeof.pointer), 
[09:29:47.276]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.276]                                 "release", "version")], collapse = " "), 
[09:29:47.276]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.276]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.276]                               info)
[09:29:47.276]                             info <- base::paste(info, collapse = "; ")
[09:29:47.276]                             if (!has_future) {
[09:29:47.276]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.276]                                 info)
[09:29:47.276]                             }
[09:29:47.276]                             else {
[09:29:47.276]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.276]                                 info, version)
[09:29:47.276]                             }
[09:29:47.276]                             base::stop(msg)
[09:29:47.276]                           }
[09:29:47.276]                         })
[09:29:47.276]                       }
[09:29:47.276]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.276]                       base::options(mc.cores = 1L)
[09:29:47.276]                     }
[09:29:47.276]                     base::local({
[09:29:47.276]                       for (pkg in "future.apply") {
[09:29:47.276]                         base::loadNamespace(pkg)
[09:29:47.276]                         base::library(pkg, character.only = TRUE)
[09:29:47.276]                       }
[09:29:47.276]                     })
[09:29:47.276]                   }
[09:29:47.276]                   ...future.strategy.old <- future::plan("list")
[09:29:47.276]                   options(future.plan = NULL)
[09:29:47.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.276]                 }
[09:29:47.276]                 ...future.workdir <- getwd()
[09:29:47.276]             }
[09:29:47.276]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.276]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.276]         }
[09:29:47.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.276]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.276]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.276]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.276]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.276]             base::names(...future.oldOptions))
[09:29:47.276]     }
[09:29:47.276]     if (FALSE) {
[09:29:47.276]     }
[09:29:47.276]     else {
[09:29:47.276]         if (TRUE) {
[09:29:47.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.276]                 open = "w")
[09:29:47.276]         }
[09:29:47.276]         else {
[09:29:47.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.276]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.276]         }
[09:29:47.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.276]             base::sink(type = "output", split = FALSE)
[09:29:47.276]             base::close(...future.stdout)
[09:29:47.276]         }, add = TRUE)
[09:29:47.276]     }
[09:29:47.276]     ...future.frame <- base::sys.nframe()
[09:29:47.276]     ...future.conditions <- base::list()
[09:29:47.276]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.276]     if (FALSE) {
[09:29:47.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.276]     }
[09:29:47.276]     ...future.result <- base::tryCatch({
[09:29:47.276]         base::withCallingHandlers({
[09:29:47.276]             ...future.value <- base::withVisible(base::local({
[09:29:47.276]                 withCallingHandlers({
[09:29:47.276]                   {
[09:29:47.276]                     do.call(function(...) {
[09:29:47.276]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.276]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.276]                         ...future.globals.maxSize)) {
[09:29:47.276]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.276]                         on.exit(options(oopts), add = TRUE)
[09:29:47.276]                       }
[09:29:47.276]                       {
[09:29:47.276]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.276]                           FUN = function(jj) {
[09:29:47.276]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.276]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.276]                           })
[09:29:47.276]                       }
[09:29:47.276]                     }, args = future.call.arguments)
[09:29:47.276]                   }
[09:29:47.276]                 }, immediateCondition = function(cond) {
[09:29:47.276]                   save_rds <- function (object, pathname, ...) 
[09:29:47.276]                   {
[09:29:47.276]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.276]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.276]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.276]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.276]                         fi_tmp[["mtime"]])
[09:29:47.276]                     }
[09:29:47.276]                     tryCatch({
[09:29:47.276]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.276]                     }, error = function(ex) {
[09:29:47.276]                       msg <- conditionMessage(ex)
[09:29:47.276]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.276]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.276]                         fi_tmp[["mtime"]], msg)
[09:29:47.276]                       ex$message <- msg
[09:29:47.276]                       stop(ex)
[09:29:47.276]                     })
[09:29:47.276]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.276]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.276]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.276]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.276]                       fi <- file.info(pathname)
[09:29:47.276]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.276]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.276]                         fi[["size"]], fi[["mtime"]])
[09:29:47.276]                       stop(msg)
[09:29:47.276]                     }
[09:29:47.276]                     invisible(pathname)
[09:29:47.276]                   }
[09:29:47.276]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.276]                     rootPath = tempdir()) 
[09:29:47.276]                   {
[09:29:47.276]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.276]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.276]                       tmpdir = path, fileext = ".rds")
[09:29:47.276]                     save_rds(obj, file)
[09:29:47.276]                   }
[09:29:47.276]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.276]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.276]                   {
[09:29:47.276]                     inherits <- base::inherits
[09:29:47.276]                     invokeRestart <- base::invokeRestart
[09:29:47.276]                     is.null <- base::is.null
[09:29:47.276]                     muffled <- FALSE
[09:29:47.276]                     if (inherits(cond, "message")) {
[09:29:47.276]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.276]                       if (muffled) 
[09:29:47.276]                         invokeRestart("muffleMessage")
[09:29:47.276]                     }
[09:29:47.276]                     else if (inherits(cond, "warning")) {
[09:29:47.276]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.276]                       if (muffled) 
[09:29:47.276]                         invokeRestart("muffleWarning")
[09:29:47.276]                     }
[09:29:47.276]                     else if (inherits(cond, "condition")) {
[09:29:47.276]                       if (!is.null(pattern)) {
[09:29:47.276]                         computeRestarts <- base::computeRestarts
[09:29:47.276]                         grepl <- base::grepl
[09:29:47.276]                         restarts <- computeRestarts(cond)
[09:29:47.276]                         for (restart in restarts) {
[09:29:47.276]                           name <- restart$name
[09:29:47.276]                           if (is.null(name)) 
[09:29:47.276]                             next
[09:29:47.276]                           if (!grepl(pattern, name)) 
[09:29:47.276]                             next
[09:29:47.276]                           invokeRestart(restart)
[09:29:47.276]                           muffled <- TRUE
[09:29:47.276]                           break
[09:29:47.276]                         }
[09:29:47.276]                       }
[09:29:47.276]                     }
[09:29:47.276]                     invisible(muffled)
[09:29:47.276]                   }
[09:29:47.276]                   muffleCondition(cond)
[09:29:47.276]                 })
[09:29:47.276]             }))
[09:29:47.276]             future::FutureResult(value = ...future.value$value, 
[09:29:47.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.276]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.276]                     ...future.globalenv.names))
[09:29:47.276]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.276]         }, condition = base::local({
[09:29:47.276]             c <- base::c
[09:29:47.276]             inherits <- base::inherits
[09:29:47.276]             invokeRestart <- base::invokeRestart
[09:29:47.276]             length <- base::length
[09:29:47.276]             list <- base::list
[09:29:47.276]             seq.int <- base::seq.int
[09:29:47.276]             signalCondition <- base::signalCondition
[09:29:47.276]             sys.calls <- base::sys.calls
[09:29:47.276]             `[[` <- base::`[[`
[09:29:47.276]             `+` <- base::`+`
[09:29:47.276]             `<<-` <- base::`<<-`
[09:29:47.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.276]                   3L)]
[09:29:47.276]             }
[09:29:47.276]             function(cond) {
[09:29:47.276]                 is_error <- inherits(cond, "error")
[09:29:47.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.276]                   NULL)
[09:29:47.276]                 if (is_error) {
[09:29:47.276]                   sessionInformation <- function() {
[09:29:47.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.276]                       search = base::search(), system = base::Sys.info())
[09:29:47.276]                   }
[09:29:47.276]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.276]                     cond$call), session = sessionInformation(), 
[09:29:47.276]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.276]                   signalCondition(cond)
[09:29:47.276]                 }
[09:29:47.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.276]                 "immediateCondition"))) {
[09:29:47.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.276]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.276]                   if (TRUE && !signal) {
[09:29:47.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.276]                     {
[09:29:47.276]                       inherits <- base::inherits
[09:29:47.276]                       invokeRestart <- base::invokeRestart
[09:29:47.276]                       is.null <- base::is.null
[09:29:47.276]                       muffled <- FALSE
[09:29:47.276]                       if (inherits(cond, "message")) {
[09:29:47.276]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.276]                         if (muffled) 
[09:29:47.276]                           invokeRestart("muffleMessage")
[09:29:47.276]                       }
[09:29:47.276]                       else if (inherits(cond, "warning")) {
[09:29:47.276]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.276]                         if (muffled) 
[09:29:47.276]                           invokeRestart("muffleWarning")
[09:29:47.276]                       }
[09:29:47.276]                       else if (inherits(cond, "condition")) {
[09:29:47.276]                         if (!is.null(pattern)) {
[09:29:47.276]                           computeRestarts <- base::computeRestarts
[09:29:47.276]                           grepl <- base::grepl
[09:29:47.276]                           restarts <- computeRestarts(cond)
[09:29:47.276]                           for (restart in restarts) {
[09:29:47.276]                             name <- restart$name
[09:29:47.276]                             if (is.null(name)) 
[09:29:47.276]                               next
[09:29:47.276]                             if (!grepl(pattern, name)) 
[09:29:47.276]                               next
[09:29:47.276]                             invokeRestart(restart)
[09:29:47.276]                             muffled <- TRUE
[09:29:47.276]                             break
[09:29:47.276]                           }
[09:29:47.276]                         }
[09:29:47.276]                       }
[09:29:47.276]                       invisible(muffled)
[09:29:47.276]                     }
[09:29:47.276]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.276]                   }
[09:29:47.276]                 }
[09:29:47.276]                 else {
[09:29:47.276]                   if (TRUE) {
[09:29:47.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.276]                     {
[09:29:47.276]                       inherits <- base::inherits
[09:29:47.276]                       invokeRestart <- base::invokeRestart
[09:29:47.276]                       is.null <- base::is.null
[09:29:47.276]                       muffled <- FALSE
[09:29:47.276]                       if (inherits(cond, "message")) {
[09:29:47.276]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.276]                         if (muffled) 
[09:29:47.276]                           invokeRestart("muffleMessage")
[09:29:47.276]                       }
[09:29:47.276]                       else if (inherits(cond, "warning")) {
[09:29:47.276]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.276]                         if (muffled) 
[09:29:47.276]                           invokeRestart("muffleWarning")
[09:29:47.276]                       }
[09:29:47.276]                       else if (inherits(cond, "condition")) {
[09:29:47.276]                         if (!is.null(pattern)) {
[09:29:47.276]                           computeRestarts <- base::computeRestarts
[09:29:47.276]                           grepl <- base::grepl
[09:29:47.276]                           restarts <- computeRestarts(cond)
[09:29:47.276]                           for (restart in restarts) {
[09:29:47.276]                             name <- restart$name
[09:29:47.276]                             if (is.null(name)) 
[09:29:47.276]                               next
[09:29:47.276]                             if (!grepl(pattern, name)) 
[09:29:47.276]                               next
[09:29:47.276]                             invokeRestart(restart)
[09:29:47.276]                             muffled <- TRUE
[09:29:47.276]                             break
[09:29:47.276]                           }
[09:29:47.276]                         }
[09:29:47.276]                       }
[09:29:47.276]                       invisible(muffled)
[09:29:47.276]                     }
[09:29:47.276]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.276]                   }
[09:29:47.276]                 }
[09:29:47.276]             }
[09:29:47.276]         }))
[09:29:47.276]     }, error = function(ex) {
[09:29:47.276]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.276]                 ...future.rng), started = ...future.startTime, 
[09:29:47.276]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.276]             version = "1.8"), class = "FutureResult")
[09:29:47.276]     }, finally = {
[09:29:47.276]         if (!identical(...future.workdir, getwd())) 
[09:29:47.276]             setwd(...future.workdir)
[09:29:47.276]         {
[09:29:47.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.276]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.276]             }
[09:29:47.276]             base::options(...future.oldOptions)
[09:29:47.276]             if (.Platform$OS.type == "windows") {
[09:29:47.276]                 old_names <- names(...future.oldEnvVars)
[09:29:47.276]                 envs <- base::Sys.getenv()
[09:29:47.276]                 names <- names(envs)
[09:29:47.276]                 common <- intersect(names, old_names)
[09:29:47.276]                 added <- setdiff(names, old_names)
[09:29:47.276]                 removed <- setdiff(old_names, names)
[09:29:47.276]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.276]                   envs[common]]
[09:29:47.276]                 NAMES <- toupper(changed)
[09:29:47.276]                 args <- list()
[09:29:47.276]                 for (kk in seq_along(NAMES)) {
[09:29:47.276]                   name <- changed[[kk]]
[09:29:47.276]                   NAME <- NAMES[[kk]]
[09:29:47.276]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.276]                     next
[09:29:47.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.276]                 }
[09:29:47.276]                 NAMES <- toupper(added)
[09:29:47.276]                 for (kk in seq_along(NAMES)) {
[09:29:47.276]                   name <- added[[kk]]
[09:29:47.276]                   NAME <- NAMES[[kk]]
[09:29:47.276]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.276]                     next
[09:29:47.276]                   args[[name]] <- ""
[09:29:47.276]                 }
[09:29:47.276]                 NAMES <- toupper(removed)
[09:29:47.276]                 for (kk in seq_along(NAMES)) {
[09:29:47.276]                   name <- removed[[kk]]
[09:29:47.276]                   NAME <- NAMES[[kk]]
[09:29:47.276]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.276]                     next
[09:29:47.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.276]                 }
[09:29:47.276]                 if (length(args) > 0) 
[09:29:47.276]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.276]             }
[09:29:47.276]             else {
[09:29:47.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.276]             }
[09:29:47.276]             {
[09:29:47.276]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.276]                   0L) {
[09:29:47.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.276]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.276]                   base::options(opts)
[09:29:47.276]                 }
[09:29:47.276]                 {
[09:29:47.276]                   {
[09:29:47.276]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.276]                     NULL
[09:29:47.276]                   }
[09:29:47.276]                   options(future.plan = NULL)
[09:29:47.276]                   if (is.na(NA_character_)) 
[09:29:47.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.276]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.276]                     .init = FALSE)
[09:29:47.276]                 }
[09:29:47.276]             }
[09:29:47.276]         }
[09:29:47.276]     })
[09:29:47.276]     if (TRUE) {
[09:29:47.276]         base::sink(type = "output", split = FALSE)
[09:29:47.276]         if (TRUE) {
[09:29:47.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.276]         }
[09:29:47.276]         else {
[09:29:47.276]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.276]         }
[09:29:47.276]         base::close(...future.stdout)
[09:29:47.276]         ...future.stdout <- NULL
[09:29:47.276]     }
[09:29:47.276]     ...future.result$conditions <- ...future.conditions
[09:29:47.276]     ...future.result$finished <- base::Sys.time()
[09:29:47.276]     ...future.result
[09:29:47.276] }
[09:29:47.280] assign_globals() ...
[09:29:47.280] List of 11
[09:29:47.280]  $ ...future.FUN            :function (x, ...)  
[09:29:47.280]  $ x_FUN                    :function (x)  
[09:29:47.280]  $ times                    : int 4
[09:29:47.280]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.280]  $ stop_if_not              :function (...)  
[09:29:47.280]  $ dim                      : int [1:2] 2 2
[09:29:47.280]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:47.280]  $ future.call.arguments    : list()
[09:29:47.280]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.280]  $ ...future.elements_ii    :List of 5
[09:29:47.280]   ..$ : int 6
[09:29:47.280]   ..$ : int 7
[09:29:47.280]   ..$ : int 8
[09:29:47.280]   ..$ : int 9
[09:29:47.280]   ..$ : int 10
[09:29:47.280]  $ ...future.seeds_ii       : NULL
[09:29:47.280]  $ ...future.globals.maxSize: NULL
[09:29:47.280]  - attr(*, "where")=List of 11
[09:29:47.280]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.280]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:47.280]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:47.280]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:47.280]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:47.280]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:47.280]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:47.280]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.280]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.280]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.280]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.280]  - attr(*, "resolved")= logi FALSE
[09:29:47.280]  - attr(*, "total_size")= num 105552
[09:29:47.280]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.280]  - attr(*, "already-done")= logi TRUE
[09:29:47.296] - copied ‘...future.FUN’ to environment
[09:29:47.296] - reassign environment for ‘x_FUN’
[09:29:47.296] - copied ‘x_FUN’ to environment
[09:29:47.296] - copied ‘times’ to environment
[09:29:47.297] - copied ‘stopf’ to environment
[09:29:47.297] - copied ‘stop_if_not’ to environment
[09:29:47.297] - copied ‘dim’ to environment
[09:29:47.297] - copied ‘valid_types’ to environment
[09:29:47.297] - copied ‘future.call.arguments’ to environment
[09:29:47.297] - copied ‘...future.elements_ii’ to environment
[09:29:47.297] - copied ‘...future.seeds_ii’ to environment
[09:29:47.298] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.298] assign_globals() ... done
[09:29:47.298] requestCore(): workers = 2
[09:29:47.300] MulticoreFuture started
[09:29:47.301] - Launch lazy future ... done
[09:29:47.301] run() for ‘MulticoreFuture’ ... done
[09:29:47.301] Created future:
[09:29:47.301] plan(): Setting new future strategy stack:
[09:29:47.302] List of future strategies:
[09:29:47.302] 1. sequential:
[09:29:47.302]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.302]    - tweaked: FALSE
[09:29:47.302]    - call: NULL
[09:29:47.303] plan(): nbrOfWorkers() = 1
[09:29:47.305] plan(): Setting new future strategy stack:
[09:29:47.305] List of future strategies:
[09:29:47.305] 1. multicore:
[09:29:47.305]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.305]    - tweaked: FALSE
[09:29:47.305]    - call: plan(strategy)
[09:29:47.310] plan(): nbrOfWorkers() = 2
[09:29:47.301] MulticoreFuture:
[09:29:47.301] Label: ‘future_vapply-2’
[09:29:47.301] Expression:
[09:29:47.301] {
[09:29:47.301]     do.call(function(...) {
[09:29:47.301]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.301]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.301]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.301]             on.exit(options(oopts), add = TRUE)
[09:29:47.301]         }
[09:29:47.301]         {
[09:29:47.301]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.301]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.301]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.301]             })
[09:29:47.301]         }
[09:29:47.301]     }, args = future.call.arguments)
[09:29:47.301] }
[09:29:47.301] Lazy evaluation: FALSE
[09:29:47.301] Asynchronous evaluation: TRUE
[09:29:47.301] Local evaluation: TRUE
[09:29:47.301] Environment: R_GlobalEnv
[09:29:47.301] Capture standard output: TRUE
[09:29:47.301] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.301] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:47.301] Packages: 1 packages (‘future.apply’)
[09:29:47.301] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.301] Resolved: TRUE
[09:29:47.301] Value: <not collected>
[09:29:47.301] Conditions captured: <none>
[09:29:47.301] Early signaling: FALSE
[09:29:47.301] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.301] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.311] Chunk #2 of 2 ... DONE
[09:29:47.311] Launching 2 futures (chunks) ... DONE
[09:29:47.311] Resolving 2 futures (chunks) ...
[09:29:47.312] resolve() on list ...
[09:29:47.312]  recursive: 0
[09:29:47.312]  length: 2
[09:29:47.312] 
[09:29:47.312] Future #1
[09:29:47.313] result() for MulticoreFuture ...
[09:29:47.313] result() for MulticoreFuture ...
[09:29:47.313] result() for MulticoreFuture ... done
[09:29:47.314] result() for MulticoreFuture ... done
[09:29:47.314] result() for MulticoreFuture ...
[09:29:47.314] result() for MulticoreFuture ... done
[09:29:47.314] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:47.314] - nx: 2
[09:29:47.314] - relay: TRUE
[09:29:47.315] - stdout: TRUE
[09:29:47.315] - signal: TRUE
[09:29:47.315] - resignal: FALSE
[09:29:47.315] - force: TRUE
[09:29:47.315] - relayed: [n=2] FALSE, FALSE
[09:29:47.315] - queued futures: [n=2] FALSE, FALSE
[09:29:47.315]  - until=1
[09:29:47.315]  - relaying element #1
[09:29:47.316] result() for MulticoreFuture ...
[09:29:47.316] result() for MulticoreFuture ... done
[09:29:47.316] result() for MulticoreFuture ...
[09:29:47.316] result() for MulticoreFuture ... done
[09:29:47.316] result() for MulticoreFuture ...
[09:29:47.316] result() for MulticoreFuture ... done
[09:29:47.317] result() for MulticoreFuture ...
[09:29:47.317] result() for MulticoreFuture ... done
[09:29:47.317] - relayed: [n=2] TRUE, FALSE
[09:29:47.317] - queued futures: [n=2] TRUE, FALSE
[09:29:47.317] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:47.318]  length: 1 (resolved future 1)
[09:29:47.318] Future #2
[09:29:47.318] result() for MulticoreFuture ...
[09:29:47.319] result() for MulticoreFuture ...
[09:29:47.319] result() for MulticoreFuture ... done
[09:29:47.319] result() for MulticoreFuture ... done
[09:29:47.319] result() for MulticoreFuture ...
[09:29:47.319] result() for MulticoreFuture ... done
[09:29:47.319] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:47.320] - nx: 2
[09:29:47.320] - relay: TRUE
[09:29:47.320] - stdout: TRUE
[09:29:47.320] - signal: TRUE
[09:29:47.320] - resignal: FALSE
[09:29:47.320] - force: TRUE
[09:29:47.320] - relayed: [n=2] TRUE, FALSE
[09:29:47.320] - queued futures: [n=2] TRUE, FALSE
[09:29:47.321]  - until=2
[09:29:47.321]  - relaying element #2
[09:29:47.321] result() for MulticoreFuture ...
[09:29:47.321] result() for MulticoreFuture ... done
[09:29:47.321] result() for MulticoreFuture ...
[09:29:47.321] result() for MulticoreFuture ... done
[09:29:47.321] result() for MulticoreFuture ...
[09:29:47.321] result() for MulticoreFuture ... done
[09:29:47.322] result() for MulticoreFuture ...
[09:29:47.322] result() for MulticoreFuture ... done
[09:29:47.322] - relayed: [n=2] TRUE, TRUE
[09:29:47.322] - queued futures: [n=2] TRUE, TRUE
[09:29:47.322] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:47.322]  length: 0 (resolved future 2)
[09:29:47.322] Relaying remaining futures
[09:29:47.322] signalConditionsASAP(NULL, pos=0) ...
[09:29:47.322] - nx: 2
[09:29:47.322] - relay: TRUE
[09:29:47.323] - stdout: TRUE
[09:29:47.323] - signal: TRUE
[09:29:47.323] - resignal: FALSE
[09:29:47.323] - force: TRUE
[09:29:47.323] - relayed: [n=2] TRUE, TRUE
[09:29:47.323] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:47.323] - relayed: [n=2] TRUE, TRUE
[09:29:47.323] - queued futures: [n=2] TRUE, TRUE
[09:29:47.323] signalConditionsASAP(NULL, pos=0) ... done
[09:29:47.324] resolve() on list ... DONE
[09:29:47.324] result() for MulticoreFuture ...
[09:29:47.324] result() for MulticoreFuture ... done
[09:29:47.324] result() for MulticoreFuture ...
[09:29:47.324] result() for MulticoreFuture ... done
[09:29:47.324] result() for MulticoreFuture ...
[09:29:47.324] result() for MulticoreFuture ... done
[09:29:47.324] result() for MulticoreFuture ...
[09:29:47.324] result() for MulticoreFuture ... done
[09:29:47.325]  - Number of value chunks collected: 2
[09:29:47.325] Resolving 2 futures (chunks) ... DONE
[09:29:47.325] Reducing values from 2 chunks ...
[09:29:47.325]  - Number of values collected after concatenation: 10
[09:29:47.325]  - Number of values expected: 10
[09:29:47.325] Reducing values from 2 chunks ... DONE
[09:29:47.325] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[09:29:47.328] future_lapply() ...
[09:29:47.337] Number of chunks: 2
[09:29:47.337] getGlobalsAndPackagesXApply() ...
[09:29:47.337]  - future.globals: TRUE
[09:29:47.337] getGlobalsAndPackages() ...
[09:29:47.337] Searching for globals...
[09:29:47.341] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[09:29:47.341] Searching for globals ... DONE
[09:29:47.341] Resolving globals: FALSE
[09:29:47.342] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[09:29:47.343] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:47.343] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.343] - packages: [2] ‘stats’, ‘future.apply’
[09:29:47.343] getGlobalsAndPackages() ... DONE
[09:29:47.343]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.343]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[09:29:47.343] Finding globals ... DONE
[09:29:47.343]  - use_args: TRUE
[09:29:47.343]  - Getting '...' globals ...
[09:29:47.344] resolve() on list ...
[09:29:47.344]  recursive: 0
[09:29:47.344]  length: 1
[09:29:47.344]  elements: ‘...’
[09:29:47.344]  length: 0 (resolved future 1)
[09:29:47.344] resolve() on list ... DONE
[09:29:47.344]    - '...' content: [n=0] 
[09:29:47.345] List of 1
[09:29:47.345]  $ ...: list()
[09:29:47.345]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.345]  - attr(*, "where")=List of 1
[09:29:47.345]   ..$ ...:<environment: 0x561d367f6f98> 
[09:29:47.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.345]  - attr(*, "resolved")= logi TRUE
[09:29:47.345]  - attr(*, "total_size")= num NA
[09:29:47.347]  - Getting '...' globals ... DONE
[09:29:47.347] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:47.347] List of 8
[09:29:47.347]  $ ...future.FUN:function (x, ...)  
[09:29:47.347]  $ x_FUN        :function (x, ...)  
[09:29:47.347]  $ times        : int 5
[09:29:47.347]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.347]  $ stop_if_not  :function (...)  
[09:29:47.347]  $ dim          : NULL
[09:29:47.347]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:47.347]  $ ...          : list()
[09:29:47.347]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.347]  - attr(*, "where")=List of 8
[09:29:47.347]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:47.347]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:47.347]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:47.347]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:47.347]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:47.347]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:47.347]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:47.347]   ..$ ...          :<environment: 0x561d367f6f98> 
[09:29:47.347]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.347]  - attr(*, "resolved")= logi FALSE
[09:29:47.347]  - attr(*, "total_size")= num 95528
[09:29:47.352] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[09:29:47.352] getGlobalsAndPackagesXApply() ... DONE
[09:29:47.353] Number of futures (= number of chunks): 2
[09:29:47.353] Launching 2 futures (chunks) ...
[09:29:47.353] Chunk #1 of 2 ...
[09:29:47.353]  - Finding globals in 'X' for chunk #1 ...
[09:29:47.353] getGlobalsAndPackages() ...
[09:29:47.354] Searching for globals...
[09:29:47.355] 
[09:29:47.355] Searching for globals ... DONE
[09:29:47.355] - globals: [0] <none>
[09:29:47.355] getGlobalsAndPackages() ... DONE
[09:29:47.355]    + additional globals found: [n=0] 
[09:29:47.355]    + additional namespaces needed: [n=0] 
[09:29:47.355]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:47.355]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.355]  - seeds: <none>
[09:29:47.355]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.356] getGlobalsAndPackages() ...
[09:29:47.356] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.356] Resolving globals: FALSE
[09:29:47.356] Tweak future expression to call with '...' arguments ...
[09:29:47.356] {
[09:29:47.356]     do.call(function(...) {
[09:29:47.356]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.356]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.356]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.356]             on.exit(options(oopts), add = TRUE)
[09:29:47.356]         }
[09:29:47.356]         {
[09:29:47.356]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.356]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.356]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.356]             })
[09:29:47.356]         }
[09:29:47.356]     }, args = future.call.arguments)
[09:29:47.356] }
[09:29:47.356] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.357] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.357] - packages: [2] ‘stats’, ‘future.apply’
[09:29:47.357] getGlobalsAndPackages() ... DONE
[09:29:47.357] run() for ‘Future’ ...
[09:29:47.358] - state: ‘created’
[09:29:47.358] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.361] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.361] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.361]   - Field: ‘label’
[09:29:47.362]   - Field: ‘local’
[09:29:47.362]   - Field: ‘owner’
[09:29:47.362]   - Field: ‘envir’
[09:29:47.362]   - Field: ‘workers’
[09:29:47.362]   - Field: ‘packages’
[09:29:47.362]   - Field: ‘gc’
[09:29:47.362]   - Field: ‘job’
[09:29:47.362]   - Field: ‘conditions’
[09:29:47.362]   - Field: ‘expr’
[09:29:47.362]   - Field: ‘uuid’
[09:29:47.362]   - Field: ‘seed’
[09:29:47.363]   - Field: ‘version’
[09:29:47.363]   - Field: ‘result’
[09:29:47.363]   - Field: ‘asynchronous’
[09:29:47.363]   - Field: ‘calls’
[09:29:47.363]   - Field: ‘globals’
[09:29:47.363]   - Field: ‘stdout’
[09:29:47.363]   - Field: ‘earlySignal’
[09:29:47.363]   - Field: ‘lazy’
[09:29:47.363]   - Field: ‘state’
[09:29:47.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.363] - Launch lazy future ...
[09:29:47.364] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[09:29:47.364] Packages needed by future strategies (n = 0): <none>
[09:29:47.364] {
[09:29:47.364]     {
[09:29:47.364]         {
[09:29:47.364]             ...future.startTime <- base::Sys.time()
[09:29:47.364]             {
[09:29:47.364]                 {
[09:29:47.364]                   {
[09:29:47.364]                     {
[09:29:47.364]                       {
[09:29:47.364]                         base::local({
[09:29:47.364]                           has_future <- base::requireNamespace("future", 
[09:29:47.364]                             quietly = TRUE)
[09:29:47.364]                           if (has_future) {
[09:29:47.364]                             ns <- base::getNamespace("future")
[09:29:47.364]                             version <- ns[[".package"]][["version"]]
[09:29:47.364]                             if (is.null(version)) 
[09:29:47.364]                               version <- utils::packageVersion("future")
[09:29:47.364]                           }
[09:29:47.364]                           else {
[09:29:47.364]                             version <- NULL
[09:29:47.364]                           }
[09:29:47.364]                           if (!has_future || version < "1.8.0") {
[09:29:47.364]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.364]                               "", base::R.version$version.string), 
[09:29:47.364]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.364]                                 base::R.version$platform, 8 * 
[09:29:47.364]                                   base::.Machine$sizeof.pointer), 
[09:29:47.364]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.364]                                 "release", "version")], collapse = " "), 
[09:29:47.364]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.364]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.364]                               info)
[09:29:47.364]                             info <- base::paste(info, collapse = "; ")
[09:29:47.364]                             if (!has_future) {
[09:29:47.364]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.364]                                 info)
[09:29:47.364]                             }
[09:29:47.364]                             else {
[09:29:47.364]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.364]                                 info, version)
[09:29:47.364]                             }
[09:29:47.364]                             base::stop(msg)
[09:29:47.364]                           }
[09:29:47.364]                         })
[09:29:47.364]                       }
[09:29:47.364]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.364]                       base::options(mc.cores = 1L)
[09:29:47.364]                     }
[09:29:47.364]                     base::local({
[09:29:47.364]                       for (pkg in c("stats", "future.apply")) {
[09:29:47.364]                         base::loadNamespace(pkg)
[09:29:47.364]                         base::library(pkg, character.only = TRUE)
[09:29:47.364]                       }
[09:29:47.364]                     })
[09:29:47.364]                   }
[09:29:47.364]                   ...future.strategy.old <- future::plan("list")
[09:29:47.364]                   options(future.plan = NULL)
[09:29:47.364]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.364]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.364]                 }
[09:29:47.364]                 ...future.workdir <- getwd()
[09:29:47.364]             }
[09:29:47.364]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.364]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.364]         }
[09:29:47.364]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.364]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.364]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.364]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.364]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.364]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.364]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.364]             base::names(...future.oldOptions))
[09:29:47.364]     }
[09:29:47.364]     if (FALSE) {
[09:29:47.364]     }
[09:29:47.364]     else {
[09:29:47.364]         if (TRUE) {
[09:29:47.364]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.364]                 open = "w")
[09:29:47.364]         }
[09:29:47.364]         else {
[09:29:47.364]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.364]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.364]         }
[09:29:47.364]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.364]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.364]             base::sink(type = "output", split = FALSE)
[09:29:47.364]             base::close(...future.stdout)
[09:29:47.364]         }, add = TRUE)
[09:29:47.364]     }
[09:29:47.364]     ...future.frame <- base::sys.nframe()
[09:29:47.364]     ...future.conditions <- base::list()
[09:29:47.364]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.364]     if (FALSE) {
[09:29:47.364]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.364]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.364]     }
[09:29:47.364]     ...future.result <- base::tryCatch({
[09:29:47.364]         base::withCallingHandlers({
[09:29:47.364]             ...future.value <- base::withVisible(base::local({
[09:29:47.364]                 withCallingHandlers({
[09:29:47.364]                   {
[09:29:47.364]                     do.call(function(...) {
[09:29:47.364]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.364]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.364]                         ...future.globals.maxSize)) {
[09:29:47.364]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.364]                         on.exit(options(oopts), add = TRUE)
[09:29:47.364]                       }
[09:29:47.364]                       {
[09:29:47.364]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.364]                           FUN = function(jj) {
[09:29:47.364]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.364]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.364]                           })
[09:29:47.364]                       }
[09:29:47.364]                     }, args = future.call.arguments)
[09:29:47.364]                   }
[09:29:47.364]                 }, immediateCondition = function(cond) {
[09:29:47.364]                   save_rds <- function (object, pathname, ...) 
[09:29:47.364]                   {
[09:29:47.364]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.364]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.364]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.364]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.364]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.364]                         fi_tmp[["mtime"]])
[09:29:47.364]                     }
[09:29:47.364]                     tryCatch({
[09:29:47.364]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.364]                     }, error = function(ex) {
[09:29:47.364]                       msg <- conditionMessage(ex)
[09:29:47.364]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.364]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.364]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.364]                         fi_tmp[["mtime"]], msg)
[09:29:47.364]                       ex$message <- msg
[09:29:47.364]                       stop(ex)
[09:29:47.364]                     })
[09:29:47.364]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.364]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.364]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.364]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.364]                       fi <- file.info(pathname)
[09:29:47.364]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.364]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.364]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.364]                         fi[["size"]], fi[["mtime"]])
[09:29:47.364]                       stop(msg)
[09:29:47.364]                     }
[09:29:47.364]                     invisible(pathname)
[09:29:47.364]                   }
[09:29:47.364]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.364]                     rootPath = tempdir()) 
[09:29:47.364]                   {
[09:29:47.364]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.364]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.364]                       tmpdir = path, fileext = ".rds")
[09:29:47.364]                     save_rds(obj, file)
[09:29:47.364]                   }
[09:29:47.364]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.364]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.364]                   {
[09:29:47.364]                     inherits <- base::inherits
[09:29:47.364]                     invokeRestart <- base::invokeRestart
[09:29:47.364]                     is.null <- base::is.null
[09:29:47.364]                     muffled <- FALSE
[09:29:47.364]                     if (inherits(cond, "message")) {
[09:29:47.364]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.364]                       if (muffled) 
[09:29:47.364]                         invokeRestart("muffleMessage")
[09:29:47.364]                     }
[09:29:47.364]                     else if (inherits(cond, "warning")) {
[09:29:47.364]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.364]                       if (muffled) 
[09:29:47.364]                         invokeRestart("muffleWarning")
[09:29:47.364]                     }
[09:29:47.364]                     else if (inherits(cond, "condition")) {
[09:29:47.364]                       if (!is.null(pattern)) {
[09:29:47.364]                         computeRestarts <- base::computeRestarts
[09:29:47.364]                         grepl <- base::grepl
[09:29:47.364]                         restarts <- computeRestarts(cond)
[09:29:47.364]                         for (restart in restarts) {
[09:29:47.364]                           name <- restart$name
[09:29:47.364]                           if (is.null(name)) 
[09:29:47.364]                             next
[09:29:47.364]                           if (!grepl(pattern, name)) 
[09:29:47.364]                             next
[09:29:47.364]                           invokeRestart(restart)
[09:29:47.364]                           muffled <- TRUE
[09:29:47.364]                           break
[09:29:47.364]                         }
[09:29:47.364]                       }
[09:29:47.364]                     }
[09:29:47.364]                     invisible(muffled)
[09:29:47.364]                   }
[09:29:47.364]                   muffleCondition(cond)
[09:29:47.364]                 })
[09:29:47.364]             }))
[09:29:47.364]             future::FutureResult(value = ...future.value$value, 
[09:29:47.364]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.364]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.364]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.364]                     ...future.globalenv.names))
[09:29:47.364]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.364]         }, condition = base::local({
[09:29:47.364]             c <- base::c
[09:29:47.364]             inherits <- base::inherits
[09:29:47.364]             invokeRestart <- base::invokeRestart
[09:29:47.364]             length <- base::length
[09:29:47.364]             list <- base::list
[09:29:47.364]             seq.int <- base::seq.int
[09:29:47.364]             signalCondition <- base::signalCondition
[09:29:47.364]             sys.calls <- base::sys.calls
[09:29:47.364]             `[[` <- base::`[[`
[09:29:47.364]             `+` <- base::`+`
[09:29:47.364]             `<<-` <- base::`<<-`
[09:29:47.364]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.364]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.364]                   3L)]
[09:29:47.364]             }
[09:29:47.364]             function(cond) {
[09:29:47.364]                 is_error <- inherits(cond, "error")
[09:29:47.364]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.364]                   NULL)
[09:29:47.364]                 if (is_error) {
[09:29:47.364]                   sessionInformation <- function() {
[09:29:47.364]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.364]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.364]                       search = base::search(), system = base::Sys.info())
[09:29:47.364]                   }
[09:29:47.364]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.364]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.364]                     cond$call), session = sessionInformation(), 
[09:29:47.364]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.364]                   signalCondition(cond)
[09:29:47.364]                 }
[09:29:47.364]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.364]                 "immediateCondition"))) {
[09:29:47.364]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.364]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.364]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.364]                   if (TRUE && !signal) {
[09:29:47.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.364]                     {
[09:29:47.364]                       inherits <- base::inherits
[09:29:47.364]                       invokeRestart <- base::invokeRestart
[09:29:47.364]                       is.null <- base::is.null
[09:29:47.364]                       muffled <- FALSE
[09:29:47.364]                       if (inherits(cond, "message")) {
[09:29:47.364]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.364]                         if (muffled) 
[09:29:47.364]                           invokeRestart("muffleMessage")
[09:29:47.364]                       }
[09:29:47.364]                       else if (inherits(cond, "warning")) {
[09:29:47.364]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.364]                         if (muffled) 
[09:29:47.364]                           invokeRestart("muffleWarning")
[09:29:47.364]                       }
[09:29:47.364]                       else if (inherits(cond, "condition")) {
[09:29:47.364]                         if (!is.null(pattern)) {
[09:29:47.364]                           computeRestarts <- base::computeRestarts
[09:29:47.364]                           grepl <- base::grepl
[09:29:47.364]                           restarts <- computeRestarts(cond)
[09:29:47.364]                           for (restart in restarts) {
[09:29:47.364]                             name <- restart$name
[09:29:47.364]                             if (is.null(name)) 
[09:29:47.364]                               next
[09:29:47.364]                             if (!grepl(pattern, name)) 
[09:29:47.364]                               next
[09:29:47.364]                             invokeRestart(restart)
[09:29:47.364]                             muffled <- TRUE
[09:29:47.364]                             break
[09:29:47.364]                           }
[09:29:47.364]                         }
[09:29:47.364]                       }
[09:29:47.364]                       invisible(muffled)
[09:29:47.364]                     }
[09:29:47.364]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.364]                   }
[09:29:47.364]                 }
[09:29:47.364]                 else {
[09:29:47.364]                   if (TRUE) {
[09:29:47.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.364]                     {
[09:29:47.364]                       inherits <- base::inherits
[09:29:47.364]                       invokeRestart <- base::invokeRestart
[09:29:47.364]                       is.null <- base::is.null
[09:29:47.364]                       muffled <- FALSE
[09:29:47.364]                       if (inherits(cond, "message")) {
[09:29:47.364]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.364]                         if (muffled) 
[09:29:47.364]                           invokeRestart("muffleMessage")
[09:29:47.364]                       }
[09:29:47.364]                       else if (inherits(cond, "warning")) {
[09:29:47.364]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.364]                         if (muffled) 
[09:29:47.364]                           invokeRestart("muffleWarning")
[09:29:47.364]                       }
[09:29:47.364]                       else if (inherits(cond, "condition")) {
[09:29:47.364]                         if (!is.null(pattern)) {
[09:29:47.364]                           computeRestarts <- base::computeRestarts
[09:29:47.364]                           grepl <- base::grepl
[09:29:47.364]                           restarts <- computeRestarts(cond)
[09:29:47.364]                           for (restart in restarts) {
[09:29:47.364]                             name <- restart$name
[09:29:47.364]                             if (is.null(name)) 
[09:29:47.364]                               next
[09:29:47.364]                             if (!grepl(pattern, name)) 
[09:29:47.364]                               next
[09:29:47.364]                             invokeRestart(restart)
[09:29:47.364]                             muffled <- TRUE
[09:29:47.364]                             break
[09:29:47.364]                           }
[09:29:47.364]                         }
[09:29:47.364]                       }
[09:29:47.364]                       invisible(muffled)
[09:29:47.364]                     }
[09:29:47.364]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.364]                   }
[09:29:47.364]                 }
[09:29:47.364]             }
[09:29:47.364]         }))
[09:29:47.364]     }, error = function(ex) {
[09:29:47.364]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.364]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.364]                 ...future.rng), started = ...future.startTime, 
[09:29:47.364]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.364]             version = "1.8"), class = "FutureResult")
[09:29:47.364]     }, finally = {
[09:29:47.364]         if (!identical(...future.workdir, getwd())) 
[09:29:47.364]             setwd(...future.workdir)
[09:29:47.364]         {
[09:29:47.364]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.364]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.364]             }
[09:29:47.364]             base::options(...future.oldOptions)
[09:29:47.364]             if (.Platform$OS.type == "windows") {
[09:29:47.364]                 old_names <- names(...future.oldEnvVars)
[09:29:47.364]                 envs <- base::Sys.getenv()
[09:29:47.364]                 names <- names(envs)
[09:29:47.364]                 common <- intersect(names, old_names)
[09:29:47.364]                 added <- setdiff(names, old_names)
[09:29:47.364]                 removed <- setdiff(old_names, names)
[09:29:47.364]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.364]                   envs[common]]
[09:29:47.364]                 NAMES <- toupper(changed)
[09:29:47.364]                 args <- list()
[09:29:47.364]                 for (kk in seq_along(NAMES)) {
[09:29:47.364]                   name <- changed[[kk]]
[09:29:47.364]                   NAME <- NAMES[[kk]]
[09:29:47.364]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.364]                     next
[09:29:47.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.364]                 }
[09:29:47.364]                 NAMES <- toupper(added)
[09:29:47.364]                 for (kk in seq_along(NAMES)) {
[09:29:47.364]                   name <- added[[kk]]
[09:29:47.364]                   NAME <- NAMES[[kk]]
[09:29:47.364]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.364]                     next
[09:29:47.364]                   args[[name]] <- ""
[09:29:47.364]                 }
[09:29:47.364]                 NAMES <- toupper(removed)
[09:29:47.364]                 for (kk in seq_along(NAMES)) {
[09:29:47.364]                   name <- removed[[kk]]
[09:29:47.364]                   NAME <- NAMES[[kk]]
[09:29:47.364]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.364]                     next
[09:29:47.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.364]                 }
[09:29:47.364]                 if (length(args) > 0) 
[09:29:47.364]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.364]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.364]             }
[09:29:47.364]             else {
[09:29:47.364]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.364]             }
[09:29:47.364]             {
[09:29:47.364]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.364]                   0L) {
[09:29:47.364]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.364]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.364]                   base::options(opts)
[09:29:47.364]                 }
[09:29:47.364]                 {
[09:29:47.364]                   {
[09:29:47.364]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.364]                     NULL
[09:29:47.364]                   }
[09:29:47.364]                   options(future.plan = NULL)
[09:29:47.364]                   if (is.na(NA_character_)) 
[09:29:47.364]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.364]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.364]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.364]                     .init = FALSE)
[09:29:47.364]                 }
[09:29:47.364]             }
[09:29:47.364]         }
[09:29:47.364]     })
[09:29:47.364]     if (TRUE) {
[09:29:47.364]         base::sink(type = "output", split = FALSE)
[09:29:47.364]         if (TRUE) {
[09:29:47.364]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.364]         }
[09:29:47.364]         else {
[09:29:47.364]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.364]         }
[09:29:47.364]         base::close(...future.stdout)
[09:29:47.364]         ...future.stdout <- NULL
[09:29:47.364]     }
[09:29:47.364]     ...future.result$conditions <- ...future.conditions
[09:29:47.364]     ...future.result$finished <- base::Sys.time()
[09:29:47.364]     ...future.result
[09:29:47.364] }
[09:29:47.367] assign_globals() ...
[09:29:47.367] List of 11
[09:29:47.367]  $ ...future.FUN            :function (x, ...)  
[09:29:47.367]  $ x_FUN                    :function (x, ...)  
[09:29:47.367]  $ times                    : int 5
[09:29:47.367]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.367]  $ stop_if_not              :function (...)  
[09:29:47.367]  $ dim                      : NULL
[09:29:47.367]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:47.367]  $ future.call.arguments    : list()
[09:29:47.367]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.367]  $ ...future.elements_ii    :List of 1
[09:29:47.367]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[09:29:47.367]  $ ...future.seeds_ii       : NULL
[09:29:47.367]  $ ...future.globals.maxSize: NULL
[09:29:47.367]  - attr(*, "where")=List of 11
[09:29:47.367]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.367]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:47.367]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:47.367]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:47.367]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:47.367]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:47.367]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:47.367]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.367]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.367]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.367]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.367]  - attr(*, "resolved")= logi FALSE
[09:29:47.367]  - attr(*, "total_size")= num 95528
[09:29:47.367]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.367]  - attr(*, "already-done")= logi TRUE
[09:29:47.374] - copied ‘...future.FUN’ to environment
[09:29:47.374] - copied ‘x_FUN’ to environment
[09:29:47.374] - copied ‘times’ to environment
[09:29:47.374] - copied ‘stopf’ to environment
[09:29:47.374] - copied ‘stop_if_not’ to environment
[09:29:47.374] - copied ‘dim’ to environment
[09:29:47.374] - copied ‘valid_types’ to environment
[09:29:47.374] - copied ‘future.call.arguments’ to environment
[09:29:47.375] - copied ‘...future.elements_ii’ to environment
[09:29:47.375] - copied ‘...future.seeds_ii’ to environment
[09:29:47.375] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.375] assign_globals() ... done
[09:29:47.375] requestCore(): workers = 2
[09:29:47.377] MulticoreFuture started
[09:29:47.377] - Launch lazy future ... done
[09:29:47.377] run() for ‘MulticoreFuture’ ... done
[09:29:47.378] Created future:
[09:29:47.378] plan(): Setting new future strategy stack:
[09:29:47.379] List of future strategies:
[09:29:47.379] 1. sequential:
[09:29:47.379]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.379]    - tweaked: FALSE
[09:29:47.379]    - call: NULL
[09:29:47.379] plan(): nbrOfWorkers() = 1
[09:29:47.382] plan(): Setting new future strategy stack:
[09:29:47.382] List of future strategies:
[09:29:47.382] 1. multicore:
[09:29:47.382]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.382]    - tweaked: FALSE
[09:29:47.382]    - call: plan(strategy)
[09:29:47.378] MulticoreFuture:
[09:29:47.378] Label: ‘future_vapply-1’
[09:29:47.378] Expression:
[09:29:47.378] {
[09:29:47.378]     do.call(function(...) {
[09:29:47.378]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.378]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.378]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.378]             on.exit(options(oopts), add = TRUE)
[09:29:47.378]         }
[09:29:47.378]         {
[09:29:47.378]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.378]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.378]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.378]             })
[09:29:47.378]         }
[09:29:47.378]     }, args = future.call.arguments)
[09:29:47.378] }
[09:29:47.378] Lazy evaluation: FALSE
[09:29:47.378] Asynchronous evaluation: TRUE
[09:29:47.378] Local evaluation: TRUE
[09:29:47.378] Environment: R_GlobalEnv
[09:29:47.378] Capture standard output: TRUE
[09:29:47.378] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.378] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:47.378] Packages: 2 packages (‘stats’, ‘future.apply’)
[09:29:47.378] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.378] Resolved: FALSE
[09:29:47.378] Value: <not collected>
[09:29:47.378] Conditions captured: <none>
[09:29:47.378] Early signaling: FALSE
[09:29:47.378] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.378] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.391] Chunk #1 of 2 ... DONE
[09:29:47.391] Chunk #2 of 2 ...
[09:29:47.391]  - Finding globals in 'X' for chunk #2 ...
[09:29:47.391] getGlobalsAndPackages() ...
[09:29:47.391] Searching for globals...
[09:29:47.392] 
[09:29:47.392] Searching for globals ... DONE
[09:29:47.392] - globals: [0] <none>
[09:29:47.392] plan(): nbrOfWorkers() = 2
[09:29:47.392] getGlobalsAndPackages() ... DONE
[09:29:47.395]    + additional globals found: [n=0] 
[09:29:47.395]    + additional namespaces needed: [n=0] 
[09:29:47.395]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:47.395]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.396]  - seeds: <none>
[09:29:47.396]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.396] getGlobalsAndPackages() ...
[09:29:47.396] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.397] Resolving globals: FALSE
[09:29:47.397] Tweak future expression to call with '...' arguments ...
[09:29:47.397] {
[09:29:47.397]     do.call(function(...) {
[09:29:47.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.397]             on.exit(options(oopts), add = TRUE)
[09:29:47.397]         }
[09:29:47.397]         {
[09:29:47.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.397]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.397]             })
[09:29:47.397]         }
[09:29:47.397]     }, args = future.call.arguments)
[09:29:47.397] }
[09:29:47.398] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.399] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.400] - packages: [2] ‘stats’, ‘future.apply’
[09:29:47.400] getGlobalsAndPackages() ... DONE
[09:29:47.401] run() for ‘Future’ ...
[09:29:47.401] - state: ‘created’
[09:29:47.401] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.407] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.407]   - Field: ‘label’
[09:29:47.407]   - Field: ‘local’
[09:29:47.408]   - Field: ‘owner’
[09:29:47.408]   - Field: ‘envir’
[09:29:47.408]   - Field: ‘workers’
[09:29:47.408]   - Field: ‘packages’
[09:29:47.408]   - Field: ‘gc’
[09:29:47.408]   - Field: ‘job’
[09:29:47.409]   - Field: ‘conditions’
[09:29:47.409]   - Field: ‘expr’
[09:29:47.409]   - Field: ‘uuid’
[09:29:47.409]   - Field: ‘seed’
[09:29:47.409]   - Field: ‘version’
[09:29:47.409]   - Field: ‘result’
[09:29:47.409]   - Field: ‘asynchronous’
[09:29:47.410]   - Field: ‘calls’
[09:29:47.410]   - Field: ‘globals’
[09:29:47.410]   - Field: ‘stdout’
[09:29:47.410]   - Field: ‘earlySignal’
[09:29:47.410]   - Field: ‘lazy’
[09:29:47.410]   - Field: ‘state’
[09:29:47.411] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.411] - Launch lazy future ...
[09:29:47.411] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[09:29:47.411] Packages needed by future strategies (n = 0): <none>
[09:29:47.412] {
[09:29:47.412]     {
[09:29:47.412]         {
[09:29:47.412]             ...future.startTime <- base::Sys.time()
[09:29:47.412]             {
[09:29:47.412]                 {
[09:29:47.412]                   {
[09:29:47.412]                     {
[09:29:47.412]                       {
[09:29:47.412]                         base::local({
[09:29:47.412]                           has_future <- base::requireNamespace("future", 
[09:29:47.412]                             quietly = TRUE)
[09:29:47.412]                           if (has_future) {
[09:29:47.412]                             ns <- base::getNamespace("future")
[09:29:47.412]                             version <- ns[[".package"]][["version"]]
[09:29:47.412]                             if (is.null(version)) 
[09:29:47.412]                               version <- utils::packageVersion("future")
[09:29:47.412]                           }
[09:29:47.412]                           else {
[09:29:47.412]                             version <- NULL
[09:29:47.412]                           }
[09:29:47.412]                           if (!has_future || version < "1.8.0") {
[09:29:47.412]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.412]                               "", base::R.version$version.string), 
[09:29:47.412]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.412]                                 base::R.version$platform, 8 * 
[09:29:47.412]                                   base::.Machine$sizeof.pointer), 
[09:29:47.412]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.412]                                 "release", "version")], collapse = " "), 
[09:29:47.412]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.412]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.412]                               info)
[09:29:47.412]                             info <- base::paste(info, collapse = "; ")
[09:29:47.412]                             if (!has_future) {
[09:29:47.412]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.412]                                 info)
[09:29:47.412]                             }
[09:29:47.412]                             else {
[09:29:47.412]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.412]                                 info, version)
[09:29:47.412]                             }
[09:29:47.412]                             base::stop(msg)
[09:29:47.412]                           }
[09:29:47.412]                         })
[09:29:47.412]                       }
[09:29:47.412]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.412]                       base::options(mc.cores = 1L)
[09:29:47.412]                     }
[09:29:47.412]                     base::local({
[09:29:47.412]                       for (pkg in c("stats", "future.apply")) {
[09:29:47.412]                         base::loadNamespace(pkg)
[09:29:47.412]                         base::library(pkg, character.only = TRUE)
[09:29:47.412]                       }
[09:29:47.412]                     })
[09:29:47.412]                   }
[09:29:47.412]                   ...future.strategy.old <- future::plan("list")
[09:29:47.412]                   options(future.plan = NULL)
[09:29:47.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.412]                 }
[09:29:47.412]                 ...future.workdir <- getwd()
[09:29:47.412]             }
[09:29:47.412]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.412]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.412]         }
[09:29:47.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.412]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.412]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.412]             base::names(...future.oldOptions))
[09:29:47.412]     }
[09:29:47.412]     if (FALSE) {
[09:29:47.412]     }
[09:29:47.412]     else {
[09:29:47.412]         if (TRUE) {
[09:29:47.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.412]                 open = "w")
[09:29:47.412]         }
[09:29:47.412]         else {
[09:29:47.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.412]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.412]         }
[09:29:47.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.412]             base::sink(type = "output", split = FALSE)
[09:29:47.412]             base::close(...future.stdout)
[09:29:47.412]         }, add = TRUE)
[09:29:47.412]     }
[09:29:47.412]     ...future.frame <- base::sys.nframe()
[09:29:47.412]     ...future.conditions <- base::list()
[09:29:47.412]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.412]     if (FALSE) {
[09:29:47.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.412]     }
[09:29:47.412]     ...future.result <- base::tryCatch({
[09:29:47.412]         base::withCallingHandlers({
[09:29:47.412]             ...future.value <- base::withVisible(base::local({
[09:29:47.412]                 withCallingHandlers({
[09:29:47.412]                   {
[09:29:47.412]                     do.call(function(...) {
[09:29:47.412]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.412]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.412]                         ...future.globals.maxSize)) {
[09:29:47.412]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.412]                         on.exit(options(oopts), add = TRUE)
[09:29:47.412]                       }
[09:29:47.412]                       {
[09:29:47.412]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.412]                           FUN = function(jj) {
[09:29:47.412]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.412]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.412]                           })
[09:29:47.412]                       }
[09:29:47.412]                     }, args = future.call.arguments)
[09:29:47.412]                   }
[09:29:47.412]                 }, immediateCondition = function(cond) {
[09:29:47.412]                   save_rds <- function (object, pathname, ...) 
[09:29:47.412]                   {
[09:29:47.412]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.412]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.412]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.412]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.412]                         fi_tmp[["mtime"]])
[09:29:47.412]                     }
[09:29:47.412]                     tryCatch({
[09:29:47.412]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.412]                     }, error = function(ex) {
[09:29:47.412]                       msg <- conditionMessage(ex)
[09:29:47.412]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.412]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.412]                         fi_tmp[["mtime"]], msg)
[09:29:47.412]                       ex$message <- msg
[09:29:47.412]                       stop(ex)
[09:29:47.412]                     })
[09:29:47.412]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.412]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.412]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.412]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.412]                       fi <- file.info(pathname)
[09:29:47.412]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.412]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.412]                         fi[["size"]], fi[["mtime"]])
[09:29:47.412]                       stop(msg)
[09:29:47.412]                     }
[09:29:47.412]                     invisible(pathname)
[09:29:47.412]                   }
[09:29:47.412]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.412]                     rootPath = tempdir()) 
[09:29:47.412]                   {
[09:29:47.412]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.412]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.412]                       tmpdir = path, fileext = ".rds")
[09:29:47.412]                     save_rds(obj, file)
[09:29:47.412]                   }
[09:29:47.412]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.412]                   {
[09:29:47.412]                     inherits <- base::inherits
[09:29:47.412]                     invokeRestart <- base::invokeRestart
[09:29:47.412]                     is.null <- base::is.null
[09:29:47.412]                     muffled <- FALSE
[09:29:47.412]                     if (inherits(cond, "message")) {
[09:29:47.412]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.412]                       if (muffled) 
[09:29:47.412]                         invokeRestart("muffleMessage")
[09:29:47.412]                     }
[09:29:47.412]                     else if (inherits(cond, "warning")) {
[09:29:47.412]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.412]                       if (muffled) 
[09:29:47.412]                         invokeRestart("muffleWarning")
[09:29:47.412]                     }
[09:29:47.412]                     else if (inherits(cond, "condition")) {
[09:29:47.412]                       if (!is.null(pattern)) {
[09:29:47.412]                         computeRestarts <- base::computeRestarts
[09:29:47.412]                         grepl <- base::grepl
[09:29:47.412]                         restarts <- computeRestarts(cond)
[09:29:47.412]                         for (restart in restarts) {
[09:29:47.412]                           name <- restart$name
[09:29:47.412]                           if (is.null(name)) 
[09:29:47.412]                             next
[09:29:47.412]                           if (!grepl(pattern, name)) 
[09:29:47.412]                             next
[09:29:47.412]                           invokeRestart(restart)
[09:29:47.412]                           muffled <- TRUE
[09:29:47.412]                           break
[09:29:47.412]                         }
[09:29:47.412]                       }
[09:29:47.412]                     }
[09:29:47.412]                     invisible(muffled)
[09:29:47.412]                   }
[09:29:47.412]                   muffleCondition(cond)
[09:29:47.412]                 })
[09:29:47.412]             }))
[09:29:47.412]             future::FutureResult(value = ...future.value$value, 
[09:29:47.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.412]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.412]                     ...future.globalenv.names))
[09:29:47.412]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.412]         }, condition = base::local({
[09:29:47.412]             c <- base::c
[09:29:47.412]             inherits <- base::inherits
[09:29:47.412]             invokeRestart <- base::invokeRestart
[09:29:47.412]             length <- base::length
[09:29:47.412]             list <- base::list
[09:29:47.412]             seq.int <- base::seq.int
[09:29:47.412]             signalCondition <- base::signalCondition
[09:29:47.412]             sys.calls <- base::sys.calls
[09:29:47.412]             `[[` <- base::`[[`
[09:29:47.412]             `+` <- base::`+`
[09:29:47.412]             `<<-` <- base::`<<-`
[09:29:47.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.412]                   3L)]
[09:29:47.412]             }
[09:29:47.412]             function(cond) {
[09:29:47.412]                 is_error <- inherits(cond, "error")
[09:29:47.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.412]                   NULL)
[09:29:47.412]                 if (is_error) {
[09:29:47.412]                   sessionInformation <- function() {
[09:29:47.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.412]                       search = base::search(), system = base::Sys.info())
[09:29:47.412]                   }
[09:29:47.412]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.412]                     cond$call), session = sessionInformation(), 
[09:29:47.412]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.412]                   signalCondition(cond)
[09:29:47.412]                 }
[09:29:47.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.412]                 "immediateCondition"))) {
[09:29:47.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.412]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.412]                   if (TRUE && !signal) {
[09:29:47.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.412]                     {
[09:29:47.412]                       inherits <- base::inherits
[09:29:47.412]                       invokeRestart <- base::invokeRestart
[09:29:47.412]                       is.null <- base::is.null
[09:29:47.412]                       muffled <- FALSE
[09:29:47.412]                       if (inherits(cond, "message")) {
[09:29:47.412]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.412]                         if (muffled) 
[09:29:47.412]                           invokeRestart("muffleMessage")
[09:29:47.412]                       }
[09:29:47.412]                       else if (inherits(cond, "warning")) {
[09:29:47.412]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.412]                         if (muffled) 
[09:29:47.412]                           invokeRestart("muffleWarning")
[09:29:47.412]                       }
[09:29:47.412]                       else if (inherits(cond, "condition")) {
[09:29:47.412]                         if (!is.null(pattern)) {
[09:29:47.412]                           computeRestarts <- base::computeRestarts
[09:29:47.412]                           grepl <- base::grepl
[09:29:47.412]                           restarts <- computeRestarts(cond)
[09:29:47.412]                           for (restart in restarts) {
[09:29:47.412]                             name <- restart$name
[09:29:47.412]                             if (is.null(name)) 
[09:29:47.412]                               next
[09:29:47.412]                             if (!grepl(pattern, name)) 
[09:29:47.412]                               next
[09:29:47.412]                             invokeRestart(restart)
[09:29:47.412]                             muffled <- TRUE
[09:29:47.412]                             break
[09:29:47.412]                           }
[09:29:47.412]                         }
[09:29:47.412]                       }
[09:29:47.412]                       invisible(muffled)
[09:29:47.412]                     }
[09:29:47.412]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.412]                   }
[09:29:47.412]                 }
[09:29:47.412]                 else {
[09:29:47.412]                   if (TRUE) {
[09:29:47.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.412]                     {
[09:29:47.412]                       inherits <- base::inherits
[09:29:47.412]                       invokeRestart <- base::invokeRestart
[09:29:47.412]                       is.null <- base::is.null
[09:29:47.412]                       muffled <- FALSE
[09:29:47.412]                       if (inherits(cond, "message")) {
[09:29:47.412]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.412]                         if (muffled) 
[09:29:47.412]                           invokeRestart("muffleMessage")
[09:29:47.412]                       }
[09:29:47.412]                       else if (inherits(cond, "warning")) {
[09:29:47.412]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.412]                         if (muffled) 
[09:29:47.412]                           invokeRestart("muffleWarning")
[09:29:47.412]                       }
[09:29:47.412]                       else if (inherits(cond, "condition")) {
[09:29:47.412]                         if (!is.null(pattern)) {
[09:29:47.412]                           computeRestarts <- base::computeRestarts
[09:29:47.412]                           grepl <- base::grepl
[09:29:47.412]                           restarts <- computeRestarts(cond)
[09:29:47.412]                           for (restart in restarts) {
[09:29:47.412]                             name <- restart$name
[09:29:47.412]                             if (is.null(name)) 
[09:29:47.412]                               next
[09:29:47.412]                             if (!grepl(pattern, name)) 
[09:29:47.412]                               next
[09:29:47.412]                             invokeRestart(restart)
[09:29:47.412]                             muffled <- TRUE
[09:29:47.412]                             break
[09:29:47.412]                           }
[09:29:47.412]                         }
[09:29:47.412]                       }
[09:29:47.412]                       invisible(muffled)
[09:29:47.412]                     }
[09:29:47.412]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.412]                   }
[09:29:47.412]                 }
[09:29:47.412]             }
[09:29:47.412]         }))
[09:29:47.412]     }, error = function(ex) {
[09:29:47.412]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.412]                 ...future.rng), started = ...future.startTime, 
[09:29:47.412]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.412]             version = "1.8"), class = "FutureResult")
[09:29:47.412]     }, finally = {
[09:29:47.412]         if (!identical(...future.workdir, getwd())) 
[09:29:47.412]             setwd(...future.workdir)
[09:29:47.412]         {
[09:29:47.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.412]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.412]             }
[09:29:47.412]             base::options(...future.oldOptions)
[09:29:47.412]             if (.Platform$OS.type == "windows") {
[09:29:47.412]                 old_names <- names(...future.oldEnvVars)
[09:29:47.412]                 envs <- base::Sys.getenv()
[09:29:47.412]                 names <- names(envs)
[09:29:47.412]                 common <- intersect(names, old_names)
[09:29:47.412]                 added <- setdiff(names, old_names)
[09:29:47.412]                 removed <- setdiff(old_names, names)
[09:29:47.412]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.412]                   envs[common]]
[09:29:47.412]                 NAMES <- toupper(changed)
[09:29:47.412]                 args <- list()
[09:29:47.412]                 for (kk in seq_along(NAMES)) {
[09:29:47.412]                   name <- changed[[kk]]
[09:29:47.412]                   NAME <- NAMES[[kk]]
[09:29:47.412]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.412]                     next
[09:29:47.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.412]                 }
[09:29:47.412]                 NAMES <- toupper(added)
[09:29:47.412]                 for (kk in seq_along(NAMES)) {
[09:29:47.412]                   name <- added[[kk]]
[09:29:47.412]                   NAME <- NAMES[[kk]]
[09:29:47.412]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.412]                     next
[09:29:47.412]                   args[[name]] <- ""
[09:29:47.412]                 }
[09:29:47.412]                 NAMES <- toupper(removed)
[09:29:47.412]                 for (kk in seq_along(NAMES)) {
[09:29:47.412]                   name <- removed[[kk]]
[09:29:47.412]                   NAME <- NAMES[[kk]]
[09:29:47.412]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.412]                     next
[09:29:47.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.412]                 }
[09:29:47.412]                 if (length(args) > 0) 
[09:29:47.412]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.412]             }
[09:29:47.412]             else {
[09:29:47.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.412]             }
[09:29:47.412]             {
[09:29:47.412]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.412]                   0L) {
[09:29:47.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.412]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.412]                   base::options(opts)
[09:29:47.412]                 }
[09:29:47.412]                 {
[09:29:47.412]                   {
[09:29:47.412]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.412]                     NULL
[09:29:47.412]                   }
[09:29:47.412]                   options(future.plan = NULL)
[09:29:47.412]                   if (is.na(NA_character_)) 
[09:29:47.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.412]                     .init = FALSE)
[09:29:47.412]                 }
[09:29:47.412]             }
[09:29:47.412]         }
[09:29:47.412]     })
[09:29:47.412]     if (TRUE) {
[09:29:47.412]         base::sink(type = "output", split = FALSE)
[09:29:47.412]         if (TRUE) {
[09:29:47.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.412]         }
[09:29:47.412]         else {
[09:29:47.412]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.412]         }
[09:29:47.412]         base::close(...future.stdout)
[09:29:47.412]         ...future.stdout <- NULL
[09:29:47.412]     }
[09:29:47.412]     ...future.result$conditions <- ...future.conditions
[09:29:47.412]     ...future.result$finished <- base::Sys.time()
[09:29:47.412]     ...future.result
[09:29:47.412] }
[09:29:47.415] assign_globals() ...
[09:29:47.415] List of 11
[09:29:47.415]  $ ...future.FUN            :function (x, ...)  
[09:29:47.415]  $ x_FUN                    :function (x, ...)  
[09:29:47.415]  $ times                    : int 5
[09:29:47.415]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.415]  $ stop_if_not              :function (...)  
[09:29:47.415]  $ dim                      : NULL
[09:29:47.415]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:47.415]  $ future.call.arguments    : list()
[09:29:47.415]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.415]  $ ...future.elements_ii    :List of 2
[09:29:47.415]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[09:29:47.415]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[09:29:47.415]  $ ...future.seeds_ii       : NULL
[09:29:47.415]  $ ...future.globals.maxSize: NULL
[09:29:47.415]  - attr(*, "where")=List of 11
[09:29:47.415]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.415]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:47.415]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:47.415]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:47.415]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:47.415]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:47.415]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:47.415]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.415]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.415]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.415]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.415]  - attr(*, "resolved")= logi FALSE
[09:29:47.415]  - attr(*, "total_size")= num 95528
[09:29:47.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.415]  - attr(*, "already-done")= logi TRUE
[09:29:47.424] - copied ‘...future.FUN’ to environment
[09:29:47.424] - copied ‘x_FUN’ to environment
[09:29:47.424] - copied ‘times’ to environment
[09:29:47.424] - copied ‘stopf’ to environment
[09:29:47.424] - copied ‘stop_if_not’ to environment
[09:29:47.425] - copied ‘dim’ to environment
[09:29:47.425] - copied ‘valid_types’ to environment
[09:29:47.425] - copied ‘future.call.arguments’ to environment
[09:29:47.425] - copied ‘...future.elements_ii’ to environment
[09:29:47.425] - copied ‘...future.seeds_ii’ to environment
[09:29:47.425] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.425] assign_globals() ... done
[09:29:47.425] requestCore(): workers = 2
[09:29:47.427] MulticoreFuture started
[09:29:47.428] - Launch lazy future ... done
[09:29:47.428] run() for ‘MulticoreFuture’ ... done
[09:29:47.428] Created future:
[09:29:47.429] plan(): Setting new future strategy stack:
[09:29:47.429] List of future strategies:
[09:29:47.429] 1. sequential:
[09:29:47.429]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.429]    - tweaked: FALSE
[09:29:47.429]    - call: NULL
[09:29:47.430] plan(): nbrOfWorkers() = 1
[09:29:47.433] plan(): Setting new future strategy stack:
[09:29:47.433] List of future strategies:
[09:29:47.433] 1. multicore:
[09:29:47.433]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.433]    - tweaked: FALSE
[09:29:47.433]    - call: plan(strategy)
[09:29:47.428] MulticoreFuture:
[09:29:47.428] Label: ‘future_vapply-2’
[09:29:47.428] Expression:
[09:29:47.428] {
[09:29:47.428]     do.call(function(...) {
[09:29:47.428]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.428]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.428]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.428]             on.exit(options(oopts), add = TRUE)
[09:29:47.428]         }
[09:29:47.428]         {
[09:29:47.428]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.428]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.428]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.428]             })
[09:29:47.428]         }
[09:29:47.428]     }, args = future.call.arguments)
[09:29:47.428] }
[09:29:47.428] Lazy evaluation: FALSE
[09:29:47.428] Asynchronous evaluation: TRUE
[09:29:47.428] Local evaluation: TRUE
[09:29:47.428] Environment: R_GlobalEnv
[09:29:47.428] Capture standard output: TRUE
[09:29:47.428] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.428] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:47.428] Packages: 2 packages (‘stats’, ‘future.apply’)
[09:29:47.428] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.428] Resolved: FALSE
[09:29:47.428] Value: <not collected>
[09:29:47.428] Conditions captured: <none>
[09:29:47.428] Early signaling: FALSE
[09:29:47.428] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.428] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.441] Chunk #2 of 2 ... DONE
[09:29:47.442] Launching 2 futures (chunks) ... DONE
[09:29:47.442] Resolving 2 futures (chunks) ...
[09:29:47.442] resolve() on list ...
[09:29:47.442]  recursive: 0
[09:29:47.442]  length: 2
[09:29:47.443] 
[09:29:47.443] Future #1
[09:29:47.443] result() for MulticoreFuture ...
[09:29:47.444] plan(): nbrOfWorkers() = 2
[09:29:47.447] result() for MulticoreFuture ...
[09:29:47.447] result() for MulticoreFuture ... done
[09:29:47.448] result() for MulticoreFuture ... done
[09:29:47.448] result() for MulticoreFuture ...
[09:29:47.448] result() for MulticoreFuture ... done
[09:29:47.448] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:47.449] - nx: 2
[09:29:47.449] - relay: TRUE
[09:29:47.449] - stdout: TRUE
[09:29:47.449] - signal: TRUE
[09:29:47.450] - resignal: FALSE
[09:29:47.450] - force: TRUE
[09:29:47.450] - relayed: [n=2] FALSE, FALSE
[09:29:47.450] - queued futures: [n=2] FALSE, FALSE
[09:29:47.451]  - until=1
[09:29:47.451]  - relaying element #1
[09:29:47.451] result() for MulticoreFuture ...
[09:29:47.451] result() for MulticoreFuture ... done
[09:29:47.452] result() for MulticoreFuture ...
[09:29:47.452] result() for MulticoreFuture ... done
[09:29:47.452] result() for MulticoreFuture ...
[09:29:47.453] result() for MulticoreFuture ... done
[09:29:47.453] result() for MulticoreFuture ...
[09:29:47.453] result() for MulticoreFuture ... done
[09:29:47.453] - relayed: [n=2] TRUE, FALSE
[09:29:47.454] - queued futures: [n=2] TRUE, FALSE
[09:29:47.454] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:47.454]  length: 1 (resolved future 1)
[09:29:47.455] Future #2
[09:29:47.455] result() for MulticoreFuture ...
[09:29:47.456] result() for MulticoreFuture ...
[09:29:47.456] result() for MulticoreFuture ... done
[09:29:47.456] result() for MulticoreFuture ... done
[09:29:47.457] result() for MulticoreFuture ...
[09:29:47.457] result() for MulticoreFuture ... done
[09:29:47.457] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:47.457] - nx: 2
[09:29:47.458] - relay: TRUE
[09:29:47.458] - stdout: TRUE
[09:29:47.458] - signal: TRUE
[09:29:47.458] - resignal: FALSE
[09:29:47.458] - force: TRUE
[09:29:47.458] - relayed: [n=2] TRUE, FALSE
[09:29:47.459] - queued futures: [n=2] TRUE, FALSE
[09:29:47.459]  - until=2
[09:29:47.459]  - relaying element #2
[09:29:47.459] result() for MulticoreFuture ...
[09:29:47.459] result() for MulticoreFuture ... done
[09:29:47.459] result() for MulticoreFuture ...
[09:29:47.459] result() for MulticoreFuture ... done
[09:29:47.460] result() for MulticoreFuture ...
[09:29:47.460] result() for MulticoreFuture ... done
[09:29:47.460] result() for MulticoreFuture ...
[09:29:47.460] result() for MulticoreFuture ... done
[09:29:47.460] - relayed: [n=2] TRUE, TRUE
[09:29:47.460] - queued futures: [n=2] TRUE, TRUE
[09:29:47.460] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:47.460]  length: 0 (resolved future 2)
[09:29:47.461] Relaying remaining futures
[09:29:47.461] signalConditionsASAP(NULL, pos=0) ...
[09:29:47.461] - nx: 2
[09:29:47.461] - relay: TRUE
[09:29:47.461] - stdout: TRUE
[09:29:47.461] - signal: TRUE
[09:29:47.461] - resignal: FALSE
[09:29:47.461] - force: TRUE
[09:29:47.461] - relayed: [n=2] TRUE, TRUE
[09:29:47.461] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:47.462] - relayed: [n=2] TRUE, TRUE
[09:29:47.462] - queued futures: [n=2] TRUE, TRUE
[09:29:47.462] signalConditionsASAP(NULL, pos=0) ... done
[09:29:47.462] resolve() on list ... DONE
[09:29:47.462] result() for MulticoreFuture ...
[09:29:47.462] result() for MulticoreFuture ... done
[09:29:47.462] result() for MulticoreFuture ...
[09:29:47.462] result() for MulticoreFuture ... done
[09:29:47.462] result() for MulticoreFuture ...
[09:29:47.463] result() for MulticoreFuture ... done
[09:29:47.463] result() for MulticoreFuture ...
[09:29:47.463] result() for MulticoreFuture ... done
[09:29:47.463]  - Number of value chunks collected: 2
[09:29:47.463] Resolving 2 futures (chunks) ... DONE
[09:29:47.463] Reducing values from 2 chunks ...
[09:29:47.463]  - Number of values collected after concatenation: 3
[09:29:47.463]  - Number of values expected: 3
[09:29:47.463] Reducing values from 2 chunks ... DONE
[09:29:47.463] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[09:29:47.465] future_lapply() ...
[09:29:47.473] Number of chunks: 2
[09:29:47.473] getGlobalsAndPackagesXApply() ...
[09:29:47.474]  - future.globals: TRUE
[09:29:47.474] getGlobalsAndPackages() ...
[09:29:47.474] Searching for globals...
[09:29:47.480] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[09:29:47.481] Searching for globals ... DONE
[09:29:47.481] Resolving globals: FALSE
[09:29:47.481] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[09:29:47.482] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[09:29:47.482] - globals: [1] ‘FUN’
[09:29:47.482] - packages: [1] ‘stats’
[09:29:47.482] getGlobalsAndPackages() ... DONE
[09:29:47.482]  - globals found/used: [n=1] ‘FUN’
[09:29:47.482]  - needed namespaces: [n=1] ‘stats’
[09:29:47.483] Finding globals ... DONE
[09:29:47.483]  - use_args: TRUE
[09:29:47.483]  - Getting '...' globals ...
[09:29:47.483] resolve() on list ...
[09:29:47.483]  recursive: 0
[09:29:47.483]  length: 1
[09:29:47.483]  elements: ‘...’
[09:29:47.483]  length: 0 (resolved future 1)
[09:29:47.484] resolve() on list ... DONE
[09:29:47.484]    - '...' content: [n=0] 
[09:29:47.484] List of 1
[09:29:47.484]  $ ...: list()
[09:29:47.484]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.484]  - attr(*, "where")=List of 1
[09:29:47.484]   ..$ ...:<environment: 0x561d346959d8> 
[09:29:47.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.484]  - attr(*, "resolved")= logi TRUE
[09:29:47.484]  - attr(*, "total_size")= num NA
[09:29:47.486]  - Getting '...' globals ... DONE
[09:29:47.486] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:29:47.486] List of 2
[09:29:47.486]  $ ...future.FUN:function (x, na.rm = TRUE)  
[09:29:47.486]  $ ...          : list()
[09:29:47.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.486]  - attr(*, "where")=List of 2
[09:29:47.486]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:47.486]   ..$ ...          :<environment: 0x561d346959d8> 
[09:29:47.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.486]  - attr(*, "resolved")= logi FALSE
[09:29:47.486]  - attr(*, "total_size")= num 46960
[09:29:47.489] Packages to be attached in all futures: [n=1] ‘stats’
[09:29:47.489] getGlobalsAndPackagesXApply() ... DONE
[09:29:47.489] Number of futures (= number of chunks): 2
[09:29:47.489] Launching 2 futures (chunks) ...
[09:29:47.489] Chunk #1 of 2 ...
[09:29:47.490]  - Finding globals in 'X' for chunk #1 ...
[09:29:47.490] getGlobalsAndPackages() ...
[09:29:47.490] Searching for globals...
[09:29:47.490] 
[09:29:47.490] Searching for globals ... DONE
[09:29:47.490] - globals: [0] <none>
[09:29:47.490] getGlobalsAndPackages() ... DONE
[09:29:47.490]    + additional globals found: [n=0] 
[09:29:47.490]    + additional namespaces needed: [n=0] 
[09:29:47.491]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:47.491]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.491]  - seeds: <none>
[09:29:47.491]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.491] getGlobalsAndPackages() ...
[09:29:47.491] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.491] Resolving globals: FALSE
[09:29:47.491] Tweak future expression to call with '...' arguments ...
[09:29:47.491] {
[09:29:47.491]     do.call(function(...) {
[09:29:47.491]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.491]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.491]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.491]             on.exit(options(oopts), add = TRUE)
[09:29:47.491]         }
[09:29:47.491]         {
[09:29:47.491]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.491]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.491]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.491]             })
[09:29:47.491]         }
[09:29:47.491]     }, args = future.call.arguments)
[09:29:47.491] }
[09:29:47.492] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.492] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.492] - packages: [1] ‘stats’
[09:29:47.492] getGlobalsAndPackages() ... DONE
[09:29:47.492] run() for ‘Future’ ...
[09:29:47.493] - state: ‘created’
[09:29:47.493] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.496] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.496] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.496]   - Field: ‘label’
[09:29:47.497]   - Field: ‘local’
[09:29:47.497]   - Field: ‘owner’
[09:29:47.497]   - Field: ‘envir’
[09:29:47.497]   - Field: ‘workers’
[09:29:47.497]   - Field: ‘packages’
[09:29:47.497]   - Field: ‘gc’
[09:29:47.497]   - Field: ‘job’
[09:29:47.497]   - Field: ‘conditions’
[09:29:47.497]   - Field: ‘expr’
[09:29:47.497]   - Field: ‘uuid’
[09:29:47.497]   - Field: ‘seed’
[09:29:47.497]   - Field: ‘version’
[09:29:47.498]   - Field: ‘result’
[09:29:47.498]   - Field: ‘asynchronous’
[09:29:47.498]   - Field: ‘calls’
[09:29:47.498]   - Field: ‘globals’
[09:29:47.498]   - Field: ‘stdout’
[09:29:47.498]   - Field: ‘earlySignal’
[09:29:47.498]   - Field: ‘lazy’
[09:29:47.498]   - Field: ‘state’
[09:29:47.498] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.498] - Launch lazy future ...
[09:29:47.499] Packages needed by the future expression (n = 1): ‘stats’
[09:29:47.499] Packages needed by future strategies (n = 0): <none>
[09:29:47.499] {
[09:29:47.499]     {
[09:29:47.499]         {
[09:29:47.499]             ...future.startTime <- base::Sys.time()
[09:29:47.499]             {
[09:29:47.499]                 {
[09:29:47.499]                   {
[09:29:47.499]                     {
[09:29:47.499]                       {
[09:29:47.499]                         base::local({
[09:29:47.499]                           has_future <- base::requireNamespace("future", 
[09:29:47.499]                             quietly = TRUE)
[09:29:47.499]                           if (has_future) {
[09:29:47.499]                             ns <- base::getNamespace("future")
[09:29:47.499]                             version <- ns[[".package"]][["version"]]
[09:29:47.499]                             if (is.null(version)) 
[09:29:47.499]                               version <- utils::packageVersion("future")
[09:29:47.499]                           }
[09:29:47.499]                           else {
[09:29:47.499]                             version <- NULL
[09:29:47.499]                           }
[09:29:47.499]                           if (!has_future || version < "1.8.0") {
[09:29:47.499]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.499]                               "", base::R.version$version.string), 
[09:29:47.499]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.499]                                 base::R.version$platform, 8 * 
[09:29:47.499]                                   base::.Machine$sizeof.pointer), 
[09:29:47.499]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.499]                                 "release", "version")], collapse = " "), 
[09:29:47.499]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.499]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.499]                               info)
[09:29:47.499]                             info <- base::paste(info, collapse = "; ")
[09:29:47.499]                             if (!has_future) {
[09:29:47.499]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.499]                                 info)
[09:29:47.499]                             }
[09:29:47.499]                             else {
[09:29:47.499]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.499]                                 info, version)
[09:29:47.499]                             }
[09:29:47.499]                             base::stop(msg)
[09:29:47.499]                           }
[09:29:47.499]                         })
[09:29:47.499]                       }
[09:29:47.499]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.499]                       base::options(mc.cores = 1L)
[09:29:47.499]                     }
[09:29:47.499]                     base::local({
[09:29:47.499]                       for (pkg in "stats") {
[09:29:47.499]                         base::loadNamespace(pkg)
[09:29:47.499]                         base::library(pkg, character.only = TRUE)
[09:29:47.499]                       }
[09:29:47.499]                     })
[09:29:47.499]                   }
[09:29:47.499]                   ...future.strategy.old <- future::plan("list")
[09:29:47.499]                   options(future.plan = NULL)
[09:29:47.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.499]                 }
[09:29:47.499]                 ...future.workdir <- getwd()
[09:29:47.499]             }
[09:29:47.499]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.499]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.499]         }
[09:29:47.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.499]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.499]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.499]             base::names(...future.oldOptions))
[09:29:47.499]     }
[09:29:47.499]     if (FALSE) {
[09:29:47.499]     }
[09:29:47.499]     else {
[09:29:47.499]         if (TRUE) {
[09:29:47.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.499]                 open = "w")
[09:29:47.499]         }
[09:29:47.499]         else {
[09:29:47.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.499]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.499]         }
[09:29:47.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.499]             base::sink(type = "output", split = FALSE)
[09:29:47.499]             base::close(...future.stdout)
[09:29:47.499]         }, add = TRUE)
[09:29:47.499]     }
[09:29:47.499]     ...future.frame <- base::sys.nframe()
[09:29:47.499]     ...future.conditions <- base::list()
[09:29:47.499]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.499]     if (FALSE) {
[09:29:47.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.499]     }
[09:29:47.499]     ...future.result <- base::tryCatch({
[09:29:47.499]         base::withCallingHandlers({
[09:29:47.499]             ...future.value <- base::withVisible(base::local({
[09:29:47.499]                 withCallingHandlers({
[09:29:47.499]                   {
[09:29:47.499]                     do.call(function(...) {
[09:29:47.499]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.499]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.499]                         ...future.globals.maxSize)) {
[09:29:47.499]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.499]                         on.exit(options(oopts), add = TRUE)
[09:29:47.499]                       }
[09:29:47.499]                       {
[09:29:47.499]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.499]                           FUN = function(jj) {
[09:29:47.499]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.499]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.499]                           })
[09:29:47.499]                       }
[09:29:47.499]                     }, args = future.call.arguments)
[09:29:47.499]                   }
[09:29:47.499]                 }, immediateCondition = function(cond) {
[09:29:47.499]                   save_rds <- function (object, pathname, ...) 
[09:29:47.499]                   {
[09:29:47.499]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.499]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.499]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.499]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.499]                         fi_tmp[["mtime"]])
[09:29:47.499]                     }
[09:29:47.499]                     tryCatch({
[09:29:47.499]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.499]                     }, error = function(ex) {
[09:29:47.499]                       msg <- conditionMessage(ex)
[09:29:47.499]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.499]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.499]                         fi_tmp[["mtime"]], msg)
[09:29:47.499]                       ex$message <- msg
[09:29:47.499]                       stop(ex)
[09:29:47.499]                     })
[09:29:47.499]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.499]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.499]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.499]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.499]                       fi <- file.info(pathname)
[09:29:47.499]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.499]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.499]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.499]                         fi[["size"]], fi[["mtime"]])
[09:29:47.499]                       stop(msg)
[09:29:47.499]                     }
[09:29:47.499]                     invisible(pathname)
[09:29:47.499]                   }
[09:29:47.499]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.499]                     rootPath = tempdir()) 
[09:29:47.499]                   {
[09:29:47.499]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.499]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.499]                       tmpdir = path, fileext = ".rds")
[09:29:47.499]                     save_rds(obj, file)
[09:29:47.499]                   }
[09:29:47.499]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.499]                   {
[09:29:47.499]                     inherits <- base::inherits
[09:29:47.499]                     invokeRestart <- base::invokeRestart
[09:29:47.499]                     is.null <- base::is.null
[09:29:47.499]                     muffled <- FALSE
[09:29:47.499]                     if (inherits(cond, "message")) {
[09:29:47.499]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.499]                       if (muffled) 
[09:29:47.499]                         invokeRestart("muffleMessage")
[09:29:47.499]                     }
[09:29:47.499]                     else if (inherits(cond, "warning")) {
[09:29:47.499]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.499]                       if (muffled) 
[09:29:47.499]                         invokeRestart("muffleWarning")
[09:29:47.499]                     }
[09:29:47.499]                     else if (inherits(cond, "condition")) {
[09:29:47.499]                       if (!is.null(pattern)) {
[09:29:47.499]                         computeRestarts <- base::computeRestarts
[09:29:47.499]                         grepl <- base::grepl
[09:29:47.499]                         restarts <- computeRestarts(cond)
[09:29:47.499]                         for (restart in restarts) {
[09:29:47.499]                           name <- restart$name
[09:29:47.499]                           if (is.null(name)) 
[09:29:47.499]                             next
[09:29:47.499]                           if (!grepl(pattern, name)) 
[09:29:47.499]                             next
[09:29:47.499]                           invokeRestart(restart)
[09:29:47.499]                           muffled <- TRUE
[09:29:47.499]                           break
[09:29:47.499]                         }
[09:29:47.499]                       }
[09:29:47.499]                     }
[09:29:47.499]                     invisible(muffled)
[09:29:47.499]                   }
[09:29:47.499]                   muffleCondition(cond)
[09:29:47.499]                 })
[09:29:47.499]             }))
[09:29:47.499]             future::FutureResult(value = ...future.value$value, 
[09:29:47.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.499]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.499]                     ...future.globalenv.names))
[09:29:47.499]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.499]         }, condition = base::local({
[09:29:47.499]             c <- base::c
[09:29:47.499]             inherits <- base::inherits
[09:29:47.499]             invokeRestart <- base::invokeRestart
[09:29:47.499]             length <- base::length
[09:29:47.499]             list <- base::list
[09:29:47.499]             seq.int <- base::seq.int
[09:29:47.499]             signalCondition <- base::signalCondition
[09:29:47.499]             sys.calls <- base::sys.calls
[09:29:47.499]             `[[` <- base::`[[`
[09:29:47.499]             `+` <- base::`+`
[09:29:47.499]             `<<-` <- base::`<<-`
[09:29:47.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.499]                   3L)]
[09:29:47.499]             }
[09:29:47.499]             function(cond) {
[09:29:47.499]                 is_error <- inherits(cond, "error")
[09:29:47.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.499]                   NULL)
[09:29:47.499]                 if (is_error) {
[09:29:47.499]                   sessionInformation <- function() {
[09:29:47.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.499]                       search = base::search(), system = base::Sys.info())
[09:29:47.499]                   }
[09:29:47.499]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.499]                     cond$call), session = sessionInformation(), 
[09:29:47.499]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.499]                   signalCondition(cond)
[09:29:47.499]                 }
[09:29:47.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.499]                 "immediateCondition"))) {
[09:29:47.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.499]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.499]                   if (TRUE && !signal) {
[09:29:47.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.499]                     {
[09:29:47.499]                       inherits <- base::inherits
[09:29:47.499]                       invokeRestart <- base::invokeRestart
[09:29:47.499]                       is.null <- base::is.null
[09:29:47.499]                       muffled <- FALSE
[09:29:47.499]                       if (inherits(cond, "message")) {
[09:29:47.499]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.499]                         if (muffled) 
[09:29:47.499]                           invokeRestart("muffleMessage")
[09:29:47.499]                       }
[09:29:47.499]                       else if (inherits(cond, "warning")) {
[09:29:47.499]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.499]                         if (muffled) 
[09:29:47.499]                           invokeRestart("muffleWarning")
[09:29:47.499]                       }
[09:29:47.499]                       else if (inherits(cond, "condition")) {
[09:29:47.499]                         if (!is.null(pattern)) {
[09:29:47.499]                           computeRestarts <- base::computeRestarts
[09:29:47.499]                           grepl <- base::grepl
[09:29:47.499]                           restarts <- computeRestarts(cond)
[09:29:47.499]                           for (restart in restarts) {
[09:29:47.499]                             name <- restart$name
[09:29:47.499]                             if (is.null(name)) 
[09:29:47.499]                               next
[09:29:47.499]                             if (!grepl(pattern, name)) 
[09:29:47.499]                               next
[09:29:47.499]                             invokeRestart(restart)
[09:29:47.499]                             muffled <- TRUE
[09:29:47.499]                             break
[09:29:47.499]                           }
[09:29:47.499]                         }
[09:29:47.499]                       }
[09:29:47.499]                       invisible(muffled)
[09:29:47.499]                     }
[09:29:47.499]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.499]                   }
[09:29:47.499]                 }
[09:29:47.499]                 else {
[09:29:47.499]                   if (TRUE) {
[09:29:47.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.499]                     {
[09:29:47.499]                       inherits <- base::inherits
[09:29:47.499]                       invokeRestart <- base::invokeRestart
[09:29:47.499]                       is.null <- base::is.null
[09:29:47.499]                       muffled <- FALSE
[09:29:47.499]                       if (inherits(cond, "message")) {
[09:29:47.499]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.499]                         if (muffled) 
[09:29:47.499]                           invokeRestart("muffleMessage")
[09:29:47.499]                       }
[09:29:47.499]                       else if (inherits(cond, "warning")) {
[09:29:47.499]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.499]                         if (muffled) 
[09:29:47.499]                           invokeRestart("muffleWarning")
[09:29:47.499]                       }
[09:29:47.499]                       else if (inherits(cond, "condition")) {
[09:29:47.499]                         if (!is.null(pattern)) {
[09:29:47.499]                           computeRestarts <- base::computeRestarts
[09:29:47.499]                           grepl <- base::grepl
[09:29:47.499]                           restarts <- computeRestarts(cond)
[09:29:47.499]                           for (restart in restarts) {
[09:29:47.499]                             name <- restart$name
[09:29:47.499]                             if (is.null(name)) 
[09:29:47.499]                               next
[09:29:47.499]                             if (!grepl(pattern, name)) 
[09:29:47.499]                               next
[09:29:47.499]                             invokeRestart(restart)
[09:29:47.499]                             muffled <- TRUE
[09:29:47.499]                             break
[09:29:47.499]                           }
[09:29:47.499]                         }
[09:29:47.499]                       }
[09:29:47.499]                       invisible(muffled)
[09:29:47.499]                     }
[09:29:47.499]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.499]                   }
[09:29:47.499]                 }
[09:29:47.499]             }
[09:29:47.499]         }))
[09:29:47.499]     }, error = function(ex) {
[09:29:47.499]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.499]                 ...future.rng), started = ...future.startTime, 
[09:29:47.499]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.499]             version = "1.8"), class = "FutureResult")
[09:29:47.499]     }, finally = {
[09:29:47.499]         if (!identical(...future.workdir, getwd())) 
[09:29:47.499]             setwd(...future.workdir)
[09:29:47.499]         {
[09:29:47.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.499]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.499]             }
[09:29:47.499]             base::options(...future.oldOptions)
[09:29:47.499]             if (.Platform$OS.type == "windows") {
[09:29:47.499]                 old_names <- names(...future.oldEnvVars)
[09:29:47.499]                 envs <- base::Sys.getenv()
[09:29:47.499]                 names <- names(envs)
[09:29:47.499]                 common <- intersect(names, old_names)
[09:29:47.499]                 added <- setdiff(names, old_names)
[09:29:47.499]                 removed <- setdiff(old_names, names)
[09:29:47.499]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.499]                   envs[common]]
[09:29:47.499]                 NAMES <- toupper(changed)
[09:29:47.499]                 args <- list()
[09:29:47.499]                 for (kk in seq_along(NAMES)) {
[09:29:47.499]                   name <- changed[[kk]]
[09:29:47.499]                   NAME <- NAMES[[kk]]
[09:29:47.499]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.499]                     next
[09:29:47.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.499]                 }
[09:29:47.499]                 NAMES <- toupper(added)
[09:29:47.499]                 for (kk in seq_along(NAMES)) {
[09:29:47.499]                   name <- added[[kk]]
[09:29:47.499]                   NAME <- NAMES[[kk]]
[09:29:47.499]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.499]                     next
[09:29:47.499]                   args[[name]] <- ""
[09:29:47.499]                 }
[09:29:47.499]                 NAMES <- toupper(removed)
[09:29:47.499]                 for (kk in seq_along(NAMES)) {
[09:29:47.499]                   name <- removed[[kk]]
[09:29:47.499]                   NAME <- NAMES[[kk]]
[09:29:47.499]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.499]                     next
[09:29:47.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.499]                 }
[09:29:47.499]                 if (length(args) > 0) 
[09:29:47.499]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.499]             }
[09:29:47.499]             else {
[09:29:47.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.499]             }
[09:29:47.499]             {
[09:29:47.499]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.499]                   0L) {
[09:29:47.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.499]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.499]                   base::options(opts)
[09:29:47.499]                 }
[09:29:47.499]                 {
[09:29:47.499]                   {
[09:29:47.499]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.499]                     NULL
[09:29:47.499]                   }
[09:29:47.499]                   options(future.plan = NULL)
[09:29:47.499]                   if (is.na(NA_character_)) 
[09:29:47.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.499]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.499]                     .init = FALSE)
[09:29:47.499]                 }
[09:29:47.499]             }
[09:29:47.499]         }
[09:29:47.499]     })
[09:29:47.499]     if (TRUE) {
[09:29:47.499]         base::sink(type = "output", split = FALSE)
[09:29:47.499]         if (TRUE) {
[09:29:47.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.499]         }
[09:29:47.499]         else {
[09:29:47.499]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.499]         }
[09:29:47.499]         base::close(...future.stdout)
[09:29:47.499]         ...future.stdout <- NULL
[09:29:47.499]     }
[09:29:47.499]     ...future.result$conditions <- ...future.conditions
[09:29:47.499]     ...future.result$finished <- base::Sys.time()
[09:29:47.499]     ...future.result
[09:29:47.499] }
[09:29:47.503] assign_globals() ...
[09:29:47.503] List of 5
[09:29:47.503]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[09:29:47.503]  $ future.call.arguments    : list()
[09:29:47.503]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.503]  $ ...future.elements_ii    :List of 4
[09:29:47.503]   ..$ : int [1:3] 1 2 3
[09:29:47.503]   ..$ : int [1:4] 1 2 3 4
[09:29:47.503]   ..$ : int [1:5] 1 2 3 4 5
[09:29:47.503]   ..$ : int [1:6] 1 2 3 4 5 6
[09:29:47.503]  $ ...future.seeds_ii       : NULL
[09:29:47.503]  $ ...future.globals.maxSize: NULL
[09:29:47.503]  - attr(*, "where")=List of 5
[09:29:47.503]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.503]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.503]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.503]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.503]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.503]  - attr(*, "resolved")= logi FALSE
[09:29:47.503]  - attr(*, "total_size")= num 46960
[09:29:47.503]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.503]  - attr(*, "already-done")= logi TRUE
[09:29:47.509] - copied ‘...future.FUN’ to environment
[09:29:47.509] - copied ‘future.call.arguments’ to environment
[09:29:47.509] - copied ‘...future.elements_ii’ to environment
[09:29:47.509] - copied ‘...future.seeds_ii’ to environment
[09:29:47.509] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.509] assign_globals() ... done
[09:29:47.509] requestCore(): workers = 2
[09:29:47.511] MulticoreFuture started
[09:29:47.512] - Launch lazy future ... done
[09:29:47.512] run() for ‘MulticoreFuture’ ... done
[09:29:47.512] Created future:
[09:29:47.513] plan(): Setting new future strategy stack:
[09:29:47.513] List of future strategies:
[09:29:47.513] 1. sequential:
[09:29:47.513]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.513]    - tweaked: FALSE
[09:29:47.513]    - call: NULL
[09:29:47.514] plan(): nbrOfWorkers() = 1
[09:29:47.516] plan(): Setting new future strategy stack:
[09:29:47.516] List of future strategies:
[09:29:47.516] 1. multicore:
[09:29:47.516]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.516]    - tweaked: FALSE
[09:29:47.516]    - call: plan(strategy)
[09:29:47.521] plan(): nbrOfWorkers() = 2
[09:29:47.512] MulticoreFuture:
[09:29:47.512] Label: ‘future_sapply-1’
[09:29:47.512] Expression:
[09:29:47.512] {
[09:29:47.512]     do.call(function(...) {
[09:29:47.512]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.512]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.512]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.512]             on.exit(options(oopts), add = TRUE)
[09:29:47.512]         }
[09:29:47.512]         {
[09:29:47.512]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.512]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.512]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.512]             })
[09:29:47.512]         }
[09:29:47.512]     }, args = future.call.arguments)
[09:29:47.512] }
[09:29:47.512] Lazy evaluation: FALSE
[09:29:47.512] Asynchronous evaluation: TRUE
[09:29:47.512] Local evaluation: TRUE
[09:29:47.512] Environment: R_GlobalEnv
[09:29:47.512] Capture standard output: TRUE
[09:29:47.512] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.512] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:47.512] Packages: 1 packages (‘stats’)
[09:29:47.512] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.512] Resolved: TRUE
[09:29:47.512] Value: <not collected>
[09:29:47.512] Conditions captured: <none>
[09:29:47.512] Early signaling: FALSE
[09:29:47.512] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.512] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.522] Chunk #1 of 2 ... DONE
[09:29:47.522] Chunk #2 of 2 ...
[09:29:47.523]  - Finding globals in 'X' for chunk #2 ...
[09:29:47.523] getGlobalsAndPackages() ...
[09:29:47.523] Searching for globals...
[09:29:47.524] 
[09:29:47.524] Searching for globals ... DONE
[09:29:47.524] - globals: [0] <none>
[09:29:47.524] getGlobalsAndPackages() ... DONE
[09:29:47.524]    + additional globals found: [n=0] 
[09:29:47.524]    + additional namespaces needed: [n=0] 
[09:29:47.524]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:47.524]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.525]  - seeds: <none>
[09:29:47.525]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.525] getGlobalsAndPackages() ...
[09:29:47.525] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.525] Resolving globals: FALSE
[09:29:47.525] Tweak future expression to call with '...' arguments ...
[09:29:47.526] {
[09:29:47.526]     do.call(function(...) {
[09:29:47.526]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.526]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.526]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.526]             on.exit(options(oopts), add = TRUE)
[09:29:47.526]         }
[09:29:47.526]         {
[09:29:47.526]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.526]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.526]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.526]             })
[09:29:47.526]         }
[09:29:47.526]     }, args = future.call.arguments)
[09:29:47.526] }
[09:29:47.526] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.527] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.527] - packages: [1] ‘stats’
[09:29:47.527] getGlobalsAndPackages() ... DONE
[09:29:47.528] run() for ‘Future’ ...
[09:29:47.528] - state: ‘created’
[09:29:47.528] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.532] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.533] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.533]   - Field: ‘label’
[09:29:47.533]   - Field: ‘local’
[09:29:47.533]   - Field: ‘owner’
[09:29:47.533]   - Field: ‘envir’
[09:29:47.533]   - Field: ‘workers’
[09:29:47.533]   - Field: ‘packages’
[09:29:47.534]   - Field: ‘gc’
[09:29:47.534]   - Field: ‘job’
[09:29:47.534]   - Field: ‘conditions’
[09:29:47.534]   - Field: ‘expr’
[09:29:47.534]   - Field: ‘uuid’
[09:29:47.534]   - Field: ‘seed’
[09:29:47.534]   - Field: ‘version’
[09:29:47.535]   - Field: ‘result’
[09:29:47.535]   - Field: ‘asynchronous’
[09:29:47.535]   - Field: ‘calls’
[09:29:47.535]   - Field: ‘globals’
[09:29:47.535]   - Field: ‘stdout’
[09:29:47.535]   - Field: ‘earlySignal’
[09:29:47.535]   - Field: ‘lazy’
[09:29:47.536]   - Field: ‘state’
[09:29:47.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.536] - Launch lazy future ...
[09:29:47.536] Packages needed by the future expression (n = 1): ‘stats’
[09:29:47.537] Packages needed by future strategies (n = 0): <none>
[09:29:47.537] {
[09:29:47.537]     {
[09:29:47.537]         {
[09:29:47.537]             ...future.startTime <- base::Sys.time()
[09:29:47.537]             {
[09:29:47.537]                 {
[09:29:47.537]                   {
[09:29:47.537]                     {
[09:29:47.537]                       {
[09:29:47.537]                         base::local({
[09:29:47.537]                           has_future <- base::requireNamespace("future", 
[09:29:47.537]                             quietly = TRUE)
[09:29:47.537]                           if (has_future) {
[09:29:47.537]                             ns <- base::getNamespace("future")
[09:29:47.537]                             version <- ns[[".package"]][["version"]]
[09:29:47.537]                             if (is.null(version)) 
[09:29:47.537]                               version <- utils::packageVersion("future")
[09:29:47.537]                           }
[09:29:47.537]                           else {
[09:29:47.537]                             version <- NULL
[09:29:47.537]                           }
[09:29:47.537]                           if (!has_future || version < "1.8.0") {
[09:29:47.537]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.537]                               "", base::R.version$version.string), 
[09:29:47.537]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.537]                                 base::R.version$platform, 8 * 
[09:29:47.537]                                   base::.Machine$sizeof.pointer), 
[09:29:47.537]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.537]                                 "release", "version")], collapse = " "), 
[09:29:47.537]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.537]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.537]                               info)
[09:29:47.537]                             info <- base::paste(info, collapse = "; ")
[09:29:47.537]                             if (!has_future) {
[09:29:47.537]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.537]                                 info)
[09:29:47.537]                             }
[09:29:47.537]                             else {
[09:29:47.537]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.537]                                 info, version)
[09:29:47.537]                             }
[09:29:47.537]                             base::stop(msg)
[09:29:47.537]                           }
[09:29:47.537]                         })
[09:29:47.537]                       }
[09:29:47.537]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.537]                       base::options(mc.cores = 1L)
[09:29:47.537]                     }
[09:29:47.537]                     base::local({
[09:29:47.537]                       for (pkg in "stats") {
[09:29:47.537]                         base::loadNamespace(pkg)
[09:29:47.537]                         base::library(pkg, character.only = TRUE)
[09:29:47.537]                       }
[09:29:47.537]                     })
[09:29:47.537]                   }
[09:29:47.537]                   ...future.strategy.old <- future::plan("list")
[09:29:47.537]                   options(future.plan = NULL)
[09:29:47.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.537]                 }
[09:29:47.537]                 ...future.workdir <- getwd()
[09:29:47.537]             }
[09:29:47.537]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.537]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.537]         }
[09:29:47.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.537]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.537]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.537]             base::names(...future.oldOptions))
[09:29:47.537]     }
[09:29:47.537]     if (FALSE) {
[09:29:47.537]     }
[09:29:47.537]     else {
[09:29:47.537]         if (TRUE) {
[09:29:47.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.537]                 open = "w")
[09:29:47.537]         }
[09:29:47.537]         else {
[09:29:47.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.537]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.537]         }
[09:29:47.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.537]             base::sink(type = "output", split = FALSE)
[09:29:47.537]             base::close(...future.stdout)
[09:29:47.537]         }, add = TRUE)
[09:29:47.537]     }
[09:29:47.537]     ...future.frame <- base::sys.nframe()
[09:29:47.537]     ...future.conditions <- base::list()
[09:29:47.537]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.537]     if (FALSE) {
[09:29:47.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.537]     }
[09:29:47.537]     ...future.result <- base::tryCatch({
[09:29:47.537]         base::withCallingHandlers({
[09:29:47.537]             ...future.value <- base::withVisible(base::local({
[09:29:47.537]                 withCallingHandlers({
[09:29:47.537]                   {
[09:29:47.537]                     do.call(function(...) {
[09:29:47.537]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.537]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.537]                         ...future.globals.maxSize)) {
[09:29:47.537]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.537]                         on.exit(options(oopts), add = TRUE)
[09:29:47.537]                       }
[09:29:47.537]                       {
[09:29:47.537]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.537]                           FUN = function(jj) {
[09:29:47.537]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.537]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.537]                           })
[09:29:47.537]                       }
[09:29:47.537]                     }, args = future.call.arguments)
[09:29:47.537]                   }
[09:29:47.537]                 }, immediateCondition = function(cond) {
[09:29:47.537]                   save_rds <- function (object, pathname, ...) 
[09:29:47.537]                   {
[09:29:47.537]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.537]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.537]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.537]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.537]                         fi_tmp[["mtime"]])
[09:29:47.537]                     }
[09:29:47.537]                     tryCatch({
[09:29:47.537]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.537]                     }, error = function(ex) {
[09:29:47.537]                       msg <- conditionMessage(ex)
[09:29:47.537]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.537]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.537]                         fi_tmp[["mtime"]], msg)
[09:29:47.537]                       ex$message <- msg
[09:29:47.537]                       stop(ex)
[09:29:47.537]                     })
[09:29:47.537]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.537]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.537]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.537]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.537]                       fi <- file.info(pathname)
[09:29:47.537]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.537]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.537]                         fi[["size"]], fi[["mtime"]])
[09:29:47.537]                       stop(msg)
[09:29:47.537]                     }
[09:29:47.537]                     invisible(pathname)
[09:29:47.537]                   }
[09:29:47.537]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.537]                     rootPath = tempdir()) 
[09:29:47.537]                   {
[09:29:47.537]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.537]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.537]                       tmpdir = path, fileext = ".rds")
[09:29:47.537]                     save_rds(obj, file)
[09:29:47.537]                   }
[09:29:47.537]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.537]                   {
[09:29:47.537]                     inherits <- base::inherits
[09:29:47.537]                     invokeRestart <- base::invokeRestart
[09:29:47.537]                     is.null <- base::is.null
[09:29:47.537]                     muffled <- FALSE
[09:29:47.537]                     if (inherits(cond, "message")) {
[09:29:47.537]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.537]                       if (muffled) 
[09:29:47.537]                         invokeRestart("muffleMessage")
[09:29:47.537]                     }
[09:29:47.537]                     else if (inherits(cond, "warning")) {
[09:29:47.537]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.537]                       if (muffled) 
[09:29:47.537]                         invokeRestart("muffleWarning")
[09:29:47.537]                     }
[09:29:47.537]                     else if (inherits(cond, "condition")) {
[09:29:47.537]                       if (!is.null(pattern)) {
[09:29:47.537]                         computeRestarts <- base::computeRestarts
[09:29:47.537]                         grepl <- base::grepl
[09:29:47.537]                         restarts <- computeRestarts(cond)
[09:29:47.537]                         for (restart in restarts) {
[09:29:47.537]                           name <- restart$name
[09:29:47.537]                           if (is.null(name)) 
[09:29:47.537]                             next
[09:29:47.537]                           if (!grepl(pattern, name)) 
[09:29:47.537]                             next
[09:29:47.537]                           invokeRestart(restart)
[09:29:47.537]                           muffled <- TRUE
[09:29:47.537]                           break
[09:29:47.537]                         }
[09:29:47.537]                       }
[09:29:47.537]                     }
[09:29:47.537]                     invisible(muffled)
[09:29:47.537]                   }
[09:29:47.537]                   muffleCondition(cond)
[09:29:47.537]                 })
[09:29:47.537]             }))
[09:29:47.537]             future::FutureResult(value = ...future.value$value, 
[09:29:47.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.537]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.537]                     ...future.globalenv.names))
[09:29:47.537]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.537]         }, condition = base::local({
[09:29:47.537]             c <- base::c
[09:29:47.537]             inherits <- base::inherits
[09:29:47.537]             invokeRestart <- base::invokeRestart
[09:29:47.537]             length <- base::length
[09:29:47.537]             list <- base::list
[09:29:47.537]             seq.int <- base::seq.int
[09:29:47.537]             signalCondition <- base::signalCondition
[09:29:47.537]             sys.calls <- base::sys.calls
[09:29:47.537]             `[[` <- base::`[[`
[09:29:47.537]             `+` <- base::`+`
[09:29:47.537]             `<<-` <- base::`<<-`
[09:29:47.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.537]                   3L)]
[09:29:47.537]             }
[09:29:47.537]             function(cond) {
[09:29:47.537]                 is_error <- inherits(cond, "error")
[09:29:47.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.537]                   NULL)
[09:29:47.537]                 if (is_error) {
[09:29:47.537]                   sessionInformation <- function() {
[09:29:47.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.537]                       search = base::search(), system = base::Sys.info())
[09:29:47.537]                   }
[09:29:47.537]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.537]                     cond$call), session = sessionInformation(), 
[09:29:47.537]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.537]                   signalCondition(cond)
[09:29:47.537]                 }
[09:29:47.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.537]                 "immediateCondition"))) {
[09:29:47.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.537]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.537]                   if (TRUE && !signal) {
[09:29:47.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.537]                     {
[09:29:47.537]                       inherits <- base::inherits
[09:29:47.537]                       invokeRestart <- base::invokeRestart
[09:29:47.537]                       is.null <- base::is.null
[09:29:47.537]                       muffled <- FALSE
[09:29:47.537]                       if (inherits(cond, "message")) {
[09:29:47.537]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.537]                         if (muffled) 
[09:29:47.537]                           invokeRestart("muffleMessage")
[09:29:47.537]                       }
[09:29:47.537]                       else if (inherits(cond, "warning")) {
[09:29:47.537]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.537]                         if (muffled) 
[09:29:47.537]                           invokeRestart("muffleWarning")
[09:29:47.537]                       }
[09:29:47.537]                       else if (inherits(cond, "condition")) {
[09:29:47.537]                         if (!is.null(pattern)) {
[09:29:47.537]                           computeRestarts <- base::computeRestarts
[09:29:47.537]                           grepl <- base::grepl
[09:29:47.537]                           restarts <- computeRestarts(cond)
[09:29:47.537]                           for (restart in restarts) {
[09:29:47.537]                             name <- restart$name
[09:29:47.537]                             if (is.null(name)) 
[09:29:47.537]                               next
[09:29:47.537]                             if (!grepl(pattern, name)) 
[09:29:47.537]                               next
[09:29:47.537]                             invokeRestart(restart)
[09:29:47.537]                             muffled <- TRUE
[09:29:47.537]                             break
[09:29:47.537]                           }
[09:29:47.537]                         }
[09:29:47.537]                       }
[09:29:47.537]                       invisible(muffled)
[09:29:47.537]                     }
[09:29:47.537]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.537]                   }
[09:29:47.537]                 }
[09:29:47.537]                 else {
[09:29:47.537]                   if (TRUE) {
[09:29:47.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.537]                     {
[09:29:47.537]                       inherits <- base::inherits
[09:29:47.537]                       invokeRestart <- base::invokeRestart
[09:29:47.537]                       is.null <- base::is.null
[09:29:47.537]                       muffled <- FALSE
[09:29:47.537]                       if (inherits(cond, "message")) {
[09:29:47.537]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.537]                         if (muffled) 
[09:29:47.537]                           invokeRestart("muffleMessage")
[09:29:47.537]                       }
[09:29:47.537]                       else if (inherits(cond, "warning")) {
[09:29:47.537]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.537]                         if (muffled) 
[09:29:47.537]                           invokeRestart("muffleWarning")
[09:29:47.537]                       }
[09:29:47.537]                       else if (inherits(cond, "condition")) {
[09:29:47.537]                         if (!is.null(pattern)) {
[09:29:47.537]                           computeRestarts <- base::computeRestarts
[09:29:47.537]                           grepl <- base::grepl
[09:29:47.537]                           restarts <- computeRestarts(cond)
[09:29:47.537]                           for (restart in restarts) {
[09:29:47.537]                             name <- restart$name
[09:29:47.537]                             if (is.null(name)) 
[09:29:47.537]                               next
[09:29:47.537]                             if (!grepl(pattern, name)) 
[09:29:47.537]                               next
[09:29:47.537]                             invokeRestart(restart)
[09:29:47.537]                             muffled <- TRUE
[09:29:47.537]                             break
[09:29:47.537]                           }
[09:29:47.537]                         }
[09:29:47.537]                       }
[09:29:47.537]                       invisible(muffled)
[09:29:47.537]                     }
[09:29:47.537]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.537]                   }
[09:29:47.537]                 }
[09:29:47.537]             }
[09:29:47.537]         }))
[09:29:47.537]     }, error = function(ex) {
[09:29:47.537]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.537]                 ...future.rng), started = ...future.startTime, 
[09:29:47.537]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.537]             version = "1.8"), class = "FutureResult")
[09:29:47.537]     }, finally = {
[09:29:47.537]         if (!identical(...future.workdir, getwd())) 
[09:29:47.537]             setwd(...future.workdir)
[09:29:47.537]         {
[09:29:47.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.537]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.537]             }
[09:29:47.537]             base::options(...future.oldOptions)
[09:29:47.537]             if (.Platform$OS.type == "windows") {
[09:29:47.537]                 old_names <- names(...future.oldEnvVars)
[09:29:47.537]                 envs <- base::Sys.getenv()
[09:29:47.537]                 names <- names(envs)
[09:29:47.537]                 common <- intersect(names, old_names)
[09:29:47.537]                 added <- setdiff(names, old_names)
[09:29:47.537]                 removed <- setdiff(old_names, names)
[09:29:47.537]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.537]                   envs[common]]
[09:29:47.537]                 NAMES <- toupper(changed)
[09:29:47.537]                 args <- list()
[09:29:47.537]                 for (kk in seq_along(NAMES)) {
[09:29:47.537]                   name <- changed[[kk]]
[09:29:47.537]                   NAME <- NAMES[[kk]]
[09:29:47.537]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.537]                     next
[09:29:47.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.537]                 }
[09:29:47.537]                 NAMES <- toupper(added)
[09:29:47.537]                 for (kk in seq_along(NAMES)) {
[09:29:47.537]                   name <- added[[kk]]
[09:29:47.537]                   NAME <- NAMES[[kk]]
[09:29:47.537]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.537]                     next
[09:29:47.537]                   args[[name]] <- ""
[09:29:47.537]                 }
[09:29:47.537]                 NAMES <- toupper(removed)
[09:29:47.537]                 for (kk in seq_along(NAMES)) {
[09:29:47.537]                   name <- removed[[kk]]
[09:29:47.537]                   NAME <- NAMES[[kk]]
[09:29:47.537]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.537]                     next
[09:29:47.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.537]                 }
[09:29:47.537]                 if (length(args) > 0) 
[09:29:47.537]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.537]             }
[09:29:47.537]             else {
[09:29:47.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.537]             }
[09:29:47.537]             {
[09:29:47.537]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.537]                   0L) {
[09:29:47.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.537]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.537]                   base::options(opts)
[09:29:47.537]                 }
[09:29:47.537]                 {
[09:29:47.537]                   {
[09:29:47.537]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.537]                     NULL
[09:29:47.537]                   }
[09:29:47.537]                   options(future.plan = NULL)
[09:29:47.537]                   if (is.na(NA_character_)) 
[09:29:47.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.537]                     .init = FALSE)
[09:29:47.537]                 }
[09:29:47.537]             }
[09:29:47.537]         }
[09:29:47.537]     })
[09:29:47.537]     if (TRUE) {
[09:29:47.537]         base::sink(type = "output", split = FALSE)
[09:29:47.537]         if (TRUE) {
[09:29:47.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.537]         }
[09:29:47.537]         else {
[09:29:47.537]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.537]         }
[09:29:47.537]         base::close(...future.stdout)
[09:29:47.537]         ...future.stdout <- NULL
[09:29:47.537]     }
[09:29:47.537]     ...future.result$conditions <- ...future.conditions
[09:29:47.537]     ...future.result$finished <- base::Sys.time()
[09:29:47.537]     ...future.result
[09:29:47.537] }
[09:29:47.541] assign_globals() ...
[09:29:47.541] List of 5
[09:29:47.541]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[09:29:47.541]  $ future.call.arguments    : list()
[09:29:47.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.541]  $ ...future.elements_ii    :List of 3
[09:29:47.541]   ..$ : int [1:7] 1 2 3 4 5 6 7
[09:29:47.541]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[09:29:47.541]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[09:29:47.541]  $ ...future.seeds_ii       : NULL
[09:29:47.541]  $ ...future.globals.maxSize: NULL
[09:29:47.541]  - attr(*, "where")=List of 5
[09:29:47.541]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.541]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.541]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.541]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.541]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.541]  - attr(*, "resolved")= logi FALSE
[09:29:47.541]  - attr(*, "total_size")= num 46960
[09:29:47.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.541]  - attr(*, "already-done")= logi TRUE
[09:29:47.553] - copied ‘...future.FUN’ to environment
[09:29:47.553] - copied ‘future.call.arguments’ to environment
[09:29:47.553] - copied ‘...future.elements_ii’ to environment
[09:29:47.554] - copied ‘...future.seeds_ii’ to environment
[09:29:47.554] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.554] assign_globals() ... done
[09:29:47.554] requestCore(): workers = 2
[09:29:47.556] MulticoreFuture started
[09:29:47.557] - Launch lazy future ... done
[09:29:47.558] run() for ‘MulticoreFuture’ ... done
[09:29:47.558] Created future:
[09:29:47.558] plan(): Setting new future strategy stack:
[09:29:47.559] List of future strategies:
[09:29:47.559] 1. sequential:
[09:29:47.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.559]    - tweaked: FALSE
[09:29:47.559]    - call: NULL
[09:29:47.561] plan(): nbrOfWorkers() = 1
[09:29:47.563] plan(): Setting new future strategy stack:
[09:29:47.563] List of future strategies:
[09:29:47.563] 1. multicore:
[09:29:47.563]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.563]    - tweaked: FALSE
[09:29:47.563]    - call: plan(strategy)
[09:29:47.569] plan(): nbrOfWorkers() = 2
[09:29:47.559] MulticoreFuture:
[09:29:47.559] Label: ‘future_sapply-2’
[09:29:47.559] Expression:
[09:29:47.559] {
[09:29:47.559]     do.call(function(...) {
[09:29:47.559]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.559]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.559]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.559]             on.exit(options(oopts), add = TRUE)
[09:29:47.559]         }
[09:29:47.559]         {
[09:29:47.559]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.559]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.559]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.559]             })
[09:29:47.559]         }
[09:29:47.559]     }, args = future.call.arguments)
[09:29:47.559] }
[09:29:47.559] Lazy evaluation: FALSE
[09:29:47.559] Asynchronous evaluation: TRUE
[09:29:47.559] Local evaluation: TRUE
[09:29:47.559] Environment: R_GlobalEnv
[09:29:47.559] Capture standard output: TRUE
[09:29:47.559] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.559] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:47.559] Packages: 1 packages (‘stats’)
[09:29:47.559] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.559] Resolved: TRUE
[09:29:47.559] Value: <not collected>
[09:29:47.559] Conditions captured: <none>
[09:29:47.559] Early signaling: FALSE
[09:29:47.559] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.559] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.570] Chunk #2 of 2 ... DONE
[09:29:47.570] Launching 2 futures (chunks) ... DONE
[09:29:47.570] Resolving 2 futures (chunks) ...
[09:29:47.570] resolve() on list ...
[09:29:47.571]  recursive: 0
[09:29:47.571]  length: 2
[09:29:47.571] 
[09:29:47.571] Future #1
[09:29:47.571] result() for MulticoreFuture ...
[09:29:47.572] result() for MulticoreFuture ...
[09:29:47.573] result() for MulticoreFuture ... done
[09:29:47.573] result() for MulticoreFuture ... done
[09:29:47.573] result() for MulticoreFuture ...
[09:29:47.573] result() for MulticoreFuture ... done
[09:29:47.573] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:47.573] - nx: 2
[09:29:47.574] - relay: TRUE
[09:29:47.574] - stdout: TRUE
[09:29:47.574] - signal: TRUE
[09:29:47.574] - resignal: FALSE
[09:29:47.574] - force: TRUE
[09:29:47.574] - relayed: [n=2] FALSE, FALSE
[09:29:47.574] - queued futures: [n=2] FALSE, FALSE
[09:29:47.574]  - until=1
[09:29:47.575]  - relaying element #1
[09:29:47.575] result() for MulticoreFuture ...
[09:29:47.575] result() for MulticoreFuture ... done
[09:29:47.575] result() for MulticoreFuture ...
[09:29:47.575] result() for MulticoreFuture ... done
[09:29:47.575] result() for MulticoreFuture ...
[09:29:47.575] result() for MulticoreFuture ... done
[09:29:47.576] result() for MulticoreFuture ...
[09:29:47.576] result() for MulticoreFuture ... done
[09:29:47.576] - relayed: [n=2] TRUE, FALSE
[09:29:47.576] - queued futures: [n=2] TRUE, FALSE
[09:29:47.576] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:47.576]  length: 1 (resolved future 1)
[09:29:47.577] Future #2
[09:29:47.577] result() for MulticoreFuture ...
[09:29:47.577] result() for MulticoreFuture ...
[09:29:47.578] result() for MulticoreFuture ... done
[09:29:47.578] result() for MulticoreFuture ... done
[09:29:47.578] result() for MulticoreFuture ...
[09:29:47.578] result() for MulticoreFuture ... done
[09:29:47.578] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:47.578] - nx: 2
[09:29:47.578] - relay: TRUE
[09:29:47.578] - stdout: TRUE
[09:29:47.579] - signal: TRUE
[09:29:47.579] - resignal: FALSE
[09:29:47.579] - force: TRUE
[09:29:47.579] - relayed: [n=2] TRUE, FALSE
[09:29:47.579] - queued futures: [n=2] TRUE, FALSE
[09:29:47.579]  - until=2
[09:29:47.579]  - relaying element #2
[09:29:47.579] result() for MulticoreFuture ...
[09:29:47.579] result() for MulticoreFuture ... done
[09:29:47.580] result() for MulticoreFuture ...
[09:29:47.580] result() for MulticoreFuture ... done
[09:29:47.580] result() for MulticoreFuture ...
[09:29:47.580] result() for MulticoreFuture ... done
[09:29:47.580] result() for MulticoreFuture ...
[09:29:47.580] result() for MulticoreFuture ... done
[09:29:47.580] - relayed: [n=2] TRUE, TRUE
[09:29:47.580] - queued futures: [n=2] TRUE, TRUE
[09:29:47.580] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:47.581]  length: 0 (resolved future 2)
[09:29:47.581] Relaying remaining futures
[09:29:47.581] signalConditionsASAP(NULL, pos=0) ...
[09:29:47.581] - nx: 2
[09:29:47.581] - relay: TRUE
[09:29:47.581] - stdout: TRUE
[09:29:47.581] - signal: TRUE
[09:29:47.581] - resignal: FALSE
[09:29:47.581] - force: TRUE
[09:29:47.581] - relayed: [n=2] TRUE, TRUE
[09:29:47.582] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:47.582] - relayed: [n=2] TRUE, TRUE
[09:29:47.582] - queued futures: [n=2] TRUE, TRUE
[09:29:47.582] signalConditionsASAP(NULL, pos=0) ... done
[09:29:47.582] resolve() on list ... DONE
[09:29:47.582] result() for MulticoreFuture ...
[09:29:47.582] result() for MulticoreFuture ... done
[09:29:47.582] result() for MulticoreFuture ...
[09:29:47.582] result() for MulticoreFuture ... done
[09:29:47.583] result() for MulticoreFuture ...
[09:29:47.583] result() for MulticoreFuture ... done
[09:29:47.583] result() for MulticoreFuture ...
[09:29:47.583] result() for MulticoreFuture ... done
[09:29:47.583]  - Number of value chunks collected: 2
[09:29:47.583] Resolving 2 futures (chunks) ... DONE
[09:29:47.583] Reducing values from 2 chunks ...
[09:29:47.583]  - Number of values collected after concatenation: 7
[09:29:47.583]  - Number of values expected: 7
[09:29:47.584] Reducing values from 2 chunks ... DONE
[09:29:47.584] future_lapply() ... DONE
[09:29:47.584] future_lapply() ...
[09:29:47.590] Number of chunks: 2
[09:29:47.590] getGlobalsAndPackagesXApply() ...
[09:29:47.590]  - future.globals: TRUE
[09:29:47.590] getGlobalsAndPackages() ...
[09:29:47.590] Searching for globals...
[09:29:47.600] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[09:29:47.601] Searching for globals ... DONE
[09:29:47.601] Resolving globals: FALSE
[09:29:47.602] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[09:29:47.602] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[09:29:47.602] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.603] - packages: [2] ‘stats’, ‘future.apply’
[09:29:47.603] getGlobalsAndPackages() ... DONE
[09:29:47.603]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.603]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[09:29:47.603] Finding globals ... DONE
[09:29:47.603]  - use_args: TRUE
[09:29:47.603]  - Getting '...' globals ...
[09:29:47.603] resolve() on list ...
[09:29:47.603]  recursive: 0
[09:29:47.604]  length: 1
[09:29:47.604]  elements: ‘...’
[09:29:47.604]  length: 0 (resolved future 1)
[09:29:47.604] resolve() on list ... DONE
[09:29:47.604]    - '...' content: [n=0] 
[09:29:47.604] List of 1
[09:29:47.604]  $ ...: list()
[09:29:47.604]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.604]  - attr(*, "where")=List of 1
[09:29:47.604]   ..$ ...:<environment: 0x561d3649fb18> 
[09:29:47.604]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.604]  - attr(*, "resolved")= logi TRUE
[09:29:47.604]  - attr(*, "total_size")= num NA
[09:29:47.607]  - Getting '...' globals ... DONE
[09:29:47.607] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:47.607] List of 8
[09:29:47.607]  $ ...future.FUN:function (x, ...)  
[09:29:47.607]  $ x_FUN        :function (x, na.rm = TRUE)  
[09:29:47.607]  $ times        : int 5
[09:29:47.607]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.607]  $ stop_if_not  :function (...)  
[09:29:47.607]  $ dim          : NULL
[09:29:47.607]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:47.607]  $ ...          : list()
[09:29:47.607]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.607]  - attr(*, "where")=List of 8
[09:29:47.607]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:47.607]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:47.607]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:47.607]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:47.607]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:47.607]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:47.607]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:47.607]   ..$ ...          :<environment: 0x561d3649fb18> 
[09:29:47.607]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.607]  - attr(*, "resolved")= logi FALSE
[09:29:47.607]  - attr(*, "total_size")= num 141240
[09:29:47.614] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[09:29:47.614] getGlobalsAndPackagesXApply() ... DONE
[09:29:47.614] Number of futures (= number of chunks): 2
[09:29:47.614] Launching 2 futures (chunks) ...
[09:29:47.614] Chunk #1 of 2 ...
[09:29:47.614]  - Finding globals in 'X' for chunk #1 ...
[09:29:47.614] getGlobalsAndPackages() ...
[09:29:47.614] Searching for globals...
[09:29:47.615] 
[09:29:47.615] Searching for globals ... DONE
[09:29:47.615] - globals: [0] <none>
[09:29:47.615] getGlobalsAndPackages() ... DONE
[09:29:47.615]    + additional globals found: [n=0] 
[09:29:47.615]    + additional namespaces needed: [n=0] 
[09:29:47.615]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:47.615]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.615]  - seeds: <none>
[09:29:47.616]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.616] getGlobalsAndPackages() ...
[09:29:47.616] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.616] Resolving globals: FALSE
[09:29:47.616] Tweak future expression to call with '...' arguments ...
[09:29:47.616] {
[09:29:47.616]     do.call(function(...) {
[09:29:47.616]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.616]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.616]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.616]             on.exit(options(oopts), add = TRUE)
[09:29:47.616]         }
[09:29:47.616]         {
[09:29:47.616]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.616]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.616]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.616]             })
[09:29:47.616]         }
[09:29:47.616]     }, args = future.call.arguments)
[09:29:47.616] }
[09:29:47.616] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.617] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.617] - packages: [2] ‘stats’, ‘future.apply’
[09:29:47.617] getGlobalsAndPackages() ... DONE
[09:29:47.617] run() for ‘Future’ ...
[09:29:47.617] - state: ‘created’
[09:29:47.618] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.621] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.621]   - Field: ‘label’
[09:29:47.621]   - Field: ‘local’
[09:29:47.622]   - Field: ‘owner’
[09:29:47.622]   - Field: ‘envir’
[09:29:47.622]   - Field: ‘workers’
[09:29:47.622]   - Field: ‘packages’
[09:29:47.622]   - Field: ‘gc’
[09:29:47.622]   - Field: ‘job’
[09:29:47.622]   - Field: ‘conditions’
[09:29:47.622]   - Field: ‘expr’
[09:29:47.622]   - Field: ‘uuid’
[09:29:47.622]   - Field: ‘seed’
[09:29:47.622]   - Field: ‘version’
[09:29:47.622]   - Field: ‘result’
[09:29:47.623]   - Field: ‘asynchronous’
[09:29:47.623]   - Field: ‘calls’
[09:29:47.623]   - Field: ‘globals’
[09:29:47.623]   - Field: ‘stdout’
[09:29:47.623]   - Field: ‘earlySignal’
[09:29:47.623]   - Field: ‘lazy’
[09:29:47.623]   - Field: ‘state’
[09:29:47.623] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.623] - Launch lazy future ...
[09:29:47.624] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[09:29:47.624] Packages needed by future strategies (n = 0): <none>
[09:29:47.624] {
[09:29:47.624]     {
[09:29:47.624]         {
[09:29:47.624]             ...future.startTime <- base::Sys.time()
[09:29:47.624]             {
[09:29:47.624]                 {
[09:29:47.624]                   {
[09:29:47.624]                     {
[09:29:47.624]                       {
[09:29:47.624]                         base::local({
[09:29:47.624]                           has_future <- base::requireNamespace("future", 
[09:29:47.624]                             quietly = TRUE)
[09:29:47.624]                           if (has_future) {
[09:29:47.624]                             ns <- base::getNamespace("future")
[09:29:47.624]                             version <- ns[[".package"]][["version"]]
[09:29:47.624]                             if (is.null(version)) 
[09:29:47.624]                               version <- utils::packageVersion("future")
[09:29:47.624]                           }
[09:29:47.624]                           else {
[09:29:47.624]                             version <- NULL
[09:29:47.624]                           }
[09:29:47.624]                           if (!has_future || version < "1.8.0") {
[09:29:47.624]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.624]                               "", base::R.version$version.string), 
[09:29:47.624]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.624]                                 base::R.version$platform, 8 * 
[09:29:47.624]                                   base::.Machine$sizeof.pointer), 
[09:29:47.624]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.624]                                 "release", "version")], collapse = " "), 
[09:29:47.624]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.624]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.624]                               info)
[09:29:47.624]                             info <- base::paste(info, collapse = "; ")
[09:29:47.624]                             if (!has_future) {
[09:29:47.624]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.624]                                 info)
[09:29:47.624]                             }
[09:29:47.624]                             else {
[09:29:47.624]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.624]                                 info, version)
[09:29:47.624]                             }
[09:29:47.624]                             base::stop(msg)
[09:29:47.624]                           }
[09:29:47.624]                         })
[09:29:47.624]                       }
[09:29:47.624]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.624]                       base::options(mc.cores = 1L)
[09:29:47.624]                     }
[09:29:47.624]                     base::local({
[09:29:47.624]                       for (pkg in c("stats", "future.apply")) {
[09:29:47.624]                         base::loadNamespace(pkg)
[09:29:47.624]                         base::library(pkg, character.only = TRUE)
[09:29:47.624]                       }
[09:29:47.624]                     })
[09:29:47.624]                   }
[09:29:47.624]                   ...future.strategy.old <- future::plan("list")
[09:29:47.624]                   options(future.plan = NULL)
[09:29:47.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.624]                 }
[09:29:47.624]                 ...future.workdir <- getwd()
[09:29:47.624]             }
[09:29:47.624]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.624]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.624]         }
[09:29:47.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.624]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.624]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.624]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.624]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.624]             base::names(...future.oldOptions))
[09:29:47.624]     }
[09:29:47.624]     if (FALSE) {
[09:29:47.624]     }
[09:29:47.624]     else {
[09:29:47.624]         if (TRUE) {
[09:29:47.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.624]                 open = "w")
[09:29:47.624]         }
[09:29:47.624]         else {
[09:29:47.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.624]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.624]         }
[09:29:47.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.624]             base::sink(type = "output", split = FALSE)
[09:29:47.624]             base::close(...future.stdout)
[09:29:47.624]         }, add = TRUE)
[09:29:47.624]     }
[09:29:47.624]     ...future.frame <- base::sys.nframe()
[09:29:47.624]     ...future.conditions <- base::list()
[09:29:47.624]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.624]     if (FALSE) {
[09:29:47.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.624]     }
[09:29:47.624]     ...future.result <- base::tryCatch({
[09:29:47.624]         base::withCallingHandlers({
[09:29:47.624]             ...future.value <- base::withVisible(base::local({
[09:29:47.624]                 withCallingHandlers({
[09:29:47.624]                   {
[09:29:47.624]                     do.call(function(...) {
[09:29:47.624]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.624]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.624]                         ...future.globals.maxSize)) {
[09:29:47.624]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.624]                         on.exit(options(oopts), add = TRUE)
[09:29:47.624]                       }
[09:29:47.624]                       {
[09:29:47.624]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.624]                           FUN = function(jj) {
[09:29:47.624]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.624]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.624]                           })
[09:29:47.624]                       }
[09:29:47.624]                     }, args = future.call.arguments)
[09:29:47.624]                   }
[09:29:47.624]                 }, immediateCondition = function(cond) {
[09:29:47.624]                   save_rds <- function (object, pathname, ...) 
[09:29:47.624]                   {
[09:29:47.624]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.624]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.624]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.624]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.624]                         fi_tmp[["mtime"]])
[09:29:47.624]                     }
[09:29:47.624]                     tryCatch({
[09:29:47.624]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.624]                     }, error = function(ex) {
[09:29:47.624]                       msg <- conditionMessage(ex)
[09:29:47.624]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.624]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.624]                         fi_tmp[["mtime"]], msg)
[09:29:47.624]                       ex$message <- msg
[09:29:47.624]                       stop(ex)
[09:29:47.624]                     })
[09:29:47.624]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.624]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.624]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.624]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.624]                       fi <- file.info(pathname)
[09:29:47.624]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.624]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.624]                         fi[["size"]], fi[["mtime"]])
[09:29:47.624]                       stop(msg)
[09:29:47.624]                     }
[09:29:47.624]                     invisible(pathname)
[09:29:47.624]                   }
[09:29:47.624]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.624]                     rootPath = tempdir()) 
[09:29:47.624]                   {
[09:29:47.624]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.624]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.624]                       tmpdir = path, fileext = ".rds")
[09:29:47.624]                     save_rds(obj, file)
[09:29:47.624]                   }
[09:29:47.624]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.624]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.624]                   {
[09:29:47.624]                     inherits <- base::inherits
[09:29:47.624]                     invokeRestart <- base::invokeRestart
[09:29:47.624]                     is.null <- base::is.null
[09:29:47.624]                     muffled <- FALSE
[09:29:47.624]                     if (inherits(cond, "message")) {
[09:29:47.624]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.624]                       if (muffled) 
[09:29:47.624]                         invokeRestart("muffleMessage")
[09:29:47.624]                     }
[09:29:47.624]                     else if (inherits(cond, "warning")) {
[09:29:47.624]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.624]                       if (muffled) 
[09:29:47.624]                         invokeRestart("muffleWarning")
[09:29:47.624]                     }
[09:29:47.624]                     else if (inherits(cond, "condition")) {
[09:29:47.624]                       if (!is.null(pattern)) {
[09:29:47.624]                         computeRestarts <- base::computeRestarts
[09:29:47.624]                         grepl <- base::grepl
[09:29:47.624]                         restarts <- computeRestarts(cond)
[09:29:47.624]                         for (restart in restarts) {
[09:29:47.624]                           name <- restart$name
[09:29:47.624]                           if (is.null(name)) 
[09:29:47.624]                             next
[09:29:47.624]                           if (!grepl(pattern, name)) 
[09:29:47.624]                             next
[09:29:47.624]                           invokeRestart(restart)
[09:29:47.624]                           muffled <- TRUE
[09:29:47.624]                           break
[09:29:47.624]                         }
[09:29:47.624]                       }
[09:29:47.624]                     }
[09:29:47.624]                     invisible(muffled)
[09:29:47.624]                   }
[09:29:47.624]                   muffleCondition(cond)
[09:29:47.624]                 })
[09:29:47.624]             }))
[09:29:47.624]             future::FutureResult(value = ...future.value$value, 
[09:29:47.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.624]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.624]                     ...future.globalenv.names))
[09:29:47.624]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.624]         }, condition = base::local({
[09:29:47.624]             c <- base::c
[09:29:47.624]             inherits <- base::inherits
[09:29:47.624]             invokeRestart <- base::invokeRestart
[09:29:47.624]             length <- base::length
[09:29:47.624]             list <- base::list
[09:29:47.624]             seq.int <- base::seq.int
[09:29:47.624]             signalCondition <- base::signalCondition
[09:29:47.624]             sys.calls <- base::sys.calls
[09:29:47.624]             `[[` <- base::`[[`
[09:29:47.624]             `+` <- base::`+`
[09:29:47.624]             `<<-` <- base::`<<-`
[09:29:47.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.624]                   3L)]
[09:29:47.624]             }
[09:29:47.624]             function(cond) {
[09:29:47.624]                 is_error <- inherits(cond, "error")
[09:29:47.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.624]                   NULL)
[09:29:47.624]                 if (is_error) {
[09:29:47.624]                   sessionInformation <- function() {
[09:29:47.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.624]                       search = base::search(), system = base::Sys.info())
[09:29:47.624]                   }
[09:29:47.624]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.624]                     cond$call), session = sessionInformation(), 
[09:29:47.624]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.624]                   signalCondition(cond)
[09:29:47.624]                 }
[09:29:47.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.624]                 "immediateCondition"))) {
[09:29:47.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.624]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.624]                   if (TRUE && !signal) {
[09:29:47.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.624]                     {
[09:29:47.624]                       inherits <- base::inherits
[09:29:47.624]                       invokeRestart <- base::invokeRestart
[09:29:47.624]                       is.null <- base::is.null
[09:29:47.624]                       muffled <- FALSE
[09:29:47.624]                       if (inherits(cond, "message")) {
[09:29:47.624]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.624]                         if (muffled) 
[09:29:47.624]                           invokeRestart("muffleMessage")
[09:29:47.624]                       }
[09:29:47.624]                       else if (inherits(cond, "warning")) {
[09:29:47.624]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.624]                         if (muffled) 
[09:29:47.624]                           invokeRestart("muffleWarning")
[09:29:47.624]                       }
[09:29:47.624]                       else if (inherits(cond, "condition")) {
[09:29:47.624]                         if (!is.null(pattern)) {
[09:29:47.624]                           computeRestarts <- base::computeRestarts
[09:29:47.624]                           grepl <- base::grepl
[09:29:47.624]                           restarts <- computeRestarts(cond)
[09:29:47.624]                           for (restart in restarts) {
[09:29:47.624]                             name <- restart$name
[09:29:47.624]                             if (is.null(name)) 
[09:29:47.624]                               next
[09:29:47.624]                             if (!grepl(pattern, name)) 
[09:29:47.624]                               next
[09:29:47.624]                             invokeRestart(restart)
[09:29:47.624]                             muffled <- TRUE
[09:29:47.624]                             break
[09:29:47.624]                           }
[09:29:47.624]                         }
[09:29:47.624]                       }
[09:29:47.624]                       invisible(muffled)
[09:29:47.624]                     }
[09:29:47.624]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.624]                   }
[09:29:47.624]                 }
[09:29:47.624]                 else {
[09:29:47.624]                   if (TRUE) {
[09:29:47.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.624]                     {
[09:29:47.624]                       inherits <- base::inherits
[09:29:47.624]                       invokeRestart <- base::invokeRestart
[09:29:47.624]                       is.null <- base::is.null
[09:29:47.624]                       muffled <- FALSE
[09:29:47.624]                       if (inherits(cond, "message")) {
[09:29:47.624]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.624]                         if (muffled) 
[09:29:47.624]                           invokeRestart("muffleMessage")
[09:29:47.624]                       }
[09:29:47.624]                       else if (inherits(cond, "warning")) {
[09:29:47.624]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.624]                         if (muffled) 
[09:29:47.624]                           invokeRestart("muffleWarning")
[09:29:47.624]                       }
[09:29:47.624]                       else if (inherits(cond, "condition")) {
[09:29:47.624]                         if (!is.null(pattern)) {
[09:29:47.624]                           computeRestarts <- base::computeRestarts
[09:29:47.624]                           grepl <- base::grepl
[09:29:47.624]                           restarts <- computeRestarts(cond)
[09:29:47.624]                           for (restart in restarts) {
[09:29:47.624]                             name <- restart$name
[09:29:47.624]                             if (is.null(name)) 
[09:29:47.624]                               next
[09:29:47.624]                             if (!grepl(pattern, name)) 
[09:29:47.624]                               next
[09:29:47.624]                             invokeRestart(restart)
[09:29:47.624]                             muffled <- TRUE
[09:29:47.624]                             break
[09:29:47.624]                           }
[09:29:47.624]                         }
[09:29:47.624]                       }
[09:29:47.624]                       invisible(muffled)
[09:29:47.624]                     }
[09:29:47.624]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.624]                   }
[09:29:47.624]                 }
[09:29:47.624]             }
[09:29:47.624]         }))
[09:29:47.624]     }, error = function(ex) {
[09:29:47.624]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.624]                 ...future.rng), started = ...future.startTime, 
[09:29:47.624]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.624]             version = "1.8"), class = "FutureResult")
[09:29:47.624]     }, finally = {
[09:29:47.624]         if (!identical(...future.workdir, getwd())) 
[09:29:47.624]             setwd(...future.workdir)
[09:29:47.624]         {
[09:29:47.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.624]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.624]             }
[09:29:47.624]             base::options(...future.oldOptions)
[09:29:47.624]             if (.Platform$OS.type == "windows") {
[09:29:47.624]                 old_names <- names(...future.oldEnvVars)
[09:29:47.624]                 envs <- base::Sys.getenv()
[09:29:47.624]                 names <- names(envs)
[09:29:47.624]                 common <- intersect(names, old_names)
[09:29:47.624]                 added <- setdiff(names, old_names)
[09:29:47.624]                 removed <- setdiff(old_names, names)
[09:29:47.624]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.624]                   envs[common]]
[09:29:47.624]                 NAMES <- toupper(changed)
[09:29:47.624]                 args <- list()
[09:29:47.624]                 for (kk in seq_along(NAMES)) {
[09:29:47.624]                   name <- changed[[kk]]
[09:29:47.624]                   NAME <- NAMES[[kk]]
[09:29:47.624]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.624]                     next
[09:29:47.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.624]                 }
[09:29:47.624]                 NAMES <- toupper(added)
[09:29:47.624]                 for (kk in seq_along(NAMES)) {
[09:29:47.624]                   name <- added[[kk]]
[09:29:47.624]                   NAME <- NAMES[[kk]]
[09:29:47.624]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.624]                     next
[09:29:47.624]                   args[[name]] <- ""
[09:29:47.624]                 }
[09:29:47.624]                 NAMES <- toupper(removed)
[09:29:47.624]                 for (kk in seq_along(NAMES)) {
[09:29:47.624]                   name <- removed[[kk]]
[09:29:47.624]                   NAME <- NAMES[[kk]]
[09:29:47.624]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.624]                     next
[09:29:47.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.624]                 }
[09:29:47.624]                 if (length(args) > 0) 
[09:29:47.624]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.624]             }
[09:29:47.624]             else {
[09:29:47.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.624]             }
[09:29:47.624]             {
[09:29:47.624]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.624]                   0L) {
[09:29:47.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.624]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.624]                   base::options(opts)
[09:29:47.624]                 }
[09:29:47.624]                 {
[09:29:47.624]                   {
[09:29:47.624]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.624]                     NULL
[09:29:47.624]                   }
[09:29:47.624]                   options(future.plan = NULL)
[09:29:47.624]                   if (is.na(NA_character_)) 
[09:29:47.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.624]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.624]                     .init = FALSE)
[09:29:47.624]                 }
[09:29:47.624]             }
[09:29:47.624]         }
[09:29:47.624]     })
[09:29:47.624]     if (TRUE) {
[09:29:47.624]         base::sink(type = "output", split = FALSE)
[09:29:47.624]         if (TRUE) {
[09:29:47.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.624]         }
[09:29:47.624]         else {
[09:29:47.624]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.624]         }
[09:29:47.624]         base::close(...future.stdout)
[09:29:47.624]         ...future.stdout <- NULL
[09:29:47.624]     }
[09:29:47.624]     ...future.result$conditions <- ...future.conditions
[09:29:47.624]     ...future.result$finished <- base::Sys.time()
[09:29:47.624]     ...future.result
[09:29:47.624] }
[09:29:47.627] assign_globals() ...
[09:29:47.627] List of 11
[09:29:47.627]  $ ...future.FUN            :function (x, ...)  
[09:29:47.627]  $ x_FUN                    :function (x, na.rm = TRUE)  
[09:29:47.627]  $ times                    : int 5
[09:29:47.627]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.627]  $ stop_if_not              :function (...)  
[09:29:47.627]  $ dim                      : NULL
[09:29:47.627]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:47.627]  $ future.call.arguments    : list()
[09:29:47.627]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.627]  $ ...future.elements_ii    :List of 4
[09:29:47.627]   ..$ : int [1:3] 1 2 3
[09:29:47.627]   ..$ : int [1:4] 1 2 3 4
[09:29:47.627]   ..$ : int [1:5] 1 2 3 4 5
[09:29:47.627]   ..$ : int [1:6] 1 2 3 4 5 6
[09:29:47.627]  $ ...future.seeds_ii       : NULL
[09:29:47.627]  $ ...future.globals.maxSize: NULL
[09:29:47.627]  - attr(*, "where")=List of 11
[09:29:47.627]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.627]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:47.627]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:47.627]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:47.627]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:47.627]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:47.627]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:47.627]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.627]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.627]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.627]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.627]  - attr(*, "resolved")= logi FALSE
[09:29:47.627]  - attr(*, "total_size")= num 141240
[09:29:47.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.627]  - attr(*, "already-done")= logi TRUE
[09:29:47.636] - copied ‘...future.FUN’ to environment
[09:29:47.636] - copied ‘x_FUN’ to environment
[09:29:47.636] - copied ‘times’ to environment
[09:29:47.636] - copied ‘stopf’ to environment
[09:29:47.636] - copied ‘stop_if_not’ to environment
[09:29:47.637] - copied ‘dim’ to environment
[09:29:47.637] - copied ‘valid_types’ to environment
[09:29:47.637] - copied ‘future.call.arguments’ to environment
[09:29:47.637] - copied ‘...future.elements_ii’ to environment
[09:29:47.637] - copied ‘...future.seeds_ii’ to environment
[09:29:47.637] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.637] assign_globals() ... done
[09:29:47.637] requestCore(): workers = 2
[09:29:47.640] MulticoreFuture started
[09:29:47.640] - Launch lazy future ... done
[09:29:47.641] run() for ‘MulticoreFuture’ ... done
[09:29:47.641] Created future:
[09:29:47.642] plan(): Setting new future strategy stack:
[09:29:47.643] List of future strategies:
[09:29:47.643] 1. sequential:
[09:29:47.643]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.643]    - tweaked: FALSE
[09:29:47.643]    - call: NULL
[09:29:47.644] plan(): nbrOfWorkers() = 1
[09:29:47.647] plan(): Setting new future strategy stack:
[09:29:47.648] List of future strategies:
[09:29:47.648] 1. multicore:
[09:29:47.648]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.648]    - tweaked: FALSE
[09:29:47.648]    - call: plan(strategy)
[09:29:47.654] plan(): nbrOfWorkers() = 2
[09:29:47.642] MulticoreFuture:
[09:29:47.642] Label: ‘future_vapply-1’
[09:29:47.642] Expression:
[09:29:47.642] {
[09:29:47.642]     do.call(function(...) {
[09:29:47.642]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.642]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.642]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.642]             on.exit(options(oopts), add = TRUE)
[09:29:47.642]         }
[09:29:47.642]         {
[09:29:47.642]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.642]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.642]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.642]             })
[09:29:47.642]         }
[09:29:47.642]     }, args = future.call.arguments)
[09:29:47.642] }
[09:29:47.642] Lazy evaluation: FALSE
[09:29:47.642] Asynchronous evaluation: TRUE
[09:29:47.642] Local evaluation: TRUE
[09:29:47.642] Environment: R_GlobalEnv
[09:29:47.642] Capture standard output: TRUE
[09:29:47.642] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.642] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:47.642] Packages: 2 packages (‘stats’, ‘future.apply’)
[09:29:47.642] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.642] Resolved: TRUE
[09:29:47.642] Value: <not collected>
[09:29:47.642] Conditions captured: <none>
[09:29:47.642] Early signaling: FALSE
[09:29:47.642] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.642] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.655] Chunk #1 of 2 ... DONE
[09:29:47.655] Chunk #2 of 2 ...
[09:29:47.656]  - Finding globals in 'X' for chunk #2 ...
[09:29:47.656] getGlobalsAndPackages() ...
[09:29:47.656] Searching for globals...
[09:29:47.657] 
[09:29:47.657] Searching for globals ... DONE
[09:29:47.657] - globals: [0] <none>
[09:29:47.657] getGlobalsAndPackages() ... DONE
[09:29:47.657]    + additional globals found: [n=0] 
[09:29:47.658]    + additional namespaces needed: [n=0] 
[09:29:47.658]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:47.658]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.658]  - seeds: <none>
[09:29:47.658]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.658] getGlobalsAndPackages() ...
[09:29:47.658] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.659] Resolving globals: FALSE
[09:29:47.659] Tweak future expression to call with '...' arguments ...
[09:29:47.659] {
[09:29:47.659]     do.call(function(...) {
[09:29:47.659]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.659]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.659]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.659]             on.exit(options(oopts), add = TRUE)
[09:29:47.659]         }
[09:29:47.659]         {
[09:29:47.659]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.659]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.659]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.659]             })
[09:29:47.659]         }
[09:29:47.659]     }, args = future.call.arguments)
[09:29:47.659] }
[09:29:47.659] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.660] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.661] - packages: [2] ‘stats’, ‘future.apply’
[09:29:47.661] getGlobalsAndPackages() ... DONE
[09:29:47.661] run() for ‘Future’ ...
[09:29:47.661] - state: ‘created’
[09:29:47.662] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.666] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.666]   - Field: ‘label’
[09:29:47.666]   - Field: ‘local’
[09:29:47.666]   - Field: ‘owner’
[09:29:47.667]   - Field: ‘envir’
[09:29:47.667]   - Field: ‘workers’
[09:29:47.667]   - Field: ‘packages’
[09:29:47.667]   - Field: ‘gc’
[09:29:47.667]   - Field: ‘job’
[09:29:47.667]   - Field: ‘conditions’
[09:29:47.667]   - Field: ‘expr’
[09:29:47.667]   - Field: ‘uuid’
[09:29:47.667]   - Field: ‘seed’
[09:29:47.668]   - Field: ‘version’
[09:29:47.668]   - Field: ‘result’
[09:29:47.668]   - Field: ‘asynchronous’
[09:29:47.668]   - Field: ‘calls’
[09:29:47.668]   - Field: ‘globals’
[09:29:47.668]   - Field: ‘stdout’
[09:29:47.668]   - Field: ‘earlySignal’
[09:29:47.669]   - Field: ‘lazy’
[09:29:47.669]   - Field: ‘state’
[09:29:47.669] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.669] - Launch lazy future ...
[09:29:47.669] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[09:29:47.669] Packages needed by future strategies (n = 0): <none>
[09:29:47.670] {
[09:29:47.670]     {
[09:29:47.670]         {
[09:29:47.670]             ...future.startTime <- base::Sys.time()
[09:29:47.670]             {
[09:29:47.670]                 {
[09:29:47.670]                   {
[09:29:47.670]                     {
[09:29:47.670]                       {
[09:29:47.670]                         base::local({
[09:29:47.670]                           has_future <- base::requireNamespace("future", 
[09:29:47.670]                             quietly = TRUE)
[09:29:47.670]                           if (has_future) {
[09:29:47.670]                             ns <- base::getNamespace("future")
[09:29:47.670]                             version <- ns[[".package"]][["version"]]
[09:29:47.670]                             if (is.null(version)) 
[09:29:47.670]                               version <- utils::packageVersion("future")
[09:29:47.670]                           }
[09:29:47.670]                           else {
[09:29:47.670]                             version <- NULL
[09:29:47.670]                           }
[09:29:47.670]                           if (!has_future || version < "1.8.0") {
[09:29:47.670]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.670]                               "", base::R.version$version.string), 
[09:29:47.670]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.670]                                 base::R.version$platform, 8 * 
[09:29:47.670]                                   base::.Machine$sizeof.pointer), 
[09:29:47.670]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.670]                                 "release", "version")], collapse = " "), 
[09:29:47.670]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.670]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.670]                               info)
[09:29:47.670]                             info <- base::paste(info, collapse = "; ")
[09:29:47.670]                             if (!has_future) {
[09:29:47.670]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.670]                                 info)
[09:29:47.670]                             }
[09:29:47.670]                             else {
[09:29:47.670]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.670]                                 info, version)
[09:29:47.670]                             }
[09:29:47.670]                             base::stop(msg)
[09:29:47.670]                           }
[09:29:47.670]                         })
[09:29:47.670]                       }
[09:29:47.670]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.670]                       base::options(mc.cores = 1L)
[09:29:47.670]                     }
[09:29:47.670]                     base::local({
[09:29:47.670]                       for (pkg in c("stats", "future.apply")) {
[09:29:47.670]                         base::loadNamespace(pkg)
[09:29:47.670]                         base::library(pkg, character.only = TRUE)
[09:29:47.670]                       }
[09:29:47.670]                     })
[09:29:47.670]                   }
[09:29:47.670]                   ...future.strategy.old <- future::plan("list")
[09:29:47.670]                   options(future.plan = NULL)
[09:29:47.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.670]                 }
[09:29:47.670]                 ...future.workdir <- getwd()
[09:29:47.670]             }
[09:29:47.670]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.670]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.670]         }
[09:29:47.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.670]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.670]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.670]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.670]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.670]             base::names(...future.oldOptions))
[09:29:47.670]     }
[09:29:47.670]     if (FALSE) {
[09:29:47.670]     }
[09:29:47.670]     else {
[09:29:47.670]         if (TRUE) {
[09:29:47.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.670]                 open = "w")
[09:29:47.670]         }
[09:29:47.670]         else {
[09:29:47.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.670]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.670]         }
[09:29:47.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.670]             base::sink(type = "output", split = FALSE)
[09:29:47.670]             base::close(...future.stdout)
[09:29:47.670]         }, add = TRUE)
[09:29:47.670]     }
[09:29:47.670]     ...future.frame <- base::sys.nframe()
[09:29:47.670]     ...future.conditions <- base::list()
[09:29:47.670]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.670]     if (FALSE) {
[09:29:47.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.670]     }
[09:29:47.670]     ...future.result <- base::tryCatch({
[09:29:47.670]         base::withCallingHandlers({
[09:29:47.670]             ...future.value <- base::withVisible(base::local({
[09:29:47.670]                 withCallingHandlers({
[09:29:47.670]                   {
[09:29:47.670]                     do.call(function(...) {
[09:29:47.670]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.670]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.670]                         ...future.globals.maxSize)) {
[09:29:47.670]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.670]                         on.exit(options(oopts), add = TRUE)
[09:29:47.670]                       }
[09:29:47.670]                       {
[09:29:47.670]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.670]                           FUN = function(jj) {
[09:29:47.670]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.670]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.670]                           })
[09:29:47.670]                       }
[09:29:47.670]                     }, args = future.call.arguments)
[09:29:47.670]                   }
[09:29:47.670]                 }, immediateCondition = function(cond) {
[09:29:47.670]                   save_rds <- function (object, pathname, ...) 
[09:29:47.670]                   {
[09:29:47.670]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.670]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.670]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.670]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.670]                         fi_tmp[["mtime"]])
[09:29:47.670]                     }
[09:29:47.670]                     tryCatch({
[09:29:47.670]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.670]                     }, error = function(ex) {
[09:29:47.670]                       msg <- conditionMessage(ex)
[09:29:47.670]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.670]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.670]                         fi_tmp[["mtime"]], msg)
[09:29:47.670]                       ex$message <- msg
[09:29:47.670]                       stop(ex)
[09:29:47.670]                     })
[09:29:47.670]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.670]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.670]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.670]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.670]                       fi <- file.info(pathname)
[09:29:47.670]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.670]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.670]                         fi[["size"]], fi[["mtime"]])
[09:29:47.670]                       stop(msg)
[09:29:47.670]                     }
[09:29:47.670]                     invisible(pathname)
[09:29:47.670]                   }
[09:29:47.670]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.670]                     rootPath = tempdir()) 
[09:29:47.670]                   {
[09:29:47.670]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.670]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.670]                       tmpdir = path, fileext = ".rds")
[09:29:47.670]                     save_rds(obj, file)
[09:29:47.670]                   }
[09:29:47.670]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.670]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.670]                   {
[09:29:47.670]                     inherits <- base::inherits
[09:29:47.670]                     invokeRestart <- base::invokeRestart
[09:29:47.670]                     is.null <- base::is.null
[09:29:47.670]                     muffled <- FALSE
[09:29:47.670]                     if (inherits(cond, "message")) {
[09:29:47.670]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.670]                       if (muffled) 
[09:29:47.670]                         invokeRestart("muffleMessage")
[09:29:47.670]                     }
[09:29:47.670]                     else if (inherits(cond, "warning")) {
[09:29:47.670]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.670]                       if (muffled) 
[09:29:47.670]                         invokeRestart("muffleWarning")
[09:29:47.670]                     }
[09:29:47.670]                     else if (inherits(cond, "condition")) {
[09:29:47.670]                       if (!is.null(pattern)) {
[09:29:47.670]                         computeRestarts <- base::computeRestarts
[09:29:47.670]                         grepl <- base::grepl
[09:29:47.670]                         restarts <- computeRestarts(cond)
[09:29:47.670]                         for (restart in restarts) {
[09:29:47.670]                           name <- restart$name
[09:29:47.670]                           if (is.null(name)) 
[09:29:47.670]                             next
[09:29:47.670]                           if (!grepl(pattern, name)) 
[09:29:47.670]                             next
[09:29:47.670]                           invokeRestart(restart)
[09:29:47.670]                           muffled <- TRUE
[09:29:47.670]                           break
[09:29:47.670]                         }
[09:29:47.670]                       }
[09:29:47.670]                     }
[09:29:47.670]                     invisible(muffled)
[09:29:47.670]                   }
[09:29:47.670]                   muffleCondition(cond)
[09:29:47.670]                 })
[09:29:47.670]             }))
[09:29:47.670]             future::FutureResult(value = ...future.value$value, 
[09:29:47.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.670]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.670]                     ...future.globalenv.names))
[09:29:47.670]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.670]         }, condition = base::local({
[09:29:47.670]             c <- base::c
[09:29:47.670]             inherits <- base::inherits
[09:29:47.670]             invokeRestart <- base::invokeRestart
[09:29:47.670]             length <- base::length
[09:29:47.670]             list <- base::list
[09:29:47.670]             seq.int <- base::seq.int
[09:29:47.670]             signalCondition <- base::signalCondition
[09:29:47.670]             sys.calls <- base::sys.calls
[09:29:47.670]             `[[` <- base::`[[`
[09:29:47.670]             `+` <- base::`+`
[09:29:47.670]             `<<-` <- base::`<<-`
[09:29:47.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.670]                   3L)]
[09:29:47.670]             }
[09:29:47.670]             function(cond) {
[09:29:47.670]                 is_error <- inherits(cond, "error")
[09:29:47.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.670]                   NULL)
[09:29:47.670]                 if (is_error) {
[09:29:47.670]                   sessionInformation <- function() {
[09:29:47.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.670]                       search = base::search(), system = base::Sys.info())
[09:29:47.670]                   }
[09:29:47.670]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.670]                     cond$call), session = sessionInformation(), 
[09:29:47.670]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.670]                   signalCondition(cond)
[09:29:47.670]                 }
[09:29:47.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.670]                 "immediateCondition"))) {
[09:29:47.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.670]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.670]                   if (TRUE && !signal) {
[09:29:47.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.670]                     {
[09:29:47.670]                       inherits <- base::inherits
[09:29:47.670]                       invokeRestart <- base::invokeRestart
[09:29:47.670]                       is.null <- base::is.null
[09:29:47.670]                       muffled <- FALSE
[09:29:47.670]                       if (inherits(cond, "message")) {
[09:29:47.670]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.670]                         if (muffled) 
[09:29:47.670]                           invokeRestart("muffleMessage")
[09:29:47.670]                       }
[09:29:47.670]                       else if (inherits(cond, "warning")) {
[09:29:47.670]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.670]                         if (muffled) 
[09:29:47.670]                           invokeRestart("muffleWarning")
[09:29:47.670]                       }
[09:29:47.670]                       else if (inherits(cond, "condition")) {
[09:29:47.670]                         if (!is.null(pattern)) {
[09:29:47.670]                           computeRestarts <- base::computeRestarts
[09:29:47.670]                           grepl <- base::grepl
[09:29:47.670]                           restarts <- computeRestarts(cond)
[09:29:47.670]                           for (restart in restarts) {
[09:29:47.670]                             name <- restart$name
[09:29:47.670]                             if (is.null(name)) 
[09:29:47.670]                               next
[09:29:47.670]                             if (!grepl(pattern, name)) 
[09:29:47.670]                               next
[09:29:47.670]                             invokeRestart(restart)
[09:29:47.670]                             muffled <- TRUE
[09:29:47.670]                             break
[09:29:47.670]                           }
[09:29:47.670]                         }
[09:29:47.670]                       }
[09:29:47.670]                       invisible(muffled)
[09:29:47.670]                     }
[09:29:47.670]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.670]                   }
[09:29:47.670]                 }
[09:29:47.670]                 else {
[09:29:47.670]                   if (TRUE) {
[09:29:47.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.670]                     {
[09:29:47.670]                       inherits <- base::inherits
[09:29:47.670]                       invokeRestart <- base::invokeRestart
[09:29:47.670]                       is.null <- base::is.null
[09:29:47.670]                       muffled <- FALSE
[09:29:47.670]                       if (inherits(cond, "message")) {
[09:29:47.670]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.670]                         if (muffled) 
[09:29:47.670]                           invokeRestart("muffleMessage")
[09:29:47.670]                       }
[09:29:47.670]                       else if (inherits(cond, "warning")) {
[09:29:47.670]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.670]                         if (muffled) 
[09:29:47.670]                           invokeRestart("muffleWarning")
[09:29:47.670]                       }
[09:29:47.670]                       else if (inherits(cond, "condition")) {
[09:29:47.670]                         if (!is.null(pattern)) {
[09:29:47.670]                           computeRestarts <- base::computeRestarts
[09:29:47.670]                           grepl <- base::grepl
[09:29:47.670]                           restarts <- computeRestarts(cond)
[09:29:47.670]                           for (restart in restarts) {
[09:29:47.670]                             name <- restart$name
[09:29:47.670]                             if (is.null(name)) 
[09:29:47.670]                               next
[09:29:47.670]                             if (!grepl(pattern, name)) 
[09:29:47.670]                               next
[09:29:47.670]                             invokeRestart(restart)
[09:29:47.670]                             muffled <- TRUE
[09:29:47.670]                             break
[09:29:47.670]                           }
[09:29:47.670]                         }
[09:29:47.670]                       }
[09:29:47.670]                       invisible(muffled)
[09:29:47.670]                     }
[09:29:47.670]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.670]                   }
[09:29:47.670]                 }
[09:29:47.670]             }
[09:29:47.670]         }))
[09:29:47.670]     }, error = function(ex) {
[09:29:47.670]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.670]                 ...future.rng), started = ...future.startTime, 
[09:29:47.670]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.670]             version = "1.8"), class = "FutureResult")
[09:29:47.670]     }, finally = {
[09:29:47.670]         if (!identical(...future.workdir, getwd())) 
[09:29:47.670]             setwd(...future.workdir)
[09:29:47.670]         {
[09:29:47.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.670]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.670]             }
[09:29:47.670]             base::options(...future.oldOptions)
[09:29:47.670]             if (.Platform$OS.type == "windows") {
[09:29:47.670]                 old_names <- names(...future.oldEnvVars)
[09:29:47.670]                 envs <- base::Sys.getenv()
[09:29:47.670]                 names <- names(envs)
[09:29:47.670]                 common <- intersect(names, old_names)
[09:29:47.670]                 added <- setdiff(names, old_names)
[09:29:47.670]                 removed <- setdiff(old_names, names)
[09:29:47.670]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.670]                   envs[common]]
[09:29:47.670]                 NAMES <- toupper(changed)
[09:29:47.670]                 args <- list()
[09:29:47.670]                 for (kk in seq_along(NAMES)) {
[09:29:47.670]                   name <- changed[[kk]]
[09:29:47.670]                   NAME <- NAMES[[kk]]
[09:29:47.670]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.670]                     next
[09:29:47.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.670]                 }
[09:29:47.670]                 NAMES <- toupper(added)
[09:29:47.670]                 for (kk in seq_along(NAMES)) {
[09:29:47.670]                   name <- added[[kk]]
[09:29:47.670]                   NAME <- NAMES[[kk]]
[09:29:47.670]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.670]                     next
[09:29:47.670]                   args[[name]] <- ""
[09:29:47.670]                 }
[09:29:47.670]                 NAMES <- toupper(removed)
[09:29:47.670]                 for (kk in seq_along(NAMES)) {
[09:29:47.670]                   name <- removed[[kk]]
[09:29:47.670]                   NAME <- NAMES[[kk]]
[09:29:47.670]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.670]                     next
[09:29:47.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.670]                 }
[09:29:47.670]                 if (length(args) > 0) 
[09:29:47.670]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.670]             }
[09:29:47.670]             else {
[09:29:47.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.670]             }
[09:29:47.670]             {
[09:29:47.670]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.670]                   0L) {
[09:29:47.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.670]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.670]                   base::options(opts)
[09:29:47.670]                 }
[09:29:47.670]                 {
[09:29:47.670]                   {
[09:29:47.670]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.670]                     NULL
[09:29:47.670]                   }
[09:29:47.670]                   options(future.plan = NULL)
[09:29:47.670]                   if (is.na(NA_character_)) 
[09:29:47.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.670]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.670]                     .init = FALSE)
[09:29:47.670]                 }
[09:29:47.670]             }
[09:29:47.670]         }
[09:29:47.670]     })
[09:29:47.670]     if (TRUE) {
[09:29:47.670]         base::sink(type = "output", split = FALSE)
[09:29:47.670]         if (TRUE) {
[09:29:47.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.670]         }
[09:29:47.670]         else {
[09:29:47.670]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.670]         }
[09:29:47.670]         base::close(...future.stdout)
[09:29:47.670]         ...future.stdout <- NULL
[09:29:47.670]     }
[09:29:47.670]     ...future.result$conditions <- ...future.conditions
[09:29:47.670]     ...future.result$finished <- base::Sys.time()
[09:29:47.670]     ...future.result
[09:29:47.670] }
[09:29:47.674] assign_globals() ...
[09:29:47.674] List of 11
[09:29:47.674]  $ ...future.FUN            :function (x, ...)  
[09:29:47.674]  $ x_FUN                    :function (x, na.rm = TRUE)  
[09:29:47.674]  $ times                    : int 5
[09:29:47.674]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.674]  $ stop_if_not              :function (...)  
[09:29:47.674]  $ dim                      : NULL
[09:29:47.674]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:47.674]  $ future.call.arguments    : list()
[09:29:47.674]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.674]  $ ...future.elements_ii    :List of 3
[09:29:47.674]   ..$ : int [1:7] 1 2 3 4 5 6 7
[09:29:47.674]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[09:29:47.674]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[09:29:47.674]  $ ...future.seeds_ii       : NULL
[09:29:47.674]  $ ...future.globals.maxSize: NULL
[09:29:47.674]  - attr(*, "where")=List of 11
[09:29:47.674]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.674]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:47.674]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:47.674]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:47.674]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:47.674]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:47.674]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:47.674]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.674]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.674]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.674]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.674]  - attr(*, "resolved")= logi FALSE
[09:29:47.674]  - attr(*, "total_size")= num 141240
[09:29:47.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.674]  - attr(*, "already-done")= logi TRUE
[09:29:47.686] - copied ‘...future.FUN’ to environment
[09:29:47.686] - copied ‘x_FUN’ to environment
[09:29:47.686] - copied ‘times’ to environment
[09:29:47.686] - copied ‘stopf’ to environment
[09:29:47.687] - copied ‘stop_if_not’ to environment
[09:29:47.687] - copied ‘dim’ to environment
[09:29:47.687] - copied ‘valid_types’ to environment
[09:29:47.687] - copied ‘future.call.arguments’ to environment
[09:29:47.687] - copied ‘...future.elements_ii’ to environment
[09:29:47.687] - copied ‘...future.seeds_ii’ to environment
[09:29:47.687] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.687] assign_globals() ... done
[09:29:47.687] requestCore(): workers = 2
[09:29:47.690] MulticoreFuture started
[09:29:47.690] - Launch lazy future ... done
[09:29:47.691] run() for ‘MulticoreFuture’ ... done
[09:29:47.691] Created future:
[09:29:47.692] plan(): Setting new future strategy stack:
[09:29:47.693] List of future strategies:
[09:29:47.693] 1. sequential:
[09:29:47.693]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.693]    - tweaked: FALSE
[09:29:47.693]    - call: NULL
[09:29:47.694] plan(): nbrOfWorkers() = 1
[09:29:47.697] plan(): Setting new future strategy stack:
[09:29:47.697] List of future strategies:
[09:29:47.697] 1. multicore:
[09:29:47.697]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.697]    - tweaked: FALSE
[09:29:47.697]    - call: plan(strategy)
[09:29:47.703] plan(): nbrOfWorkers() = 2
[09:29:47.692] MulticoreFuture:
[09:29:47.692] Label: ‘future_vapply-2’
[09:29:47.692] Expression:
[09:29:47.692] {
[09:29:47.692]     do.call(function(...) {
[09:29:47.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.692]             on.exit(options(oopts), add = TRUE)
[09:29:47.692]         }
[09:29:47.692]         {
[09:29:47.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.692]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.692]             })
[09:29:47.692]         }
[09:29:47.692]     }, args = future.call.arguments)
[09:29:47.692] }
[09:29:47.692] Lazy evaluation: FALSE
[09:29:47.692] Asynchronous evaluation: TRUE
[09:29:47.692] Local evaluation: TRUE
[09:29:47.692] Environment: R_GlobalEnv
[09:29:47.692] Capture standard output: TRUE
[09:29:47.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.692] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:47.692] Packages: 2 packages (‘stats’, ‘future.apply’)
[09:29:47.692] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.692] Resolved: TRUE
[09:29:47.692] Value: <not collected>
[09:29:47.692] Conditions captured: <none>
[09:29:47.692] Early signaling: FALSE
[09:29:47.692] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.692] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.703] Chunk #2 of 2 ... DONE
[09:29:47.704] Launching 2 futures (chunks) ... DONE
[09:29:47.704] Resolving 2 futures (chunks) ...
[09:29:47.704] resolve() on list ...
[09:29:47.704]  recursive: 0
[09:29:47.704]  length: 2
[09:29:47.704] 
[09:29:47.705] Future #1
[09:29:47.705] result() for MulticoreFuture ...
[09:29:47.706] result() for MulticoreFuture ...
[09:29:47.706] result() for MulticoreFuture ... done
[09:29:47.706] result() for MulticoreFuture ... done
[09:29:47.706] result() for MulticoreFuture ...
[09:29:47.706] result() for MulticoreFuture ... done
[09:29:47.706] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:47.707] - nx: 2
[09:29:47.707] - relay: TRUE
[09:29:47.707] - stdout: TRUE
[09:29:47.707] - signal: TRUE
[09:29:47.707] - resignal: FALSE
[09:29:47.707] - force: TRUE
[09:29:47.707] - relayed: [n=2] FALSE, FALSE
[09:29:47.707] - queued futures: [n=2] FALSE, FALSE
[09:29:47.708]  - until=1
[09:29:47.708]  - relaying element #1
[09:29:47.708] result() for MulticoreFuture ...
[09:29:47.708] result() for MulticoreFuture ... done
[09:29:47.708] result() for MulticoreFuture ...
[09:29:47.708] result() for MulticoreFuture ... done
[09:29:47.709] result() for MulticoreFuture ...
[09:29:47.709] result() for MulticoreFuture ... done
[09:29:47.709] result() for MulticoreFuture ...
[09:29:47.709] result() for MulticoreFuture ... done
[09:29:47.709] - relayed: [n=2] TRUE, FALSE
[09:29:47.709] - queued futures: [n=2] TRUE, FALSE
[09:29:47.709] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:47.710]  length: 1 (resolved future 1)
[09:29:47.710] Future #2
[09:29:47.710] result() for MulticoreFuture ...
[09:29:47.711] result() for MulticoreFuture ...
[09:29:47.711] result() for MulticoreFuture ... done
[09:29:47.711] result() for MulticoreFuture ... done
[09:29:47.711] result() for MulticoreFuture ...
[09:29:47.711] result() for MulticoreFuture ... done
[09:29:47.712] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:47.712] - nx: 2
[09:29:47.712] - relay: TRUE
[09:29:47.712] - stdout: TRUE
[09:29:47.712] - signal: TRUE
[09:29:47.712] - resignal: FALSE
[09:29:47.713] - force: TRUE
[09:29:47.713] - relayed: [n=2] TRUE, FALSE
[09:29:47.713] - queued futures: [n=2] TRUE, FALSE
[09:29:47.713]  - until=2
[09:29:47.713]  - relaying element #2
[09:29:47.713] result() for MulticoreFuture ...
[09:29:47.713] result() for MulticoreFuture ... done
[09:29:47.714] result() for MulticoreFuture ...
[09:29:47.714] result() for MulticoreFuture ... done
[09:29:47.714] result() for MulticoreFuture ...
[09:29:47.714] result() for MulticoreFuture ... done
[09:29:47.714] result() for MulticoreFuture ...
[09:29:47.714] result() for MulticoreFuture ... done
[09:29:47.714] - relayed: [n=2] TRUE, TRUE
[09:29:47.714] - queued futures: [n=2] TRUE, TRUE
[09:29:47.714] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:47.715]  length: 0 (resolved future 2)
[09:29:47.715] Relaying remaining futures
[09:29:47.715] signalConditionsASAP(NULL, pos=0) ...
[09:29:47.715] - nx: 2
[09:29:47.715] - relay: TRUE
[09:29:47.715] - stdout: TRUE
[09:29:47.715] - signal: TRUE
[09:29:47.715] - resignal: FALSE
[09:29:47.715] - force: TRUE
[09:29:47.715] - relayed: [n=2] TRUE, TRUE
[09:29:47.716] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:47.716] - relayed: [n=2] TRUE, TRUE
[09:29:47.716] - queued futures: [n=2] TRUE, TRUE
[09:29:47.716] signalConditionsASAP(NULL, pos=0) ... done
[09:29:47.716] resolve() on list ... DONE
[09:29:47.716] result() for MulticoreFuture ...
[09:29:47.716] result() for MulticoreFuture ... done
[09:29:47.716] result() for MulticoreFuture ...
[09:29:47.716] result() for MulticoreFuture ... done
[09:29:47.717] result() for MulticoreFuture ...
[09:29:47.717] result() for MulticoreFuture ... done
[09:29:47.717] result() for MulticoreFuture ...
[09:29:47.717] result() for MulticoreFuture ... done
[09:29:47.717]  - Number of value chunks collected: 2
[09:29:47.717] Resolving 2 futures (chunks) ... DONE
[09:29:47.717] Reducing values from 2 chunks ...
[09:29:47.717]  - Number of values collected after concatenation: 7
[09:29:47.717]  - Number of values expected: 7
[09:29:47.718] Reducing values from 2 chunks ... DONE
[09:29:47.718] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[09:29:47.720] future_lapply() ...
[09:29:47.724] Number of chunks: 2
[09:29:47.724] getGlobalsAndPackagesXApply() ...
[09:29:47.724]  - future.globals: TRUE
[09:29:47.724] getGlobalsAndPackages() ...
[09:29:47.725] Searching for globals...
[09:29:47.728] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[09:29:47.728] Searching for globals ... DONE
[09:29:47.728] Resolving globals: FALSE
[09:29:47.729] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[09:29:47.729] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[09:29:47.729] - globals: [1] ‘FUN’
[09:29:47.729] 
[09:29:47.730] getGlobalsAndPackages() ... DONE
[09:29:47.730]  - globals found/used: [n=1] ‘FUN’
[09:29:47.730]  - needed namespaces: [n=0] 
[09:29:47.730] Finding globals ... DONE
[09:29:47.730]  - use_args: TRUE
[09:29:47.730]  - Getting '...' globals ...
[09:29:47.731] resolve() on list ...
[09:29:47.731]  recursive: 0
[09:29:47.731]  length: 1
[09:29:47.731]  elements: ‘...’
[09:29:47.731]  length: 0 (resolved future 1)
[09:29:47.731] resolve() on list ... DONE
[09:29:47.731]    - '...' content: [n=1] ‘y’
[09:29:47.731] List of 1
[09:29:47.731]  $ ...:List of 1
[09:29:47.731]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:47.731]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.731]  - attr(*, "where")=List of 1
[09:29:47.731]   ..$ ...:<environment: 0x561d36546a10> 
[09:29:47.731]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.731]  - attr(*, "resolved")= logi TRUE
[09:29:47.731]  - attr(*, "total_size")= num NA
[09:29:47.735]  - Getting '...' globals ... DONE
[09:29:47.735] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:29:47.735] List of 2
[09:29:47.735]  $ ...future.FUN:function (x, y)  
[09:29:47.735]  $ ...          :List of 1
[09:29:47.735]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:47.735]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.735]  - attr(*, "where")=List of 2
[09:29:47.735]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:47.735]   ..$ ...          :<environment: 0x561d36546a10> 
[09:29:47.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.735]  - attr(*, "resolved")= logi FALSE
[09:29:47.735]  - attr(*, "total_size")= num 4264
[09:29:47.738] Packages to be attached in all futures: [n=0] 
[09:29:47.738] getGlobalsAndPackagesXApply() ... DONE
[09:29:47.738] Number of futures (= number of chunks): 2
[09:29:47.738] Launching 2 futures (chunks) ...
[09:29:47.738] Chunk #1 of 2 ...
[09:29:47.738]  - Finding globals in 'X' for chunk #1 ...
[09:29:47.739] getGlobalsAndPackages() ...
[09:29:47.739] Searching for globals...
[09:29:47.739] 
[09:29:47.739] Searching for globals ... DONE
[09:29:47.739] - globals: [0] <none>
[09:29:47.739] getGlobalsAndPackages() ... DONE
[09:29:47.739]    + additional globals found: [n=0] 
[09:29:47.739]    + additional namespaces needed: [n=0] 
[09:29:47.739]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:47.739]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.740]  - seeds: <none>
[09:29:47.740]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.740] getGlobalsAndPackages() ...
[09:29:47.740] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.740] Resolving globals: FALSE
[09:29:47.740] Tweak future expression to call with '...' arguments ...
[09:29:47.740] {
[09:29:47.740]     do.call(function(...) {
[09:29:47.740]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.740]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.740]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.740]             on.exit(options(oopts), add = TRUE)
[09:29:47.740]         }
[09:29:47.740]         {
[09:29:47.740]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.740]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.740]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.740]             })
[09:29:47.740]         }
[09:29:47.740]     }, args = future.call.arguments)
[09:29:47.740] }
[09:29:47.740] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.741] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.741] 
[09:29:47.741] getGlobalsAndPackages() ... DONE
[09:29:47.741] run() for ‘Future’ ...
[09:29:47.741] - state: ‘created’
[09:29:47.741] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.745] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.745] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.745]   - Field: ‘label’
[09:29:47.745]   - Field: ‘local’
[09:29:47.745]   - Field: ‘owner’
[09:29:47.745]   - Field: ‘envir’
[09:29:47.746]   - Field: ‘workers’
[09:29:47.746]   - Field: ‘packages’
[09:29:47.746]   - Field: ‘gc’
[09:29:47.746]   - Field: ‘job’
[09:29:47.746]   - Field: ‘conditions’
[09:29:47.746]   - Field: ‘expr’
[09:29:47.746]   - Field: ‘uuid’
[09:29:47.746]   - Field: ‘seed’
[09:29:47.746]   - Field: ‘version’
[09:29:47.746]   - Field: ‘result’
[09:29:47.746]   - Field: ‘asynchronous’
[09:29:47.747]   - Field: ‘calls’
[09:29:47.747]   - Field: ‘globals’
[09:29:47.747]   - Field: ‘stdout’
[09:29:47.747]   - Field: ‘earlySignal’
[09:29:47.747]   - Field: ‘lazy’
[09:29:47.747]   - Field: ‘state’
[09:29:47.747] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.747] - Launch lazy future ...
[09:29:47.747] Packages needed by the future expression (n = 0): <none>
[09:29:47.748] Packages needed by future strategies (n = 0): <none>
[09:29:47.748] {
[09:29:47.748]     {
[09:29:47.748]         {
[09:29:47.748]             ...future.startTime <- base::Sys.time()
[09:29:47.748]             {
[09:29:47.748]                 {
[09:29:47.748]                   {
[09:29:47.748]                     {
[09:29:47.748]                       base::local({
[09:29:47.748]                         has_future <- base::requireNamespace("future", 
[09:29:47.748]                           quietly = TRUE)
[09:29:47.748]                         if (has_future) {
[09:29:47.748]                           ns <- base::getNamespace("future")
[09:29:47.748]                           version <- ns[[".package"]][["version"]]
[09:29:47.748]                           if (is.null(version)) 
[09:29:47.748]                             version <- utils::packageVersion("future")
[09:29:47.748]                         }
[09:29:47.748]                         else {
[09:29:47.748]                           version <- NULL
[09:29:47.748]                         }
[09:29:47.748]                         if (!has_future || version < "1.8.0") {
[09:29:47.748]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.748]                             "", base::R.version$version.string), 
[09:29:47.748]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:47.748]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:47.748]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.748]                               "release", "version")], collapse = " "), 
[09:29:47.748]                             hostname = base::Sys.info()[["nodename"]])
[09:29:47.748]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.748]                             info)
[09:29:47.748]                           info <- base::paste(info, collapse = "; ")
[09:29:47.748]                           if (!has_future) {
[09:29:47.748]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.748]                               info)
[09:29:47.748]                           }
[09:29:47.748]                           else {
[09:29:47.748]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.748]                               info, version)
[09:29:47.748]                           }
[09:29:47.748]                           base::stop(msg)
[09:29:47.748]                         }
[09:29:47.748]                       })
[09:29:47.748]                     }
[09:29:47.748]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.748]                     base::options(mc.cores = 1L)
[09:29:47.748]                   }
[09:29:47.748]                   ...future.strategy.old <- future::plan("list")
[09:29:47.748]                   options(future.plan = NULL)
[09:29:47.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.748]                 }
[09:29:47.748]                 ...future.workdir <- getwd()
[09:29:47.748]             }
[09:29:47.748]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.748]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.748]         }
[09:29:47.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.748]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.748]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.748]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.748]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.748]             base::names(...future.oldOptions))
[09:29:47.748]     }
[09:29:47.748]     if (FALSE) {
[09:29:47.748]     }
[09:29:47.748]     else {
[09:29:47.748]         if (TRUE) {
[09:29:47.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.748]                 open = "w")
[09:29:47.748]         }
[09:29:47.748]         else {
[09:29:47.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.748]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.748]         }
[09:29:47.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.748]             base::sink(type = "output", split = FALSE)
[09:29:47.748]             base::close(...future.stdout)
[09:29:47.748]         }, add = TRUE)
[09:29:47.748]     }
[09:29:47.748]     ...future.frame <- base::sys.nframe()
[09:29:47.748]     ...future.conditions <- base::list()
[09:29:47.748]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.748]     if (FALSE) {
[09:29:47.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.748]     }
[09:29:47.748]     ...future.result <- base::tryCatch({
[09:29:47.748]         base::withCallingHandlers({
[09:29:47.748]             ...future.value <- base::withVisible(base::local({
[09:29:47.748]                 withCallingHandlers({
[09:29:47.748]                   {
[09:29:47.748]                     do.call(function(...) {
[09:29:47.748]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.748]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.748]                         ...future.globals.maxSize)) {
[09:29:47.748]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.748]                         on.exit(options(oopts), add = TRUE)
[09:29:47.748]                       }
[09:29:47.748]                       {
[09:29:47.748]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.748]                           FUN = function(jj) {
[09:29:47.748]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.748]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.748]                           })
[09:29:47.748]                       }
[09:29:47.748]                     }, args = future.call.arguments)
[09:29:47.748]                   }
[09:29:47.748]                 }, immediateCondition = function(cond) {
[09:29:47.748]                   save_rds <- function (object, pathname, ...) 
[09:29:47.748]                   {
[09:29:47.748]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.748]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.748]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.748]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.748]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.748]                         fi_tmp[["mtime"]])
[09:29:47.748]                     }
[09:29:47.748]                     tryCatch({
[09:29:47.748]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.748]                     }, error = function(ex) {
[09:29:47.748]                       msg <- conditionMessage(ex)
[09:29:47.748]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.748]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.748]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.748]                         fi_tmp[["mtime"]], msg)
[09:29:47.748]                       ex$message <- msg
[09:29:47.748]                       stop(ex)
[09:29:47.748]                     })
[09:29:47.748]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.748]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.748]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.748]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.748]                       fi <- file.info(pathname)
[09:29:47.748]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.748]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.748]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.748]                         fi[["size"]], fi[["mtime"]])
[09:29:47.748]                       stop(msg)
[09:29:47.748]                     }
[09:29:47.748]                     invisible(pathname)
[09:29:47.748]                   }
[09:29:47.748]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.748]                     rootPath = tempdir()) 
[09:29:47.748]                   {
[09:29:47.748]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.748]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.748]                       tmpdir = path, fileext = ".rds")
[09:29:47.748]                     save_rds(obj, file)
[09:29:47.748]                   }
[09:29:47.748]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.748]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.748]                   {
[09:29:47.748]                     inherits <- base::inherits
[09:29:47.748]                     invokeRestart <- base::invokeRestart
[09:29:47.748]                     is.null <- base::is.null
[09:29:47.748]                     muffled <- FALSE
[09:29:47.748]                     if (inherits(cond, "message")) {
[09:29:47.748]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.748]                       if (muffled) 
[09:29:47.748]                         invokeRestart("muffleMessage")
[09:29:47.748]                     }
[09:29:47.748]                     else if (inherits(cond, "warning")) {
[09:29:47.748]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.748]                       if (muffled) 
[09:29:47.748]                         invokeRestart("muffleWarning")
[09:29:47.748]                     }
[09:29:47.748]                     else if (inherits(cond, "condition")) {
[09:29:47.748]                       if (!is.null(pattern)) {
[09:29:47.748]                         computeRestarts <- base::computeRestarts
[09:29:47.748]                         grepl <- base::grepl
[09:29:47.748]                         restarts <- computeRestarts(cond)
[09:29:47.748]                         for (restart in restarts) {
[09:29:47.748]                           name <- restart$name
[09:29:47.748]                           if (is.null(name)) 
[09:29:47.748]                             next
[09:29:47.748]                           if (!grepl(pattern, name)) 
[09:29:47.748]                             next
[09:29:47.748]                           invokeRestart(restart)
[09:29:47.748]                           muffled <- TRUE
[09:29:47.748]                           break
[09:29:47.748]                         }
[09:29:47.748]                       }
[09:29:47.748]                     }
[09:29:47.748]                     invisible(muffled)
[09:29:47.748]                   }
[09:29:47.748]                   muffleCondition(cond)
[09:29:47.748]                 })
[09:29:47.748]             }))
[09:29:47.748]             future::FutureResult(value = ...future.value$value, 
[09:29:47.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.748]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.748]                     ...future.globalenv.names))
[09:29:47.748]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.748]         }, condition = base::local({
[09:29:47.748]             c <- base::c
[09:29:47.748]             inherits <- base::inherits
[09:29:47.748]             invokeRestart <- base::invokeRestart
[09:29:47.748]             length <- base::length
[09:29:47.748]             list <- base::list
[09:29:47.748]             seq.int <- base::seq.int
[09:29:47.748]             signalCondition <- base::signalCondition
[09:29:47.748]             sys.calls <- base::sys.calls
[09:29:47.748]             `[[` <- base::`[[`
[09:29:47.748]             `+` <- base::`+`
[09:29:47.748]             `<<-` <- base::`<<-`
[09:29:47.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.748]                   3L)]
[09:29:47.748]             }
[09:29:47.748]             function(cond) {
[09:29:47.748]                 is_error <- inherits(cond, "error")
[09:29:47.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.748]                   NULL)
[09:29:47.748]                 if (is_error) {
[09:29:47.748]                   sessionInformation <- function() {
[09:29:47.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.748]                       search = base::search(), system = base::Sys.info())
[09:29:47.748]                   }
[09:29:47.748]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.748]                     cond$call), session = sessionInformation(), 
[09:29:47.748]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.748]                   signalCondition(cond)
[09:29:47.748]                 }
[09:29:47.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.748]                 "immediateCondition"))) {
[09:29:47.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.748]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.748]                   if (TRUE && !signal) {
[09:29:47.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.748]                     {
[09:29:47.748]                       inherits <- base::inherits
[09:29:47.748]                       invokeRestart <- base::invokeRestart
[09:29:47.748]                       is.null <- base::is.null
[09:29:47.748]                       muffled <- FALSE
[09:29:47.748]                       if (inherits(cond, "message")) {
[09:29:47.748]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.748]                         if (muffled) 
[09:29:47.748]                           invokeRestart("muffleMessage")
[09:29:47.748]                       }
[09:29:47.748]                       else if (inherits(cond, "warning")) {
[09:29:47.748]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.748]                         if (muffled) 
[09:29:47.748]                           invokeRestart("muffleWarning")
[09:29:47.748]                       }
[09:29:47.748]                       else if (inherits(cond, "condition")) {
[09:29:47.748]                         if (!is.null(pattern)) {
[09:29:47.748]                           computeRestarts <- base::computeRestarts
[09:29:47.748]                           grepl <- base::grepl
[09:29:47.748]                           restarts <- computeRestarts(cond)
[09:29:47.748]                           for (restart in restarts) {
[09:29:47.748]                             name <- restart$name
[09:29:47.748]                             if (is.null(name)) 
[09:29:47.748]                               next
[09:29:47.748]                             if (!grepl(pattern, name)) 
[09:29:47.748]                               next
[09:29:47.748]                             invokeRestart(restart)
[09:29:47.748]                             muffled <- TRUE
[09:29:47.748]                             break
[09:29:47.748]                           }
[09:29:47.748]                         }
[09:29:47.748]                       }
[09:29:47.748]                       invisible(muffled)
[09:29:47.748]                     }
[09:29:47.748]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.748]                   }
[09:29:47.748]                 }
[09:29:47.748]                 else {
[09:29:47.748]                   if (TRUE) {
[09:29:47.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.748]                     {
[09:29:47.748]                       inherits <- base::inherits
[09:29:47.748]                       invokeRestart <- base::invokeRestart
[09:29:47.748]                       is.null <- base::is.null
[09:29:47.748]                       muffled <- FALSE
[09:29:47.748]                       if (inherits(cond, "message")) {
[09:29:47.748]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.748]                         if (muffled) 
[09:29:47.748]                           invokeRestart("muffleMessage")
[09:29:47.748]                       }
[09:29:47.748]                       else if (inherits(cond, "warning")) {
[09:29:47.748]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.748]                         if (muffled) 
[09:29:47.748]                           invokeRestart("muffleWarning")
[09:29:47.748]                       }
[09:29:47.748]                       else if (inherits(cond, "condition")) {
[09:29:47.748]                         if (!is.null(pattern)) {
[09:29:47.748]                           computeRestarts <- base::computeRestarts
[09:29:47.748]                           grepl <- base::grepl
[09:29:47.748]                           restarts <- computeRestarts(cond)
[09:29:47.748]                           for (restart in restarts) {
[09:29:47.748]                             name <- restart$name
[09:29:47.748]                             if (is.null(name)) 
[09:29:47.748]                               next
[09:29:47.748]                             if (!grepl(pattern, name)) 
[09:29:47.748]                               next
[09:29:47.748]                             invokeRestart(restart)
[09:29:47.748]                             muffled <- TRUE
[09:29:47.748]                             break
[09:29:47.748]                           }
[09:29:47.748]                         }
[09:29:47.748]                       }
[09:29:47.748]                       invisible(muffled)
[09:29:47.748]                     }
[09:29:47.748]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.748]                   }
[09:29:47.748]                 }
[09:29:47.748]             }
[09:29:47.748]         }))
[09:29:47.748]     }, error = function(ex) {
[09:29:47.748]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.748]                 ...future.rng), started = ...future.startTime, 
[09:29:47.748]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.748]             version = "1.8"), class = "FutureResult")
[09:29:47.748]     }, finally = {
[09:29:47.748]         if (!identical(...future.workdir, getwd())) 
[09:29:47.748]             setwd(...future.workdir)
[09:29:47.748]         {
[09:29:47.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.748]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.748]             }
[09:29:47.748]             base::options(...future.oldOptions)
[09:29:47.748]             if (.Platform$OS.type == "windows") {
[09:29:47.748]                 old_names <- names(...future.oldEnvVars)
[09:29:47.748]                 envs <- base::Sys.getenv()
[09:29:47.748]                 names <- names(envs)
[09:29:47.748]                 common <- intersect(names, old_names)
[09:29:47.748]                 added <- setdiff(names, old_names)
[09:29:47.748]                 removed <- setdiff(old_names, names)
[09:29:47.748]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.748]                   envs[common]]
[09:29:47.748]                 NAMES <- toupper(changed)
[09:29:47.748]                 args <- list()
[09:29:47.748]                 for (kk in seq_along(NAMES)) {
[09:29:47.748]                   name <- changed[[kk]]
[09:29:47.748]                   NAME <- NAMES[[kk]]
[09:29:47.748]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.748]                     next
[09:29:47.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.748]                 }
[09:29:47.748]                 NAMES <- toupper(added)
[09:29:47.748]                 for (kk in seq_along(NAMES)) {
[09:29:47.748]                   name <- added[[kk]]
[09:29:47.748]                   NAME <- NAMES[[kk]]
[09:29:47.748]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.748]                     next
[09:29:47.748]                   args[[name]] <- ""
[09:29:47.748]                 }
[09:29:47.748]                 NAMES <- toupper(removed)
[09:29:47.748]                 for (kk in seq_along(NAMES)) {
[09:29:47.748]                   name <- removed[[kk]]
[09:29:47.748]                   NAME <- NAMES[[kk]]
[09:29:47.748]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.748]                     next
[09:29:47.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.748]                 }
[09:29:47.748]                 if (length(args) > 0) 
[09:29:47.748]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.748]             }
[09:29:47.748]             else {
[09:29:47.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.748]             }
[09:29:47.748]             {
[09:29:47.748]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.748]                   0L) {
[09:29:47.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.748]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.748]                   base::options(opts)
[09:29:47.748]                 }
[09:29:47.748]                 {
[09:29:47.748]                   {
[09:29:47.748]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.748]                     NULL
[09:29:47.748]                   }
[09:29:47.748]                   options(future.plan = NULL)
[09:29:47.748]                   if (is.na(NA_character_)) 
[09:29:47.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.748]                     .init = FALSE)
[09:29:47.748]                 }
[09:29:47.748]             }
[09:29:47.748]         }
[09:29:47.748]     })
[09:29:47.748]     if (TRUE) {
[09:29:47.748]         base::sink(type = "output", split = FALSE)
[09:29:47.748]         if (TRUE) {
[09:29:47.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.748]         }
[09:29:47.748]         else {
[09:29:47.748]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.748]         }
[09:29:47.748]         base::close(...future.stdout)
[09:29:47.748]         ...future.stdout <- NULL
[09:29:47.748]     }
[09:29:47.748]     ...future.result$conditions <- ...future.conditions
[09:29:47.748]     ...future.result$finished <- base::Sys.time()
[09:29:47.748]     ...future.result
[09:29:47.748] }
[09:29:47.751] assign_globals() ...
[09:29:47.751] List of 5
[09:29:47.751]  $ ...future.FUN            :function (x, y)  
[09:29:47.751]  $ future.call.arguments    :List of 1
[09:29:47.751]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:47.751]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.751]  $ ...future.elements_ii    :List of 2
[09:29:47.751]   ..$ A: num 50
[09:29:47.751]   ..$ B: num 60
[09:29:47.751]  $ ...future.seeds_ii       : NULL
[09:29:47.751]  $ ...future.globals.maxSize: NULL
[09:29:47.751]  - attr(*, "where")=List of 5
[09:29:47.751]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.751]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.751]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.751]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.751]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.751]  - attr(*, "resolved")= logi FALSE
[09:29:47.751]  - attr(*, "total_size")= num 4264
[09:29:47.751]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.751]  - attr(*, "already-done")= logi TRUE
[09:29:47.758] - reassign environment for ‘...future.FUN’
[09:29:47.758] - copied ‘...future.FUN’ to environment
[09:29:47.758] - copied ‘future.call.arguments’ to environment
[09:29:47.758] - copied ‘...future.elements_ii’ to environment
[09:29:47.758] - copied ‘...future.seeds_ii’ to environment
[09:29:47.758] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.759] assign_globals() ... done
[09:29:47.759] requestCore(): workers = 2
[09:29:47.761] MulticoreFuture started
[09:29:47.761] - Launch lazy future ... done
[09:29:47.761] run() for ‘MulticoreFuture’ ... done
[09:29:47.762] plan(): Setting new future strategy stack:
[09:29:47.762] Created future:
[09:29:47.762] List of future strategies:
[09:29:47.762] 1. sequential:
[09:29:47.762]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.762]    - tweaked: FALSE
[09:29:47.762]    - call: NULL
[09:29:47.763] plan(): nbrOfWorkers() = 1
[09:29:47.765] plan(): Setting new future strategy stack:
[09:29:47.765] List of future strategies:
[09:29:47.765] 1. multicore:
[09:29:47.765]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.765]    - tweaked: FALSE
[09:29:47.765]    - call: plan(strategy)
[09:29:47.770] plan(): nbrOfWorkers() = 2
[09:29:47.762] MulticoreFuture:
[09:29:47.762] Label: ‘future_sapply-1’
[09:29:47.762] Expression:
[09:29:47.762] {
[09:29:47.762]     do.call(function(...) {
[09:29:47.762]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.762]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.762]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.762]             on.exit(options(oopts), add = TRUE)
[09:29:47.762]         }
[09:29:47.762]         {
[09:29:47.762]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.762]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.762]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.762]             })
[09:29:47.762]         }
[09:29:47.762]     }, args = future.call.arguments)
[09:29:47.762] }
[09:29:47.762] Lazy evaluation: FALSE
[09:29:47.762] Asynchronous evaluation: TRUE
[09:29:47.762] Local evaluation: TRUE
[09:29:47.762] Environment: R_GlobalEnv
[09:29:47.762] Capture standard output: TRUE
[09:29:47.762] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.762] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:47.762] Packages: <none>
[09:29:47.762] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.762] Resolved: TRUE
[09:29:47.762] Value: <not collected>
[09:29:47.762] Conditions captured: <none>
[09:29:47.762] Early signaling: FALSE
[09:29:47.762] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.762] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.771] Chunk #1 of 2 ... DONE
[09:29:47.772] Chunk #2 of 2 ...
[09:29:47.772]  - Finding globals in 'X' for chunk #2 ...
[09:29:47.772] getGlobalsAndPackages() ...
[09:29:47.772] Searching for globals...
[09:29:47.773] 
[09:29:47.773] Searching for globals ... DONE
[09:29:47.773] - globals: [0] <none>
[09:29:47.773] getGlobalsAndPackages() ... DONE
[09:29:47.773]    + additional globals found: [n=0] 
[09:29:47.773]    + additional namespaces needed: [n=0] 
[09:29:47.773]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:47.774]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.774]  - seeds: <none>
[09:29:47.774]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.774] getGlobalsAndPackages() ...
[09:29:47.774] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.774] Resolving globals: FALSE
[09:29:47.775] Tweak future expression to call with '...' arguments ...
[09:29:47.775] {
[09:29:47.775]     do.call(function(...) {
[09:29:47.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.775]             on.exit(options(oopts), add = TRUE)
[09:29:47.775]         }
[09:29:47.775]         {
[09:29:47.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.775]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.775]             })
[09:29:47.775]         }
[09:29:47.775]     }, args = future.call.arguments)
[09:29:47.775] }
[09:29:47.775] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.776] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.776] 
[09:29:47.776] getGlobalsAndPackages() ... DONE
[09:29:47.777] run() for ‘Future’ ...
[09:29:47.777] - state: ‘created’
[09:29:47.777] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.781] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.782] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.782]   - Field: ‘label’
[09:29:47.782]   - Field: ‘local’
[09:29:47.782]   - Field: ‘owner’
[09:29:47.782]   - Field: ‘envir’
[09:29:47.783]   - Field: ‘workers’
[09:29:47.783]   - Field: ‘packages’
[09:29:47.783]   - Field: ‘gc’
[09:29:47.783]   - Field: ‘job’
[09:29:47.783]   - Field: ‘conditions’
[09:29:47.783]   - Field: ‘expr’
[09:29:47.783]   - Field: ‘uuid’
[09:29:47.784]   - Field: ‘seed’
[09:29:47.784]   - Field: ‘version’
[09:29:47.784]   - Field: ‘result’
[09:29:47.784]   - Field: ‘asynchronous’
[09:29:47.784]   - Field: ‘calls’
[09:29:47.784]   - Field: ‘globals’
[09:29:47.784]   - Field: ‘stdout’
[09:29:47.785]   - Field: ‘earlySignal’
[09:29:47.785]   - Field: ‘lazy’
[09:29:47.785]   - Field: ‘state’
[09:29:47.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.785] - Launch lazy future ...
[09:29:47.786] Packages needed by the future expression (n = 0): <none>
[09:29:47.786] Packages needed by future strategies (n = 0): <none>
[09:29:47.786] {
[09:29:47.786]     {
[09:29:47.786]         {
[09:29:47.786]             ...future.startTime <- base::Sys.time()
[09:29:47.786]             {
[09:29:47.786]                 {
[09:29:47.786]                   {
[09:29:47.786]                     {
[09:29:47.786]                       base::local({
[09:29:47.786]                         has_future <- base::requireNamespace("future", 
[09:29:47.786]                           quietly = TRUE)
[09:29:47.786]                         if (has_future) {
[09:29:47.786]                           ns <- base::getNamespace("future")
[09:29:47.786]                           version <- ns[[".package"]][["version"]]
[09:29:47.786]                           if (is.null(version)) 
[09:29:47.786]                             version <- utils::packageVersion("future")
[09:29:47.786]                         }
[09:29:47.786]                         else {
[09:29:47.786]                           version <- NULL
[09:29:47.786]                         }
[09:29:47.786]                         if (!has_future || version < "1.8.0") {
[09:29:47.786]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.786]                             "", base::R.version$version.string), 
[09:29:47.786]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:47.786]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:47.786]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.786]                               "release", "version")], collapse = " "), 
[09:29:47.786]                             hostname = base::Sys.info()[["nodename"]])
[09:29:47.786]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.786]                             info)
[09:29:47.786]                           info <- base::paste(info, collapse = "; ")
[09:29:47.786]                           if (!has_future) {
[09:29:47.786]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.786]                               info)
[09:29:47.786]                           }
[09:29:47.786]                           else {
[09:29:47.786]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.786]                               info, version)
[09:29:47.786]                           }
[09:29:47.786]                           base::stop(msg)
[09:29:47.786]                         }
[09:29:47.786]                       })
[09:29:47.786]                     }
[09:29:47.786]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.786]                     base::options(mc.cores = 1L)
[09:29:47.786]                   }
[09:29:47.786]                   ...future.strategy.old <- future::plan("list")
[09:29:47.786]                   options(future.plan = NULL)
[09:29:47.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.786]                 }
[09:29:47.786]                 ...future.workdir <- getwd()
[09:29:47.786]             }
[09:29:47.786]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.786]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.786]         }
[09:29:47.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.786]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.786]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.786]             base::names(...future.oldOptions))
[09:29:47.786]     }
[09:29:47.786]     if (FALSE) {
[09:29:47.786]     }
[09:29:47.786]     else {
[09:29:47.786]         if (TRUE) {
[09:29:47.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.786]                 open = "w")
[09:29:47.786]         }
[09:29:47.786]         else {
[09:29:47.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.786]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.786]         }
[09:29:47.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.786]             base::sink(type = "output", split = FALSE)
[09:29:47.786]             base::close(...future.stdout)
[09:29:47.786]         }, add = TRUE)
[09:29:47.786]     }
[09:29:47.786]     ...future.frame <- base::sys.nframe()
[09:29:47.786]     ...future.conditions <- base::list()
[09:29:47.786]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.786]     if (FALSE) {
[09:29:47.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.786]     }
[09:29:47.786]     ...future.result <- base::tryCatch({
[09:29:47.786]         base::withCallingHandlers({
[09:29:47.786]             ...future.value <- base::withVisible(base::local({
[09:29:47.786]                 withCallingHandlers({
[09:29:47.786]                   {
[09:29:47.786]                     do.call(function(...) {
[09:29:47.786]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.786]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.786]                         ...future.globals.maxSize)) {
[09:29:47.786]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.786]                         on.exit(options(oopts), add = TRUE)
[09:29:47.786]                       }
[09:29:47.786]                       {
[09:29:47.786]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.786]                           FUN = function(jj) {
[09:29:47.786]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.786]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.786]                           })
[09:29:47.786]                       }
[09:29:47.786]                     }, args = future.call.arguments)
[09:29:47.786]                   }
[09:29:47.786]                 }, immediateCondition = function(cond) {
[09:29:47.786]                   save_rds <- function (object, pathname, ...) 
[09:29:47.786]                   {
[09:29:47.786]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.786]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.786]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.786]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.786]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.786]                         fi_tmp[["mtime"]])
[09:29:47.786]                     }
[09:29:47.786]                     tryCatch({
[09:29:47.786]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.786]                     }, error = function(ex) {
[09:29:47.786]                       msg <- conditionMessage(ex)
[09:29:47.786]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.786]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.786]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.786]                         fi_tmp[["mtime"]], msg)
[09:29:47.786]                       ex$message <- msg
[09:29:47.786]                       stop(ex)
[09:29:47.786]                     })
[09:29:47.786]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.786]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.786]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.786]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.786]                       fi <- file.info(pathname)
[09:29:47.786]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.786]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.786]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.786]                         fi[["size"]], fi[["mtime"]])
[09:29:47.786]                       stop(msg)
[09:29:47.786]                     }
[09:29:47.786]                     invisible(pathname)
[09:29:47.786]                   }
[09:29:47.786]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.786]                     rootPath = tempdir()) 
[09:29:47.786]                   {
[09:29:47.786]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.786]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.786]                       tmpdir = path, fileext = ".rds")
[09:29:47.786]                     save_rds(obj, file)
[09:29:47.786]                   }
[09:29:47.786]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.786]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.786]                   {
[09:29:47.786]                     inherits <- base::inherits
[09:29:47.786]                     invokeRestart <- base::invokeRestart
[09:29:47.786]                     is.null <- base::is.null
[09:29:47.786]                     muffled <- FALSE
[09:29:47.786]                     if (inherits(cond, "message")) {
[09:29:47.786]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.786]                       if (muffled) 
[09:29:47.786]                         invokeRestart("muffleMessage")
[09:29:47.786]                     }
[09:29:47.786]                     else if (inherits(cond, "warning")) {
[09:29:47.786]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.786]                       if (muffled) 
[09:29:47.786]                         invokeRestart("muffleWarning")
[09:29:47.786]                     }
[09:29:47.786]                     else if (inherits(cond, "condition")) {
[09:29:47.786]                       if (!is.null(pattern)) {
[09:29:47.786]                         computeRestarts <- base::computeRestarts
[09:29:47.786]                         grepl <- base::grepl
[09:29:47.786]                         restarts <- computeRestarts(cond)
[09:29:47.786]                         for (restart in restarts) {
[09:29:47.786]                           name <- restart$name
[09:29:47.786]                           if (is.null(name)) 
[09:29:47.786]                             next
[09:29:47.786]                           if (!grepl(pattern, name)) 
[09:29:47.786]                             next
[09:29:47.786]                           invokeRestart(restart)
[09:29:47.786]                           muffled <- TRUE
[09:29:47.786]                           break
[09:29:47.786]                         }
[09:29:47.786]                       }
[09:29:47.786]                     }
[09:29:47.786]                     invisible(muffled)
[09:29:47.786]                   }
[09:29:47.786]                   muffleCondition(cond)
[09:29:47.786]                 })
[09:29:47.786]             }))
[09:29:47.786]             future::FutureResult(value = ...future.value$value, 
[09:29:47.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.786]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.786]                     ...future.globalenv.names))
[09:29:47.786]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.786]         }, condition = base::local({
[09:29:47.786]             c <- base::c
[09:29:47.786]             inherits <- base::inherits
[09:29:47.786]             invokeRestart <- base::invokeRestart
[09:29:47.786]             length <- base::length
[09:29:47.786]             list <- base::list
[09:29:47.786]             seq.int <- base::seq.int
[09:29:47.786]             signalCondition <- base::signalCondition
[09:29:47.786]             sys.calls <- base::sys.calls
[09:29:47.786]             `[[` <- base::`[[`
[09:29:47.786]             `+` <- base::`+`
[09:29:47.786]             `<<-` <- base::`<<-`
[09:29:47.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.786]                   3L)]
[09:29:47.786]             }
[09:29:47.786]             function(cond) {
[09:29:47.786]                 is_error <- inherits(cond, "error")
[09:29:47.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.786]                   NULL)
[09:29:47.786]                 if (is_error) {
[09:29:47.786]                   sessionInformation <- function() {
[09:29:47.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.786]                       search = base::search(), system = base::Sys.info())
[09:29:47.786]                   }
[09:29:47.786]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.786]                     cond$call), session = sessionInformation(), 
[09:29:47.786]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.786]                   signalCondition(cond)
[09:29:47.786]                 }
[09:29:47.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.786]                 "immediateCondition"))) {
[09:29:47.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.786]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.786]                   if (TRUE && !signal) {
[09:29:47.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.786]                     {
[09:29:47.786]                       inherits <- base::inherits
[09:29:47.786]                       invokeRestart <- base::invokeRestart
[09:29:47.786]                       is.null <- base::is.null
[09:29:47.786]                       muffled <- FALSE
[09:29:47.786]                       if (inherits(cond, "message")) {
[09:29:47.786]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.786]                         if (muffled) 
[09:29:47.786]                           invokeRestart("muffleMessage")
[09:29:47.786]                       }
[09:29:47.786]                       else if (inherits(cond, "warning")) {
[09:29:47.786]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.786]                         if (muffled) 
[09:29:47.786]                           invokeRestart("muffleWarning")
[09:29:47.786]                       }
[09:29:47.786]                       else if (inherits(cond, "condition")) {
[09:29:47.786]                         if (!is.null(pattern)) {
[09:29:47.786]                           computeRestarts <- base::computeRestarts
[09:29:47.786]                           grepl <- base::grepl
[09:29:47.786]                           restarts <- computeRestarts(cond)
[09:29:47.786]                           for (restart in restarts) {
[09:29:47.786]                             name <- restart$name
[09:29:47.786]                             if (is.null(name)) 
[09:29:47.786]                               next
[09:29:47.786]                             if (!grepl(pattern, name)) 
[09:29:47.786]                               next
[09:29:47.786]                             invokeRestart(restart)
[09:29:47.786]                             muffled <- TRUE
[09:29:47.786]                             break
[09:29:47.786]                           }
[09:29:47.786]                         }
[09:29:47.786]                       }
[09:29:47.786]                       invisible(muffled)
[09:29:47.786]                     }
[09:29:47.786]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.786]                   }
[09:29:47.786]                 }
[09:29:47.786]                 else {
[09:29:47.786]                   if (TRUE) {
[09:29:47.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.786]                     {
[09:29:47.786]                       inherits <- base::inherits
[09:29:47.786]                       invokeRestart <- base::invokeRestart
[09:29:47.786]                       is.null <- base::is.null
[09:29:47.786]                       muffled <- FALSE
[09:29:47.786]                       if (inherits(cond, "message")) {
[09:29:47.786]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.786]                         if (muffled) 
[09:29:47.786]                           invokeRestart("muffleMessage")
[09:29:47.786]                       }
[09:29:47.786]                       else if (inherits(cond, "warning")) {
[09:29:47.786]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.786]                         if (muffled) 
[09:29:47.786]                           invokeRestart("muffleWarning")
[09:29:47.786]                       }
[09:29:47.786]                       else if (inherits(cond, "condition")) {
[09:29:47.786]                         if (!is.null(pattern)) {
[09:29:47.786]                           computeRestarts <- base::computeRestarts
[09:29:47.786]                           grepl <- base::grepl
[09:29:47.786]                           restarts <- computeRestarts(cond)
[09:29:47.786]                           for (restart in restarts) {
[09:29:47.786]                             name <- restart$name
[09:29:47.786]                             if (is.null(name)) 
[09:29:47.786]                               next
[09:29:47.786]                             if (!grepl(pattern, name)) 
[09:29:47.786]                               next
[09:29:47.786]                             invokeRestart(restart)
[09:29:47.786]                             muffled <- TRUE
[09:29:47.786]                             break
[09:29:47.786]                           }
[09:29:47.786]                         }
[09:29:47.786]                       }
[09:29:47.786]                       invisible(muffled)
[09:29:47.786]                     }
[09:29:47.786]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.786]                   }
[09:29:47.786]                 }
[09:29:47.786]             }
[09:29:47.786]         }))
[09:29:47.786]     }, error = function(ex) {
[09:29:47.786]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.786]                 ...future.rng), started = ...future.startTime, 
[09:29:47.786]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.786]             version = "1.8"), class = "FutureResult")
[09:29:47.786]     }, finally = {
[09:29:47.786]         if (!identical(...future.workdir, getwd())) 
[09:29:47.786]             setwd(...future.workdir)
[09:29:47.786]         {
[09:29:47.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.786]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.786]             }
[09:29:47.786]             base::options(...future.oldOptions)
[09:29:47.786]             if (.Platform$OS.type == "windows") {
[09:29:47.786]                 old_names <- names(...future.oldEnvVars)
[09:29:47.786]                 envs <- base::Sys.getenv()
[09:29:47.786]                 names <- names(envs)
[09:29:47.786]                 common <- intersect(names, old_names)
[09:29:47.786]                 added <- setdiff(names, old_names)
[09:29:47.786]                 removed <- setdiff(old_names, names)
[09:29:47.786]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.786]                   envs[common]]
[09:29:47.786]                 NAMES <- toupper(changed)
[09:29:47.786]                 args <- list()
[09:29:47.786]                 for (kk in seq_along(NAMES)) {
[09:29:47.786]                   name <- changed[[kk]]
[09:29:47.786]                   NAME <- NAMES[[kk]]
[09:29:47.786]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.786]                     next
[09:29:47.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.786]                 }
[09:29:47.786]                 NAMES <- toupper(added)
[09:29:47.786]                 for (kk in seq_along(NAMES)) {
[09:29:47.786]                   name <- added[[kk]]
[09:29:47.786]                   NAME <- NAMES[[kk]]
[09:29:47.786]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.786]                     next
[09:29:47.786]                   args[[name]] <- ""
[09:29:47.786]                 }
[09:29:47.786]                 NAMES <- toupper(removed)
[09:29:47.786]                 for (kk in seq_along(NAMES)) {
[09:29:47.786]                   name <- removed[[kk]]
[09:29:47.786]                   NAME <- NAMES[[kk]]
[09:29:47.786]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.786]                     next
[09:29:47.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.786]                 }
[09:29:47.786]                 if (length(args) > 0) 
[09:29:47.786]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.786]             }
[09:29:47.786]             else {
[09:29:47.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.786]             }
[09:29:47.786]             {
[09:29:47.786]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.786]                   0L) {
[09:29:47.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.786]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.786]                   base::options(opts)
[09:29:47.786]                 }
[09:29:47.786]                 {
[09:29:47.786]                   {
[09:29:47.786]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.786]                     NULL
[09:29:47.786]                   }
[09:29:47.786]                   options(future.plan = NULL)
[09:29:47.786]                   if (is.na(NA_character_)) 
[09:29:47.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.786]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.786]                     .init = FALSE)
[09:29:47.786]                 }
[09:29:47.786]             }
[09:29:47.786]         }
[09:29:47.786]     })
[09:29:47.786]     if (TRUE) {
[09:29:47.786]         base::sink(type = "output", split = FALSE)
[09:29:47.786]         if (TRUE) {
[09:29:47.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.786]         }
[09:29:47.786]         else {
[09:29:47.786]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.786]         }
[09:29:47.786]         base::close(...future.stdout)
[09:29:47.786]         ...future.stdout <- NULL
[09:29:47.786]     }
[09:29:47.786]     ...future.result$conditions <- ...future.conditions
[09:29:47.786]     ...future.result$finished <- base::Sys.time()
[09:29:47.786]     ...future.result
[09:29:47.786] }
[09:29:47.790] assign_globals() ...
[09:29:47.790] List of 5
[09:29:47.790]  $ ...future.FUN            :function (x, y)  
[09:29:47.790]  $ future.call.arguments    :List of 1
[09:29:47.790]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:47.790]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.790]  $ ...future.elements_ii    :List of 2
[09:29:47.790]   ..$ C: num 70
[09:29:47.790]   ..$ D: num 80
[09:29:47.790]  $ ...future.seeds_ii       : NULL
[09:29:47.790]  $ ...future.globals.maxSize: NULL
[09:29:47.790]  - attr(*, "where")=List of 5
[09:29:47.790]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.790]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.790]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.790]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.790]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.790]  - attr(*, "resolved")= logi FALSE
[09:29:47.790]  - attr(*, "total_size")= num 4264
[09:29:47.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.790]  - attr(*, "already-done")= logi TRUE
[09:29:47.802] - reassign environment for ‘...future.FUN’
[09:29:47.803] - copied ‘...future.FUN’ to environment
[09:29:47.803] - copied ‘future.call.arguments’ to environment
[09:29:47.803] - copied ‘...future.elements_ii’ to environment
[09:29:47.803] - copied ‘...future.seeds_ii’ to environment
[09:29:47.803] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.803] assign_globals() ... done
[09:29:47.803] requestCore(): workers = 2
[09:29:47.806] MulticoreFuture started
[09:29:47.807] - Launch lazy future ... done
[09:29:47.807] plan(): Setting new future strategy stack:
[09:29:47.807] run() for ‘MulticoreFuture’ ... done
[09:29:47.808] Created future:
[09:29:47.808] List of future strategies:
[09:29:47.808] 1. sequential:
[09:29:47.808]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.808]    - tweaked: FALSE
[09:29:47.808]    - call: NULL
[09:29:47.809] plan(): nbrOfWorkers() = 1
[09:29:47.812] plan(): Setting new future strategy stack:
[09:29:47.812] List of future strategies:
[09:29:47.812] 1. multicore:
[09:29:47.812]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.812]    - tweaked: FALSE
[09:29:47.812]    - call: plan(strategy)
[09:29:47.817] plan(): nbrOfWorkers() = 2
[09:29:47.808] MulticoreFuture:
[09:29:47.808] Label: ‘future_sapply-2’
[09:29:47.808] Expression:
[09:29:47.808] {
[09:29:47.808]     do.call(function(...) {
[09:29:47.808]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.808]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.808]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.808]             on.exit(options(oopts), add = TRUE)
[09:29:47.808]         }
[09:29:47.808]         {
[09:29:47.808]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.808]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.808]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.808]             })
[09:29:47.808]         }
[09:29:47.808]     }, args = future.call.arguments)
[09:29:47.808] }
[09:29:47.808] Lazy evaluation: FALSE
[09:29:47.808] Asynchronous evaluation: TRUE
[09:29:47.808] Local evaluation: TRUE
[09:29:47.808] Environment: R_GlobalEnv
[09:29:47.808] Capture standard output: TRUE
[09:29:47.808] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.808] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:47.808] Packages: <none>
[09:29:47.808] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.808] Resolved: TRUE
[09:29:47.808] Value: <not collected>
[09:29:47.808] Conditions captured: <none>
[09:29:47.808] Early signaling: FALSE
[09:29:47.808] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.808] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.818] Chunk #2 of 2 ... DONE
[09:29:47.818] Launching 2 futures (chunks) ... DONE
[09:29:47.819] Resolving 2 futures (chunks) ...
[09:29:47.819] resolve() on list ...
[09:29:47.819]  recursive: 0
[09:29:47.819]  length: 2
[09:29:47.819] 
[09:29:47.820] Future #1
[09:29:47.820] result() for MulticoreFuture ...
[09:29:47.821] result() for MulticoreFuture ...
[09:29:47.821] result() for MulticoreFuture ... done
[09:29:47.821] result() for MulticoreFuture ... done
[09:29:47.821] result() for MulticoreFuture ...
[09:29:47.821] result() for MulticoreFuture ... done
[09:29:47.822] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:47.822] - nx: 2
[09:29:47.822] - relay: TRUE
[09:29:47.822] - stdout: TRUE
[09:29:47.822] - signal: TRUE
[09:29:47.822] - resignal: FALSE
[09:29:47.822] - force: TRUE
[09:29:47.822] - relayed: [n=2] FALSE, FALSE
[09:29:47.823] - queued futures: [n=2] FALSE, FALSE
[09:29:47.823]  - until=1
[09:29:47.823]  - relaying element #1
[09:29:47.823] result() for MulticoreFuture ...
[09:29:47.823] result() for MulticoreFuture ... done
[09:29:47.823] result() for MulticoreFuture ...
[09:29:47.823] result() for MulticoreFuture ... done
[09:29:47.824] result() for MulticoreFuture ...
[09:29:47.824] result() for MulticoreFuture ... done
[09:29:47.824] result() for MulticoreFuture ...
[09:29:47.824] result() for MulticoreFuture ... done
[09:29:47.824] - relayed: [n=2] TRUE, FALSE
[09:29:47.824] - queued futures: [n=2] TRUE, FALSE
[09:29:47.825] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:47.825]  length: 1 (resolved future 1)
[09:29:47.825] Future #2
[09:29:47.825] result() for MulticoreFuture ...
[09:29:47.826] result() for MulticoreFuture ...
[09:29:47.826] result() for MulticoreFuture ... done
[09:29:47.826] result() for MulticoreFuture ... done
[09:29:47.826] result() for MulticoreFuture ...
[09:29:47.826] result() for MulticoreFuture ... done
[09:29:47.826] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:47.827] - nx: 2
[09:29:47.827] - relay: TRUE
[09:29:47.827] - stdout: TRUE
[09:29:47.827] - signal: TRUE
[09:29:47.827] - resignal: FALSE
[09:29:47.827] - force: TRUE
[09:29:47.827] - relayed: [n=2] TRUE, FALSE
[09:29:47.827] - queued futures: [n=2] TRUE, FALSE
[09:29:47.828]  - until=2
[09:29:47.828]  - relaying element #2
[09:29:47.828] result() for MulticoreFuture ...
[09:29:47.828] result() for MulticoreFuture ... done
[09:29:47.828] result() for MulticoreFuture ...
[09:29:47.828] result() for MulticoreFuture ... done
[09:29:47.828] result() for MulticoreFuture ...
[09:29:47.828] result() for MulticoreFuture ... done
[09:29:47.829] result() for MulticoreFuture ...
[09:29:47.829] result() for MulticoreFuture ... done
[09:29:47.829] - relayed: [n=2] TRUE, TRUE
[09:29:47.829] - queued futures: [n=2] TRUE, TRUE
[09:29:47.829] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:47.829]  length: 0 (resolved future 2)
[09:29:47.829] Relaying remaining futures
[09:29:47.829] signalConditionsASAP(NULL, pos=0) ...
[09:29:47.829] - nx: 2
[09:29:47.830] - relay: TRUE
[09:29:47.830] - stdout: TRUE
[09:29:47.830] - signal: TRUE
[09:29:47.830] - resignal: FALSE
[09:29:47.830] - force: TRUE
[09:29:47.830] - relayed: [n=2] TRUE, TRUE
[09:29:47.830] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:47.830] - relayed: [n=2] TRUE, TRUE
[09:29:47.830] - queued futures: [n=2] TRUE, TRUE
[09:29:47.831] signalConditionsASAP(NULL, pos=0) ... done
[09:29:47.831] resolve() on list ... DONE
[09:29:47.831] result() for MulticoreFuture ...
[09:29:47.831] result() for MulticoreFuture ... done
[09:29:47.831] result() for MulticoreFuture ...
[09:29:47.831] result() for MulticoreFuture ... done
[09:29:47.831] result() for MulticoreFuture ...
[09:29:47.831] result() for MulticoreFuture ... done
[09:29:47.831] result() for MulticoreFuture ...
[09:29:47.832] result() for MulticoreFuture ... done
[09:29:47.832]  - Number of value chunks collected: 2
[09:29:47.832] Resolving 2 futures (chunks) ... DONE
[09:29:47.832] Reducing values from 2 chunks ...
[09:29:47.832]  - Number of values collected after concatenation: 4
[09:29:47.832]  - Number of values expected: 4
[09:29:47.832] Reducing values from 2 chunks ... DONE
[09:29:47.832] future_lapply() ... DONE
[09:29:47.833] future_lapply() ...
[09:29:47.841] Number of chunks: 2
[09:29:47.841] getGlobalsAndPackagesXApply() ...
[09:29:47.841]  - future.globals: TRUE
[09:29:47.841] getGlobalsAndPackages() ...
[09:29:47.841] Searching for globals...
[09:29:47.846] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[09:29:47.846] Searching for globals ... DONE
[09:29:47.846] Resolving globals: FALSE
[09:29:47.847] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[09:29:47.847] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:47.848] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.848] - packages: [1] ‘future.apply’
[09:29:47.848] getGlobalsAndPackages() ... DONE
[09:29:47.848]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.848]  - needed namespaces: [n=1] ‘future.apply’
[09:29:47.848] Finding globals ... DONE
[09:29:47.848]  - use_args: TRUE
[09:29:47.848]  - Getting '...' globals ...
[09:29:47.849] resolve() on list ...
[09:29:47.849]  recursive: 0
[09:29:47.849]  length: 1
[09:29:47.849]  elements: ‘...’
[09:29:47.849]  length: 0 (resolved future 1)
[09:29:47.849] resolve() on list ... DONE
[09:29:47.849]    - '...' content: [n=1] ‘y’
[09:29:47.849] List of 1
[09:29:47.849]  $ ...:List of 1
[09:29:47.849]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:47.849]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.849]  - attr(*, "where")=List of 1
[09:29:47.849]   ..$ ...:<environment: 0x561d3653dbe0> 
[09:29:47.849]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.849]  - attr(*, "resolved")= logi TRUE
[09:29:47.849]  - attr(*, "total_size")= num NA
[09:29:47.852]  - Getting '...' globals ... DONE
[09:29:47.853] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:47.853] List of 8
[09:29:47.853]  $ ...future.FUN:function (x, ...)  
[09:29:47.853]  $ x_FUN        :function (x, y)  
[09:29:47.853]  $ times        : int 15
[09:29:47.853]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.853]  $ stop_if_not  :function (...)  
[09:29:47.853]  $ dim          : int [1:2] 3 5
[09:29:47.853]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:47.853]  $ ...          :List of 1
[09:29:47.853]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:47.853]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.853]  - attr(*, "where")=List of 8
[09:29:47.853]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:47.853]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:47.853]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:47.853]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:47.853]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:47.853]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:47.853]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:47.853]   ..$ ...          :<environment: 0x561d3653dbe0> 
[09:29:47.853]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.853]  - attr(*, "resolved")= logi FALSE
[09:29:47.853]  - attr(*, "total_size")= num 98600
[09:29:47.860] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:47.860] getGlobalsAndPackagesXApply() ... DONE
[09:29:47.860] Number of futures (= number of chunks): 2
[09:29:47.860] Launching 2 futures (chunks) ...
[09:29:47.860] Chunk #1 of 2 ...
[09:29:47.860]  - Finding globals in 'X' for chunk #1 ...
[09:29:47.861] getGlobalsAndPackages() ...
[09:29:47.861] Searching for globals...
[09:29:47.861] 
[09:29:47.861] Searching for globals ... DONE
[09:29:47.861] - globals: [0] <none>
[09:29:47.861] getGlobalsAndPackages() ... DONE
[09:29:47.861]    + additional globals found: [n=0] 
[09:29:47.861]    + additional namespaces needed: [n=0] 
[09:29:47.861]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:47.862]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.862]  - seeds: <none>
[09:29:47.862]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.862] getGlobalsAndPackages() ...
[09:29:47.862] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.862] Resolving globals: FALSE
[09:29:47.862] Tweak future expression to call with '...' arguments ...
[09:29:47.862] {
[09:29:47.862]     do.call(function(...) {
[09:29:47.862]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.862]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.862]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.862]             on.exit(options(oopts), add = TRUE)
[09:29:47.862]         }
[09:29:47.862]         {
[09:29:47.862]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.862]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.862]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.862]             })
[09:29:47.862]         }
[09:29:47.862]     }, args = future.call.arguments)
[09:29:47.862] }
[09:29:47.862] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.863] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.863] - packages: [1] ‘future.apply’
[09:29:47.863] getGlobalsAndPackages() ... DONE
[09:29:47.864] run() for ‘Future’ ...
[09:29:47.864] - state: ‘created’
[09:29:47.864] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.867] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.867] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.867]   - Field: ‘label’
[09:29:47.868]   - Field: ‘local’
[09:29:47.868]   - Field: ‘owner’
[09:29:47.868]   - Field: ‘envir’
[09:29:47.868]   - Field: ‘workers’
[09:29:47.868]   - Field: ‘packages’
[09:29:47.868]   - Field: ‘gc’
[09:29:47.868]   - Field: ‘job’
[09:29:47.868]   - Field: ‘conditions’
[09:29:47.868]   - Field: ‘expr’
[09:29:47.868]   - Field: ‘uuid’
[09:29:47.868]   - Field: ‘seed’
[09:29:47.869]   - Field: ‘version’
[09:29:47.869]   - Field: ‘result’
[09:29:47.869]   - Field: ‘asynchronous’
[09:29:47.869]   - Field: ‘calls’
[09:29:47.869]   - Field: ‘globals’
[09:29:47.869]   - Field: ‘stdout’
[09:29:47.869]   - Field: ‘earlySignal’
[09:29:47.869]   - Field: ‘lazy’
[09:29:47.869]   - Field: ‘state’
[09:29:47.869] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.869] - Launch lazy future ...
[09:29:47.870] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:47.870] Packages needed by future strategies (n = 0): <none>
[09:29:47.870] {
[09:29:47.870]     {
[09:29:47.870]         {
[09:29:47.870]             ...future.startTime <- base::Sys.time()
[09:29:47.870]             {
[09:29:47.870]                 {
[09:29:47.870]                   {
[09:29:47.870]                     {
[09:29:47.870]                       {
[09:29:47.870]                         base::local({
[09:29:47.870]                           has_future <- base::requireNamespace("future", 
[09:29:47.870]                             quietly = TRUE)
[09:29:47.870]                           if (has_future) {
[09:29:47.870]                             ns <- base::getNamespace("future")
[09:29:47.870]                             version <- ns[[".package"]][["version"]]
[09:29:47.870]                             if (is.null(version)) 
[09:29:47.870]                               version <- utils::packageVersion("future")
[09:29:47.870]                           }
[09:29:47.870]                           else {
[09:29:47.870]                             version <- NULL
[09:29:47.870]                           }
[09:29:47.870]                           if (!has_future || version < "1.8.0") {
[09:29:47.870]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.870]                               "", base::R.version$version.string), 
[09:29:47.870]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.870]                                 base::R.version$platform, 8 * 
[09:29:47.870]                                   base::.Machine$sizeof.pointer), 
[09:29:47.870]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.870]                                 "release", "version")], collapse = " "), 
[09:29:47.870]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.870]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.870]                               info)
[09:29:47.870]                             info <- base::paste(info, collapse = "; ")
[09:29:47.870]                             if (!has_future) {
[09:29:47.870]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.870]                                 info)
[09:29:47.870]                             }
[09:29:47.870]                             else {
[09:29:47.870]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.870]                                 info, version)
[09:29:47.870]                             }
[09:29:47.870]                             base::stop(msg)
[09:29:47.870]                           }
[09:29:47.870]                         })
[09:29:47.870]                       }
[09:29:47.870]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.870]                       base::options(mc.cores = 1L)
[09:29:47.870]                     }
[09:29:47.870]                     base::local({
[09:29:47.870]                       for (pkg in "future.apply") {
[09:29:47.870]                         base::loadNamespace(pkg)
[09:29:47.870]                         base::library(pkg, character.only = TRUE)
[09:29:47.870]                       }
[09:29:47.870]                     })
[09:29:47.870]                   }
[09:29:47.870]                   ...future.strategy.old <- future::plan("list")
[09:29:47.870]                   options(future.plan = NULL)
[09:29:47.870]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.870]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.870]                 }
[09:29:47.870]                 ...future.workdir <- getwd()
[09:29:47.870]             }
[09:29:47.870]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.870]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.870]         }
[09:29:47.870]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.870]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.870]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.870]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.870]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.870]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.870]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.870]             base::names(...future.oldOptions))
[09:29:47.870]     }
[09:29:47.870]     if (FALSE) {
[09:29:47.870]     }
[09:29:47.870]     else {
[09:29:47.870]         if (TRUE) {
[09:29:47.870]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.870]                 open = "w")
[09:29:47.870]         }
[09:29:47.870]         else {
[09:29:47.870]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.870]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.870]         }
[09:29:47.870]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.870]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.870]             base::sink(type = "output", split = FALSE)
[09:29:47.870]             base::close(...future.stdout)
[09:29:47.870]         }, add = TRUE)
[09:29:47.870]     }
[09:29:47.870]     ...future.frame <- base::sys.nframe()
[09:29:47.870]     ...future.conditions <- base::list()
[09:29:47.870]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.870]     if (FALSE) {
[09:29:47.870]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.870]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.870]     }
[09:29:47.870]     ...future.result <- base::tryCatch({
[09:29:47.870]         base::withCallingHandlers({
[09:29:47.870]             ...future.value <- base::withVisible(base::local({
[09:29:47.870]                 withCallingHandlers({
[09:29:47.870]                   {
[09:29:47.870]                     do.call(function(...) {
[09:29:47.870]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.870]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.870]                         ...future.globals.maxSize)) {
[09:29:47.870]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.870]                         on.exit(options(oopts), add = TRUE)
[09:29:47.870]                       }
[09:29:47.870]                       {
[09:29:47.870]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.870]                           FUN = function(jj) {
[09:29:47.870]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.870]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.870]                           })
[09:29:47.870]                       }
[09:29:47.870]                     }, args = future.call.arguments)
[09:29:47.870]                   }
[09:29:47.870]                 }, immediateCondition = function(cond) {
[09:29:47.870]                   save_rds <- function (object, pathname, ...) 
[09:29:47.870]                   {
[09:29:47.870]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.870]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.870]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.870]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.870]                         fi_tmp[["mtime"]])
[09:29:47.870]                     }
[09:29:47.870]                     tryCatch({
[09:29:47.870]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.870]                     }, error = function(ex) {
[09:29:47.870]                       msg <- conditionMessage(ex)
[09:29:47.870]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.870]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.870]                         fi_tmp[["mtime"]], msg)
[09:29:47.870]                       ex$message <- msg
[09:29:47.870]                       stop(ex)
[09:29:47.870]                     })
[09:29:47.870]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.870]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.870]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.870]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.870]                       fi <- file.info(pathname)
[09:29:47.870]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.870]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.870]                         fi[["size"]], fi[["mtime"]])
[09:29:47.870]                       stop(msg)
[09:29:47.870]                     }
[09:29:47.870]                     invisible(pathname)
[09:29:47.870]                   }
[09:29:47.870]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.870]                     rootPath = tempdir()) 
[09:29:47.870]                   {
[09:29:47.870]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.870]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.870]                       tmpdir = path, fileext = ".rds")
[09:29:47.870]                     save_rds(obj, file)
[09:29:47.870]                   }
[09:29:47.870]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.870]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.870]                   {
[09:29:47.870]                     inherits <- base::inherits
[09:29:47.870]                     invokeRestart <- base::invokeRestart
[09:29:47.870]                     is.null <- base::is.null
[09:29:47.870]                     muffled <- FALSE
[09:29:47.870]                     if (inherits(cond, "message")) {
[09:29:47.870]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.870]                       if (muffled) 
[09:29:47.870]                         invokeRestart("muffleMessage")
[09:29:47.870]                     }
[09:29:47.870]                     else if (inherits(cond, "warning")) {
[09:29:47.870]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.870]                       if (muffled) 
[09:29:47.870]                         invokeRestart("muffleWarning")
[09:29:47.870]                     }
[09:29:47.870]                     else if (inherits(cond, "condition")) {
[09:29:47.870]                       if (!is.null(pattern)) {
[09:29:47.870]                         computeRestarts <- base::computeRestarts
[09:29:47.870]                         grepl <- base::grepl
[09:29:47.870]                         restarts <- computeRestarts(cond)
[09:29:47.870]                         for (restart in restarts) {
[09:29:47.870]                           name <- restart$name
[09:29:47.870]                           if (is.null(name)) 
[09:29:47.870]                             next
[09:29:47.870]                           if (!grepl(pattern, name)) 
[09:29:47.870]                             next
[09:29:47.870]                           invokeRestart(restart)
[09:29:47.870]                           muffled <- TRUE
[09:29:47.870]                           break
[09:29:47.870]                         }
[09:29:47.870]                       }
[09:29:47.870]                     }
[09:29:47.870]                     invisible(muffled)
[09:29:47.870]                   }
[09:29:47.870]                   muffleCondition(cond)
[09:29:47.870]                 })
[09:29:47.870]             }))
[09:29:47.870]             future::FutureResult(value = ...future.value$value, 
[09:29:47.870]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.870]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.870]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.870]                     ...future.globalenv.names))
[09:29:47.870]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.870]         }, condition = base::local({
[09:29:47.870]             c <- base::c
[09:29:47.870]             inherits <- base::inherits
[09:29:47.870]             invokeRestart <- base::invokeRestart
[09:29:47.870]             length <- base::length
[09:29:47.870]             list <- base::list
[09:29:47.870]             seq.int <- base::seq.int
[09:29:47.870]             signalCondition <- base::signalCondition
[09:29:47.870]             sys.calls <- base::sys.calls
[09:29:47.870]             `[[` <- base::`[[`
[09:29:47.870]             `+` <- base::`+`
[09:29:47.870]             `<<-` <- base::`<<-`
[09:29:47.870]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.870]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.870]                   3L)]
[09:29:47.870]             }
[09:29:47.870]             function(cond) {
[09:29:47.870]                 is_error <- inherits(cond, "error")
[09:29:47.870]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.870]                   NULL)
[09:29:47.870]                 if (is_error) {
[09:29:47.870]                   sessionInformation <- function() {
[09:29:47.870]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.870]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.870]                       search = base::search(), system = base::Sys.info())
[09:29:47.870]                   }
[09:29:47.870]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.870]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.870]                     cond$call), session = sessionInformation(), 
[09:29:47.870]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.870]                   signalCondition(cond)
[09:29:47.870]                 }
[09:29:47.870]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.870]                 "immediateCondition"))) {
[09:29:47.870]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.870]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.870]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.870]                   if (TRUE && !signal) {
[09:29:47.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.870]                     {
[09:29:47.870]                       inherits <- base::inherits
[09:29:47.870]                       invokeRestart <- base::invokeRestart
[09:29:47.870]                       is.null <- base::is.null
[09:29:47.870]                       muffled <- FALSE
[09:29:47.870]                       if (inherits(cond, "message")) {
[09:29:47.870]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.870]                         if (muffled) 
[09:29:47.870]                           invokeRestart("muffleMessage")
[09:29:47.870]                       }
[09:29:47.870]                       else if (inherits(cond, "warning")) {
[09:29:47.870]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.870]                         if (muffled) 
[09:29:47.870]                           invokeRestart("muffleWarning")
[09:29:47.870]                       }
[09:29:47.870]                       else if (inherits(cond, "condition")) {
[09:29:47.870]                         if (!is.null(pattern)) {
[09:29:47.870]                           computeRestarts <- base::computeRestarts
[09:29:47.870]                           grepl <- base::grepl
[09:29:47.870]                           restarts <- computeRestarts(cond)
[09:29:47.870]                           for (restart in restarts) {
[09:29:47.870]                             name <- restart$name
[09:29:47.870]                             if (is.null(name)) 
[09:29:47.870]                               next
[09:29:47.870]                             if (!grepl(pattern, name)) 
[09:29:47.870]                               next
[09:29:47.870]                             invokeRestart(restart)
[09:29:47.870]                             muffled <- TRUE
[09:29:47.870]                             break
[09:29:47.870]                           }
[09:29:47.870]                         }
[09:29:47.870]                       }
[09:29:47.870]                       invisible(muffled)
[09:29:47.870]                     }
[09:29:47.870]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.870]                   }
[09:29:47.870]                 }
[09:29:47.870]                 else {
[09:29:47.870]                   if (TRUE) {
[09:29:47.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.870]                     {
[09:29:47.870]                       inherits <- base::inherits
[09:29:47.870]                       invokeRestart <- base::invokeRestart
[09:29:47.870]                       is.null <- base::is.null
[09:29:47.870]                       muffled <- FALSE
[09:29:47.870]                       if (inherits(cond, "message")) {
[09:29:47.870]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.870]                         if (muffled) 
[09:29:47.870]                           invokeRestart("muffleMessage")
[09:29:47.870]                       }
[09:29:47.870]                       else if (inherits(cond, "warning")) {
[09:29:47.870]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.870]                         if (muffled) 
[09:29:47.870]                           invokeRestart("muffleWarning")
[09:29:47.870]                       }
[09:29:47.870]                       else if (inherits(cond, "condition")) {
[09:29:47.870]                         if (!is.null(pattern)) {
[09:29:47.870]                           computeRestarts <- base::computeRestarts
[09:29:47.870]                           grepl <- base::grepl
[09:29:47.870]                           restarts <- computeRestarts(cond)
[09:29:47.870]                           for (restart in restarts) {
[09:29:47.870]                             name <- restart$name
[09:29:47.870]                             if (is.null(name)) 
[09:29:47.870]                               next
[09:29:47.870]                             if (!grepl(pattern, name)) 
[09:29:47.870]                               next
[09:29:47.870]                             invokeRestart(restart)
[09:29:47.870]                             muffled <- TRUE
[09:29:47.870]                             break
[09:29:47.870]                           }
[09:29:47.870]                         }
[09:29:47.870]                       }
[09:29:47.870]                       invisible(muffled)
[09:29:47.870]                     }
[09:29:47.870]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.870]                   }
[09:29:47.870]                 }
[09:29:47.870]             }
[09:29:47.870]         }))
[09:29:47.870]     }, error = function(ex) {
[09:29:47.870]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.870]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.870]                 ...future.rng), started = ...future.startTime, 
[09:29:47.870]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.870]             version = "1.8"), class = "FutureResult")
[09:29:47.870]     }, finally = {
[09:29:47.870]         if (!identical(...future.workdir, getwd())) 
[09:29:47.870]             setwd(...future.workdir)
[09:29:47.870]         {
[09:29:47.870]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.870]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.870]             }
[09:29:47.870]             base::options(...future.oldOptions)
[09:29:47.870]             if (.Platform$OS.type == "windows") {
[09:29:47.870]                 old_names <- names(...future.oldEnvVars)
[09:29:47.870]                 envs <- base::Sys.getenv()
[09:29:47.870]                 names <- names(envs)
[09:29:47.870]                 common <- intersect(names, old_names)
[09:29:47.870]                 added <- setdiff(names, old_names)
[09:29:47.870]                 removed <- setdiff(old_names, names)
[09:29:47.870]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.870]                   envs[common]]
[09:29:47.870]                 NAMES <- toupper(changed)
[09:29:47.870]                 args <- list()
[09:29:47.870]                 for (kk in seq_along(NAMES)) {
[09:29:47.870]                   name <- changed[[kk]]
[09:29:47.870]                   NAME <- NAMES[[kk]]
[09:29:47.870]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.870]                     next
[09:29:47.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.870]                 }
[09:29:47.870]                 NAMES <- toupper(added)
[09:29:47.870]                 for (kk in seq_along(NAMES)) {
[09:29:47.870]                   name <- added[[kk]]
[09:29:47.870]                   NAME <- NAMES[[kk]]
[09:29:47.870]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.870]                     next
[09:29:47.870]                   args[[name]] <- ""
[09:29:47.870]                 }
[09:29:47.870]                 NAMES <- toupper(removed)
[09:29:47.870]                 for (kk in seq_along(NAMES)) {
[09:29:47.870]                   name <- removed[[kk]]
[09:29:47.870]                   NAME <- NAMES[[kk]]
[09:29:47.870]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.870]                     next
[09:29:47.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.870]                 }
[09:29:47.870]                 if (length(args) > 0) 
[09:29:47.870]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.870]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.870]             }
[09:29:47.870]             else {
[09:29:47.870]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.870]             }
[09:29:47.870]             {
[09:29:47.870]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.870]                   0L) {
[09:29:47.870]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.870]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.870]                   base::options(opts)
[09:29:47.870]                 }
[09:29:47.870]                 {
[09:29:47.870]                   {
[09:29:47.870]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.870]                     NULL
[09:29:47.870]                   }
[09:29:47.870]                   options(future.plan = NULL)
[09:29:47.870]                   if (is.na(NA_character_)) 
[09:29:47.870]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.870]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.870]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.870]                     .init = FALSE)
[09:29:47.870]                 }
[09:29:47.870]             }
[09:29:47.870]         }
[09:29:47.870]     })
[09:29:47.870]     if (TRUE) {
[09:29:47.870]         base::sink(type = "output", split = FALSE)
[09:29:47.870]         if (TRUE) {
[09:29:47.870]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.870]         }
[09:29:47.870]         else {
[09:29:47.870]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.870]         }
[09:29:47.870]         base::close(...future.stdout)
[09:29:47.870]         ...future.stdout <- NULL
[09:29:47.870]     }
[09:29:47.870]     ...future.result$conditions <- ...future.conditions
[09:29:47.870]     ...future.result$finished <- base::Sys.time()
[09:29:47.870]     ...future.result
[09:29:47.870] }
[09:29:47.873] assign_globals() ...
[09:29:47.873] List of 11
[09:29:47.873]  $ ...future.FUN            :function (x, ...)  
[09:29:47.873]  $ x_FUN                    :function (x, y)  
[09:29:47.873]  $ times                    : int 15
[09:29:47.873]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.873]  $ stop_if_not              :function (...)  
[09:29:47.873]  $ dim                      : int [1:2] 3 5
[09:29:47.873]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:47.873]  $ future.call.arguments    :List of 1
[09:29:47.873]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:47.873]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.873]  $ ...future.elements_ii    :List of 2
[09:29:47.873]   ..$ A: num 50
[09:29:47.873]   ..$ B: num 60
[09:29:47.873]  $ ...future.seeds_ii       : NULL
[09:29:47.873]  $ ...future.globals.maxSize: NULL
[09:29:47.873]  - attr(*, "where")=List of 11
[09:29:47.873]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.873]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:47.873]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:47.873]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:47.873]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:47.873]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:47.873]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:47.873]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.873]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.873]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.873]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.873]  - attr(*, "resolved")= logi FALSE
[09:29:47.873]  - attr(*, "total_size")= num 98600
[09:29:47.873]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.873]  - attr(*, "already-done")= logi TRUE
[09:29:47.882] - copied ‘...future.FUN’ to environment
[09:29:47.882] - reassign environment for ‘x_FUN’
[09:29:47.882] - copied ‘x_FUN’ to environment
[09:29:47.882] - copied ‘times’ to environment
[09:29:47.883] - copied ‘stopf’ to environment
[09:29:47.883] - copied ‘stop_if_not’ to environment
[09:29:47.883] - copied ‘dim’ to environment
[09:29:47.883] - copied ‘valid_types’ to environment
[09:29:47.883] - copied ‘future.call.arguments’ to environment
[09:29:47.883] - copied ‘...future.elements_ii’ to environment
[09:29:47.883] - copied ‘...future.seeds_ii’ to environment
[09:29:47.883] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.883] assign_globals() ... done
[09:29:47.883] requestCore(): workers = 2
[09:29:47.886] MulticoreFuture started
[09:29:47.887] - Launch lazy future ... done
[09:29:47.887] run() for ‘MulticoreFuture’ ... done
[09:29:47.888] Created future:
[09:29:47.888] plan(): Setting new future strategy stack:
[09:29:47.888] List of future strategies:
[09:29:47.888] 1. sequential:
[09:29:47.888]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.888]    - tweaked: FALSE
[09:29:47.888]    - call: NULL
[09:29:47.890] plan(): nbrOfWorkers() = 1
[09:29:47.893] plan(): Setting new future strategy stack:
[09:29:47.893] List of future strategies:
[09:29:47.893] 1. multicore:
[09:29:47.893]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.893]    - tweaked: FALSE
[09:29:47.893]    - call: plan(strategy)
[09:29:47.900] plan(): nbrOfWorkers() = 2
[09:29:47.888] MulticoreFuture:
[09:29:47.888] Label: ‘future_vapply-1’
[09:29:47.888] Expression:
[09:29:47.888] {
[09:29:47.888]     do.call(function(...) {
[09:29:47.888]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.888]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.888]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.888]             on.exit(options(oopts), add = TRUE)
[09:29:47.888]         }
[09:29:47.888]         {
[09:29:47.888]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.888]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.888]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.888]             })
[09:29:47.888]         }
[09:29:47.888]     }, args = future.call.arguments)
[09:29:47.888] }
[09:29:47.888] Lazy evaluation: FALSE
[09:29:47.888] Asynchronous evaluation: TRUE
[09:29:47.888] Local evaluation: TRUE
[09:29:47.888] Environment: R_GlobalEnv
[09:29:47.888] Capture standard output: TRUE
[09:29:47.888] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.888] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:47.888] Packages: 1 packages (‘future.apply’)
[09:29:47.888] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.888] Resolved: TRUE
[09:29:47.888] Value: <not collected>
[09:29:47.888] Conditions captured: <none>
[09:29:47.888] Early signaling: FALSE
[09:29:47.888] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.888] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.901] Chunk #1 of 2 ... DONE
[09:29:47.901] Chunk #2 of 2 ...
[09:29:47.901]  - Finding globals in 'X' for chunk #2 ...
[09:29:47.901] getGlobalsAndPackages() ...
[09:29:47.902] Searching for globals...
[09:29:47.902] 
[09:29:47.902] Searching for globals ... DONE
[09:29:47.903] - globals: [0] <none>
[09:29:47.903] getGlobalsAndPackages() ... DONE
[09:29:47.903]    + additional globals found: [n=0] 
[09:29:47.903]    + additional namespaces needed: [n=0] 
[09:29:47.903]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:47.903]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.904]  - seeds: <none>
[09:29:47.904]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.904] getGlobalsAndPackages() ...
[09:29:47.904] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.904] Resolving globals: FALSE
[09:29:47.904] Tweak future expression to call with '...' arguments ...
[09:29:47.905] {
[09:29:47.905]     do.call(function(...) {
[09:29:47.905]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.905]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.905]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.905]             on.exit(options(oopts), add = TRUE)
[09:29:47.905]         }
[09:29:47.905]         {
[09:29:47.905]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.905]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.905]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.905]             })
[09:29:47.905]         }
[09:29:47.905]     }, args = future.call.arguments)
[09:29:47.905] }
[09:29:47.905] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.906] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.906] - packages: [1] ‘future.apply’
[09:29:47.906] getGlobalsAndPackages() ... DONE
[09:29:47.907] run() for ‘Future’ ...
[09:29:47.907] - state: ‘created’
[09:29:47.907] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:47.911] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.911] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:47.912]   - Field: ‘label’
[09:29:47.912]   - Field: ‘local’
[09:29:47.912]   - Field: ‘owner’
[09:29:47.912]   - Field: ‘envir’
[09:29:47.912]   - Field: ‘workers’
[09:29:47.912]   - Field: ‘packages’
[09:29:47.913]   - Field: ‘gc’
[09:29:47.913]   - Field: ‘job’
[09:29:47.913]   - Field: ‘conditions’
[09:29:47.913]   - Field: ‘expr’
[09:29:47.913]   - Field: ‘uuid’
[09:29:47.913]   - Field: ‘seed’
[09:29:47.913]   - Field: ‘version’
[09:29:47.913]   - Field: ‘result’
[09:29:47.913]   - Field: ‘asynchronous’
[09:29:47.914]   - Field: ‘calls’
[09:29:47.914]   - Field: ‘globals’
[09:29:47.914]   - Field: ‘stdout’
[09:29:47.914]   - Field: ‘earlySignal’
[09:29:47.914]   - Field: ‘lazy’
[09:29:47.914]   - Field: ‘state’
[09:29:47.914] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:47.914] - Launch lazy future ...
[09:29:47.915] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:47.915] Packages needed by future strategies (n = 0): <none>
[09:29:47.916] {
[09:29:47.916]     {
[09:29:47.916]         {
[09:29:47.916]             ...future.startTime <- base::Sys.time()
[09:29:47.916]             {
[09:29:47.916]                 {
[09:29:47.916]                   {
[09:29:47.916]                     {
[09:29:47.916]                       {
[09:29:47.916]                         base::local({
[09:29:47.916]                           has_future <- base::requireNamespace("future", 
[09:29:47.916]                             quietly = TRUE)
[09:29:47.916]                           if (has_future) {
[09:29:47.916]                             ns <- base::getNamespace("future")
[09:29:47.916]                             version <- ns[[".package"]][["version"]]
[09:29:47.916]                             if (is.null(version)) 
[09:29:47.916]                               version <- utils::packageVersion("future")
[09:29:47.916]                           }
[09:29:47.916]                           else {
[09:29:47.916]                             version <- NULL
[09:29:47.916]                           }
[09:29:47.916]                           if (!has_future || version < "1.8.0") {
[09:29:47.916]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:47.916]                               "", base::R.version$version.string), 
[09:29:47.916]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:47.916]                                 base::R.version$platform, 8 * 
[09:29:47.916]                                   base::.Machine$sizeof.pointer), 
[09:29:47.916]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:47.916]                                 "release", "version")], collapse = " "), 
[09:29:47.916]                               hostname = base::Sys.info()[["nodename"]])
[09:29:47.916]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:47.916]                               info)
[09:29:47.916]                             info <- base::paste(info, collapse = "; ")
[09:29:47.916]                             if (!has_future) {
[09:29:47.916]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:47.916]                                 info)
[09:29:47.916]                             }
[09:29:47.916]                             else {
[09:29:47.916]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:47.916]                                 info, version)
[09:29:47.916]                             }
[09:29:47.916]                             base::stop(msg)
[09:29:47.916]                           }
[09:29:47.916]                         })
[09:29:47.916]                       }
[09:29:47.916]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:47.916]                       base::options(mc.cores = 1L)
[09:29:47.916]                     }
[09:29:47.916]                     base::local({
[09:29:47.916]                       for (pkg in "future.apply") {
[09:29:47.916]                         base::loadNamespace(pkg)
[09:29:47.916]                         base::library(pkg, character.only = TRUE)
[09:29:47.916]                       }
[09:29:47.916]                     })
[09:29:47.916]                   }
[09:29:47.916]                   ...future.strategy.old <- future::plan("list")
[09:29:47.916]                   options(future.plan = NULL)
[09:29:47.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:47.916]                 }
[09:29:47.916]                 ...future.workdir <- getwd()
[09:29:47.916]             }
[09:29:47.916]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:47.916]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:47.916]         }
[09:29:47.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:47.916]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:47.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:47.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:47.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:47.916]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:47.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:47.916]             base::names(...future.oldOptions))
[09:29:47.916]     }
[09:29:47.916]     if (FALSE) {
[09:29:47.916]     }
[09:29:47.916]     else {
[09:29:47.916]         if (TRUE) {
[09:29:47.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:47.916]                 open = "w")
[09:29:47.916]         }
[09:29:47.916]         else {
[09:29:47.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:47.916]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:47.916]         }
[09:29:47.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:47.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:47.916]             base::sink(type = "output", split = FALSE)
[09:29:47.916]             base::close(...future.stdout)
[09:29:47.916]         }, add = TRUE)
[09:29:47.916]     }
[09:29:47.916]     ...future.frame <- base::sys.nframe()
[09:29:47.916]     ...future.conditions <- base::list()
[09:29:47.916]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:47.916]     if (FALSE) {
[09:29:47.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:47.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:47.916]     }
[09:29:47.916]     ...future.result <- base::tryCatch({
[09:29:47.916]         base::withCallingHandlers({
[09:29:47.916]             ...future.value <- base::withVisible(base::local({
[09:29:47.916]                 withCallingHandlers({
[09:29:47.916]                   {
[09:29:47.916]                     do.call(function(...) {
[09:29:47.916]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.916]                       if (!identical(...future.globals.maxSize.org, 
[09:29:47.916]                         ...future.globals.maxSize)) {
[09:29:47.916]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.916]                         on.exit(options(oopts), add = TRUE)
[09:29:47.916]                       }
[09:29:47.916]                       {
[09:29:47.916]                         lapply(seq_along(...future.elements_ii), 
[09:29:47.916]                           FUN = function(jj) {
[09:29:47.916]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.916]                             ...future.FUN(...future.X_jj, ...)
[09:29:47.916]                           })
[09:29:47.916]                       }
[09:29:47.916]                     }, args = future.call.arguments)
[09:29:47.916]                   }
[09:29:47.916]                 }, immediateCondition = function(cond) {
[09:29:47.916]                   save_rds <- function (object, pathname, ...) 
[09:29:47.916]                   {
[09:29:47.916]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:47.916]                     if (file_test("-f", pathname_tmp)) {
[09:29:47.916]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.916]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:47.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.916]                         fi_tmp[["mtime"]])
[09:29:47.916]                     }
[09:29:47.916]                     tryCatch({
[09:29:47.916]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:47.916]                     }, error = function(ex) {
[09:29:47.916]                       msg <- conditionMessage(ex)
[09:29:47.916]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.916]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:47.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.916]                         fi_tmp[["mtime"]], msg)
[09:29:47.916]                       ex$message <- msg
[09:29:47.916]                       stop(ex)
[09:29:47.916]                     })
[09:29:47.916]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:47.916]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:47.916]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:47.916]                       fi_tmp <- file.info(pathname_tmp)
[09:29:47.916]                       fi <- file.info(pathname)
[09:29:47.916]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:47.916]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:47.916]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:47.916]                         fi[["size"]], fi[["mtime"]])
[09:29:47.916]                       stop(msg)
[09:29:47.916]                     }
[09:29:47.916]                     invisible(pathname)
[09:29:47.916]                   }
[09:29:47.916]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:47.916]                     rootPath = tempdir()) 
[09:29:47.916]                   {
[09:29:47.916]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:47.916]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:47.916]                       tmpdir = path, fileext = ".rds")
[09:29:47.916]                     save_rds(obj, file)
[09:29:47.916]                   }
[09:29:47.916]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:47.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.916]                   {
[09:29:47.916]                     inherits <- base::inherits
[09:29:47.916]                     invokeRestart <- base::invokeRestart
[09:29:47.916]                     is.null <- base::is.null
[09:29:47.916]                     muffled <- FALSE
[09:29:47.916]                     if (inherits(cond, "message")) {
[09:29:47.916]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:47.916]                       if (muffled) 
[09:29:47.916]                         invokeRestart("muffleMessage")
[09:29:47.916]                     }
[09:29:47.916]                     else if (inherits(cond, "warning")) {
[09:29:47.916]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:47.916]                       if (muffled) 
[09:29:47.916]                         invokeRestart("muffleWarning")
[09:29:47.916]                     }
[09:29:47.916]                     else if (inherits(cond, "condition")) {
[09:29:47.916]                       if (!is.null(pattern)) {
[09:29:47.916]                         computeRestarts <- base::computeRestarts
[09:29:47.916]                         grepl <- base::grepl
[09:29:47.916]                         restarts <- computeRestarts(cond)
[09:29:47.916]                         for (restart in restarts) {
[09:29:47.916]                           name <- restart$name
[09:29:47.916]                           if (is.null(name)) 
[09:29:47.916]                             next
[09:29:47.916]                           if (!grepl(pattern, name)) 
[09:29:47.916]                             next
[09:29:47.916]                           invokeRestart(restart)
[09:29:47.916]                           muffled <- TRUE
[09:29:47.916]                           break
[09:29:47.916]                         }
[09:29:47.916]                       }
[09:29:47.916]                     }
[09:29:47.916]                     invisible(muffled)
[09:29:47.916]                   }
[09:29:47.916]                   muffleCondition(cond)
[09:29:47.916]                 })
[09:29:47.916]             }))
[09:29:47.916]             future::FutureResult(value = ...future.value$value, 
[09:29:47.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.916]                   ...future.rng), globalenv = if (FALSE) 
[09:29:47.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:47.916]                     ...future.globalenv.names))
[09:29:47.916]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:47.916]         }, condition = base::local({
[09:29:47.916]             c <- base::c
[09:29:47.916]             inherits <- base::inherits
[09:29:47.916]             invokeRestart <- base::invokeRestart
[09:29:47.916]             length <- base::length
[09:29:47.916]             list <- base::list
[09:29:47.916]             seq.int <- base::seq.int
[09:29:47.916]             signalCondition <- base::signalCondition
[09:29:47.916]             sys.calls <- base::sys.calls
[09:29:47.916]             `[[` <- base::`[[`
[09:29:47.916]             `+` <- base::`+`
[09:29:47.916]             `<<-` <- base::`<<-`
[09:29:47.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:47.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:47.916]                   3L)]
[09:29:47.916]             }
[09:29:47.916]             function(cond) {
[09:29:47.916]                 is_error <- inherits(cond, "error")
[09:29:47.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:47.916]                   NULL)
[09:29:47.916]                 if (is_error) {
[09:29:47.916]                   sessionInformation <- function() {
[09:29:47.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:47.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:47.916]                       search = base::search(), system = base::Sys.info())
[09:29:47.916]                   }
[09:29:47.916]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:47.916]                     cond$call), session = sessionInformation(), 
[09:29:47.916]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:47.916]                   signalCondition(cond)
[09:29:47.916]                 }
[09:29:47.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:47.916]                 "immediateCondition"))) {
[09:29:47.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:47.916]                   ...future.conditions[[length(...future.conditions) + 
[09:29:47.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:47.916]                   if (TRUE && !signal) {
[09:29:47.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.916]                     {
[09:29:47.916]                       inherits <- base::inherits
[09:29:47.916]                       invokeRestart <- base::invokeRestart
[09:29:47.916]                       is.null <- base::is.null
[09:29:47.916]                       muffled <- FALSE
[09:29:47.916]                       if (inherits(cond, "message")) {
[09:29:47.916]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.916]                         if (muffled) 
[09:29:47.916]                           invokeRestart("muffleMessage")
[09:29:47.916]                       }
[09:29:47.916]                       else if (inherits(cond, "warning")) {
[09:29:47.916]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.916]                         if (muffled) 
[09:29:47.916]                           invokeRestart("muffleWarning")
[09:29:47.916]                       }
[09:29:47.916]                       else if (inherits(cond, "condition")) {
[09:29:47.916]                         if (!is.null(pattern)) {
[09:29:47.916]                           computeRestarts <- base::computeRestarts
[09:29:47.916]                           grepl <- base::grepl
[09:29:47.916]                           restarts <- computeRestarts(cond)
[09:29:47.916]                           for (restart in restarts) {
[09:29:47.916]                             name <- restart$name
[09:29:47.916]                             if (is.null(name)) 
[09:29:47.916]                               next
[09:29:47.916]                             if (!grepl(pattern, name)) 
[09:29:47.916]                               next
[09:29:47.916]                             invokeRestart(restart)
[09:29:47.916]                             muffled <- TRUE
[09:29:47.916]                             break
[09:29:47.916]                           }
[09:29:47.916]                         }
[09:29:47.916]                       }
[09:29:47.916]                       invisible(muffled)
[09:29:47.916]                     }
[09:29:47.916]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.916]                   }
[09:29:47.916]                 }
[09:29:47.916]                 else {
[09:29:47.916]                   if (TRUE) {
[09:29:47.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:47.916]                     {
[09:29:47.916]                       inherits <- base::inherits
[09:29:47.916]                       invokeRestart <- base::invokeRestart
[09:29:47.916]                       is.null <- base::is.null
[09:29:47.916]                       muffled <- FALSE
[09:29:47.916]                       if (inherits(cond, "message")) {
[09:29:47.916]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:47.916]                         if (muffled) 
[09:29:47.916]                           invokeRestart("muffleMessage")
[09:29:47.916]                       }
[09:29:47.916]                       else if (inherits(cond, "warning")) {
[09:29:47.916]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:47.916]                         if (muffled) 
[09:29:47.916]                           invokeRestart("muffleWarning")
[09:29:47.916]                       }
[09:29:47.916]                       else if (inherits(cond, "condition")) {
[09:29:47.916]                         if (!is.null(pattern)) {
[09:29:47.916]                           computeRestarts <- base::computeRestarts
[09:29:47.916]                           grepl <- base::grepl
[09:29:47.916]                           restarts <- computeRestarts(cond)
[09:29:47.916]                           for (restart in restarts) {
[09:29:47.916]                             name <- restart$name
[09:29:47.916]                             if (is.null(name)) 
[09:29:47.916]                               next
[09:29:47.916]                             if (!grepl(pattern, name)) 
[09:29:47.916]                               next
[09:29:47.916]                             invokeRestart(restart)
[09:29:47.916]                             muffled <- TRUE
[09:29:47.916]                             break
[09:29:47.916]                           }
[09:29:47.916]                         }
[09:29:47.916]                       }
[09:29:47.916]                       invisible(muffled)
[09:29:47.916]                     }
[09:29:47.916]                     muffleCondition(cond, pattern = "^muffle")
[09:29:47.916]                   }
[09:29:47.916]                 }
[09:29:47.916]             }
[09:29:47.916]         }))
[09:29:47.916]     }, error = function(ex) {
[09:29:47.916]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:47.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:47.916]                 ...future.rng), started = ...future.startTime, 
[09:29:47.916]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:47.916]             version = "1.8"), class = "FutureResult")
[09:29:47.916]     }, finally = {
[09:29:47.916]         if (!identical(...future.workdir, getwd())) 
[09:29:47.916]             setwd(...future.workdir)
[09:29:47.916]         {
[09:29:47.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:47.916]                 ...future.oldOptions$nwarnings <- NULL
[09:29:47.916]             }
[09:29:47.916]             base::options(...future.oldOptions)
[09:29:47.916]             if (.Platform$OS.type == "windows") {
[09:29:47.916]                 old_names <- names(...future.oldEnvVars)
[09:29:47.916]                 envs <- base::Sys.getenv()
[09:29:47.916]                 names <- names(envs)
[09:29:47.916]                 common <- intersect(names, old_names)
[09:29:47.916]                 added <- setdiff(names, old_names)
[09:29:47.916]                 removed <- setdiff(old_names, names)
[09:29:47.916]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:47.916]                   envs[common]]
[09:29:47.916]                 NAMES <- toupper(changed)
[09:29:47.916]                 args <- list()
[09:29:47.916]                 for (kk in seq_along(NAMES)) {
[09:29:47.916]                   name <- changed[[kk]]
[09:29:47.916]                   NAME <- NAMES[[kk]]
[09:29:47.916]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.916]                     next
[09:29:47.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.916]                 }
[09:29:47.916]                 NAMES <- toupper(added)
[09:29:47.916]                 for (kk in seq_along(NAMES)) {
[09:29:47.916]                   name <- added[[kk]]
[09:29:47.916]                   NAME <- NAMES[[kk]]
[09:29:47.916]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.916]                     next
[09:29:47.916]                   args[[name]] <- ""
[09:29:47.916]                 }
[09:29:47.916]                 NAMES <- toupper(removed)
[09:29:47.916]                 for (kk in seq_along(NAMES)) {
[09:29:47.916]                   name <- removed[[kk]]
[09:29:47.916]                   NAME <- NAMES[[kk]]
[09:29:47.916]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:47.916]                     next
[09:29:47.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:47.916]                 }
[09:29:47.916]                 if (length(args) > 0) 
[09:29:47.916]                   base::do.call(base::Sys.setenv, args = args)
[09:29:47.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:47.916]             }
[09:29:47.916]             else {
[09:29:47.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:47.916]             }
[09:29:47.916]             {
[09:29:47.916]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:47.916]                   0L) {
[09:29:47.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:47.916]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:47.916]                   base::options(opts)
[09:29:47.916]                 }
[09:29:47.916]                 {
[09:29:47.916]                   {
[09:29:47.916]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:47.916]                     NULL
[09:29:47.916]                   }
[09:29:47.916]                   options(future.plan = NULL)
[09:29:47.916]                   if (is.na(NA_character_)) 
[09:29:47.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:47.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:47.916]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:47.916]                     .init = FALSE)
[09:29:47.916]                 }
[09:29:47.916]             }
[09:29:47.916]         }
[09:29:47.916]     })
[09:29:47.916]     if (TRUE) {
[09:29:47.916]         base::sink(type = "output", split = FALSE)
[09:29:47.916]         if (TRUE) {
[09:29:47.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:47.916]         }
[09:29:47.916]         else {
[09:29:47.916]             ...future.result["stdout"] <- base::list(NULL)
[09:29:47.916]         }
[09:29:47.916]         base::close(...future.stdout)
[09:29:47.916]         ...future.stdout <- NULL
[09:29:47.916]     }
[09:29:47.916]     ...future.result$conditions <- ...future.conditions
[09:29:47.916]     ...future.result$finished <- base::Sys.time()
[09:29:47.916]     ...future.result
[09:29:47.916] }
[09:29:47.919] assign_globals() ...
[09:29:47.919] List of 11
[09:29:47.919]  $ ...future.FUN            :function (x, ...)  
[09:29:47.919]  $ x_FUN                    :function (x, y)  
[09:29:47.919]  $ times                    : int 15
[09:29:47.919]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.919]  $ stop_if_not              :function (...)  
[09:29:47.919]  $ dim                      : int [1:2] 3 5
[09:29:47.919]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:47.919]  $ future.call.arguments    :List of 1
[09:29:47.919]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:47.919]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.919]  $ ...future.elements_ii    :List of 2
[09:29:47.919]   ..$ C: num 70
[09:29:47.919]   ..$ D: num 80
[09:29:47.919]  $ ...future.seeds_ii       : NULL
[09:29:47.919]  $ ...future.globals.maxSize: NULL
[09:29:47.919]  - attr(*, "where")=List of 11
[09:29:47.919]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:47.919]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:47.919]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:47.919]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:47.919]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:47.919]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:47.919]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:47.919]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:47.919]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:47.919]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:47.919]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:47.919]  - attr(*, "resolved")= logi FALSE
[09:29:47.919]  - attr(*, "total_size")= num 98600
[09:29:47.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.919]  - attr(*, "already-done")= logi TRUE
[09:29:47.933] - copied ‘...future.FUN’ to environment
[09:29:47.933] - reassign environment for ‘x_FUN’
[09:29:47.933] - copied ‘x_FUN’ to environment
[09:29:47.934] - copied ‘times’ to environment
[09:29:47.934] - copied ‘stopf’ to environment
[09:29:47.934] - copied ‘stop_if_not’ to environment
[09:29:47.934] - copied ‘dim’ to environment
[09:29:47.934] - copied ‘valid_types’ to environment
[09:29:47.934] - copied ‘future.call.arguments’ to environment
[09:29:47.934] - copied ‘...future.elements_ii’ to environment
[09:29:47.934] - copied ‘...future.seeds_ii’ to environment
[09:29:47.935] - copied ‘...future.globals.maxSize’ to environment
[09:29:47.935] assign_globals() ... done
[09:29:47.935] requestCore(): workers = 2
[09:29:47.937] MulticoreFuture started
[09:29:47.938] - Launch lazy future ... done
[09:29:47.938] run() for ‘MulticoreFuture’ ... done
[09:29:47.939] Created future:
[09:29:47.939] plan(): Setting new future strategy stack:
[09:29:47.939] List of future strategies:
[09:29:47.939] 1. sequential:
[09:29:47.939]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:47.939]    - tweaked: FALSE
[09:29:47.939]    - call: NULL
[09:29:47.941] plan(): nbrOfWorkers() = 1
[09:29:47.944] plan(): Setting new future strategy stack:
[09:29:47.944] List of future strategies:
[09:29:47.944] 1. multicore:
[09:29:47.944]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:47.944]    - tweaked: FALSE
[09:29:47.944]    - call: plan(strategy)
[09:29:47.950] plan(): nbrOfWorkers() = 2
[09:29:47.939] MulticoreFuture:
[09:29:47.939] Label: ‘future_vapply-2’
[09:29:47.939] Expression:
[09:29:47.939] {
[09:29:47.939]     do.call(function(...) {
[09:29:47.939]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.939]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.939]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.939]             on.exit(options(oopts), add = TRUE)
[09:29:47.939]         }
[09:29:47.939]         {
[09:29:47.939]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.939]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.939]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.939]             })
[09:29:47.939]         }
[09:29:47.939]     }, args = future.call.arguments)
[09:29:47.939] }
[09:29:47.939] Lazy evaluation: FALSE
[09:29:47.939] Asynchronous evaluation: TRUE
[09:29:47.939] Local evaluation: TRUE
[09:29:47.939] Environment: R_GlobalEnv
[09:29:47.939] Capture standard output: TRUE
[09:29:47.939] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:47.939] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:47.939] Packages: 1 packages (‘future.apply’)
[09:29:47.939] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:47.939] Resolved: TRUE
[09:29:47.939] Value: <not collected>
[09:29:47.939] Conditions captured: <none>
[09:29:47.939] Early signaling: FALSE
[09:29:47.939] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:47.939] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:47.951] Chunk #2 of 2 ... DONE
[09:29:47.952] Launching 2 futures (chunks) ... DONE
[09:29:47.952] Resolving 2 futures (chunks) ...
[09:29:47.952] resolve() on list ...
[09:29:47.952]  recursive: 0
[09:29:47.952]  length: 2
[09:29:47.953] 
[09:29:47.953] Future #1
[09:29:47.953] result() for MulticoreFuture ...
[09:29:47.954] result() for MulticoreFuture ...
[09:29:47.954] result() for MulticoreFuture ... done
[09:29:47.954] result() for MulticoreFuture ... done
[09:29:47.955] result() for MulticoreFuture ...
[09:29:47.955] result() for MulticoreFuture ... done
[09:29:47.955] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:47.955] - nx: 2
[09:29:47.956] - relay: TRUE
[09:29:47.956] - stdout: TRUE
[09:29:47.956] - signal: TRUE
[09:29:47.956] - resignal: FALSE
[09:29:47.956] - force: TRUE
[09:29:47.957] - relayed: [n=2] FALSE, FALSE
[09:29:47.957] - queued futures: [n=2] FALSE, FALSE
[09:29:47.957]  - until=1
[09:29:47.957]  - relaying element #1
[09:29:47.957] result() for MulticoreFuture ...
[09:29:47.958] result() for MulticoreFuture ... done
[09:29:47.958] result() for MulticoreFuture ...
[09:29:47.958] result() for MulticoreFuture ... done
[09:29:47.958] result() for MulticoreFuture ...
[09:29:47.958] result() for MulticoreFuture ... done
[09:29:47.959] result() for MulticoreFuture ...
[09:29:47.959] result() for MulticoreFuture ... done
[09:29:47.959] - relayed: [n=2] TRUE, FALSE
[09:29:47.959] - queued futures: [n=2] TRUE, FALSE
[09:29:47.959] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:47.959]  length: 1 (resolved future 1)
[09:29:47.960] Future #2
[09:29:47.960] result() for MulticoreFuture ...
[09:29:47.960] result() for MulticoreFuture ...
[09:29:47.961] result() for MulticoreFuture ... done
[09:29:47.961] result() for MulticoreFuture ... done
[09:29:47.961] result() for MulticoreFuture ...
[09:29:47.961] result() for MulticoreFuture ... done
[09:29:47.961] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:47.962] - nx: 2
[09:29:47.962] - relay: TRUE
[09:29:47.962] - stdout: TRUE
[09:29:47.962] - signal: TRUE
[09:29:47.962] - resignal: FALSE
[09:29:47.962] - force: TRUE
[09:29:47.962] - relayed: [n=2] TRUE, FALSE
[09:29:47.963] - queued futures: [n=2] TRUE, FALSE
[09:29:47.963]  - until=2
[09:29:47.963]  - relaying element #2
[09:29:47.963] result() for MulticoreFuture ...
[09:29:47.963] result() for MulticoreFuture ... done
[09:29:47.963] result() for MulticoreFuture ...
[09:29:47.963] result() for MulticoreFuture ... done
[09:29:47.964] result() for MulticoreFuture ...
[09:29:47.964] result() for MulticoreFuture ... done
[09:29:47.964] result() for MulticoreFuture ...
[09:29:47.964] result() for MulticoreFuture ... done
[09:29:47.964] - relayed: [n=2] TRUE, TRUE
[09:29:47.964] - queued futures: [n=2] TRUE, TRUE
[09:29:47.964] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:47.965]  length: 0 (resolved future 2)
[09:29:47.965] Relaying remaining futures
[09:29:47.965] signalConditionsASAP(NULL, pos=0) ...
[09:29:47.965] - nx: 2
[09:29:47.965] - relay: TRUE
[09:29:47.965] - stdout: TRUE
[09:29:47.965] - signal: TRUE
[09:29:47.965] - resignal: FALSE
[09:29:47.965] - force: TRUE
[09:29:47.965] - relayed: [n=2] TRUE, TRUE
[09:29:47.965] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:47.966] - relayed: [n=2] TRUE, TRUE
[09:29:47.966] - queued futures: [n=2] TRUE, TRUE
[09:29:47.966] signalConditionsASAP(NULL, pos=0) ... done
[09:29:47.966] resolve() on list ... DONE
[09:29:47.966] result() for MulticoreFuture ...
[09:29:47.966] result() for MulticoreFuture ... done
[09:29:47.966] result() for MulticoreFuture ...
[09:29:47.966] result() for MulticoreFuture ... done
[09:29:47.966] result() for MulticoreFuture ...
[09:29:47.967] result() for MulticoreFuture ... done
[09:29:47.967] result() for MulticoreFuture ...
[09:29:47.967] result() for MulticoreFuture ... done
[09:29:47.967]  - Number of value chunks collected: 2
[09:29:47.967] Resolving 2 futures (chunks) ... DONE
[09:29:47.967] Reducing values from 2 chunks ...
[09:29:47.967]  - Number of values collected after concatenation: 4
[09:29:47.967]  - Number of values expected: 4
[09:29:47.967] Reducing values from 2 chunks ... DONE
[09:29:47.967] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[09:29:47.969] future_lapply() ...
[09:29:47.977] Number of chunks: 2
[09:29:47.977] getGlobalsAndPackagesXApply() ...
[09:29:47.978]  - future.globals: TRUE
[09:29:47.978] getGlobalsAndPackages() ...
[09:29:47.978] Searching for globals...
[09:29:47.982] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:47.982] Searching for globals ... DONE
[09:29:47.982] Resolving globals: FALSE
[09:29:47.983] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[09:29:47.983] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:47.983] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.984] - packages: [1] ‘future.apply’
[09:29:47.984] getGlobalsAndPackages() ... DONE
[09:29:47.984]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:47.984]  - needed namespaces: [n=1] ‘future.apply’
[09:29:47.984] Finding globals ... DONE
[09:29:47.984]  - use_args: TRUE
[09:29:47.984]  - Getting '...' globals ...
[09:29:47.985] resolve() on list ...
[09:29:47.985]  recursive: 0
[09:29:47.985]  length: 1
[09:29:47.985]  elements: ‘...’
[09:29:47.985]  length: 0 (resolved future 1)
[09:29:47.985] resolve() on list ... DONE
[09:29:47.985]    - '...' content: [n=0] 
[09:29:47.985] List of 1
[09:29:47.985]  $ ...: list()
[09:29:47.985]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.985]  - attr(*, "where")=List of 1
[09:29:47.985]   ..$ ...:<environment: 0x561d364febe0> 
[09:29:47.985]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.985]  - attr(*, "resolved")= logi TRUE
[09:29:47.985]  - attr(*, "total_size")= num NA
[09:29:47.988]  - Getting '...' globals ... DONE
[09:29:47.988] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:47.988] List of 8
[09:29:47.988]  $ ...future.FUN:function (x, ...)  
[09:29:47.988]  $ x_FUN        :function (x)  
[09:29:47.988]  $ times        : int 1
[09:29:47.988]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:47.988]  $ stop_if_not  :function (...)  
[09:29:47.988]  $ dim          : NULL
[09:29:47.988]  $ valid_types  : chr "logical"
[09:29:47.988]  $ ...          : list()
[09:29:47.988]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:47.988]  - attr(*, "where")=List of 8
[09:29:47.988]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:47.988]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:47.988]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:47.988]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:47.988]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:47.988]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:47.988]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:47.988]   ..$ ...          :<environment: 0x561d364febe0> 
[09:29:47.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:47.988]  - attr(*, "resolved")= logi FALSE
[09:29:47.988]  - attr(*, "total_size")= num 94200
[09:29:47.993] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:47.993] getGlobalsAndPackagesXApply() ... DONE
[09:29:47.993] Number of futures (= number of chunks): 2
[09:29:47.994] Launching 2 futures (chunks) ...
[09:29:47.994] Chunk #1 of 2 ...
[09:29:47.994]  - Finding globals in 'X' for chunk #1 ...
[09:29:47.994] getGlobalsAndPackages() ...
[09:29:47.994] Searching for globals...
[09:29:47.994] 
[09:29:47.994] Searching for globals ... DONE
[09:29:47.994] - globals: [0] <none>
[09:29:47.994] getGlobalsAndPackages() ... DONE
[09:29:47.994]    + additional globals found: [n=0] 
[09:29:47.995]    + additional namespaces needed: [n=0] 
[09:29:47.995]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:47.995]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:47.995]  - seeds: <none>
[09:29:47.995]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.995] getGlobalsAndPackages() ...
[09:29:47.995] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.995] Resolving globals: FALSE
[09:29:47.995] Tweak future expression to call with '...' arguments ...
[09:29:47.995] {
[09:29:47.995]     do.call(function(...) {
[09:29:47.995]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:47.995]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:47.995]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:47.995]             on.exit(options(oopts), add = TRUE)
[09:29:47.995]         }
[09:29:47.995]         {
[09:29:47.995]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:47.995]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:47.995]                 ...future.FUN(...future.X_jj, ...)
[09:29:47.995]             })
[09:29:47.995]         }
[09:29:47.995]     }, args = future.call.arguments)
[09:29:47.995] }
[09:29:47.996] Tweak future expression to call with '...' arguments ... DONE
[09:29:47.998] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:47.998] - packages: [1] ‘future.apply’
[09:29:47.998] getGlobalsAndPackages() ... DONE
[09:29:47.998] run() for ‘Future’ ...
[09:29:47.998] - state: ‘created’
[09:29:47.999] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:48.002] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:48.002]   - Field: ‘label’
[09:29:48.003]   - Field: ‘local’
[09:29:48.003]   - Field: ‘owner’
[09:29:48.003]   - Field: ‘envir’
[09:29:48.003]   - Field: ‘workers’
[09:29:48.003]   - Field: ‘packages’
[09:29:48.003]   - Field: ‘gc’
[09:29:48.003]   - Field: ‘job’
[09:29:48.003]   - Field: ‘conditions’
[09:29:48.003]   - Field: ‘expr’
[09:29:48.003]   - Field: ‘uuid’
[09:29:48.004]   - Field: ‘seed’
[09:29:48.004]   - Field: ‘version’
[09:29:48.004]   - Field: ‘result’
[09:29:48.004]   - Field: ‘asynchronous’
[09:29:48.004]   - Field: ‘calls’
[09:29:48.004]   - Field: ‘globals’
[09:29:48.004]   - Field: ‘stdout’
[09:29:48.004]   - Field: ‘earlySignal’
[09:29:48.004]   - Field: ‘lazy’
[09:29:48.004]   - Field: ‘state’
[09:29:48.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:48.005] - Launch lazy future ...
[09:29:48.005] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:48.005] Packages needed by future strategies (n = 0): <none>
[09:29:48.006] {
[09:29:48.006]     {
[09:29:48.006]         {
[09:29:48.006]             ...future.startTime <- base::Sys.time()
[09:29:48.006]             {
[09:29:48.006]                 {
[09:29:48.006]                   {
[09:29:48.006]                     {
[09:29:48.006]                       {
[09:29:48.006]                         base::local({
[09:29:48.006]                           has_future <- base::requireNamespace("future", 
[09:29:48.006]                             quietly = TRUE)
[09:29:48.006]                           if (has_future) {
[09:29:48.006]                             ns <- base::getNamespace("future")
[09:29:48.006]                             version <- ns[[".package"]][["version"]]
[09:29:48.006]                             if (is.null(version)) 
[09:29:48.006]                               version <- utils::packageVersion("future")
[09:29:48.006]                           }
[09:29:48.006]                           else {
[09:29:48.006]                             version <- NULL
[09:29:48.006]                           }
[09:29:48.006]                           if (!has_future || version < "1.8.0") {
[09:29:48.006]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:48.006]                               "", base::R.version$version.string), 
[09:29:48.006]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:48.006]                                 base::R.version$platform, 8 * 
[09:29:48.006]                                   base::.Machine$sizeof.pointer), 
[09:29:48.006]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:48.006]                                 "release", "version")], collapse = " "), 
[09:29:48.006]                               hostname = base::Sys.info()[["nodename"]])
[09:29:48.006]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:48.006]                               info)
[09:29:48.006]                             info <- base::paste(info, collapse = "; ")
[09:29:48.006]                             if (!has_future) {
[09:29:48.006]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:48.006]                                 info)
[09:29:48.006]                             }
[09:29:48.006]                             else {
[09:29:48.006]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:48.006]                                 info, version)
[09:29:48.006]                             }
[09:29:48.006]                             base::stop(msg)
[09:29:48.006]                           }
[09:29:48.006]                         })
[09:29:48.006]                       }
[09:29:48.006]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:48.006]                       base::options(mc.cores = 1L)
[09:29:48.006]                     }
[09:29:48.006]                     base::local({
[09:29:48.006]                       for (pkg in "future.apply") {
[09:29:48.006]                         base::loadNamespace(pkg)
[09:29:48.006]                         base::library(pkg, character.only = TRUE)
[09:29:48.006]                       }
[09:29:48.006]                     })
[09:29:48.006]                   }
[09:29:48.006]                   ...future.strategy.old <- future::plan("list")
[09:29:48.006]                   options(future.plan = NULL)
[09:29:48.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:48.006]                 }
[09:29:48.006]                 ...future.workdir <- getwd()
[09:29:48.006]             }
[09:29:48.006]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:48.006]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:48.006]         }
[09:29:48.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:48.006]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:48.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:48.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:48.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:48.006]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:48.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:48.006]             base::names(...future.oldOptions))
[09:29:48.006]     }
[09:29:48.006]     if (FALSE) {
[09:29:48.006]     }
[09:29:48.006]     else {
[09:29:48.006]         if (TRUE) {
[09:29:48.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:48.006]                 open = "w")
[09:29:48.006]         }
[09:29:48.006]         else {
[09:29:48.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:48.006]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:48.006]         }
[09:29:48.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:48.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:48.006]             base::sink(type = "output", split = FALSE)
[09:29:48.006]             base::close(...future.stdout)
[09:29:48.006]         }, add = TRUE)
[09:29:48.006]     }
[09:29:48.006]     ...future.frame <- base::sys.nframe()
[09:29:48.006]     ...future.conditions <- base::list()
[09:29:48.006]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:48.006]     if (FALSE) {
[09:29:48.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:48.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:48.006]     }
[09:29:48.006]     ...future.result <- base::tryCatch({
[09:29:48.006]         base::withCallingHandlers({
[09:29:48.006]             ...future.value <- base::withVisible(base::local({
[09:29:48.006]                 withCallingHandlers({
[09:29:48.006]                   {
[09:29:48.006]                     do.call(function(...) {
[09:29:48.006]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.006]                       if (!identical(...future.globals.maxSize.org, 
[09:29:48.006]                         ...future.globals.maxSize)) {
[09:29:48.006]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.006]                         on.exit(options(oopts), add = TRUE)
[09:29:48.006]                       }
[09:29:48.006]                       {
[09:29:48.006]                         lapply(seq_along(...future.elements_ii), 
[09:29:48.006]                           FUN = function(jj) {
[09:29:48.006]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.006]                             ...future.FUN(...future.X_jj, ...)
[09:29:48.006]                           })
[09:29:48.006]                       }
[09:29:48.006]                     }, args = future.call.arguments)
[09:29:48.006]                   }
[09:29:48.006]                 }, immediateCondition = function(cond) {
[09:29:48.006]                   save_rds <- function (object, pathname, ...) 
[09:29:48.006]                   {
[09:29:48.006]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:48.006]                     if (file_test("-f", pathname_tmp)) {
[09:29:48.006]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.006]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:48.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.006]                         fi_tmp[["mtime"]])
[09:29:48.006]                     }
[09:29:48.006]                     tryCatch({
[09:29:48.006]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:48.006]                     }, error = function(ex) {
[09:29:48.006]                       msg <- conditionMessage(ex)
[09:29:48.006]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.006]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:48.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.006]                         fi_tmp[["mtime"]], msg)
[09:29:48.006]                       ex$message <- msg
[09:29:48.006]                       stop(ex)
[09:29:48.006]                     })
[09:29:48.006]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:48.006]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:48.006]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:48.006]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.006]                       fi <- file.info(pathname)
[09:29:48.006]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:48.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.006]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:48.006]                         fi[["size"]], fi[["mtime"]])
[09:29:48.006]                       stop(msg)
[09:29:48.006]                     }
[09:29:48.006]                     invisible(pathname)
[09:29:48.006]                   }
[09:29:48.006]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:48.006]                     rootPath = tempdir()) 
[09:29:48.006]                   {
[09:29:48.006]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:48.006]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:48.006]                       tmpdir = path, fileext = ".rds")
[09:29:48.006]                     save_rds(obj, file)
[09:29:48.006]                   }
[09:29:48.006]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:48.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.006]                   {
[09:29:48.006]                     inherits <- base::inherits
[09:29:48.006]                     invokeRestart <- base::invokeRestart
[09:29:48.006]                     is.null <- base::is.null
[09:29:48.006]                     muffled <- FALSE
[09:29:48.006]                     if (inherits(cond, "message")) {
[09:29:48.006]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:48.006]                       if (muffled) 
[09:29:48.006]                         invokeRestart("muffleMessage")
[09:29:48.006]                     }
[09:29:48.006]                     else if (inherits(cond, "warning")) {
[09:29:48.006]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:48.006]                       if (muffled) 
[09:29:48.006]                         invokeRestart("muffleWarning")
[09:29:48.006]                     }
[09:29:48.006]                     else if (inherits(cond, "condition")) {
[09:29:48.006]                       if (!is.null(pattern)) {
[09:29:48.006]                         computeRestarts <- base::computeRestarts
[09:29:48.006]                         grepl <- base::grepl
[09:29:48.006]                         restarts <- computeRestarts(cond)
[09:29:48.006]                         for (restart in restarts) {
[09:29:48.006]                           name <- restart$name
[09:29:48.006]                           if (is.null(name)) 
[09:29:48.006]                             next
[09:29:48.006]                           if (!grepl(pattern, name)) 
[09:29:48.006]                             next
[09:29:48.006]                           invokeRestart(restart)
[09:29:48.006]                           muffled <- TRUE
[09:29:48.006]                           break
[09:29:48.006]                         }
[09:29:48.006]                       }
[09:29:48.006]                     }
[09:29:48.006]                     invisible(muffled)
[09:29:48.006]                   }
[09:29:48.006]                   muffleCondition(cond)
[09:29:48.006]                 })
[09:29:48.006]             }))
[09:29:48.006]             future::FutureResult(value = ...future.value$value, 
[09:29:48.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.006]                   ...future.rng), globalenv = if (FALSE) 
[09:29:48.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:48.006]                     ...future.globalenv.names))
[09:29:48.006]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:48.006]         }, condition = base::local({
[09:29:48.006]             c <- base::c
[09:29:48.006]             inherits <- base::inherits
[09:29:48.006]             invokeRestart <- base::invokeRestart
[09:29:48.006]             length <- base::length
[09:29:48.006]             list <- base::list
[09:29:48.006]             seq.int <- base::seq.int
[09:29:48.006]             signalCondition <- base::signalCondition
[09:29:48.006]             sys.calls <- base::sys.calls
[09:29:48.006]             `[[` <- base::`[[`
[09:29:48.006]             `+` <- base::`+`
[09:29:48.006]             `<<-` <- base::`<<-`
[09:29:48.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:48.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:48.006]                   3L)]
[09:29:48.006]             }
[09:29:48.006]             function(cond) {
[09:29:48.006]                 is_error <- inherits(cond, "error")
[09:29:48.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:48.006]                   NULL)
[09:29:48.006]                 if (is_error) {
[09:29:48.006]                   sessionInformation <- function() {
[09:29:48.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:48.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:48.006]                       search = base::search(), system = base::Sys.info())
[09:29:48.006]                   }
[09:29:48.006]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:48.006]                     cond$call), session = sessionInformation(), 
[09:29:48.006]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:48.006]                   signalCondition(cond)
[09:29:48.006]                 }
[09:29:48.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:48.006]                 "immediateCondition"))) {
[09:29:48.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:48.006]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:48.006]                   if (TRUE && !signal) {
[09:29:48.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.006]                     {
[09:29:48.006]                       inherits <- base::inherits
[09:29:48.006]                       invokeRestart <- base::invokeRestart
[09:29:48.006]                       is.null <- base::is.null
[09:29:48.006]                       muffled <- FALSE
[09:29:48.006]                       if (inherits(cond, "message")) {
[09:29:48.006]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.006]                         if (muffled) 
[09:29:48.006]                           invokeRestart("muffleMessage")
[09:29:48.006]                       }
[09:29:48.006]                       else if (inherits(cond, "warning")) {
[09:29:48.006]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.006]                         if (muffled) 
[09:29:48.006]                           invokeRestart("muffleWarning")
[09:29:48.006]                       }
[09:29:48.006]                       else if (inherits(cond, "condition")) {
[09:29:48.006]                         if (!is.null(pattern)) {
[09:29:48.006]                           computeRestarts <- base::computeRestarts
[09:29:48.006]                           grepl <- base::grepl
[09:29:48.006]                           restarts <- computeRestarts(cond)
[09:29:48.006]                           for (restart in restarts) {
[09:29:48.006]                             name <- restart$name
[09:29:48.006]                             if (is.null(name)) 
[09:29:48.006]                               next
[09:29:48.006]                             if (!grepl(pattern, name)) 
[09:29:48.006]                               next
[09:29:48.006]                             invokeRestart(restart)
[09:29:48.006]                             muffled <- TRUE
[09:29:48.006]                             break
[09:29:48.006]                           }
[09:29:48.006]                         }
[09:29:48.006]                       }
[09:29:48.006]                       invisible(muffled)
[09:29:48.006]                     }
[09:29:48.006]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.006]                   }
[09:29:48.006]                 }
[09:29:48.006]                 else {
[09:29:48.006]                   if (TRUE) {
[09:29:48.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.006]                     {
[09:29:48.006]                       inherits <- base::inherits
[09:29:48.006]                       invokeRestart <- base::invokeRestart
[09:29:48.006]                       is.null <- base::is.null
[09:29:48.006]                       muffled <- FALSE
[09:29:48.006]                       if (inherits(cond, "message")) {
[09:29:48.006]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.006]                         if (muffled) 
[09:29:48.006]                           invokeRestart("muffleMessage")
[09:29:48.006]                       }
[09:29:48.006]                       else if (inherits(cond, "warning")) {
[09:29:48.006]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.006]                         if (muffled) 
[09:29:48.006]                           invokeRestart("muffleWarning")
[09:29:48.006]                       }
[09:29:48.006]                       else if (inherits(cond, "condition")) {
[09:29:48.006]                         if (!is.null(pattern)) {
[09:29:48.006]                           computeRestarts <- base::computeRestarts
[09:29:48.006]                           grepl <- base::grepl
[09:29:48.006]                           restarts <- computeRestarts(cond)
[09:29:48.006]                           for (restart in restarts) {
[09:29:48.006]                             name <- restart$name
[09:29:48.006]                             if (is.null(name)) 
[09:29:48.006]                               next
[09:29:48.006]                             if (!grepl(pattern, name)) 
[09:29:48.006]                               next
[09:29:48.006]                             invokeRestart(restart)
[09:29:48.006]                             muffled <- TRUE
[09:29:48.006]                             break
[09:29:48.006]                           }
[09:29:48.006]                         }
[09:29:48.006]                       }
[09:29:48.006]                       invisible(muffled)
[09:29:48.006]                     }
[09:29:48.006]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.006]                   }
[09:29:48.006]                 }
[09:29:48.006]             }
[09:29:48.006]         }))
[09:29:48.006]     }, error = function(ex) {
[09:29:48.006]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:48.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.006]                 ...future.rng), started = ...future.startTime, 
[09:29:48.006]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:48.006]             version = "1.8"), class = "FutureResult")
[09:29:48.006]     }, finally = {
[09:29:48.006]         if (!identical(...future.workdir, getwd())) 
[09:29:48.006]             setwd(...future.workdir)
[09:29:48.006]         {
[09:29:48.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:48.006]                 ...future.oldOptions$nwarnings <- NULL
[09:29:48.006]             }
[09:29:48.006]             base::options(...future.oldOptions)
[09:29:48.006]             if (.Platform$OS.type == "windows") {
[09:29:48.006]                 old_names <- names(...future.oldEnvVars)
[09:29:48.006]                 envs <- base::Sys.getenv()
[09:29:48.006]                 names <- names(envs)
[09:29:48.006]                 common <- intersect(names, old_names)
[09:29:48.006]                 added <- setdiff(names, old_names)
[09:29:48.006]                 removed <- setdiff(old_names, names)
[09:29:48.006]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:48.006]                   envs[common]]
[09:29:48.006]                 NAMES <- toupper(changed)
[09:29:48.006]                 args <- list()
[09:29:48.006]                 for (kk in seq_along(NAMES)) {
[09:29:48.006]                   name <- changed[[kk]]
[09:29:48.006]                   NAME <- NAMES[[kk]]
[09:29:48.006]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.006]                     next
[09:29:48.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.006]                 }
[09:29:48.006]                 NAMES <- toupper(added)
[09:29:48.006]                 for (kk in seq_along(NAMES)) {
[09:29:48.006]                   name <- added[[kk]]
[09:29:48.006]                   NAME <- NAMES[[kk]]
[09:29:48.006]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.006]                     next
[09:29:48.006]                   args[[name]] <- ""
[09:29:48.006]                 }
[09:29:48.006]                 NAMES <- toupper(removed)
[09:29:48.006]                 for (kk in seq_along(NAMES)) {
[09:29:48.006]                   name <- removed[[kk]]
[09:29:48.006]                   NAME <- NAMES[[kk]]
[09:29:48.006]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.006]                     next
[09:29:48.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.006]                 }
[09:29:48.006]                 if (length(args) > 0) 
[09:29:48.006]                   base::do.call(base::Sys.setenv, args = args)
[09:29:48.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:48.006]             }
[09:29:48.006]             else {
[09:29:48.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:48.006]             }
[09:29:48.006]             {
[09:29:48.006]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:48.006]                   0L) {
[09:29:48.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:48.006]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:48.006]                   base::options(opts)
[09:29:48.006]                 }
[09:29:48.006]                 {
[09:29:48.006]                   {
[09:29:48.006]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:48.006]                     NULL
[09:29:48.006]                   }
[09:29:48.006]                   options(future.plan = NULL)
[09:29:48.006]                   if (is.na(NA_character_)) 
[09:29:48.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:48.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:48.006]                     .init = FALSE)
[09:29:48.006]                 }
[09:29:48.006]             }
[09:29:48.006]         }
[09:29:48.006]     })
[09:29:48.006]     if (TRUE) {
[09:29:48.006]         base::sink(type = "output", split = FALSE)
[09:29:48.006]         if (TRUE) {
[09:29:48.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:48.006]         }
[09:29:48.006]         else {
[09:29:48.006]             ...future.result["stdout"] <- base::list(NULL)
[09:29:48.006]         }
[09:29:48.006]         base::close(...future.stdout)
[09:29:48.006]         ...future.stdout <- NULL
[09:29:48.006]     }
[09:29:48.006]     ...future.result$conditions <- ...future.conditions
[09:29:48.006]     ...future.result$finished <- base::Sys.time()
[09:29:48.006]     ...future.result
[09:29:48.006] }
[09:29:48.008] assign_globals() ...
[09:29:48.008] List of 11
[09:29:48.008]  $ ...future.FUN            :function (x, ...)  
[09:29:48.008]  $ x_FUN                    :function (x)  
[09:29:48.008]  $ times                    : int 1
[09:29:48.008]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:48.008]  $ stop_if_not              :function (...)  
[09:29:48.008]  $ dim                      : NULL
[09:29:48.008]  $ valid_types              : chr "logical"
[09:29:48.008]  $ future.call.arguments    : list()
[09:29:48.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:48.008]  $ ...future.elements_ii    :List of 6
[09:29:48.008]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[09:29:48.008]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[09:29:48.008]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[09:29:48.008]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[09:29:48.008]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[09:29:48.008]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[09:29:48.008]  $ ...future.seeds_ii       : NULL
[09:29:48.008]  $ ...future.globals.maxSize: NULL
[09:29:48.008]  - attr(*, "where")=List of 11
[09:29:48.008]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:48.008]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:48.008]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:48.008]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:48.008]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:48.008]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:48.008]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:48.008]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:48.008]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:48.008]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:48.008]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:48.008]  - attr(*, "resolved")= logi FALSE
[09:29:48.008]  - attr(*, "total_size")= num 94200
[09:29:48.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:48.008]  - attr(*, "already-done")= logi TRUE
[09:29:48.017] - copied ‘...future.FUN’ to environment
[09:29:48.017] - copied ‘x_FUN’ to environment
[09:29:48.017] - copied ‘times’ to environment
[09:29:48.017] - copied ‘stopf’ to environment
[09:29:48.017] - copied ‘stop_if_not’ to environment
[09:29:48.017] - copied ‘dim’ to environment
[09:29:48.017] - copied ‘valid_types’ to environment
[09:29:48.017] - copied ‘future.call.arguments’ to environment
[09:29:48.018] - copied ‘...future.elements_ii’ to environment
[09:29:48.018] - copied ‘...future.seeds_ii’ to environment
[09:29:48.018] - copied ‘...future.globals.maxSize’ to environment
[09:29:48.018] assign_globals() ... done
[09:29:48.018] requestCore(): workers = 2
[09:29:48.020] MulticoreFuture started
[09:29:48.020] - Launch lazy future ... done
[09:29:48.021] run() for ‘MulticoreFuture’ ... done
[09:29:48.021] Created future:
[09:29:48.021] plan(): Setting new future strategy stack:
[09:29:48.022] List of future strategies:
[09:29:48.022] 1. sequential:
[09:29:48.022]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:48.022]    - tweaked: FALSE
[09:29:48.022]    - call: NULL
[09:29:48.023] plan(): nbrOfWorkers() = 1
[09:29:48.025] plan(): Setting new future strategy stack:
[09:29:48.025] List of future strategies:
[09:29:48.025] 1. multicore:
[09:29:48.025]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:48.025]    - tweaked: FALSE
[09:29:48.025]    - call: plan(strategy)
[09:29:48.021] MulticoreFuture:
[09:29:48.021] Label: ‘future_vapply-1’
[09:29:48.021] Expression:
[09:29:48.021] {
[09:29:48.021]     do.call(function(...) {
[09:29:48.021]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.021]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:48.021]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.021]             on.exit(options(oopts), add = TRUE)
[09:29:48.021]         }
[09:29:48.021]         {
[09:29:48.021]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:48.021]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.021]                 ...future.FUN(...future.X_jj, ...)
[09:29:48.021]             })
[09:29:48.021]         }
[09:29:48.021]     }, args = future.call.arguments)
[09:29:48.021] }
[09:29:48.021] Lazy evaluation: FALSE
[09:29:48.021] Asynchronous evaluation: TRUE
[09:29:48.021] Local evaluation: TRUE
[09:29:48.021] Environment: R_GlobalEnv
[09:29:48.021] Capture standard output: TRUE
[09:29:48.021] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:48.021] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:48.021] Packages: 1 packages (‘future.apply’)
[09:29:48.021] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:48.021] Resolved: FALSE
[09:29:48.021] Value: <not collected>
[09:29:48.021] Conditions captured: <none>
[09:29:48.021] Early signaling: FALSE
[09:29:48.021] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:48.021] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.034] Chunk #1 of 2 ... DONE
[09:29:48.034] Chunk #2 of 2 ...
[09:29:48.035]  - Finding globals in 'X' for chunk #2 ...
[09:29:48.035] getGlobalsAndPackages() ...
[09:29:48.035] Searching for globals...
[09:29:48.035] plan(): nbrOfWorkers() = 2
[09:29:48.036] 
[09:29:48.036] Searching for globals ... DONE
[09:29:48.036] - globals: [0] <none>
[09:29:48.039] getGlobalsAndPackages() ... DONE
[09:29:48.039]    + additional globals found: [n=0] 
[09:29:48.039]    + additional namespaces needed: [n=0] 
[09:29:48.039]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:48.040]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:48.040]  - seeds: <none>
[09:29:48.040]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.040] getGlobalsAndPackages() ...
[09:29:48.041] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.041] Resolving globals: FALSE
[09:29:48.041] Tweak future expression to call with '...' arguments ...
[09:29:48.042] {
[09:29:48.042]     do.call(function(...) {
[09:29:48.042]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.042]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:48.042]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.042]             on.exit(options(oopts), add = TRUE)
[09:29:48.042]         }
[09:29:48.042]         {
[09:29:48.042]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:48.042]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.042]                 ...future.FUN(...future.X_jj, ...)
[09:29:48.042]             })
[09:29:48.042]         }
[09:29:48.042]     }, args = future.call.arguments)
[09:29:48.042] }
[09:29:48.042] Tweak future expression to call with '...' arguments ... DONE
[09:29:48.044] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.044] - packages: [1] ‘future.apply’
[09:29:48.045] getGlobalsAndPackages() ... DONE
[09:29:48.045] run() for ‘Future’ ...
[09:29:48.045] - state: ‘created’
[09:29:48.046] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:48.051] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.051] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:48.051]   - Field: ‘label’
[09:29:48.052]   - Field: ‘local’
[09:29:48.052]   - Field: ‘owner’
[09:29:48.052]   - Field: ‘envir’
[09:29:48.052]   - Field: ‘workers’
[09:29:48.052]   - Field: ‘packages’
[09:29:48.053]   - Field: ‘gc’
[09:29:48.053]   - Field: ‘job’
[09:29:48.053]   - Field: ‘conditions’
[09:29:48.053]   - Field: ‘expr’
[09:29:48.053]   - Field: ‘uuid’
[09:29:48.053]   - Field: ‘seed’
[09:29:48.054]   - Field: ‘version’
[09:29:48.054]   - Field: ‘result’
[09:29:48.054]   - Field: ‘asynchronous’
[09:29:48.054]   - Field: ‘calls’
[09:29:48.054]   - Field: ‘globals’
[09:29:48.055]   - Field: ‘stdout’
[09:29:48.055]   - Field: ‘earlySignal’
[09:29:48.055]   - Field: ‘lazy’
[09:29:48.055]   - Field: ‘state’
[09:29:48.055] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:48.055] - Launch lazy future ...
[09:29:48.056] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:48.056] Packages needed by future strategies (n = 0): <none>
[09:29:48.057] {
[09:29:48.057]     {
[09:29:48.057]         {
[09:29:48.057]             ...future.startTime <- base::Sys.time()
[09:29:48.057]             {
[09:29:48.057]                 {
[09:29:48.057]                   {
[09:29:48.057]                     {
[09:29:48.057]                       {
[09:29:48.057]                         base::local({
[09:29:48.057]                           has_future <- base::requireNamespace("future", 
[09:29:48.057]                             quietly = TRUE)
[09:29:48.057]                           if (has_future) {
[09:29:48.057]                             ns <- base::getNamespace("future")
[09:29:48.057]                             version <- ns[[".package"]][["version"]]
[09:29:48.057]                             if (is.null(version)) 
[09:29:48.057]                               version <- utils::packageVersion("future")
[09:29:48.057]                           }
[09:29:48.057]                           else {
[09:29:48.057]                             version <- NULL
[09:29:48.057]                           }
[09:29:48.057]                           if (!has_future || version < "1.8.0") {
[09:29:48.057]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:48.057]                               "", base::R.version$version.string), 
[09:29:48.057]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:48.057]                                 base::R.version$platform, 8 * 
[09:29:48.057]                                   base::.Machine$sizeof.pointer), 
[09:29:48.057]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:48.057]                                 "release", "version")], collapse = " "), 
[09:29:48.057]                               hostname = base::Sys.info()[["nodename"]])
[09:29:48.057]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:48.057]                               info)
[09:29:48.057]                             info <- base::paste(info, collapse = "; ")
[09:29:48.057]                             if (!has_future) {
[09:29:48.057]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:48.057]                                 info)
[09:29:48.057]                             }
[09:29:48.057]                             else {
[09:29:48.057]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:48.057]                                 info, version)
[09:29:48.057]                             }
[09:29:48.057]                             base::stop(msg)
[09:29:48.057]                           }
[09:29:48.057]                         })
[09:29:48.057]                       }
[09:29:48.057]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:48.057]                       base::options(mc.cores = 1L)
[09:29:48.057]                     }
[09:29:48.057]                     base::local({
[09:29:48.057]                       for (pkg in "future.apply") {
[09:29:48.057]                         base::loadNamespace(pkg)
[09:29:48.057]                         base::library(pkg, character.only = TRUE)
[09:29:48.057]                       }
[09:29:48.057]                     })
[09:29:48.057]                   }
[09:29:48.057]                   ...future.strategy.old <- future::plan("list")
[09:29:48.057]                   options(future.plan = NULL)
[09:29:48.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:48.057]                 }
[09:29:48.057]                 ...future.workdir <- getwd()
[09:29:48.057]             }
[09:29:48.057]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:48.057]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:48.057]         }
[09:29:48.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:48.057]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:48.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:48.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:48.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:48.057]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:48.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:48.057]             base::names(...future.oldOptions))
[09:29:48.057]     }
[09:29:48.057]     if (FALSE) {
[09:29:48.057]     }
[09:29:48.057]     else {
[09:29:48.057]         if (TRUE) {
[09:29:48.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:48.057]                 open = "w")
[09:29:48.057]         }
[09:29:48.057]         else {
[09:29:48.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:48.057]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:48.057]         }
[09:29:48.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:48.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:48.057]             base::sink(type = "output", split = FALSE)
[09:29:48.057]             base::close(...future.stdout)
[09:29:48.057]         }, add = TRUE)
[09:29:48.057]     }
[09:29:48.057]     ...future.frame <- base::sys.nframe()
[09:29:48.057]     ...future.conditions <- base::list()
[09:29:48.057]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:48.057]     if (FALSE) {
[09:29:48.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:48.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:48.057]     }
[09:29:48.057]     ...future.result <- base::tryCatch({
[09:29:48.057]         base::withCallingHandlers({
[09:29:48.057]             ...future.value <- base::withVisible(base::local({
[09:29:48.057]                 withCallingHandlers({
[09:29:48.057]                   {
[09:29:48.057]                     do.call(function(...) {
[09:29:48.057]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.057]                       if (!identical(...future.globals.maxSize.org, 
[09:29:48.057]                         ...future.globals.maxSize)) {
[09:29:48.057]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.057]                         on.exit(options(oopts), add = TRUE)
[09:29:48.057]                       }
[09:29:48.057]                       {
[09:29:48.057]                         lapply(seq_along(...future.elements_ii), 
[09:29:48.057]                           FUN = function(jj) {
[09:29:48.057]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.057]                             ...future.FUN(...future.X_jj, ...)
[09:29:48.057]                           })
[09:29:48.057]                       }
[09:29:48.057]                     }, args = future.call.arguments)
[09:29:48.057]                   }
[09:29:48.057]                 }, immediateCondition = function(cond) {
[09:29:48.057]                   save_rds <- function (object, pathname, ...) 
[09:29:48.057]                   {
[09:29:48.057]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:48.057]                     if (file_test("-f", pathname_tmp)) {
[09:29:48.057]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.057]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:48.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.057]                         fi_tmp[["mtime"]])
[09:29:48.057]                     }
[09:29:48.057]                     tryCatch({
[09:29:48.057]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:48.057]                     }, error = function(ex) {
[09:29:48.057]                       msg <- conditionMessage(ex)
[09:29:48.057]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.057]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:48.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.057]                         fi_tmp[["mtime"]], msg)
[09:29:48.057]                       ex$message <- msg
[09:29:48.057]                       stop(ex)
[09:29:48.057]                     })
[09:29:48.057]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:48.057]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:48.057]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:48.057]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.057]                       fi <- file.info(pathname)
[09:29:48.057]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:48.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.057]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:48.057]                         fi[["size"]], fi[["mtime"]])
[09:29:48.057]                       stop(msg)
[09:29:48.057]                     }
[09:29:48.057]                     invisible(pathname)
[09:29:48.057]                   }
[09:29:48.057]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:48.057]                     rootPath = tempdir()) 
[09:29:48.057]                   {
[09:29:48.057]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:48.057]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:48.057]                       tmpdir = path, fileext = ".rds")
[09:29:48.057]                     save_rds(obj, file)
[09:29:48.057]                   }
[09:29:48.057]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:48.057]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.057]                   {
[09:29:48.057]                     inherits <- base::inherits
[09:29:48.057]                     invokeRestart <- base::invokeRestart
[09:29:48.057]                     is.null <- base::is.null
[09:29:48.057]                     muffled <- FALSE
[09:29:48.057]                     if (inherits(cond, "message")) {
[09:29:48.057]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:48.057]                       if (muffled) 
[09:29:48.057]                         invokeRestart("muffleMessage")
[09:29:48.057]                     }
[09:29:48.057]                     else if (inherits(cond, "warning")) {
[09:29:48.057]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:48.057]                       if (muffled) 
[09:29:48.057]                         invokeRestart("muffleWarning")
[09:29:48.057]                     }
[09:29:48.057]                     else if (inherits(cond, "condition")) {
[09:29:48.057]                       if (!is.null(pattern)) {
[09:29:48.057]                         computeRestarts <- base::computeRestarts
[09:29:48.057]                         grepl <- base::grepl
[09:29:48.057]                         restarts <- computeRestarts(cond)
[09:29:48.057]                         for (restart in restarts) {
[09:29:48.057]                           name <- restart$name
[09:29:48.057]                           if (is.null(name)) 
[09:29:48.057]                             next
[09:29:48.057]                           if (!grepl(pattern, name)) 
[09:29:48.057]                             next
[09:29:48.057]                           invokeRestart(restart)
[09:29:48.057]                           muffled <- TRUE
[09:29:48.057]                           break
[09:29:48.057]                         }
[09:29:48.057]                       }
[09:29:48.057]                     }
[09:29:48.057]                     invisible(muffled)
[09:29:48.057]                   }
[09:29:48.057]                   muffleCondition(cond)
[09:29:48.057]                 })
[09:29:48.057]             }))
[09:29:48.057]             future::FutureResult(value = ...future.value$value, 
[09:29:48.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.057]                   ...future.rng), globalenv = if (FALSE) 
[09:29:48.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:48.057]                     ...future.globalenv.names))
[09:29:48.057]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:48.057]         }, condition = base::local({
[09:29:48.057]             c <- base::c
[09:29:48.057]             inherits <- base::inherits
[09:29:48.057]             invokeRestart <- base::invokeRestart
[09:29:48.057]             length <- base::length
[09:29:48.057]             list <- base::list
[09:29:48.057]             seq.int <- base::seq.int
[09:29:48.057]             signalCondition <- base::signalCondition
[09:29:48.057]             sys.calls <- base::sys.calls
[09:29:48.057]             `[[` <- base::`[[`
[09:29:48.057]             `+` <- base::`+`
[09:29:48.057]             `<<-` <- base::`<<-`
[09:29:48.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:48.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:48.057]                   3L)]
[09:29:48.057]             }
[09:29:48.057]             function(cond) {
[09:29:48.057]                 is_error <- inherits(cond, "error")
[09:29:48.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:48.057]                   NULL)
[09:29:48.057]                 if (is_error) {
[09:29:48.057]                   sessionInformation <- function() {
[09:29:48.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:48.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:48.057]                       search = base::search(), system = base::Sys.info())
[09:29:48.057]                   }
[09:29:48.057]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:48.057]                     cond$call), session = sessionInformation(), 
[09:29:48.057]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:48.057]                   signalCondition(cond)
[09:29:48.057]                 }
[09:29:48.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:48.057]                 "immediateCondition"))) {
[09:29:48.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:48.057]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:48.057]                   if (TRUE && !signal) {
[09:29:48.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.057]                     {
[09:29:48.057]                       inherits <- base::inherits
[09:29:48.057]                       invokeRestart <- base::invokeRestart
[09:29:48.057]                       is.null <- base::is.null
[09:29:48.057]                       muffled <- FALSE
[09:29:48.057]                       if (inherits(cond, "message")) {
[09:29:48.057]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.057]                         if (muffled) 
[09:29:48.057]                           invokeRestart("muffleMessage")
[09:29:48.057]                       }
[09:29:48.057]                       else if (inherits(cond, "warning")) {
[09:29:48.057]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.057]                         if (muffled) 
[09:29:48.057]                           invokeRestart("muffleWarning")
[09:29:48.057]                       }
[09:29:48.057]                       else if (inherits(cond, "condition")) {
[09:29:48.057]                         if (!is.null(pattern)) {
[09:29:48.057]                           computeRestarts <- base::computeRestarts
[09:29:48.057]                           grepl <- base::grepl
[09:29:48.057]                           restarts <- computeRestarts(cond)
[09:29:48.057]                           for (restart in restarts) {
[09:29:48.057]                             name <- restart$name
[09:29:48.057]                             if (is.null(name)) 
[09:29:48.057]                               next
[09:29:48.057]                             if (!grepl(pattern, name)) 
[09:29:48.057]                               next
[09:29:48.057]                             invokeRestart(restart)
[09:29:48.057]                             muffled <- TRUE
[09:29:48.057]                             break
[09:29:48.057]                           }
[09:29:48.057]                         }
[09:29:48.057]                       }
[09:29:48.057]                       invisible(muffled)
[09:29:48.057]                     }
[09:29:48.057]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.057]                   }
[09:29:48.057]                 }
[09:29:48.057]                 else {
[09:29:48.057]                   if (TRUE) {
[09:29:48.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.057]                     {
[09:29:48.057]                       inherits <- base::inherits
[09:29:48.057]                       invokeRestart <- base::invokeRestart
[09:29:48.057]                       is.null <- base::is.null
[09:29:48.057]                       muffled <- FALSE
[09:29:48.057]                       if (inherits(cond, "message")) {
[09:29:48.057]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.057]                         if (muffled) 
[09:29:48.057]                           invokeRestart("muffleMessage")
[09:29:48.057]                       }
[09:29:48.057]                       else if (inherits(cond, "warning")) {
[09:29:48.057]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.057]                         if (muffled) 
[09:29:48.057]                           invokeRestart("muffleWarning")
[09:29:48.057]                       }
[09:29:48.057]                       else if (inherits(cond, "condition")) {
[09:29:48.057]                         if (!is.null(pattern)) {
[09:29:48.057]                           computeRestarts <- base::computeRestarts
[09:29:48.057]                           grepl <- base::grepl
[09:29:48.057]                           restarts <- computeRestarts(cond)
[09:29:48.057]                           for (restart in restarts) {
[09:29:48.057]                             name <- restart$name
[09:29:48.057]                             if (is.null(name)) 
[09:29:48.057]                               next
[09:29:48.057]                             if (!grepl(pattern, name)) 
[09:29:48.057]                               next
[09:29:48.057]                             invokeRestart(restart)
[09:29:48.057]                             muffled <- TRUE
[09:29:48.057]                             break
[09:29:48.057]                           }
[09:29:48.057]                         }
[09:29:48.057]                       }
[09:29:48.057]                       invisible(muffled)
[09:29:48.057]                     }
[09:29:48.057]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.057]                   }
[09:29:48.057]                 }
[09:29:48.057]             }
[09:29:48.057]         }))
[09:29:48.057]     }, error = function(ex) {
[09:29:48.057]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:48.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.057]                 ...future.rng), started = ...future.startTime, 
[09:29:48.057]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:48.057]             version = "1.8"), class = "FutureResult")
[09:29:48.057]     }, finally = {
[09:29:48.057]         if (!identical(...future.workdir, getwd())) 
[09:29:48.057]             setwd(...future.workdir)
[09:29:48.057]         {
[09:29:48.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:48.057]                 ...future.oldOptions$nwarnings <- NULL
[09:29:48.057]             }
[09:29:48.057]             base::options(...future.oldOptions)
[09:29:48.057]             if (.Platform$OS.type == "windows") {
[09:29:48.057]                 old_names <- names(...future.oldEnvVars)
[09:29:48.057]                 envs <- base::Sys.getenv()
[09:29:48.057]                 names <- names(envs)
[09:29:48.057]                 common <- intersect(names, old_names)
[09:29:48.057]                 added <- setdiff(names, old_names)
[09:29:48.057]                 removed <- setdiff(old_names, names)
[09:29:48.057]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:48.057]                   envs[common]]
[09:29:48.057]                 NAMES <- toupper(changed)
[09:29:48.057]                 args <- list()
[09:29:48.057]                 for (kk in seq_along(NAMES)) {
[09:29:48.057]                   name <- changed[[kk]]
[09:29:48.057]                   NAME <- NAMES[[kk]]
[09:29:48.057]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.057]                     next
[09:29:48.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.057]                 }
[09:29:48.057]                 NAMES <- toupper(added)
[09:29:48.057]                 for (kk in seq_along(NAMES)) {
[09:29:48.057]                   name <- added[[kk]]
[09:29:48.057]                   NAME <- NAMES[[kk]]
[09:29:48.057]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.057]                     next
[09:29:48.057]                   args[[name]] <- ""
[09:29:48.057]                 }
[09:29:48.057]                 NAMES <- toupper(removed)
[09:29:48.057]                 for (kk in seq_along(NAMES)) {
[09:29:48.057]                   name <- removed[[kk]]
[09:29:48.057]                   NAME <- NAMES[[kk]]
[09:29:48.057]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.057]                     next
[09:29:48.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.057]                 }
[09:29:48.057]                 if (length(args) > 0) 
[09:29:48.057]                   base::do.call(base::Sys.setenv, args = args)
[09:29:48.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:48.057]             }
[09:29:48.057]             else {
[09:29:48.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:48.057]             }
[09:29:48.057]             {
[09:29:48.057]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:48.057]                   0L) {
[09:29:48.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:48.057]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:48.057]                   base::options(opts)
[09:29:48.057]                 }
[09:29:48.057]                 {
[09:29:48.057]                   {
[09:29:48.057]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:48.057]                     NULL
[09:29:48.057]                   }
[09:29:48.057]                   options(future.plan = NULL)
[09:29:48.057]                   if (is.na(NA_character_)) 
[09:29:48.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:48.057]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:48.057]                     .init = FALSE)
[09:29:48.057]                 }
[09:29:48.057]             }
[09:29:48.057]         }
[09:29:48.057]     })
[09:29:48.057]     if (TRUE) {
[09:29:48.057]         base::sink(type = "output", split = FALSE)
[09:29:48.057]         if (TRUE) {
[09:29:48.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:48.057]         }
[09:29:48.057]         else {
[09:29:48.057]             ...future.result["stdout"] <- base::list(NULL)
[09:29:48.057]         }
[09:29:48.057]         base::close(...future.stdout)
[09:29:48.057]         ...future.stdout <- NULL
[09:29:48.057]     }
[09:29:48.057]     ...future.result$conditions <- ...future.conditions
[09:29:48.057]     ...future.result$finished <- base::Sys.time()
[09:29:48.057]     ...future.result
[09:29:48.057] }
[09:29:48.059] assign_globals() ...
[09:29:48.059] List of 11
[09:29:48.059]  $ ...future.FUN            :function (x, ...)  
[09:29:48.059]  $ x_FUN                    :function (x)  
[09:29:48.059]  $ times                    : int 1
[09:29:48.059]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:48.059]  $ stop_if_not              :function (...)  
[09:29:48.059]  $ dim                      : NULL
[09:29:48.059]  $ valid_types              : chr "logical"
[09:29:48.059]  $ future.call.arguments    : list()
[09:29:48.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:48.059]  $ ...future.elements_ii    :List of 5
[09:29:48.059]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[09:29:48.059]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[09:29:48.059]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[09:29:48.059]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[09:29:48.059]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[09:29:48.059]  $ ...future.seeds_ii       : NULL
[09:29:48.059]  $ ...future.globals.maxSize: NULL
[09:29:48.059]  - attr(*, "where")=List of 11
[09:29:48.059]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:48.059]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:48.059]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:48.059]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:48.059]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:48.059]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:48.059]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:48.059]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:48.059]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:48.059]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:48.059]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:48.059]  - attr(*, "resolved")= logi FALSE
[09:29:48.059]  - attr(*, "total_size")= num 94200
[09:29:48.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:48.059]  - attr(*, "already-done")= logi TRUE
[09:29:48.070] - copied ‘...future.FUN’ to environment
[09:29:48.070] - copied ‘x_FUN’ to environment
[09:29:48.070] - copied ‘times’ to environment
[09:29:48.070] - copied ‘stopf’ to environment
[09:29:48.070] - copied ‘stop_if_not’ to environment
[09:29:48.070] - copied ‘dim’ to environment
[09:29:48.070] - copied ‘valid_types’ to environment
[09:29:48.070] - copied ‘future.call.arguments’ to environment
[09:29:48.070] - copied ‘...future.elements_ii’ to environment
[09:29:48.070] - copied ‘...future.seeds_ii’ to environment
[09:29:48.071] - copied ‘...future.globals.maxSize’ to environment
[09:29:48.071] assign_globals() ... done
[09:29:48.071] requestCore(): workers = 2
[09:29:48.073] MulticoreFuture started
[09:29:48.073] - Launch lazy future ... done
[09:29:48.073] run() for ‘MulticoreFuture’ ... done
[09:29:48.074] Created future:
[09:29:48.074] plan(): Setting new future strategy stack:
[09:29:48.074] List of future strategies:
[09:29:48.074] 1. sequential:
[09:29:48.074]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:48.074]    - tweaked: FALSE
[09:29:48.074]    - call: NULL
[09:29:48.079] plan(): nbrOfWorkers() = 1
[09:29:48.082] plan(): Setting new future strategy stack:
[09:29:48.082] List of future strategies:
[09:29:48.082] 1. multicore:
[09:29:48.082]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:48.082]    - tweaked: FALSE
[09:29:48.082]    - call: plan(strategy)
[09:29:48.088] plan(): nbrOfWorkers() = 2
[09:29:48.074] MulticoreFuture:
[09:29:48.074] Label: ‘future_vapply-2’
[09:29:48.074] Expression:
[09:29:48.074] {
[09:29:48.074]     do.call(function(...) {
[09:29:48.074]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.074]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:48.074]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.074]             on.exit(options(oopts), add = TRUE)
[09:29:48.074]         }
[09:29:48.074]         {
[09:29:48.074]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:48.074]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.074]                 ...future.FUN(...future.X_jj, ...)
[09:29:48.074]             })
[09:29:48.074]         }
[09:29:48.074]     }, args = future.call.arguments)
[09:29:48.074] }
[09:29:48.074] Lazy evaluation: FALSE
[09:29:48.074] Asynchronous evaluation: TRUE
[09:29:48.074] Local evaluation: TRUE
[09:29:48.074] Environment: R_GlobalEnv
[09:29:48.074] Capture standard output: TRUE
[09:29:48.074] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:48.074] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:48.074] Packages: 1 packages (‘future.apply’)
[09:29:48.074] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:48.074] Resolved: TRUE
[09:29:48.074] Value: <not collected>
[09:29:48.074] Conditions captured: <none>
[09:29:48.074] Early signaling: FALSE
[09:29:48.074] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:48.074] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.089] Chunk #2 of 2 ... DONE
[09:29:48.090] Launching 2 futures (chunks) ... DONE
[09:29:48.090] Resolving 2 futures (chunks) ...
[09:29:48.090] resolve() on list ...
[09:29:48.090]  recursive: 0
[09:29:48.091]  length: 2
[09:29:48.091] 
[09:29:48.091] Future #1
[09:29:48.091] result() for MulticoreFuture ...
[09:29:48.093] result() for MulticoreFuture ...
[09:29:48.093] result() for MulticoreFuture ... done
[09:29:48.093] result() for MulticoreFuture ... done
[09:29:48.093] result() for MulticoreFuture ...
[09:29:48.094] result() for MulticoreFuture ... done
[09:29:48.094] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:48.094] - nx: 2
[09:29:48.094] - relay: TRUE
[09:29:48.095] - stdout: TRUE
[09:29:48.095] - signal: TRUE
[09:29:48.095] - resignal: FALSE
[09:29:48.096] - force: TRUE
[09:29:48.096] - relayed: [n=2] FALSE, FALSE
[09:29:48.096] - queued futures: [n=2] FALSE, FALSE
[09:29:48.097]  - until=1
[09:29:48.097]  - relaying element #1
[09:29:48.097] result() for MulticoreFuture ...
[09:29:48.097] result() for MulticoreFuture ... done
[09:29:48.097] result() for MulticoreFuture ...
[09:29:48.098] result() for MulticoreFuture ... done
[09:29:48.098] result() for MulticoreFuture ...
[09:29:48.098] result() for MulticoreFuture ... done
[09:29:48.098] result() for MulticoreFuture ...
[09:29:48.098] result() for MulticoreFuture ... done
[09:29:48.099] - relayed: [n=2] TRUE, FALSE
[09:29:48.099] - queued futures: [n=2] TRUE, FALSE
[09:29:48.099] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:48.099]  length: 1 (resolved future 1)
[09:29:48.100] Future #2
[09:29:48.100] result() for MulticoreFuture ...
[09:29:48.101] result() for MulticoreFuture ...
[09:29:48.101] result() for MulticoreFuture ... done
[09:29:48.101] result() for MulticoreFuture ... done
[09:29:48.102] result() for MulticoreFuture ...
[09:29:48.102] result() for MulticoreFuture ... done
[09:29:48.102] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:48.102] - nx: 2
[09:29:48.102] - relay: TRUE
[09:29:48.102] - stdout: TRUE
[09:29:48.103] - signal: TRUE
[09:29:48.103] - resignal: FALSE
[09:29:48.103] - force: TRUE
[09:29:48.103] - relayed: [n=2] TRUE, FALSE
[09:29:48.103] - queued futures: [n=2] TRUE, FALSE
[09:29:48.103]  - until=2
[09:29:48.104]  - relaying element #2
[09:29:48.104] result() for MulticoreFuture ...
[09:29:48.104] result() for MulticoreFuture ... done
[09:29:48.104] result() for MulticoreFuture ...
[09:29:48.104] result() for MulticoreFuture ... done
[09:29:48.104] result() for MulticoreFuture ...
[09:29:48.105] result() for MulticoreFuture ... done
[09:29:48.105] result() for MulticoreFuture ...
[09:29:48.105] result() for MulticoreFuture ... done
[09:29:48.105] - relayed: [n=2] TRUE, TRUE
[09:29:48.105] - queued futures: [n=2] TRUE, TRUE
[09:29:48.105] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:48.105]  length: 0 (resolved future 2)
[09:29:48.105] Relaying remaining futures
[09:29:48.105] signalConditionsASAP(NULL, pos=0) ...
[09:29:48.105] - nx: 2
[09:29:48.106] - relay: TRUE
[09:29:48.106] - stdout: TRUE
[09:29:48.106] - signal: TRUE
[09:29:48.106] - resignal: FALSE
[09:29:48.106] - force: TRUE
[09:29:48.106] - relayed: [n=2] TRUE, TRUE
[09:29:48.106] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:48.106] - relayed: [n=2] TRUE, TRUE
[09:29:48.106] - queued futures: [n=2] TRUE, TRUE
[09:29:48.106] signalConditionsASAP(NULL, pos=0) ... done
[09:29:48.106] resolve() on list ... DONE
[09:29:48.107] result() for MulticoreFuture ...
[09:29:48.107] result() for MulticoreFuture ... done
[09:29:48.107] result() for MulticoreFuture ...
[09:29:48.107] result() for MulticoreFuture ... done
[09:29:48.107] result() for MulticoreFuture ...
[09:29:48.107] result() for MulticoreFuture ... done
[09:29:48.107] result() for MulticoreFuture ...
[09:29:48.107] result() for MulticoreFuture ... done
[09:29:48.107]  - Number of value chunks collected: 2
[09:29:48.108] Resolving 2 futures (chunks) ... DONE
[09:29:48.108] Reducing values from 2 chunks ...
[09:29:48.108]  - Number of values collected after concatenation: 11
[09:29:48.108]  - Number of values expected: 11
[09:29:48.108] Reducing values from 2 chunks ... DONE
[09:29:48.108] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[09:29:48.109] future_lapply() ...
[09:29:48.115] Number of chunks: 2
[09:29:48.115] getGlobalsAndPackagesXApply() ...
[09:29:48.115]  - future.globals: TRUE
[09:29:48.115] getGlobalsAndPackages() ...
[09:29:48.115] Searching for globals...
[09:29:48.118] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:48.118] Searching for globals ... DONE
[09:29:48.118] Resolving globals: FALSE
[09:29:48.119] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[09:29:48.122] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:48.122] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:48.122] - packages: [1] ‘future.apply’
[09:29:48.122] getGlobalsAndPackages() ... DONE
[09:29:48.122]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:48.122]  - needed namespaces: [n=1] ‘future.apply’
[09:29:48.123] Finding globals ... DONE
[09:29:48.123]  - use_args: TRUE
[09:29:48.123]  - Getting '...' globals ...
[09:29:48.123] resolve() on list ...
[09:29:48.123]  recursive: 0
[09:29:48.123]  length: 1
[09:29:48.123]  elements: ‘...’
[09:29:48.123]  length: 0 (resolved future 1)
[09:29:48.124] resolve() on list ... DONE
[09:29:48.124]    - '...' content: [n=0] 
[09:29:48.124] List of 1
[09:29:48.124]  $ ...: list()
[09:29:48.124]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:48.124]  - attr(*, "where")=List of 1
[09:29:48.124]   ..$ ...:<environment: 0x561d34804a68> 
[09:29:48.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:48.124]  - attr(*, "resolved")= logi TRUE
[09:29:48.124]  - attr(*, "total_size")= num NA
[09:29:48.127]  - Getting '...' globals ... DONE
[09:29:48.127] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:48.127] List of 8
[09:29:48.127]  $ ...future.FUN:function (x, ...)  
[09:29:48.127]  $ x_FUN        :function (x)  
[09:29:48.127]  $ times        : int 1
[09:29:48.127]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:48.127]  $ stop_if_not  :function (...)  
[09:29:48.127]  $ dim          : NULL
[09:29:48.127]  $ valid_types  : chr [1:2] "logical" "integer"
[09:29:48.127]  $ ...          : list()
[09:29:48.127]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:48.127]  - attr(*, "where")=List of 8
[09:29:48.127]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:48.127]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:48.127]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:48.127]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:48.127]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:48.127]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:48.127]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:48.127]   ..$ ...          :<environment: 0x561d34804a68> 
[09:29:48.127]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:48.127]  - attr(*, "resolved")= logi FALSE
[09:29:48.127]  - attr(*, "total_size")= num 94264
[09:29:48.132] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:48.132] getGlobalsAndPackagesXApply() ... DONE
[09:29:48.132] Number of futures (= number of chunks): 2
[09:29:48.133] Launching 2 futures (chunks) ...
[09:29:48.133] Chunk #1 of 2 ...
[09:29:48.133]  - Finding globals in 'X' for chunk #1 ...
[09:29:48.133] getGlobalsAndPackages() ...
[09:29:48.133] Searching for globals...
[09:29:48.133] 
[09:29:48.133] Searching for globals ... DONE
[09:29:48.133] - globals: [0] <none>
[09:29:48.133] getGlobalsAndPackages() ... DONE
[09:29:48.134]    + additional globals found: [n=0] 
[09:29:48.134]    + additional namespaces needed: [n=0] 
[09:29:48.134]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:48.134]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:48.134]  - seeds: <none>
[09:29:48.134]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.134] getGlobalsAndPackages() ...
[09:29:48.134] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.134] Resolving globals: FALSE
[09:29:48.134] Tweak future expression to call with '...' arguments ...
[09:29:48.135] {
[09:29:48.135]     do.call(function(...) {
[09:29:48.135]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.135]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:48.135]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.135]             on.exit(options(oopts), add = TRUE)
[09:29:48.135]         }
[09:29:48.135]         {
[09:29:48.135]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:48.135]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.135]                 ...future.FUN(...future.X_jj, ...)
[09:29:48.135]             })
[09:29:48.135]         }
[09:29:48.135]     }, args = future.call.arguments)
[09:29:48.135] }
[09:29:48.135] Tweak future expression to call with '...' arguments ... DONE
[09:29:48.135] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.135] - packages: [1] ‘future.apply’
[09:29:48.135] getGlobalsAndPackages() ... DONE
[09:29:48.136] run() for ‘Future’ ...
[09:29:48.136] - state: ‘created’
[09:29:48.136] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:48.139] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:48.140]   - Field: ‘label’
[09:29:48.140]   - Field: ‘local’
[09:29:48.140]   - Field: ‘owner’
[09:29:48.140]   - Field: ‘envir’
[09:29:48.140]   - Field: ‘workers’
[09:29:48.140]   - Field: ‘packages’
[09:29:48.140]   - Field: ‘gc’
[09:29:48.140]   - Field: ‘job’
[09:29:48.140]   - Field: ‘conditions’
[09:29:48.141]   - Field: ‘expr’
[09:29:48.141]   - Field: ‘uuid’
[09:29:48.141]   - Field: ‘seed’
[09:29:48.141]   - Field: ‘version’
[09:29:48.141]   - Field: ‘result’
[09:29:48.141]   - Field: ‘asynchronous’
[09:29:48.141]   - Field: ‘calls’
[09:29:48.141]   - Field: ‘globals’
[09:29:48.141]   - Field: ‘stdout’
[09:29:48.141]   - Field: ‘earlySignal’
[09:29:48.141]   - Field: ‘lazy’
[09:29:48.141]   - Field: ‘state’
[09:29:48.142] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:48.142] - Launch lazy future ...
[09:29:48.142] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:48.142] Packages needed by future strategies (n = 0): <none>
[09:29:48.144] {
[09:29:48.144]     {
[09:29:48.144]         {
[09:29:48.144]             ...future.startTime <- base::Sys.time()
[09:29:48.144]             {
[09:29:48.144]                 {
[09:29:48.144]                   {
[09:29:48.144]                     {
[09:29:48.144]                       {
[09:29:48.144]                         base::local({
[09:29:48.144]                           has_future <- base::requireNamespace("future", 
[09:29:48.144]                             quietly = TRUE)
[09:29:48.144]                           if (has_future) {
[09:29:48.144]                             ns <- base::getNamespace("future")
[09:29:48.144]                             version <- ns[[".package"]][["version"]]
[09:29:48.144]                             if (is.null(version)) 
[09:29:48.144]                               version <- utils::packageVersion("future")
[09:29:48.144]                           }
[09:29:48.144]                           else {
[09:29:48.144]                             version <- NULL
[09:29:48.144]                           }
[09:29:48.144]                           if (!has_future || version < "1.8.0") {
[09:29:48.144]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:48.144]                               "", base::R.version$version.string), 
[09:29:48.144]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:48.144]                                 base::R.version$platform, 8 * 
[09:29:48.144]                                   base::.Machine$sizeof.pointer), 
[09:29:48.144]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:48.144]                                 "release", "version")], collapse = " "), 
[09:29:48.144]                               hostname = base::Sys.info()[["nodename"]])
[09:29:48.144]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:48.144]                               info)
[09:29:48.144]                             info <- base::paste(info, collapse = "; ")
[09:29:48.144]                             if (!has_future) {
[09:29:48.144]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:48.144]                                 info)
[09:29:48.144]                             }
[09:29:48.144]                             else {
[09:29:48.144]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:48.144]                                 info, version)
[09:29:48.144]                             }
[09:29:48.144]                             base::stop(msg)
[09:29:48.144]                           }
[09:29:48.144]                         })
[09:29:48.144]                       }
[09:29:48.144]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:48.144]                       base::options(mc.cores = 1L)
[09:29:48.144]                     }
[09:29:48.144]                     base::local({
[09:29:48.144]                       for (pkg in "future.apply") {
[09:29:48.144]                         base::loadNamespace(pkg)
[09:29:48.144]                         base::library(pkg, character.only = TRUE)
[09:29:48.144]                       }
[09:29:48.144]                     })
[09:29:48.144]                   }
[09:29:48.144]                   ...future.strategy.old <- future::plan("list")
[09:29:48.144]                   options(future.plan = NULL)
[09:29:48.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:48.144]                 }
[09:29:48.144]                 ...future.workdir <- getwd()
[09:29:48.144]             }
[09:29:48.144]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:48.144]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:48.144]         }
[09:29:48.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:48.144]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:48.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:48.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:48.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:48.144]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:48.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:48.144]             base::names(...future.oldOptions))
[09:29:48.144]     }
[09:29:48.144]     if (FALSE) {
[09:29:48.144]     }
[09:29:48.144]     else {
[09:29:48.144]         if (TRUE) {
[09:29:48.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:48.144]                 open = "w")
[09:29:48.144]         }
[09:29:48.144]         else {
[09:29:48.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:48.144]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:48.144]         }
[09:29:48.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:48.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:48.144]             base::sink(type = "output", split = FALSE)
[09:29:48.144]             base::close(...future.stdout)
[09:29:48.144]         }, add = TRUE)
[09:29:48.144]     }
[09:29:48.144]     ...future.frame <- base::sys.nframe()
[09:29:48.144]     ...future.conditions <- base::list()
[09:29:48.144]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:48.144]     if (FALSE) {
[09:29:48.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:48.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:48.144]     }
[09:29:48.144]     ...future.result <- base::tryCatch({
[09:29:48.144]         base::withCallingHandlers({
[09:29:48.144]             ...future.value <- base::withVisible(base::local({
[09:29:48.144]                 withCallingHandlers({
[09:29:48.144]                   {
[09:29:48.144]                     do.call(function(...) {
[09:29:48.144]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.144]                       if (!identical(...future.globals.maxSize.org, 
[09:29:48.144]                         ...future.globals.maxSize)) {
[09:29:48.144]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.144]                         on.exit(options(oopts), add = TRUE)
[09:29:48.144]                       }
[09:29:48.144]                       {
[09:29:48.144]                         lapply(seq_along(...future.elements_ii), 
[09:29:48.144]                           FUN = function(jj) {
[09:29:48.144]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.144]                             ...future.FUN(...future.X_jj, ...)
[09:29:48.144]                           })
[09:29:48.144]                       }
[09:29:48.144]                     }, args = future.call.arguments)
[09:29:48.144]                   }
[09:29:48.144]                 }, immediateCondition = function(cond) {
[09:29:48.144]                   save_rds <- function (object, pathname, ...) 
[09:29:48.144]                   {
[09:29:48.144]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:48.144]                     if (file_test("-f", pathname_tmp)) {
[09:29:48.144]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.144]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:48.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.144]                         fi_tmp[["mtime"]])
[09:29:48.144]                     }
[09:29:48.144]                     tryCatch({
[09:29:48.144]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:48.144]                     }, error = function(ex) {
[09:29:48.144]                       msg <- conditionMessage(ex)
[09:29:48.144]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.144]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:48.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.144]                         fi_tmp[["mtime"]], msg)
[09:29:48.144]                       ex$message <- msg
[09:29:48.144]                       stop(ex)
[09:29:48.144]                     })
[09:29:48.144]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:48.144]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:48.144]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:48.144]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.144]                       fi <- file.info(pathname)
[09:29:48.144]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:48.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.144]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:48.144]                         fi[["size"]], fi[["mtime"]])
[09:29:48.144]                       stop(msg)
[09:29:48.144]                     }
[09:29:48.144]                     invisible(pathname)
[09:29:48.144]                   }
[09:29:48.144]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:48.144]                     rootPath = tempdir()) 
[09:29:48.144]                   {
[09:29:48.144]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:48.144]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:48.144]                       tmpdir = path, fileext = ".rds")
[09:29:48.144]                     save_rds(obj, file)
[09:29:48.144]                   }
[09:29:48.144]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:48.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.144]                   {
[09:29:48.144]                     inherits <- base::inherits
[09:29:48.144]                     invokeRestart <- base::invokeRestart
[09:29:48.144]                     is.null <- base::is.null
[09:29:48.144]                     muffled <- FALSE
[09:29:48.144]                     if (inherits(cond, "message")) {
[09:29:48.144]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:48.144]                       if (muffled) 
[09:29:48.144]                         invokeRestart("muffleMessage")
[09:29:48.144]                     }
[09:29:48.144]                     else if (inherits(cond, "warning")) {
[09:29:48.144]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:48.144]                       if (muffled) 
[09:29:48.144]                         invokeRestart("muffleWarning")
[09:29:48.144]                     }
[09:29:48.144]                     else if (inherits(cond, "condition")) {
[09:29:48.144]                       if (!is.null(pattern)) {
[09:29:48.144]                         computeRestarts <- base::computeRestarts
[09:29:48.144]                         grepl <- base::grepl
[09:29:48.144]                         restarts <- computeRestarts(cond)
[09:29:48.144]                         for (restart in restarts) {
[09:29:48.144]                           name <- restart$name
[09:29:48.144]                           if (is.null(name)) 
[09:29:48.144]                             next
[09:29:48.144]                           if (!grepl(pattern, name)) 
[09:29:48.144]                             next
[09:29:48.144]                           invokeRestart(restart)
[09:29:48.144]                           muffled <- TRUE
[09:29:48.144]                           break
[09:29:48.144]                         }
[09:29:48.144]                       }
[09:29:48.144]                     }
[09:29:48.144]                     invisible(muffled)
[09:29:48.144]                   }
[09:29:48.144]                   muffleCondition(cond)
[09:29:48.144]                 })
[09:29:48.144]             }))
[09:29:48.144]             future::FutureResult(value = ...future.value$value, 
[09:29:48.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.144]                   ...future.rng), globalenv = if (FALSE) 
[09:29:48.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:48.144]                     ...future.globalenv.names))
[09:29:48.144]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:48.144]         }, condition = base::local({
[09:29:48.144]             c <- base::c
[09:29:48.144]             inherits <- base::inherits
[09:29:48.144]             invokeRestart <- base::invokeRestart
[09:29:48.144]             length <- base::length
[09:29:48.144]             list <- base::list
[09:29:48.144]             seq.int <- base::seq.int
[09:29:48.144]             signalCondition <- base::signalCondition
[09:29:48.144]             sys.calls <- base::sys.calls
[09:29:48.144]             `[[` <- base::`[[`
[09:29:48.144]             `+` <- base::`+`
[09:29:48.144]             `<<-` <- base::`<<-`
[09:29:48.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:48.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:48.144]                   3L)]
[09:29:48.144]             }
[09:29:48.144]             function(cond) {
[09:29:48.144]                 is_error <- inherits(cond, "error")
[09:29:48.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:48.144]                   NULL)
[09:29:48.144]                 if (is_error) {
[09:29:48.144]                   sessionInformation <- function() {
[09:29:48.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:48.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:48.144]                       search = base::search(), system = base::Sys.info())
[09:29:48.144]                   }
[09:29:48.144]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:48.144]                     cond$call), session = sessionInformation(), 
[09:29:48.144]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:48.144]                   signalCondition(cond)
[09:29:48.144]                 }
[09:29:48.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:48.144]                 "immediateCondition"))) {
[09:29:48.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:48.144]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:48.144]                   if (TRUE && !signal) {
[09:29:48.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.144]                     {
[09:29:48.144]                       inherits <- base::inherits
[09:29:48.144]                       invokeRestart <- base::invokeRestart
[09:29:48.144]                       is.null <- base::is.null
[09:29:48.144]                       muffled <- FALSE
[09:29:48.144]                       if (inherits(cond, "message")) {
[09:29:48.144]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.144]                         if (muffled) 
[09:29:48.144]                           invokeRestart("muffleMessage")
[09:29:48.144]                       }
[09:29:48.144]                       else if (inherits(cond, "warning")) {
[09:29:48.144]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.144]                         if (muffled) 
[09:29:48.144]                           invokeRestart("muffleWarning")
[09:29:48.144]                       }
[09:29:48.144]                       else if (inherits(cond, "condition")) {
[09:29:48.144]                         if (!is.null(pattern)) {
[09:29:48.144]                           computeRestarts <- base::computeRestarts
[09:29:48.144]                           grepl <- base::grepl
[09:29:48.144]                           restarts <- computeRestarts(cond)
[09:29:48.144]                           for (restart in restarts) {
[09:29:48.144]                             name <- restart$name
[09:29:48.144]                             if (is.null(name)) 
[09:29:48.144]                               next
[09:29:48.144]                             if (!grepl(pattern, name)) 
[09:29:48.144]                               next
[09:29:48.144]                             invokeRestart(restart)
[09:29:48.144]                             muffled <- TRUE
[09:29:48.144]                             break
[09:29:48.144]                           }
[09:29:48.144]                         }
[09:29:48.144]                       }
[09:29:48.144]                       invisible(muffled)
[09:29:48.144]                     }
[09:29:48.144]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.144]                   }
[09:29:48.144]                 }
[09:29:48.144]                 else {
[09:29:48.144]                   if (TRUE) {
[09:29:48.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.144]                     {
[09:29:48.144]                       inherits <- base::inherits
[09:29:48.144]                       invokeRestart <- base::invokeRestart
[09:29:48.144]                       is.null <- base::is.null
[09:29:48.144]                       muffled <- FALSE
[09:29:48.144]                       if (inherits(cond, "message")) {
[09:29:48.144]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.144]                         if (muffled) 
[09:29:48.144]                           invokeRestart("muffleMessage")
[09:29:48.144]                       }
[09:29:48.144]                       else if (inherits(cond, "warning")) {
[09:29:48.144]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.144]                         if (muffled) 
[09:29:48.144]                           invokeRestart("muffleWarning")
[09:29:48.144]                       }
[09:29:48.144]                       else if (inherits(cond, "condition")) {
[09:29:48.144]                         if (!is.null(pattern)) {
[09:29:48.144]                           computeRestarts <- base::computeRestarts
[09:29:48.144]                           grepl <- base::grepl
[09:29:48.144]                           restarts <- computeRestarts(cond)
[09:29:48.144]                           for (restart in restarts) {
[09:29:48.144]                             name <- restart$name
[09:29:48.144]                             if (is.null(name)) 
[09:29:48.144]                               next
[09:29:48.144]                             if (!grepl(pattern, name)) 
[09:29:48.144]                               next
[09:29:48.144]                             invokeRestart(restart)
[09:29:48.144]                             muffled <- TRUE
[09:29:48.144]                             break
[09:29:48.144]                           }
[09:29:48.144]                         }
[09:29:48.144]                       }
[09:29:48.144]                       invisible(muffled)
[09:29:48.144]                     }
[09:29:48.144]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.144]                   }
[09:29:48.144]                 }
[09:29:48.144]             }
[09:29:48.144]         }))
[09:29:48.144]     }, error = function(ex) {
[09:29:48.144]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:48.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.144]                 ...future.rng), started = ...future.startTime, 
[09:29:48.144]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:48.144]             version = "1.8"), class = "FutureResult")
[09:29:48.144]     }, finally = {
[09:29:48.144]         if (!identical(...future.workdir, getwd())) 
[09:29:48.144]             setwd(...future.workdir)
[09:29:48.144]         {
[09:29:48.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:48.144]                 ...future.oldOptions$nwarnings <- NULL
[09:29:48.144]             }
[09:29:48.144]             base::options(...future.oldOptions)
[09:29:48.144]             if (.Platform$OS.type == "windows") {
[09:29:48.144]                 old_names <- names(...future.oldEnvVars)
[09:29:48.144]                 envs <- base::Sys.getenv()
[09:29:48.144]                 names <- names(envs)
[09:29:48.144]                 common <- intersect(names, old_names)
[09:29:48.144]                 added <- setdiff(names, old_names)
[09:29:48.144]                 removed <- setdiff(old_names, names)
[09:29:48.144]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:48.144]                   envs[common]]
[09:29:48.144]                 NAMES <- toupper(changed)
[09:29:48.144]                 args <- list()
[09:29:48.144]                 for (kk in seq_along(NAMES)) {
[09:29:48.144]                   name <- changed[[kk]]
[09:29:48.144]                   NAME <- NAMES[[kk]]
[09:29:48.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.144]                     next
[09:29:48.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.144]                 }
[09:29:48.144]                 NAMES <- toupper(added)
[09:29:48.144]                 for (kk in seq_along(NAMES)) {
[09:29:48.144]                   name <- added[[kk]]
[09:29:48.144]                   NAME <- NAMES[[kk]]
[09:29:48.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.144]                     next
[09:29:48.144]                   args[[name]] <- ""
[09:29:48.144]                 }
[09:29:48.144]                 NAMES <- toupper(removed)
[09:29:48.144]                 for (kk in seq_along(NAMES)) {
[09:29:48.144]                   name <- removed[[kk]]
[09:29:48.144]                   NAME <- NAMES[[kk]]
[09:29:48.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.144]                     next
[09:29:48.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.144]                 }
[09:29:48.144]                 if (length(args) > 0) 
[09:29:48.144]                   base::do.call(base::Sys.setenv, args = args)
[09:29:48.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:48.144]             }
[09:29:48.144]             else {
[09:29:48.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:48.144]             }
[09:29:48.144]             {
[09:29:48.144]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:48.144]                   0L) {
[09:29:48.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:48.144]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:48.144]                   base::options(opts)
[09:29:48.144]                 }
[09:29:48.144]                 {
[09:29:48.144]                   {
[09:29:48.144]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:48.144]                     NULL
[09:29:48.144]                   }
[09:29:48.144]                   options(future.plan = NULL)
[09:29:48.144]                   if (is.na(NA_character_)) 
[09:29:48.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:48.144]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:48.144]                     .init = FALSE)
[09:29:48.144]                 }
[09:29:48.144]             }
[09:29:48.144]         }
[09:29:48.144]     })
[09:29:48.144]     if (TRUE) {
[09:29:48.144]         base::sink(type = "output", split = FALSE)
[09:29:48.144]         if (TRUE) {
[09:29:48.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:48.144]         }
[09:29:48.144]         else {
[09:29:48.144]             ...future.result["stdout"] <- base::list(NULL)
[09:29:48.144]         }
[09:29:48.144]         base::close(...future.stdout)
[09:29:48.144]         ...future.stdout <- NULL
[09:29:48.144]     }
[09:29:48.144]     ...future.result$conditions <- ...future.conditions
[09:29:48.144]     ...future.result$finished <- base::Sys.time()
[09:29:48.144]     ...future.result
[09:29:48.144] }
[09:29:48.146] assign_globals() ...
[09:29:48.147] List of 11
[09:29:48.147]  $ ...future.FUN            :function (x, ...)  
[09:29:48.147]  $ x_FUN                    :function (x)  
[09:29:48.147]  $ times                    : int 1
[09:29:48.147]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:48.147]  $ stop_if_not              :function (...)  
[09:29:48.147]  $ dim                      : NULL
[09:29:48.147]  $ valid_types              : chr [1:2] "logical" "integer"
[09:29:48.147]  $ future.call.arguments    : list()
[09:29:48.147]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:48.147]  $ ...future.elements_ii    :List of 1
[09:29:48.147]   ..$ a: num 1
[09:29:48.147]  $ ...future.seeds_ii       : NULL
[09:29:48.147]  $ ...future.globals.maxSize: NULL
[09:29:48.147]  - attr(*, "where")=List of 11
[09:29:48.147]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:48.147]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:48.147]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:48.147]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:48.147]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:48.147]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:48.147]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:48.147]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:48.147]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:48.147]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:48.147]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:48.147]  - attr(*, "resolved")= logi FALSE
[09:29:48.147]  - attr(*, "total_size")= num 94264
[09:29:48.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:48.147]  - attr(*, "already-done")= logi TRUE
[09:29:48.154] - copied ‘...future.FUN’ to environment
[09:29:48.154] - copied ‘x_FUN’ to environment
[09:29:48.154] - copied ‘times’ to environment
[09:29:48.154] - copied ‘stopf’ to environment
[09:29:48.154] - copied ‘stop_if_not’ to environment
[09:29:48.154] - copied ‘dim’ to environment
[09:29:48.154] - copied ‘valid_types’ to environment
[09:29:48.154] - copied ‘future.call.arguments’ to environment
[09:29:48.155] - copied ‘...future.elements_ii’ to environment
[09:29:48.155] - copied ‘...future.seeds_ii’ to environment
[09:29:48.155] - copied ‘...future.globals.maxSize’ to environment
[09:29:48.155] assign_globals() ... done
[09:29:48.155] requestCore(): workers = 2
[09:29:48.157] MulticoreFuture started
[09:29:48.157] - Launch lazy future ... done
[09:29:48.158] run() for ‘MulticoreFuture’ ... done
[09:29:48.158] Created future:
[09:29:48.158] plan(): Setting new future strategy stack:
[09:29:48.159] List of future strategies:
[09:29:48.159] 1. sequential:
[09:29:48.159]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:48.159]    - tweaked: FALSE
[09:29:48.159]    - call: NULL
[09:29:48.159] plan(): nbrOfWorkers() = 1
[09:29:48.162] plan(): Setting new future strategy stack:
[09:29:48.162] List of future strategies:
[09:29:48.162] 1. multicore:
[09:29:48.162]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:48.162]    - tweaked: FALSE
[09:29:48.162]    - call: plan(strategy)
[09:29:48.167] plan(): nbrOfWorkers() = 2
[09:29:48.158] MulticoreFuture:
[09:29:48.158] Label: ‘future_vapply-1’
[09:29:48.158] Expression:
[09:29:48.158] {
[09:29:48.158]     do.call(function(...) {
[09:29:48.158]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.158]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:48.158]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.158]             on.exit(options(oopts), add = TRUE)
[09:29:48.158]         }
[09:29:48.158]         {
[09:29:48.158]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:48.158]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.158]                 ...future.FUN(...future.X_jj, ...)
[09:29:48.158]             })
[09:29:48.158]         }
[09:29:48.158]     }, args = future.call.arguments)
[09:29:48.158] }
[09:29:48.158] Lazy evaluation: FALSE
[09:29:48.158] Asynchronous evaluation: TRUE
[09:29:48.158] Local evaluation: TRUE
[09:29:48.158] Environment: R_GlobalEnv
[09:29:48.158] Capture standard output: TRUE
[09:29:48.158] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:48.158] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:48.158] Packages: 1 packages (‘future.apply’)
[09:29:48.158] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:48.158] Resolved: TRUE
[09:29:48.158] Value: <not collected>
[09:29:48.158] Conditions captured: <none>
[09:29:48.158] Early signaling: FALSE
[09:29:48.158] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:48.158] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.168] Chunk #1 of 2 ... DONE
[09:29:48.168] Chunk #2 of 2 ...
[09:29:48.168]  - Finding globals in 'X' for chunk #2 ...
[09:29:48.168] getGlobalsAndPackages() ...
[09:29:48.169] Searching for globals...
[09:29:48.169] 
[09:29:48.169] Searching for globals ... DONE
[09:29:48.169] - globals: [0] <none>
[09:29:48.169] getGlobalsAndPackages() ... DONE
[09:29:48.170]    + additional globals found: [n=0] 
[09:29:48.170]    + additional namespaces needed: [n=0] 
[09:29:48.170]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:48.170]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:48.170]  - seeds: <none>
[09:29:48.170]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.170] getGlobalsAndPackages() ...
[09:29:48.170] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.171] Resolving globals: FALSE
[09:29:48.171] Tweak future expression to call with '...' arguments ...
[09:29:48.171] {
[09:29:48.171]     do.call(function(...) {
[09:29:48.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:48.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.171]             on.exit(options(oopts), add = TRUE)
[09:29:48.171]         }
[09:29:48.171]         {
[09:29:48.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:48.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.171]                 ...future.FUN(...future.X_jj, ...)
[09:29:48.171]             })
[09:29:48.171]         }
[09:29:48.171]     }, args = future.call.arguments)
[09:29:48.171] }
[09:29:48.171] Tweak future expression to call with '...' arguments ... DONE
[09:29:48.172] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.173] - packages: [1] ‘future.apply’
[09:29:48.173] getGlobalsAndPackages() ... DONE
[09:29:48.173] run() for ‘Future’ ...
[09:29:48.174] - state: ‘created’
[09:29:48.174] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:48.178] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.178] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:48.179]   - Field: ‘label’
[09:29:48.179]   - Field: ‘local’
[09:29:48.179]   - Field: ‘owner’
[09:29:48.179]   - Field: ‘envir’
[09:29:48.179]   - Field: ‘workers’
[09:29:48.179]   - Field: ‘packages’
[09:29:48.179]   - Field: ‘gc’
[09:29:48.180]   - Field: ‘job’
[09:29:48.180]   - Field: ‘conditions’
[09:29:48.180]   - Field: ‘expr’
[09:29:48.180]   - Field: ‘uuid’
[09:29:48.180]   - Field: ‘seed’
[09:29:48.180]   - Field: ‘version’
[09:29:48.181]   - Field: ‘result’
[09:29:48.181]   - Field: ‘asynchronous’
[09:29:48.181]   - Field: ‘calls’
[09:29:48.181]   - Field: ‘globals’
[09:29:48.181]   - Field: ‘stdout’
[09:29:48.181]   - Field: ‘earlySignal’
[09:29:48.181]   - Field: ‘lazy’
[09:29:48.182]   - Field: ‘state’
[09:29:48.182] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:48.182] - Launch lazy future ...
[09:29:48.182] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:48.186] Packages needed by future strategies (n = 0): <none>
[09:29:48.187] {
[09:29:48.187]     {
[09:29:48.187]         {
[09:29:48.187]             ...future.startTime <- base::Sys.time()
[09:29:48.187]             {
[09:29:48.187]                 {
[09:29:48.187]                   {
[09:29:48.187]                     {
[09:29:48.187]                       {
[09:29:48.187]                         base::local({
[09:29:48.187]                           has_future <- base::requireNamespace("future", 
[09:29:48.187]                             quietly = TRUE)
[09:29:48.187]                           if (has_future) {
[09:29:48.187]                             ns <- base::getNamespace("future")
[09:29:48.187]                             version <- ns[[".package"]][["version"]]
[09:29:48.187]                             if (is.null(version)) 
[09:29:48.187]                               version <- utils::packageVersion("future")
[09:29:48.187]                           }
[09:29:48.187]                           else {
[09:29:48.187]                             version <- NULL
[09:29:48.187]                           }
[09:29:48.187]                           if (!has_future || version < "1.8.0") {
[09:29:48.187]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:48.187]                               "", base::R.version$version.string), 
[09:29:48.187]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:48.187]                                 base::R.version$platform, 8 * 
[09:29:48.187]                                   base::.Machine$sizeof.pointer), 
[09:29:48.187]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:48.187]                                 "release", "version")], collapse = " "), 
[09:29:48.187]                               hostname = base::Sys.info()[["nodename"]])
[09:29:48.187]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:48.187]                               info)
[09:29:48.187]                             info <- base::paste(info, collapse = "; ")
[09:29:48.187]                             if (!has_future) {
[09:29:48.187]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:48.187]                                 info)
[09:29:48.187]                             }
[09:29:48.187]                             else {
[09:29:48.187]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:48.187]                                 info, version)
[09:29:48.187]                             }
[09:29:48.187]                             base::stop(msg)
[09:29:48.187]                           }
[09:29:48.187]                         })
[09:29:48.187]                       }
[09:29:48.187]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:48.187]                       base::options(mc.cores = 1L)
[09:29:48.187]                     }
[09:29:48.187]                     base::local({
[09:29:48.187]                       for (pkg in "future.apply") {
[09:29:48.187]                         base::loadNamespace(pkg)
[09:29:48.187]                         base::library(pkg, character.only = TRUE)
[09:29:48.187]                       }
[09:29:48.187]                     })
[09:29:48.187]                   }
[09:29:48.187]                   ...future.strategy.old <- future::plan("list")
[09:29:48.187]                   options(future.plan = NULL)
[09:29:48.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:48.187]                 }
[09:29:48.187]                 ...future.workdir <- getwd()
[09:29:48.187]             }
[09:29:48.187]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:48.187]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:48.187]         }
[09:29:48.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:48.187]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:48.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:48.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:48.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:48.187]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:48.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:48.187]             base::names(...future.oldOptions))
[09:29:48.187]     }
[09:29:48.187]     if (FALSE) {
[09:29:48.187]     }
[09:29:48.187]     else {
[09:29:48.187]         if (TRUE) {
[09:29:48.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:48.187]                 open = "w")
[09:29:48.187]         }
[09:29:48.187]         else {
[09:29:48.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:48.187]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:48.187]         }
[09:29:48.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:48.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:48.187]             base::sink(type = "output", split = FALSE)
[09:29:48.187]             base::close(...future.stdout)
[09:29:48.187]         }, add = TRUE)
[09:29:48.187]     }
[09:29:48.187]     ...future.frame <- base::sys.nframe()
[09:29:48.187]     ...future.conditions <- base::list()
[09:29:48.187]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:48.187]     if (FALSE) {
[09:29:48.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:48.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:48.187]     }
[09:29:48.187]     ...future.result <- base::tryCatch({
[09:29:48.187]         base::withCallingHandlers({
[09:29:48.187]             ...future.value <- base::withVisible(base::local({
[09:29:48.187]                 withCallingHandlers({
[09:29:48.187]                   {
[09:29:48.187]                     do.call(function(...) {
[09:29:48.187]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.187]                       if (!identical(...future.globals.maxSize.org, 
[09:29:48.187]                         ...future.globals.maxSize)) {
[09:29:48.187]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.187]                         on.exit(options(oopts), add = TRUE)
[09:29:48.187]                       }
[09:29:48.187]                       {
[09:29:48.187]                         lapply(seq_along(...future.elements_ii), 
[09:29:48.187]                           FUN = function(jj) {
[09:29:48.187]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.187]                             ...future.FUN(...future.X_jj, ...)
[09:29:48.187]                           })
[09:29:48.187]                       }
[09:29:48.187]                     }, args = future.call.arguments)
[09:29:48.187]                   }
[09:29:48.187]                 }, immediateCondition = function(cond) {
[09:29:48.187]                   save_rds <- function (object, pathname, ...) 
[09:29:48.187]                   {
[09:29:48.187]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:48.187]                     if (file_test("-f", pathname_tmp)) {
[09:29:48.187]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.187]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:48.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.187]                         fi_tmp[["mtime"]])
[09:29:48.187]                     }
[09:29:48.187]                     tryCatch({
[09:29:48.187]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:48.187]                     }, error = function(ex) {
[09:29:48.187]                       msg <- conditionMessage(ex)
[09:29:48.187]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.187]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:48.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.187]                         fi_tmp[["mtime"]], msg)
[09:29:48.187]                       ex$message <- msg
[09:29:48.187]                       stop(ex)
[09:29:48.187]                     })
[09:29:48.187]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:48.187]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:48.187]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:48.187]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.187]                       fi <- file.info(pathname)
[09:29:48.187]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:48.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.187]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:48.187]                         fi[["size"]], fi[["mtime"]])
[09:29:48.187]                       stop(msg)
[09:29:48.187]                     }
[09:29:48.187]                     invisible(pathname)
[09:29:48.187]                   }
[09:29:48.187]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:48.187]                     rootPath = tempdir()) 
[09:29:48.187]                   {
[09:29:48.187]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:48.187]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:48.187]                       tmpdir = path, fileext = ".rds")
[09:29:48.187]                     save_rds(obj, file)
[09:29:48.187]                   }
[09:29:48.187]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:48.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.187]                   {
[09:29:48.187]                     inherits <- base::inherits
[09:29:48.187]                     invokeRestart <- base::invokeRestart
[09:29:48.187]                     is.null <- base::is.null
[09:29:48.187]                     muffled <- FALSE
[09:29:48.187]                     if (inherits(cond, "message")) {
[09:29:48.187]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:48.187]                       if (muffled) 
[09:29:48.187]                         invokeRestart("muffleMessage")
[09:29:48.187]                     }
[09:29:48.187]                     else if (inherits(cond, "warning")) {
[09:29:48.187]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:48.187]                       if (muffled) 
[09:29:48.187]                         invokeRestart("muffleWarning")
[09:29:48.187]                     }
[09:29:48.187]                     else if (inherits(cond, "condition")) {
[09:29:48.187]                       if (!is.null(pattern)) {
[09:29:48.187]                         computeRestarts <- base::computeRestarts
[09:29:48.187]                         grepl <- base::grepl
[09:29:48.187]                         restarts <- computeRestarts(cond)
[09:29:48.187]                         for (restart in restarts) {
[09:29:48.187]                           name <- restart$name
[09:29:48.187]                           if (is.null(name)) 
[09:29:48.187]                             next
[09:29:48.187]                           if (!grepl(pattern, name)) 
[09:29:48.187]                             next
[09:29:48.187]                           invokeRestart(restart)
[09:29:48.187]                           muffled <- TRUE
[09:29:48.187]                           break
[09:29:48.187]                         }
[09:29:48.187]                       }
[09:29:48.187]                     }
[09:29:48.187]                     invisible(muffled)
[09:29:48.187]                   }
[09:29:48.187]                   muffleCondition(cond)
[09:29:48.187]                 })
[09:29:48.187]             }))
[09:29:48.187]             future::FutureResult(value = ...future.value$value, 
[09:29:48.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.187]                   ...future.rng), globalenv = if (FALSE) 
[09:29:48.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:48.187]                     ...future.globalenv.names))
[09:29:48.187]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:48.187]         }, condition = base::local({
[09:29:48.187]             c <- base::c
[09:29:48.187]             inherits <- base::inherits
[09:29:48.187]             invokeRestart <- base::invokeRestart
[09:29:48.187]             length <- base::length
[09:29:48.187]             list <- base::list
[09:29:48.187]             seq.int <- base::seq.int
[09:29:48.187]             signalCondition <- base::signalCondition
[09:29:48.187]             sys.calls <- base::sys.calls
[09:29:48.187]             `[[` <- base::`[[`
[09:29:48.187]             `+` <- base::`+`
[09:29:48.187]             `<<-` <- base::`<<-`
[09:29:48.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:48.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:48.187]                   3L)]
[09:29:48.187]             }
[09:29:48.187]             function(cond) {
[09:29:48.187]                 is_error <- inherits(cond, "error")
[09:29:48.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:48.187]                   NULL)
[09:29:48.187]                 if (is_error) {
[09:29:48.187]                   sessionInformation <- function() {
[09:29:48.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:48.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:48.187]                       search = base::search(), system = base::Sys.info())
[09:29:48.187]                   }
[09:29:48.187]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:48.187]                     cond$call), session = sessionInformation(), 
[09:29:48.187]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:48.187]                   signalCondition(cond)
[09:29:48.187]                 }
[09:29:48.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:48.187]                 "immediateCondition"))) {
[09:29:48.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:48.187]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:48.187]                   if (TRUE && !signal) {
[09:29:48.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.187]                     {
[09:29:48.187]                       inherits <- base::inherits
[09:29:48.187]                       invokeRestart <- base::invokeRestart
[09:29:48.187]                       is.null <- base::is.null
[09:29:48.187]                       muffled <- FALSE
[09:29:48.187]                       if (inherits(cond, "message")) {
[09:29:48.187]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.187]                         if (muffled) 
[09:29:48.187]                           invokeRestart("muffleMessage")
[09:29:48.187]                       }
[09:29:48.187]                       else if (inherits(cond, "warning")) {
[09:29:48.187]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.187]                         if (muffled) 
[09:29:48.187]                           invokeRestart("muffleWarning")
[09:29:48.187]                       }
[09:29:48.187]                       else if (inherits(cond, "condition")) {
[09:29:48.187]                         if (!is.null(pattern)) {
[09:29:48.187]                           computeRestarts <- base::computeRestarts
[09:29:48.187]                           grepl <- base::grepl
[09:29:48.187]                           restarts <- computeRestarts(cond)
[09:29:48.187]                           for (restart in restarts) {
[09:29:48.187]                             name <- restart$name
[09:29:48.187]                             if (is.null(name)) 
[09:29:48.187]                               next
[09:29:48.187]                             if (!grepl(pattern, name)) 
[09:29:48.187]                               next
[09:29:48.187]                             invokeRestart(restart)
[09:29:48.187]                             muffled <- TRUE
[09:29:48.187]                             break
[09:29:48.187]                           }
[09:29:48.187]                         }
[09:29:48.187]                       }
[09:29:48.187]                       invisible(muffled)
[09:29:48.187]                     }
[09:29:48.187]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.187]                   }
[09:29:48.187]                 }
[09:29:48.187]                 else {
[09:29:48.187]                   if (TRUE) {
[09:29:48.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.187]                     {
[09:29:48.187]                       inherits <- base::inherits
[09:29:48.187]                       invokeRestart <- base::invokeRestart
[09:29:48.187]                       is.null <- base::is.null
[09:29:48.187]                       muffled <- FALSE
[09:29:48.187]                       if (inherits(cond, "message")) {
[09:29:48.187]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.187]                         if (muffled) 
[09:29:48.187]                           invokeRestart("muffleMessage")
[09:29:48.187]                       }
[09:29:48.187]                       else if (inherits(cond, "warning")) {
[09:29:48.187]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.187]                         if (muffled) 
[09:29:48.187]                           invokeRestart("muffleWarning")
[09:29:48.187]                       }
[09:29:48.187]                       else if (inherits(cond, "condition")) {
[09:29:48.187]                         if (!is.null(pattern)) {
[09:29:48.187]                           computeRestarts <- base::computeRestarts
[09:29:48.187]                           grepl <- base::grepl
[09:29:48.187]                           restarts <- computeRestarts(cond)
[09:29:48.187]                           for (restart in restarts) {
[09:29:48.187]                             name <- restart$name
[09:29:48.187]                             if (is.null(name)) 
[09:29:48.187]                               next
[09:29:48.187]                             if (!grepl(pattern, name)) 
[09:29:48.187]                               next
[09:29:48.187]                             invokeRestart(restart)
[09:29:48.187]                             muffled <- TRUE
[09:29:48.187]                             break
[09:29:48.187]                           }
[09:29:48.187]                         }
[09:29:48.187]                       }
[09:29:48.187]                       invisible(muffled)
[09:29:48.187]                     }
[09:29:48.187]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.187]                   }
[09:29:48.187]                 }
[09:29:48.187]             }
[09:29:48.187]         }))
[09:29:48.187]     }, error = function(ex) {
[09:29:48.187]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:48.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.187]                 ...future.rng), started = ...future.startTime, 
[09:29:48.187]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:48.187]             version = "1.8"), class = "FutureResult")
[09:29:48.187]     }, finally = {
[09:29:48.187]         if (!identical(...future.workdir, getwd())) 
[09:29:48.187]             setwd(...future.workdir)
[09:29:48.187]         {
[09:29:48.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:48.187]                 ...future.oldOptions$nwarnings <- NULL
[09:29:48.187]             }
[09:29:48.187]             base::options(...future.oldOptions)
[09:29:48.187]             if (.Platform$OS.type == "windows") {
[09:29:48.187]                 old_names <- names(...future.oldEnvVars)
[09:29:48.187]                 envs <- base::Sys.getenv()
[09:29:48.187]                 names <- names(envs)
[09:29:48.187]                 common <- intersect(names, old_names)
[09:29:48.187]                 added <- setdiff(names, old_names)
[09:29:48.187]                 removed <- setdiff(old_names, names)
[09:29:48.187]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:48.187]                   envs[common]]
[09:29:48.187]                 NAMES <- toupper(changed)
[09:29:48.187]                 args <- list()
[09:29:48.187]                 for (kk in seq_along(NAMES)) {
[09:29:48.187]                   name <- changed[[kk]]
[09:29:48.187]                   NAME <- NAMES[[kk]]
[09:29:48.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.187]                     next
[09:29:48.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.187]                 }
[09:29:48.187]                 NAMES <- toupper(added)
[09:29:48.187]                 for (kk in seq_along(NAMES)) {
[09:29:48.187]                   name <- added[[kk]]
[09:29:48.187]                   NAME <- NAMES[[kk]]
[09:29:48.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.187]                     next
[09:29:48.187]                   args[[name]] <- ""
[09:29:48.187]                 }
[09:29:48.187]                 NAMES <- toupper(removed)
[09:29:48.187]                 for (kk in seq_along(NAMES)) {
[09:29:48.187]                   name <- removed[[kk]]
[09:29:48.187]                   NAME <- NAMES[[kk]]
[09:29:48.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.187]                     next
[09:29:48.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.187]                 }
[09:29:48.187]                 if (length(args) > 0) 
[09:29:48.187]                   base::do.call(base::Sys.setenv, args = args)
[09:29:48.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:48.187]             }
[09:29:48.187]             else {
[09:29:48.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:48.187]             }
[09:29:48.187]             {
[09:29:48.187]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:48.187]                   0L) {
[09:29:48.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:48.187]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:48.187]                   base::options(opts)
[09:29:48.187]                 }
[09:29:48.187]                 {
[09:29:48.187]                   {
[09:29:48.187]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:48.187]                     NULL
[09:29:48.187]                   }
[09:29:48.187]                   options(future.plan = NULL)
[09:29:48.187]                   if (is.na(NA_character_)) 
[09:29:48.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:48.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:48.187]                     .init = FALSE)
[09:29:48.187]                 }
[09:29:48.187]             }
[09:29:48.187]         }
[09:29:48.187]     })
[09:29:48.187]     if (TRUE) {
[09:29:48.187]         base::sink(type = "output", split = FALSE)
[09:29:48.187]         if (TRUE) {
[09:29:48.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:48.187]         }
[09:29:48.187]         else {
[09:29:48.187]             ...future.result["stdout"] <- base::list(NULL)
[09:29:48.187]         }
[09:29:48.187]         base::close(...future.stdout)
[09:29:48.187]         ...future.stdout <- NULL
[09:29:48.187]     }
[09:29:48.187]     ...future.result$conditions <- ...future.conditions
[09:29:48.187]     ...future.result$finished <- base::Sys.time()
[09:29:48.187]     ...future.result
[09:29:48.187] }
[09:29:48.190] assign_globals() ...
[09:29:48.190] List of 11
[09:29:48.190]  $ ...future.FUN            :function (x, ...)  
[09:29:48.190]  $ x_FUN                    :function (x)  
[09:29:48.190]  $ times                    : int 1
[09:29:48.190]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:48.190]  $ stop_if_not              :function (...)  
[09:29:48.190]  $ dim                      : NULL
[09:29:48.190]  $ valid_types              : chr [1:2] "logical" "integer"
[09:29:48.190]  $ future.call.arguments    : list()
[09:29:48.190]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:48.190]  $ ...future.elements_ii    :List of 2
[09:29:48.190]   ..$ b: num 2
[09:29:48.190]   ..$ c: num 3
[09:29:48.190]  $ ...future.seeds_ii       : NULL
[09:29:48.190]  $ ...future.globals.maxSize: NULL
[09:29:48.190]  - attr(*, "where")=List of 11
[09:29:48.190]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:48.190]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:48.190]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:48.190]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:48.190]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:48.190]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:48.190]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:48.190]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:48.190]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:48.190]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:48.190]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:48.190]  - attr(*, "resolved")= logi FALSE
[09:29:48.190]  - attr(*, "total_size")= num 94264
[09:29:48.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:48.190]  - attr(*, "already-done")= logi TRUE
[09:29:48.203] - copied ‘...future.FUN’ to environment
[09:29:48.203] - copied ‘x_FUN’ to environment
[09:29:48.204] - copied ‘times’ to environment
[09:29:48.204] - copied ‘stopf’ to environment
[09:29:48.204] - copied ‘stop_if_not’ to environment
[09:29:48.204] - copied ‘dim’ to environment
[09:29:48.204] - copied ‘valid_types’ to environment
[09:29:48.204] - copied ‘future.call.arguments’ to environment
[09:29:48.204] - copied ‘...future.elements_ii’ to environment
[09:29:48.204] - copied ‘...future.seeds_ii’ to environment
[09:29:48.204] - copied ‘...future.globals.maxSize’ to environment
[09:29:48.205] assign_globals() ... done
[09:29:48.205] requestCore(): workers = 2
[09:29:48.207] MulticoreFuture started
[09:29:48.207] - Launch lazy future ... done
[09:29:48.207] run() for ‘MulticoreFuture’ ... done
[09:29:48.208] Created future:
[09:29:48.208] plan(): Setting new future strategy stack:
[09:29:48.208] List of future strategies:
[09:29:48.208] 1. sequential:
[09:29:48.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:48.208]    - tweaked: FALSE
[09:29:48.208]    - call: NULL
[09:29:48.209] plan(): nbrOfWorkers() = 1
[09:29:48.211] plan(): Setting new future strategy stack:
[09:29:48.212] List of future strategies:
[09:29:48.212] 1. multicore:
[09:29:48.212]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:48.212]    - tweaked: FALSE
[09:29:48.212]    - call: plan(strategy)
[09:29:48.217] plan(): nbrOfWorkers() = 2
[09:29:48.208] MulticoreFuture:
[09:29:48.208] Label: ‘future_vapply-2’
[09:29:48.208] Expression:
[09:29:48.208] {
[09:29:48.208]     do.call(function(...) {
[09:29:48.208]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.208]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:48.208]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.208]             on.exit(options(oopts), add = TRUE)
[09:29:48.208]         }
[09:29:48.208]         {
[09:29:48.208]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:48.208]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.208]                 ...future.FUN(...future.X_jj, ...)
[09:29:48.208]             })
[09:29:48.208]         }
[09:29:48.208]     }, args = future.call.arguments)
[09:29:48.208] }
[09:29:48.208] Lazy evaluation: FALSE
[09:29:48.208] Asynchronous evaluation: TRUE
[09:29:48.208] Local evaluation: TRUE
[09:29:48.208] Environment: R_GlobalEnv
[09:29:48.208] Capture standard output: TRUE
[09:29:48.208] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:48.208] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:48.208] Packages: 1 packages (‘future.apply’)
[09:29:48.208] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:48.208] Resolved: TRUE
[09:29:48.208] Value: <not collected>
[09:29:48.208] Conditions captured: <none>
[09:29:48.208] Early signaling: FALSE
[09:29:48.208] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:48.208] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.218] Chunk #2 of 2 ... DONE
[09:29:48.218] Launching 2 futures (chunks) ... DONE
[09:29:48.218] Resolving 2 futures (chunks) ...
[09:29:48.218] resolve() on list ...
[09:29:48.218]  recursive: 0
[09:29:48.219]  length: 2
[09:29:48.219] 
[09:29:48.219] Future #1
[09:29:48.219] result() for MulticoreFuture ...
[09:29:48.220] result() for MulticoreFuture ...
[09:29:48.220] result() for MulticoreFuture ... done
[09:29:48.220] result() for MulticoreFuture ... done
[09:29:48.220] result() for MulticoreFuture ...
[09:29:48.221] result() for MulticoreFuture ... done
[09:29:48.221] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:48.221] - nx: 2
[09:29:48.221] - relay: TRUE
[09:29:48.221] - stdout: TRUE
[09:29:48.221] - signal: TRUE
[09:29:48.222] - resignal: FALSE
[09:29:48.222] - force: TRUE
[09:29:48.222] - relayed: [n=2] FALSE, FALSE
[09:29:48.222] - queued futures: [n=2] FALSE, FALSE
[09:29:48.222]  - until=1
[09:29:48.222]  - relaying element #1
[09:29:48.222] result() for MulticoreFuture ...
[09:29:48.223] result() for MulticoreFuture ... done
[09:29:48.223] result() for MulticoreFuture ...
[09:29:48.223] result() for MulticoreFuture ... done
[09:29:48.223] result() for MulticoreFuture ...
[09:29:48.223] result() for MulticoreFuture ... done
[09:29:48.223] result() for MulticoreFuture ...
[09:29:48.224] result() for MulticoreFuture ... done
[09:29:48.224] - relayed: [n=2] TRUE, FALSE
[09:29:48.224] - queued futures: [n=2] TRUE, FALSE
[09:29:48.224] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:48.224]  length: 1 (resolved future 1)
[09:29:48.224] Future #2
[09:29:48.225] result() for MulticoreFuture ...
[09:29:48.225] result() for MulticoreFuture ...
[09:29:48.225] result() for MulticoreFuture ... done
[09:29:48.226] result() for MulticoreFuture ... done
[09:29:48.226] result() for MulticoreFuture ...
[09:29:48.226] result() for MulticoreFuture ... done
[09:29:48.226] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:29:48.226] - nx: 2
[09:29:48.226] - relay: TRUE
[09:29:48.226] - stdout: TRUE
[09:29:48.227] - signal: TRUE
[09:29:48.227] - resignal: FALSE
[09:29:48.227] - force: TRUE
[09:29:48.227] - relayed: [n=2] TRUE, FALSE
[09:29:48.227] - queued futures: [n=2] TRUE, FALSE
[09:29:48.227]  - until=2
[09:29:48.227]  - relaying element #2
[09:29:48.227] result() for MulticoreFuture ...
[09:29:48.228] result() for MulticoreFuture ... done
[09:29:48.228] result() for MulticoreFuture ...
[09:29:48.228] result() for MulticoreFuture ... done
[09:29:48.228] result() for MulticoreFuture ...
[09:29:48.231] result() for MulticoreFuture ... done
[09:29:48.231] result() for MulticoreFuture ...
[09:29:48.231] result() for MulticoreFuture ... done
[09:29:48.231] - relayed: [n=2] TRUE, TRUE
[09:29:48.231] - queued futures: [n=2] TRUE, TRUE
[09:29:48.232] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:29:48.232]  length: 0 (resolved future 2)
[09:29:48.232] Relaying remaining futures
[09:29:48.232] signalConditionsASAP(NULL, pos=0) ...
[09:29:48.232] - nx: 2
[09:29:48.232] - relay: TRUE
[09:29:48.233] - stdout: TRUE
[09:29:48.233] - signal: TRUE
[09:29:48.233] - resignal: FALSE
[09:29:48.233] - force: TRUE
[09:29:48.233] - relayed: [n=2] TRUE, TRUE
[09:29:48.233] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:48.233] - relayed: [n=2] TRUE, TRUE
[09:29:48.234] - queued futures: [n=2] TRUE, TRUE
[09:29:48.234] signalConditionsASAP(NULL, pos=0) ... done
[09:29:48.234] resolve() on list ... DONE
[09:29:48.234] result() for MulticoreFuture ...
[09:29:48.234] result() for MulticoreFuture ... done
[09:29:48.234] result() for MulticoreFuture ...
[09:29:48.234] result() for MulticoreFuture ... done
[09:29:48.235] result() for MulticoreFuture ...
[09:29:48.235] result() for MulticoreFuture ... done
[09:29:48.235] result() for MulticoreFuture ...
[09:29:48.235] result() for MulticoreFuture ... done
[09:29:48.235]  - Number of value chunks collected: 2
[09:29:48.235] Resolving 2 futures (chunks) ... DONE
[09:29:48.235] Reducing values from 2 chunks ...
[09:29:48.236]  - Number of values collected after concatenation: 3
[09:29:48.236]  - Number of values expected: 3
[09:29:48.236] Reducing values from 2 chunks ... DONE
[09:29:48.236] future_lapply() ... DONE
- exceptions ...
[09:29:48.236] future_lapply() ...
[09:29:48.242] Number of chunks: 2
[09:29:48.243] getGlobalsAndPackagesXApply() ...
[09:29:48.243]  - future.globals: TRUE
[09:29:48.243] getGlobalsAndPackages() ...
[09:29:48.243] Searching for globals...
[09:29:48.246] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:48.247] Searching for globals ... DONE
[09:29:48.247] Resolving globals: FALSE
[09:29:48.248] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[09:29:48.248] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:48.248] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:48.248] - packages: [1] ‘future.apply’
[09:29:48.248] getGlobalsAndPackages() ... DONE
[09:29:48.248]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:48.249]  - needed namespaces: [n=1] ‘future.apply’
[09:29:48.249] Finding globals ... DONE
[09:29:48.249]  - use_args: TRUE
[09:29:48.249]  - Getting '...' globals ...
[09:29:48.249] resolve() on list ...
[09:29:48.249]  recursive: 0
[09:29:48.249]  length: 1
[09:29:48.249]  elements: ‘...’
[09:29:48.250]  length: 0 (resolved future 1)
[09:29:48.250] resolve() on list ... DONE
[09:29:48.250]    - '...' content: [n=0] 
[09:29:48.250] List of 1
[09:29:48.250]  $ ...: list()
[09:29:48.250]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:48.250]  - attr(*, "where")=List of 1
[09:29:48.250]   ..$ ...:<environment: 0x561d36daa508> 
[09:29:48.250]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:48.250]  - attr(*, "resolved")= logi TRUE
[09:29:48.250]  - attr(*, "total_size")= num NA
[09:29:48.252]  - Getting '...' globals ... DONE
[09:29:48.253] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:48.253] List of 8
[09:29:48.253]  $ ...future.FUN:function (x, ...)  
[09:29:48.253]  $ x_FUN        :function (x)  
[09:29:48.253]  $ times        : int 2
[09:29:48.253]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:48.253]  $ stop_if_not  :function (...)  
[09:29:48.253]  $ dim          : NULL
[09:29:48.253]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:48.253]  $ ...          : list()
[09:29:48.253]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:48.253]  - attr(*, "where")=List of 8
[09:29:48.253]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:48.253]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:48.253]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:48.253]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:48.253]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:48.253]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:48.253]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:48.253]   ..$ ...          :<environment: 0x561d36daa508> 
[09:29:48.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:48.253]  - attr(*, "resolved")= logi FALSE
[09:29:48.253]  - attr(*, "total_size")= num 95128
[09:29:48.260] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:48.260] getGlobalsAndPackagesXApply() ... DONE
[09:29:48.260] Number of futures (= number of chunks): 2
[09:29:48.260] Launching 2 futures (chunks) ...
[09:29:48.260] Chunk #1 of 2 ...
[09:29:48.260]  - Finding globals in 'X' for chunk #1 ...
[09:29:48.261] getGlobalsAndPackages() ...
[09:29:48.261] Searching for globals...
[09:29:48.261] 
[09:29:48.261] Searching for globals ... DONE
[09:29:48.261] - globals: [0] <none>
[09:29:48.261] getGlobalsAndPackages() ... DONE
[09:29:48.261]    + additional globals found: [n=0] 
[09:29:48.261]    + additional namespaces needed: [n=0] 
[09:29:48.261]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:48.262]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:48.262]  - seeds: <none>
[09:29:48.262]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.262] getGlobalsAndPackages() ...
[09:29:48.262] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.262] Resolving globals: FALSE
[09:29:48.262] Tweak future expression to call with '...' arguments ...
[09:29:48.262] {
[09:29:48.262]     do.call(function(...) {
[09:29:48.262]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.262]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:48.262]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.262]             on.exit(options(oopts), add = TRUE)
[09:29:48.262]         }
[09:29:48.262]         {
[09:29:48.262]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:48.262]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.262]                 ...future.FUN(...future.X_jj, ...)
[09:29:48.262]             })
[09:29:48.262]         }
[09:29:48.262]     }, args = future.call.arguments)
[09:29:48.262] }
[09:29:48.263] Tweak future expression to call with '...' arguments ... DONE
[09:29:48.263] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.263] - packages: [1] ‘future.apply’
[09:29:48.263] getGlobalsAndPackages() ... DONE
[09:29:48.264] run() for ‘Future’ ...
[09:29:48.264] - state: ‘created’
[09:29:48.264] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:48.267] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.267] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:48.268]   - Field: ‘label’
[09:29:48.268]   - Field: ‘local’
[09:29:48.268]   - Field: ‘owner’
[09:29:48.268]   - Field: ‘envir’
[09:29:48.268]   - Field: ‘workers’
[09:29:48.268]   - Field: ‘packages’
[09:29:48.268]   - Field: ‘gc’
[09:29:48.268]   - Field: ‘job’
[09:29:48.268]   - Field: ‘conditions’
[09:29:48.268]   - Field: ‘expr’
[09:29:48.268]   - Field: ‘uuid’
[09:29:48.269]   - Field: ‘seed’
[09:29:48.269]   - Field: ‘version’
[09:29:48.269]   - Field: ‘result’
[09:29:48.269]   - Field: ‘asynchronous’
[09:29:48.269]   - Field: ‘calls’
[09:29:48.269]   - Field: ‘globals’
[09:29:48.269]   - Field: ‘stdout’
[09:29:48.269]   - Field: ‘earlySignal’
[09:29:48.269]   - Field: ‘lazy’
[09:29:48.269]   - Field: ‘state’
[09:29:48.269] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:48.270] - Launch lazy future ...
[09:29:48.270] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:48.270] Packages needed by future strategies (n = 0): <none>
[09:29:48.270] {
[09:29:48.270]     {
[09:29:48.270]         {
[09:29:48.270]             ...future.startTime <- base::Sys.time()
[09:29:48.270]             {
[09:29:48.270]                 {
[09:29:48.270]                   {
[09:29:48.270]                     {
[09:29:48.270]                       {
[09:29:48.270]                         base::local({
[09:29:48.270]                           has_future <- base::requireNamespace("future", 
[09:29:48.270]                             quietly = TRUE)
[09:29:48.270]                           if (has_future) {
[09:29:48.270]                             ns <- base::getNamespace("future")
[09:29:48.270]                             version <- ns[[".package"]][["version"]]
[09:29:48.270]                             if (is.null(version)) 
[09:29:48.270]                               version <- utils::packageVersion("future")
[09:29:48.270]                           }
[09:29:48.270]                           else {
[09:29:48.270]                             version <- NULL
[09:29:48.270]                           }
[09:29:48.270]                           if (!has_future || version < "1.8.0") {
[09:29:48.270]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:48.270]                               "", base::R.version$version.string), 
[09:29:48.270]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:48.270]                                 base::R.version$platform, 8 * 
[09:29:48.270]                                   base::.Machine$sizeof.pointer), 
[09:29:48.270]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:48.270]                                 "release", "version")], collapse = " "), 
[09:29:48.270]                               hostname = base::Sys.info()[["nodename"]])
[09:29:48.270]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:48.270]                               info)
[09:29:48.270]                             info <- base::paste(info, collapse = "; ")
[09:29:48.270]                             if (!has_future) {
[09:29:48.270]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:48.270]                                 info)
[09:29:48.270]                             }
[09:29:48.270]                             else {
[09:29:48.270]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:48.270]                                 info, version)
[09:29:48.270]                             }
[09:29:48.270]                             base::stop(msg)
[09:29:48.270]                           }
[09:29:48.270]                         })
[09:29:48.270]                       }
[09:29:48.270]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:48.270]                       base::options(mc.cores = 1L)
[09:29:48.270]                     }
[09:29:48.270]                     base::local({
[09:29:48.270]                       for (pkg in "future.apply") {
[09:29:48.270]                         base::loadNamespace(pkg)
[09:29:48.270]                         base::library(pkg, character.only = TRUE)
[09:29:48.270]                       }
[09:29:48.270]                     })
[09:29:48.270]                   }
[09:29:48.270]                   ...future.strategy.old <- future::plan("list")
[09:29:48.270]                   options(future.plan = NULL)
[09:29:48.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:48.270]                 }
[09:29:48.270]                 ...future.workdir <- getwd()
[09:29:48.270]             }
[09:29:48.270]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:48.270]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:48.270]         }
[09:29:48.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:48.270]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:48.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:48.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:48.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:48.270]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:48.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:48.270]             base::names(...future.oldOptions))
[09:29:48.270]     }
[09:29:48.270]     if (FALSE) {
[09:29:48.270]     }
[09:29:48.270]     else {
[09:29:48.270]         if (TRUE) {
[09:29:48.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:48.270]                 open = "w")
[09:29:48.270]         }
[09:29:48.270]         else {
[09:29:48.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:48.270]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:48.270]         }
[09:29:48.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:48.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:48.270]             base::sink(type = "output", split = FALSE)
[09:29:48.270]             base::close(...future.stdout)
[09:29:48.270]         }, add = TRUE)
[09:29:48.270]     }
[09:29:48.270]     ...future.frame <- base::sys.nframe()
[09:29:48.270]     ...future.conditions <- base::list()
[09:29:48.270]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:48.270]     if (FALSE) {
[09:29:48.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:48.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:48.270]     }
[09:29:48.270]     ...future.result <- base::tryCatch({
[09:29:48.270]         base::withCallingHandlers({
[09:29:48.270]             ...future.value <- base::withVisible(base::local({
[09:29:48.270]                 withCallingHandlers({
[09:29:48.270]                   {
[09:29:48.270]                     do.call(function(...) {
[09:29:48.270]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.270]                       if (!identical(...future.globals.maxSize.org, 
[09:29:48.270]                         ...future.globals.maxSize)) {
[09:29:48.270]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.270]                         on.exit(options(oopts), add = TRUE)
[09:29:48.270]                       }
[09:29:48.270]                       {
[09:29:48.270]                         lapply(seq_along(...future.elements_ii), 
[09:29:48.270]                           FUN = function(jj) {
[09:29:48.270]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.270]                             ...future.FUN(...future.X_jj, ...)
[09:29:48.270]                           })
[09:29:48.270]                       }
[09:29:48.270]                     }, args = future.call.arguments)
[09:29:48.270]                   }
[09:29:48.270]                 }, immediateCondition = function(cond) {
[09:29:48.270]                   save_rds <- function (object, pathname, ...) 
[09:29:48.270]                   {
[09:29:48.270]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:48.270]                     if (file_test("-f", pathname_tmp)) {
[09:29:48.270]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.270]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:48.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.270]                         fi_tmp[["mtime"]])
[09:29:48.270]                     }
[09:29:48.270]                     tryCatch({
[09:29:48.270]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:48.270]                     }, error = function(ex) {
[09:29:48.270]                       msg <- conditionMessage(ex)
[09:29:48.270]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.270]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:48.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.270]                         fi_tmp[["mtime"]], msg)
[09:29:48.270]                       ex$message <- msg
[09:29:48.270]                       stop(ex)
[09:29:48.270]                     })
[09:29:48.270]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:48.270]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:48.270]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:48.270]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.270]                       fi <- file.info(pathname)
[09:29:48.270]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:48.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.270]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:48.270]                         fi[["size"]], fi[["mtime"]])
[09:29:48.270]                       stop(msg)
[09:29:48.270]                     }
[09:29:48.270]                     invisible(pathname)
[09:29:48.270]                   }
[09:29:48.270]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:48.270]                     rootPath = tempdir()) 
[09:29:48.270]                   {
[09:29:48.270]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:48.270]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:48.270]                       tmpdir = path, fileext = ".rds")
[09:29:48.270]                     save_rds(obj, file)
[09:29:48.270]                   }
[09:29:48.270]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:48.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.270]                   {
[09:29:48.270]                     inherits <- base::inherits
[09:29:48.270]                     invokeRestart <- base::invokeRestart
[09:29:48.270]                     is.null <- base::is.null
[09:29:48.270]                     muffled <- FALSE
[09:29:48.270]                     if (inherits(cond, "message")) {
[09:29:48.270]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:48.270]                       if (muffled) 
[09:29:48.270]                         invokeRestart("muffleMessage")
[09:29:48.270]                     }
[09:29:48.270]                     else if (inherits(cond, "warning")) {
[09:29:48.270]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:48.270]                       if (muffled) 
[09:29:48.270]                         invokeRestart("muffleWarning")
[09:29:48.270]                     }
[09:29:48.270]                     else if (inherits(cond, "condition")) {
[09:29:48.270]                       if (!is.null(pattern)) {
[09:29:48.270]                         computeRestarts <- base::computeRestarts
[09:29:48.270]                         grepl <- base::grepl
[09:29:48.270]                         restarts <- computeRestarts(cond)
[09:29:48.270]                         for (restart in restarts) {
[09:29:48.270]                           name <- restart$name
[09:29:48.270]                           if (is.null(name)) 
[09:29:48.270]                             next
[09:29:48.270]                           if (!grepl(pattern, name)) 
[09:29:48.270]                             next
[09:29:48.270]                           invokeRestart(restart)
[09:29:48.270]                           muffled <- TRUE
[09:29:48.270]                           break
[09:29:48.270]                         }
[09:29:48.270]                       }
[09:29:48.270]                     }
[09:29:48.270]                     invisible(muffled)
[09:29:48.270]                   }
[09:29:48.270]                   muffleCondition(cond)
[09:29:48.270]                 })
[09:29:48.270]             }))
[09:29:48.270]             future::FutureResult(value = ...future.value$value, 
[09:29:48.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.270]                   ...future.rng), globalenv = if (FALSE) 
[09:29:48.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:48.270]                     ...future.globalenv.names))
[09:29:48.270]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:48.270]         }, condition = base::local({
[09:29:48.270]             c <- base::c
[09:29:48.270]             inherits <- base::inherits
[09:29:48.270]             invokeRestart <- base::invokeRestart
[09:29:48.270]             length <- base::length
[09:29:48.270]             list <- base::list
[09:29:48.270]             seq.int <- base::seq.int
[09:29:48.270]             signalCondition <- base::signalCondition
[09:29:48.270]             sys.calls <- base::sys.calls
[09:29:48.270]             `[[` <- base::`[[`
[09:29:48.270]             `+` <- base::`+`
[09:29:48.270]             `<<-` <- base::`<<-`
[09:29:48.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:48.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:48.270]                   3L)]
[09:29:48.270]             }
[09:29:48.270]             function(cond) {
[09:29:48.270]                 is_error <- inherits(cond, "error")
[09:29:48.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:48.270]                   NULL)
[09:29:48.270]                 if (is_error) {
[09:29:48.270]                   sessionInformation <- function() {
[09:29:48.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:48.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:48.270]                       search = base::search(), system = base::Sys.info())
[09:29:48.270]                   }
[09:29:48.270]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:48.270]                     cond$call), session = sessionInformation(), 
[09:29:48.270]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:48.270]                   signalCondition(cond)
[09:29:48.270]                 }
[09:29:48.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:48.270]                 "immediateCondition"))) {
[09:29:48.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:48.270]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:48.270]                   if (TRUE && !signal) {
[09:29:48.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.270]                     {
[09:29:48.270]                       inherits <- base::inherits
[09:29:48.270]                       invokeRestart <- base::invokeRestart
[09:29:48.270]                       is.null <- base::is.null
[09:29:48.270]                       muffled <- FALSE
[09:29:48.270]                       if (inherits(cond, "message")) {
[09:29:48.270]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.270]                         if (muffled) 
[09:29:48.270]                           invokeRestart("muffleMessage")
[09:29:48.270]                       }
[09:29:48.270]                       else if (inherits(cond, "warning")) {
[09:29:48.270]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.270]                         if (muffled) 
[09:29:48.270]                           invokeRestart("muffleWarning")
[09:29:48.270]                       }
[09:29:48.270]                       else if (inherits(cond, "condition")) {
[09:29:48.270]                         if (!is.null(pattern)) {
[09:29:48.270]                           computeRestarts <- base::computeRestarts
[09:29:48.270]                           grepl <- base::grepl
[09:29:48.270]                           restarts <- computeRestarts(cond)
[09:29:48.270]                           for (restart in restarts) {
[09:29:48.270]                             name <- restart$name
[09:29:48.270]                             if (is.null(name)) 
[09:29:48.270]                               next
[09:29:48.270]                             if (!grepl(pattern, name)) 
[09:29:48.270]                               next
[09:29:48.270]                             invokeRestart(restart)
[09:29:48.270]                             muffled <- TRUE
[09:29:48.270]                             break
[09:29:48.270]                           }
[09:29:48.270]                         }
[09:29:48.270]                       }
[09:29:48.270]                       invisible(muffled)
[09:29:48.270]                     }
[09:29:48.270]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.270]                   }
[09:29:48.270]                 }
[09:29:48.270]                 else {
[09:29:48.270]                   if (TRUE) {
[09:29:48.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.270]                     {
[09:29:48.270]                       inherits <- base::inherits
[09:29:48.270]                       invokeRestart <- base::invokeRestart
[09:29:48.270]                       is.null <- base::is.null
[09:29:48.270]                       muffled <- FALSE
[09:29:48.270]                       if (inherits(cond, "message")) {
[09:29:48.270]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.270]                         if (muffled) 
[09:29:48.270]                           invokeRestart("muffleMessage")
[09:29:48.270]                       }
[09:29:48.270]                       else if (inherits(cond, "warning")) {
[09:29:48.270]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.270]                         if (muffled) 
[09:29:48.270]                           invokeRestart("muffleWarning")
[09:29:48.270]                       }
[09:29:48.270]                       else if (inherits(cond, "condition")) {
[09:29:48.270]                         if (!is.null(pattern)) {
[09:29:48.270]                           computeRestarts <- base::computeRestarts
[09:29:48.270]                           grepl <- base::grepl
[09:29:48.270]                           restarts <- computeRestarts(cond)
[09:29:48.270]                           for (restart in restarts) {
[09:29:48.270]                             name <- restart$name
[09:29:48.270]                             if (is.null(name)) 
[09:29:48.270]                               next
[09:29:48.270]                             if (!grepl(pattern, name)) 
[09:29:48.270]                               next
[09:29:48.270]                             invokeRestart(restart)
[09:29:48.270]                             muffled <- TRUE
[09:29:48.270]                             break
[09:29:48.270]                           }
[09:29:48.270]                         }
[09:29:48.270]                       }
[09:29:48.270]                       invisible(muffled)
[09:29:48.270]                     }
[09:29:48.270]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.270]                   }
[09:29:48.270]                 }
[09:29:48.270]             }
[09:29:48.270]         }))
[09:29:48.270]     }, error = function(ex) {
[09:29:48.270]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:48.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.270]                 ...future.rng), started = ...future.startTime, 
[09:29:48.270]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:48.270]             version = "1.8"), class = "FutureResult")
[09:29:48.270]     }, finally = {
[09:29:48.270]         if (!identical(...future.workdir, getwd())) 
[09:29:48.270]             setwd(...future.workdir)
[09:29:48.270]         {
[09:29:48.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:48.270]                 ...future.oldOptions$nwarnings <- NULL
[09:29:48.270]             }
[09:29:48.270]             base::options(...future.oldOptions)
[09:29:48.270]             if (.Platform$OS.type == "windows") {
[09:29:48.270]                 old_names <- names(...future.oldEnvVars)
[09:29:48.270]                 envs <- base::Sys.getenv()
[09:29:48.270]                 names <- names(envs)
[09:29:48.270]                 common <- intersect(names, old_names)
[09:29:48.270]                 added <- setdiff(names, old_names)
[09:29:48.270]                 removed <- setdiff(old_names, names)
[09:29:48.270]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:48.270]                   envs[common]]
[09:29:48.270]                 NAMES <- toupper(changed)
[09:29:48.270]                 args <- list()
[09:29:48.270]                 for (kk in seq_along(NAMES)) {
[09:29:48.270]                   name <- changed[[kk]]
[09:29:48.270]                   NAME <- NAMES[[kk]]
[09:29:48.270]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.270]                     next
[09:29:48.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.270]                 }
[09:29:48.270]                 NAMES <- toupper(added)
[09:29:48.270]                 for (kk in seq_along(NAMES)) {
[09:29:48.270]                   name <- added[[kk]]
[09:29:48.270]                   NAME <- NAMES[[kk]]
[09:29:48.270]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.270]                     next
[09:29:48.270]                   args[[name]] <- ""
[09:29:48.270]                 }
[09:29:48.270]                 NAMES <- toupper(removed)
[09:29:48.270]                 for (kk in seq_along(NAMES)) {
[09:29:48.270]                   name <- removed[[kk]]
[09:29:48.270]                   NAME <- NAMES[[kk]]
[09:29:48.270]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.270]                     next
[09:29:48.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.270]                 }
[09:29:48.270]                 if (length(args) > 0) 
[09:29:48.270]                   base::do.call(base::Sys.setenv, args = args)
[09:29:48.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:48.270]             }
[09:29:48.270]             else {
[09:29:48.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:48.270]             }
[09:29:48.270]             {
[09:29:48.270]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:48.270]                   0L) {
[09:29:48.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:48.270]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:48.270]                   base::options(opts)
[09:29:48.270]                 }
[09:29:48.270]                 {
[09:29:48.270]                   {
[09:29:48.270]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:48.270]                     NULL
[09:29:48.270]                   }
[09:29:48.270]                   options(future.plan = NULL)
[09:29:48.270]                   if (is.na(NA_character_)) 
[09:29:48.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:48.270]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:48.270]                     .init = FALSE)
[09:29:48.270]                 }
[09:29:48.270]             }
[09:29:48.270]         }
[09:29:48.270]     })
[09:29:48.270]     if (TRUE) {
[09:29:48.270]         base::sink(type = "output", split = FALSE)
[09:29:48.270]         if (TRUE) {
[09:29:48.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:48.270]         }
[09:29:48.270]         else {
[09:29:48.270]             ...future.result["stdout"] <- base::list(NULL)
[09:29:48.270]         }
[09:29:48.270]         base::close(...future.stdout)
[09:29:48.270]         ...future.stdout <- NULL
[09:29:48.270]     }
[09:29:48.270]     ...future.result$conditions <- ...future.conditions
[09:29:48.270]     ...future.result$finished <- base::Sys.time()
[09:29:48.270]     ...future.result
[09:29:48.270] }
[09:29:48.273] assign_globals() ...
[09:29:48.273] List of 11
[09:29:48.273]  $ ...future.FUN            :function (x, ...)  
[09:29:48.273]  $ x_FUN                    :function (x)  
[09:29:48.273]  $ times                    : int 2
[09:29:48.273]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:48.273]  $ stop_if_not              :function (...)  
[09:29:48.273]  $ dim                      : NULL
[09:29:48.273]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:48.273]  $ future.call.arguments    : list()
[09:29:48.273]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:48.273]  $ ...future.elements_ii    :List of 1
[09:29:48.273]   ..$ : int 1
[09:29:48.273]  $ ...future.seeds_ii       : NULL
[09:29:48.273]  $ ...future.globals.maxSize: NULL
[09:29:48.273]  - attr(*, "where")=List of 11
[09:29:48.273]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:48.273]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:48.273]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:48.273]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:48.273]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:48.273]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:48.273]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:48.273]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:48.273]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:48.273]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:48.273]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:48.273]  - attr(*, "resolved")= logi FALSE
[09:29:48.273]  - attr(*, "total_size")= num 95128
[09:29:48.273]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:48.273]  - attr(*, "already-done")= logi TRUE
[09:29:48.282] - copied ‘...future.FUN’ to environment
[09:29:48.282] - copied ‘x_FUN’ to environment
[09:29:48.282] - copied ‘times’ to environment
[09:29:48.282] - copied ‘stopf’ to environment
[09:29:48.282] - copied ‘stop_if_not’ to environment
[09:29:48.282] - copied ‘dim’ to environment
[09:29:48.283] - copied ‘valid_types’ to environment
[09:29:48.283] - copied ‘future.call.arguments’ to environment
[09:29:48.283] - copied ‘...future.elements_ii’ to environment
[09:29:48.283] - copied ‘...future.seeds_ii’ to environment
[09:29:48.283] - copied ‘...future.globals.maxSize’ to environment
[09:29:48.283] assign_globals() ... done
[09:29:48.283] requestCore(): workers = 2
[09:29:48.286] MulticoreFuture started
[09:29:48.286] - Launch lazy future ... done
[09:29:48.287] run() for ‘MulticoreFuture’ ... done
[09:29:48.287] Created future:
[09:29:48.288] plan(): Setting new future strategy stack:
[09:29:48.288] List of future strategies:
[09:29:48.288] 1. sequential:
[09:29:48.288]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:48.288]    - tweaked: FALSE
[09:29:48.288]    - call: NULL
[09:29:48.290] plan(): nbrOfWorkers() = 1
[09:29:48.293] plan(): Setting new future strategy stack:
[09:29:48.293] List of future strategies:
[09:29:48.293] 1. multicore:
[09:29:48.293]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:48.293]    - tweaked: FALSE
[09:29:48.293]    - call: plan(strategy)
[09:29:48.299] plan(): nbrOfWorkers() = 2
[09:29:48.288] MulticoreFuture:
[09:29:48.288] Label: ‘future_vapply-1’
[09:29:48.288] Expression:
[09:29:48.288] {
[09:29:48.288]     do.call(function(...) {
[09:29:48.288]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.288]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:48.288]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.288]             on.exit(options(oopts), add = TRUE)
[09:29:48.288]         }
[09:29:48.288]         {
[09:29:48.288]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:48.288]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.288]                 ...future.FUN(...future.X_jj, ...)
[09:29:48.288]             })
[09:29:48.288]         }
[09:29:48.288]     }, args = future.call.arguments)
[09:29:48.288] }
[09:29:48.288] Lazy evaluation: FALSE
[09:29:48.288] Asynchronous evaluation: TRUE
[09:29:48.288] Local evaluation: TRUE
[09:29:48.288] Environment: R_GlobalEnv
[09:29:48.288] Capture standard output: TRUE
[09:29:48.288] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:48.288] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:48.288] Packages: 1 packages (‘future.apply’)
[09:29:48.288] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:48.288] Resolved: FALSE
[09:29:48.288] Value: <not collected>
[09:29:48.288] Conditions captured: <none>
[09:29:48.288] Early signaling: FALSE
[09:29:48.288] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:48.288] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.302] Chunk #1 of 2 ... DONE
[09:29:48.303] Chunk #2 of 2 ...
[09:29:48.303]  - Finding globals in 'X' for chunk #2 ...
[09:29:48.303] getGlobalsAndPackages() ...
[09:29:48.303] Searching for globals...
[09:29:48.304] 
[09:29:48.304] Searching for globals ... DONE
[09:29:48.304] - globals: [0] <none>
[09:29:48.304] getGlobalsAndPackages() ... DONE
[09:29:48.304]    + additional globals found: [n=0] 
[09:29:48.304]    + additional namespaces needed: [n=0] 
[09:29:48.305]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:48.305]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:48.305]  - seeds: <none>
[09:29:48.305]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.305] getGlobalsAndPackages() ...
[09:29:48.305] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.305] Resolving globals: FALSE
[09:29:48.306] Tweak future expression to call with '...' arguments ...
[09:29:48.306] {
[09:29:48.306]     do.call(function(...) {
[09:29:48.306]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.306]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:48.306]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.306]             on.exit(options(oopts), add = TRUE)
[09:29:48.306]         }
[09:29:48.306]         {
[09:29:48.306]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:48.306]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.306]                 ...future.FUN(...future.X_jj, ...)
[09:29:48.306]             })
[09:29:48.306]         }
[09:29:48.306]     }, args = future.call.arguments)
[09:29:48.306] }
[09:29:48.306] Tweak future expression to call with '...' arguments ... DONE
[09:29:48.307] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:48.307] - packages: [1] ‘future.apply’
[09:29:48.307] getGlobalsAndPackages() ... DONE
[09:29:48.308] run() for ‘Future’ ...
[09:29:48.308] - state: ‘created’
[09:29:48.308] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:29:48.312] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.312] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:29:48.312]   - Field: ‘label’
[09:29:48.313]   - Field: ‘local’
[09:29:48.313]   - Field: ‘owner’
[09:29:48.313]   - Field: ‘envir’
[09:29:48.313]   - Field: ‘workers’
[09:29:48.313]   - Field: ‘packages’
[09:29:48.313]   - Field: ‘gc’
[09:29:48.313]   - Field: ‘job’
[09:29:48.313]   - Field: ‘conditions’
[09:29:48.314]   - Field: ‘expr’
[09:29:48.314]   - Field: ‘uuid’
[09:29:48.314]   - Field: ‘seed’
[09:29:48.314]   - Field: ‘version’
[09:29:48.314]   - Field: ‘result’
[09:29:48.314]   - Field: ‘asynchronous’
[09:29:48.314]   - Field: ‘calls’
[09:29:48.314]   - Field: ‘globals’
[09:29:48.315]   - Field: ‘stdout’
[09:29:48.315]   - Field: ‘earlySignal’
[09:29:48.315]   - Field: ‘lazy’
[09:29:48.315]   - Field: ‘state’
[09:29:48.315] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:29:48.315] - Launch lazy future ...
[09:29:48.316] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:48.316] Packages needed by future strategies (n = 0): <none>
[09:29:48.317] {
[09:29:48.317]     {
[09:29:48.317]         {
[09:29:48.317]             ...future.startTime <- base::Sys.time()
[09:29:48.317]             {
[09:29:48.317]                 {
[09:29:48.317]                   {
[09:29:48.317]                     {
[09:29:48.317]                       {
[09:29:48.317]                         base::local({
[09:29:48.317]                           has_future <- base::requireNamespace("future", 
[09:29:48.317]                             quietly = TRUE)
[09:29:48.317]                           if (has_future) {
[09:29:48.317]                             ns <- base::getNamespace("future")
[09:29:48.317]                             version <- ns[[".package"]][["version"]]
[09:29:48.317]                             if (is.null(version)) 
[09:29:48.317]                               version <- utils::packageVersion("future")
[09:29:48.317]                           }
[09:29:48.317]                           else {
[09:29:48.317]                             version <- NULL
[09:29:48.317]                           }
[09:29:48.317]                           if (!has_future || version < "1.8.0") {
[09:29:48.317]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:48.317]                               "", base::R.version$version.string), 
[09:29:48.317]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:48.317]                                 base::R.version$platform, 8 * 
[09:29:48.317]                                   base::.Machine$sizeof.pointer), 
[09:29:48.317]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:48.317]                                 "release", "version")], collapse = " "), 
[09:29:48.317]                               hostname = base::Sys.info()[["nodename"]])
[09:29:48.317]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:48.317]                               info)
[09:29:48.317]                             info <- base::paste(info, collapse = "; ")
[09:29:48.317]                             if (!has_future) {
[09:29:48.317]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:48.317]                                 info)
[09:29:48.317]                             }
[09:29:48.317]                             else {
[09:29:48.317]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:48.317]                                 info, version)
[09:29:48.317]                             }
[09:29:48.317]                             base::stop(msg)
[09:29:48.317]                           }
[09:29:48.317]                         })
[09:29:48.317]                       }
[09:29:48.317]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:48.317]                       base::options(mc.cores = 1L)
[09:29:48.317]                     }
[09:29:48.317]                     base::local({
[09:29:48.317]                       for (pkg in "future.apply") {
[09:29:48.317]                         base::loadNamespace(pkg)
[09:29:48.317]                         base::library(pkg, character.only = TRUE)
[09:29:48.317]                       }
[09:29:48.317]                     })
[09:29:48.317]                   }
[09:29:48.317]                   ...future.strategy.old <- future::plan("list")
[09:29:48.317]                   options(future.plan = NULL)
[09:29:48.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:48.317]                 }
[09:29:48.317]                 ...future.workdir <- getwd()
[09:29:48.317]             }
[09:29:48.317]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:48.317]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:48.317]         }
[09:29:48.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:48.317]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:48.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:48.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:48.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:48.317]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:48.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:48.317]             base::names(...future.oldOptions))
[09:29:48.317]     }
[09:29:48.317]     if (FALSE) {
[09:29:48.317]     }
[09:29:48.317]     else {
[09:29:48.317]         if (TRUE) {
[09:29:48.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:48.317]                 open = "w")
[09:29:48.317]         }
[09:29:48.317]         else {
[09:29:48.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:48.317]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:48.317]         }
[09:29:48.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:48.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:48.317]             base::sink(type = "output", split = FALSE)
[09:29:48.317]             base::close(...future.stdout)
[09:29:48.317]         }, add = TRUE)
[09:29:48.317]     }
[09:29:48.317]     ...future.frame <- base::sys.nframe()
[09:29:48.317]     ...future.conditions <- base::list()
[09:29:48.317]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:48.317]     if (FALSE) {
[09:29:48.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:48.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:48.317]     }
[09:29:48.317]     ...future.result <- base::tryCatch({
[09:29:48.317]         base::withCallingHandlers({
[09:29:48.317]             ...future.value <- base::withVisible(base::local({
[09:29:48.317]                 withCallingHandlers({
[09:29:48.317]                   {
[09:29:48.317]                     do.call(function(...) {
[09:29:48.317]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.317]                       if (!identical(...future.globals.maxSize.org, 
[09:29:48.317]                         ...future.globals.maxSize)) {
[09:29:48.317]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.317]                         on.exit(options(oopts), add = TRUE)
[09:29:48.317]                       }
[09:29:48.317]                       {
[09:29:48.317]                         lapply(seq_along(...future.elements_ii), 
[09:29:48.317]                           FUN = function(jj) {
[09:29:48.317]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.317]                             ...future.FUN(...future.X_jj, ...)
[09:29:48.317]                           })
[09:29:48.317]                       }
[09:29:48.317]                     }, args = future.call.arguments)
[09:29:48.317]                   }
[09:29:48.317]                 }, immediateCondition = function(cond) {
[09:29:48.317]                   save_rds <- function (object, pathname, ...) 
[09:29:48.317]                   {
[09:29:48.317]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:29:48.317]                     if (file_test("-f", pathname_tmp)) {
[09:29:48.317]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.317]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:29:48.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.317]                         fi_tmp[["mtime"]])
[09:29:48.317]                     }
[09:29:48.317]                     tryCatch({
[09:29:48.317]                       saveRDS(object, file = pathname_tmp, ...)
[09:29:48.317]                     }, error = function(ex) {
[09:29:48.317]                       msg <- conditionMessage(ex)
[09:29:48.317]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.317]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:29:48.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.317]                         fi_tmp[["mtime"]], msg)
[09:29:48.317]                       ex$message <- msg
[09:29:48.317]                       stop(ex)
[09:29:48.317]                     })
[09:29:48.317]                     stopifnot(file_test("-f", pathname_tmp))
[09:29:48.317]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:29:48.317]                     if (!res || file_test("-f", pathname_tmp)) {
[09:29:48.317]                       fi_tmp <- file.info(pathname_tmp)
[09:29:48.317]                       fi <- file.info(pathname)
[09:29:48.317]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:29:48.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:29:48.317]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:29:48.317]                         fi[["size"]], fi[["mtime"]])
[09:29:48.317]                       stop(msg)
[09:29:48.317]                     }
[09:29:48.317]                     invisible(pathname)
[09:29:48.317]                   }
[09:29:48.317]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:29:48.317]                     rootPath = tempdir()) 
[09:29:48.317]                   {
[09:29:48.317]                     obj <- list(time = Sys.time(), condition = cond)
[09:29:48.317]                     file <- tempfile(pattern = class(cond)[1], 
[09:29:48.317]                       tmpdir = path, fileext = ".rds")
[09:29:48.317]                     save_rds(obj, file)
[09:29:48.317]                   }
[09:29:48.317]                   saveImmediateCondition(cond, path = "/tmp/RtmpTd92Ax/.future/immediateConditions")
[09:29:48.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.317]                   {
[09:29:48.317]                     inherits <- base::inherits
[09:29:48.317]                     invokeRestart <- base::invokeRestart
[09:29:48.317]                     is.null <- base::is.null
[09:29:48.317]                     muffled <- FALSE
[09:29:48.317]                     if (inherits(cond, "message")) {
[09:29:48.317]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:48.317]                       if (muffled) 
[09:29:48.317]                         invokeRestart("muffleMessage")
[09:29:48.317]                     }
[09:29:48.317]                     else if (inherits(cond, "warning")) {
[09:29:48.317]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:48.317]                       if (muffled) 
[09:29:48.317]                         invokeRestart("muffleWarning")
[09:29:48.317]                     }
[09:29:48.317]                     else if (inherits(cond, "condition")) {
[09:29:48.317]                       if (!is.null(pattern)) {
[09:29:48.317]                         computeRestarts <- base::computeRestarts
[09:29:48.317]                         grepl <- base::grepl
[09:29:48.317]                         restarts <- computeRestarts(cond)
[09:29:48.317]                         for (restart in restarts) {
[09:29:48.317]                           name <- restart$name
[09:29:48.317]                           if (is.null(name)) 
[09:29:48.317]                             next
[09:29:48.317]                           if (!grepl(pattern, name)) 
[09:29:48.317]                             next
[09:29:48.317]                           invokeRestart(restart)
[09:29:48.317]                           muffled <- TRUE
[09:29:48.317]                           break
[09:29:48.317]                         }
[09:29:48.317]                       }
[09:29:48.317]                     }
[09:29:48.317]                     invisible(muffled)
[09:29:48.317]                   }
[09:29:48.317]                   muffleCondition(cond)
[09:29:48.317]                 })
[09:29:48.317]             }))
[09:29:48.317]             future::FutureResult(value = ...future.value$value, 
[09:29:48.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.317]                   ...future.rng), globalenv = if (FALSE) 
[09:29:48.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:48.317]                     ...future.globalenv.names))
[09:29:48.317]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:48.317]         }, condition = base::local({
[09:29:48.317]             c <- base::c
[09:29:48.317]             inherits <- base::inherits
[09:29:48.317]             invokeRestart <- base::invokeRestart
[09:29:48.317]             length <- base::length
[09:29:48.317]             list <- base::list
[09:29:48.317]             seq.int <- base::seq.int
[09:29:48.317]             signalCondition <- base::signalCondition
[09:29:48.317]             sys.calls <- base::sys.calls
[09:29:48.317]             `[[` <- base::`[[`
[09:29:48.317]             `+` <- base::`+`
[09:29:48.317]             `<<-` <- base::`<<-`
[09:29:48.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:48.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:48.317]                   3L)]
[09:29:48.317]             }
[09:29:48.317]             function(cond) {
[09:29:48.317]                 is_error <- inherits(cond, "error")
[09:29:48.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:48.317]                   NULL)
[09:29:48.317]                 if (is_error) {
[09:29:48.317]                   sessionInformation <- function() {
[09:29:48.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:48.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:48.317]                       search = base::search(), system = base::Sys.info())
[09:29:48.317]                   }
[09:29:48.317]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:48.317]                     cond$call), session = sessionInformation(), 
[09:29:48.317]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:48.317]                   signalCondition(cond)
[09:29:48.317]                 }
[09:29:48.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:48.317]                 "immediateCondition"))) {
[09:29:48.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:48.317]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:48.317]                   if (TRUE && !signal) {
[09:29:48.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.317]                     {
[09:29:48.317]                       inherits <- base::inherits
[09:29:48.317]                       invokeRestart <- base::invokeRestart
[09:29:48.317]                       is.null <- base::is.null
[09:29:48.317]                       muffled <- FALSE
[09:29:48.317]                       if (inherits(cond, "message")) {
[09:29:48.317]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.317]                         if (muffled) 
[09:29:48.317]                           invokeRestart("muffleMessage")
[09:29:48.317]                       }
[09:29:48.317]                       else if (inherits(cond, "warning")) {
[09:29:48.317]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.317]                         if (muffled) 
[09:29:48.317]                           invokeRestart("muffleWarning")
[09:29:48.317]                       }
[09:29:48.317]                       else if (inherits(cond, "condition")) {
[09:29:48.317]                         if (!is.null(pattern)) {
[09:29:48.317]                           computeRestarts <- base::computeRestarts
[09:29:48.317]                           grepl <- base::grepl
[09:29:48.317]                           restarts <- computeRestarts(cond)
[09:29:48.317]                           for (restart in restarts) {
[09:29:48.317]                             name <- restart$name
[09:29:48.317]                             if (is.null(name)) 
[09:29:48.317]                               next
[09:29:48.317]                             if (!grepl(pattern, name)) 
[09:29:48.317]                               next
[09:29:48.317]                             invokeRestart(restart)
[09:29:48.317]                             muffled <- TRUE
[09:29:48.317]                             break
[09:29:48.317]                           }
[09:29:48.317]                         }
[09:29:48.317]                       }
[09:29:48.317]                       invisible(muffled)
[09:29:48.317]                     }
[09:29:48.317]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.317]                   }
[09:29:48.317]                 }
[09:29:48.317]                 else {
[09:29:48.317]                   if (TRUE) {
[09:29:48.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.317]                     {
[09:29:48.317]                       inherits <- base::inherits
[09:29:48.317]                       invokeRestart <- base::invokeRestart
[09:29:48.317]                       is.null <- base::is.null
[09:29:48.317]                       muffled <- FALSE
[09:29:48.317]                       if (inherits(cond, "message")) {
[09:29:48.317]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.317]                         if (muffled) 
[09:29:48.317]                           invokeRestart("muffleMessage")
[09:29:48.317]                       }
[09:29:48.317]                       else if (inherits(cond, "warning")) {
[09:29:48.317]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.317]                         if (muffled) 
[09:29:48.317]                           invokeRestart("muffleWarning")
[09:29:48.317]                       }
[09:29:48.317]                       else if (inherits(cond, "condition")) {
[09:29:48.317]                         if (!is.null(pattern)) {
[09:29:48.317]                           computeRestarts <- base::computeRestarts
[09:29:48.317]                           grepl <- base::grepl
[09:29:48.317]                           restarts <- computeRestarts(cond)
[09:29:48.317]                           for (restart in restarts) {
[09:29:48.317]                             name <- restart$name
[09:29:48.317]                             if (is.null(name)) 
[09:29:48.317]                               next
[09:29:48.317]                             if (!grepl(pattern, name)) 
[09:29:48.317]                               next
[09:29:48.317]                             invokeRestart(restart)
[09:29:48.317]                             muffled <- TRUE
[09:29:48.317]                             break
[09:29:48.317]                           }
[09:29:48.317]                         }
[09:29:48.317]                       }
[09:29:48.317]                       invisible(muffled)
[09:29:48.317]                     }
[09:29:48.317]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.317]                   }
[09:29:48.317]                 }
[09:29:48.317]             }
[09:29:48.317]         }))
[09:29:48.317]     }, error = function(ex) {
[09:29:48.317]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:48.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.317]                 ...future.rng), started = ...future.startTime, 
[09:29:48.317]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:48.317]             version = "1.8"), class = "FutureResult")
[09:29:48.317]     }, finally = {
[09:29:48.317]         if (!identical(...future.workdir, getwd())) 
[09:29:48.317]             setwd(...future.workdir)
[09:29:48.317]         {
[09:29:48.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:48.317]                 ...future.oldOptions$nwarnings <- NULL
[09:29:48.317]             }
[09:29:48.317]             base::options(...future.oldOptions)
[09:29:48.317]             if (.Platform$OS.type == "windows") {
[09:29:48.317]                 old_names <- names(...future.oldEnvVars)
[09:29:48.317]                 envs <- base::Sys.getenv()
[09:29:48.317]                 names <- names(envs)
[09:29:48.317]                 common <- intersect(names, old_names)
[09:29:48.317]                 added <- setdiff(names, old_names)
[09:29:48.317]                 removed <- setdiff(old_names, names)
[09:29:48.317]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:48.317]                   envs[common]]
[09:29:48.317]                 NAMES <- toupper(changed)
[09:29:48.317]                 args <- list()
[09:29:48.317]                 for (kk in seq_along(NAMES)) {
[09:29:48.317]                   name <- changed[[kk]]
[09:29:48.317]                   NAME <- NAMES[[kk]]
[09:29:48.317]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.317]                     next
[09:29:48.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.317]                 }
[09:29:48.317]                 NAMES <- toupper(added)
[09:29:48.317]                 for (kk in seq_along(NAMES)) {
[09:29:48.317]                   name <- added[[kk]]
[09:29:48.317]                   NAME <- NAMES[[kk]]
[09:29:48.317]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.317]                     next
[09:29:48.317]                   args[[name]] <- ""
[09:29:48.317]                 }
[09:29:48.317]                 NAMES <- toupper(removed)
[09:29:48.317]                 for (kk in seq_along(NAMES)) {
[09:29:48.317]                   name <- removed[[kk]]
[09:29:48.317]                   NAME <- NAMES[[kk]]
[09:29:48.317]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.317]                     next
[09:29:48.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.317]                 }
[09:29:48.317]                 if (length(args) > 0) 
[09:29:48.317]                   base::do.call(base::Sys.setenv, args = args)
[09:29:48.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:48.317]             }
[09:29:48.317]             else {
[09:29:48.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:48.317]             }
[09:29:48.317]             {
[09:29:48.317]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:48.317]                   0L) {
[09:29:48.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:48.317]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:48.317]                   base::options(opts)
[09:29:48.317]                 }
[09:29:48.317]                 {
[09:29:48.317]                   {
[09:29:48.317]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:48.317]                     NULL
[09:29:48.317]                   }
[09:29:48.317]                   options(future.plan = NULL)
[09:29:48.317]                   if (is.na(NA_character_)) 
[09:29:48.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:48.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:48.317]                     .init = FALSE)
[09:29:48.317]                 }
[09:29:48.317]             }
[09:29:48.317]         }
[09:29:48.317]     })
[09:29:48.317]     if (TRUE) {
[09:29:48.317]         base::sink(type = "output", split = FALSE)
[09:29:48.317]         if (TRUE) {
[09:29:48.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:48.317]         }
[09:29:48.317]         else {
[09:29:48.317]             ...future.result["stdout"] <- base::list(NULL)
[09:29:48.317]         }
[09:29:48.317]         base::close(...future.stdout)
[09:29:48.317]         ...future.stdout <- NULL
[09:29:48.317]     }
[09:29:48.317]     ...future.result$conditions <- ...future.conditions
[09:29:48.317]     ...future.result$finished <- base::Sys.time()
[09:29:48.317]     ...future.result
[09:29:48.317] }
[09:29:48.320] assign_globals() ...
[09:29:48.320] List of 11
[09:29:48.320]  $ ...future.FUN            :function (x, ...)  
[09:29:48.320]  $ x_FUN                    :function (x)  
[09:29:48.320]  $ times                    : int 2
[09:29:48.320]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:48.320]  $ stop_if_not              :function (...)  
[09:29:48.320]  $ dim                      : NULL
[09:29:48.320]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[09:29:48.320]  $ future.call.arguments    : list()
[09:29:48.320]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:48.320]  $ ...future.elements_ii    :List of 2
[09:29:48.320]   ..$ : int 2
[09:29:48.320]   ..$ : int 3
[09:29:48.320]  $ ...future.seeds_ii       : NULL
[09:29:48.320]  $ ...future.globals.maxSize: NULL
[09:29:48.320]  - attr(*, "where")=List of 11
[09:29:48.320]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[09:29:48.320]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[09:29:48.320]   ..$ times                    :<environment: R_EmptyEnv> 
[09:29:48.320]   ..$ stopf                    :<environment: R_EmptyEnv> 
[09:29:48.320]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[09:29:48.320]   ..$ dim                      :<environment: R_EmptyEnv> 
[09:29:48.320]   ..$ valid_types              :<environment: R_EmptyEnv> 
[09:29:48.320]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[09:29:48.320]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[09:29:48.320]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[09:29:48.320]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[09:29:48.320]  - attr(*, "resolved")= logi FALSE
[09:29:48.320]  - attr(*, "total_size")= num 95128
[09:29:48.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:48.320]  - attr(*, "already-done")= logi TRUE
[09:29:48.333] - copied ‘...future.FUN’ to environment
[09:29:48.333] - copied ‘x_FUN’ to environment
[09:29:48.333] - copied ‘times’ to environment
[09:29:48.333] - copied ‘stopf’ to environment
[09:29:48.334] - copied ‘stop_if_not’ to environment
[09:29:48.334] - copied ‘dim’ to environment
[09:29:48.334] - copied ‘valid_types’ to environment
[09:29:48.334] - copied ‘future.call.arguments’ to environment
[09:29:48.334] - copied ‘...future.elements_ii’ to environment
[09:29:48.334] - copied ‘...future.seeds_ii’ to environment
[09:29:48.334] - copied ‘...future.globals.maxSize’ to environment
[09:29:48.334] assign_globals() ... done
[09:29:48.334] requestCore(): workers = 2
[09:29:48.337] MulticoreFuture started
[09:29:48.338] - Launch lazy future ... done
[09:29:48.338] run() for ‘MulticoreFuture’ ... done
[09:29:48.339] Created future:
[09:29:48.339] plan(): Setting new future strategy stack:
[09:29:48.339] List of future strategies:
[09:29:48.339] 1. sequential:
[09:29:48.339]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:48.339]    - tweaked: FALSE
[09:29:48.339]    - call: NULL
[09:29:48.341] plan(): nbrOfWorkers() = 1
[09:29:48.343] plan(): Setting new future strategy stack:
[09:29:48.343] List of future strategies:
[09:29:48.343] 1. multicore:
[09:29:48.343]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:29:48.343]    - tweaked: FALSE
[09:29:48.343]    - call: plan(strategy)
[09:29:48.349] plan(): nbrOfWorkers() = 2
[09:29:48.339] MulticoreFuture:
[09:29:48.339] Label: ‘future_vapply-2’
[09:29:48.339] Expression:
[09:29:48.339] {
[09:29:48.339]     do.call(function(...) {
[09:29:48.339]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:48.339]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:48.339]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:48.339]             on.exit(options(oopts), add = TRUE)
[09:29:48.339]         }
[09:29:48.339]         {
[09:29:48.339]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:48.339]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:48.339]                 ...future.FUN(...future.X_jj, ...)
[09:29:48.339]             })
[09:29:48.339]         }
[09:29:48.339]     }, args = future.call.arguments)
[09:29:48.339] }
[09:29:48.339] Lazy evaluation: FALSE
[09:29:48.339] Asynchronous evaluation: TRUE
[09:29:48.339] Local evaluation: TRUE
[09:29:48.339] Environment: R_GlobalEnv
[09:29:48.339] Capture standard output: TRUE
[09:29:48.339] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:48.339] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:48.339] Packages: 1 packages (‘future.apply’)
[09:29:48.339] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:48.339] Resolved: FALSE
[09:29:48.339] Value: <not collected>
[09:29:48.339] Conditions captured: <none>
[09:29:48.339] Early signaling: FALSE
[09:29:48.339] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:48.339] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:48.353] Chunk #2 of 2 ... DONE
[09:29:48.353] Launching 2 futures (chunks) ... DONE
[09:29:48.353] Resolving 2 futures (chunks) ...
[09:29:48.353] resolve() on list ...
[09:29:48.353]  recursive: 0
[09:29:48.354]  length: 2
[09:29:48.354] 
[09:29:48.354] Future #1
[09:29:48.355] result() for MulticoreFuture ...
[09:29:48.362] result() for MulticoreFuture ...
[09:29:48.362] result() for MulticoreFuture ... done
[09:29:48.362] signalConditions() ...
[09:29:48.362]  - include = ‘immediateCondition’
[09:29:48.362]  - exclude = 
[09:29:48.362]  - resignal = FALSE
[09:29:48.363]  - Number of conditions: 1
[09:29:48.363] signalConditions() ... done
[09:29:48.363] result() for MulticoreFuture ... done
[09:29:48.363] result() for MulticoreFuture ...
[09:29:48.363] result() for MulticoreFuture ... done
[09:29:48.363] signalConditions() ...
[09:29:48.363]  - include = ‘immediateCondition’
[09:29:48.364]  - exclude = 
[09:29:48.364]  - resignal = FALSE
[09:29:48.364]  - Number of conditions: 1
[09:29:48.364] signalConditions() ... done
[09:29:48.364] signalConditionsASAP(MulticoreFuture, pos=1) ...
[09:29:48.364] - nx: 2
[09:29:48.364] - relay: TRUE
[09:29:48.365] - stdout: TRUE
[09:29:48.365] - signal: TRUE
[09:29:48.365] - resignal: FALSE
[09:29:48.365] - force: TRUE
[09:29:48.365] - relayed: [n=2] FALSE, FALSE
[09:29:48.365] - queued futures: [n=2] FALSE, FALSE
[09:29:48.365]  - until=1
[09:29:48.366]  - relaying element #1
[09:29:48.366] result() for MulticoreFuture ...
[09:29:48.366] result() for MulticoreFuture ... done
[09:29:48.366] result() for MulticoreFuture ...
[09:29:48.366] result() for MulticoreFuture ... done
[09:29:48.366] signalConditions() ...
[09:29:48.366]  - include = ‘immediateCondition’
[09:29:48.366]  - exclude = 
[09:29:48.367]  - resignal = FALSE
[09:29:48.367]  - Number of conditions: 1
[09:29:48.367] signalConditions() ... done
[09:29:48.367] result() for MulticoreFuture ...
[09:29:48.367] result() for MulticoreFuture ... done
[09:29:48.367] signalConditions() ...
[09:29:48.367]  - include = ‘immediateCondition’
[09:29:48.368]  - exclude = 
[09:29:48.368]  - resignal = FALSE
[09:29:48.368]  - Number of conditions: 1
[09:29:48.368] signalConditions() ... done
[09:29:48.368] result() for MulticoreFuture ...
[09:29:48.368] result() for MulticoreFuture ... done
[09:29:48.368] signalConditions() ...
[09:29:48.368]  - include = ‘condition’
[09:29:48.369]  - exclude = ‘immediateCondition’
[09:29:48.369]  - resignal = TRUE
[09:29:48.369]  - Number of conditions: 1
[09:29:48.369]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[09:29:48.369] signalConditions() ... done
[09:29:48.369] - relayed: [n=2] FALSE, FALSE
[09:29:48.369] - queued futures: [n=2] TRUE, FALSE
[09:29:48.373] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[09:29:48.373] plan(): Setting new future strategy stack:
[09:29:48.373] List of future strategies:
[09:29:48.373] 1. sequential:
[09:29:48.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:48.373]    - tweaked: FALSE
[09:29:48.373]    - call: plan(sequential)
[09:29:48.374] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[09:29:48.375] plan(): Setting new future strategy stack:
[09:29:48.375] List of future strategies:
[09:29:48.375] 1. multisession:
[09:29:48.375]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:29:48.375]    - tweaked: FALSE
[09:29:48.375]    - call: plan(strategy)
[09:29:48.376] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:29:48.376] multisession:
[09:29:48.376] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:29:48.376] - tweaked: FALSE
[09:29:48.376] - call: plan(strategy)
[09:29:48.383] getGlobalsAndPackages() ...
[09:29:48.383] Not searching for globals
[09:29:48.383] - globals: [0] <none>
[09:29:48.383] getGlobalsAndPackages() ... DONE
[09:29:48.384] [local output] makeClusterPSOCK() ...
[09:29:48.435] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:29:48.436] [local output] Base port: 11682
[09:29:48.437] [local output] Getting setup options for 2 cluster nodes ...
[09:29:48.437] [local output]  - Node 1 of 2 ...
[09:29:48.437] [local output] localMachine=TRUE => revtunnel=FALSE

[09:29:48.438] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpTd92Ax/worker.rank=1.parallelly.parent=36647.8f276a4fab89.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpTd92Ax/worker.rank=1.parallelly.parent=36647.8f276a4fab89.pid")'’
[09:29:48.624] - Possible to infer worker's PID: TRUE
[09:29:48.624] [local output] Rscript port: 11682

[09:29:48.625] [local output]  - Node 2 of 2 ...
[09:29:48.625] [local output] localMachine=TRUE => revtunnel=FALSE

[09:29:48.626] [local output] Rscript port: 11682

[09:29:48.626] [local output] Getting setup options for 2 cluster nodes ... done
[09:29:48.626] [local output]  - Parallel setup requested for some PSOCK nodes
[09:29:48.626] [local output] Setting up PSOCK nodes in parallel
[09:29:48.627] List of 36
[09:29:48.627]  $ worker          : chr "localhost"
[09:29:48.627]   ..- attr(*, "localhost")= logi TRUE
[09:29:48.627]  $ master          : chr "localhost"
[09:29:48.627]  $ port            : int 11682
[09:29:48.627]  $ connectTimeout  : num 120
[09:29:48.627]  $ timeout         : num 2592000
[09:29:48.627]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:29:48.627]  $ homogeneous     : logi TRUE
[09:29:48.627]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:29:48.627]  $ rscript_envs    : NULL
[09:29:48.627]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:29:48.627]  $ rscript_startup : NULL
[09:29:48.627]  $ rscript_sh      : chr "sh"
[09:29:48.627]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:29:48.627]  $ methods         : logi TRUE
[09:29:48.627]  $ socketOptions   : chr "no-delay"
[09:29:48.627]  $ useXDR          : logi FALSE
[09:29:48.627]  $ outfile         : chr "/dev/null"
[09:29:48.627]  $ renice          : int NA
[09:29:48.627]  $ rshcmd          : NULL
[09:29:48.627]  $ user            : chr(0) 
[09:29:48.627]  $ revtunnel       : logi FALSE
[09:29:48.627]  $ rshlogfile      : NULL
[09:29:48.627]  $ rshopts         : chr(0) 
[09:29:48.627]  $ rank            : int 1
[09:29:48.627]  $ manual          : logi FALSE
[09:29:48.627]  $ dryrun          : logi FALSE
[09:29:48.627]  $ quiet           : logi FALSE
[09:29:48.627]  $ setup_strategy  : chr "parallel"
[09:29:48.627]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:29:48.627]  $ pidfile         : chr "/tmp/RtmpTd92Ax/worker.rank=1.parallelly.parent=36647.8f276a4fab89.pid"
[09:29:48.627]  $ rshcmd_label    : NULL
[09:29:48.627]  $ rsh_call        : NULL
[09:29:48.627]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:29:48.627]  $ localMachine    : logi TRUE
[09:29:48.627]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:29:48.627]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:29:48.627]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:29:48.627]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:29:48.627]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:29:48.627]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:29:48.627]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:29:48.627]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:29:48.627]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:29:48.627]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:29:48.627]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:29:48.627]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:29:48.627]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:29:48.627]  $ arguments       :List of 28
[09:29:48.627]   ..$ worker          : chr "localhost"
[09:29:48.627]   ..$ master          : NULL
[09:29:48.627]   ..$ port            : int 11682
[09:29:48.627]   ..$ connectTimeout  : num 120
[09:29:48.627]   ..$ timeout         : num 2592000
[09:29:48.627]   ..$ rscript         : NULL
[09:29:48.627]   ..$ homogeneous     : NULL
[09:29:48.627]   ..$ rscript_args    : NULL
[09:29:48.627]   ..$ rscript_envs    : NULL
[09:29:48.627]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:29:48.627]   ..$ rscript_startup : NULL
[09:29:48.627]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:29:48.627]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:29:48.627]   ..$ methods         : logi TRUE
[09:29:48.627]   ..$ socketOptions   : chr "no-delay"
[09:29:48.627]   ..$ useXDR          : logi FALSE
[09:29:48.627]   ..$ outfile         : chr "/dev/null"
[09:29:48.627]   ..$ renice          : int NA
[09:29:48.627]   ..$ rshcmd          : NULL
[09:29:48.627]   ..$ user            : NULL
[09:29:48.627]   ..$ revtunnel       : logi NA
[09:29:48.627]   ..$ rshlogfile      : NULL
[09:29:48.627]   ..$ rshopts         : NULL
[09:29:48.627]   ..$ rank            : int 1
[09:29:48.627]   ..$ manual          : logi FALSE
[09:29:48.627]   ..$ dryrun          : logi FALSE
[09:29:48.627]   ..$ quiet           : logi FALSE
[09:29:48.627]   ..$ setup_strategy  : chr "parallel"
[09:29:48.627]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:29:48.644] [local output] System call to launch all workers:
[09:29:48.644] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpTd92Ax/worker.rank=1.parallelly.parent=36647.8f276a4fab89.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11682 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:29:48.644] [local output] Starting PSOCK main server
[09:29:48.650] [local output] Workers launched
[09:29:48.650] [local output] Waiting for workers to connect back
[09:29:48.650]  - [local output] 0 workers out of 2 ready
[09:29:48.888]  - [local output] 0 workers out of 2 ready
[09:29:48.889]  - [local output] 1 workers out of 2 ready
[09:29:48.902]  - [local output] 1 workers out of 2 ready
[09:29:48.903]  - [local output] 2 workers out of 2 ready
[09:29:48.903] [local output] Launching of workers completed
[09:29:48.903] [local output] Collecting session information from workers
[09:29:48.904] [local output]  - Worker #1 of 2
[09:29:48.905] [local output]  - Worker #2 of 2
[09:29:48.905] [local output] makeClusterPSOCK() ... done
[09:29:48.916] Packages needed by the future expression (n = 0): <none>
[09:29:48.917] Packages needed by future strategies (n = 0): <none>
[09:29:48.917] {
[09:29:48.917]     {
[09:29:48.917]         {
[09:29:48.917]             ...future.startTime <- base::Sys.time()
[09:29:48.917]             {
[09:29:48.917]                 {
[09:29:48.917]                   {
[09:29:48.917]                     {
[09:29:48.917]                       base::local({
[09:29:48.917]                         has_future <- base::requireNamespace("future", 
[09:29:48.917]                           quietly = TRUE)
[09:29:48.917]                         if (has_future) {
[09:29:48.917]                           ns <- base::getNamespace("future")
[09:29:48.917]                           version <- ns[[".package"]][["version"]]
[09:29:48.917]                           if (is.null(version)) 
[09:29:48.917]                             version <- utils::packageVersion("future")
[09:29:48.917]                         }
[09:29:48.917]                         else {
[09:29:48.917]                           version <- NULL
[09:29:48.917]                         }
[09:29:48.917]                         if (!has_future || version < "1.8.0") {
[09:29:48.917]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:48.917]                             "", base::R.version$version.string), 
[09:29:48.917]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:48.917]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:48.917]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:48.917]                               "release", "version")], collapse = " "), 
[09:29:48.917]                             hostname = base::Sys.info()[["nodename"]])
[09:29:48.917]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:48.917]                             info)
[09:29:48.917]                           info <- base::paste(info, collapse = "; ")
[09:29:48.917]                           if (!has_future) {
[09:29:48.917]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:48.917]                               info)
[09:29:48.917]                           }
[09:29:48.917]                           else {
[09:29:48.917]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:48.917]                               info, version)
[09:29:48.917]                           }
[09:29:48.917]                           base::stop(msg)
[09:29:48.917]                         }
[09:29:48.917]                       })
[09:29:48.917]                     }
[09:29:48.917]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:48.917]                     base::options(mc.cores = 1L)
[09:29:48.917]                   }
[09:29:48.917]                   ...future.strategy.old <- future::plan("list")
[09:29:48.917]                   options(future.plan = NULL)
[09:29:48.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:48.917]                 }
[09:29:48.917]                 ...future.workdir <- getwd()
[09:29:48.917]             }
[09:29:48.917]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:48.917]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:48.917]         }
[09:29:48.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:48.917]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:29:48.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:48.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:48.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:48.917]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:48.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:48.917]             base::names(...future.oldOptions))
[09:29:48.917]     }
[09:29:48.917]     if (FALSE) {
[09:29:48.917]     }
[09:29:48.917]     else {
[09:29:48.917]         if (TRUE) {
[09:29:48.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:48.917]                 open = "w")
[09:29:48.917]         }
[09:29:48.917]         else {
[09:29:48.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:48.917]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:48.917]         }
[09:29:48.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:48.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:48.917]             base::sink(type = "output", split = FALSE)
[09:29:48.917]             base::close(...future.stdout)
[09:29:48.917]         }, add = TRUE)
[09:29:48.917]     }
[09:29:48.917]     ...future.frame <- base::sys.nframe()
[09:29:48.917]     ...future.conditions <- base::list()
[09:29:48.917]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:48.917]     if (FALSE) {
[09:29:48.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:48.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:48.917]     }
[09:29:48.917]     ...future.result <- base::tryCatch({
[09:29:48.917]         base::withCallingHandlers({
[09:29:48.917]             ...future.value <- base::withVisible(base::local({
[09:29:48.917]                 ...future.makeSendCondition <- base::local({
[09:29:48.917]                   sendCondition <- NULL
[09:29:48.917]                   function(frame = 1L) {
[09:29:48.917]                     if (is.function(sendCondition)) 
[09:29:48.917]                       return(sendCondition)
[09:29:48.917]                     ns <- getNamespace("parallel")
[09:29:48.917]                     if (exists("sendData", mode = "function", 
[09:29:48.917]                       envir = ns)) {
[09:29:48.917]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:48.917]                         envir = ns)
[09:29:48.917]                       envir <- sys.frame(frame)
[09:29:48.917]                       master <- NULL
[09:29:48.917]                       while (!identical(envir, .GlobalEnv) && 
[09:29:48.917]                         !identical(envir, emptyenv())) {
[09:29:48.917]                         if (exists("master", mode = "list", envir = envir, 
[09:29:48.917]                           inherits = FALSE)) {
[09:29:48.917]                           master <- get("master", mode = "list", 
[09:29:48.917]                             envir = envir, inherits = FALSE)
[09:29:48.917]                           if (inherits(master, c("SOCKnode", 
[09:29:48.917]                             "SOCK0node"))) {
[09:29:48.917]                             sendCondition <<- function(cond) {
[09:29:48.917]                               data <- list(type = "VALUE", value = cond, 
[09:29:48.917]                                 success = TRUE)
[09:29:48.917]                               parallel_sendData(master, data)
[09:29:48.917]                             }
[09:29:48.917]                             return(sendCondition)
[09:29:48.917]                           }
[09:29:48.917]                         }
[09:29:48.917]                         frame <- frame + 1L
[09:29:48.917]                         envir <- sys.frame(frame)
[09:29:48.917]                       }
[09:29:48.917]                     }
[09:29:48.917]                     sendCondition <<- function(cond) NULL
[09:29:48.917]                   }
[09:29:48.917]                 })
[09:29:48.917]                 withCallingHandlers({
[09:29:48.917]                   NA
[09:29:48.917]                 }, immediateCondition = function(cond) {
[09:29:48.917]                   sendCondition <- ...future.makeSendCondition()
[09:29:48.917]                   sendCondition(cond)
[09:29:48.917]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.917]                   {
[09:29:48.917]                     inherits <- base::inherits
[09:29:48.917]                     invokeRestart <- base::invokeRestart
[09:29:48.917]                     is.null <- base::is.null
[09:29:48.917]                     muffled <- FALSE
[09:29:48.917]                     if (inherits(cond, "message")) {
[09:29:48.917]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:48.917]                       if (muffled) 
[09:29:48.917]                         invokeRestart("muffleMessage")
[09:29:48.917]                     }
[09:29:48.917]                     else if (inherits(cond, "warning")) {
[09:29:48.917]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:48.917]                       if (muffled) 
[09:29:48.917]                         invokeRestart("muffleWarning")
[09:29:48.917]                     }
[09:29:48.917]                     else if (inherits(cond, "condition")) {
[09:29:48.917]                       if (!is.null(pattern)) {
[09:29:48.917]                         computeRestarts <- base::computeRestarts
[09:29:48.917]                         grepl <- base::grepl
[09:29:48.917]                         restarts <- computeRestarts(cond)
[09:29:48.917]                         for (restart in restarts) {
[09:29:48.917]                           name <- restart$name
[09:29:48.917]                           if (is.null(name)) 
[09:29:48.917]                             next
[09:29:48.917]                           if (!grepl(pattern, name)) 
[09:29:48.917]                             next
[09:29:48.917]                           invokeRestart(restart)
[09:29:48.917]                           muffled <- TRUE
[09:29:48.917]                           break
[09:29:48.917]                         }
[09:29:48.917]                       }
[09:29:48.917]                     }
[09:29:48.917]                     invisible(muffled)
[09:29:48.917]                   }
[09:29:48.917]                   muffleCondition(cond)
[09:29:48.917]                 })
[09:29:48.917]             }))
[09:29:48.917]             future::FutureResult(value = ...future.value$value, 
[09:29:48.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.917]                   ...future.rng), globalenv = if (FALSE) 
[09:29:48.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:48.917]                     ...future.globalenv.names))
[09:29:48.917]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:48.917]         }, condition = base::local({
[09:29:48.917]             c <- base::c
[09:29:48.917]             inherits <- base::inherits
[09:29:48.917]             invokeRestart <- base::invokeRestart
[09:29:48.917]             length <- base::length
[09:29:48.917]             list <- base::list
[09:29:48.917]             seq.int <- base::seq.int
[09:29:48.917]             signalCondition <- base::signalCondition
[09:29:48.917]             sys.calls <- base::sys.calls
[09:29:48.917]             `[[` <- base::`[[`
[09:29:48.917]             `+` <- base::`+`
[09:29:48.917]             `<<-` <- base::`<<-`
[09:29:48.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:48.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:48.917]                   3L)]
[09:29:48.917]             }
[09:29:48.917]             function(cond) {
[09:29:48.917]                 is_error <- inherits(cond, "error")
[09:29:48.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:48.917]                   NULL)
[09:29:48.917]                 if (is_error) {
[09:29:48.917]                   sessionInformation <- function() {
[09:29:48.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:48.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:48.917]                       search = base::search(), system = base::Sys.info())
[09:29:48.917]                   }
[09:29:48.917]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:48.917]                     cond$call), session = sessionInformation(), 
[09:29:48.917]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:48.917]                   signalCondition(cond)
[09:29:48.917]                 }
[09:29:48.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:48.917]                 "immediateCondition"))) {
[09:29:48.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:48.917]                   ...future.conditions[[length(...future.conditions) + 
[09:29:48.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:48.917]                   if (TRUE && !signal) {
[09:29:48.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.917]                     {
[09:29:48.917]                       inherits <- base::inherits
[09:29:48.917]                       invokeRestart <- base::invokeRestart
[09:29:48.917]                       is.null <- base::is.null
[09:29:48.917]                       muffled <- FALSE
[09:29:48.917]                       if (inherits(cond, "message")) {
[09:29:48.917]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.917]                         if (muffled) 
[09:29:48.917]                           invokeRestart("muffleMessage")
[09:29:48.917]                       }
[09:29:48.917]                       else if (inherits(cond, "warning")) {
[09:29:48.917]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.917]                         if (muffled) 
[09:29:48.917]                           invokeRestart("muffleWarning")
[09:29:48.917]                       }
[09:29:48.917]                       else if (inherits(cond, "condition")) {
[09:29:48.917]                         if (!is.null(pattern)) {
[09:29:48.917]                           computeRestarts <- base::computeRestarts
[09:29:48.917]                           grepl <- base::grepl
[09:29:48.917]                           restarts <- computeRestarts(cond)
[09:29:48.917]                           for (restart in restarts) {
[09:29:48.917]                             name <- restart$name
[09:29:48.917]                             if (is.null(name)) 
[09:29:48.917]                               next
[09:29:48.917]                             if (!grepl(pattern, name)) 
[09:29:48.917]                               next
[09:29:48.917]                             invokeRestart(restart)
[09:29:48.917]                             muffled <- TRUE
[09:29:48.917]                             break
[09:29:48.917]                           }
[09:29:48.917]                         }
[09:29:48.917]                       }
[09:29:48.917]                       invisible(muffled)
[09:29:48.917]                     }
[09:29:48.917]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.917]                   }
[09:29:48.917]                 }
[09:29:48.917]                 else {
[09:29:48.917]                   if (TRUE) {
[09:29:48.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:48.917]                     {
[09:29:48.917]                       inherits <- base::inherits
[09:29:48.917]                       invokeRestart <- base::invokeRestart
[09:29:48.917]                       is.null <- base::is.null
[09:29:48.917]                       muffled <- FALSE
[09:29:48.917]                       if (inherits(cond, "message")) {
[09:29:48.917]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:48.917]                         if (muffled) 
[09:29:48.917]                           invokeRestart("muffleMessage")
[09:29:48.917]                       }
[09:29:48.917]                       else if (inherits(cond, "warning")) {
[09:29:48.917]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:48.917]                         if (muffled) 
[09:29:48.917]                           invokeRestart("muffleWarning")
[09:29:48.917]                       }
[09:29:48.917]                       else if (inherits(cond, "condition")) {
[09:29:48.917]                         if (!is.null(pattern)) {
[09:29:48.917]                           computeRestarts <- base::computeRestarts
[09:29:48.917]                           grepl <- base::grepl
[09:29:48.917]                           restarts <- computeRestarts(cond)
[09:29:48.917]                           for (restart in restarts) {
[09:29:48.917]                             name <- restart$name
[09:29:48.917]                             if (is.null(name)) 
[09:29:48.917]                               next
[09:29:48.917]                             if (!grepl(pattern, name)) 
[09:29:48.917]                               next
[09:29:48.917]                             invokeRestart(restart)
[09:29:48.917]                             muffled <- TRUE
[09:29:48.917]                             break
[09:29:48.917]                           }
[09:29:48.917]                         }
[09:29:48.917]                       }
[09:29:48.917]                       invisible(muffled)
[09:29:48.917]                     }
[09:29:48.917]                     muffleCondition(cond, pattern = "^muffle")
[09:29:48.917]                   }
[09:29:48.917]                 }
[09:29:48.917]             }
[09:29:48.917]         }))
[09:29:48.917]     }, error = function(ex) {
[09:29:48.917]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:48.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:48.917]                 ...future.rng), started = ...future.startTime, 
[09:29:48.917]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:48.917]             version = "1.8"), class = "FutureResult")
[09:29:48.917]     }, finally = {
[09:29:48.917]         if (!identical(...future.workdir, getwd())) 
[09:29:48.917]             setwd(...future.workdir)
[09:29:48.917]         {
[09:29:48.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:48.917]                 ...future.oldOptions$nwarnings <- NULL
[09:29:48.917]             }
[09:29:48.917]             base::options(...future.oldOptions)
[09:29:48.917]             if (.Platform$OS.type == "windows") {
[09:29:48.917]                 old_names <- names(...future.oldEnvVars)
[09:29:48.917]                 envs <- base::Sys.getenv()
[09:29:48.917]                 names <- names(envs)
[09:29:48.917]                 common <- intersect(names, old_names)
[09:29:48.917]                 added <- setdiff(names, old_names)
[09:29:48.917]                 removed <- setdiff(old_names, names)
[09:29:48.917]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:48.917]                   envs[common]]
[09:29:48.917]                 NAMES <- toupper(changed)
[09:29:48.917]                 args <- list()
[09:29:48.917]                 for (kk in seq_along(NAMES)) {
[09:29:48.917]                   name <- changed[[kk]]
[09:29:48.917]                   NAME <- NAMES[[kk]]
[09:29:48.917]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.917]                     next
[09:29:48.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.917]                 }
[09:29:48.917]                 NAMES <- toupper(added)
[09:29:48.917]                 for (kk in seq_along(NAMES)) {
[09:29:48.917]                   name <- added[[kk]]
[09:29:48.917]                   NAME <- NAMES[[kk]]
[09:29:48.917]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.917]                     next
[09:29:48.917]                   args[[name]] <- ""
[09:29:48.917]                 }
[09:29:48.917]                 NAMES <- toupper(removed)
[09:29:48.917]                 for (kk in seq_along(NAMES)) {
[09:29:48.917]                   name <- removed[[kk]]
[09:29:48.917]                   NAME <- NAMES[[kk]]
[09:29:48.917]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:48.917]                     next
[09:29:48.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:48.917]                 }
[09:29:48.917]                 if (length(args) > 0) 
[09:29:48.917]                   base::do.call(base::Sys.setenv, args = args)
[09:29:48.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:48.917]             }
[09:29:48.917]             else {
[09:29:48.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:48.917]             }
[09:29:48.917]             {
[09:29:48.917]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:48.917]                   0L) {
[09:29:48.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:48.917]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:48.917]                   base::options(opts)
[09:29:48.917]                 }
[09:29:48.917]                 {
[09:29:48.917]                   {
[09:29:48.917]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:48.917]                     NULL
[09:29:48.917]                   }
[09:29:48.917]                   options(future.plan = NULL)
[09:29:48.917]                   if (is.na(NA_character_)) 
[09:29:48.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:48.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:48.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:48.917]                     .init = FALSE)
[09:29:48.917]                 }
[09:29:48.917]             }
[09:29:48.917]         }
[09:29:48.917]     })
[09:29:48.917]     if (TRUE) {
[09:29:48.917]         base::sink(type = "output", split = FALSE)
[09:29:48.917]         if (TRUE) {
[09:29:48.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:48.917]         }
[09:29:48.917]         else {
[09:29:48.917]             ...future.result["stdout"] <- base::list(NULL)
[09:29:48.917]         }
[09:29:48.917]         base::close(...future.stdout)
[09:29:48.917]         ...future.stdout <- NULL
[09:29:48.917]     }
[09:29:48.917]     ...future.result$conditions <- ...future.conditions
[09:29:48.917]     ...future.result$finished <- base::Sys.time()
[09:29:48.917]     ...future.result
[09:29:48.917] }
[09:29:48.969] MultisessionFuture started
[09:29:48.969] result() for ClusterFuture ...
[09:29:48.970] receiveMessageFromWorker() for ClusterFuture ...
[09:29:48.970] - Validating connection of MultisessionFuture
[09:29:49.001] - received message: FutureResult
[09:29:49.001] - Received FutureResult
[09:29:49.001] - Erased future from FutureRegistry
[09:29:49.001] result() for ClusterFuture ...
[09:29:49.001] - result already collected: FutureResult
[09:29:49.002] result() for ClusterFuture ... done
[09:29:49.002] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:49.002] result() for ClusterFuture ... done
[09:29:49.002] result() for ClusterFuture ...
[09:29:49.002] - result already collected: FutureResult
[09:29:49.002] result() for ClusterFuture ... done
[09:29:49.002] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:29:49.006] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[09:29:49.009] future_lapply() ...
[09:29:49.015] Number of chunks: 2
[09:29:49.015] getGlobalsAndPackagesXApply() ...
[09:29:49.015]  - future.globals: TRUE
[09:29:49.015] getGlobalsAndPackages() ...
[09:29:49.015] Searching for globals...
[09:29:49.019] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:49.019] Searching for globals ... DONE
[09:29:49.019] Resolving globals: FALSE
[09:29:49.020] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[09:29:49.020] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:49.021] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:49.021] - packages: [1] ‘future.apply’
[09:29:49.021] getGlobalsAndPackages() ... DONE
[09:29:49.021]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:49.021]  - needed namespaces: [n=1] ‘future.apply’
[09:29:49.021] Finding globals ... DONE
[09:29:49.021]  - use_args: TRUE
[09:29:49.022]  - Getting '...' globals ...
[09:29:49.022] resolve() on list ...
[09:29:49.022]  recursive: 0
[09:29:49.022]  length: 1
[09:29:49.022]  elements: ‘...’
[09:29:49.022]  length: 0 (resolved future 1)
[09:29:49.023] resolve() on list ... DONE
[09:29:49.023]    - '...' content: [n=0] 
[09:29:49.023] List of 1
[09:29:49.023]  $ ...: list()
[09:29:49.023]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:49.023]  - attr(*, "where")=List of 1
[09:29:49.023]   ..$ ...:<environment: 0x561d37e88f08> 
[09:29:49.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:49.023]  - attr(*, "resolved")= logi TRUE
[09:29:49.023]  - attr(*, "total_size")= num NA
[09:29:49.026]  - Getting '...' globals ... DONE
[09:29:49.026] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:49.026] List of 8
[09:29:49.026]  $ ...future.FUN:function (x, ...)  
[09:29:49.026]  $ x_FUN        :function (x)  
[09:29:49.026]  $ times        : int 1
[09:29:49.026]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:49.026]  $ stop_if_not  :function (...)  
[09:29:49.026]  $ dim          : NULL
[09:29:49.026]  $ valid_types  : chr "character"
[09:29:49.026]  $ ...          : list()
[09:29:49.026]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:49.026]  - attr(*, "where")=List of 8
[09:29:49.026]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:49.026]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:49.026]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:49.026]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:49.026]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:49.026]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:49.026]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:49.026]   ..$ ...          :<environment: 0x561d37e88f08> 
[09:29:49.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:49.026]  - attr(*, "resolved")= logi FALSE
[09:29:49.026]  - attr(*, "total_size")= num 94208
[09:29:49.033] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:49.033] getGlobalsAndPackagesXApply() ... DONE
[09:29:49.033] Number of futures (= number of chunks): 2
[09:29:49.033] Launching 2 futures (chunks) ...
[09:29:49.033] Chunk #1 of 2 ...
[09:29:49.033]  - Finding globals in 'X' for chunk #1 ...
[09:29:49.033] getGlobalsAndPackages() ...
[09:29:49.034] Searching for globals...
[09:29:49.034] 
[09:29:49.034] Searching for globals ... DONE
[09:29:49.034] - globals: [0] <none>
[09:29:49.034] getGlobalsAndPackages() ... DONE
[09:29:49.034]    + additional globals found: [n=0] 
[09:29:49.034]    + additional namespaces needed: [n=0] 
[09:29:49.035]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:49.035]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:49.035]  - seeds: <none>
[09:29:49.035]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.035] getGlobalsAndPackages() ...
[09:29:49.035] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.035] Resolving globals: FALSE
[09:29:49.035] Tweak future expression to call with '...' arguments ...
[09:29:49.036] {
[09:29:49.036]     do.call(function(...) {
[09:29:49.036]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.036]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:49.036]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.036]             on.exit(options(oopts), add = TRUE)
[09:29:49.036]         }
[09:29:49.036]         {
[09:29:49.036]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:49.036]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.036]                 ...future.FUN(...future.X_jj, ...)
[09:29:49.036]             })
[09:29:49.036]         }
[09:29:49.036]     }, args = future.call.arguments)
[09:29:49.036] }
[09:29:49.036] Tweak future expression to call with '...' arguments ... DONE
[09:29:49.036] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.037] - packages: [1] ‘future.apply’
[09:29:49.037] getGlobalsAndPackages() ... DONE
[09:29:49.037] run() for ‘Future’ ...
[09:29:49.037] - state: ‘created’
[09:29:49.037] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:49.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:49.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:49.052]   - Field: ‘node’
[09:29:49.052]   - Field: ‘label’
[09:29:49.052]   - Field: ‘local’
[09:29:49.052]   - Field: ‘owner’
[09:29:49.052]   - Field: ‘envir’
[09:29:49.052]   - Field: ‘workers’
[09:29:49.052]   - Field: ‘packages’
[09:29:49.053]   - Field: ‘gc’
[09:29:49.053]   - Field: ‘conditions’
[09:29:49.053]   - Field: ‘persistent’
[09:29:49.053]   - Field: ‘expr’
[09:29:49.053]   - Field: ‘uuid’
[09:29:49.053]   - Field: ‘seed’
[09:29:49.053]   - Field: ‘version’
[09:29:49.053]   - Field: ‘result’
[09:29:49.053]   - Field: ‘asynchronous’
[09:29:49.054]   - Field: ‘calls’
[09:29:49.054]   - Field: ‘globals’
[09:29:49.054]   - Field: ‘stdout’
[09:29:49.054]   - Field: ‘earlySignal’
[09:29:49.054]   - Field: ‘lazy’
[09:29:49.054]   - Field: ‘state’
[09:29:49.054] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:49.054] - Launch lazy future ...
[09:29:49.055] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:49.055] Packages needed by future strategies (n = 0): <none>
[09:29:49.055] {
[09:29:49.055]     {
[09:29:49.055]         {
[09:29:49.055]             ...future.startTime <- base::Sys.time()
[09:29:49.055]             {
[09:29:49.055]                 {
[09:29:49.055]                   {
[09:29:49.055]                     {
[09:29:49.055]                       {
[09:29:49.055]                         base::local({
[09:29:49.055]                           has_future <- base::requireNamespace("future", 
[09:29:49.055]                             quietly = TRUE)
[09:29:49.055]                           if (has_future) {
[09:29:49.055]                             ns <- base::getNamespace("future")
[09:29:49.055]                             version <- ns[[".package"]][["version"]]
[09:29:49.055]                             if (is.null(version)) 
[09:29:49.055]                               version <- utils::packageVersion("future")
[09:29:49.055]                           }
[09:29:49.055]                           else {
[09:29:49.055]                             version <- NULL
[09:29:49.055]                           }
[09:29:49.055]                           if (!has_future || version < "1.8.0") {
[09:29:49.055]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:49.055]                               "", base::R.version$version.string), 
[09:29:49.055]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:49.055]                                 base::R.version$platform, 8 * 
[09:29:49.055]                                   base::.Machine$sizeof.pointer), 
[09:29:49.055]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:49.055]                                 "release", "version")], collapse = " "), 
[09:29:49.055]                               hostname = base::Sys.info()[["nodename"]])
[09:29:49.055]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:49.055]                               info)
[09:29:49.055]                             info <- base::paste(info, collapse = "; ")
[09:29:49.055]                             if (!has_future) {
[09:29:49.055]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:49.055]                                 info)
[09:29:49.055]                             }
[09:29:49.055]                             else {
[09:29:49.055]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:49.055]                                 info, version)
[09:29:49.055]                             }
[09:29:49.055]                             base::stop(msg)
[09:29:49.055]                           }
[09:29:49.055]                         })
[09:29:49.055]                       }
[09:29:49.055]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:49.055]                       base::options(mc.cores = 1L)
[09:29:49.055]                     }
[09:29:49.055]                     base::local({
[09:29:49.055]                       for (pkg in "future.apply") {
[09:29:49.055]                         base::loadNamespace(pkg)
[09:29:49.055]                         base::library(pkg, character.only = TRUE)
[09:29:49.055]                       }
[09:29:49.055]                     })
[09:29:49.055]                   }
[09:29:49.055]                   ...future.strategy.old <- future::plan("list")
[09:29:49.055]                   options(future.plan = NULL)
[09:29:49.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:49.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:49.055]                 }
[09:29:49.055]                 ...future.workdir <- getwd()
[09:29:49.055]             }
[09:29:49.055]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:49.055]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:49.055]         }
[09:29:49.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:49.055]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:49.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:49.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:49.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:49.055]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:49.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:49.055]             base::names(...future.oldOptions))
[09:29:49.055]     }
[09:29:49.055]     if (FALSE) {
[09:29:49.055]     }
[09:29:49.055]     else {
[09:29:49.055]         if (TRUE) {
[09:29:49.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:49.055]                 open = "w")
[09:29:49.055]         }
[09:29:49.055]         else {
[09:29:49.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:49.055]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:49.055]         }
[09:29:49.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:49.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:49.055]             base::sink(type = "output", split = FALSE)
[09:29:49.055]             base::close(...future.stdout)
[09:29:49.055]         }, add = TRUE)
[09:29:49.055]     }
[09:29:49.055]     ...future.frame <- base::sys.nframe()
[09:29:49.055]     ...future.conditions <- base::list()
[09:29:49.055]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:49.055]     if (FALSE) {
[09:29:49.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:49.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:49.055]     }
[09:29:49.055]     ...future.result <- base::tryCatch({
[09:29:49.055]         base::withCallingHandlers({
[09:29:49.055]             ...future.value <- base::withVisible(base::local({
[09:29:49.055]                 ...future.makeSendCondition <- base::local({
[09:29:49.055]                   sendCondition <- NULL
[09:29:49.055]                   function(frame = 1L) {
[09:29:49.055]                     if (is.function(sendCondition)) 
[09:29:49.055]                       return(sendCondition)
[09:29:49.055]                     ns <- getNamespace("parallel")
[09:29:49.055]                     if (exists("sendData", mode = "function", 
[09:29:49.055]                       envir = ns)) {
[09:29:49.055]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:49.055]                         envir = ns)
[09:29:49.055]                       envir <- sys.frame(frame)
[09:29:49.055]                       master <- NULL
[09:29:49.055]                       while (!identical(envir, .GlobalEnv) && 
[09:29:49.055]                         !identical(envir, emptyenv())) {
[09:29:49.055]                         if (exists("master", mode = "list", envir = envir, 
[09:29:49.055]                           inherits = FALSE)) {
[09:29:49.055]                           master <- get("master", mode = "list", 
[09:29:49.055]                             envir = envir, inherits = FALSE)
[09:29:49.055]                           if (inherits(master, c("SOCKnode", 
[09:29:49.055]                             "SOCK0node"))) {
[09:29:49.055]                             sendCondition <<- function(cond) {
[09:29:49.055]                               data <- list(type = "VALUE", value = cond, 
[09:29:49.055]                                 success = TRUE)
[09:29:49.055]                               parallel_sendData(master, data)
[09:29:49.055]                             }
[09:29:49.055]                             return(sendCondition)
[09:29:49.055]                           }
[09:29:49.055]                         }
[09:29:49.055]                         frame <- frame + 1L
[09:29:49.055]                         envir <- sys.frame(frame)
[09:29:49.055]                       }
[09:29:49.055]                     }
[09:29:49.055]                     sendCondition <<- function(cond) NULL
[09:29:49.055]                   }
[09:29:49.055]                 })
[09:29:49.055]                 withCallingHandlers({
[09:29:49.055]                   {
[09:29:49.055]                     do.call(function(...) {
[09:29:49.055]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.055]                       if (!identical(...future.globals.maxSize.org, 
[09:29:49.055]                         ...future.globals.maxSize)) {
[09:29:49.055]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.055]                         on.exit(options(oopts), add = TRUE)
[09:29:49.055]                       }
[09:29:49.055]                       {
[09:29:49.055]                         lapply(seq_along(...future.elements_ii), 
[09:29:49.055]                           FUN = function(jj) {
[09:29:49.055]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.055]                             ...future.FUN(...future.X_jj, ...)
[09:29:49.055]                           })
[09:29:49.055]                       }
[09:29:49.055]                     }, args = future.call.arguments)
[09:29:49.055]                   }
[09:29:49.055]                 }, immediateCondition = function(cond) {
[09:29:49.055]                   sendCondition <- ...future.makeSendCondition()
[09:29:49.055]                   sendCondition(cond)
[09:29:49.055]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.055]                   {
[09:29:49.055]                     inherits <- base::inherits
[09:29:49.055]                     invokeRestart <- base::invokeRestart
[09:29:49.055]                     is.null <- base::is.null
[09:29:49.055]                     muffled <- FALSE
[09:29:49.055]                     if (inherits(cond, "message")) {
[09:29:49.055]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:49.055]                       if (muffled) 
[09:29:49.055]                         invokeRestart("muffleMessage")
[09:29:49.055]                     }
[09:29:49.055]                     else if (inherits(cond, "warning")) {
[09:29:49.055]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:49.055]                       if (muffled) 
[09:29:49.055]                         invokeRestart("muffleWarning")
[09:29:49.055]                     }
[09:29:49.055]                     else if (inherits(cond, "condition")) {
[09:29:49.055]                       if (!is.null(pattern)) {
[09:29:49.055]                         computeRestarts <- base::computeRestarts
[09:29:49.055]                         grepl <- base::grepl
[09:29:49.055]                         restarts <- computeRestarts(cond)
[09:29:49.055]                         for (restart in restarts) {
[09:29:49.055]                           name <- restart$name
[09:29:49.055]                           if (is.null(name)) 
[09:29:49.055]                             next
[09:29:49.055]                           if (!grepl(pattern, name)) 
[09:29:49.055]                             next
[09:29:49.055]                           invokeRestart(restart)
[09:29:49.055]                           muffled <- TRUE
[09:29:49.055]                           break
[09:29:49.055]                         }
[09:29:49.055]                       }
[09:29:49.055]                     }
[09:29:49.055]                     invisible(muffled)
[09:29:49.055]                   }
[09:29:49.055]                   muffleCondition(cond)
[09:29:49.055]                 })
[09:29:49.055]             }))
[09:29:49.055]             future::FutureResult(value = ...future.value$value, 
[09:29:49.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:49.055]                   ...future.rng), globalenv = if (FALSE) 
[09:29:49.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:49.055]                     ...future.globalenv.names))
[09:29:49.055]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:49.055]         }, condition = base::local({
[09:29:49.055]             c <- base::c
[09:29:49.055]             inherits <- base::inherits
[09:29:49.055]             invokeRestart <- base::invokeRestart
[09:29:49.055]             length <- base::length
[09:29:49.055]             list <- base::list
[09:29:49.055]             seq.int <- base::seq.int
[09:29:49.055]             signalCondition <- base::signalCondition
[09:29:49.055]             sys.calls <- base::sys.calls
[09:29:49.055]             `[[` <- base::`[[`
[09:29:49.055]             `+` <- base::`+`
[09:29:49.055]             `<<-` <- base::`<<-`
[09:29:49.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:49.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:49.055]                   3L)]
[09:29:49.055]             }
[09:29:49.055]             function(cond) {
[09:29:49.055]                 is_error <- inherits(cond, "error")
[09:29:49.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:49.055]                   NULL)
[09:29:49.055]                 if (is_error) {
[09:29:49.055]                   sessionInformation <- function() {
[09:29:49.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:49.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:49.055]                       search = base::search(), system = base::Sys.info())
[09:29:49.055]                   }
[09:29:49.055]                   ...future.conditions[[length(...future.conditions) + 
[09:29:49.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:49.055]                     cond$call), session = sessionInformation(), 
[09:29:49.055]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:49.055]                   signalCondition(cond)
[09:29:49.055]                 }
[09:29:49.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:49.055]                 "immediateCondition"))) {
[09:29:49.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:49.055]                   ...future.conditions[[length(...future.conditions) + 
[09:29:49.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:49.055]                   if (TRUE && !signal) {
[09:29:49.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.055]                     {
[09:29:49.055]                       inherits <- base::inherits
[09:29:49.055]                       invokeRestart <- base::invokeRestart
[09:29:49.055]                       is.null <- base::is.null
[09:29:49.055]                       muffled <- FALSE
[09:29:49.055]                       if (inherits(cond, "message")) {
[09:29:49.055]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:49.055]                         if (muffled) 
[09:29:49.055]                           invokeRestart("muffleMessage")
[09:29:49.055]                       }
[09:29:49.055]                       else if (inherits(cond, "warning")) {
[09:29:49.055]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:49.055]                         if (muffled) 
[09:29:49.055]                           invokeRestart("muffleWarning")
[09:29:49.055]                       }
[09:29:49.055]                       else if (inherits(cond, "condition")) {
[09:29:49.055]                         if (!is.null(pattern)) {
[09:29:49.055]                           computeRestarts <- base::computeRestarts
[09:29:49.055]                           grepl <- base::grepl
[09:29:49.055]                           restarts <- computeRestarts(cond)
[09:29:49.055]                           for (restart in restarts) {
[09:29:49.055]                             name <- restart$name
[09:29:49.055]                             if (is.null(name)) 
[09:29:49.055]                               next
[09:29:49.055]                             if (!grepl(pattern, name)) 
[09:29:49.055]                               next
[09:29:49.055]                             invokeRestart(restart)
[09:29:49.055]                             muffled <- TRUE
[09:29:49.055]                             break
[09:29:49.055]                           }
[09:29:49.055]                         }
[09:29:49.055]                       }
[09:29:49.055]                       invisible(muffled)
[09:29:49.055]                     }
[09:29:49.055]                     muffleCondition(cond, pattern = "^muffle")
[09:29:49.055]                   }
[09:29:49.055]                 }
[09:29:49.055]                 else {
[09:29:49.055]                   if (TRUE) {
[09:29:49.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.055]                     {
[09:29:49.055]                       inherits <- base::inherits
[09:29:49.055]                       invokeRestart <- base::invokeRestart
[09:29:49.055]                       is.null <- base::is.null
[09:29:49.055]                       muffled <- FALSE
[09:29:49.055]                       if (inherits(cond, "message")) {
[09:29:49.055]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:49.055]                         if (muffled) 
[09:29:49.055]                           invokeRestart("muffleMessage")
[09:29:49.055]                       }
[09:29:49.055]                       else if (inherits(cond, "warning")) {
[09:29:49.055]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:49.055]                         if (muffled) 
[09:29:49.055]                           invokeRestart("muffleWarning")
[09:29:49.055]                       }
[09:29:49.055]                       else if (inherits(cond, "condition")) {
[09:29:49.055]                         if (!is.null(pattern)) {
[09:29:49.055]                           computeRestarts <- base::computeRestarts
[09:29:49.055]                           grepl <- base::grepl
[09:29:49.055]                           restarts <- computeRestarts(cond)
[09:29:49.055]                           for (restart in restarts) {
[09:29:49.055]                             name <- restart$name
[09:29:49.055]                             if (is.null(name)) 
[09:29:49.055]                               next
[09:29:49.055]                             if (!grepl(pattern, name)) 
[09:29:49.055]                               next
[09:29:49.055]                             invokeRestart(restart)
[09:29:49.055]                             muffled <- TRUE
[09:29:49.055]                             break
[09:29:49.055]                           }
[09:29:49.055]                         }
[09:29:49.055]                       }
[09:29:49.055]                       invisible(muffled)
[09:29:49.055]                     }
[09:29:49.055]                     muffleCondition(cond, pattern = "^muffle")
[09:29:49.055]                   }
[09:29:49.055]                 }
[09:29:49.055]             }
[09:29:49.055]         }))
[09:29:49.055]     }, error = function(ex) {
[09:29:49.055]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:49.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:49.055]                 ...future.rng), started = ...future.startTime, 
[09:29:49.055]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:49.055]             version = "1.8"), class = "FutureResult")
[09:29:49.055]     }, finally = {
[09:29:49.055]         if (!identical(...future.workdir, getwd())) 
[09:29:49.055]             setwd(...future.workdir)
[09:29:49.055]         {
[09:29:49.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:49.055]                 ...future.oldOptions$nwarnings <- NULL
[09:29:49.055]             }
[09:29:49.055]             base::options(...future.oldOptions)
[09:29:49.055]             if (.Platform$OS.type == "windows") {
[09:29:49.055]                 old_names <- names(...future.oldEnvVars)
[09:29:49.055]                 envs <- base::Sys.getenv()
[09:29:49.055]                 names <- names(envs)
[09:29:49.055]                 common <- intersect(names, old_names)
[09:29:49.055]                 added <- setdiff(names, old_names)
[09:29:49.055]                 removed <- setdiff(old_names, names)
[09:29:49.055]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:49.055]                   envs[common]]
[09:29:49.055]                 NAMES <- toupper(changed)
[09:29:49.055]                 args <- list()
[09:29:49.055]                 for (kk in seq_along(NAMES)) {
[09:29:49.055]                   name <- changed[[kk]]
[09:29:49.055]                   NAME <- NAMES[[kk]]
[09:29:49.055]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.055]                     next
[09:29:49.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:49.055]                 }
[09:29:49.055]                 NAMES <- toupper(added)
[09:29:49.055]                 for (kk in seq_along(NAMES)) {
[09:29:49.055]                   name <- added[[kk]]
[09:29:49.055]                   NAME <- NAMES[[kk]]
[09:29:49.055]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.055]                     next
[09:29:49.055]                   args[[name]] <- ""
[09:29:49.055]                 }
[09:29:49.055]                 NAMES <- toupper(removed)
[09:29:49.055]                 for (kk in seq_along(NAMES)) {
[09:29:49.055]                   name <- removed[[kk]]
[09:29:49.055]                   NAME <- NAMES[[kk]]
[09:29:49.055]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.055]                     next
[09:29:49.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:49.055]                 }
[09:29:49.055]                 if (length(args) > 0) 
[09:29:49.055]                   base::do.call(base::Sys.setenv, args = args)
[09:29:49.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:49.055]             }
[09:29:49.055]             else {
[09:29:49.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:49.055]             }
[09:29:49.055]             {
[09:29:49.055]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:49.055]                   0L) {
[09:29:49.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:49.055]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:49.055]                   base::options(opts)
[09:29:49.055]                 }
[09:29:49.055]                 {
[09:29:49.055]                   {
[09:29:49.055]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:49.055]                     NULL
[09:29:49.055]                   }
[09:29:49.055]                   options(future.plan = NULL)
[09:29:49.055]                   if (is.na(NA_character_)) 
[09:29:49.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:49.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:49.055]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:49.055]                     .init = FALSE)
[09:29:49.055]                 }
[09:29:49.055]             }
[09:29:49.055]         }
[09:29:49.055]     })
[09:29:49.055]     if (TRUE) {
[09:29:49.055]         base::sink(type = "output", split = FALSE)
[09:29:49.055]         if (TRUE) {
[09:29:49.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:49.055]         }
[09:29:49.055]         else {
[09:29:49.055]             ...future.result["stdout"] <- base::list(NULL)
[09:29:49.055]         }
[09:29:49.055]         base::close(...future.stdout)
[09:29:49.055]         ...future.stdout <- NULL
[09:29:49.055]     }
[09:29:49.055]     ...future.result$conditions <- ...future.conditions
[09:29:49.055]     ...future.result$finished <- base::Sys.time()
[09:29:49.055]     ...future.result
[09:29:49.055] }
[09:29:49.058] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[09:29:49.059] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:49.100] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:49.100] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[09:29:49.101] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[09:29:49.101] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:49.101] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:49.101] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:49.144] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:49.144] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:49.188] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:49.188] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:49.189] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:49.189] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[09:29:49.189] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[09:29:49.190] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:49.190] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:49.190] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[09:29:49.191] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[09:29:49.191] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:49.191] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:49.191] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:49.192] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:49.192] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[09:29:49.192] MultisessionFuture started
[09:29:49.193] - Launch lazy future ... done
[09:29:49.193] run() for ‘MultisessionFuture’ ... done
[09:29:49.193] Created future:
[09:29:49.193] MultisessionFuture:
[09:29:49.193] Label: ‘future_vapply-1’
[09:29:49.193] Expression:
[09:29:49.193] {
[09:29:49.193]     do.call(function(...) {
[09:29:49.193]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.193]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:49.193]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.193]             on.exit(options(oopts), add = TRUE)
[09:29:49.193]         }
[09:29:49.193]         {
[09:29:49.193]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:49.193]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.193]                 ...future.FUN(...future.X_jj, ...)
[09:29:49.193]             })
[09:29:49.193]         }
[09:29:49.193]     }, args = future.call.arguments)
[09:29:49.193] }
[09:29:49.193] Lazy evaluation: FALSE
[09:29:49.193] Asynchronous evaluation: TRUE
[09:29:49.193] Local evaluation: TRUE
[09:29:49.193] Environment: R_GlobalEnv
[09:29:49.193] Capture standard output: TRUE
[09:29:49.193] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:49.193] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:49.193] Packages: 1 packages (‘future.apply’)
[09:29:49.193] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:49.193] Resolved: FALSE
[09:29:49.193] Value: <not collected>
[09:29:49.193] Conditions captured: <none>
[09:29:49.193] Early signaling: FALSE
[09:29:49.193] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:49.193] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:49.205] Chunk #1 of 2 ... DONE
[09:29:49.205] Chunk #2 of 2 ...
[09:29:49.206]  - Finding globals in 'X' for chunk #2 ...
[09:29:49.206] getGlobalsAndPackages() ...
[09:29:49.206] Searching for globals...
[09:29:49.206] 
[09:29:49.206] Searching for globals ... DONE
[09:29:49.206] - globals: [0] <none>
[09:29:49.207] getGlobalsAndPackages() ... DONE
[09:29:49.207]    + additional globals found: [n=0] 
[09:29:49.207]    + additional namespaces needed: [n=0] 
[09:29:49.207]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:49.207]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:49.207]  - seeds: <none>
[09:29:49.207]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.207] getGlobalsAndPackages() ...
[09:29:49.207] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.208] Resolving globals: FALSE
[09:29:49.208] Tweak future expression to call with '...' arguments ...
[09:29:49.208] {
[09:29:49.208]     do.call(function(...) {
[09:29:49.208]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.208]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:49.208]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.208]             on.exit(options(oopts), add = TRUE)
[09:29:49.208]         }
[09:29:49.208]         {
[09:29:49.208]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:49.208]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.208]                 ...future.FUN(...future.X_jj, ...)
[09:29:49.208]             })
[09:29:49.208]         }
[09:29:49.208]     }, args = future.call.arguments)
[09:29:49.208] }
[09:29:49.208] Tweak future expression to call with '...' arguments ... DONE
[09:29:49.209] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.209] - packages: [1] ‘future.apply’
[09:29:49.209] getGlobalsAndPackages() ... DONE
[09:29:49.209] run() for ‘Future’ ...
[09:29:49.209] - state: ‘created’
[09:29:49.210] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:49.224] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:49.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:49.225]   - Field: ‘node’
[09:29:49.225]   - Field: ‘label’
[09:29:49.225]   - Field: ‘local’
[09:29:49.225]   - Field: ‘owner’
[09:29:49.225]   - Field: ‘envir’
[09:29:49.225]   - Field: ‘workers’
[09:29:49.225]   - Field: ‘packages’
[09:29:49.225]   - Field: ‘gc’
[09:29:49.226]   - Field: ‘conditions’
[09:29:49.226]   - Field: ‘persistent’
[09:29:49.226]   - Field: ‘expr’
[09:29:49.226]   - Field: ‘uuid’
[09:29:49.226]   - Field: ‘seed’
[09:29:49.226]   - Field: ‘version’
[09:29:49.226]   - Field: ‘result’
[09:29:49.226]   - Field: ‘asynchronous’
[09:29:49.226]   - Field: ‘calls’
[09:29:49.227]   - Field: ‘globals’
[09:29:49.227]   - Field: ‘stdout’
[09:29:49.227]   - Field: ‘earlySignal’
[09:29:49.227]   - Field: ‘lazy’
[09:29:49.227]   - Field: ‘state’
[09:29:49.227] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:49.227] - Launch lazy future ...
[09:29:49.228] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:49.228] Packages needed by future strategies (n = 0): <none>
[09:29:49.228] {
[09:29:49.228]     {
[09:29:49.228]         {
[09:29:49.228]             ...future.startTime <- base::Sys.time()
[09:29:49.228]             {
[09:29:49.228]                 {
[09:29:49.228]                   {
[09:29:49.228]                     {
[09:29:49.228]                       {
[09:29:49.228]                         base::local({
[09:29:49.228]                           has_future <- base::requireNamespace("future", 
[09:29:49.228]                             quietly = TRUE)
[09:29:49.228]                           if (has_future) {
[09:29:49.228]                             ns <- base::getNamespace("future")
[09:29:49.228]                             version <- ns[[".package"]][["version"]]
[09:29:49.228]                             if (is.null(version)) 
[09:29:49.228]                               version <- utils::packageVersion("future")
[09:29:49.228]                           }
[09:29:49.228]                           else {
[09:29:49.228]                             version <- NULL
[09:29:49.228]                           }
[09:29:49.228]                           if (!has_future || version < "1.8.0") {
[09:29:49.228]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:49.228]                               "", base::R.version$version.string), 
[09:29:49.228]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:49.228]                                 base::R.version$platform, 8 * 
[09:29:49.228]                                   base::.Machine$sizeof.pointer), 
[09:29:49.228]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:49.228]                                 "release", "version")], collapse = " "), 
[09:29:49.228]                               hostname = base::Sys.info()[["nodename"]])
[09:29:49.228]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:49.228]                               info)
[09:29:49.228]                             info <- base::paste(info, collapse = "; ")
[09:29:49.228]                             if (!has_future) {
[09:29:49.228]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:49.228]                                 info)
[09:29:49.228]                             }
[09:29:49.228]                             else {
[09:29:49.228]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:49.228]                                 info, version)
[09:29:49.228]                             }
[09:29:49.228]                             base::stop(msg)
[09:29:49.228]                           }
[09:29:49.228]                         })
[09:29:49.228]                       }
[09:29:49.228]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:49.228]                       base::options(mc.cores = 1L)
[09:29:49.228]                     }
[09:29:49.228]                     base::local({
[09:29:49.228]                       for (pkg in "future.apply") {
[09:29:49.228]                         base::loadNamespace(pkg)
[09:29:49.228]                         base::library(pkg, character.only = TRUE)
[09:29:49.228]                       }
[09:29:49.228]                     })
[09:29:49.228]                   }
[09:29:49.228]                   ...future.strategy.old <- future::plan("list")
[09:29:49.228]                   options(future.plan = NULL)
[09:29:49.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:49.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:49.228]                 }
[09:29:49.228]                 ...future.workdir <- getwd()
[09:29:49.228]             }
[09:29:49.228]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:49.228]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:49.228]         }
[09:29:49.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:49.228]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:49.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:49.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:49.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:49.228]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:49.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:49.228]             base::names(...future.oldOptions))
[09:29:49.228]     }
[09:29:49.228]     if (FALSE) {
[09:29:49.228]     }
[09:29:49.228]     else {
[09:29:49.228]         if (TRUE) {
[09:29:49.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:49.228]                 open = "w")
[09:29:49.228]         }
[09:29:49.228]         else {
[09:29:49.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:49.228]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:49.228]         }
[09:29:49.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:49.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:49.228]             base::sink(type = "output", split = FALSE)
[09:29:49.228]             base::close(...future.stdout)
[09:29:49.228]         }, add = TRUE)
[09:29:49.228]     }
[09:29:49.228]     ...future.frame <- base::sys.nframe()
[09:29:49.228]     ...future.conditions <- base::list()
[09:29:49.228]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:49.228]     if (FALSE) {
[09:29:49.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:49.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:49.228]     }
[09:29:49.228]     ...future.result <- base::tryCatch({
[09:29:49.228]         base::withCallingHandlers({
[09:29:49.228]             ...future.value <- base::withVisible(base::local({
[09:29:49.228]                 ...future.makeSendCondition <- base::local({
[09:29:49.228]                   sendCondition <- NULL
[09:29:49.228]                   function(frame = 1L) {
[09:29:49.228]                     if (is.function(sendCondition)) 
[09:29:49.228]                       return(sendCondition)
[09:29:49.228]                     ns <- getNamespace("parallel")
[09:29:49.228]                     if (exists("sendData", mode = "function", 
[09:29:49.228]                       envir = ns)) {
[09:29:49.228]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:49.228]                         envir = ns)
[09:29:49.228]                       envir <- sys.frame(frame)
[09:29:49.228]                       master <- NULL
[09:29:49.228]                       while (!identical(envir, .GlobalEnv) && 
[09:29:49.228]                         !identical(envir, emptyenv())) {
[09:29:49.228]                         if (exists("master", mode = "list", envir = envir, 
[09:29:49.228]                           inherits = FALSE)) {
[09:29:49.228]                           master <- get("master", mode = "list", 
[09:29:49.228]                             envir = envir, inherits = FALSE)
[09:29:49.228]                           if (inherits(master, c("SOCKnode", 
[09:29:49.228]                             "SOCK0node"))) {
[09:29:49.228]                             sendCondition <<- function(cond) {
[09:29:49.228]                               data <- list(type = "VALUE", value = cond, 
[09:29:49.228]                                 success = TRUE)
[09:29:49.228]                               parallel_sendData(master, data)
[09:29:49.228]                             }
[09:29:49.228]                             return(sendCondition)
[09:29:49.228]                           }
[09:29:49.228]                         }
[09:29:49.228]                         frame <- frame + 1L
[09:29:49.228]                         envir <- sys.frame(frame)
[09:29:49.228]                       }
[09:29:49.228]                     }
[09:29:49.228]                     sendCondition <<- function(cond) NULL
[09:29:49.228]                   }
[09:29:49.228]                 })
[09:29:49.228]                 withCallingHandlers({
[09:29:49.228]                   {
[09:29:49.228]                     do.call(function(...) {
[09:29:49.228]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.228]                       if (!identical(...future.globals.maxSize.org, 
[09:29:49.228]                         ...future.globals.maxSize)) {
[09:29:49.228]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.228]                         on.exit(options(oopts), add = TRUE)
[09:29:49.228]                       }
[09:29:49.228]                       {
[09:29:49.228]                         lapply(seq_along(...future.elements_ii), 
[09:29:49.228]                           FUN = function(jj) {
[09:29:49.228]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.228]                             ...future.FUN(...future.X_jj, ...)
[09:29:49.228]                           })
[09:29:49.228]                       }
[09:29:49.228]                     }, args = future.call.arguments)
[09:29:49.228]                   }
[09:29:49.228]                 }, immediateCondition = function(cond) {
[09:29:49.228]                   sendCondition <- ...future.makeSendCondition()
[09:29:49.228]                   sendCondition(cond)
[09:29:49.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.228]                   {
[09:29:49.228]                     inherits <- base::inherits
[09:29:49.228]                     invokeRestart <- base::invokeRestart
[09:29:49.228]                     is.null <- base::is.null
[09:29:49.228]                     muffled <- FALSE
[09:29:49.228]                     if (inherits(cond, "message")) {
[09:29:49.228]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:49.228]                       if (muffled) 
[09:29:49.228]                         invokeRestart("muffleMessage")
[09:29:49.228]                     }
[09:29:49.228]                     else if (inherits(cond, "warning")) {
[09:29:49.228]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:49.228]                       if (muffled) 
[09:29:49.228]                         invokeRestart("muffleWarning")
[09:29:49.228]                     }
[09:29:49.228]                     else if (inherits(cond, "condition")) {
[09:29:49.228]                       if (!is.null(pattern)) {
[09:29:49.228]                         computeRestarts <- base::computeRestarts
[09:29:49.228]                         grepl <- base::grepl
[09:29:49.228]                         restarts <- computeRestarts(cond)
[09:29:49.228]                         for (restart in restarts) {
[09:29:49.228]                           name <- restart$name
[09:29:49.228]                           if (is.null(name)) 
[09:29:49.228]                             next
[09:29:49.228]                           if (!grepl(pattern, name)) 
[09:29:49.228]                             next
[09:29:49.228]                           invokeRestart(restart)
[09:29:49.228]                           muffled <- TRUE
[09:29:49.228]                           break
[09:29:49.228]                         }
[09:29:49.228]                       }
[09:29:49.228]                     }
[09:29:49.228]                     invisible(muffled)
[09:29:49.228]                   }
[09:29:49.228]                   muffleCondition(cond)
[09:29:49.228]                 })
[09:29:49.228]             }))
[09:29:49.228]             future::FutureResult(value = ...future.value$value, 
[09:29:49.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:49.228]                   ...future.rng), globalenv = if (FALSE) 
[09:29:49.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:49.228]                     ...future.globalenv.names))
[09:29:49.228]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:49.228]         }, condition = base::local({
[09:29:49.228]             c <- base::c
[09:29:49.228]             inherits <- base::inherits
[09:29:49.228]             invokeRestart <- base::invokeRestart
[09:29:49.228]             length <- base::length
[09:29:49.228]             list <- base::list
[09:29:49.228]             seq.int <- base::seq.int
[09:29:49.228]             signalCondition <- base::signalCondition
[09:29:49.228]             sys.calls <- base::sys.calls
[09:29:49.228]             `[[` <- base::`[[`
[09:29:49.228]             `+` <- base::`+`
[09:29:49.228]             `<<-` <- base::`<<-`
[09:29:49.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:49.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:49.228]                   3L)]
[09:29:49.228]             }
[09:29:49.228]             function(cond) {
[09:29:49.228]                 is_error <- inherits(cond, "error")
[09:29:49.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:49.228]                   NULL)
[09:29:49.228]                 if (is_error) {
[09:29:49.228]                   sessionInformation <- function() {
[09:29:49.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:49.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:49.228]                       search = base::search(), system = base::Sys.info())
[09:29:49.228]                   }
[09:29:49.228]                   ...future.conditions[[length(...future.conditions) + 
[09:29:49.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:49.228]                     cond$call), session = sessionInformation(), 
[09:29:49.228]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:49.228]                   signalCondition(cond)
[09:29:49.228]                 }
[09:29:49.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:49.228]                 "immediateCondition"))) {
[09:29:49.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:49.228]                   ...future.conditions[[length(...future.conditions) + 
[09:29:49.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:49.228]                   if (TRUE && !signal) {
[09:29:49.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.228]                     {
[09:29:49.228]                       inherits <- base::inherits
[09:29:49.228]                       invokeRestart <- base::invokeRestart
[09:29:49.228]                       is.null <- base::is.null
[09:29:49.228]                       muffled <- FALSE
[09:29:49.228]                       if (inherits(cond, "message")) {
[09:29:49.228]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:49.228]                         if (muffled) 
[09:29:49.228]                           invokeRestart("muffleMessage")
[09:29:49.228]                       }
[09:29:49.228]                       else if (inherits(cond, "warning")) {
[09:29:49.228]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:49.228]                         if (muffled) 
[09:29:49.228]                           invokeRestart("muffleWarning")
[09:29:49.228]                       }
[09:29:49.228]                       else if (inherits(cond, "condition")) {
[09:29:49.228]                         if (!is.null(pattern)) {
[09:29:49.228]                           computeRestarts <- base::computeRestarts
[09:29:49.228]                           grepl <- base::grepl
[09:29:49.228]                           restarts <- computeRestarts(cond)
[09:29:49.228]                           for (restart in restarts) {
[09:29:49.228]                             name <- restart$name
[09:29:49.228]                             if (is.null(name)) 
[09:29:49.228]                               next
[09:29:49.228]                             if (!grepl(pattern, name)) 
[09:29:49.228]                               next
[09:29:49.228]                             invokeRestart(restart)
[09:29:49.228]                             muffled <- TRUE
[09:29:49.228]                             break
[09:29:49.228]                           }
[09:29:49.228]                         }
[09:29:49.228]                       }
[09:29:49.228]                       invisible(muffled)
[09:29:49.228]                     }
[09:29:49.228]                     muffleCondition(cond, pattern = "^muffle")
[09:29:49.228]                   }
[09:29:49.228]                 }
[09:29:49.228]                 else {
[09:29:49.228]                   if (TRUE) {
[09:29:49.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.228]                     {
[09:29:49.228]                       inherits <- base::inherits
[09:29:49.228]                       invokeRestart <- base::invokeRestart
[09:29:49.228]                       is.null <- base::is.null
[09:29:49.228]                       muffled <- FALSE
[09:29:49.228]                       if (inherits(cond, "message")) {
[09:29:49.228]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:49.228]                         if (muffled) 
[09:29:49.228]                           invokeRestart("muffleMessage")
[09:29:49.228]                       }
[09:29:49.228]                       else if (inherits(cond, "warning")) {
[09:29:49.228]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:49.228]                         if (muffled) 
[09:29:49.228]                           invokeRestart("muffleWarning")
[09:29:49.228]                       }
[09:29:49.228]                       else if (inherits(cond, "condition")) {
[09:29:49.228]                         if (!is.null(pattern)) {
[09:29:49.228]                           computeRestarts <- base::computeRestarts
[09:29:49.228]                           grepl <- base::grepl
[09:29:49.228]                           restarts <- computeRestarts(cond)
[09:29:49.228]                           for (restart in restarts) {
[09:29:49.228]                             name <- restart$name
[09:29:49.228]                             if (is.null(name)) 
[09:29:49.228]                               next
[09:29:49.228]                             if (!grepl(pattern, name)) 
[09:29:49.228]                               next
[09:29:49.228]                             invokeRestart(restart)
[09:29:49.228]                             muffled <- TRUE
[09:29:49.228]                             break
[09:29:49.228]                           }
[09:29:49.228]                         }
[09:29:49.228]                       }
[09:29:49.228]                       invisible(muffled)
[09:29:49.228]                     }
[09:29:49.228]                     muffleCondition(cond, pattern = "^muffle")
[09:29:49.228]                   }
[09:29:49.228]                 }
[09:29:49.228]             }
[09:29:49.228]         }))
[09:29:49.228]     }, error = function(ex) {
[09:29:49.228]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:49.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:49.228]                 ...future.rng), started = ...future.startTime, 
[09:29:49.228]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:49.228]             version = "1.8"), class = "FutureResult")
[09:29:49.228]     }, finally = {
[09:29:49.228]         if (!identical(...future.workdir, getwd())) 
[09:29:49.228]             setwd(...future.workdir)
[09:29:49.228]         {
[09:29:49.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:49.228]                 ...future.oldOptions$nwarnings <- NULL
[09:29:49.228]             }
[09:29:49.228]             base::options(...future.oldOptions)
[09:29:49.228]             if (.Platform$OS.type == "windows") {
[09:29:49.228]                 old_names <- names(...future.oldEnvVars)
[09:29:49.228]                 envs <- base::Sys.getenv()
[09:29:49.228]                 names <- names(envs)
[09:29:49.228]                 common <- intersect(names, old_names)
[09:29:49.228]                 added <- setdiff(names, old_names)
[09:29:49.228]                 removed <- setdiff(old_names, names)
[09:29:49.228]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:49.228]                   envs[common]]
[09:29:49.228]                 NAMES <- toupper(changed)
[09:29:49.228]                 args <- list()
[09:29:49.228]                 for (kk in seq_along(NAMES)) {
[09:29:49.228]                   name <- changed[[kk]]
[09:29:49.228]                   NAME <- NAMES[[kk]]
[09:29:49.228]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.228]                     next
[09:29:49.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:49.228]                 }
[09:29:49.228]                 NAMES <- toupper(added)
[09:29:49.228]                 for (kk in seq_along(NAMES)) {
[09:29:49.228]                   name <- added[[kk]]
[09:29:49.228]                   NAME <- NAMES[[kk]]
[09:29:49.228]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.228]                     next
[09:29:49.228]                   args[[name]] <- ""
[09:29:49.228]                 }
[09:29:49.228]                 NAMES <- toupper(removed)
[09:29:49.228]                 for (kk in seq_along(NAMES)) {
[09:29:49.228]                   name <- removed[[kk]]
[09:29:49.228]                   NAME <- NAMES[[kk]]
[09:29:49.228]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.228]                     next
[09:29:49.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:49.228]                 }
[09:29:49.228]                 if (length(args) > 0) 
[09:29:49.228]                   base::do.call(base::Sys.setenv, args = args)
[09:29:49.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:49.228]             }
[09:29:49.228]             else {
[09:29:49.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:49.228]             }
[09:29:49.228]             {
[09:29:49.228]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:49.228]                   0L) {
[09:29:49.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:49.228]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:49.228]                   base::options(opts)
[09:29:49.228]                 }
[09:29:49.228]                 {
[09:29:49.228]                   {
[09:29:49.228]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:49.228]                     NULL
[09:29:49.228]                   }
[09:29:49.228]                   options(future.plan = NULL)
[09:29:49.228]                   if (is.na(NA_character_)) 
[09:29:49.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:49.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:49.228]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:49.228]                     .init = FALSE)
[09:29:49.228]                 }
[09:29:49.228]             }
[09:29:49.228]         }
[09:29:49.228]     })
[09:29:49.228]     if (TRUE) {
[09:29:49.228]         base::sink(type = "output", split = FALSE)
[09:29:49.228]         if (TRUE) {
[09:29:49.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:49.228]         }
[09:29:49.228]         else {
[09:29:49.228]             ...future.result["stdout"] <- base::list(NULL)
[09:29:49.228]         }
[09:29:49.228]         base::close(...future.stdout)
[09:29:49.228]         ...future.stdout <- NULL
[09:29:49.228]     }
[09:29:49.228]     ...future.result$conditions <- ...future.conditions
[09:29:49.228]     ...future.result$finished <- base::Sys.time()
[09:29:49.228]     ...future.result
[09:29:49.228] }
[09:29:49.283] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[09:29:49.283] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[09:29:49.287] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[09:29:49.287] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[09:29:49.288] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[09:29:49.288] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[09:29:49.288] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[09:29:49.289] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[09:29:49.332] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[09:29:49.332] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[09:29:49.376] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[09:29:49.376] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[09:29:49.377] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[09:29:49.377] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[09:29:49.377] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[09:29:49.377] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:29:49.378] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:29:49.378] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[09:29:49.378] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[09:29:49.379] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:49.379] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:49.379] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:49.380] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:49.380] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[09:29:49.380] MultisessionFuture started
[09:29:49.381] - Launch lazy future ... done
[09:29:49.381] run() for ‘MultisessionFuture’ ... done
[09:29:49.383] Created future:
[09:29:49.383] MultisessionFuture:
[09:29:49.383] Label: ‘future_vapply-2’
[09:29:49.383] Expression:
[09:29:49.383] {
[09:29:49.383]     do.call(function(...) {
[09:29:49.383]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.383]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:49.383]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.383]             on.exit(options(oopts), add = TRUE)
[09:29:49.383]         }
[09:29:49.383]         {
[09:29:49.383]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:49.383]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.383]                 ...future.FUN(...future.X_jj, ...)
[09:29:49.383]             })
[09:29:49.383]         }
[09:29:49.383]     }, args = future.call.arguments)
[09:29:49.383] }
[09:29:49.383] Lazy evaluation: FALSE
[09:29:49.383] Asynchronous evaluation: TRUE
[09:29:49.383] Local evaluation: TRUE
[09:29:49.383] Environment: R_GlobalEnv
[09:29:49.383] Capture standard output: TRUE
[09:29:49.383] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:49.383] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:49.383] Packages: 1 packages (‘future.apply’)
[09:29:49.383] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:49.383] Resolved: FALSE
[09:29:49.383] Value: <not collected>
[09:29:49.383] Conditions captured: <none>
[09:29:49.383] Early signaling: FALSE
[09:29:49.383] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:49.383] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:49.395] Chunk #2 of 2 ... DONE
[09:29:49.395] Launching 2 futures (chunks) ... DONE
[09:29:49.395] Resolving 2 futures (chunks) ...
[09:29:49.395] resolve() on list ...
[09:29:49.395]  recursive: 0
[09:29:49.395]  length: 2
[09:29:49.396] 
[09:29:49.396] receiveMessageFromWorker() for ClusterFuture ...
[09:29:49.396] - Validating connection of MultisessionFuture
[09:29:49.396] - received message: FutureResult
[09:29:49.396] - Received FutureResult
[09:29:49.396] - Erased future from FutureRegistry
[09:29:49.397] result() for ClusterFuture ...
[09:29:49.397] - result already collected: FutureResult
[09:29:49.397] result() for ClusterFuture ... done
[09:29:49.397] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:49.397] Future #1
[09:29:49.397] result() for ClusterFuture ...
[09:29:49.397] - result already collected: FutureResult
[09:29:49.397] result() for ClusterFuture ... done
[09:29:49.397] result() for ClusterFuture ...
[09:29:49.397] - result already collected: FutureResult
[09:29:49.397] result() for ClusterFuture ... done
[09:29:49.397] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:49.398] - nx: 2
[09:29:49.398] - relay: TRUE
[09:29:49.398] - stdout: TRUE
[09:29:49.398] - signal: TRUE
[09:29:49.398] - resignal: FALSE
[09:29:49.398] - force: TRUE
[09:29:49.398] - relayed: [n=2] FALSE, FALSE
[09:29:49.398] - queued futures: [n=2] FALSE, FALSE
[09:29:49.398]  - until=1
[09:29:49.398]  - relaying element #1
[09:29:49.398] result() for ClusterFuture ...
[09:29:49.398] - result already collected: FutureResult
[09:29:49.399] result() for ClusterFuture ... done
[09:29:49.399] result() for ClusterFuture ...
[09:29:49.399] - result already collected: FutureResult
[09:29:49.399] result() for ClusterFuture ... done
[09:29:49.399] result() for ClusterFuture ...
[09:29:49.399] - result already collected: FutureResult
[09:29:49.399] result() for ClusterFuture ... done
[09:29:49.399] result() for ClusterFuture ...
[09:29:49.399] - result already collected: FutureResult
[09:29:49.399] result() for ClusterFuture ... done
[09:29:49.399] - relayed: [n=2] TRUE, FALSE
[09:29:49.399] - queued futures: [n=2] TRUE, FALSE
[09:29:49.400] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:49.400]  length: 1 (resolved future 1)
[09:29:49.465] receiveMessageFromWorker() for ClusterFuture ...
[09:29:49.465] - Validating connection of MultisessionFuture
[09:29:49.465] - received message: FutureResult
[09:29:49.466] - Received FutureResult
[09:29:49.466] - Erased future from FutureRegistry
[09:29:49.466] result() for ClusterFuture ...
[09:29:49.466] - result already collected: FutureResult
[09:29:49.466] result() for ClusterFuture ... done
[09:29:49.466] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:49.466] Future #2
[09:29:49.466] result() for ClusterFuture ...
[09:29:49.466] - result already collected: FutureResult
[09:29:49.466] result() for ClusterFuture ... done
[09:29:49.466] result() for ClusterFuture ...
[09:29:49.467] - result already collected: FutureResult
[09:29:49.467] result() for ClusterFuture ... done
[09:29:49.467] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:49.467] - nx: 2
[09:29:49.467] - relay: TRUE
[09:29:49.467] - stdout: TRUE
[09:29:49.467] - signal: TRUE
[09:29:49.467] - resignal: FALSE
[09:29:49.467] - force: TRUE
[09:29:49.467] - relayed: [n=2] TRUE, FALSE
[09:29:49.467] - queued futures: [n=2] TRUE, FALSE
[09:29:49.467]  - until=2
[09:29:49.468]  - relaying element #2
[09:29:49.468] result() for ClusterFuture ...
[09:29:49.468] - result already collected: FutureResult
[09:29:49.468] result() for ClusterFuture ... done
[09:29:49.468] result() for ClusterFuture ...
[09:29:49.468] - result already collected: FutureResult
[09:29:49.468] result() for ClusterFuture ... done
[09:29:49.468] result() for ClusterFuture ...
[09:29:49.468] - result already collected: FutureResult
[09:29:49.468] result() for ClusterFuture ... done
[09:29:49.468] result() for ClusterFuture ...
[09:29:49.469] - result already collected: FutureResult
[09:29:49.469] result() for ClusterFuture ... done
[09:29:49.469] - relayed: [n=2] TRUE, TRUE
[09:29:49.469] - queued futures: [n=2] TRUE, TRUE
[09:29:49.469] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:49.469]  length: 0 (resolved future 2)
[09:29:49.469] Relaying remaining futures
[09:29:49.469] signalConditionsASAP(NULL, pos=0) ...
[09:29:49.469] - nx: 2
[09:29:49.469] - relay: TRUE
[09:29:49.469] - stdout: TRUE
[09:29:49.469] - signal: TRUE
[09:29:49.470] - resignal: FALSE
[09:29:49.470] - force: TRUE
[09:29:49.470] - relayed: [n=2] TRUE, TRUE
[09:29:49.470] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:49.470] - relayed: [n=2] TRUE, TRUE
[09:29:49.470] - queued futures: [n=2] TRUE, TRUE
[09:29:49.470] signalConditionsASAP(NULL, pos=0) ... done
[09:29:49.470] resolve() on list ... DONE
[09:29:49.470] result() for ClusterFuture ...
[09:29:49.470] - result already collected: FutureResult
[09:29:49.470] result() for ClusterFuture ... done
[09:29:49.470] result() for ClusterFuture ...
[09:29:49.471] - result already collected: FutureResult
[09:29:49.471] result() for ClusterFuture ... done
[09:29:49.471] result() for ClusterFuture ...
[09:29:49.471] - result already collected: FutureResult
[09:29:49.471] result() for ClusterFuture ... done
[09:29:49.471] result() for ClusterFuture ...
[09:29:49.471] - result already collected: FutureResult
[09:29:49.471] result() for ClusterFuture ... done
[09:29:49.471]  - Number of value chunks collected: 2
[09:29:49.471] Resolving 2 futures (chunks) ... DONE
[09:29:49.471] Reducing values from 2 chunks ...
[09:29:49.472]  - Number of values collected after concatenation: 2
[09:29:49.472]  - Number of values expected: 2
[09:29:49.472] Reducing values from 2 chunks ... DONE
[09:29:49.472] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[09:29:49.473] future_lapply() ...
[09:29:49.479] Number of chunks: 2
[09:29:49.479] getGlobalsAndPackagesXApply() ...
[09:29:49.479]  - future.globals: TRUE
[09:29:49.479] getGlobalsAndPackages() ...
[09:29:49.479] Searching for globals...
[09:29:49.483] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[09:29:49.483] Searching for globals ... DONE
[09:29:49.483] Resolving globals: FALSE
[09:29:49.484] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[09:29:49.484] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:49.484] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:49.484] - packages: [1] ‘future.apply’
[09:29:49.485] getGlobalsAndPackages() ... DONE
[09:29:49.485]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:49.485]  - needed namespaces: [n=1] ‘future.apply’
[09:29:49.485] Finding globals ... DONE
[09:29:49.485]  - use_args: TRUE
[09:29:49.485]  - Getting '...' globals ...
[09:29:49.485] resolve() on list ...
[09:29:49.485]  recursive: 0
[09:29:49.486]  length: 1
[09:29:49.486]  elements: ‘...’
[09:29:49.486]  length: 0 (resolved future 1)
[09:29:49.486] resolve() on list ... DONE
[09:29:49.486]    - '...' content: [n=0] 
[09:29:49.486] List of 1
[09:29:49.486]  $ ...: list()
[09:29:49.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:49.486]  - attr(*, "where")=List of 1
[09:29:49.486]   ..$ ...:<environment: 0x561d35e786f8> 
[09:29:49.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:49.486]  - attr(*, "resolved")= logi TRUE
[09:29:49.486]  - attr(*, "total_size")= num NA
[09:29:49.488]  - Getting '...' globals ... DONE
[09:29:49.489] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:49.489] List of 8
[09:29:49.489]  $ ...future.FUN:function (x, ...)  
[09:29:49.489]  $ x_FUN        :function (x)  
[09:29:49.489]  $ times        : int 0
[09:29:49.489]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:49.489]  $ stop_if_not  :function (...)  
[09:29:49.489]  $ dim          : NULL
[09:29:49.489]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:49.489]  $ ...          : list()
[09:29:49.489]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:49.489]  - attr(*, "where")=List of 8
[09:29:49.489]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:49.489]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:49.489]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:49.489]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:49.489]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:49.489]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:49.489]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:49.489]   ..$ ...          :<environment: 0x561d35e786f8> 
[09:29:49.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:49.489]  - attr(*, "resolved")= logi FALSE
[09:29:49.489]  - attr(*, "total_size")= num 95472
[09:29:49.494] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:49.494] getGlobalsAndPackagesXApply() ... DONE
[09:29:49.494] Number of futures (= number of chunks): 2
[09:29:49.494] Launching 2 futures (chunks) ...
[09:29:49.494] Chunk #1 of 2 ...
[09:29:49.494]  - Finding globals in 'X' for chunk #1 ...
[09:29:49.494] getGlobalsAndPackages() ...
[09:29:49.495] Searching for globals...
[09:29:49.495] 
[09:29:49.495] Searching for globals ... DONE
[09:29:49.495] - globals: [0] <none>
[09:29:49.495] getGlobalsAndPackages() ... DONE
[09:29:49.495]    + additional globals found: [n=0] 
[09:29:49.495]    + additional namespaces needed: [n=0] 
[09:29:49.495]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:49.495]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:49.496]  - seeds: <none>
[09:29:49.496]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.496] getGlobalsAndPackages() ...
[09:29:49.496] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.496] Resolving globals: FALSE
[09:29:49.496] Tweak future expression to call with '...' arguments ...
[09:29:49.496] {
[09:29:49.496]     do.call(function(...) {
[09:29:49.496]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.496]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:49.496]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.496]             on.exit(options(oopts), add = TRUE)
[09:29:49.496]         }
[09:29:49.496]         {
[09:29:49.496]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:49.496]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.496]                 ...future.FUN(...future.X_jj, ...)
[09:29:49.496]             })
[09:29:49.496]         }
[09:29:49.496]     }, args = future.call.arguments)
[09:29:49.496] }
[09:29:49.496] Tweak future expression to call with '...' arguments ... DONE
[09:29:49.497] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.497] - packages: [1] ‘future.apply’
[09:29:49.497] getGlobalsAndPackages() ... DONE
[09:29:49.497] run() for ‘Future’ ...
[09:29:49.498] - state: ‘created’
[09:29:49.498] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:49.511] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:49.512] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:49.512]   - Field: ‘node’
[09:29:49.512]   - Field: ‘label’
[09:29:49.512]   - Field: ‘local’
[09:29:49.512]   - Field: ‘owner’
[09:29:49.512]   - Field: ‘envir’
[09:29:49.512]   - Field: ‘workers’
[09:29:49.512]   - Field: ‘packages’
[09:29:49.512]   - Field: ‘gc’
[09:29:49.512]   - Field: ‘conditions’
[09:29:49.512]   - Field: ‘persistent’
[09:29:49.513]   - Field: ‘expr’
[09:29:49.513]   - Field: ‘uuid’
[09:29:49.513]   - Field: ‘seed’
[09:29:49.513]   - Field: ‘version’
[09:29:49.513]   - Field: ‘result’
[09:29:49.513]   - Field: ‘asynchronous’
[09:29:49.513]   - Field: ‘calls’
[09:29:49.513]   - Field: ‘globals’
[09:29:49.513]   - Field: ‘stdout’
[09:29:49.513]   - Field: ‘earlySignal’
[09:29:49.513]   - Field: ‘lazy’
[09:29:49.514]   - Field: ‘state’
[09:29:49.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:49.514] - Launch lazy future ...
[09:29:49.514] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:49.514] Packages needed by future strategies (n = 0): <none>
[09:29:49.515] {
[09:29:49.515]     {
[09:29:49.515]         {
[09:29:49.515]             ...future.startTime <- base::Sys.time()
[09:29:49.515]             {
[09:29:49.515]                 {
[09:29:49.515]                   {
[09:29:49.515]                     {
[09:29:49.515]                       {
[09:29:49.515]                         base::local({
[09:29:49.515]                           has_future <- base::requireNamespace("future", 
[09:29:49.515]                             quietly = TRUE)
[09:29:49.515]                           if (has_future) {
[09:29:49.515]                             ns <- base::getNamespace("future")
[09:29:49.515]                             version <- ns[[".package"]][["version"]]
[09:29:49.515]                             if (is.null(version)) 
[09:29:49.515]                               version <- utils::packageVersion("future")
[09:29:49.515]                           }
[09:29:49.515]                           else {
[09:29:49.515]                             version <- NULL
[09:29:49.515]                           }
[09:29:49.515]                           if (!has_future || version < "1.8.0") {
[09:29:49.515]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:49.515]                               "", base::R.version$version.string), 
[09:29:49.515]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:49.515]                                 base::R.version$platform, 8 * 
[09:29:49.515]                                   base::.Machine$sizeof.pointer), 
[09:29:49.515]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:49.515]                                 "release", "version")], collapse = " "), 
[09:29:49.515]                               hostname = base::Sys.info()[["nodename"]])
[09:29:49.515]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:49.515]                               info)
[09:29:49.515]                             info <- base::paste(info, collapse = "; ")
[09:29:49.515]                             if (!has_future) {
[09:29:49.515]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:49.515]                                 info)
[09:29:49.515]                             }
[09:29:49.515]                             else {
[09:29:49.515]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:49.515]                                 info, version)
[09:29:49.515]                             }
[09:29:49.515]                             base::stop(msg)
[09:29:49.515]                           }
[09:29:49.515]                         })
[09:29:49.515]                       }
[09:29:49.515]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:49.515]                       base::options(mc.cores = 1L)
[09:29:49.515]                     }
[09:29:49.515]                     base::local({
[09:29:49.515]                       for (pkg in "future.apply") {
[09:29:49.515]                         base::loadNamespace(pkg)
[09:29:49.515]                         base::library(pkg, character.only = TRUE)
[09:29:49.515]                       }
[09:29:49.515]                     })
[09:29:49.515]                   }
[09:29:49.515]                   ...future.strategy.old <- future::plan("list")
[09:29:49.515]                   options(future.plan = NULL)
[09:29:49.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:49.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:49.515]                 }
[09:29:49.515]                 ...future.workdir <- getwd()
[09:29:49.515]             }
[09:29:49.515]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:49.515]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:49.515]         }
[09:29:49.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:49.515]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:49.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:49.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:49.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:49.515]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:49.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:49.515]             base::names(...future.oldOptions))
[09:29:49.515]     }
[09:29:49.515]     if (FALSE) {
[09:29:49.515]     }
[09:29:49.515]     else {
[09:29:49.515]         if (TRUE) {
[09:29:49.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:49.515]                 open = "w")
[09:29:49.515]         }
[09:29:49.515]         else {
[09:29:49.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:49.515]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:49.515]         }
[09:29:49.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:49.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:49.515]             base::sink(type = "output", split = FALSE)
[09:29:49.515]             base::close(...future.stdout)
[09:29:49.515]         }, add = TRUE)
[09:29:49.515]     }
[09:29:49.515]     ...future.frame <- base::sys.nframe()
[09:29:49.515]     ...future.conditions <- base::list()
[09:29:49.515]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:49.515]     if (FALSE) {
[09:29:49.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:49.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:49.515]     }
[09:29:49.515]     ...future.result <- base::tryCatch({
[09:29:49.515]         base::withCallingHandlers({
[09:29:49.515]             ...future.value <- base::withVisible(base::local({
[09:29:49.515]                 ...future.makeSendCondition <- base::local({
[09:29:49.515]                   sendCondition <- NULL
[09:29:49.515]                   function(frame = 1L) {
[09:29:49.515]                     if (is.function(sendCondition)) 
[09:29:49.515]                       return(sendCondition)
[09:29:49.515]                     ns <- getNamespace("parallel")
[09:29:49.515]                     if (exists("sendData", mode = "function", 
[09:29:49.515]                       envir = ns)) {
[09:29:49.515]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:49.515]                         envir = ns)
[09:29:49.515]                       envir <- sys.frame(frame)
[09:29:49.515]                       master <- NULL
[09:29:49.515]                       while (!identical(envir, .GlobalEnv) && 
[09:29:49.515]                         !identical(envir, emptyenv())) {
[09:29:49.515]                         if (exists("master", mode = "list", envir = envir, 
[09:29:49.515]                           inherits = FALSE)) {
[09:29:49.515]                           master <- get("master", mode = "list", 
[09:29:49.515]                             envir = envir, inherits = FALSE)
[09:29:49.515]                           if (inherits(master, c("SOCKnode", 
[09:29:49.515]                             "SOCK0node"))) {
[09:29:49.515]                             sendCondition <<- function(cond) {
[09:29:49.515]                               data <- list(type = "VALUE", value = cond, 
[09:29:49.515]                                 success = TRUE)
[09:29:49.515]                               parallel_sendData(master, data)
[09:29:49.515]                             }
[09:29:49.515]                             return(sendCondition)
[09:29:49.515]                           }
[09:29:49.515]                         }
[09:29:49.515]                         frame <- frame + 1L
[09:29:49.515]                         envir <- sys.frame(frame)
[09:29:49.515]                       }
[09:29:49.515]                     }
[09:29:49.515]                     sendCondition <<- function(cond) NULL
[09:29:49.515]                   }
[09:29:49.515]                 })
[09:29:49.515]                 withCallingHandlers({
[09:29:49.515]                   {
[09:29:49.515]                     do.call(function(...) {
[09:29:49.515]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.515]                       if (!identical(...future.globals.maxSize.org, 
[09:29:49.515]                         ...future.globals.maxSize)) {
[09:29:49.515]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.515]                         on.exit(options(oopts), add = TRUE)
[09:29:49.515]                       }
[09:29:49.515]                       {
[09:29:49.515]                         lapply(seq_along(...future.elements_ii), 
[09:29:49.515]                           FUN = function(jj) {
[09:29:49.515]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.515]                             ...future.FUN(...future.X_jj, ...)
[09:29:49.515]                           })
[09:29:49.515]                       }
[09:29:49.515]                     }, args = future.call.arguments)
[09:29:49.515]                   }
[09:29:49.515]                 }, immediateCondition = function(cond) {
[09:29:49.515]                   sendCondition <- ...future.makeSendCondition()
[09:29:49.515]                   sendCondition(cond)
[09:29:49.515]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.515]                   {
[09:29:49.515]                     inherits <- base::inherits
[09:29:49.515]                     invokeRestart <- base::invokeRestart
[09:29:49.515]                     is.null <- base::is.null
[09:29:49.515]                     muffled <- FALSE
[09:29:49.515]                     if (inherits(cond, "message")) {
[09:29:49.515]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:49.515]                       if (muffled) 
[09:29:49.515]                         invokeRestart("muffleMessage")
[09:29:49.515]                     }
[09:29:49.515]                     else if (inherits(cond, "warning")) {
[09:29:49.515]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:49.515]                       if (muffled) 
[09:29:49.515]                         invokeRestart("muffleWarning")
[09:29:49.515]                     }
[09:29:49.515]                     else if (inherits(cond, "condition")) {
[09:29:49.515]                       if (!is.null(pattern)) {
[09:29:49.515]                         computeRestarts <- base::computeRestarts
[09:29:49.515]                         grepl <- base::grepl
[09:29:49.515]                         restarts <- computeRestarts(cond)
[09:29:49.515]                         for (restart in restarts) {
[09:29:49.515]                           name <- restart$name
[09:29:49.515]                           if (is.null(name)) 
[09:29:49.515]                             next
[09:29:49.515]                           if (!grepl(pattern, name)) 
[09:29:49.515]                             next
[09:29:49.515]                           invokeRestart(restart)
[09:29:49.515]                           muffled <- TRUE
[09:29:49.515]                           break
[09:29:49.515]                         }
[09:29:49.515]                       }
[09:29:49.515]                     }
[09:29:49.515]                     invisible(muffled)
[09:29:49.515]                   }
[09:29:49.515]                   muffleCondition(cond)
[09:29:49.515]                 })
[09:29:49.515]             }))
[09:29:49.515]             future::FutureResult(value = ...future.value$value, 
[09:29:49.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:49.515]                   ...future.rng), globalenv = if (FALSE) 
[09:29:49.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:49.515]                     ...future.globalenv.names))
[09:29:49.515]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:49.515]         }, condition = base::local({
[09:29:49.515]             c <- base::c
[09:29:49.515]             inherits <- base::inherits
[09:29:49.515]             invokeRestart <- base::invokeRestart
[09:29:49.515]             length <- base::length
[09:29:49.515]             list <- base::list
[09:29:49.515]             seq.int <- base::seq.int
[09:29:49.515]             signalCondition <- base::signalCondition
[09:29:49.515]             sys.calls <- base::sys.calls
[09:29:49.515]             `[[` <- base::`[[`
[09:29:49.515]             `+` <- base::`+`
[09:29:49.515]             `<<-` <- base::`<<-`
[09:29:49.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:49.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:49.515]                   3L)]
[09:29:49.515]             }
[09:29:49.515]             function(cond) {
[09:29:49.515]                 is_error <- inherits(cond, "error")
[09:29:49.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:49.515]                   NULL)
[09:29:49.515]                 if (is_error) {
[09:29:49.515]                   sessionInformation <- function() {
[09:29:49.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:49.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:49.515]                       search = base::search(), system = base::Sys.info())
[09:29:49.515]                   }
[09:29:49.515]                   ...future.conditions[[length(...future.conditions) + 
[09:29:49.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:49.515]                     cond$call), session = sessionInformation(), 
[09:29:49.515]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:49.515]                   signalCondition(cond)
[09:29:49.515]                 }
[09:29:49.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:49.515]                 "immediateCondition"))) {
[09:29:49.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:49.515]                   ...future.conditions[[length(...future.conditions) + 
[09:29:49.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:49.515]                   if (TRUE && !signal) {
[09:29:49.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.515]                     {
[09:29:49.515]                       inherits <- base::inherits
[09:29:49.515]                       invokeRestart <- base::invokeRestart
[09:29:49.515]                       is.null <- base::is.null
[09:29:49.515]                       muffled <- FALSE
[09:29:49.515]                       if (inherits(cond, "message")) {
[09:29:49.515]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:49.515]                         if (muffled) 
[09:29:49.515]                           invokeRestart("muffleMessage")
[09:29:49.515]                       }
[09:29:49.515]                       else if (inherits(cond, "warning")) {
[09:29:49.515]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:49.515]                         if (muffled) 
[09:29:49.515]                           invokeRestart("muffleWarning")
[09:29:49.515]                       }
[09:29:49.515]                       else if (inherits(cond, "condition")) {
[09:29:49.515]                         if (!is.null(pattern)) {
[09:29:49.515]                           computeRestarts <- base::computeRestarts
[09:29:49.515]                           grepl <- base::grepl
[09:29:49.515]                           restarts <- computeRestarts(cond)
[09:29:49.515]                           for (restart in restarts) {
[09:29:49.515]                             name <- restart$name
[09:29:49.515]                             if (is.null(name)) 
[09:29:49.515]                               next
[09:29:49.515]                             if (!grepl(pattern, name)) 
[09:29:49.515]                               next
[09:29:49.515]                             invokeRestart(restart)
[09:29:49.515]                             muffled <- TRUE
[09:29:49.515]                             break
[09:29:49.515]                           }
[09:29:49.515]                         }
[09:29:49.515]                       }
[09:29:49.515]                       invisible(muffled)
[09:29:49.515]                     }
[09:29:49.515]                     muffleCondition(cond, pattern = "^muffle")
[09:29:49.515]                   }
[09:29:49.515]                 }
[09:29:49.515]                 else {
[09:29:49.515]                   if (TRUE) {
[09:29:49.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.515]                     {
[09:29:49.515]                       inherits <- base::inherits
[09:29:49.515]                       invokeRestart <- base::invokeRestart
[09:29:49.515]                       is.null <- base::is.null
[09:29:49.515]                       muffled <- FALSE
[09:29:49.515]                       if (inherits(cond, "message")) {
[09:29:49.515]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:49.515]                         if (muffled) 
[09:29:49.515]                           invokeRestart("muffleMessage")
[09:29:49.515]                       }
[09:29:49.515]                       else if (inherits(cond, "warning")) {
[09:29:49.515]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:49.515]                         if (muffled) 
[09:29:49.515]                           invokeRestart("muffleWarning")
[09:29:49.515]                       }
[09:29:49.515]                       else if (inherits(cond, "condition")) {
[09:29:49.515]                         if (!is.null(pattern)) {
[09:29:49.515]                           computeRestarts <- base::computeRestarts
[09:29:49.515]                           grepl <- base::grepl
[09:29:49.515]                           restarts <- computeRestarts(cond)
[09:29:49.515]                           for (restart in restarts) {
[09:29:49.515]                             name <- restart$name
[09:29:49.515]                             if (is.null(name)) 
[09:29:49.515]                               next
[09:29:49.515]                             if (!grepl(pattern, name)) 
[09:29:49.515]                               next
[09:29:49.515]                             invokeRestart(restart)
[09:29:49.515]                             muffled <- TRUE
[09:29:49.515]                             break
[09:29:49.515]                           }
[09:29:49.515]                         }
[09:29:49.515]                       }
[09:29:49.515]                       invisible(muffled)
[09:29:49.515]                     }
[09:29:49.515]                     muffleCondition(cond, pattern = "^muffle")
[09:29:49.515]                   }
[09:29:49.515]                 }
[09:29:49.515]             }
[09:29:49.515]         }))
[09:29:49.515]     }, error = function(ex) {
[09:29:49.515]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:49.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:49.515]                 ...future.rng), started = ...future.startTime, 
[09:29:49.515]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:49.515]             version = "1.8"), class = "FutureResult")
[09:29:49.515]     }, finally = {
[09:29:49.515]         if (!identical(...future.workdir, getwd())) 
[09:29:49.515]             setwd(...future.workdir)
[09:29:49.515]         {
[09:29:49.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:49.515]                 ...future.oldOptions$nwarnings <- NULL
[09:29:49.515]             }
[09:29:49.515]             base::options(...future.oldOptions)
[09:29:49.515]             if (.Platform$OS.type == "windows") {
[09:29:49.515]                 old_names <- names(...future.oldEnvVars)
[09:29:49.515]                 envs <- base::Sys.getenv()
[09:29:49.515]                 names <- names(envs)
[09:29:49.515]                 common <- intersect(names, old_names)
[09:29:49.515]                 added <- setdiff(names, old_names)
[09:29:49.515]                 removed <- setdiff(old_names, names)
[09:29:49.515]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:49.515]                   envs[common]]
[09:29:49.515]                 NAMES <- toupper(changed)
[09:29:49.515]                 args <- list()
[09:29:49.515]                 for (kk in seq_along(NAMES)) {
[09:29:49.515]                   name <- changed[[kk]]
[09:29:49.515]                   NAME <- NAMES[[kk]]
[09:29:49.515]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.515]                     next
[09:29:49.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:49.515]                 }
[09:29:49.515]                 NAMES <- toupper(added)
[09:29:49.515]                 for (kk in seq_along(NAMES)) {
[09:29:49.515]                   name <- added[[kk]]
[09:29:49.515]                   NAME <- NAMES[[kk]]
[09:29:49.515]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.515]                     next
[09:29:49.515]                   args[[name]] <- ""
[09:29:49.515]                 }
[09:29:49.515]                 NAMES <- toupper(removed)
[09:29:49.515]                 for (kk in seq_along(NAMES)) {
[09:29:49.515]                   name <- removed[[kk]]
[09:29:49.515]                   NAME <- NAMES[[kk]]
[09:29:49.515]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.515]                     next
[09:29:49.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:49.515]                 }
[09:29:49.515]                 if (length(args) > 0) 
[09:29:49.515]                   base::do.call(base::Sys.setenv, args = args)
[09:29:49.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:49.515]             }
[09:29:49.515]             else {
[09:29:49.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:49.515]             }
[09:29:49.515]             {
[09:29:49.515]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:49.515]                   0L) {
[09:29:49.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:49.515]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:49.515]                   base::options(opts)
[09:29:49.515]                 }
[09:29:49.515]                 {
[09:29:49.515]                   {
[09:29:49.515]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:49.515]                     NULL
[09:29:49.515]                   }
[09:29:49.515]                   options(future.plan = NULL)
[09:29:49.515]                   if (is.na(NA_character_)) 
[09:29:49.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:49.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:49.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:49.515]                     .init = FALSE)
[09:29:49.515]                 }
[09:29:49.515]             }
[09:29:49.515]         }
[09:29:49.515]     })
[09:29:49.515]     if (TRUE) {
[09:29:49.515]         base::sink(type = "output", split = FALSE)
[09:29:49.515]         if (TRUE) {
[09:29:49.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:49.515]         }
[09:29:49.515]         else {
[09:29:49.515]             ...future.result["stdout"] <- base::list(NULL)
[09:29:49.515]         }
[09:29:49.515]         base::close(...future.stdout)
[09:29:49.515]         ...future.stdout <- NULL
[09:29:49.515]     }
[09:29:49.515]     ...future.result$conditions <- ...future.conditions
[09:29:49.515]     ...future.result$finished <- base::Sys.time()
[09:29:49.515]     ...future.result
[09:29:49.515] }
[09:29:49.517] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[09:29:49.517] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:49.560] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:49.560] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[09:29:49.561] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[09:29:49.561] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:49.561] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:49.561] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:49.604] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:49.604] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:49.648] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:49.648] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:49.649] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:49.649] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:49.649] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:49.649] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:49.650] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:49.650] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:49.650] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:49.650] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:49.651] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:49.651] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:49.651] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:49.651] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[09:29:49.652] MultisessionFuture started
[09:29:49.652] - Launch lazy future ... done
[09:29:49.652] run() for ‘MultisessionFuture’ ... done
[09:29:49.652] Created future:
[09:29:49.652] MultisessionFuture:
[09:29:49.652] Label: ‘future_vapply-1’
[09:29:49.652] Expression:
[09:29:49.652] {
[09:29:49.652]     do.call(function(...) {
[09:29:49.652]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.652]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:49.652]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.652]             on.exit(options(oopts), add = TRUE)
[09:29:49.652]         }
[09:29:49.652]         {
[09:29:49.652]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:49.652]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.652]                 ...future.FUN(...future.X_jj, ...)
[09:29:49.652]             })
[09:29:49.652]         }
[09:29:49.652]     }, args = future.call.arguments)
[09:29:49.652] }
[09:29:49.652] Lazy evaluation: FALSE
[09:29:49.652] Asynchronous evaluation: TRUE
[09:29:49.652] Local evaluation: TRUE
[09:29:49.652] Environment: R_GlobalEnv
[09:29:49.652] Capture standard output: TRUE
[09:29:49.652] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:49.652] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:49.652] Packages: 1 packages (‘future.apply’)
[09:29:49.652] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:49.652] Resolved: FALSE
[09:29:49.652] Value: <not collected>
[09:29:49.652] Conditions captured: <none>
[09:29:49.652] Early signaling: FALSE
[09:29:49.652] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:49.652] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:49.664] Chunk #1 of 2 ... DONE
[09:29:49.664] Chunk #2 of 2 ...
[09:29:49.664]  - Finding globals in 'X' for chunk #2 ...
[09:29:49.665] getGlobalsAndPackages() ...
[09:29:49.665] Searching for globals...
[09:29:49.665] 
[09:29:49.665] Searching for globals ... DONE
[09:29:49.665] - globals: [0] <none>
[09:29:49.665] getGlobalsAndPackages() ... DONE
[09:29:49.665]    + additional globals found: [n=0] 
[09:29:49.665]    + additional namespaces needed: [n=0] 
[09:29:49.665]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:49.666]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:49.666]  - seeds: <none>
[09:29:49.666]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.666] getGlobalsAndPackages() ...
[09:29:49.666] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.666] Resolving globals: FALSE
[09:29:49.666] Tweak future expression to call with '...' arguments ...
[09:29:49.666] {
[09:29:49.666]     do.call(function(...) {
[09:29:49.666]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.666]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:49.666]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.666]             on.exit(options(oopts), add = TRUE)
[09:29:49.666]         }
[09:29:49.666]         {
[09:29:49.666]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:49.666]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.666]                 ...future.FUN(...future.X_jj, ...)
[09:29:49.666]             })
[09:29:49.666]         }
[09:29:49.666]     }, args = future.call.arguments)
[09:29:49.666] }
[09:29:49.666] Tweak future expression to call with '...' arguments ... DONE
[09:29:49.667] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.667] - packages: [1] ‘future.apply’
[09:29:49.667] getGlobalsAndPackages() ... DONE
[09:29:49.667] run() for ‘Future’ ...
[09:29:49.668] - state: ‘created’
[09:29:49.668] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:49.681] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:49.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:49.681]   - Field: ‘node’
[09:29:49.681]   - Field: ‘label’
[09:29:49.682]   - Field: ‘local’
[09:29:49.682]   - Field: ‘owner’
[09:29:49.682]   - Field: ‘envir’
[09:29:49.682]   - Field: ‘workers’
[09:29:49.682]   - Field: ‘packages’
[09:29:49.682]   - Field: ‘gc’
[09:29:49.682]   - Field: ‘conditions’
[09:29:49.682]   - Field: ‘persistent’
[09:29:49.682]   - Field: ‘expr’
[09:29:49.682]   - Field: ‘uuid’
[09:29:49.682]   - Field: ‘seed’
[09:29:49.683]   - Field: ‘version’
[09:29:49.683]   - Field: ‘result’
[09:29:49.683]   - Field: ‘asynchronous’
[09:29:49.683]   - Field: ‘calls’
[09:29:49.683]   - Field: ‘globals’
[09:29:49.683]   - Field: ‘stdout’
[09:29:49.683]   - Field: ‘earlySignal’
[09:29:49.683]   - Field: ‘lazy’
[09:29:49.683]   - Field: ‘state’
[09:29:49.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:49.683] - Launch lazy future ...
[09:29:49.684] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:49.684] Packages needed by future strategies (n = 0): <none>
[09:29:49.684] {
[09:29:49.684]     {
[09:29:49.684]         {
[09:29:49.684]             ...future.startTime <- base::Sys.time()
[09:29:49.684]             {
[09:29:49.684]                 {
[09:29:49.684]                   {
[09:29:49.684]                     {
[09:29:49.684]                       {
[09:29:49.684]                         base::local({
[09:29:49.684]                           has_future <- base::requireNamespace("future", 
[09:29:49.684]                             quietly = TRUE)
[09:29:49.684]                           if (has_future) {
[09:29:49.684]                             ns <- base::getNamespace("future")
[09:29:49.684]                             version <- ns[[".package"]][["version"]]
[09:29:49.684]                             if (is.null(version)) 
[09:29:49.684]                               version <- utils::packageVersion("future")
[09:29:49.684]                           }
[09:29:49.684]                           else {
[09:29:49.684]                             version <- NULL
[09:29:49.684]                           }
[09:29:49.684]                           if (!has_future || version < "1.8.0") {
[09:29:49.684]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:49.684]                               "", base::R.version$version.string), 
[09:29:49.684]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:49.684]                                 base::R.version$platform, 8 * 
[09:29:49.684]                                   base::.Machine$sizeof.pointer), 
[09:29:49.684]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:49.684]                                 "release", "version")], collapse = " "), 
[09:29:49.684]                               hostname = base::Sys.info()[["nodename"]])
[09:29:49.684]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:49.684]                               info)
[09:29:49.684]                             info <- base::paste(info, collapse = "; ")
[09:29:49.684]                             if (!has_future) {
[09:29:49.684]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:49.684]                                 info)
[09:29:49.684]                             }
[09:29:49.684]                             else {
[09:29:49.684]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:49.684]                                 info, version)
[09:29:49.684]                             }
[09:29:49.684]                             base::stop(msg)
[09:29:49.684]                           }
[09:29:49.684]                         })
[09:29:49.684]                       }
[09:29:49.684]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:49.684]                       base::options(mc.cores = 1L)
[09:29:49.684]                     }
[09:29:49.684]                     base::local({
[09:29:49.684]                       for (pkg in "future.apply") {
[09:29:49.684]                         base::loadNamespace(pkg)
[09:29:49.684]                         base::library(pkg, character.only = TRUE)
[09:29:49.684]                       }
[09:29:49.684]                     })
[09:29:49.684]                   }
[09:29:49.684]                   ...future.strategy.old <- future::plan("list")
[09:29:49.684]                   options(future.plan = NULL)
[09:29:49.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:49.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:49.684]                 }
[09:29:49.684]                 ...future.workdir <- getwd()
[09:29:49.684]             }
[09:29:49.684]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:49.684]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:49.684]         }
[09:29:49.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:49.684]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:49.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:49.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:49.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:49.684]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:49.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:49.684]             base::names(...future.oldOptions))
[09:29:49.684]     }
[09:29:49.684]     if (FALSE) {
[09:29:49.684]     }
[09:29:49.684]     else {
[09:29:49.684]         if (TRUE) {
[09:29:49.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:49.684]                 open = "w")
[09:29:49.684]         }
[09:29:49.684]         else {
[09:29:49.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:49.684]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:49.684]         }
[09:29:49.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:49.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:49.684]             base::sink(type = "output", split = FALSE)
[09:29:49.684]             base::close(...future.stdout)
[09:29:49.684]         }, add = TRUE)
[09:29:49.684]     }
[09:29:49.684]     ...future.frame <- base::sys.nframe()
[09:29:49.684]     ...future.conditions <- base::list()
[09:29:49.684]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:49.684]     if (FALSE) {
[09:29:49.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:49.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:49.684]     }
[09:29:49.684]     ...future.result <- base::tryCatch({
[09:29:49.684]         base::withCallingHandlers({
[09:29:49.684]             ...future.value <- base::withVisible(base::local({
[09:29:49.684]                 ...future.makeSendCondition <- base::local({
[09:29:49.684]                   sendCondition <- NULL
[09:29:49.684]                   function(frame = 1L) {
[09:29:49.684]                     if (is.function(sendCondition)) 
[09:29:49.684]                       return(sendCondition)
[09:29:49.684]                     ns <- getNamespace("parallel")
[09:29:49.684]                     if (exists("sendData", mode = "function", 
[09:29:49.684]                       envir = ns)) {
[09:29:49.684]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:49.684]                         envir = ns)
[09:29:49.684]                       envir <- sys.frame(frame)
[09:29:49.684]                       master <- NULL
[09:29:49.684]                       while (!identical(envir, .GlobalEnv) && 
[09:29:49.684]                         !identical(envir, emptyenv())) {
[09:29:49.684]                         if (exists("master", mode = "list", envir = envir, 
[09:29:49.684]                           inherits = FALSE)) {
[09:29:49.684]                           master <- get("master", mode = "list", 
[09:29:49.684]                             envir = envir, inherits = FALSE)
[09:29:49.684]                           if (inherits(master, c("SOCKnode", 
[09:29:49.684]                             "SOCK0node"))) {
[09:29:49.684]                             sendCondition <<- function(cond) {
[09:29:49.684]                               data <- list(type = "VALUE", value = cond, 
[09:29:49.684]                                 success = TRUE)
[09:29:49.684]                               parallel_sendData(master, data)
[09:29:49.684]                             }
[09:29:49.684]                             return(sendCondition)
[09:29:49.684]                           }
[09:29:49.684]                         }
[09:29:49.684]                         frame <- frame + 1L
[09:29:49.684]                         envir <- sys.frame(frame)
[09:29:49.684]                       }
[09:29:49.684]                     }
[09:29:49.684]                     sendCondition <<- function(cond) NULL
[09:29:49.684]                   }
[09:29:49.684]                 })
[09:29:49.684]                 withCallingHandlers({
[09:29:49.684]                   {
[09:29:49.684]                     do.call(function(...) {
[09:29:49.684]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.684]                       if (!identical(...future.globals.maxSize.org, 
[09:29:49.684]                         ...future.globals.maxSize)) {
[09:29:49.684]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.684]                         on.exit(options(oopts), add = TRUE)
[09:29:49.684]                       }
[09:29:49.684]                       {
[09:29:49.684]                         lapply(seq_along(...future.elements_ii), 
[09:29:49.684]                           FUN = function(jj) {
[09:29:49.684]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.684]                             ...future.FUN(...future.X_jj, ...)
[09:29:49.684]                           })
[09:29:49.684]                       }
[09:29:49.684]                     }, args = future.call.arguments)
[09:29:49.684]                   }
[09:29:49.684]                 }, immediateCondition = function(cond) {
[09:29:49.684]                   sendCondition <- ...future.makeSendCondition()
[09:29:49.684]                   sendCondition(cond)
[09:29:49.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.684]                   {
[09:29:49.684]                     inherits <- base::inherits
[09:29:49.684]                     invokeRestart <- base::invokeRestart
[09:29:49.684]                     is.null <- base::is.null
[09:29:49.684]                     muffled <- FALSE
[09:29:49.684]                     if (inherits(cond, "message")) {
[09:29:49.684]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:49.684]                       if (muffled) 
[09:29:49.684]                         invokeRestart("muffleMessage")
[09:29:49.684]                     }
[09:29:49.684]                     else if (inherits(cond, "warning")) {
[09:29:49.684]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:49.684]                       if (muffled) 
[09:29:49.684]                         invokeRestart("muffleWarning")
[09:29:49.684]                     }
[09:29:49.684]                     else if (inherits(cond, "condition")) {
[09:29:49.684]                       if (!is.null(pattern)) {
[09:29:49.684]                         computeRestarts <- base::computeRestarts
[09:29:49.684]                         grepl <- base::grepl
[09:29:49.684]                         restarts <- computeRestarts(cond)
[09:29:49.684]                         for (restart in restarts) {
[09:29:49.684]                           name <- restart$name
[09:29:49.684]                           if (is.null(name)) 
[09:29:49.684]                             next
[09:29:49.684]                           if (!grepl(pattern, name)) 
[09:29:49.684]                             next
[09:29:49.684]                           invokeRestart(restart)
[09:29:49.684]                           muffled <- TRUE
[09:29:49.684]                           break
[09:29:49.684]                         }
[09:29:49.684]                       }
[09:29:49.684]                     }
[09:29:49.684]                     invisible(muffled)
[09:29:49.684]                   }
[09:29:49.684]                   muffleCondition(cond)
[09:29:49.684]                 })
[09:29:49.684]             }))
[09:29:49.684]             future::FutureResult(value = ...future.value$value, 
[09:29:49.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:49.684]                   ...future.rng), globalenv = if (FALSE) 
[09:29:49.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:49.684]                     ...future.globalenv.names))
[09:29:49.684]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:49.684]         }, condition = base::local({
[09:29:49.684]             c <- base::c
[09:29:49.684]             inherits <- base::inherits
[09:29:49.684]             invokeRestart <- base::invokeRestart
[09:29:49.684]             length <- base::length
[09:29:49.684]             list <- base::list
[09:29:49.684]             seq.int <- base::seq.int
[09:29:49.684]             signalCondition <- base::signalCondition
[09:29:49.684]             sys.calls <- base::sys.calls
[09:29:49.684]             `[[` <- base::`[[`
[09:29:49.684]             `+` <- base::`+`
[09:29:49.684]             `<<-` <- base::`<<-`
[09:29:49.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:49.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:49.684]                   3L)]
[09:29:49.684]             }
[09:29:49.684]             function(cond) {
[09:29:49.684]                 is_error <- inherits(cond, "error")
[09:29:49.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:49.684]                   NULL)
[09:29:49.684]                 if (is_error) {
[09:29:49.684]                   sessionInformation <- function() {
[09:29:49.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:49.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:49.684]                       search = base::search(), system = base::Sys.info())
[09:29:49.684]                   }
[09:29:49.684]                   ...future.conditions[[length(...future.conditions) + 
[09:29:49.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:49.684]                     cond$call), session = sessionInformation(), 
[09:29:49.684]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:49.684]                   signalCondition(cond)
[09:29:49.684]                 }
[09:29:49.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:49.684]                 "immediateCondition"))) {
[09:29:49.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:49.684]                   ...future.conditions[[length(...future.conditions) + 
[09:29:49.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:49.684]                   if (TRUE && !signal) {
[09:29:49.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.684]                     {
[09:29:49.684]                       inherits <- base::inherits
[09:29:49.684]                       invokeRestart <- base::invokeRestart
[09:29:49.684]                       is.null <- base::is.null
[09:29:49.684]                       muffled <- FALSE
[09:29:49.684]                       if (inherits(cond, "message")) {
[09:29:49.684]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:49.684]                         if (muffled) 
[09:29:49.684]                           invokeRestart("muffleMessage")
[09:29:49.684]                       }
[09:29:49.684]                       else if (inherits(cond, "warning")) {
[09:29:49.684]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:49.684]                         if (muffled) 
[09:29:49.684]                           invokeRestart("muffleWarning")
[09:29:49.684]                       }
[09:29:49.684]                       else if (inherits(cond, "condition")) {
[09:29:49.684]                         if (!is.null(pattern)) {
[09:29:49.684]                           computeRestarts <- base::computeRestarts
[09:29:49.684]                           grepl <- base::grepl
[09:29:49.684]                           restarts <- computeRestarts(cond)
[09:29:49.684]                           for (restart in restarts) {
[09:29:49.684]                             name <- restart$name
[09:29:49.684]                             if (is.null(name)) 
[09:29:49.684]                               next
[09:29:49.684]                             if (!grepl(pattern, name)) 
[09:29:49.684]                               next
[09:29:49.684]                             invokeRestart(restart)
[09:29:49.684]                             muffled <- TRUE
[09:29:49.684]                             break
[09:29:49.684]                           }
[09:29:49.684]                         }
[09:29:49.684]                       }
[09:29:49.684]                       invisible(muffled)
[09:29:49.684]                     }
[09:29:49.684]                     muffleCondition(cond, pattern = "^muffle")
[09:29:49.684]                   }
[09:29:49.684]                 }
[09:29:49.684]                 else {
[09:29:49.684]                   if (TRUE) {
[09:29:49.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.684]                     {
[09:29:49.684]                       inherits <- base::inherits
[09:29:49.684]                       invokeRestart <- base::invokeRestart
[09:29:49.684]                       is.null <- base::is.null
[09:29:49.684]                       muffled <- FALSE
[09:29:49.684]                       if (inherits(cond, "message")) {
[09:29:49.684]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:49.684]                         if (muffled) 
[09:29:49.684]                           invokeRestart("muffleMessage")
[09:29:49.684]                       }
[09:29:49.684]                       else if (inherits(cond, "warning")) {
[09:29:49.684]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:49.684]                         if (muffled) 
[09:29:49.684]                           invokeRestart("muffleWarning")
[09:29:49.684]                       }
[09:29:49.684]                       else if (inherits(cond, "condition")) {
[09:29:49.684]                         if (!is.null(pattern)) {
[09:29:49.684]                           computeRestarts <- base::computeRestarts
[09:29:49.684]                           grepl <- base::grepl
[09:29:49.684]                           restarts <- computeRestarts(cond)
[09:29:49.684]                           for (restart in restarts) {
[09:29:49.684]                             name <- restart$name
[09:29:49.684]                             if (is.null(name)) 
[09:29:49.684]                               next
[09:29:49.684]                             if (!grepl(pattern, name)) 
[09:29:49.684]                               next
[09:29:49.684]                             invokeRestart(restart)
[09:29:49.684]                             muffled <- TRUE
[09:29:49.684]                             break
[09:29:49.684]                           }
[09:29:49.684]                         }
[09:29:49.684]                       }
[09:29:49.684]                       invisible(muffled)
[09:29:49.684]                     }
[09:29:49.684]                     muffleCondition(cond, pattern = "^muffle")
[09:29:49.684]                   }
[09:29:49.684]                 }
[09:29:49.684]             }
[09:29:49.684]         }))
[09:29:49.684]     }, error = function(ex) {
[09:29:49.684]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:49.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:49.684]                 ...future.rng), started = ...future.startTime, 
[09:29:49.684]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:49.684]             version = "1.8"), class = "FutureResult")
[09:29:49.684]     }, finally = {
[09:29:49.684]         if (!identical(...future.workdir, getwd())) 
[09:29:49.684]             setwd(...future.workdir)
[09:29:49.684]         {
[09:29:49.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:49.684]                 ...future.oldOptions$nwarnings <- NULL
[09:29:49.684]             }
[09:29:49.684]             base::options(...future.oldOptions)
[09:29:49.684]             if (.Platform$OS.type == "windows") {
[09:29:49.684]                 old_names <- names(...future.oldEnvVars)
[09:29:49.684]                 envs <- base::Sys.getenv()
[09:29:49.684]                 names <- names(envs)
[09:29:49.684]                 common <- intersect(names, old_names)
[09:29:49.684]                 added <- setdiff(names, old_names)
[09:29:49.684]                 removed <- setdiff(old_names, names)
[09:29:49.684]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:49.684]                   envs[common]]
[09:29:49.684]                 NAMES <- toupper(changed)
[09:29:49.684]                 args <- list()
[09:29:49.684]                 for (kk in seq_along(NAMES)) {
[09:29:49.684]                   name <- changed[[kk]]
[09:29:49.684]                   NAME <- NAMES[[kk]]
[09:29:49.684]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.684]                     next
[09:29:49.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:49.684]                 }
[09:29:49.684]                 NAMES <- toupper(added)
[09:29:49.684]                 for (kk in seq_along(NAMES)) {
[09:29:49.684]                   name <- added[[kk]]
[09:29:49.684]                   NAME <- NAMES[[kk]]
[09:29:49.684]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.684]                     next
[09:29:49.684]                   args[[name]] <- ""
[09:29:49.684]                 }
[09:29:49.684]                 NAMES <- toupper(removed)
[09:29:49.684]                 for (kk in seq_along(NAMES)) {
[09:29:49.684]                   name <- removed[[kk]]
[09:29:49.684]                   NAME <- NAMES[[kk]]
[09:29:49.684]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.684]                     next
[09:29:49.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:49.684]                 }
[09:29:49.684]                 if (length(args) > 0) 
[09:29:49.684]                   base::do.call(base::Sys.setenv, args = args)
[09:29:49.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:49.684]             }
[09:29:49.684]             else {
[09:29:49.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:49.684]             }
[09:29:49.684]             {
[09:29:49.684]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:49.684]                   0L) {
[09:29:49.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:49.684]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:49.684]                   base::options(opts)
[09:29:49.684]                 }
[09:29:49.684]                 {
[09:29:49.684]                   {
[09:29:49.684]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:49.684]                     NULL
[09:29:49.684]                   }
[09:29:49.684]                   options(future.plan = NULL)
[09:29:49.684]                   if (is.na(NA_character_)) 
[09:29:49.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:49.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:49.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:49.684]                     .init = FALSE)
[09:29:49.684]                 }
[09:29:49.684]             }
[09:29:49.684]         }
[09:29:49.684]     })
[09:29:49.684]     if (TRUE) {
[09:29:49.684]         base::sink(type = "output", split = FALSE)
[09:29:49.684]         if (TRUE) {
[09:29:49.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:49.684]         }
[09:29:49.684]         else {
[09:29:49.684]             ...future.result["stdout"] <- base::list(NULL)
[09:29:49.684]         }
[09:29:49.684]         base::close(...future.stdout)
[09:29:49.684]         ...future.stdout <- NULL
[09:29:49.684]     }
[09:29:49.684]     ...future.result$conditions <- ...future.conditions
[09:29:49.684]     ...future.result$finished <- base::Sys.time()
[09:29:49.684]     ...future.result
[09:29:49.684] }
[09:29:49.687] Exporting 11 global objects (93.23 KiB) to cluster node #2 ...
[09:29:49.687] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[09:29:49.728] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[09:29:49.728] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[09:29:49.729] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[09:29:49.729] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[09:29:49.729] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[09:29:49.729] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[09:29:49.772] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[09:29:49.772] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[09:29:49.816] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[09:29:49.816] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[09:29:49.817] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[09:29:49.817] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[09:29:49.817] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[09:29:49.817] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:29:49.818] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:29:49.818] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[09:29:49.818] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[09:29:49.819] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:49.819] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:49.819] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:49.819] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:49.819] Exporting 11 global objects (93.23 KiB) to cluster node #2 ... DONE
[09:29:49.820] MultisessionFuture started
[09:29:49.820] - Launch lazy future ... done
[09:29:49.820] run() for ‘MultisessionFuture’ ... done
[09:29:49.820] Created future:
[09:29:49.821] MultisessionFuture:
[09:29:49.821] Label: ‘future_vapply-2’
[09:29:49.821] Expression:
[09:29:49.821] {
[09:29:49.821]     do.call(function(...) {
[09:29:49.821]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.821]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:49.821]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.821]             on.exit(options(oopts), add = TRUE)
[09:29:49.821]         }
[09:29:49.821]         {
[09:29:49.821]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:49.821]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.821]                 ...future.FUN(...future.X_jj, ...)
[09:29:49.821]             })
[09:29:49.821]         }
[09:29:49.821]     }, args = future.call.arguments)
[09:29:49.821] }
[09:29:49.821] Lazy evaluation: FALSE
[09:29:49.821] Asynchronous evaluation: TRUE
[09:29:49.821] Local evaluation: TRUE
[09:29:49.821] Environment: R_GlobalEnv
[09:29:49.821] Capture standard output: TRUE
[09:29:49.821] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:49.821] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:49.821] Packages: 1 packages (‘future.apply’)
[09:29:49.821] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:49.821] Resolved: FALSE
[09:29:49.821] Value: <not collected>
[09:29:49.821] Conditions captured: <none>
[09:29:49.821] Early signaling: FALSE
[09:29:49.821] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:49.821] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:49.832] Chunk #2 of 2 ... DONE
[09:29:49.832] Launching 2 futures (chunks) ... DONE
[09:29:49.832] Resolving 2 futures (chunks) ...
[09:29:49.833] resolve() on list ...
[09:29:49.833]  recursive: 0
[09:29:49.833]  length: 2
[09:29:49.833] 
[09:29:49.833] receiveMessageFromWorker() for ClusterFuture ...
[09:29:49.833] - Validating connection of MultisessionFuture
[09:29:49.834] - received message: FutureResult
[09:29:49.834] - Received FutureResult
[09:29:49.834] - Erased future from FutureRegistry
[09:29:49.834] result() for ClusterFuture ...
[09:29:49.834] - result already collected: FutureResult
[09:29:49.834] result() for ClusterFuture ... done
[09:29:49.834] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:49.834] Future #1
[09:29:49.834] result() for ClusterFuture ...
[09:29:49.834] - result already collected: FutureResult
[09:29:49.835] result() for ClusterFuture ... done
[09:29:49.835] result() for ClusterFuture ...
[09:29:49.835] - result already collected: FutureResult
[09:29:49.835] result() for ClusterFuture ... done
[09:29:49.835] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:49.835] - nx: 2
[09:29:49.835] - relay: TRUE
[09:29:49.835] - stdout: TRUE
[09:29:49.835] - signal: TRUE
[09:29:49.835] - resignal: FALSE
[09:29:49.835] - force: TRUE
[09:29:49.835] - relayed: [n=2] FALSE, FALSE
[09:29:49.836] - queued futures: [n=2] FALSE, FALSE
[09:29:49.836]  - until=1
[09:29:49.836]  - relaying element #1
[09:29:49.836] result() for ClusterFuture ...
[09:29:49.836] - result already collected: FutureResult
[09:29:49.836] result() for ClusterFuture ... done
[09:29:49.836] result() for ClusterFuture ...
[09:29:49.836] - result already collected: FutureResult
[09:29:49.836] result() for ClusterFuture ... done
[09:29:49.836] result() for ClusterFuture ...
[09:29:49.836] - result already collected: FutureResult
[09:29:49.837] result() for ClusterFuture ... done
[09:29:49.837] result() for ClusterFuture ...
[09:29:49.837] - result already collected: FutureResult
[09:29:49.837] result() for ClusterFuture ... done
[09:29:49.837] - relayed: [n=2] TRUE, FALSE
[09:29:49.837] - queued futures: [n=2] TRUE, FALSE
[09:29:49.837] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:49.837]  length: 1 (resolved future 1)
[09:29:49.866] receiveMessageFromWorker() for ClusterFuture ...
[09:29:49.866] - Validating connection of MultisessionFuture
[09:29:49.866] - received message: FutureResult
[09:29:49.866] - Received FutureResult
[09:29:49.866] - Erased future from FutureRegistry
[09:29:49.866] result() for ClusterFuture ...
[09:29:49.866] - result already collected: FutureResult
[09:29:49.866] result() for ClusterFuture ... done
[09:29:49.866] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:49.867] Future #2
[09:29:49.867] result() for ClusterFuture ...
[09:29:49.867] - result already collected: FutureResult
[09:29:49.867] result() for ClusterFuture ... done
[09:29:49.867] result() for ClusterFuture ...
[09:29:49.867] - result already collected: FutureResult
[09:29:49.867] result() for ClusterFuture ... done
[09:29:49.867] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:49.867] - nx: 2
[09:29:49.867] - relay: TRUE
[09:29:49.867] - stdout: TRUE
[09:29:49.867] - signal: TRUE
[09:29:49.868] - resignal: FALSE
[09:29:49.868] - force: TRUE
[09:29:49.868] - relayed: [n=2] TRUE, FALSE
[09:29:49.868] - queued futures: [n=2] TRUE, FALSE
[09:29:49.868]  - until=2
[09:29:49.868]  - relaying element #2
[09:29:49.868] result() for ClusterFuture ...
[09:29:49.868] - result already collected: FutureResult
[09:29:49.868] result() for ClusterFuture ... done
[09:29:49.868] result() for ClusterFuture ...
[09:29:49.868] - result already collected: FutureResult
[09:29:49.868] result() for ClusterFuture ... done
[09:29:49.869] result() for ClusterFuture ...
[09:29:49.869] - result already collected: FutureResult
[09:29:49.869] result() for ClusterFuture ... done
[09:29:49.869] result() for ClusterFuture ...
[09:29:49.869] - result already collected: FutureResult
[09:29:49.869] result() for ClusterFuture ... done
[09:29:49.869] - relayed: [n=2] TRUE, TRUE
[09:29:49.869] - queued futures: [n=2] TRUE, TRUE
[09:29:49.869] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:49.869]  length: 0 (resolved future 2)
[09:29:49.869] Relaying remaining futures
[09:29:49.870] signalConditionsASAP(NULL, pos=0) ...
[09:29:49.870] - nx: 2
[09:29:49.870] - relay: TRUE
[09:29:49.870] - stdout: TRUE
[09:29:49.870] - signal: TRUE
[09:29:49.870] - resignal: FALSE
[09:29:49.870] - force: TRUE
[09:29:49.870] - relayed: [n=2] TRUE, TRUE
[09:29:49.870] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:49.870] - relayed: [n=2] TRUE, TRUE
[09:29:49.870] - queued futures: [n=2] TRUE, TRUE
[09:29:49.870] signalConditionsASAP(NULL, pos=0) ... done
[09:29:49.871] resolve() on list ... DONE
[09:29:49.871] result() for ClusterFuture ...
[09:29:49.871] - result already collected: FutureResult
[09:29:49.871] result() for ClusterFuture ... done
[09:29:49.871] result() for ClusterFuture ...
[09:29:49.871] - result already collected: FutureResult
[09:29:49.871] result() for ClusterFuture ... done
[09:29:49.871] result() for ClusterFuture ...
[09:29:49.871] - result already collected: FutureResult
[09:29:49.871] result() for ClusterFuture ... done
[09:29:49.871] result() for ClusterFuture ...
[09:29:49.871] - result already collected: FutureResult
[09:29:49.872] result() for ClusterFuture ... done
[09:29:49.872]  - Number of value chunks collected: 2
[09:29:49.872] Resolving 2 futures (chunks) ... DONE
[09:29:49.872] Reducing values from 2 chunks ...
[09:29:49.872]  - Number of values collected after concatenation: 10
[09:29:49.872]  - Number of values expected: 10
[09:29:49.872] Reducing values from 2 chunks ... DONE
[09:29:49.872] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[09:29:49.873] future_lapply() ...
[09:29:49.878] Number of chunks: 2
[09:29:49.880] getGlobalsAndPackagesXApply() ...
[09:29:49.880]  - future.globals: TRUE
[09:29:49.880] getGlobalsAndPackages() ...
[09:29:49.880] Searching for globals...
[09:29:49.884] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[09:29:49.884] Searching for globals ... DONE
[09:29:49.884] Resolving globals: FALSE
[09:29:49.885] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[09:29:49.885] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:49.885] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:49.885] - packages: [1] ‘future.apply’
[09:29:49.885] getGlobalsAndPackages() ... DONE
[09:29:49.885]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:49.886]  - needed namespaces: [n=1] ‘future.apply’
[09:29:49.886] Finding globals ... DONE
[09:29:49.886]  - use_args: TRUE
[09:29:49.886]  - Getting '...' globals ...
[09:29:49.886] resolve() on list ...
[09:29:49.886]  recursive: 0
[09:29:49.886]  length: 1
[09:29:49.886]  elements: ‘...’
[09:29:49.887]  length: 0 (resolved future 1)
[09:29:49.887] resolve() on list ... DONE
[09:29:49.887]    - '...' content: [n=0] 
[09:29:49.887] List of 1
[09:29:49.887]  $ ...: list()
[09:29:49.887]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:49.887]  - attr(*, "where")=List of 1
[09:29:49.887]   ..$ ...:<environment: 0x561d394882c0> 
[09:29:49.887]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:49.887]  - attr(*, "resolved")= logi TRUE
[09:29:49.887]  - attr(*, "total_size")= num NA
[09:29:49.889]  - Getting '...' globals ... DONE
[09:29:49.889] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:49.889] List of 8
[09:29:49.889]  $ ...future.FUN:function (x, ...)  
[09:29:49.889]  $ x_FUN        :function (x)  
[09:29:49.889]  $ times        : int 0
[09:29:49.889]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:49.889]  $ stop_if_not  :function (...)  
[09:29:49.889]  $ dim          : NULL
[09:29:49.889]  $ valid_types  : chr [1:2] "logical" "integer"
[09:29:49.889]  $ ...          : list()
[09:29:49.889]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:49.889]  - attr(*, "where")=List of 8
[09:29:49.889]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:49.889]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:49.889]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:49.889]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:49.889]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:49.889]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:49.889]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:49.889]   ..$ ...          :<environment: 0x561d394882c0> 
[09:29:49.889]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:49.889]  - attr(*, "resolved")= logi FALSE
[09:29:49.889]  - attr(*, "total_size")= num 95400
[09:29:49.895] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:49.895] getGlobalsAndPackagesXApply() ... DONE
[09:29:49.895] Number of futures (= number of chunks): 2
[09:29:49.895] Launching 2 futures (chunks) ...
[09:29:49.895] Chunk #1 of 2 ...
[09:29:49.895]  - Finding globals in 'X' for chunk #1 ...
[09:29:49.895] getGlobalsAndPackages() ...
[09:29:49.895] Searching for globals...
[09:29:49.896] 
[09:29:49.896] Searching for globals ... DONE
[09:29:49.896] - globals: [0] <none>
[09:29:49.896] getGlobalsAndPackages() ... DONE
[09:29:49.896]    + additional globals found: [n=0] 
[09:29:49.896]    + additional namespaces needed: [n=0] 
[09:29:49.896]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:49.896]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:49.896]  - seeds: <none>
[09:29:49.897]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.897] getGlobalsAndPackages() ...
[09:29:49.897] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.897] Resolving globals: FALSE
[09:29:49.897] Tweak future expression to call with '...' arguments ...
[09:29:49.897] {
[09:29:49.897]     do.call(function(...) {
[09:29:49.897]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.897]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:49.897]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.897]             on.exit(options(oopts), add = TRUE)
[09:29:49.897]         }
[09:29:49.897]         {
[09:29:49.897]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:49.897]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.897]                 ...future.FUN(...future.X_jj, ...)
[09:29:49.897]             })
[09:29:49.897]         }
[09:29:49.897]     }, args = future.call.arguments)
[09:29:49.897] }
[09:29:49.897] Tweak future expression to call with '...' arguments ... DONE
[09:29:49.898] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:49.898] - packages: [1] ‘future.apply’
[09:29:49.898] getGlobalsAndPackages() ... DONE
[09:29:49.898] run() for ‘Future’ ...
[09:29:49.898] - state: ‘created’
[09:29:49.899] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:49.912] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:49.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:49.913]   - Field: ‘node’
[09:29:49.913]   - Field: ‘label’
[09:29:49.913]   - Field: ‘local’
[09:29:49.913]   - Field: ‘owner’
[09:29:49.913]   - Field: ‘envir’
[09:29:49.913]   - Field: ‘workers’
[09:29:49.913]   - Field: ‘packages’
[09:29:49.913]   - Field: ‘gc’
[09:29:49.913]   - Field: ‘conditions’
[09:29:49.913]   - Field: ‘persistent’
[09:29:49.914]   - Field: ‘expr’
[09:29:49.914]   - Field: ‘uuid’
[09:29:49.914]   - Field: ‘seed’
[09:29:49.914]   - Field: ‘version’
[09:29:49.914]   - Field: ‘result’
[09:29:49.914]   - Field: ‘asynchronous’
[09:29:49.914]   - Field: ‘calls’
[09:29:49.914]   - Field: ‘globals’
[09:29:49.914]   - Field: ‘stdout’
[09:29:49.914]   - Field: ‘earlySignal’
[09:29:49.914]   - Field: ‘lazy’
[09:29:49.914]   - Field: ‘state’
[09:29:49.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:49.915] - Launch lazy future ...
[09:29:49.915] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:49.915] Packages needed by future strategies (n = 0): <none>
[09:29:49.915] {
[09:29:49.915]     {
[09:29:49.915]         {
[09:29:49.915]             ...future.startTime <- base::Sys.time()
[09:29:49.915]             {
[09:29:49.915]                 {
[09:29:49.915]                   {
[09:29:49.915]                     {
[09:29:49.915]                       {
[09:29:49.915]                         base::local({
[09:29:49.915]                           has_future <- base::requireNamespace("future", 
[09:29:49.915]                             quietly = TRUE)
[09:29:49.915]                           if (has_future) {
[09:29:49.915]                             ns <- base::getNamespace("future")
[09:29:49.915]                             version <- ns[[".package"]][["version"]]
[09:29:49.915]                             if (is.null(version)) 
[09:29:49.915]                               version <- utils::packageVersion("future")
[09:29:49.915]                           }
[09:29:49.915]                           else {
[09:29:49.915]                             version <- NULL
[09:29:49.915]                           }
[09:29:49.915]                           if (!has_future || version < "1.8.0") {
[09:29:49.915]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:49.915]                               "", base::R.version$version.string), 
[09:29:49.915]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:49.915]                                 base::R.version$platform, 8 * 
[09:29:49.915]                                   base::.Machine$sizeof.pointer), 
[09:29:49.915]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:49.915]                                 "release", "version")], collapse = " "), 
[09:29:49.915]                               hostname = base::Sys.info()[["nodename"]])
[09:29:49.915]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:49.915]                               info)
[09:29:49.915]                             info <- base::paste(info, collapse = "; ")
[09:29:49.915]                             if (!has_future) {
[09:29:49.915]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:49.915]                                 info)
[09:29:49.915]                             }
[09:29:49.915]                             else {
[09:29:49.915]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:49.915]                                 info, version)
[09:29:49.915]                             }
[09:29:49.915]                             base::stop(msg)
[09:29:49.915]                           }
[09:29:49.915]                         })
[09:29:49.915]                       }
[09:29:49.915]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:49.915]                       base::options(mc.cores = 1L)
[09:29:49.915]                     }
[09:29:49.915]                     base::local({
[09:29:49.915]                       for (pkg in "future.apply") {
[09:29:49.915]                         base::loadNamespace(pkg)
[09:29:49.915]                         base::library(pkg, character.only = TRUE)
[09:29:49.915]                       }
[09:29:49.915]                     })
[09:29:49.915]                   }
[09:29:49.915]                   ...future.strategy.old <- future::plan("list")
[09:29:49.915]                   options(future.plan = NULL)
[09:29:49.915]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:49.915]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:49.915]                 }
[09:29:49.915]                 ...future.workdir <- getwd()
[09:29:49.915]             }
[09:29:49.915]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:49.915]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:49.915]         }
[09:29:49.915]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:49.915]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:49.915]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:49.915]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:49.915]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:49.915]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:49.915]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:49.915]             base::names(...future.oldOptions))
[09:29:49.915]     }
[09:29:49.915]     if (FALSE) {
[09:29:49.915]     }
[09:29:49.915]     else {
[09:29:49.915]         if (TRUE) {
[09:29:49.915]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:49.915]                 open = "w")
[09:29:49.915]         }
[09:29:49.915]         else {
[09:29:49.915]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:49.915]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:49.915]         }
[09:29:49.915]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:49.915]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:49.915]             base::sink(type = "output", split = FALSE)
[09:29:49.915]             base::close(...future.stdout)
[09:29:49.915]         }, add = TRUE)
[09:29:49.915]     }
[09:29:49.915]     ...future.frame <- base::sys.nframe()
[09:29:49.915]     ...future.conditions <- base::list()
[09:29:49.915]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:49.915]     if (FALSE) {
[09:29:49.915]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:49.915]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:49.915]     }
[09:29:49.915]     ...future.result <- base::tryCatch({
[09:29:49.915]         base::withCallingHandlers({
[09:29:49.915]             ...future.value <- base::withVisible(base::local({
[09:29:49.915]                 ...future.makeSendCondition <- base::local({
[09:29:49.915]                   sendCondition <- NULL
[09:29:49.915]                   function(frame = 1L) {
[09:29:49.915]                     if (is.function(sendCondition)) 
[09:29:49.915]                       return(sendCondition)
[09:29:49.915]                     ns <- getNamespace("parallel")
[09:29:49.915]                     if (exists("sendData", mode = "function", 
[09:29:49.915]                       envir = ns)) {
[09:29:49.915]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:49.915]                         envir = ns)
[09:29:49.915]                       envir <- sys.frame(frame)
[09:29:49.915]                       master <- NULL
[09:29:49.915]                       while (!identical(envir, .GlobalEnv) && 
[09:29:49.915]                         !identical(envir, emptyenv())) {
[09:29:49.915]                         if (exists("master", mode = "list", envir = envir, 
[09:29:49.915]                           inherits = FALSE)) {
[09:29:49.915]                           master <- get("master", mode = "list", 
[09:29:49.915]                             envir = envir, inherits = FALSE)
[09:29:49.915]                           if (inherits(master, c("SOCKnode", 
[09:29:49.915]                             "SOCK0node"))) {
[09:29:49.915]                             sendCondition <<- function(cond) {
[09:29:49.915]                               data <- list(type = "VALUE", value = cond, 
[09:29:49.915]                                 success = TRUE)
[09:29:49.915]                               parallel_sendData(master, data)
[09:29:49.915]                             }
[09:29:49.915]                             return(sendCondition)
[09:29:49.915]                           }
[09:29:49.915]                         }
[09:29:49.915]                         frame <- frame + 1L
[09:29:49.915]                         envir <- sys.frame(frame)
[09:29:49.915]                       }
[09:29:49.915]                     }
[09:29:49.915]                     sendCondition <<- function(cond) NULL
[09:29:49.915]                   }
[09:29:49.915]                 })
[09:29:49.915]                 withCallingHandlers({
[09:29:49.915]                   {
[09:29:49.915]                     do.call(function(...) {
[09:29:49.915]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:49.915]                       if (!identical(...future.globals.maxSize.org, 
[09:29:49.915]                         ...future.globals.maxSize)) {
[09:29:49.915]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:49.915]                         on.exit(options(oopts), add = TRUE)
[09:29:49.915]                       }
[09:29:49.915]                       {
[09:29:49.915]                         lapply(seq_along(...future.elements_ii), 
[09:29:49.915]                           FUN = function(jj) {
[09:29:49.915]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:49.915]                             ...future.FUN(...future.X_jj, ...)
[09:29:49.915]                           })
[09:29:49.915]                       }
[09:29:49.915]                     }, args = future.call.arguments)
[09:29:49.915]                   }
[09:29:49.915]                 }, immediateCondition = function(cond) {
[09:29:49.915]                   sendCondition <- ...future.makeSendCondition()
[09:29:49.915]                   sendCondition(cond)
[09:29:49.915]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.915]                   {
[09:29:49.915]                     inherits <- base::inherits
[09:29:49.915]                     invokeRestart <- base::invokeRestart
[09:29:49.915]                     is.null <- base::is.null
[09:29:49.915]                     muffled <- FALSE
[09:29:49.915]                     if (inherits(cond, "message")) {
[09:29:49.915]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:49.915]                       if (muffled) 
[09:29:49.915]                         invokeRestart("muffleMessage")
[09:29:49.915]                     }
[09:29:49.915]                     else if (inherits(cond, "warning")) {
[09:29:49.915]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:49.915]                       if (muffled) 
[09:29:49.915]                         invokeRestart("muffleWarning")
[09:29:49.915]                     }
[09:29:49.915]                     else if (inherits(cond, "condition")) {
[09:29:49.915]                       if (!is.null(pattern)) {
[09:29:49.915]                         computeRestarts <- base::computeRestarts
[09:29:49.915]                         grepl <- base::grepl
[09:29:49.915]                         restarts <- computeRestarts(cond)
[09:29:49.915]                         for (restart in restarts) {
[09:29:49.915]                           name <- restart$name
[09:29:49.915]                           if (is.null(name)) 
[09:29:49.915]                             next
[09:29:49.915]                           if (!grepl(pattern, name)) 
[09:29:49.915]                             next
[09:29:49.915]                           invokeRestart(restart)
[09:29:49.915]                           muffled <- TRUE
[09:29:49.915]                           break
[09:29:49.915]                         }
[09:29:49.915]                       }
[09:29:49.915]                     }
[09:29:49.915]                     invisible(muffled)
[09:29:49.915]                   }
[09:29:49.915]                   muffleCondition(cond)
[09:29:49.915]                 })
[09:29:49.915]             }))
[09:29:49.915]             future::FutureResult(value = ...future.value$value, 
[09:29:49.915]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:49.915]                   ...future.rng), globalenv = if (FALSE) 
[09:29:49.915]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:49.915]                     ...future.globalenv.names))
[09:29:49.915]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:49.915]         }, condition = base::local({
[09:29:49.915]             c <- base::c
[09:29:49.915]             inherits <- base::inherits
[09:29:49.915]             invokeRestart <- base::invokeRestart
[09:29:49.915]             length <- base::length
[09:29:49.915]             list <- base::list
[09:29:49.915]             seq.int <- base::seq.int
[09:29:49.915]             signalCondition <- base::signalCondition
[09:29:49.915]             sys.calls <- base::sys.calls
[09:29:49.915]             `[[` <- base::`[[`
[09:29:49.915]             `+` <- base::`+`
[09:29:49.915]             `<<-` <- base::`<<-`
[09:29:49.915]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:49.915]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:49.915]                   3L)]
[09:29:49.915]             }
[09:29:49.915]             function(cond) {
[09:29:49.915]                 is_error <- inherits(cond, "error")
[09:29:49.915]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:49.915]                   NULL)
[09:29:49.915]                 if (is_error) {
[09:29:49.915]                   sessionInformation <- function() {
[09:29:49.915]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:49.915]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:49.915]                       search = base::search(), system = base::Sys.info())
[09:29:49.915]                   }
[09:29:49.915]                   ...future.conditions[[length(...future.conditions) + 
[09:29:49.915]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:49.915]                     cond$call), session = sessionInformation(), 
[09:29:49.915]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:49.915]                   signalCondition(cond)
[09:29:49.915]                 }
[09:29:49.915]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:49.915]                 "immediateCondition"))) {
[09:29:49.915]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:49.915]                   ...future.conditions[[length(...future.conditions) + 
[09:29:49.915]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:49.915]                   if (TRUE && !signal) {
[09:29:49.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.915]                     {
[09:29:49.915]                       inherits <- base::inherits
[09:29:49.915]                       invokeRestart <- base::invokeRestart
[09:29:49.915]                       is.null <- base::is.null
[09:29:49.915]                       muffled <- FALSE
[09:29:49.915]                       if (inherits(cond, "message")) {
[09:29:49.915]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:49.915]                         if (muffled) 
[09:29:49.915]                           invokeRestart("muffleMessage")
[09:29:49.915]                       }
[09:29:49.915]                       else if (inherits(cond, "warning")) {
[09:29:49.915]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:49.915]                         if (muffled) 
[09:29:49.915]                           invokeRestart("muffleWarning")
[09:29:49.915]                       }
[09:29:49.915]                       else if (inherits(cond, "condition")) {
[09:29:49.915]                         if (!is.null(pattern)) {
[09:29:49.915]                           computeRestarts <- base::computeRestarts
[09:29:49.915]                           grepl <- base::grepl
[09:29:49.915]                           restarts <- computeRestarts(cond)
[09:29:49.915]                           for (restart in restarts) {
[09:29:49.915]                             name <- restart$name
[09:29:49.915]                             if (is.null(name)) 
[09:29:49.915]                               next
[09:29:49.915]                             if (!grepl(pattern, name)) 
[09:29:49.915]                               next
[09:29:49.915]                             invokeRestart(restart)
[09:29:49.915]                             muffled <- TRUE
[09:29:49.915]                             break
[09:29:49.915]                           }
[09:29:49.915]                         }
[09:29:49.915]                       }
[09:29:49.915]                       invisible(muffled)
[09:29:49.915]                     }
[09:29:49.915]                     muffleCondition(cond, pattern = "^muffle")
[09:29:49.915]                   }
[09:29:49.915]                 }
[09:29:49.915]                 else {
[09:29:49.915]                   if (TRUE) {
[09:29:49.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:49.915]                     {
[09:29:49.915]                       inherits <- base::inherits
[09:29:49.915]                       invokeRestart <- base::invokeRestart
[09:29:49.915]                       is.null <- base::is.null
[09:29:49.915]                       muffled <- FALSE
[09:29:49.915]                       if (inherits(cond, "message")) {
[09:29:49.915]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:49.915]                         if (muffled) 
[09:29:49.915]                           invokeRestart("muffleMessage")
[09:29:49.915]                       }
[09:29:49.915]                       else if (inherits(cond, "warning")) {
[09:29:49.915]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:49.915]                         if (muffled) 
[09:29:49.915]                           invokeRestart("muffleWarning")
[09:29:49.915]                       }
[09:29:49.915]                       else if (inherits(cond, "condition")) {
[09:29:49.915]                         if (!is.null(pattern)) {
[09:29:49.915]                           computeRestarts <- base::computeRestarts
[09:29:49.915]                           grepl <- base::grepl
[09:29:49.915]                           restarts <- computeRestarts(cond)
[09:29:49.915]                           for (restart in restarts) {
[09:29:49.915]                             name <- restart$name
[09:29:49.915]                             if (is.null(name)) 
[09:29:49.915]                               next
[09:29:49.915]                             if (!grepl(pattern, name)) 
[09:29:49.915]                               next
[09:29:49.915]                             invokeRestart(restart)
[09:29:49.915]                             muffled <- TRUE
[09:29:49.915]                             break
[09:29:49.915]                           }
[09:29:49.915]                         }
[09:29:49.915]                       }
[09:29:49.915]                       invisible(muffled)
[09:29:49.915]                     }
[09:29:49.915]                     muffleCondition(cond, pattern = "^muffle")
[09:29:49.915]                   }
[09:29:49.915]                 }
[09:29:49.915]             }
[09:29:49.915]         }))
[09:29:49.915]     }, error = function(ex) {
[09:29:49.915]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:49.915]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:49.915]                 ...future.rng), started = ...future.startTime, 
[09:29:49.915]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:49.915]             version = "1.8"), class = "FutureResult")
[09:29:49.915]     }, finally = {
[09:29:49.915]         if (!identical(...future.workdir, getwd())) 
[09:29:49.915]             setwd(...future.workdir)
[09:29:49.915]         {
[09:29:49.915]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:49.915]                 ...future.oldOptions$nwarnings <- NULL
[09:29:49.915]             }
[09:29:49.915]             base::options(...future.oldOptions)
[09:29:49.915]             if (.Platform$OS.type == "windows") {
[09:29:49.915]                 old_names <- names(...future.oldEnvVars)
[09:29:49.915]                 envs <- base::Sys.getenv()
[09:29:49.915]                 names <- names(envs)
[09:29:49.915]                 common <- intersect(names, old_names)
[09:29:49.915]                 added <- setdiff(names, old_names)
[09:29:49.915]                 removed <- setdiff(old_names, names)
[09:29:49.915]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:49.915]                   envs[common]]
[09:29:49.915]                 NAMES <- toupper(changed)
[09:29:49.915]                 args <- list()
[09:29:49.915]                 for (kk in seq_along(NAMES)) {
[09:29:49.915]                   name <- changed[[kk]]
[09:29:49.915]                   NAME <- NAMES[[kk]]
[09:29:49.915]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.915]                     next
[09:29:49.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:49.915]                 }
[09:29:49.915]                 NAMES <- toupper(added)
[09:29:49.915]                 for (kk in seq_along(NAMES)) {
[09:29:49.915]                   name <- added[[kk]]
[09:29:49.915]                   NAME <- NAMES[[kk]]
[09:29:49.915]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.915]                     next
[09:29:49.915]                   args[[name]] <- ""
[09:29:49.915]                 }
[09:29:49.915]                 NAMES <- toupper(removed)
[09:29:49.915]                 for (kk in seq_along(NAMES)) {
[09:29:49.915]                   name <- removed[[kk]]
[09:29:49.915]                   NAME <- NAMES[[kk]]
[09:29:49.915]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:49.915]                     next
[09:29:49.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:49.915]                 }
[09:29:49.915]                 if (length(args) > 0) 
[09:29:49.915]                   base::do.call(base::Sys.setenv, args = args)
[09:29:49.915]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:49.915]             }
[09:29:49.915]             else {
[09:29:49.915]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:49.915]             }
[09:29:49.915]             {
[09:29:49.915]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:49.915]                   0L) {
[09:29:49.915]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:49.915]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:49.915]                   base::options(opts)
[09:29:49.915]                 }
[09:29:49.915]                 {
[09:29:49.915]                   {
[09:29:49.915]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:49.915]                     NULL
[09:29:49.915]                   }
[09:29:49.915]                   options(future.plan = NULL)
[09:29:49.915]                   if (is.na(NA_character_)) 
[09:29:49.915]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:49.915]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:49.915]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:49.915]                     .init = FALSE)
[09:29:49.915]                 }
[09:29:49.915]             }
[09:29:49.915]         }
[09:29:49.915]     })
[09:29:49.915]     if (TRUE) {
[09:29:49.915]         base::sink(type = "output", split = FALSE)
[09:29:49.915]         if (TRUE) {
[09:29:49.915]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:49.915]         }
[09:29:49.915]         else {
[09:29:49.915]             ...future.result["stdout"] <- base::list(NULL)
[09:29:49.915]         }
[09:29:49.915]         base::close(...future.stdout)
[09:29:49.915]         ...future.stdout <- NULL
[09:29:49.915]     }
[09:29:49.915]     ...future.result$conditions <- ...future.conditions
[09:29:49.915]     ...future.result$finished <- base::Sys.time()
[09:29:49.915]     ...future.result
[09:29:49.915] }
[09:29:49.918] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[09:29:49.918] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:49.960] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:49.960] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[09:29:49.961] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[09:29:49.961] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:49.961] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:49.961] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:50.004] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:50.004] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:50.048] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:50.048] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:50.049] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.049] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[09:29:50.049] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[09:29:50.049] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:50.050] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.050] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:50.050] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:50.050] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:50.051] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.051] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:50.051] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.051] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[09:29:50.052] MultisessionFuture started
[09:29:50.052] - Launch lazy future ... done
[09:29:50.052] run() for ‘MultisessionFuture’ ... done
[09:29:50.052] Created future:
[09:29:50.052] MultisessionFuture:
[09:29:50.052] Label: ‘future_vapply-1’
[09:29:50.052] Expression:
[09:29:50.052] {
[09:29:50.052]     do.call(function(...) {
[09:29:50.052]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.052]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:50.052]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.052]             on.exit(options(oopts), add = TRUE)
[09:29:50.052]         }
[09:29:50.052]         {
[09:29:50.052]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:50.052]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.052]                 ...future.FUN(...future.X_jj, ...)
[09:29:50.052]             })
[09:29:50.052]         }
[09:29:50.052]     }, args = future.call.arguments)
[09:29:50.052] }
[09:29:50.052] Lazy evaluation: FALSE
[09:29:50.052] Asynchronous evaluation: TRUE
[09:29:50.052] Local evaluation: TRUE
[09:29:50.052] Environment: R_GlobalEnv
[09:29:50.052] Capture standard output: TRUE
[09:29:50.052] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:50.052] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:50.052] Packages: 1 packages (‘future.apply’)
[09:29:50.052] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:50.052] Resolved: FALSE
[09:29:50.052] Value: <not collected>
[09:29:50.052] Conditions captured: <none>
[09:29:50.052] Early signaling: FALSE
[09:29:50.052] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:50.052] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:50.064] Chunk #1 of 2 ... DONE
[09:29:50.064] Chunk #2 of 2 ...
[09:29:50.064]  - Finding globals in 'X' for chunk #2 ...
[09:29:50.064] getGlobalsAndPackages() ...
[09:29:50.065] Searching for globals...
[09:29:50.065] 
[09:29:50.065] Searching for globals ... DONE
[09:29:50.065] - globals: [0] <none>
[09:29:50.065] getGlobalsAndPackages() ... DONE
[09:29:50.065]    + additional globals found: [n=0] 
[09:29:50.065]    + additional namespaces needed: [n=0] 
[09:29:50.065]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:50.065]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:50.065]  - seeds: <none>
[09:29:50.066]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.066] getGlobalsAndPackages() ...
[09:29:50.066] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.066] Resolving globals: FALSE
[09:29:50.066] Tweak future expression to call with '...' arguments ...
[09:29:50.066] {
[09:29:50.066]     do.call(function(...) {
[09:29:50.066]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.066]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:50.066]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.066]             on.exit(options(oopts), add = TRUE)
[09:29:50.066]         }
[09:29:50.066]         {
[09:29:50.066]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:50.066]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.066]                 ...future.FUN(...future.X_jj, ...)
[09:29:50.066]             })
[09:29:50.066]         }
[09:29:50.066]     }, args = future.call.arguments)
[09:29:50.066] }
[09:29:50.066] Tweak future expression to call with '...' arguments ... DONE
[09:29:50.067] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.067] - packages: [1] ‘future.apply’
[09:29:50.067] getGlobalsAndPackages() ... DONE
[09:29:50.067] run() for ‘Future’ ...
[09:29:50.067] - state: ‘created’
[09:29:50.067] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:50.081] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:50.082] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:50.082]   - Field: ‘node’
[09:29:50.082]   - Field: ‘label’
[09:29:50.082]   - Field: ‘local’
[09:29:50.082]   - Field: ‘owner’
[09:29:50.082]   - Field: ‘envir’
[09:29:50.082]   - Field: ‘workers’
[09:29:50.082]   - Field: ‘packages’
[09:29:50.082]   - Field: ‘gc’
[09:29:50.082]   - Field: ‘conditions’
[09:29:50.082]   - Field: ‘persistent’
[09:29:50.083]   - Field: ‘expr’
[09:29:50.083]   - Field: ‘uuid’
[09:29:50.083]   - Field: ‘seed’
[09:29:50.083]   - Field: ‘version’
[09:29:50.083]   - Field: ‘result’
[09:29:50.083]   - Field: ‘asynchronous’
[09:29:50.083]   - Field: ‘calls’
[09:29:50.083]   - Field: ‘globals’
[09:29:50.083]   - Field: ‘stdout’
[09:29:50.083]   - Field: ‘earlySignal’
[09:29:50.084]   - Field: ‘lazy’
[09:29:50.084]   - Field: ‘state’
[09:29:50.084] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:50.084] - Launch lazy future ...
[09:29:50.084] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:50.084] Packages needed by future strategies (n = 0): <none>
[09:29:50.085] {
[09:29:50.085]     {
[09:29:50.085]         {
[09:29:50.085]             ...future.startTime <- base::Sys.time()
[09:29:50.085]             {
[09:29:50.085]                 {
[09:29:50.085]                   {
[09:29:50.085]                     {
[09:29:50.085]                       {
[09:29:50.085]                         base::local({
[09:29:50.085]                           has_future <- base::requireNamespace("future", 
[09:29:50.085]                             quietly = TRUE)
[09:29:50.085]                           if (has_future) {
[09:29:50.085]                             ns <- base::getNamespace("future")
[09:29:50.085]                             version <- ns[[".package"]][["version"]]
[09:29:50.085]                             if (is.null(version)) 
[09:29:50.085]                               version <- utils::packageVersion("future")
[09:29:50.085]                           }
[09:29:50.085]                           else {
[09:29:50.085]                             version <- NULL
[09:29:50.085]                           }
[09:29:50.085]                           if (!has_future || version < "1.8.0") {
[09:29:50.085]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:50.085]                               "", base::R.version$version.string), 
[09:29:50.085]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:50.085]                                 base::R.version$platform, 8 * 
[09:29:50.085]                                   base::.Machine$sizeof.pointer), 
[09:29:50.085]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:50.085]                                 "release", "version")], collapse = " "), 
[09:29:50.085]                               hostname = base::Sys.info()[["nodename"]])
[09:29:50.085]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:50.085]                               info)
[09:29:50.085]                             info <- base::paste(info, collapse = "; ")
[09:29:50.085]                             if (!has_future) {
[09:29:50.085]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:50.085]                                 info)
[09:29:50.085]                             }
[09:29:50.085]                             else {
[09:29:50.085]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:50.085]                                 info, version)
[09:29:50.085]                             }
[09:29:50.085]                             base::stop(msg)
[09:29:50.085]                           }
[09:29:50.085]                         })
[09:29:50.085]                       }
[09:29:50.085]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:50.085]                       base::options(mc.cores = 1L)
[09:29:50.085]                     }
[09:29:50.085]                     base::local({
[09:29:50.085]                       for (pkg in "future.apply") {
[09:29:50.085]                         base::loadNamespace(pkg)
[09:29:50.085]                         base::library(pkg, character.only = TRUE)
[09:29:50.085]                       }
[09:29:50.085]                     })
[09:29:50.085]                   }
[09:29:50.085]                   ...future.strategy.old <- future::plan("list")
[09:29:50.085]                   options(future.plan = NULL)
[09:29:50.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:50.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:50.085]                 }
[09:29:50.085]                 ...future.workdir <- getwd()
[09:29:50.085]             }
[09:29:50.085]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:50.085]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:50.085]         }
[09:29:50.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:50.085]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:50.085]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:50.085]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:50.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:50.085]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:50.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:50.085]             base::names(...future.oldOptions))
[09:29:50.085]     }
[09:29:50.085]     if (FALSE) {
[09:29:50.085]     }
[09:29:50.085]     else {
[09:29:50.085]         if (TRUE) {
[09:29:50.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:50.085]                 open = "w")
[09:29:50.085]         }
[09:29:50.085]         else {
[09:29:50.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:50.085]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:50.085]         }
[09:29:50.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:50.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:50.085]             base::sink(type = "output", split = FALSE)
[09:29:50.085]             base::close(...future.stdout)
[09:29:50.085]         }, add = TRUE)
[09:29:50.085]     }
[09:29:50.085]     ...future.frame <- base::sys.nframe()
[09:29:50.085]     ...future.conditions <- base::list()
[09:29:50.085]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:50.085]     if (FALSE) {
[09:29:50.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:50.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:50.085]     }
[09:29:50.085]     ...future.result <- base::tryCatch({
[09:29:50.085]         base::withCallingHandlers({
[09:29:50.085]             ...future.value <- base::withVisible(base::local({
[09:29:50.085]                 ...future.makeSendCondition <- base::local({
[09:29:50.085]                   sendCondition <- NULL
[09:29:50.085]                   function(frame = 1L) {
[09:29:50.085]                     if (is.function(sendCondition)) 
[09:29:50.085]                       return(sendCondition)
[09:29:50.085]                     ns <- getNamespace("parallel")
[09:29:50.085]                     if (exists("sendData", mode = "function", 
[09:29:50.085]                       envir = ns)) {
[09:29:50.085]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:50.085]                         envir = ns)
[09:29:50.085]                       envir <- sys.frame(frame)
[09:29:50.085]                       master <- NULL
[09:29:50.085]                       while (!identical(envir, .GlobalEnv) && 
[09:29:50.085]                         !identical(envir, emptyenv())) {
[09:29:50.085]                         if (exists("master", mode = "list", envir = envir, 
[09:29:50.085]                           inherits = FALSE)) {
[09:29:50.085]                           master <- get("master", mode = "list", 
[09:29:50.085]                             envir = envir, inherits = FALSE)
[09:29:50.085]                           if (inherits(master, c("SOCKnode", 
[09:29:50.085]                             "SOCK0node"))) {
[09:29:50.085]                             sendCondition <<- function(cond) {
[09:29:50.085]                               data <- list(type = "VALUE", value = cond, 
[09:29:50.085]                                 success = TRUE)
[09:29:50.085]                               parallel_sendData(master, data)
[09:29:50.085]                             }
[09:29:50.085]                             return(sendCondition)
[09:29:50.085]                           }
[09:29:50.085]                         }
[09:29:50.085]                         frame <- frame + 1L
[09:29:50.085]                         envir <- sys.frame(frame)
[09:29:50.085]                       }
[09:29:50.085]                     }
[09:29:50.085]                     sendCondition <<- function(cond) NULL
[09:29:50.085]                   }
[09:29:50.085]                 })
[09:29:50.085]                 withCallingHandlers({
[09:29:50.085]                   {
[09:29:50.085]                     do.call(function(...) {
[09:29:50.085]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.085]                       if (!identical(...future.globals.maxSize.org, 
[09:29:50.085]                         ...future.globals.maxSize)) {
[09:29:50.085]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.085]                         on.exit(options(oopts), add = TRUE)
[09:29:50.085]                       }
[09:29:50.085]                       {
[09:29:50.085]                         lapply(seq_along(...future.elements_ii), 
[09:29:50.085]                           FUN = function(jj) {
[09:29:50.085]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.085]                             ...future.FUN(...future.X_jj, ...)
[09:29:50.085]                           })
[09:29:50.085]                       }
[09:29:50.085]                     }, args = future.call.arguments)
[09:29:50.085]                   }
[09:29:50.085]                 }, immediateCondition = function(cond) {
[09:29:50.085]                   sendCondition <- ...future.makeSendCondition()
[09:29:50.085]                   sendCondition(cond)
[09:29:50.085]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.085]                   {
[09:29:50.085]                     inherits <- base::inherits
[09:29:50.085]                     invokeRestart <- base::invokeRestart
[09:29:50.085]                     is.null <- base::is.null
[09:29:50.085]                     muffled <- FALSE
[09:29:50.085]                     if (inherits(cond, "message")) {
[09:29:50.085]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:50.085]                       if (muffled) 
[09:29:50.085]                         invokeRestart("muffleMessage")
[09:29:50.085]                     }
[09:29:50.085]                     else if (inherits(cond, "warning")) {
[09:29:50.085]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:50.085]                       if (muffled) 
[09:29:50.085]                         invokeRestart("muffleWarning")
[09:29:50.085]                     }
[09:29:50.085]                     else if (inherits(cond, "condition")) {
[09:29:50.085]                       if (!is.null(pattern)) {
[09:29:50.085]                         computeRestarts <- base::computeRestarts
[09:29:50.085]                         grepl <- base::grepl
[09:29:50.085]                         restarts <- computeRestarts(cond)
[09:29:50.085]                         for (restart in restarts) {
[09:29:50.085]                           name <- restart$name
[09:29:50.085]                           if (is.null(name)) 
[09:29:50.085]                             next
[09:29:50.085]                           if (!grepl(pattern, name)) 
[09:29:50.085]                             next
[09:29:50.085]                           invokeRestart(restart)
[09:29:50.085]                           muffled <- TRUE
[09:29:50.085]                           break
[09:29:50.085]                         }
[09:29:50.085]                       }
[09:29:50.085]                     }
[09:29:50.085]                     invisible(muffled)
[09:29:50.085]                   }
[09:29:50.085]                   muffleCondition(cond)
[09:29:50.085]                 })
[09:29:50.085]             }))
[09:29:50.085]             future::FutureResult(value = ...future.value$value, 
[09:29:50.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:50.085]                   ...future.rng), globalenv = if (FALSE) 
[09:29:50.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:50.085]                     ...future.globalenv.names))
[09:29:50.085]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:50.085]         }, condition = base::local({
[09:29:50.085]             c <- base::c
[09:29:50.085]             inherits <- base::inherits
[09:29:50.085]             invokeRestart <- base::invokeRestart
[09:29:50.085]             length <- base::length
[09:29:50.085]             list <- base::list
[09:29:50.085]             seq.int <- base::seq.int
[09:29:50.085]             signalCondition <- base::signalCondition
[09:29:50.085]             sys.calls <- base::sys.calls
[09:29:50.085]             `[[` <- base::`[[`
[09:29:50.085]             `+` <- base::`+`
[09:29:50.085]             `<<-` <- base::`<<-`
[09:29:50.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:50.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:50.085]                   3L)]
[09:29:50.085]             }
[09:29:50.085]             function(cond) {
[09:29:50.085]                 is_error <- inherits(cond, "error")
[09:29:50.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:50.085]                   NULL)
[09:29:50.085]                 if (is_error) {
[09:29:50.085]                   sessionInformation <- function() {
[09:29:50.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:50.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:50.085]                       search = base::search(), system = base::Sys.info())
[09:29:50.085]                   }
[09:29:50.085]                   ...future.conditions[[length(...future.conditions) + 
[09:29:50.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:50.085]                     cond$call), session = sessionInformation(), 
[09:29:50.085]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:50.085]                   signalCondition(cond)
[09:29:50.085]                 }
[09:29:50.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:50.085]                 "immediateCondition"))) {
[09:29:50.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:50.085]                   ...future.conditions[[length(...future.conditions) + 
[09:29:50.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:50.085]                   if (TRUE && !signal) {
[09:29:50.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.085]                     {
[09:29:50.085]                       inherits <- base::inherits
[09:29:50.085]                       invokeRestart <- base::invokeRestart
[09:29:50.085]                       is.null <- base::is.null
[09:29:50.085]                       muffled <- FALSE
[09:29:50.085]                       if (inherits(cond, "message")) {
[09:29:50.085]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:50.085]                         if (muffled) 
[09:29:50.085]                           invokeRestart("muffleMessage")
[09:29:50.085]                       }
[09:29:50.085]                       else if (inherits(cond, "warning")) {
[09:29:50.085]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:50.085]                         if (muffled) 
[09:29:50.085]                           invokeRestart("muffleWarning")
[09:29:50.085]                       }
[09:29:50.085]                       else if (inherits(cond, "condition")) {
[09:29:50.085]                         if (!is.null(pattern)) {
[09:29:50.085]                           computeRestarts <- base::computeRestarts
[09:29:50.085]                           grepl <- base::grepl
[09:29:50.085]                           restarts <- computeRestarts(cond)
[09:29:50.085]                           for (restart in restarts) {
[09:29:50.085]                             name <- restart$name
[09:29:50.085]                             if (is.null(name)) 
[09:29:50.085]                               next
[09:29:50.085]                             if (!grepl(pattern, name)) 
[09:29:50.085]                               next
[09:29:50.085]                             invokeRestart(restart)
[09:29:50.085]                             muffled <- TRUE
[09:29:50.085]                             break
[09:29:50.085]                           }
[09:29:50.085]                         }
[09:29:50.085]                       }
[09:29:50.085]                       invisible(muffled)
[09:29:50.085]                     }
[09:29:50.085]                     muffleCondition(cond, pattern = "^muffle")
[09:29:50.085]                   }
[09:29:50.085]                 }
[09:29:50.085]                 else {
[09:29:50.085]                   if (TRUE) {
[09:29:50.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.085]                     {
[09:29:50.085]                       inherits <- base::inherits
[09:29:50.085]                       invokeRestart <- base::invokeRestart
[09:29:50.085]                       is.null <- base::is.null
[09:29:50.085]                       muffled <- FALSE
[09:29:50.085]                       if (inherits(cond, "message")) {
[09:29:50.085]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:50.085]                         if (muffled) 
[09:29:50.085]                           invokeRestart("muffleMessage")
[09:29:50.085]                       }
[09:29:50.085]                       else if (inherits(cond, "warning")) {
[09:29:50.085]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:50.085]                         if (muffled) 
[09:29:50.085]                           invokeRestart("muffleWarning")
[09:29:50.085]                       }
[09:29:50.085]                       else if (inherits(cond, "condition")) {
[09:29:50.085]                         if (!is.null(pattern)) {
[09:29:50.085]                           computeRestarts <- base::computeRestarts
[09:29:50.085]                           grepl <- base::grepl
[09:29:50.085]                           restarts <- computeRestarts(cond)
[09:29:50.085]                           for (restart in restarts) {
[09:29:50.085]                             name <- restart$name
[09:29:50.085]                             if (is.null(name)) 
[09:29:50.085]                               next
[09:29:50.085]                             if (!grepl(pattern, name)) 
[09:29:50.085]                               next
[09:29:50.085]                             invokeRestart(restart)
[09:29:50.085]                             muffled <- TRUE
[09:29:50.085]                             break
[09:29:50.085]                           }
[09:29:50.085]                         }
[09:29:50.085]                       }
[09:29:50.085]                       invisible(muffled)
[09:29:50.085]                     }
[09:29:50.085]                     muffleCondition(cond, pattern = "^muffle")
[09:29:50.085]                   }
[09:29:50.085]                 }
[09:29:50.085]             }
[09:29:50.085]         }))
[09:29:50.085]     }, error = function(ex) {
[09:29:50.085]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:50.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:50.085]                 ...future.rng), started = ...future.startTime, 
[09:29:50.085]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:50.085]             version = "1.8"), class = "FutureResult")
[09:29:50.085]     }, finally = {
[09:29:50.085]         if (!identical(...future.workdir, getwd())) 
[09:29:50.085]             setwd(...future.workdir)
[09:29:50.085]         {
[09:29:50.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:50.085]                 ...future.oldOptions$nwarnings <- NULL
[09:29:50.085]             }
[09:29:50.085]             base::options(...future.oldOptions)
[09:29:50.085]             if (.Platform$OS.type == "windows") {
[09:29:50.085]                 old_names <- names(...future.oldEnvVars)
[09:29:50.085]                 envs <- base::Sys.getenv()
[09:29:50.085]                 names <- names(envs)
[09:29:50.085]                 common <- intersect(names, old_names)
[09:29:50.085]                 added <- setdiff(names, old_names)
[09:29:50.085]                 removed <- setdiff(old_names, names)
[09:29:50.085]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:50.085]                   envs[common]]
[09:29:50.085]                 NAMES <- toupper(changed)
[09:29:50.085]                 args <- list()
[09:29:50.085]                 for (kk in seq_along(NAMES)) {
[09:29:50.085]                   name <- changed[[kk]]
[09:29:50.085]                   NAME <- NAMES[[kk]]
[09:29:50.085]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.085]                     next
[09:29:50.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:50.085]                 }
[09:29:50.085]                 NAMES <- toupper(added)
[09:29:50.085]                 for (kk in seq_along(NAMES)) {
[09:29:50.085]                   name <- added[[kk]]
[09:29:50.085]                   NAME <- NAMES[[kk]]
[09:29:50.085]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.085]                     next
[09:29:50.085]                   args[[name]] <- ""
[09:29:50.085]                 }
[09:29:50.085]                 NAMES <- toupper(removed)
[09:29:50.085]                 for (kk in seq_along(NAMES)) {
[09:29:50.085]                   name <- removed[[kk]]
[09:29:50.085]                   NAME <- NAMES[[kk]]
[09:29:50.085]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.085]                     next
[09:29:50.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:50.085]                 }
[09:29:50.085]                 if (length(args) > 0) 
[09:29:50.085]                   base::do.call(base::Sys.setenv, args = args)
[09:29:50.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:50.085]             }
[09:29:50.085]             else {
[09:29:50.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:50.085]             }
[09:29:50.085]             {
[09:29:50.085]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:50.085]                   0L) {
[09:29:50.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:50.085]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:50.085]                   base::options(opts)
[09:29:50.085]                 }
[09:29:50.085]                 {
[09:29:50.085]                   {
[09:29:50.085]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:50.085]                     NULL
[09:29:50.085]                   }
[09:29:50.085]                   options(future.plan = NULL)
[09:29:50.085]                   if (is.na(NA_character_)) 
[09:29:50.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:50.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:50.085]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:50.085]                     .init = FALSE)
[09:29:50.085]                 }
[09:29:50.085]             }
[09:29:50.085]         }
[09:29:50.085]     })
[09:29:50.085]     if (TRUE) {
[09:29:50.085]         base::sink(type = "output", split = FALSE)
[09:29:50.085]         if (TRUE) {
[09:29:50.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:50.085]         }
[09:29:50.085]         else {
[09:29:50.085]             ...future.result["stdout"] <- base::list(NULL)
[09:29:50.085]         }
[09:29:50.085]         base::close(...future.stdout)
[09:29:50.085]         ...future.stdout <- NULL
[09:29:50.085]     }
[09:29:50.085]     ...future.result$conditions <- ...future.conditions
[09:29:50.085]     ...future.result$finished <- base::Sys.time()
[09:29:50.085]     ...future.result
[09:29:50.085] }
[09:29:50.087] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[09:29:50.088] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[09:29:50.128] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[09:29:50.128] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[09:29:50.129] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[09:29:50.129] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[09:29:50.129] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[09:29:50.129] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[09:29:50.172] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[09:29:50.172] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[09:29:50.216] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[09:29:50.216] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[09:29:50.217] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[09:29:50.217] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[09:29:50.217] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[09:29:50.217] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:29:50.218] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:29:50.218] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[09:29:50.218] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[09:29:50.218] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:50.219] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:50.219] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:50.219] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:50.219] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[09:29:50.220] MultisessionFuture started
[09:29:50.220] - Launch lazy future ... done
[09:29:50.220] run() for ‘MultisessionFuture’ ... done
[09:29:50.220] Created future:
[09:29:50.221] MultisessionFuture:
[09:29:50.221] Label: ‘future_vapply-2’
[09:29:50.221] Expression:
[09:29:50.221] {
[09:29:50.221]     do.call(function(...) {
[09:29:50.221]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.221]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:50.221]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.221]             on.exit(options(oopts), add = TRUE)
[09:29:50.221]         }
[09:29:50.221]         {
[09:29:50.221]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:50.221]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.221]                 ...future.FUN(...future.X_jj, ...)
[09:29:50.221]             })
[09:29:50.221]         }
[09:29:50.221]     }, args = future.call.arguments)
[09:29:50.221] }
[09:29:50.221] Lazy evaluation: FALSE
[09:29:50.221] Asynchronous evaluation: TRUE
[09:29:50.221] Local evaluation: TRUE
[09:29:50.221] Environment: R_GlobalEnv
[09:29:50.221] Capture standard output: TRUE
[09:29:50.221] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:50.221] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:50.221] Packages: 1 packages (‘future.apply’)
[09:29:50.221] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:50.221] Resolved: FALSE
[09:29:50.221] Value: <not collected>
[09:29:50.221] Conditions captured: <none>
[09:29:50.221] Early signaling: FALSE
[09:29:50.221] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:50.221] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:50.232] Chunk #2 of 2 ... DONE
[09:29:50.232] Launching 2 futures (chunks) ... DONE
[09:29:50.232] Resolving 2 futures (chunks) ...
[09:29:50.233] resolve() on list ...
[09:29:50.233]  recursive: 0
[09:29:50.233]  length: 2
[09:29:50.233] 
[09:29:50.233] receiveMessageFromWorker() for ClusterFuture ...
[09:29:50.233] - Validating connection of MultisessionFuture
[09:29:50.234] - received message: FutureResult
[09:29:50.234] - Received FutureResult
[09:29:50.234] - Erased future from FutureRegistry
[09:29:50.234] result() for ClusterFuture ...
[09:29:50.234] - result already collected: FutureResult
[09:29:50.234] result() for ClusterFuture ... done
[09:29:50.234] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:50.234] Future #1
[09:29:50.234] result() for ClusterFuture ...
[09:29:50.234] - result already collected: FutureResult
[09:29:50.235] result() for ClusterFuture ... done
[09:29:50.235] result() for ClusterFuture ...
[09:29:50.235] - result already collected: FutureResult
[09:29:50.235] result() for ClusterFuture ... done
[09:29:50.235] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:50.235] - nx: 2
[09:29:50.235] - relay: TRUE
[09:29:50.235] - stdout: TRUE
[09:29:50.235] - signal: TRUE
[09:29:50.235] - resignal: FALSE
[09:29:50.235] - force: TRUE
[09:29:50.235] - relayed: [n=2] FALSE, FALSE
[09:29:50.236] - queued futures: [n=2] FALSE, FALSE
[09:29:50.236]  - until=1
[09:29:50.236]  - relaying element #1
[09:29:50.236] result() for ClusterFuture ...
[09:29:50.236] - result already collected: FutureResult
[09:29:50.236] result() for ClusterFuture ... done
[09:29:50.236] result() for ClusterFuture ...
[09:29:50.236] - result already collected: FutureResult
[09:29:50.236] result() for ClusterFuture ... done
[09:29:50.236] result() for ClusterFuture ...
[09:29:50.236] - result already collected: FutureResult
[09:29:50.237] result() for ClusterFuture ... done
[09:29:50.237] result() for ClusterFuture ...
[09:29:50.237] - result already collected: FutureResult
[09:29:50.237] result() for ClusterFuture ... done
[09:29:50.237] - relayed: [n=2] TRUE, FALSE
[09:29:50.237] - queued futures: [n=2] TRUE, FALSE
[09:29:50.237] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:50.237]  length: 1 (resolved future 1)
[09:29:50.265] receiveMessageFromWorker() for ClusterFuture ...
[09:29:50.266] - Validating connection of MultisessionFuture
[09:29:50.266] - received message: FutureResult
[09:29:50.266] - Received FutureResult
[09:29:50.266] - Erased future from FutureRegistry
[09:29:50.266] result() for ClusterFuture ...
[09:29:50.266] - result already collected: FutureResult
[09:29:50.266] result() for ClusterFuture ... done
[09:29:50.266] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:50.266] Future #2
[09:29:50.267] result() for ClusterFuture ...
[09:29:50.267] - result already collected: FutureResult
[09:29:50.267] result() for ClusterFuture ... done
[09:29:50.267] result() for ClusterFuture ...
[09:29:50.267] - result already collected: FutureResult
[09:29:50.267] result() for ClusterFuture ... done
[09:29:50.267] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:50.267] - nx: 2
[09:29:50.267] - relay: TRUE
[09:29:50.267] - stdout: TRUE
[09:29:50.267] - signal: TRUE
[09:29:50.267] - resignal: FALSE
[09:29:50.268] - force: TRUE
[09:29:50.268] - relayed: [n=2] TRUE, FALSE
[09:29:50.268] - queued futures: [n=2] TRUE, FALSE
[09:29:50.268]  - until=2
[09:29:50.268]  - relaying element #2
[09:29:50.268] result() for ClusterFuture ...
[09:29:50.268] - result already collected: FutureResult
[09:29:50.268] result() for ClusterFuture ... done
[09:29:50.268] result() for ClusterFuture ...
[09:29:50.268] - result already collected: FutureResult
[09:29:50.268] result() for ClusterFuture ... done
[09:29:50.269] result() for ClusterFuture ...
[09:29:50.269] - result already collected: FutureResult
[09:29:50.269] result() for ClusterFuture ... done
[09:29:50.269] result() for ClusterFuture ...
[09:29:50.269] - result already collected: FutureResult
[09:29:50.269] result() for ClusterFuture ... done
[09:29:50.269] - relayed: [n=2] TRUE, TRUE
[09:29:50.269] - queued futures: [n=2] TRUE, TRUE
[09:29:50.269] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:50.269]  length: 0 (resolved future 2)
[09:29:50.269] Relaying remaining futures
[09:29:50.269] signalConditionsASAP(NULL, pos=0) ...
[09:29:50.270] - nx: 2
[09:29:50.270] - relay: TRUE
[09:29:50.270] - stdout: TRUE
[09:29:50.270] - signal: TRUE
[09:29:50.270] - resignal: FALSE
[09:29:50.270] - force: TRUE
[09:29:50.270] - relayed: [n=2] TRUE, TRUE
[09:29:50.270] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:50.270] - relayed: [n=2] TRUE, TRUE
[09:29:50.270] - queued futures: [n=2] TRUE, TRUE
[09:29:50.270] signalConditionsASAP(NULL, pos=0) ... done
[09:29:50.270] resolve() on list ... DONE
[09:29:50.271] result() for ClusterFuture ...
[09:29:50.271] - result already collected: FutureResult
[09:29:50.271] result() for ClusterFuture ... done
[09:29:50.271] result() for ClusterFuture ...
[09:29:50.271] - result already collected: FutureResult
[09:29:50.271] result() for ClusterFuture ... done
[09:29:50.271] result() for ClusterFuture ...
[09:29:50.271] - result already collected: FutureResult
[09:29:50.271] result() for ClusterFuture ... done
[09:29:50.271] result() for ClusterFuture ...
[09:29:50.271] - result already collected: FutureResult
[09:29:50.271] result() for ClusterFuture ... done
[09:29:50.272]  - Number of value chunks collected: 2
[09:29:50.272] Resolving 2 futures (chunks) ... DONE
[09:29:50.272] Reducing values from 2 chunks ...
[09:29:50.272]  - Number of values collected after concatenation: 10
[09:29:50.272]  - Number of values expected: 10
[09:29:50.272] Reducing values from 2 chunks ... DONE
[09:29:50.272] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[09:29:50.273] future_lapply() ...
[09:29:50.278] Number of chunks: 2
[09:29:50.278] getGlobalsAndPackagesXApply() ...
[09:29:50.278]  - future.globals: TRUE
[09:29:50.278] getGlobalsAndPackages() ...
[09:29:50.279] Searching for globals...
[09:29:50.281] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:50.282] Searching for globals ... DONE
[09:29:50.282] Resolving globals: FALSE
[09:29:50.283] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[09:29:50.283] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:50.283] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:50.283] - packages: [1] ‘future.apply’
[09:29:50.283] getGlobalsAndPackages() ... DONE
[09:29:50.283]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:50.283]  - needed namespaces: [n=1] ‘future.apply’
[09:29:50.284] Finding globals ... DONE
[09:29:50.284]  - use_args: TRUE
[09:29:50.284]  - Getting '...' globals ...
[09:29:50.284] resolve() on list ...
[09:29:50.284]  recursive: 0
[09:29:50.284]  length: 1
[09:29:50.284]  elements: ‘...’
[09:29:50.284]  length: 0 (resolved future 1)
[09:29:50.285] resolve() on list ... DONE
[09:29:50.285]    - '...' content: [n=0] 
[09:29:50.285] List of 1
[09:29:50.285]  $ ...: list()
[09:29:50.285]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:50.285]  - attr(*, "where")=List of 1
[09:29:50.285]   ..$ ...:<environment: 0x561d3898e8e8> 
[09:29:50.285]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:50.285]  - attr(*, "resolved")= logi TRUE
[09:29:50.285]  - attr(*, "total_size")= num NA
[09:29:50.287]  - Getting '...' globals ... DONE
[09:29:50.287] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:50.287] List of 8
[09:29:50.287]  $ ...future.FUN:function (x, ...)  
[09:29:50.287]  $ x_FUN        :function (x)  
[09:29:50.287]  $ times        : int 1
[09:29:50.287]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:50.287]  $ stop_if_not  :function (...)  
[09:29:50.287]  $ dim          : NULL
[09:29:50.287]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:50.287]  $ ...          : list()
[09:29:50.287]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:50.287]  - attr(*, "where")=List of 8
[09:29:50.287]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:50.287]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:50.287]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:50.287]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:50.287]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:50.287]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:50.287]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:50.287]   ..$ ...          :<environment: 0x561d3898e8e8> 
[09:29:50.287]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:50.287]  - attr(*, "resolved")= logi FALSE
[09:29:50.287]  - attr(*, "total_size")= num 94336
[09:29:50.292] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:50.293] getGlobalsAndPackagesXApply() ... DONE
[09:29:50.293] Number of futures (= number of chunks): 2
[09:29:50.293] Launching 2 futures (chunks) ...
[09:29:50.293] Chunk #1 of 2 ...
[09:29:50.293]  - Finding globals in 'X' for chunk #1 ...
[09:29:50.293] getGlobalsAndPackages() ...
[09:29:50.293] Searching for globals...
[09:29:50.293] 
[09:29:50.294] Searching for globals ... DONE
[09:29:50.294] - globals: [0] <none>
[09:29:50.294] getGlobalsAndPackages() ... DONE
[09:29:50.294]    + additional globals found: [n=0] 
[09:29:50.294]    + additional namespaces needed: [n=0] 
[09:29:50.294]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:50.294]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:50.294]  - seeds: <none>
[09:29:50.294]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.294] getGlobalsAndPackages() ...
[09:29:50.294] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.295] Resolving globals: FALSE
[09:29:50.296] Tweak future expression to call with '...' arguments ...
[09:29:50.297] {
[09:29:50.297]     do.call(function(...) {
[09:29:50.297]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.297]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:50.297]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.297]             on.exit(options(oopts), add = TRUE)
[09:29:50.297]         }
[09:29:50.297]         {
[09:29:50.297]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:50.297]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.297]                 ...future.FUN(...future.X_jj, ...)
[09:29:50.297]             })
[09:29:50.297]         }
[09:29:50.297]     }, args = future.call.arguments)
[09:29:50.297] }
[09:29:50.297] Tweak future expression to call with '...' arguments ... DONE
[09:29:50.297] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.297] - packages: [1] ‘future.apply’
[09:29:50.298] getGlobalsAndPackages() ... DONE
[09:29:50.298] run() for ‘Future’ ...
[09:29:50.298] - state: ‘created’
[09:29:50.298] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:50.312] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:50.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:50.313]   - Field: ‘node’
[09:29:50.313]   - Field: ‘label’
[09:29:50.313]   - Field: ‘local’
[09:29:50.313]   - Field: ‘owner’
[09:29:50.313]   - Field: ‘envir’
[09:29:50.313]   - Field: ‘workers’
[09:29:50.313]   - Field: ‘packages’
[09:29:50.313]   - Field: ‘gc’
[09:29:50.313]   - Field: ‘conditions’
[09:29:50.313]   - Field: ‘persistent’
[09:29:50.314]   - Field: ‘expr’
[09:29:50.314]   - Field: ‘uuid’
[09:29:50.314]   - Field: ‘seed’
[09:29:50.314]   - Field: ‘version’
[09:29:50.314]   - Field: ‘result’
[09:29:50.314]   - Field: ‘asynchronous’
[09:29:50.314]   - Field: ‘calls’
[09:29:50.314]   - Field: ‘globals’
[09:29:50.314]   - Field: ‘stdout’
[09:29:50.314]   - Field: ‘earlySignal’
[09:29:50.314]   - Field: ‘lazy’
[09:29:50.314]   - Field: ‘state’
[09:29:50.315] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:50.315] - Launch lazy future ...
[09:29:50.315] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:50.315] Packages needed by future strategies (n = 0): <none>
[09:29:50.315] {
[09:29:50.315]     {
[09:29:50.315]         {
[09:29:50.315]             ...future.startTime <- base::Sys.time()
[09:29:50.315]             {
[09:29:50.315]                 {
[09:29:50.315]                   {
[09:29:50.315]                     {
[09:29:50.315]                       {
[09:29:50.315]                         base::local({
[09:29:50.315]                           has_future <- base::requireNamespace("future", 
[09:29:50.315]                             quietly = TRUE)
[09:29:50.315]                           if (has_future) {
[09:29:50.315]                             ns <- base::getNamespace("future")
[09:29:50.315]                             version <- ns[[".package"]][["version"]]
[09:29:50.315]                             if (is.null(version)) 
[09:29:50.315]                               version <- utils::packageVersion("future")
[09:29:50.315]                           }
[09:29:50.315]                           else {
[09:29:50.315]                             version <- NULL
[09:29:50.315]                           }
[09:29:50.315]                           if (!has_future || version < "1.8.0") {
[09:29:50.315]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:50.315]                               "", base::R.version$version.string), 
[09:29:50.315]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:50.315]                                 base::R.version$platform, 8 * 
[09:29:50.315]                                   base::.Machine$sizeof.pointer), 
[09:29:50.315]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:50.315]                                 "release", "version")], collapse = " "), 
[09:29:50.315]                               hostname = base::Sys.info()[["nodename"]])
[09:29:50.315]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:50.315]                               info)
[09:29:50.315]                             info <- base::paste(info, collapse = "; ")
[09:29:50.315]                             if (!has_future) {
[09:29:50.315]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:50.315]                                 info)
[09:29:50.315]                             }
[09:29:50.315]                             else {
[09:29:50.315]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:50.315]                                 info, version)
[09:29:50.315]                             }
[09:29:50.315]                             base::stop(msg)
[09:29:50.315]                           }
[09:29:50.315]                         })
[09:29:50.315]                       }
[09:29:50.315]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:50.315]                       base::options(mc.cores = 1L)
[09:29:50.315]                     }
[09:29:50.315]                     base::local({
[09:29:50.315]                       for (pkg in "future.apply") {
[09:29:50.315]                         base::loadNamespace(pkg)
[09:29:50.315]                         base::library(pkg, character.only = TRUE)
[09:29:50.315]                       }
[09:29:50.315]                     })
[09:29:50.315]                   }
[09:29:50.315]                   ...future.strategy.old <- future::plan("list")
[09:29:50.315]                   options(future.plan = NULL)
[09:29:50.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:50.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:50.315]                 }
[09:29:50.315]                 ...future.workdir <- getwd()
[09:29:50.315]             }
[09:29:50.315]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:50.315]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:50.315]         }
[09:29:50.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:50.315]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:50.315]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:50.315]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:50.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:50.315]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:50.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:50.315]             base::names(...future.oldOptions))
[09:29:50.315]     }
[09:29:50.315]     if (FALSE) {
[09:29:50.315]     }
[09:29:50.315]     else {
[09:29:50.315]         if (TRUE) {
[09:29:50.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:50.315]                 open = "w")
[09:29:50.315]         }
[09:29:50.315]         else {
[09:29:50.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:50.315]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:50.315]         }
[09:29:50.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:50.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:50.315]             base::sink(type = "output", split = FALSE)
[09:29:50.315]             base::close(...future.stdout)
[09:29:50.315]         }, add = TRUE)
[09:29:50.315]     }
[09:29:50.315]     ...future.frame <- base::sys.nframe()
[09:29:50.315]     ...future.conditions <- base::list()
[09:29:50.315]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:50.315]     if (FALSE) {
[09:29:50.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:50.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:50.315]     }
[09:29:50.315]     ...future.result <- base::tryCatch({
[09:29:50.315]         base::withCallingHandlers({
[09:29:50.315]             ...future.value <- base::withVisible(base::local({
[09:29:50.315]                 ...future.makeSendCondition <- base::local({
[09:29:50.315]                   sendCondition <- NULL
[09:29:50.315]                   function(frame = 1L) {
[09:29:50.315]                     if (is.function(sendCondition)) 
[09:29:50.315]                       return(sendCondition)
[09:29:50.315]                     ns <- getNamespace("parallel")
[09:29:50.315]                     if (exists("sendData", mode = "function", 
[09:29:50.315]                       envir = ns)) {
[09:29:50.315]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:50.315]                         envir = ns)
[09:29:50.315]                       envir <- sys.frame(frame)
[09:29:50.315]                       master <- NULL
[09:29:50.315]                       while (!identical(envir, .GlobalEnv) && 
[09:29:50.315]                         !identical(envir, emptyenv())) {
[09:29:50.315]                         if (exists("master", mode = "list", envir = envir, 
[09:29:50.315]                           inherits = FALSE)) {
[09:29:50.315]                           master <- get("master", mode = "list", 
[09:29:50.315]                             envir = envir, inherits = FALSE)
[09:29:50.315]                           if (inherits(master, c("SOCKnode", 
[09:29:50.315]                             "SOCK0node"))) {
[09:29:50.315]                             sendCondition <<- function(cond) {
[09:29:50.315]                               data <- list(type = "VALUE", value = cond, 
[09:29:50.315]                                 success = TRUE)
[09:29:50.315]                               parallel_sendData(master, data)
[09:29:50.315]                             }
[09:29:50.315]                             return(sendCondition)
[09:29:50.315]                           }
[09:29:50.315]                         }
[09:29:50.315]                         frame <- frame + 1L
[09:29:50.315]                         envir <- sys.frame(frame)
[09:29:50.315]                       }
[09:29:50.315]                     }
[09:29:50.315]                     sendCondition <<- function(cond) NULL
[09:29:50.315]                   }
[09:29:50.315]                 })
[09:29:50.315]                 withCallingHandlers({
[09:29:50.315]                   {
[09:29:50.315]                     do.call(function(...) {
[09:29:50.315]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.315]                       if (!identical(...future.globals.maxSize.org, 
[09:29:50.315]                         ...future.globals.maxSize)) {
[09:29:50.315]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.315]                         on.exit(options(oopts), add = TRUE)
[09:29:50.315]                       }
[09:29:50.315]                       {
[09:29:50.315]                         lapply(seq_along(...future.elements_ii), 
[09:29:50.315]                           FUN = function(jj) {
[09:29:50.315]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.315]                             ...future.FUN(...future.X_jj, ...)
[09:29:50.315]                           })
[09:29:50.315]                       }
[09:29:50.315]                     }, args = future.call.arguments)
[09:29:50.315]                   }
[09:29:50.315]                 }, immediateCondition = function(cond) {
[09:29:50.315]                   sendCondition <- ...future.makeSendCondition()
[09:29:50.315]                   sendCondition(cond)
[09:29:50.315]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.315]                   {
[09:29:50.315]                     inherits <- base::inherits
[09:29:50.315]                     invokeRestart <- base::invokeRestart
[09:29:50.315]                     is.null <- base::is.null
[09:29:50.315]                     muffled <- FALSE
[09:29:50.315]                     if (inherits(cond, "message")) {
[09:29:50.315]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:50.315]                       if (muffled) 
[09:29:50.315]                         invokeRestart("muffleMessage")
[09:29:50.315]                     }
[09:29:50.315]                     else if (inherits(cond, "warning")) {
[09:29:50.315]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:50.315]                       if (muffled) 
[09:29:50.315]                         invokeRestart("muffleWarning")
[09:29:50.315]                     }
[09:29:50.315]                     else if (inherits(cond, "condition")) {
[09:29:50.315]                       if (!is.null(pattern)) {
[09:29:50.315]                         computeRestarts <- base::computeRestarts
[09:29:50.315]                         grepl <- base::grepl
[09:29:50.315]                         restarts <- computeRestarts(cond)
[09:29:50.315]                         for (restart in restarts) {
[09:29:50.315]                           name <- restart$name
[09:29:50.315]                           if (is.null(name)) 
[09:29:50.315]                             next
[09:29:50.315]                           if (!grepl(pattern, name)) 
[09:29:50.315]                             next
[09:29:50.315]                           invokeRestart(restart)
[09:29:50.315]                           muffled <- TRUE
[09:29:50.315]                           break
[09:29:50.315]                         }
[09:29:50.315]                       }
[09:29:50.315]                     }
[09:29:50.315]                     invisible(muffled)
[09:29:50.315]                   }
[09:29:50.315]                   muffleCondition(cond)
[09:29:50.315]                 })
[09:29:50.315]             }))
[09:29:50.315]             future::FutureResult(value = ...future.value$value, 
[09:29:50.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:50.315]                   ...future.rng), globalenv = if (FALSE) 
[09:29:50.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:50.315]                     ...future.globalenv.names))
[09:29:50.315]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:50.315]         }, condition = base::local({
[09:29:50.315]             c <- base::c
[09:29:50.315]             inherits <- base::inherits
[09:29:50.315]             invokeRestart <- base::invokeRestart
[09:29:50.315]             length <- base::length
[09:29:50.315]             list <- base::list
[09:29:50.315]             seq.int <- base::seq.int
[09:29:50.315]             signalCondition <- base::signalCondition
[09:29:50.315]             sys.calls <- base::sys.calls
[09:29:50.315]             `[[` <- base::`[[`
[09:29:50.315]             `+` <- base::`+`
[09:29:50.315]             `<<-` <- base::`<<-`
[09:29:50.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:50.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:50.315]                   3L)]
[09:29:50.315]             }
[09:29:50.315]             function(cond) {
[09:29:50.315]                 is_error <- inherits(cond, "error")
[09:29:50.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:50.315]                   NULL)
[09:29:50.315]                 if (is_error) {
[09:29:50.315]                   sessionInformation <- function() {
[09:29:50.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:50.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:50.315]                       search = base::search(), system = base::Sys.info())
[09:29:50.315]                   }
[09:29:50.315]                   ...future.conditions[[length(...future.conditions) + 
[09:29:50.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:50.315]                     cond$call), session = sessionInformation(), 
[09:29:50.315]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:50.315]                   signalCondition(cond)
[09:29:50.315]                 }
[09:29:50.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:50.315]                 "immediateCondition"))) {
[09:29:50.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:50.315]                   ...future.conditions[[length(...future.conditions) + 
[09:29:50.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:50.315]                   if (TRUE && !signal) {
[09:29:50.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.315]                     {
[09:29:50.315]                       inherits <- base::inherits
[09:29:50.315]                       invokeRestart <- base::invokeRestart
[09:29:50.315]                       is.null <- base::is.null
[09:29:50.315]                       muffled <- FALSE
[09:29:50.315]                       if (inherits(cond, "message")) {
[09:29:50.315]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:50.315]                         if (muffled) 
[09:29:50.315]                           invokeRestart("muffleMessage")
[09:29:50.315]                       }
[09:29:50.315]                       else if (inherits(cond, "warning")) {
[09:29:50.315]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:50.315]                         if (muffled) 
[09:29:50.315]                           invokeRestart("muffleWarning")
[09:29:50.315]                       }
[09:29:50.315]                       else if (inherits(cond, "condition")) {
[09:29:50.315]                         if (!is.null(pattern)) {
[09:29:50.315]                           computeRestarts <- base::computeRestarts
[09:29:50.315]                           grepl <- base::grepl
[09:29:50.315]                           restarts <- computeRestarts(cond)
[09:29:50.315]                           for (restart in restarts) {
[09:29:50.315]                             name <- restart$name
[09:29:50.315]                             if (is.null(name)) 
[09:29:50.315]                               next
[09:29:50.315]                             if (!grepl(pattern, name)) 
[09:29:50.315]                               next
[09:29:50.315]                             invokeRestart(restart)
[09:29:50.315]                             muffled <- TRUE
[09:29:50.315]                             break
[09:29:50.315]                           }
[09:29:50.315]                         }
[09:29:50.315]                       }
[09:29:50.315]                       invisible(muffled)
[09:29:50.315]                     }
[09:29:50.315]                     muffleCondition(cond, pattern = "^muffle")
[09:29:50.315]                   }
[09:29:50.315]                 }
[09:29:50.315]                 else {
[09:29:50.315]                   if (TRUE) {
[09:29:50.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.315]                     {
[09:29:50.315]                       inherits <- base::inherits
[09:29:50.315]                       invokeRestart <- base::invokeRestart
[09:29:50.315]                       is.null <- base::is.null
[09:29:50.315]                       muffled <- FALSE
[09:29:50.315]                       if (inherits(cond, "message")) {
[09:29:50.315]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:50.315]                         if (muffled) 
[09:29:50.315]                           invokeRestart("muffleMessage")
[09:29:50.315]                       }
[09:29:50.315]                       else if (inherits(cond, "warning")) {
[09:29:50.315]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:50.315]                         if (muffled) 
[09:29:50.315]                           invokeRestart("muffleWarning")
[09:29:50.315]                       }
[09:29:50.315]                       else if (inherits(cond, "condition")) {
[09:29:50.315]                         if (!is.null(pattern)) {
[09:29:50.315]                           computeRestarts <- base::computeRestarts
[09:29:50.315]                           grepl <- base::grepl
[09:29:50.315]                           restarts <- computeRestarts(cond)
[09:29:50.315]                           for (restart in restarts) {
[09:29:50.315]                             name <- restart$name
[09:29:50.315]                             if (is.null(name)) 
[09:29:50.315]                               next
[09:29:50.315]                             if (!grepl(pattern, name)) 
[09:29:50.315]                               next
[09:29:50.315]                             invokeRestart(restart)
[09:29:50.315]                             muffled <- TRUE
[09:29:50.315]                             break
[09:29:50.315]                           }
[09:29:50.315]                         }
[09:29:50.315]                       }
[09:29:50.315]                       invisible(muffled)
[09:29:50.315]                     }
[09:29:50.315]                     muffleCondition(cond, pattern = "^muffle")
[09:29:50.315]                   }
[09:29:50.315]                 }
[09:29:50.315]             }
[09:29:50.315]         }))
[09:29:50.315]     }, error = function(ex) {
[09:29:50.315]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:50.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:50.315]                 ...future.rng), started = ...future.startTime, 
[09:29:50.315]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:50.315]             version = "1.8"), class = "FutureResult")
[09:29:50.315]     }, finally = {
[09:29:50.315]         if (!identical(...future.workdir, getwd())) 
[09:29:50.315]             setwd(...future.workdir)
[09:29:50.315]         {
[09:29:50.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:50.315]                 ...future.oldOptions$nwarnings <- NULL
[09:29:50.315]             }
[09:29:50.315]             base::options(...future.oldOptions)
[09:29:50.315]             if (.Platform$OS.type == "windows") {
[09:29:50.315]                 old_names <- names(...future.oldEnvVars)
[09:29:50.315]                 envs <- base::Sys.getenv()
[09:29:50.315]                 names <- names(envs)
[09:29:50.315]                 common <- intersect(names, old_names)
[09:29:50.315]                 added <- setdiff(names, old_names)
[09:29:50.315]                 removed <- setdiff(old_names, names)
[09:29:50.315]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:50.315]                   envs[common]]
[09:29:50.315]                 NAMES <- toupper(changed)
[09:29:50.315]                 args <- list()
[09:29:50.315]                 for (kk in seq_along(NAMES)) {
[09:29:50.315]                   name <- changed[[kk]]
[09:29:50.315]                   NAME <- NAMES[[kk]]
[09:29:50.315]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.315]                     next
[09:29:50.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:50.315]                 }
[09:29:50.315]                 NAMES <- toupper(added)
[09:29:50.315]                 for (kk in seq_along(NAMES)) {
[09:29:50.315]                   name <- added[[kk]]
[09:29:50.315]                   NAME <- NAMES[[kk]]
[09:29:50.315]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.315]                     next
[09:29:50.315]                   args[[name]] <- ""
[09:29:50.315]                 }
[09:29:50.315]                 NAMES <- toupper(removed)
[09:29:50.315]                 for (kk in seq_along(NAMES)) {
[09:29:50.315]                   name <- removed[[kk]]
[09:29:50.315]                   NAME <- NAMES[[kk]]
[09:29:50.315]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.315]                     next
[09:29:50.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:50.315]                 }
[09:29:50.315]                 if (length(args) > 0) 
[09:29:50.315]                   base::do.call(base::Sys.setenv, args = args)
[09:29:50.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:50.315]             }
[09:29:50.315]             else {
[09:29:50.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:50.315]             }
[09:29:50.315]             {
[09:29:50.315]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:50.315]                   0L) {
[09:29:50.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:50.315]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:50.315]                   base::options(opts)
[09:29:50.315]                 }
[09:29:50.315]                 {
[09:29:50.315]                   {
[09:29:50.315]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:50.315]                     NULL
[09:29:50.315]                   }
[09:29:50.315]                   options(future.plan = NULL)
[09:29:50.315]                   if (is.na(NA_character_)) 
[09:29:50.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:50.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:50.315]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:50.315]                     .init = FALSE)
[09:29:50.315]                 }
[09:29:50.315]             }
[09:29:50.315]         }
[09:29:50.315]     })
[09:29:50.315]     if (TRUE) {
[09:29:50.315]         base::sink(type = "output", split = FALSE)
[09:29:50.315]         if (TRUE) {
[09:29:50.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:50.315]         }
[09:29:50.315]         else {
[09:29:50.315]             ...future.result["stdout"] <- base::list(NULL)
[09:29:50.315]         }
[09:29:50.315]         base::close(...future.stdout)
[09:29:50.315]         ...future.stdout <- NULL
[09:29:50.315]     }
[09:29:50.315]     ...future.result$conditions <- ...future.conditions
[09:29:50.315]     ...future.result$finished <- base::Sys.time()
[09:29:50.315]     ...future.result
[09:29:50.315] }
[09:29:50.318] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[09:29:50.318] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:50.360] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:50.360] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[09:29:50.361] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[09:29:50.361] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:50.361] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:50.361] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:50.404] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:50.404] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:50.448] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:50.448] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:50.449] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.449] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:50.449] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:50.449] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:50.450] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.450] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:50.450] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:50.450] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:50.451] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.451] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:50.451] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.451] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[09:29:50.452] MultisessionFuture started
[09:29:50.452] - Launch lazy future ... done
[09:29:50.452] run() for ‘MultisessionFuture’ ... done
[09:29:50.452] Created future:
[09:29:50.452] MultisessionFuture:
[09:29:50.452] Label: ‘future_vapply-1’
[09:29:50.452] Expression:
[09:29:50.452] {
[09:29:50.452]     do.call(function(...) {
[09:29:50.452]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.452]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:50.452]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.452]             on.exit(options(oopts), add = TRUE)
[09:29:50.452]         }
[09:29:50.452]         {
[09:29:50.452]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:50.452]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.452]                 ...future.FUN(...future.X_jj, ...)
[09:29:50.452]             })
[09:29:50.452]         }
[09:29:50.452]     }, args = future.call.arguments)
[09:29:50.452] }
[09:29:50.452] Lazy evaluation: FALSE
[09:29:50.452] Asynchronous evaluation: TRUE
[09:29:50.452] Local evaluation: TRUE
[09:29:50.452] Environment: R_GlobalEnv
[09:29:50.452] Capture standard output: TRUE
[09:29:50.452] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:50.452] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:50.452] Packages: 1 packages (‘future.apply’)
[09:29:50.452] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:50.452] Resolved: FALSE
[09:29:50.452] Value: <not collected>
[09:29:50.452] Conditions captured: <none>
[09:29:50.452] Early signaling: FALSE
[09:29:50.452] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:50.452] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:50.464] Chunk #1 of 2 ... DONE
[09:29:50.464] Chunk #2 of 2 ...
[09:29:50.464]  - Finding globals in 'X' for chunk #2 ...
[09:29:50.464] getGlobalsAndPackages() ...
[09:29:50.464] Searching for globals...
[09:29:50.465] 
[09:29:50.465] Searching for globals ... DONE
[09:29:50.465] - globals: [0] <none>
[09:29:50.465] getGlobalsAndPackages() ... DONE
[09:29:50.465]    + additional globals found: [n=0] 
[09:29:50.465]    + additional namespaces needed: [n=0] 
[09:29:50.465]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:50.465]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:50.465]  - seeds: <none>
[09:29:50.465]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.466] getGlobalsAndPackages() ...
[09:29:50.466] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.466] Resolving globals: FALSE
[09:29:50.466] Tweak future expression to call with '...' arguments ...
[09:29:50.466] {
[09:29:50.466]     do.call(function(...) {
[09:29:50.466]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.466]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:50.466]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.466]             on.exit(options(oopts), add = TRUE)
[09:29:50.466]         }
[09:29:50.466]         {
[09:29:50.466]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:50.466]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.466]                 ...future.FUN(...future.X_jj, ...)
[09:29:50.466]             })
[09:29:50.466]         }
[09:29:50.466]     }, args = future.call.arguments)
[09:29:50.466] }
[09:29:50.466] Tweak future expression to call with '...' arguments ... DONE
[09:29:50.467] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.467] - packages: [1] ‘future.apply’
[09:29:50.467] getGlobalsAndPackages() ... DONE
[09:29:50.467] run() for ‘Future’ ...
[09:29:50.467] - state: ‘created’
[09:29:50.467] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:50.483] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:50.483] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:50.483]   - Field: ‘node’
[09:29:50.483]   - Field: ‘label’
[09:29:50.483]   - Field: ‘local’
[09:29:50.483]   - Field: ‘owner’
[09:29:50.484]   - Field: ‘envir’
[09:29:50.484]   - Field: ‘workers’
[09:29:50.484]   - Field: ‘packages’
[09:29:50.484]   - Field: ‘gc’
[09:29:50.484]   - Field: ‘conditions’
[09:29:50.484]   - Field: ‘persistent’
[09:29:50.484]   - Field: ‘expr’
[09:29:50.484]   - Field: ‘uuid’
[09:29:50.484]   - Field: ‘seed’
[09:29:50.484]   - Field: ‘version’
[09:29:50.485]   - Field: ‘result’
[09:29:50.485]   - Field: ‘asynchronous’
[09:29:50.485]   - Field: ‘calls’
[09:29:50.485]   - Field: ‘globals’
[09:29:50.485]   - Field: ‘stdout’
[09:29:50.485]   - Field: ‘earlySignal’
[09:29:50.485]   - Field: ‘lazy’
[09:29:50.485]   - Field: ‘state’
[09:29:50.485] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:50.485] - Launch lazy future ...
[09:29:50.486] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:50.486] Packages needed by future strategies (n = 0): <none>
[09:29:50.486] {
[09:29:50.486]     {
[09:29:50.486]         {
[09:29:50.486]             ...future.startTime <- base::Sys.time()
[09:29:50.486]             {
[09:29:50.486]                 {
[09:29:50.486]                   {
[09:29:50.486]                     {
[09:29:50.486]                       {
[09:29:50.486]                         base::local({
[09:29:50.486]                           has_future <- base::requireNamespace("future", 
[09:29:50.486]                             quietly = TRUE)
[09:29:50.486]                           if (has_future) {
[09:29:50.486]                             ns <- base::getNamespace("future")
[09:29:50.486]                             version <- ns[[".package"]][["version"]]
[09:29:50.486]                             if (is.null(version)) 
[09:29:50.486]                               version <- utils::packageVersion("future")
[09:29:50.486]                           }
[09:29:50.486]                           else {
[09:29:50.486]                             version <- NULL
[09:29:50.486]                           }
[09:29:50.486]                           if (!has_future || version < "1.8.0") {
[09:29:50.486]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:50.486]                               "", base::R.version$version.string), 
[09:29:50.486]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:50.486]                                 base::R.version$platform, 8 * 
[09:29:50.486]                                   base::.Machine$sizeof.pointer), 
[09:29:50.486]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:50.486]                                 "release", "version")], collapse = " "), 
[09:29:50.486]                               hostname = base::Sys.info()[["nodename"]])
[09:29:50.486]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:50.486]                               info)
[09:29:50.486]                             info <- base::paste(info, collapse = "; ")
[09:29:50.486]                             if (!has_future) {
[09:29:50.486]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:50.486]                                 info)
[09:29:50.486]                             }
[09:29:50.486]                             else {
[09:29:50.486]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:50.486]                                 info, version)
[09:29:50.486]                             }
[09:29:50.486]                             base::stop(msg)
[09:29:50.486]                           }
[09:29:50.486]                         })
[09:29:50.486]                       }
[09:29:50.486]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:50.486]                       base::options(mc.cores = 1L)
[09:29:50.486]                     }
[09:29:50.486]                     base::local({
[09:29:50.486]                       for (pkg in "future.apply") {
[09:29:50.486]                         base::loadNamespace(pkg)
[09:29:50.486]                         base::library(pkg, character.only = TRUE)
[09:29:50.486]                       }
[09:29:50.486]                     })
[09:29:50.486]                   }
[09:29:50.486]                   ...future.strategy.old <- future::plan("list")
[09:29:50.486]                   options(future.plan = NULL)
[09:29:50.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:50.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:50.486]                 }
[09:29:50.486]                 ...future.workdir <- getwd()
[09:29:50.486]             }
[09:29:50.486]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:50.486]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:50.486]         }
[09:29:50.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:50.486]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:50.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:50.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:50.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:50.486]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:50.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:50.486]             base::names(...future.oldOptions))
[09:29:50.486]     }
[09:29:50.486]     if (FALSE) {
[09:29:50.486]     }
[09:29:50.486]     else {
[09:29:50.486]         if (TRUE) {
[09:29:50.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:50.486]                 open = "w")
[09:29:50.486]         }
[09:29:50.486]         else {
[09:29:50.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:50.486]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:50.486]         }
[09:29:50.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:50.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:50.486]             base::sink(type = "output", split = FALSE)
[09:29:50.486]             base::close(...future.stdout)
[09:29:50.486]         }, add = TRUE)
[09:29:50.486]     }
[09:29:50.486]     ...future.frame <- base::sys.nframe()
[09:29:50.486]     ...future.conditions <- base::list()
[09:29:50.486]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:50.486]     if (FALSE) {
[09:29:50.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:50.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:50.486]     }
[09:29:50.486]     ...future.result <- base::tryCatch({
[09:29:50.486]         base::withCallingHandlers({
[09:29:50.486]             ...future.value <- base::withVisible(base::local({
[09:29:50.486]                 ...future.makeSendCondition <- base::local({
[09:29:50.486]                   sendCondition <- NULL
[09:29:50.486]                   function(frame = 1L) {
[09:29:50.486]                     if (is.function(sendCondition)) 
[09:29:50.486]                       return(sendCondition)
[09:29:50.486]                     ns <- getNamespace("parallel")
[09:29:50.486]                     if (exists("sendData", mode = "function", 
[09:29:50.486]                       envir = ns)) {
[09:29:50.486]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:50.486]                         envir = ns)
[09:29:50.486]                       envir <- sys.frame(frame)
[09:29:50.486]                       master <- NULL
[09:29:50.486]                       while (!identical(envir, .GlobalEnv) && 
[09:29:50.486]                         !identical(envir, emptyenv())) {
[09:29:50.486]                         if (exists("master", mode = "list", envir = envir, 
[09:29:50.486]                           inherits = FALSE)) {
[09:29:50.486]                           master <- get("master", mode = "list", 
[09:29:50.486]                             envir = envir, inherits = FALSE)
[09:29:50.486]                           if (inherits(master, c("SOCKnode", 
[09:29:50.486]                             "SOCK0node"))) {
[09:29:50.486]                             sendCondition <<- function(cond) {
[09:29:50.486]                               data <- list(type = "VALUE", value = cond, 
[09:29:50.486]                                 success = TRUE)
[09:29:50.486]                               parallel_sendData(master, data)
[09:29:50.486]                             }
[09:29:50.486]                             return(sendCondition)
[09:29:50.486]                           }
[09:29:50.486]                         }
[09:29:50.486]                         frame <- frame + 1L
[09:29:50.486]                         envir <- sys.frame(frame)
[09:29:50.486]                       }
[09:29:50.486]                     }
[09:29:50.486]                     sendCondition <<- function(cond) NULL
[09:29:50.486]                   }
[09:29:50.486]                 })
[09:29:50.486]                 withCallingHandlers({
[09:29:50.486]                   {
[09:29:50.486]                     do.call(function(...) {
[09:29:50.486]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.486]                       if (!identical(...future.globals.maxSize.org, 
[09:29:50.486]                         ...future.globals.maxSize)) {
[09:29:50.486]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.486]                         on.exit(options(oopts), add = TRUE)
[09:29:50.486]                       }
[09:29:50.486]                       {
[09:29:50.486]                         lapply(seq_along(...future.elements_ii), 
[09:29:50.486]                           FUN = function(jj) {
[09:29:50.486]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.486]                             ...future.FUN(...future.X_jj, ...)
[09:29:50.486]                           })
[09:29:50.486]                       }
[09:29:50.486]                     }, args = future.call.arguments)
[09:29:50.486]                   }
[09:29:50.486]                 }, immediateCondition = function(cond) {
[09:29:50.486]                   sendCondition <- ...future.makeSendCondition()
[09:29:50.486]                   sendCondition(cond)
[09:29:50.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.486]                   {
[09:29:50.486]                     inherits <- base::inherits
[09:29:50.486]                     invokeRestart <- base::invokeRestart
[09:29:50.486]                     is.null <- base::is.null
[09:29:50.486]                     muffled <- FALSE
[09:29:50.486]                     if (inherits(cond, "message")) {
[09:29:50.486]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:50.486]                       if (muffled) 
[09:29:50.486]                         invokeRestart("muffleMessage")
[09:29:50.486]                     }
[09:29:50.486]                     else if (inherits(cond, "warning")) {
[09:29:50.486]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:50.486]                       if (muffled) 
[09:29:50.486]                         invokeRestart("muffleWarning")
[09:29:50.486]                     }
[09:29:50.486]                     else if (inherits(cond, "condition")) {
[09:29:50.486]                       if (!is.null(pattern)) {
[09:29:50.486]                         computeRestarts <- base::computeRestarts
[09:29:50.486]                         grepl <- base::grepl
[09:29:50.486]                         restarts <- computeRestarts(cond)
[09:29:50.486]                         for (restart in restarts) {
[09:29:50.486]                           name <- restart$name
[09:29:50.486]                           if (is.null(name)) 
[09:29:50.486]                             next
[09:29:50.486]                           if (!grepl(pattern, name)) 
[09:29:50.486]                             next
[09:29:50.486]                           invokeRestart(restart)
[09:29:50.486]                           muffled <- TRUE
[09:29:50.486]                           break
[09:29:50.486]                         }
[09:29:50.486]                       }
[09:29:50.486]                     }
[09:29:50.486]                     invisible(muffled)
[09:29:50.486]                   }
[09:29:50.486]                   muffleCondition(cond)
[09:29:50.486]                 })
[09:29:50.486]             }))
[09:29:50.486]             future::FutureResult(value = ...future.value$value, 
[09:29:50.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:50.486]                   ...future.rng), globalenv = if (FALSE) 
[09:29:50.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:50.486]                     ...future.globalenv.names))
[09:29:50.486]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:50.486]         }, condition = base::local({
[09:29:50.486]             c <- base::c
[09:29:50.486]             inherits <- base::inherits
[09:29:50.486]             invokeRestart <- base::invokeRestart
[09:29:50.486]             length <- base::length
[09:29:50.486]             list <- base::list
[09:29:50.486]             seq.int <- base::seq.int
[09:29:50.486]             signalCondition <- base::signalCondition
[09:29:50.486]             sys.calls <- base::sys.calls
[09:29:50.486]             `[[` <- base::`[[`
[09:29:50.486]             `+` <- base::`+`
[09:29:50.486]             `<<-` <- base::`<<-`
[09:29:50.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:50.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:50.486]                   3L)]
[09:29:50.486]             }
[09:29:50.486]             function(cond) {
[09:29:50.486]                 is_error <- inherits(cond, "error")
[09:29:50.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:50.486]                   NULL)
[09:29:50.486]                 if (is_error) {
[09:29:50.486]                   sessionInformation <- function() {
[09:29:50.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:50.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:50.486]                       search = base::search(), system = base::Sys.info())
[09:29:50.486]                   }
[09:29:50.486]                   ...future.conditions[[length(...future.conditions) + 
[09:29:50.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:50.486]                     cond$call), session = sessionInformation(), 
[09:29:50.486]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:50.486]                   signalCondition(cond)
[09:29:50.486]                 }
[09:29:50.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:50.486]                 "immediateCondition"))) {
[09:29:50.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:50.486]                   ...future.conditions[[length(...future.conditions) + 
[09:29:50.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:50.486]                   if (TRUE && !signal) {
[09:29:50.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.486]                     {
[09:29:50.486]                       inherits <- base::inherits
[09:29:50.486]                       invokeRestart <- base::invokeRestart
[09:29:50.486]                       is.null <- base::is.null
[09:29:50.486]                       muffled <- FALSE
[09:29:50.486]                       if (inherits(cond, "message")) {
[09:29:50.486]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:50.486]                         if (muffled) 
[09:29:50.486]                           invokeRestart("muffleMessage")
[09:29:50.486]                       }
[09:29:50.486]                       else if (inherits(cond, "warning")) {
[09:29:50.486]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:50.486]                         if (muffled) 
[09:29:50.486]                           invokeRestart("muffleWarning")
[09:29:50.486]                       }
[09:29:50.486]                       else if (inherits(cond, "condition")) {
[09:29:50.486]                         if (!is.null(pattern)) {
[09:29:50.486]                           computeRestarts <- base::computeRestarts
[09:29:50.486]                           grepl <- base::grepl
[09:29:50.486]                           restarts <- computeRestarts(cond)
[09:29:50.486]                           for (restart in restarts) {
[09:29:50.486]                             name <- restart$name
[09:29:50.486]                             if (is.null(name)) 
[09:29:50.486]                               next
[09:29:50.486]                             if (!grepl(pattern, name)) 
[09:29:50.486]                               next
[09:29:50.486]                             invokeRestart(restart)
[09:29:50.486]                             muffled <- TRUE
[09:29:50.486]                             break
[09:29:50.486]                           }
[09:29:50.486]                         }
[09:29:50.486]                       }
[09:29:50.486]                       invisible(muffled)
[09:29:50.486]                     }
[09:29:50.486]                     muffleCondition(cond, pattern = "^muffle")
[09:29:50.486]                   }
[09:29:50.486]                 }
[09:29:50.486]                 else {
[09:29:50.486]                   if (TRUE) {
[09:29:50.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.486]                     {
[09:29:50.486]                       inherits <- base::inherits
[09:29:50.486]                       invokeRestart <- base::invokeRestart
[09:29:50.486]                       is.null <- base::is.null
[09:29:50.486]                       muffled <- FALSE
[09:29:50.486]                       if (inherits(cond, "message")) {
[09:29:50.486]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:50.486]                         if (muffled) 
[09:29:50.486]                           invokeRestart("muffleMessage")
[09:29:50.486]                       }
[09:29:50.486]                       else if (inherits(cond, "warning")) {
[09:29:50.486]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:50.486]                         if (muffled) 
[09:29:50.486]                           invokeRestart("muffleWarning")
[09:29:50.486]                       }
[09:29:50.486]                       else if (inherits(cond, "condition")) {
[09:29:50.486]                         if (!is.null(pattern)) {
[09:29:50.486]                           computeRestarts <- base::computeRestarts
[09:29:50.486]                           grepl <- base::grepl
[09:29:50.486]                           restarts <- computeRestarts(cond)
[09:29:50.486]                           for (restart in restarts) {
[09:29:50.486]                             name <- restart$name
[09:29:50.486]                             if (is.null(name)) 
[09:29:50.486]                               next
[09:29:50.486]                             if (!grepl(pattern, name)) 
[09:29:50.486]                               next
[09:29:50.486]                             invokeRestart(restart)
[09:29:50.486]                             muffled <- TRUE
[09:29:50.486]                             break
[09:29:50.486]                           }
[09:29:50.486]                         }
[09:29:50.486]                       }
[09:29:50.486]                       invisible(muffled)
[09:29:50.486]                     }
[09:29:50.486]                     muffleCondition(cond, pattern = "^muffle")
[09:29:50.486]                   }
[09:29:50.486]                 }
[09:29:50.486]             }
[09:29:50.486]         }))
[09:29:50.486]     }, error = function(ex) {
[09:29:50.486]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:50.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:50.486]                 ...future.rng), started = ...future.startTime, 
[09:29:50.486]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:50.486]             version = "1.8"), class = "FutureResult")
[09:29:50.486]     }, finally = {
[09:29:50.486]         if (!identical(...future.workdir, getwd())) 
[09:29:50.486]             setwd(...future.workdir)
[09:29:50.486]         {
[09:29:50.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:50.486]                 ...future.oldOptions$nwarnings <- NULL
[09:29:50.486]             }
[09:29:50.486]             base::options(...future.oldOptions)
[09:29:50.486]             if (.Platform$OS.type == "windows") {
[09:29:50.486]                 old_names <- names(...future.oldEnvVars)
[09:29:50.486]                 envs <- base::Sys.getenv()
[09:29:50.486]                 names <- names(envs)
[09:29:50.486]                 common <- intersect(names, old_names)
[09:29:50.486]                 added <- setdiff(names, old_names)
[09:29:50.486]                 removed <- setdiff(old_names, names)
[09:29:50.486]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:50.486]                   envs[common]]
[09:29:50.486]                 NAMES <- toupper(changed)
[09:29:50.486]                 args <- list()
[09:29:50.486]                 for (kk in seq_along(NAMES)) {
[09:29:50.486]                   name <- changed[[kk]]
[09:29:50.486]                   NAME <- NAMES[[kk]]
[09:29:50.486]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.486]                     next
[09:29:50.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:50.486]                 }
[09:29:50.486]                 NAMES <- toupper(added)
[09:29:50.486]                 for (kk in seq_along(NAMES)) {
[09:29:50.486]                   name <- added[[kk]]
[09:29:50.486]                   NAME <- NAMES[[kk]]
[09:29:50.486]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.486]                     next
[09:29:50.486]                   args[[name]] <- ""
[09:29:50.486]                 }
[09:29:50.486]                 NAMES <- toupper(removed)
[09:29:50.486]                 for (kk in seq_along(NAMES)) {
[09:29:50.486]                   name <- removed[[kk]]
[09:29:50.486]                   NAME <- NAMES[[kk]]
[09:29:50.486]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.486]                     next
[09:29:50.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:50.486]                 }
[09:29:50.486]                 if (length(args) > 0) 
[09:29:50.486]                   base::do.call(base::Sys.setenv, args = args)
[09:29:50.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:50.486]             }
[09:29:50.486]             else {
[09:29:50.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:50.486]             }
[09:29:50.486]             {
[09:29:50.486]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:50.486]                   0L) {
[09:29:50.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:50.486]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:50.486]                   base::options(opts)
[09:29:50.486]                 }
[09:29:50.486]                 {
[09:29:50.486]                   {
[09:29:50.486]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:50.486]                     NULL
[09:29:50.486]                   }
[09:29:50.486]                   options(future.plan = NULL)
[09:29:50.486]                   if (is.na(NA_character_)) 
[09:29:50.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:50.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:50.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:50.486]                     .init = FALSE)
[09:29:50.486]                 }
[09:29:50.486]             }
[09:29:50.486]         }
[09:29:50.486]     })
[09:29:50.486]     if (TRUE) {
[09:29:50.486]         base::sink(type = "output", split = FALSE)
[09:29:50.486]         if (TRUE) {
[09:29:50.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:50.486]         }
[09:29:50.486]         else {
[09:29:50.486]             ...future.result["stdout"] <- base::list(NULL)
[09:29:50.486]         }
[09:29:50.486]         base::close(...future.stdout)
[09:29:50.486]         ...future.stdout <- NULL
[09:29:50.486]     }
[09:29:50.486]     ...future.result$conditions <- ...future.conditions
[09:29:50.486]     ...future.result$finished <- base::Sys.time()
[09:29:50.486]     ...future.result
[09:29:50.486] }
[09:29:50.489] Exporting 11 global objects (92.12 KiB) to cluster node #2 ...
[09:29:50.489] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[09:29:50.532] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[09:29:50.532] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[09:29:50.533] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[09:29:50.533] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[09:29:50.533] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[09:29:50.533] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[09:29:50.576] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[09:29:50.576] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[09:29:50.620] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[09:29:50.620] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[09:29:50.621] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[09:29:50.621] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[09:29:50.621] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[09:29:50.621] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:29:50.622] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:29:50.622] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[09:29:50.622] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[09:29:50.622] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:50.623] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:50.623] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:50.623] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:50.623] Exporting 11 global objects (92.12 KiB) to cluster node #2 ... DONE
[09:29:50.624] MultisessionFuture started
[09:29:50.624] - Launch lazy future ... done
[09:29:50.624] run() for ‘MultisessionFuture’ ... done
[09:29:50.624] Created future:
[09:29:50.624] MultisessionFuture:
[09:29:50.624] Label: ‘future_vapply-2’
[09:29:50.624] Expression:
[09:29:50.624] {
[09:29:50.624]     do.call(function(...) {
[09:29:50.624]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.624]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:50.624]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.624]             on.exit(options(oopts), add = TRUE)
[09:29:50.624]         }
[09:29:50.624]         {
[09:29:50.624]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:50.624]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.624]                 ...future.FUN(...future.X_jj, ...)
[09:29:50.624]             })
[09:29:50.624]         }
[09:29:50.624]     }, args = future.call.arguments)
[09:29:50.624] }
[09:29:50.624] Lazy evaluation: FALSE
[09:29:50.624] Asynchronous evaluation: TRUE
[09:29:50.624] Local evaluation: TRUE
[09:29:50.624] Environment: R_GlobalEnv
[09:29:50.624] Capture standard output: TRUE
[09:29:50.624] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:50.624] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:50.624] Packages: 1 packages (‘future.apply’)
[09:29:50.624] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:50.624] Resolved: FALSE
[09:29:50.624] Value: <not collected>
[09:29:50.624] Conditions captured: <none>
[09:29:50.624] Early signaling: FALSE
[09:29:50.624] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:50.624] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:50.636] Chunk #2 of 2 ... DONE
[09:29:50.636] Launching 2 futures (chunks) ... DONE
[09:29:50.636] Resolving 2 futures (chunks) ...
[09:29:50.636] resolve() on list ...
[09:29:50.636]  recursive: 0
[09:29:50.637]  length: 2
[09:29:50.637] 
[09:29:50.637] receiveMessageFromWorker() for ClusterFuture ...
[09:29:50.637] - Validating connection of MultisessionFuture
[09:29:50.637] - received message: FutureResult
[09:29:50.637] - Received FutureResult
[09:29:50.638] - Erased future from FutureRegistry
[09:29:50.638] result() for ClusterFuture ...
[09:29:50.638] - result already collected: FutureResult
[09:29:50.638] result() for ClusterFuture ... done
[09:29:50.638] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:50.638] Future #1
[09:29:50.638] result() for ClusterFuture ...
[09:29:50.638] - result already collected: FutureResult
[09:29:50.638] result() for ClusterFuture ... done
[09:29:50.638] result() for ClusterFuture ...
[09:29:50.638] - result already collected: FutureResult
[09:29:50.638] result() for ClusterFuture ... done
[09:29:50.639] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:50.639] - nx: 2
[09:29:50.639] - relay: TRUE
[09:29:50.639] - stdout: TRUE
[09:29:50.639] - signal: TRUE
[09:29:50.639] - resignal: FALSE
[09:29:50.639] - force: TRUE
[09:29:50.639] - relayed: [n=2] FALSE, FALSE
[09:29:50.639] - queued futures: [n=2] FALSE, FALSE
[09:29:50.639]  - until=1
[09:29:50.639]  - relaying element #1
[09:29:50.640] result() for ClusterFuture ...
[09:29:50.640] - result already collected: FutureResult
[09:29:50.640] result() for ClusterFuture ... done
[09:29:50.640] result() for ClusterFuture ...
[09:29:50.640] - result already collected: FutureResult
[09:29:50.640] result() for ClusterFuture ... done
[09:29:50.640] result() for ClusterFuture ...
[09:29:50.640] - result already collected: FutureResult
[09:29:50.640] result() for ClusterFuture ... done
[09:29:50.640] result() for ClusterFuture ...
[09:29:50.640] - result already collected: FutureResult
[09:29:50.641] result() for ClusterFuture ... done
[09:29:50.641] - relayed: [n=2] TRUE, FALSE
[09:29:50.641] - queued futures: [n=2] TRUE, FALSE
[09:29:50.641] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:50.641]  length: 1 (resolved future 1)
[09:29:50.669] receiveMessageFromWorker() for ClusterFuture ...
[09:29:50.670] - Validating connection of MultisessionFuture
[09:29:50.670] - received message: FutureResult
[09:29:50.670] - Received FutureResult
[09:29:50.670] - Erased future from FutureRegistry
[09:29:50.670] result() for ClusterFuture ...
[09:29:50.670] - result already collected: FutureResult
[09:29:50.670] result() for ClusterFuture ... done
[09:29:50.670] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:50.670] Future #2
[09:29:50.670] result() for ClusterFuture ...
[09:29:50.671] - result already collected: FutureResult
[09:29:50.671] result() for ClusterFuture ... done
[09:29:50.671] result() for ClusterFuture ...
[09:29:50.671] - result already collected: FutureResult
[09:29:50.671] result() for ClusterFuture ... done
[09:29:50.671] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:50.671] - nx: 2
[09:29:50.671] - relay: TRUE
[09:29:50.671] - stdout: TRUE
[09:29:50.671] - signal: TRUE
[09:29:50.671] - resignal: FALSE
[09:29:50.671] - force: TRUE
[09:29:50.672] - relayed: [n=2] TRUE, FALSE
[09:29:50.672] - queued futures: [n=2] TRUE, FALSE
[09:29:50.672]  - until=2
[09:29:50.672]  - relaying element #2
[09:29:50.672] result() for ClusterFuture ...
[09:29:50.672] - result already collected: FutureResult
[09:29:50.672] result() for ClusterFuture ... done
[09:29:50.672] result() for ClusterFuture ...
[09:29:50.672] - result already collected: FutureResult
[09:29:50.672] result() for ClusterFuture ... done
[09:29:50.672] result() for ClusterFuture ...
[09:29:50.673] - result already collected: FutureResult
[09:29:50.673] result() for ClusterFuture ... done
[09:29:50.673] result() for ClusterFuture ...
[09:29:50.673] - result already collected: FutureResult
[09:29:50.673] result() for ClusterFuture ... done
[09:29:50.673] - relayed: [n=2] TRUE, TRUE
[09:29:50.673] - queued futures: [n=2] TRUE, TRUE
[09:29:50.673] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:50.673]  length: 0 (resolved future 2)
[09:29:50.673] Relaying remaining futures
[09:29:50.673] signalConditionsASAP(NULL, pos=0) ...
[09:29:50.673] - nx: 2
[09:29:50.674] - relay: TRUE
[09:29:50.674] - stdout: TRUE
[09:29:50.674] - signal: TRUE
[09:29:50.674] - resignal: FALSE
[09:29:50.674] - force: TRUE
[09:29:50.674] - relayed: [n=2] TRUE, TRUE
[09:29:50.674] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:50.674] - relayed: [n=2] TRUE, TRUE
[09:29:50.674] - queued futures: [n=2] TRUE, TRUE
[09:29:50.674] signalConditionsASAP(NULL, pos=0) ... done
[09:29:50.674] resolve() on list ... DONE
[09:29:50.675] result() for ClusterFuture ...
[09:29:50.675] - result already collected: FutureResult
[09:29:50.675] result() for ClusterFuture ... done
[09:29:50.675] result() for ClusterFuture ...
[09:29:50.675] - result already collected: FutureResult
[09:29:50.675] result() for ClusterFuture ... done
[09:29:50.675] result() for ClusterFuture ...
[09:29:50.675] - result already collected: FutureResult
[09:29:50.675] result() for ClusterFuture ... done
[09:29:50.675] result() for ClusterFuture ...
[09:29:50.675] - result already collected: FutureResult
[09:29:50.675] result() for ClusterFuture ... done
[09:29:50.676]  - Number of value chunks collected: 2
[09:29:50.676] Resolving 2 futures (chunks) ... DONE
[09:29:50.676] Reducing values from 2 chunks ...
[09:29:50.676]  - Number of values collected after concatenation: 10
[09:29:50.676]  - Number of values expected: 10
[09:29:50.676] Reducing values from 2 chunks ... DONE
[09:29:50.676] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[09:29:50.677] future_lapply() ...
[09:29:50.682] Number of chunks: 2
[09:29:50.682] getGlobalsAndPackagesXApply() ...
[09:29:50.682]  - future.globals: TRUE
[09:29:50.683] getGlobalsAndPackages() ...
[09:29:50.683] Searching for globals...
[09:29:50.686] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[09:29:50.686] Searching for globals ... DONE
[09:29:50.687] Resolving globals: FALSE
[09:29:50.687] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[09:29:50.688] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:50.688] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:50.688] - packages: [1] ‘future.apply’
[09:29:50.688] getGlobalsAndPackages() ... DONE
[09:29:50.688]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:50.688]  - needed namespaces: [n=1] ‘future.apply’
[09:29:50.689] Finding globals ... DONE
[09:29:50.689]  - use_args: TRUE
[09:29:50.689]  - Getting '...' globals ...
[09:29:50.689] resolve() on list ...
[09:29:50.689]  recursive: 0
[09:29:50.689]  length: 1
[09:29:50.689]  elements: ‘...’
[09:29:50.689]  length: 0 (resolved future 1)
[09:29:50.689] resolve() on list ... DONE
[09:29:50.690]    - '...' content: [n=0] 
[09:29:50.690] List of 1
[09:29:50.690]  $ ...: list()
[09:29:50.690]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:50.690]  - attr(*, "where")=List of 1
[09:29:50.690]   ..$ ...:<environment: 0x561d3812cf60> 
[09:29:50.690]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:50.690]  - attr(*, "resolved")= logi TRUE
[09:29:50.690]  - attr(*, "total_size")= num NA
[09:29:50.692]  - Getting '...' globals ... DONE
[09:29:50.692] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:50.692] List of 8
[09:29:50.692]  $ ...future.FUN:function (x, ...)  
[09:29:50.692]  $ x_FUN        :function (x)  
[09:29:50.692]  $ times        : int 2
[09:29:50.692]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:50.692]  $ stop_if_not  :function (...)  
[09:29:50.692]  $ dim          : NULL
[09:29:50.692]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:50.692]  $ ...          : list()
[09:29:50.692]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:50.692]  - attr(*, "where")=List of 8
[09:29:50.692]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:50.692]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:50.692]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:50.692]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:50.692]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:50.692]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:50.692]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:50.692]   ..$ ...          :<environment: 0x561d3812cf60> 
[09:29:50.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:50.692]  - attr(*, "resolved")= logi FALSE
[09:29:50.692]  - attr(*, "total_size")= num 96456
[09:29:50.697] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:50.698] getGlobalsAndPackagesXApply() ... DONE
[09:29:50.698] Number of futures (= number of chunks): 2
[09:29:50.698] Launching 2 futures (chunks) ...
[09:29:50.698] Chunk #1 of 2 ...
[09:29:50.698]  - Finding globals in 'X' for chunk #1 ...
[09:29:50.698] getGlobalsAndPackages() ...
[09:29:50.698] Searching for globals...
[09:29:50.699] 
[09:29:50.699] Searching for globals ... DONE
[09:29:50.699] - globals: [0] <none>
[09:29:50.699] getGlobalsAndPackages() ... DONE
[09:29:50.699]    + additional globals found: [n=0] 
[09:29:50.699]    + additional namespaces needed: [n=0] 
[09:29:50.699]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:50.699]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:50.699]  - seeds: <none>
[09:29:50.699]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.699] getGlobalsAndPackages() ...
[09:29:50.699] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.700] Resolving globals: FALSE
[09:29:50.700] Tweak future expression to call with '...' arguments ...
[09:29:50.700] {
[09:29:50.700]     do.call(function(...) {
[09:29:50.700]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.700]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:50.700]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.700]             on.exit(options(oopts), add = TRUE)
[09:29:50.700]         }
[09:29:50.700]         {
[09:29:50.700]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:50.700]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.700]                 ...future.FUN(...future.X_jj, ...)
[09:29:50.700]             })
[09:29:50.700]         }
[09:29:50.700]     }, args = future.call.arguments)
[09:29:50.700] }
[09:29:50.700] Tweak future expression to call with '...' arguments ... DONE
[09:29:50.701] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.701] - packages: [1] ‘future.apply’
[09:29:50.701] getGlobalsAndPackages() ... DONE
[09:29:50.701] run() for ‘Future’ ...
[09:29:50.701] - state: ‘created’
[09:29:50.701] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:50.715] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:50.715] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:50.715]   - Field: ‘node’
[09:29:50.715]   - Field: ‘label’
[09:29:50.715]   - Field: ‘local’
[09:29:50.715]   - Field: ‘owner’
[09:29:50.716]   - Field: ‘envir’
[09:29:50.716]   - Field: ‘workers’
[09:29:50.716]   - Field: ‘packages’
[09:29:50.716]   - Field: ‘gc’
[09:29:50.716]   - Field: ‘conditions’
[09:29:50.716]   - Field: ‘persistent’
[09:29:50.716]   - Field: ‘expr’
[09:29:50.716]   - Field: ‘uuid’
[09:29:50.716]   - Field: ‘seed’
[09:29:50.716]   - Field: ‘version’
[09:29:50.717]   - Field: ‘result’
[09:29:50.717]   - Field: ‘asynchronous’
[09:29:50.717]   - Field: ‘calls’
[09:29:50.717]   - Field: ‘globals’
[09:29:50.717]   - Field: ‘stdout’
[09:29:50.717]   - Field: ‘earlySignal’
[09:29:50.717]   - Field: ‘lazy’
[09:29:50.717]   - Field: ‘state’
[09:29:50.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:50.717] - Launch lazy future ...
[09:29:50.718] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:50.718] Packages needed by future strategies (n = 0): <none>
[09:29:50.718] {
[09:29:50.718]     {
[09:29:50.718]         {
[09:29:50.718]             ...future.startTime <- base::Sys.time()
[09:29:50.718]             {
[09:29:50.718]                 {
[09:29:50.718]                   {
[09:29:50.718]                     {
[09:29:50.718]                       {
[09:29:50.718]                         base::local({
[09:29:50.718]                           has_future <- base::requireNamespace("future", 
[09:29:50.718]                             quietly = TRUE)
[09:29:50.718]                           if (has_future) {
[09:29:50.718]                             ns <- base::getNamespace("future")
[09:29:50.718]                             version <- ns[[".package"]][["version"]]
[09:29:50.718]                             if (is.null(version)) 
[09:29:50.718]                               version <- utils::packageVersion("future")
[09:29:50.718]                           }
[09:29:50.718]                           else {
[09:29:50.718]                             version <- NULL
[09:29:50.718]                           }
[09:29:50.718]                           if (!has_future || version < "1.8.0") {
[09:29:50.718]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:50.718]                               "", base::R.version$version.string), 
[09:29:50.718]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:50.718]                                 base::R.version$platform, 8 * 
[09:29:50.718]                                   base::.Machine$sizeof.pointer), 
[09:29:50.718]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:50.718]                                 "release", "version")], collapse = " "), 
[09:29:50.718]                               hostname = base::Sys.info()[["nodename"]])
[09:29:50.718]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:50.718]                               info)
[09:29:50.718]                             info <- base::paste(info, collapse = "; ")
[09:29:50.718]                             if (!has_future) {
[09:29:50.718]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:50.718]                                 info)
[09:29:50.718]                             }
[09:29:50.718]                             else {
[09:29:50.718]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:50.718]                                 info, version)
[09:29:50.718]                             }
[09:29:50.718]                             base::stop(msg)
[09:29:50.718]                           }
[09:29:50.718]                         })
[09:29:50.718]                       }
[09:29:50.718]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:50.718]                       base::options(mc.cores = 1L)
[09:29:50.718]                     }
[09:29:50.718]                     base::local({
[09:29:50.718]                       for (pkg in "future.apply") {
[09:29:50.718]                         base::loadNamespace(pkg)
[09:29:50.718]                         base::library(pkg, character.only = TRUE)
[09:29:50.718]                       }
[09:29:50.718]                     })
[09:29:50.718]                   }
[09:29:50.718]                   ...future.strategy.old <- future::plan("list")
[09:29:50.718]                   options(future.plan = NULL)
[09:29:50.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:50.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:50.718]                 }
[09:29:50.718]                 ...future.workdir <- getwd()
[09:29:50.718]             }
[09:29:50.718]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:50.718]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:50.718]         }
[09:29:50.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:50.718]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:50.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:50.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:50.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:50.718]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:50.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:50.718]             base::names(...future.oldOptions))
[09:29:50.718]     }
[09:29:50.718]     if (FALSE) {
[09:29:50.718]     }
[09:29:50.718]     else {
[09:29:50.718]         if (TRUE) {
[09:29:50.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:50.718]                 open = "w")
[09:29:50.718]         }
[09:29:50.718]         else {
[09:29:50.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:50.718]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:50.718]         }
[09:29:50.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:50.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:50.718]             base::sink(type = "output", split = FALSE)
[09:29:50.718]             base::close(...future.stdout)
[09:29:50.718]         }, add = TRUE)
[09:29:50.718]     }
[09:29:50.718]     ...future.frame <- base::sys.nframe()
[09:29:50.718]     ...future.conditions <- base::list()
[09:29:50.718]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:50.718]     if (FALSE) {
[09:29:50.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:50.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:50.718]     }
[09:29:50.718]     ...future.result <- base::tryCatch({
[09:29:50.718]         base::withCallingHandlers({
[09:29:50.718]             ...future.value <- base::withVisible(base::local({
[09:29:50.718]                 ...future.makeSendCondition <- base::local({
[09:29:50.718]                   sendCondition <- NULL
[09:29:50.718]                   function(frame = 1L) {
[09:29:50.718]                     if (is.function(sendCondition)) 
[09:29:50.718]                       return(sendCondition)
[09:29:50.718]                     ns <- getNamespace("parallel")
[09:29:50.718]                     if (exists("sendData", mode = "function", 
[09:29:50.718]                       envir = ns)) {
[09:29:50.718]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:50.718]                         envir = ns)
[09:29:50.718]                       envir <- sys.frame(frame)
[09:29:50.718]                       master <- NULL
[09:29:50.718]                       while (!identical(envir, .GlobalEnv) && 
[09:29:50.718]                         !identical(envir, emptyenv())) {
[09:29:50.718]                         if (exists("master", mode = "list", envir = envir, 
[09:29:50.718]                           inherits = FALSE)) {
[09:29:50.718]                           master <- get("master", mode = "list", 
[09:29:50.718]                             envir = envir, inherits = FALSE)
[09:29:50.718]                           if (inherits(master, c("SOCKnode", 
[09:29:50.718]                             "SOCK0node"))) {
[09:29:50.718]                             sendCondition <<- function(cond) {
[09:29:50.718]                               data <- list(type = "VALUE", value = cond, 
[09:29:50.718]                                 success = TRUE)
[09:29:50.718]                               parallel_sendData(master, data)
[09:29:50.718]                             }
[09:29:50.718]                             return(sendCondition)
[09:29:50.718]                           }
[09:29:50.718]                         }
[09:29:50.718]                         frame <- frame + 1L
[09:29:50.718]                         envir <- sys.frame(frame)
[09:29:50.718]                       }
[09:29:50.718]                     }
[09:29:50.718]                     sendCondition <<- function(cond) NULL
[09:29:50.718]                   }
[09:29:50.718]                 })
[09:29:50.718]                 withCallingHandlers({
[09:29:50.718]                   {
[09:29:50.718]                     do.call(function(...) {
[09:29:50.718]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.718]                       if (!identical(...future.globals.maxSize.org, 
[09:29:50.718]                         ...future.globals.maxSize)) {
[09:29:50.718]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.718]                         on.exit(options(oopts), add = TRUE)
[09:29:50.718]                       }
[09:29:50.718]                       {
[09:29:50.718]                         lapply(seq_along(...future.elements_ii), 
[09:29:50.718]                           FUN = function(jj) {
[09:29:50.718]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.718]                             ...future.FUN(...future.X_jj, ...)
[09:29:50.718]                           })
[09:29:50.718]                       }
[09:29:50.718]                     }, args = future.call.arguments)
[09:29:50.718]                   }
[09:29:50.718]                 }, immediateCondition = function(cond) {
[09:29:50.718]                   sendCondition <- ...future.makeSendCondition()
[09:29:50.718]                   sendCondition(cond)
[09:29:50.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.718]                   {
[09:29:50.718]                     inherits <- base::inherits
[09:29:50.718]                     invokeRestart <- base::invokeRestart
[09:29:50.718]                     is.null <- base::is.null
[09:29:50.718]                     muffled <- FALSE
[09:29:50.718]                     if (inherits(cond, "message")) {
[09:29:50.718]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:50.718]                       if (muffled) 
[09:29:50.718]                         invokeRestart("muffleMessage")
[09:29:50.718]                     }
[09:29:50.718]                     else if (inherits(cond, "warning")) {
[09:29:50.718]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:50.718]                       if (muffled) 
[09:29:50.718]                         invokeRestart("muffleWarning")
[09:29:50.718]                     }
[09:29:50.718]                     else if (inherits(cond, "condition")) {
[09:29:50.718]                       if (!is.null(pattern)) {
[09:29:50.718]                         computeRestarts <- base::computeRestarts
[09:29:50.718]                         grepl <- base::grepl
[09:29:50.718]                         restarts <- computeRestarts(cond)
[09:29:50.718]                         for (restart in restarts) {
[09:29:50.718]                           name <- restart$name
[09:29:50.718]                           if (is.null(name)) 
[09:29:50.718]                             next
[09:29:50.718]                           if (!grepl(pattern, name)) 
[09:29:50.718]                             next
[09:29:50.718]                           invokeRestart(restart)
[09:29:50.718]                           muffled <- TRUE
[09:29:50.718]                           break
[09:29:50.718]                         }
[09:29:50.718]                       }
[09:29:50.718]                     }
[09:29:50.718]                     invisible(muffled)
[09:29:50.718]                   }
[09:29:50.718]                   muffleCondition(cond)
[09:29:50.718]                 })
[09:29:50.718]             }))
[09:29:50.718]             future::FutureResult(value = ...future.value$value, 
[09:29:50.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:50.718]                   ...future.rng), globalenv = if (FALSE) 
[09:29:50.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:50.718]                     ...future.globalenv.names))
[09:29:50.718]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:50.718]         }, condition = base::local({
[09:29:50.718]             c <- base::c
[09:29:50.718]             inherits <- base::inherits
[09:29:50.718]             invokeRestart <- base::invokeRestart
[09:29:50.718]             length <- base::length
[09:29:50.718]             list <- base::list
[09:29:50.718]             seq.int <- base::seq.int
[09:29:50.718]             signalCondition <- base::signalCondition
[09:29:50.718]             sys.calls <- base::sys.calls
[09:29:50.718]             `[[` <- base::`[[`
[09:29:50.718]             `+` <- base::`+`
[09:29:50.718]             `<<-` <- base::`<<-`
[09:29:50.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:50.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:50.718]                   3L)]
[09:29:50.718]             }
[09:29:50.718]             function(cond) {
[09:29:50.718]                 is_error <- inherits(cond, "error")
[09:29:50.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:50.718]                   NULL)
[09:29:50.718]                 if (is_error) {
[09:29:50.718]                   sessionInformation <- function() {
[09:29:50.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:50.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:50.718]                       search = base::search(), system = base::Sys.info())
[09:29:50.718]                   }
[09:29:50.718]                   ...future.conditions[[length(...future.conditions) + 
[09:29:50.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:50.718]                     cond$call), session = sessionInformation(), 
[09:29:50.718]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:50.718]                   signalCondition(cond)
[09:29:50.718]                 }
[09:29:50.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:50.718]                 "immediateCondition"))) {
[09:29:50.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:50.718]                   ...future.conditions[[length(...future.conditions) + 
[09:29:50.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:50.718]                   if (TRUE && !signal) {
[09:29:50.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.718]                     {
[09:29:50.718]                       inherits <- base::inherits
[09:29:50.718]                       invokeRestart <- base::invokeRestart
[09:29:50.718]                       is.null <- base::is.null
[09:29:50.718]                       muffled <- FALSE
[09:29:50.718]                       if (inherits(cond, "message")) {
[09:29:50.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:50.718]                         if (muffled) 
[09:29:50.718]                           invokeRestart("muffleMessage")
[09:29:50.718]                       }
[09:29:50.718]                       else if (inherits(cond, "warning")) {
[09:29:50.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:50.718]                         if (muffled) 
[09:29:50.718]                           invokeRestart("muffleWarning")
[09:29:50.718]                       }
[09:29:50.718]                       else if (inherits(cond, "condition")) {
[09:29:50.718]                         if (!is.null(pattern)) {
[09:29:50.718]                           computeRestarts <- base::computeRestarts
[09:29:50.718]                           grepl <- base::grepl
[09:29:50.718]                           restarts <- computeRestarts(cond)
[09:29:50.718]                           for (restart in restarts) {
[09:29:50.718]                             name <- restart$name
[09:29:50.718]                             if (is.null(name)) 
[09:29:50.718]                               next
[09:29:50.718]                             if (!grepl(pattern, name)) 
[09:29:50.718]                               next
[09:29:50.718]                             invokeRestart(restart)
[09:29:50.718]                             muffled <- TRUE
[09:29:50.718]                             break
[09:29:50.718]                           }
[09:29:50.718]                         }
[09:29:50.718]                       }
[09:29:50.718]                       invisible(muffled)
[09:29:50.718]                     }
[09:29:50.718]                     muffleCondition(cond, pattern = "^muffle")
[09:29:50.718]                   }
[09:29:50.718]                 }
[09:29:50.718]                 else {
[09:29:50.718]                   if (TRUE) {
[09:29:50.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.718]                     {
[09:29:50.718]                       inherits <- base::inherits
[09:29:50.718]                       invokeRestart <- base::invokeRestart
[09:29:50.718]                       is.null <- base::is.null
[09:29:50.718]                       muffled <- FALSE
[09:29:50.718]                       if (inherits(cond, "message")) {
[09:29:50.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:50.718]                         if (muffled) 
[09:29:50.718]                           invokeRestart("muffleMessage")
[09:29:50.718]                       }
[09:29:50.718]                       else if (inherits(cond, "warning")) {
[09:29:50.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:50.718]                         if (muffled) 
[09:29:50.718]                           invokeRestart("muffleWarning")
[09:29:50.718]                       }
[09:29:50.718]                       else if (inherits(cond, "condition")) {
[09:29:50.718]                         if (!is.null(pattern)) {
[09:29:50.718]                           computeRestarts <- base::computeRestarts
[09:29:50.718]                           grepl <- base::grepl
[09:29:50.718]                           restarts <- computeRestarts(cond)
[09:29:50.718]                           for (restart in restarts) {
[09:29:50.718]                             name <- restart$name
[09:29:50.718]                             if (is.null(name)) 
[09:29:50.718]                               next
[09:29:50.718]                             if (!grepl(pattern, name)) 
[09:29:50.718]                               next
[09:29:50.718]                             invokeRestart(restart)
[09:29:50.718]                             muffled <- TRUE
[09:29:50.718]                             break
[09:29:50.718]                           }
[09:29:50.718]                         }
[09:29:50.718]                       }
[09:29:50.718]                       invisible(muffled)
[09:29:50.718]                     }
[09:29:50.718]                     muffleCondition(cond, pattern = "^muffle")
[09:29:50.718]                   }
[09:29:50.718]                 }
[09:29:50.718]             }
[09:29:50.718]         }))
[09:29:50.718]     }, error = function(ex) {
[09:29:50.718]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:50.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:50.718]                 ...future.rng), started = ...future.startTime, 
[09:29:50.718]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:50.718]             version = "1.8"), class = "FutureResult")
[09:29:50.718]     }, finally = {
[09:29:50.718]         if (!identical(...future.workdir, getwd())) 
[09:29:50.718]             setwd(...future.workdir)
[09:29:50.718]         {
[09:29:50.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:50.718]                 ...future.oldOptions$nwarnings <- NULL
[09:29:50.718]             }
[09:29:50.718]             base::options(...future.oldOptions)
[09:29:50.718]             if (.Platform$OS.type == "windows") {
[09:29:50.718]                 old_names <- names(...future.oldEnvVars)
[09:29:50.718]                 envs <- base::Sys.getenv()
[09:29:50.718]                 names <- names(envs)
[09:29:50.718]                 common <- intersect(names, old_names)
[09:29:50.718]                 added <- setdiff(names, old_names)
[09:29:50.718]                 removed <- setdiff(old_names, names)
[09:29:50.718]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:50.718]                   envs[common]]
[09:29:50.718]                 NAMES <- toupper(changed)
[09:29:50.718]                 args <- list()
[09:29:50.718]                 for (kk in seq_along(NAMES)) {
[09:29:50.718]                   name <- changed[[kk]]
[09:29:50.718]                   NAME <- NAMES[[kk]]
[09:29:50.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.718]                     next
[09:29:50.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:50.718]                 }
[09:29:50.718]                 NAMES <- toupper(added)
[09:29:50.718]                 for (kk in seq_along(NAMES)) {
[09:29:50.718]                   name <- added[[kk]]
[09:29:50.718]                   NAME <- NAMES[[kk]]
[09:29:50.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.718]                     next
[09:29:50.718]                   args[[name]] <- ""
[09:29:50.718]                 }
[09:29:50.718]                 NAMES <- toupper(removed)
[09:29:50.718]                 for (kk in seq_along(NAMES)) {
[09:29:50.718]                   name <- removed[[kk]]
[09:29:50.718]                   NAME <- NAMES[[kk]]
[09:29:50.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.718]                     next
[09:29:50.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:50.718]                 }
[09:29:50.718]                 if (length(args) > 0) 
[09:29:50.718]                   base::do.call(base::Sys.setenv, args = args)
[09:29:50.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:50.718]             }
[09:29:50.718]             else {
[09:29:50.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:50.718]             }
[09:29:50.718]             {
[09:29:50.718]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:50.718]                   0L) {
[09:29:50.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:50.718]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:50.718]                   base::options(opts)
[09:29:50.718]                 }
[09:29:50.718]                 {
[09:29:50.718]                   {
[09:29:50.718]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:50.718]                     NULL
[09:29:50.718]                   }
[09:29:50.718]                   options(future.plan = NULL)
[09:29:50.718]                   if (is.na(NA_character_)) 
[09:29:50.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:50.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:50.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:50.718]                     .init = FALSE)
[09:29:50.718]                 }
[09:29:50.718]             }
[09:29:50.718]         }
[09:29:50.718]     })
[09:29:50.718]     if (TRUE) {
[09:29:50.718]         base::sink(type = "output", split = FALSE)
[09:29:50.718]         if (TRUE) {
[09:29:50.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:50.718]         }
[09:29:50.718]         else {
[09:29:50.718]             ...future.result["stdout"] <- base::list(NULL)
[09:29:50.718]         }
[09:29:50.718]         base::close(...future.stdout)
[09:29:50.718]         ...future.stdout <- NULL
[09:29:50.718]     }
[09:29:50.718]     ...future.result$conditions <- ...future.conditions
[09:29:50.718]     ...future.result$finished <- base::Sys.time()
[09:29:50.718]     ...future.result
[09:29:50.718] }
[09:29:50.721] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[09:29:50.721] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:50.764] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:50.764] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[09:29:50.765] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[09:29:50.765] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:50.765] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:50.765] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:50.808] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:50.808] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:50.852] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:50.852] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:50.853] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.853] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:50.853] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:50.853] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:50.854] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.854] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:50.854] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:50.854] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:50.855] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.855] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:50.855] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:50.855] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[09:29:50.856] MultisessionFuture started
[09:29:50.856] - Launch lazy future ... done
[09:29:50.856] run() for ‘MultisessionFuture’ ... done
[09:29:50.856] Created future:
[09:29:50.858] receiveMessageFromWorker() for ClusterFuture ...
[09:29:50.858] - Validating connection of MultisessionFuture
[09:29:50.858] - received message: FutureResult
[09:29:50.858] - Received FutureResult
[09:29:50.858] - Erased future from FutureRegistry
[09:29:50.858] result() for ClusterFuture ...
[09:29:50.858] - result already collected: FutureResult
[09:29:50.858] result() for ClusterFuture ... done
[09:29:50.859] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:50.856] MultisessionFuture:
[09:29:50.856] Label: ‘future_vapply-1’
[09:29:50.856] Expression:
[09:29:50.856] {
[09:29:50.856]     do.call(function(...) {
[09:29:50.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:50.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.856]             on.exit(options(oopts), add = TRUE)
[09:29:50.856]         }
[09:29:50.856]         {
[09:29:50.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:50.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.856]                 ...future.FUN(...future.X_jj, ...)
[09:29:50.856]             })
[09:29:50.856]         }
[09:29:50.856]     }, args = future.call.arguments)
[09:29:50.856] }
[09:29:50.856] Lazy evaluation: FALSE
[09:29:50.856] Asynchronous evaluation: TRUE
[09:29:50.856] Local evaluation: TRUE
[09:29:50.856] Environment: R_GlobalEnv
[09:29:50.856] Capture standard output: TRUE
[09:29:50.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:50.856] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:50.856] Packages: 1 packages (‘future.apply’)
[09:29:50.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:50.856] Resolved: TRUE
[09:29:50.856] Value: <not collected>
[09:29:50.856] Conditions captured: <none>
[09:29:50.856] Early signaling: FALSE
[09:29:50.856] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:50.856] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:50.859] Chunk #1 of 2 ... DONE
[09:29:50.859] Chunk #2 of 2 ...
[09:29:50.859]  - Finding globals in 'X' for chunk #2 ...
[09:29:50.859] getGlobalsAndPackages() ...
[09:29:50.859] Searching for globals...
[09:29:50.859] 
[09:29:50.860] Searching for globals ... DONE
[09:29:50.860] - globals: [0] <none>
[09:29:50.860] getGlobalsAndPackages() ... DONE
[09:29:50.860]    + additional globals found: [n=0] 
[09:29:50.860]    + additional namespaces needed: [n=0] 
[09:29:50.860]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:50.860]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:50.860]  - seeds: <none>
[09:29:50.860]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.860] getGlobalsAndPackages() ...
[09:29:50.860] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.861] Resolving globals: FALSE
[09:29:50.861] Tweak future expression to call with '...' arguments ...
[09:29:50.861] {
[09:29:50.861]     do.call(function(...) {
[09:29:50.861]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.861]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:50.861]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.861]             on.exit(options(oopts), add = TRUE)
[09:29:50.861]         }
[09:29:50.861]         {
[09:29:50.861]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:50.861]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.861]                 ...future.FUN(...future.X_jj, ...)
[09:29:50.861]             })
[09:29:50.861]         }
[09:29:50.861]     }, args = future.call.arguments)
[09:29:50.861] }
[09:29:50.861] Tweak future expression to call with '...' arguments ... DONE
[09:29:50.862] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:50.862] - packages: [1] ‘future.apply’
[09:29:50.862] getGlobalsAndPackages() ... DONE
[09:29:50.862] run() for ‘Future’ ...
[09:29:50.862] - state: ‘created’
[09:29:50.862] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:50.878] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:50.878] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:50.878]   - Field: ‘node’
[09:29:50.878]   - Field: ‘label’
[09:29:50.878]   - Field: ‘local’
[09:29:50.878]   - Field: ‘owner’
[09:29:50.879]   - Field: ‘envir’
[09:29:50.879]   - Field: ‘workers’
[09:29:50.879]   - Field: ‘packages’
[09:29:50.879]   - Field: ‘gc’
[09:29:50.879]   - Field: ‘conditions’
[09:29:50.879]   - Field: ‘persistent’
[09:29:50.879]   - Field: ‘expr’
[09:29:50.879]   - Field: ‘uuid’
[09:29:50.879]   - Field: ‘seed’
[09:29:50.879]   - Field: ‘version’
[09:29:50.879]   - Field: ‘result’
[09:29:50.879]   - Field: ‘asynchronous’
[09:29:50.880]   - Field: ‘calls’
[09:29:50.880]   - Field: ‘globals’
[09:29:50.880]   - Field: ‘stdout’
[09:29:50.880]   - Field: ‘earlySignal’
[09:29:50.880]   - Field: ‘lazy’
[09:29:50.880]   - Field: ‘state’
[09:29:50.880] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:50.880] - Launch lazy future ...
[09:29:50.880] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:50.881] Packages needed by future strategies (n = 0): <none>
[09:29:50.881] {
[09:29:50.881]     {
[09:29:50.881]         {
[09:29:50.881]             ...future.startTime <- base::Sys.time()
[09:29:50.881]             {
[09:29:50.881]                 {
[09:29:50.881]                   {
[09:29:50.881]                     {
[09:29:50.881]                       {
[09:29:50.881]                         base::local({
[09:29:50.881]                           has_future <- base::requireNamespace("future", 
[09:29:50.881]                             quietly = TRUE)
[09:29:50.881]                           if (has_future) {
[09:29:50.881]                             ns <- base::getNamespace("future")
[09:29:50.881]                             version <- ns[[".package"]][["version"]]
[09:29:50.881]                             if (is.null(version)) 
[09:29:50.881]                               version <- utils::packageVersion("future")
[09:29:50.881]                           }
[09:29:50.881]                           else {
[09:29:50.881]                             version <- NULL
[09:29:50.881]                           }
[09:29:50.881]                           if (!has_future || version < "1.8.0") {
[09:29:50.881]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:50.881]                               "", base::R.version$version.string), 
[09:29:50.881]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:50.881]                                 base::R.version$platform, 8 * 
[09:29:50.881]                                   base::.Machine$sizeof.pointer), 
[09:29:50.881]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:50.881]                                 "release", "version")], collapse = " "), 
[09:29:50.881]                               hostname = base::Sys.info()[["nodename"]])
[09:29:50.881]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:50.881]                               info)
[09:29:50.881]                             info <- base::paste(info, collapse = "; ")
[09:29:50.881]                             if (!has_future) {
[09:29:50.881]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:50.881]                                 info)
[09:29:50.881]                             }
[09:29:50.881]                             else {
[09:29:50.881]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:50.881]                                 info, version)
[09:29:50.881]                             }
[09:29:50.881]                             base::stop(msg)
[09:29:50.881]                           }
[09:29:50.881]                         })
[09:29:50.881]                       }
[09:29:50.881]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:50.881]                       base::options(mc.cores = 1L)
[09:29:50.881]                     }
[09:29:50.881]                     base::local({
[09:29:50.881]                       for (pkg in "future.apply") {
[09:29:50.881]                         base::loadNamespace(pkg)
[09:29:50.881]                         base::library(pkg, character.only = TRUE)
[09:29:50.881]                       }
[09:29:50.881]                     })
[09:29:50.881]                   }
[09:29:50.881]                   ...future.strategy.old <- future::plan("list")
[09:29:50.881]                   options(future.plan = NULL)
[09:29:50.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:50.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:50.881]                 }
[09:29:50.881]                 ...future.workdir <- getwd()
[09:29:50.881]             }
[09:29:50.881]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:50.881]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:50.881]         }
[09:29:50.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:50.881]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:50.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:50.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:50.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:50.881]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:50.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:50.881]             base::names(...future.oldOptions))
[09:29:50.881]     }
[09:29:50.881]     if (FALSE) {
[09:29:50.881]     }
[09:29:50.881]     else {
[09:29:50.881]         if (TRUE) {
[09:29:50.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:50.881]                 open = "w")
[09:29:50.881]         }
[09:29:50.881]         else {
[09:29:50.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:50.881]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:50.881]         }
[09:29:50.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:50.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:50.881]             base::sink(type = "output", split = FALSE)
[09:29:50.881]             base::close(...future.stdout)
[09:29:50.881]         }, add = TRUE)
[09:29:50.881]     }
[09:29:50.881]     ...future.frame <- base::sys.nframe()
[09:29:50.881]     ...future.conditions <- base::list()
[09:29:50.881]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:50.881]     if (FALSE) {
[09:29:50.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:50.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:50.881]     }
[09:29:50.881]     ...future.result <- base::tryCatch({
[09:29:50.881]         base::withCallingHandlers({
[09:29:50.881]             ...future.value <- base::withVisible(base::local({
[09:29:50.881]                 ...future.makeSendCondition <- base::local({
[09:29:50.881]                   sendCondition <- NULL
[09:29:50.881]                   function(frame = 1L) {
[09:29:50.881]                     if (is.function(sendCondition)) 
[09:29:50.881]                       return(sendCondition)
[09:29:50.881]                     ns <- getNamespace("parallel")
[09:29:50.881]                     if (exists("sendData", mode = "function", 
[09:29:50.881]                       envir = ns)) {
[09:29:50.881]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:50.881]                         envir = ns)
[09:29:50.881]                       envir <- sys.frame(frame)
[09:29:50.881]                       master <- NULL
[09:29:50.881]                       while (!identical(envir, .GlobalEnv) && 
[09:29:50.881]                         !identical(envir, emptyenv())) {
[09:29:50.881]                         if (exists("master", mode = "list", envir = envir, 
[09:29:50.881]                           inherits = FALSE)) {
[09:29:50.881]                           master <- get("master", mode = "list", 
[09:29:50.881]                             envir = envir, inherits = FALSE)
[09:29:50.881]                           if (inherits(master, c("SOCKnode", 
[09:29:50.881]                             "SOCK0node"))) {
[09:29:50.881]                             sendCondition <<- function(cond) {
[09:29:50.881]                               data <- list(type = "VALUE", value = cond, 
[09:29:50.881]                                 success = TRUE)
[09:29:50.881]                               parallel_sendData(master, data)
[09:29:50.881]                             }
[09:29:50.881]                             return(sendCondition)
[09:29:50.881]                           }
[09:29:50.881]                         }
[09:29:50.881]                         frame <- frame + 1L
[09:29:50.881]                         envir <- sys.frame(frame)
[09:29:50.881]                       }
[09:29:50.881]                     }
[09:29:50.881]                     sendCondition <<- function(cond) NULL
[09:29:50.881]                   }
[09:29:50.881]                 })
[09:29:50.881]                 withCallingHandlers({
[09:29:50.881]                   {
[09:29:50.881]                     do.call(function(...) {
[09:29:50.881]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:50.881]                       if (!identical(...future.globals.maxSize.org, 
[09:29:50.881]                         ...future.globals.maxSize)) {
[09:29:50.881]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:50.881]                         on.exit(options(oopts), add = TRUE)
[09:29:50.881]                       }
[09:29:50.881]                       {
[09:29:50.881]                         lapply(seq_along(...future.elements_ii), 
[09:29:50.881]                           FUN = function(jj) {
[09:29:50.881]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:50.881]                             ...future.FUN(...future.X_jj, ...)
[09:29:50.881]                           })
[09:29:50.881]                       }
[09:29:50.881]                     }, args = future.call.arguments)
[09:29:50.881]                   }
[09:29:50.881]                 }, immediateCondition = function(cond) {
[09:29:50.881]                   sendCondition <- ...future.makeSendCondition()
[09:29:50.881]                   sendCondition(cond)
[09:29:50.881]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.881]                   {
[09:29:50.881]                     inherits <- base::inherits
[09:29:50.881]                     invokeRestart <- base::invokeRestart
[09:29:50.881]                     is.null <- base::is.null
[09:29:50.881]                     muffled <- FALSE
[09:29:50.881]                     if (inherits(cond, "message")) {
[09:29:50.881]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:50.881]                       if (muffled) 
[09:29:50.881]                         invokeRestart("muffleMessage")
[09:29:50.881]                     }
[09:29:50.881]                     else if (inherits(cond, "warning")) {
[09:29:50.881]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:50.881]                       if (muffled) 
[09:29:50.881]                         invokeRestart("muffleWarning")
[09:29:50.881]                     }
[09:29:50.881]                     else if (inherits(cond, "condition")) {
[09:29:50.881]                       if (!is.null(pattern)) {
[09:29:50.881]                         computeRestarts <- base::computeRestarts
[09:29:50.881]                         grepl <- base::grepl
[09:29:50.881]                         restarts <- computeRestarts(cond)
[09:29:50.881]                         for (restart in restarts) {
[09:29:50.881]                           name <- restart$name
[09:29:50.881]                           if (is.null(name)) 
[09:29:50.881]                             next
[09:29:50.881]                           if (!grepl(pattern, name)) 
[09:29:50.881]                             next
[09:29:50.881]                           invokeRestart(restart)
[09:29:50.881]                           muffled <- TRUE
[09:29:50.881]                           break
[09:29:50.881]                         }
[09:29:50.881]                       }
[09:29:50.881]                     }
[09:29:50.881]                     invisible(muffled)
[09:29:50.881]                   }
[09:29:50.881]                   muffleCondition(cond)
[09:29:50.881]                 })
[09:29:50.881]             }))
[09:29:50.881]             future::FutureResult(value = ...future.value$value, 
[09:29:50.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:50.881]                   ...future.rng), globalenv = if (FALSE) 
[09:29:50.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:50.881]                     ...future.globalenv.names))
[09:29:50.881]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:50.881]         }, condition = base::local({
[09:29:50.881]             c <- base::c
[09:29:50.881]             inherits <- base::inherits
[09:29:50.881]             invokeRestart <- base::invokeRestart
[09:29:50.881]             length <- base::length
[09:29:50.881]             list <- base::list
[09:29:50.881]             seq.int <- base::seq.int
[09:29:50.881]             signalCondition <- base::signalCondition
[09:29:50.881]             sys.calls <- base::sys.calls
[09:29:50.881]             `[[` <- base::`[[`
[09:29:50.881]             `+` <- base::`+`
[09:29:50.881]             `<<-` <- base::`<<-`
[09:29:50.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:50.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:50.881]                   3L)]
[09:29:50.881]             }
[09:29:50.881]             function(cond) {
[09:29:50.881]                 is_error <- inherits(cond, "error")
[09:29:50.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:50.881]                   NULL)
[09:29:50.881]                 if (is_error) {
[09:29:50.881]                   sessionInformation <- function() {
[09:29:50.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:50.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:50.881]                       search = base::search(), system = base::Sys.info())
[09:29:50.881]                   }
[09:29:50.881]                   ...future.conditions[[length(...future.conditions) + 
[09:29:50.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:50.881]                     cond$call), session = sessionInformation(), 
[09:29:50.881]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:50.881]                   signalCondition(cond)
[09:29:50.881]                 }
[09:29:50.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:50.881]                 "immediateCondition"))) {
[09:29:50.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:50.881]                   ...future.conditions[[length(...future.conditions) + 
[09:29:50.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:50.881]                   if (TRUE && !signal) {
[09:29:50.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.881]                     {
[09:29:50.881]                       inherits <- base::inherits
[09:29:50.881]                       invokeRestart <- base::invokeRestart
[09:29:50.881]                       is.null <- base::is.null
[09:29:50.881]                       muffled <- FALSE
[09:29:50.881]                       if (inherits(cond, "message")) {
[09:29:50.881]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:50.881]                         if (muffled) 
[09:29:50.881]                           invokeRestart("muffleMessage")
[09:29:50.881]                       }
[09:29:50.881]                       else if (inherits(cond, "warning")) {
[09:29:50.881]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:50.881]                         if (muffled) 
[09:29:50.881]                           invokeRestart("muffleWarning")
[09:29:50.881]                       }
[09:29:50.881]                       else if (inherits(cond, "condition")) {
[09:29:50.881]                         if (!is.null(pattern)) {
[09:29:50.881]                           computeRestarts <- base::computeRestarts
[09:29:50.881]                           grepl <- base::grepl
[09:29:50.881]                           restarts <- computeRestarts(cond)
[09:29:50.881]                           for (restart in restarts) {
[09:29:50.881]                             name <- restart$name
[09:29:50.881]                             if (is.null(name)) 
[09:29:50.881]                               next
[09:29:50.881]                             if (!grepl(pattern, name)) 
[09:29:50.881]                               next
[09:29:50.881]                             invokeRestart(restart)
[09:29:50.881]                             muffled <- TRUE
[09:29:50.881]                             break
[09:29:50.881]                           }
[09:29:50.881]                         }
[09:29:50.881]                       }
[09:29:50.881]                       invisible(muffled)
[09:29:50.881]                     }
[09:29:50.881]                     muffleCondition(cond, pattern = "^muffle")
[09:29:50.881]                   }
[09:29:50.881]                 }
[09:29:50.881]                 else {
[09:29:50.881]                   if (TRUE) {
[09:29:50.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:50.881]                     {
[09:29:50.881]                       inherits <- base::inherits
[09:29:50.881]                       invokeRestart <- base::invokeRestart
[09:29:50.881]                       is.null <- base::is.null
[09:29:50.881]                       muffled <- FALSE
[09:29:50.881]                       if (inherits(cond, "message")) {
[09:29:50.881]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:50.881]                         if (muffled) 
[09:29:50.881]                           invokeRestart("muffleMessage")
[09:29:50.881]                       }
[09:29:50.881]                       else if (inherits(cond, "warning")) {
[09:29:50.881]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:50.881]                         if (muffled) 
[09:29:50.881]                           invokeRestart("muffleWarning")
[09:29:50.881]                       }
[09:29:50.881]                       else if (inherits(cond, "condition")) {
[09:29:50.881]                         if (!is.null(pattern)) {
[09:29:50.881]                           computeRestarts <- base::computeRestarts
[09:29:50.881]                           grepl <- base::grepl
[09:29:50.881]                           restarts <- computeRestarts(cond)
[09:29:50.881]                           for (restart in restarts) {
[09:29:50.881]                             name <- restart$name
[09:29:50.881]                             if (is.null(name)) 
[09:29:50.881]                               next
[09:29:50.881]                             if (!grepl(pattern, name)) 
[09:29:50.881]                               next
[09:29:50.881]                             invokeRestart(restart)
[09:29:50.881]                             muffled <- TRUE
[09:29:50.881]                             break
[09:29:50.881]                           }
[09:29:50.881]                         }
[09:29:50.881]                       }
[09:29:50.881]                       invisible(muffled)
[09:29:50.881]                     }
[09:29:50.881]                     muffleCondition(cond, pattern = "^muffle")
[09:29:50.881]                   }
[09:29:50.881]                 }
[09:29:50.881]             }
[09:29:50.881]         }))
[09:29:50.881]     }, error = function(ex) {
[09:29:50.881]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:50.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:50.881]                 ...future.rng), started = ...future.startTime, 
[09:29:50.881]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:50.881]             version = "1.8"), class = "FutureResult")
[09:29:50.881]     }, finally = {
[09:29:50.881]         if (!identical(...future.workdir, getwd())) 
[09:29:50.881]             setwd(...future.workdir)
[09:29:50.881]         {
[09:29:50.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:50.881]                 ...future.oldOptions$nwarnings <- NULL
[09:29:50.881]             }
[09:29:50.881]             base::options(...future.oldOptions)
[09:29:50.881]             if (.Platform$OS.type == "windows") {
[09:29:50.881]                 old_names <- names(...future.oldEnvVars)
[09:29:50.881]                 envs <- base::Sys.getenv()
[09:29:50.881]                 names <- names(envs)
[09:29:50.881]                 common <- intersect(names, old_names)
[09:29:50.881]                 added <- setdiff(names, old_names)
[09:29:50.881]                 removed <- setdiff(old_names, names)
[09:29:50.881]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:50.881]                   envs[common]]
[09:29:50.881]                 NAMES <- toupper(changed)
[09:29:50.881]                 args <- list()
[09:29:50.881]                 for (kk in seq_along(NAMES)) {
[09:29:50.881]                   name <- changed[[kk]]
[09:29:50.881]                   NAME <- NAMES[[kk]]
[09:29:50.881]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.881]                     next
[09:29:50.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:50.881]                 }
[09:29:50.881]                 NAMES <- toupper(added)
[09:29:50.881]                 for (kk in seq_along(NAMES)) {
[09:29:50.881]                   name <- added[[kk]]
[09:29:50.881]                   NAME <- NAMES[[kk]]
[09:29:50.881]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.881]                     next
[09:29:50.881]                   args[[name]] <- ""
[09:29:50.881]                 }
[09:29:50.881]                 NAMES <- toupper(removed)
[09:29:50.881]                 for (kk in seq_along(NAMES)) {
[09:29:50.881]                   name <- removed[[kk]]
[09:29:50.881]                   NAME <- NAMES[[kk]]
[09:29:50.881]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:50.881]                     next
[09:29:50.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:50.881]                 }
[09:29:50.881]                 if (length(args) > 0) 
[09:29:50.881]                   base::do.call(base::Sys.setenv, args = args)
[09:29:50.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:50.881]             }
[09:29:50.881]             else {
[09:29:50.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:50.881]             }
[09:29:50.881]             {
[09:29:50.881]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:50.881]                   0L) {
[09:29:50.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:50.881]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:50.881]                   base::options(opts)
[09:29:50.881]                 }
[09:29:50.881]                 {
[09:29:50.881]                   {
[09:29:50.881]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:50.881]                     NULL
[09:29:50.881]                   }
[09:29:50.881]                   options(future.plan = NULL)
[09:29:50.881]                   if (is.na(NA_character_)) 
[09:29:50.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:50.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:50.881]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:50.881]                     .init = FALSE)
[09:29:50.881]                 }
[09:29:50.881]             }
[09:29:50.881]         }
[09:29:50.881]     })
[09:29:50.881]     if (TRUE) {
[09:29:50.881]         base::sink(type = "output", split = FALSE)
[09:29:50.881]         if (TRUE) {
[09:29:50.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:50.881]         }
[09:29:50.881]         else {
[09:29:50.881]             ...future.result["stdout"] <- base::list(NULL)
[09:29:50.881]         }
[09:29:50.881]         base::close(...future.stdout)
[09:29:50.881]         ...future.stdout <- NULL
[09:29:50.881]     }
[09:29:50.881]     ...future.result$conditions <- ...future.conditions
[09:29:50.881]     ...future.result$finished <- base::Sys.time()
[09:29:50.881]     ...future.result
[09:29:50.881] }
[09:29:50.884] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[09:29:50.884] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:50.928] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:50.928] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[09:29:50.929] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[09:29:50.929] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:50.929] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:50.929] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:50.972] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:50.972] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:51.016] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:51.016] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:51.017] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.017] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:51.017] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:51.017] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:51.018] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.018] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:51.018] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:51.018] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:51.019] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.019] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:51.019] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.019] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[09:29:51.020] MultisessionFuture started
[09:29:51.020] - Launch lazy future ... done
[09:29:51.020] run() for ‘MultisessionFuture’ ... done
[09:29:51.020] Created future:
[09:29:51.021] receiveMessageFromWorker() for ClusterFuture ...
[09:29:51.022] - Validating connection of MultisessionFuture
[09:29:51.022] - received message: FutureResult
[09:29:51.022] - Received FutureResult
[09:29:51.022] - Erased future from FutureRegistry
[09:29:51.022] result() for ClusterFuture ...
[09:29:51.022] - result already collected: FutureResult
[09:29:51.022] result() for ClusterFuture ... done
[09:29:51.022] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:51.020] MultisessionFuture:
[09:29:51.020] Label: ‘future_vapply-2’
[09:29:51.020] Expression:
[09:29:51.020] {
[09:29:51.020]     do.call(function(...) {
[09:29:51.020]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.020]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.020]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.020]             on.exit(options(oopts), add = TRUE)
[09:29:51.020]         }
[09:29:51.020]         {
[09:29:51.020]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.020]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.020]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.020]             })
[09:29:51.020]         }
[09:29:51.020]     }, args = future.call.arguments)
[09:29:51.020] }
[09:29:51.020] Lazy evaluation: FALSE
[09:29:51.020] Asynchronous evaluation: TRUE
[09:29:51.020] Local evaluation: TRUE
[09:29:51.020] Environment: R_GlobalEnv
[09:29:51.020] Capture standard output: TRUE
[09:29:51.020] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:51.020] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:51.020] Packages: 1 packages (‘future.apply’)
[09:29:51.020] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:51.020] Resolved: TRUE
[09:29:51.020] Value: <not collected>
[09:29:51.020] Conditions captured: <none>
[09:29:51.020] Early signaling: FALSE
[09:29:51.020] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:51.020] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.023] Chunk #2 of 2 ... DONE
[09:29:51.023] Launching 2 futures (chunks) ... DONE
[09:29:51.023] Resolving 2 futures (chunks) ...
[09:29:51.023] resolve() on list ...
[09:29:51.023]  recursive: 0
[09:29:51.023]  length: 2
[09:29:51.023] 
[09:29:51.023] Future #1
[09:29:51.023] result() for ClusterFuture ...
[09:29:51.023] - result already collected: FutureResult
[09:29:51.023] result() for ClusterFuture ... done
[09:29:51.024] result() for ClusterFuture ...
[09:29:51.024] - result already collected: FutureResult
[09:29:51.024] result() for ClusterFuture ... done
[09:29:51.024] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:51.024] - nx: 2
[09:29:51.024] - relay: TRUE
[09:29:51.024] - stdout: TRUE
[09:29:51.024] - signal: TRUE
[09:29:51.024] - resignal: FALSE
[09:29:51.024] - force: TRUE
[09:29:51.024] - relayed: [n=2] FALSE, FALSE
[09:29:51.025] - queued futures: [n=2] FALSE, FALSE
[09:29:51.025]  - until=1
[09:29:51.025]  - relaying element #1
[09:29:51.025] result() for ClusterFuture ...
[09:29:51.025] - result already collected: FutureResult
[09:29:51.025] result() for ClusterFuture ... done
[09:29:51.025] result() for ClusterFuture ...
[09:29:51.025] - result already collected: FutureResult
[09:29:51.025] result() for ClusterFuture ... done
[09:29:51.025] result() for ClusterFuture ...
[09:29:51.025] - result already collected: FutureResult
[09:29:51.026] result() for ClusterFuture ... done
[09:29:51.026] result() for ClusterFuture ...
[09:29:51.026] - result already collected: FutureResult
[09:29:51.026] result() for ClusterFuture ... done
[09:29:51.026] - relayed: [n=2] TRUE, FALSE
[09:29:51.026] - queued futures: [n=2] TRUE, FALSE
[09:29:51.026] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:51.026]  length: 1 (resolved future 1)
[09:29:51.026] Future #2
[09:29:51.026] result() for ClusterFuture ...
[09:29:51.026] - result already collected: FutureResult
[09:29:51.027] result() for ClusterFuture ... done
[09:29:51.027] result() for ClusterFuture ...
[09:29:51.027] - result already collected: FutureResult
[09:29:51.027] result() for ClusterFuture ... done
[09:29:51.027] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:51.027] - nx: 2
[09:29:51.027] - relay: TRUE
[09:29:51.027] - stdout: TRUE
[09:29:51.027] - signal: TRUE
[09:29:51.027] - resignal: FALSE
[09:29:51.027] - force: TRUE
[09:29:51.027] - relayed: [n=2] TRUE, FALSE
[09:29:51.028] - queued futures: [n=2] TRUE, FALSE
[09:29:51.028]  - until=2
[09:29:51.028]  - relaying element #2
[09:29:51.028] result() for ClusterFuture ...
[09:29:51.028] - result already collected: FutureResult
[09:29:51.028] result() for ClusterFuture ... done
[09:29:51.028] result() for ClusterFuture ...
[09:29:51.028] - result already collected: FutureResult
[09:29:51.028] result() for ClusterFuture ... done
[09:29:51.028] result() for ClusterFuture ...
[09:29:51.028] - result already collected: FutureResult
[09:29:51.029] result() for ClusterFuture ... done
[09:29:51.029] result() for ClusterFuture ...
[09:29:51.029] - result already collected: FutureResult
[09:29:51.029] result() for ClusterFuture ... done
[09:29:51.029] - relayed: [n=2] TRUE, TRUE
[09:29:51.029] - queued futures: [n=2] TRUE, TRUE
[09:29:51.029] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:51.029]  length: 0 (resolved future 2)
[09:29:51.029] Relaying remaining futures
[09:29:51.029] signalConditionsASAP(NULL, pos=0) ...
[09:29:51.029] - nx: 2
[09:29:51.029] - relay: TRUE
[09:29:51.030] - stdout: TRUE
[09:29:51.030] - signal: TRUE
[09:29:51.030] - resignal: FALSE
[09:29:51.030] - force: TRUE
[09:29:51.030] - relayed: [n=2] TRUE, TRUE
[09:29:51.030] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:51.030] - relayed: [n=2] TRUE, TRUE
[09:29:51.030] - queued futures: [n=2] TRUE, TRUE
[09:29:51.030] signalConditionsASAP(NULL, pos=0) ... done
[09:29:51.030] resolve() on list ... DONE
[09:29:51.031] result() for ClusterFuture ...
[09:29:51.031] - result already collected: FutureResult
[09:29:51.031] result() for ClusterFuture ... done
[09:29:51.031] result() for ClusterFuture ...
[09:29:51.031] - result already collected: FutureResult
[09:29:51.031] result() for ClusterFuture ... done
[09:29:51.031] result() for ClusterFuture ...
[09:29:51.031] - result already collected: FutureResult
[09:29:51.031] result() for ClusterFuture ... done
[09:29:51.031] result() for ClusterFuture ...
[09:29:51.031] - result already collected: FutureResult
[09:29:51.031] result() for ClusterFuture ... done
[09:29:51.032]  - Number of value chunks collected: 2
[09:29:51.032] Resolving 2 futures (chunks) ... DONE
[09:29:51.032] Reducing values from 2 chunks ...
[09:29:51.032]  - Number of values collected after concatenation: 10
[09:29:51.032]  - Number of values expected: 10
[09:29:51.032] Reducing values from 2 chunks ... DONE
[09:29:51.032] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[09:29:51.033] future_lapply() ...
[09:29:51.038] Number of chunks: 2
[09:29:51.039] getGlobalsAndPackagesXApply() ...
[09:29:51.039]  - future.globals: TRUE
[09:29:51.039] getGlobalsAndPackages() ...
[09:29:51.039] Searching for globals...
[09:29:51.042] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[09:29:51.043] Searching for globals ... DONE
[09:29:51.043] Resolving globals: FALSE
[09:29:51.043] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[09:29:51.044] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:51.044] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:51.044] - packages: [1] ‘future.apply’
[09:29:51.044] getGlobalsAndPackages() ... DONE
[09:29:51.044]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:51.044]  - needed namespaces: [n=1] ‘future.apply’
[09:29:51.045] Finding globals ... DONE
[09:29:51.045]  - use_args: TRUE
[09:29:51.045]  - Getting '...' globals ...
[09:29:51.045] resolve() on list ...
[09:29:51.045]  recursive: 0
[09:29:51.045]  length: 1
[09:29:51.045]  elements: ‘...’
[09:29:51.045]  length: 0 (resolved future 1)
[09:29:51.045] resolve() on list ... DONE
[09:29:51.046]    - '...' content: [n=0] 
[09:29:51.046] List of 1
[09:29:51.046]  $ ...: list()
[09:29:51.046]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:51.046]  - attr(*, "where")=List of 1
[09:29:51.046]   ..$ ...:<environment: 0x561d376d0510> 
[09:29:51.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:51.046]  - attr(*, "resolved")= logi TRUE
[09:29:51.046]  - attr(*, "total_size")= num NA
[09:29:51.048]  - Getting '...' globals ... DONE
[09:29:51.048] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:51.048] List of 8
[09:29:51.048]  $ ...future.FUN:function (x, ...)  
[09:29:51.048]  $ x_FUN        :function (x)  
[09:29:51.048]  $ times        : int 4
[09:29:51.048]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:51.048]  $ stop_if_not  :function (...)  
[09:29:51.048]  $ dim          : int [1:2] 2 2
[09:29:51.048]  $ valid_types  : chr [1:2] "logical" "integer"
[09:29:51.048]  $ ...          : list()
[09:29:51.048]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:51.048]  - attr(*, "where")=List of 8
[09:29:51.048]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:51.048]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:51.048]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:51.048]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:51.048]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:51.048]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:51.048]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:51.048]   ..$ ...          :<environment: 0x561d376d0510> 
[09:29:51.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:51.048]  - attr(*, "resolved")= logi FALSE
[09:29:51.048]  - attr(*, "total_size")= num 97232
[09:29:51.054] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:51.054] getGlobalsAndPackagesXApply() ... DONE
[09:29:51.054] Number of futures (= number of chunks): 2
[09:29:51.054] Launching 2 futures (chunks) ...
[09:29:51.054] Chunk #1 of 2 ...
[09:29:51.054]  - Finding globals in 'X' for chunk #1 ...
[09:29:51.054] getGlobalsAndPackages() ...
[09:29:51.054] Searching for globals...
[09:29:51.055] 
[09:29:51.055] Searching for globals ... DONE
[09:29:51.055] - globals: [0] <none>
[09:29:51.055] getGlobalsAndPackages() ... DONE
[09:29:51.055]    + additional globals found: [n=0] 
[09:29:51.055]    + additional namespaces needed: [n=0] 
[09:29:51.055]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:51.055]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:51.055]  - seeds: <none>
[09:29:51.055]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.056] getGlobalsAndPackages() ...
[09:29:51.056] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.056] Resolving globals: FALSE
[09:29:51.056] Tweak future expression to call with '...' arguments ...
[09:29:51.056] {
[09:29:51.056]     do.call(function(...) {
[09:29:51.056]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.056]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.056]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.056]             on.exit(options(oopts), add = TRUE)
[09:29:51.056]         }
[09:29:51.056]         {
[09:29:51.056]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.056]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.056]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.056]             })
[09:29:51.056]         }
[09:29:51.056]     }, args = future.call.arguments)
[09:29:51.056] }
[09:29:51.056] Tweak future expression to call with '...' arguments ... DONE
[09:29:51.057] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.057] - packages: [1] ‘future.apply’
[09:29:51.057] getGlobalsAndPackages() ... DONE
[09:29:51.057] run() for ‘Future’ ...
[09:29:51.057] - state: ‘created’
[09:29:51.057] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:51.071] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:51.071]   - Field: ‘node’
[09:29:51.071]   - Field: ‘label’
[09:29:51.071]   - Field: ‘local’
[09:29:51.071]   - Field: ‘owner’
[09:29:51.072]   - Field: ‘envir’
[09:29:51.072]   - Field: ‘workers’
[09:29:51.072]   - Field: ‘packages’
[09:29:51.072]   - Field: ‘gc’
[09:29:51.072]   - Field: ‘conditions’
[09:29:51.072]   - Field: ‘persistent’
[09:29:51.072]   - Field: ‘expr’
[09:29:51.072]   - Field: ‘uuid’
[09:29:51.072]   - Field: ‘seed’
[09:29:51.072]   - Field: ‘version’
[09:29:51.073]   - Field: ‘result’
[09:29:51.073]   - Field: ‘asynchronous’
[09:29:51.073]   - Field: ‘calls’
[09:29:51.073]   - Field: ‘globals’
[09:29:51.073]   - Field: ‘stdout’
[09:29:51.073]   - Field: ‘earlySignal’
[09:29:51.073]   - Field: ‘lazy’
[09:29:51.073]   - Field: ‘state’
[09:29:51.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:51.073] - Launch lazy future ...
[09:29:51.074] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:51.074] Packages needed by future strategies (n = 0): <none>
[09:29:51.074] {
[09:29:51.074]     {
[09:29:51.074]         {
[09:29:51.074]             ...future.startTime <- base::Sys.time()
[09:29:51.074]             {
[09:29:51.074]                 {
[09:29:51.074]                   {
[09:29:51.074]                     {
[09:29:51.074]                       {
[09:29:51.074]                         base::local({
[09:29:51.074]                           has_future <- base::requireNamespace("future", 
[09:29:51.074]                             quietly = TRUE)
[09:29:51.074]                           if (has_future) {
[09:29:51.074]                             ns <- base::getNamespace("future")
[09:29:51.074]                             version <- ns[[".package"]][["version"]]
[09:29:51.074]                             if (is.null(version)) 
[09:29:51.074]                               version <- utils::packageVersion("future")
[09:29:51.074]                           }
[09:29:51.074]                           else {
[09:29:51.074]                             version <- NULL
[09:29:51.074]                           }
[09:29:51.074]                           if (!has_future || version < "1.8.0") {
[09:29:51.074]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:51.074]                               "", base::R.version$version.string), 
[09:29:51.074]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:51.074]                                 base::R.version$platform, 8 * 
[09:29:51.074]                                   base::.Machine$sizeof.pointer), 
[09:29:51.074]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:51.074]                                 "release", "version")], collapse = " "), 
[09:29:51.074]                               hostname = base::Sys.info()[["nodename"]])
[09:29:51.074]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:51.074]                               info)
[09:29:51.074]                             info <- base::paste(info, collapse = "; ")
[09:29:51.074]                             if (!has_future) {
[09:29:51.074]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:51.074]                                 info)
[09:29:51.074]                             }
[09:29:51.074]                             else {
[09:29:51.074]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:51.074]                                 info, version)
[09:29:51.074]                             }
[09:29:51.074]                             base::stop(msg)
[09:29:51.074]                           }
[09:29:51.074]                         })
[09:29:51.074]                       }
[09:29:51.074]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:51.074]                       base::options(mc.cores = 1L)
[09:29:51.074]                     }
[09:29:51.074]                     base::local({
[09:29:51.074]                       for (pkg in "future.apply") {
[09:29:51.074]                         base::loadNamespace(pkg)
[09:29:51.074]                         base::library(pkg, character.only = TRUE)
[09:29:51.074]                       }
[09:29:51.074]                     })
[09:29:51.074]                   }
[09:29:51.074]                   ...future.strategy.old <- future::plan("list")
[09:29:51.074]                   options(future.plan = NULL)
[09:29:51.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:51.074]                 }
[09:29:51.074]                 ...future.workdir <- getwd()
[09:29:51.074]             }
[09:29:51.074]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:51.074]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:51.074]         }
[09:29:51.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:51.074]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:51.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:51.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:51.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:51.074]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:51.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:51.074]             base::names(...future.oldOptions))
[09:29:51.074]     }
[09:29:51.074]     if (FALSE) {
[09:29:51.074]     }
[09:29:51.074]     else {
[09:29:51.074]         if (TRUE) {
[09:29:51.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:51.074]                 open = "w")
[09:29:51.074]         }
[09:29:51.074]         else {
[09:29:51.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:51.074]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:51.074]         }
[09:29:51.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:51.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:51.074]             base::sink(type = "output", split = FALSE)
[09:29:51.074]             base::close(...future.stdout)
[09:29:51.074]         }, add = TRUE)
[09:29:51.074]     }
[09:29:51.074]     ...future.frame <- base::sys.nframe()
[09:29:51.074]     ...future.conditions <- base::list()
[09:29:51.074]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:51.074]     if (FALSE) {
[09:29:51.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:51.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:51.074]     }
[09:29:51.074]     ...future.result <- base::tryCatch({
[09:29:51.074]         base::withCallingHandlers({
[09:29:51.074]             ...future.value <- base::withVisible(base::local({
[09:29:51.074]                 ...future.makeSendCondition <- base::local({
[09:29:51.074]                   sendCondition <- NULL
[09:29:51.074]                   function(frame = 1L) {
[09:29:51.074]                     if (is.function(sendCondition)) 
[09:29:51.074]                       return(sendCondition)
[09:29:51.074]                     ns <- getNamespace("parallel")
[09:29:51.074]                     if (exists("sendData", mode = "function", 
[09:29:51.074]                       envir = ns)) {
[09:29:51.074]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:51.074]                         envir = ns)
[09:29:51.074]                       envir <- sys.frame(frame)
[09:29:51.074]                       master <- NULL
[09:29:51.074]                       while (!identical(envir, .GlobalEnv) && 
[09:29:51.074]                         !identical(envir, emptyenv())) {
[09:29:51.074]                         if (exists("master", mode = "list", envir = envir, 
[09:29:51.074]                           inherits = FALSE)) {
[09:29:51.074]                           master <- get("master", mode = "list", 
[09:29:51.074]                             envir = envir, inherits = FALSE)
[09:29:51.074]                           if (inherits(master, c("SOCKnode", 
[09:29:51.074]                             "SOCK0node"))) {
[09:29:51.074]                             sendCondition <<- function(cond) {
[09:29:51.074]                               data <- list(type = "VALUE", value = cond, 
[09:29:51.074]                                 success = TRUE)
[09:29:51.074]                               parallel_sendData(master, data)
[09:29:51.074]                             }
[09:29:51.074]                             return(sendCondition)
[09:29:51.074]                           }
[09:29:51.074]                         }
[09:29:51.074]                         frame <- frame + 1L
[09:29:51.074]                         envir <- sys.frame(frame)
[09:29:51.074]                       }
[09:29:51.074]                     }
[09:29:51.074]                     sendCondition <<- function(cond) NULL
[09:29:51.074]                   }
[09:29:51.074]                 })
[09:29:51.074]                 withCallingHandlers({
[09:29:51.074]                   {
[09:29:51.074]                     do.call(function(...) {
[09:29:51.074]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.074]                       if (!identical(...future.globals.maxSize.org, 
[09:29:51.074]                         ...future.globals.maxSize)) {
[09:29:51.074]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.074]                         on.exit(options(oopts), add = TRUE)
[09:29:51.074]                       }
[09:29:51.074]                       {
[09:29:51.074]                         lapply(seq_along(...future.elements_ii), 
[09:29:51.074]                           FUN = function(jj) {
[09:29:51.074]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.074]                             ...future.FUN(...future.X_jj, ...)
[09:29:51.074]                           })
[09:29:51.074]                       }
[09:29:51.074]                     }, args = future.call.arguments)
[09:29:51.074]                   }
[09:29:51.074]                 }, immediateCondition = function(cond) {
[09:29:51.074]                   sendCondition <- ...future.makeSendCondition()
[09:29:51.074]                   sendCondition(cond)
[09:29:51.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.074]                   {
[09:29:51.074]                     inherits <- base::inherits
[09:29:51.074]                     invokeRestart <- base::invokeRestart
[09:29:51.074]                     is.null <- base::is.null
[09:29:51.074]                     muffled <- FALSE
[09:29:51.074]                     if (inherits(cond, "message")) {
[09:29:51.074]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:51.074]                       if (muffled) 
[09:29:51.074]                         invokeRestart("muffleMessage")
[09:29:51.074]                     }
[09:29:51.074]                     else if (inherits(cond, "warning")) {
[09:29:51.074]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:51.074]                       if (muffled) 
[09:29:51.074]                         invokeRestart("muffleWarning")
[09:29:51.074]                     }
[09:29:51.074]                     else if (inherits(cond, "condition")) {
[09:29:51.074]                       if (!is.null(pattern)) {
[09:29:51.074]                         computeRestarts <- base::computeRestarts
[09:29:51.074]                         grepl <- base::grepl
[09:29:51.074]                         restarts <- computeRestarts(cond)
[09:29:51.074]                         for (restart in restarts) {
[09:29:51.074]                           name <- restart$name
[09:29:51.074]                           if (is.null(name)) 
[09:29:51.074]                             next
[09:29:51.074]                           if (!grepl(pattern, name)) 
[09:29:51.074]                             next
[09:29:51.074]                           invokeRestart(restart)
[09:29:51.074]                           muffled <- TRUE
[09:29:51.074]                           break
[09:29:51.074]                         }
[09:29:51.074]                       }
[09:29:51.074]                     }
[09:29:51.074]                     invisible(muffled)
[09:29:51.074]                   }
[09:29:51.074]                   muffleCondition(cond)
[09:29:51.074]                 })
[09:29:51.074]             }))
[09:29:51.074]             future::FutureResult(value = ...future.value$value, 
[09:29:51.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.074]                   ...future.rng), globalenv = if (FALSE) 
[09:29:51.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:51.074]                     ...future.globalenv.names))
[09:29:51.074]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:51.074]         }, condition = base::local({
[09:29:51.074]             c <- base::c
[09:29:51.074]             inherits <- base::inherits
[09:29:51.074]             invokeRestart <- base::invokeRestart
[09:29:51.074]             length <- base::length
[09:29:51.074]             list <- base::list
[09:29:51.074]             seq.int <- base::seq.int
[09:29:51.074]             signalCondition <- base::signalCondition
[09:29:51.074]             sys.calls <- base::sys.calls
[09:29:51.074]             `[[` <- base::`[[`
[09:29:51.074]             `+` <- base::`+`
[09:29:51.074]             `<<-` <- base::`<<-`
[09:29:51.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:51.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:51.074]                   3L)]
[09:29:51.074]             }
[09:29:51.074]             function(cond) {
[09:29:51.074]                 is_error <- inherits(cond, "error")
[09:29:51.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:51.074]                   NULL)
[09:29:51.074]                 if (is_error) {
[09:29:51.074]                   sessionInformation <- function() {
[09:29:51.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:51.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:51.074]                       search = base::search(), system = base::Sys.info())
[09:29:51.074]                   }
[09:29:51.074]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:51.074]                     cond$call), session = sessionInformation(), 
[09:29:51.074]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:51.074]                   signalCondition(cond)
[09:29:51.074]                 }
[09:29:51.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:51.074]                 "immediateCondition"))) {
[09:29:51.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:51.074]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:51.074]                   if (TRUE && !signal) {
[09:29:51.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.074]                     {
[09:29:51.074]                       inherits <- base::inherits
[09:29:51.074]                       invokeRestart <- base::invokeRestart
[09:29:51.074]                       is.null <- base::is.null
[09:29:51.074]                       muffled <- FALSE
[09:29:51.074]                       if (inherits(cond, "message")) {
[09:29:51.074]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.074]                         if (muffled) 
[09:29:51.074]                           invokeRestart("muffleMessage")
[09:29:51.074]                       }
[09:29:51.074]                       else if (inherits(cond, "warning")) {
[09:29:51.074]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.074]                         if (muffled) 
[09:29:51.074]                           invokeRestart("muffleWarning")
[09:29:51.074]                       }
[09:29:51.074]                       else if (inherits(cond, "condition")) {
[09:29:51.074]                         if (!is.null(pattern)) {
[09:29:51.074]                           computeRestarts <- base::computeRestarts
[09:29:51.074]                           grepl <- base::grepl
[09:29:51.074]                           restarts <- computeRestarts(cond)
[09:29:51.074]                           for (restart in restarts) {
[09:29:51.074]                             name <- restart$name
[09:29:51.074]                             if (is.null(name)) 
[09:29:51.074]                               next
[09:29:51.074]                             if (!grepl(pattern, name)) 
[09:29:51.074]                               next
[09:29:51.074]                             invokeRestart(restart)
[09:29:51.074]                             muffled <- TRUE
[09:29:51.074]                             break
[09:29:51.074]                           }
[09:29:51.074]                         }
[09:29:51.074]                       }
[09:29:51.074]                       invisible(muffled)
[09:29:51.074]                     }
[09:29:51.074]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.074]                   }
[09:29:51.074]                 }
[09:29:51.074]                 else {
[09:29:51.074]                   if (TRUE) {
[09:29:51.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.074]                     {
[09:29:51.074]                       inherits <- base::inherits
[09:29:51.074]                       invokeRestart <- base::invokeRestart
[09:29:51.074]                       is.null <- base::is.null
[09:29:51.074]                       muffled <- FALSE
[09:29:51.074]                       if (inherits(cond, "message")) {
[09:29:51.074]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.074]                         if (muffled) 
[09:29:51.074]                           invokeRestart("muffleMessage")
[09:29:51.074]                       }
[09:29:51.074]                       else if (inherits(cond, "warning")) {
[09:29:51.074]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.074]                         if (muffled) 
[09:29:51.074]                           invokeRestart("muffleWarning")
[09:29:51.074]                       }
[09:29:51.074]                       else if (inherits(cond, "condition")) {
[09:29:51.074]                         if (!is.null(pattern)) {
[09:29:51.074]                           computeRestarts <- base::computeRestarts
[09:29:51.074]                           grepl <- base::grepl
[09:29:51.074]                           restarts <- computeRestarts(cond)
[09:29:51.074]                           for (restart in restarts) {
[09:29:51.074]                             name <- restart$name
[09:29:51.074]                             if (is.null(name)) 
[09:29:51.074]                               next
[09:29:51.074]                             if (!grepl(pattern, name)) 
[09:29:51.074]                               next
[09:29:51.074]                             invokeRestart(restart)
[09:29:51.074]                             muffled <- TRUE
[09:29:51.074]                             break
[09:29:51.074]                           }
[09:29:51.074]                         }
[09:29:51.074]                       }
[09:29:51.074]                       invisible(muffled)
[09:29:51.074]                     }
[09:29:51.074]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.074]                   }
[09:29:51.074]                 }
[09:29:51.074]             }
[09:29:51.074]         }))
[09:29:51.074]     }, error = function(ex) {
[09:29:51.074]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:51.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.074]                 ...future.rng), started = ...future.startTime, 
[09:29:51.074]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:51.074]             version = "1.8"), class = "FutureResult")
[09:29:51.074]     }, finally = {
[09:29:51.074]         if (!identical(...future.workdir, getwd())) 
[09:29:51.074]             setwd(...future.workdir)
[09:29:51.074]         {
[09:29:51.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:51.074]                 ...future.oldOptions$nwarnings <- NULL
[09:29:51.074]             }
[09:29:51.074]             base::options(...future.oldOptions)
[09:29:51.074]             if (.Platform$OS.type == "windows") {
[09:29:51.074]                 old_names <- names(...future.oldEnvVars)
[09:29:51.074]                 envs <- base::Sys.getenv()
[09:29:51.074]                 names <- names(envs)
[09:29:51.074]                 common <- intersect(names, old_names)
[09:29:51.074]                 added <- setdiff(names, old_names)
[09:29:51.074]                 removed <- setdiff(old_names, names)
[09:29:51.074]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:51.074]                   envs[common]]
[09:29:51.074]                 NAMES <- toupper(changed)
[09:29:51.074]                 args <- list()
[09:29:51.074]                 for (kk in seq_along(NAMES)) {
[09:29:51.074]                   name <- changed[[kk]]
[09:29:51.074]                   NAME <- NAMES[[kk]]
[09:29:51.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.074]                     next
[09:29:51.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.074]                 }
[09:29:51.074]                 NAMES <- toupper(added)
[09:29:51.074]                 for (kk in seq_along(NAMES)) {
[09:29:51.074]                   name <- added[[kk]]
[09:29:51.074]                   NAME <- NAMES[[kk]]
[09:29:51.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.074]                     next
[09:29:51.074]                   args[[name]] <- ""
[09:29:51.074]                 }
[09:29:51.074]                 NAMES <- toupper(removed)
[09:29:51.074]                 for (kk in seq_along(NAMES)) {
[09:29:51.074]                   name <- removed[[kk]]
[09:29:51.074]                   NAME <- NAMES[[kk]]
[09:29:51.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.074]                     next
[09:29:51.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.074]                 }
[09:29:51.074]                 if (length(args) > 0) 
[09:29:51.074]                   base::do.call(base::Sys.setenv, args = args)
[09:29:51.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:51.074]             }
[09:29:51.074]             else {
[09:29:51.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:51.074]             }
[09:29:51.074]             {
[09:29:51.074]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:51.074]                   0L) {
[09:29:51.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:51.074]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:51.074]                   base::options(opts)
[09:29:51.074]                 }
[09:29:51.074]                 {
[09:29:51.074]                   {
[09:29:51.074]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:51.074]                     NULL
[09:29:51.074]                   }
[09:29:51.074]                   options(future.plan = NULL)
[09:29:51.074]                   if (is.na(NA_character_)) 
[09:29:51.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:51.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:51.074]                     .init = FALSE)
[09:29:51.074]                 }
[09:29:51.074]             }
[09:29:51.074]         }
[09:29:51.074]     })
[09:29:51.074]     if (TRUE) {
[09:29:51.074]         base::sink(type = "output", split = FALSE)
[09:29:51.074]         if (TRUE) {
[09:29:51.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:51.074]         }
[09:29:51.074]         else {
[09:29:51.074]             ...future.result["stdout"] <- base::list(NULL)
[09:29:51.074]         }
[09:29:51.074]         base::close(...future.stdout)
[09:29:51.074]         ...future.stdout <- NULL
[09:29:51.074]     }
[09:29:51.074]     ...future.result$conditions <- ...future.conditions
[09:29:51.074]     ...future.result$finished <- base::Sys.time()
[09:29:51.074]     ...future.result
[09:29:51.074] }
[09:29:51.077] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[09:29:51.077] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:51.120] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:51.120] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[09:29:51.121] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[09:29:51.121] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:51.121] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:51.121] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:51.164] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:51.164] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:51.208] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:51.208] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[09:29:51.209] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[09:29:51.209] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[09:29:51.209] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[09:29:51.209] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:51.210] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.210] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:51.210] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:51.210] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:51.211] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.211] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:51.211] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.211] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[09:29:51.212] MultisessionFuture started
[09:29:51.212] - Launch lazy future ... done
[09:29:51.212] run() for ‘MultisessionFuture’ ... done
[09:29:51.212] Created future:
[09:29:51.214] receiveMessageFromWorker() for ClusterFuture ...
[09:29:51.214] - Validating connection of MultisessionFuture
[09:29:51.214] - received message: FutureResult
[09:29:51.214] - Received FutureResult
[09:29:51.214] - Erased future from FutureRegistry
[09:29:51.214] result() for ClusterFuture ...
[09:29:51.214] - result already collected: FutureResult
[09:29:51.214] result() for ClusterFuture ... done
[09:29:51.214] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:51.212] MultisessionFuture:
[09:29:51.212] Label: ‘future_vapply-1’
[09:29:51.212] Expression:
[09:29:51.212] {
[09:29:51.212]     do.call(function(...) {
[09:29:51.212]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.212]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.212]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.212]             on.exit(options(oopts), add = TRUE)
[09:29:51.212]         }
[09:29:51.212]         {
[09:29:51.212]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.212]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.212]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.212]             })
[09:29:51.212]         }
[09:29:51.212]     }, args = future.call.arguments)
[09:29:51.212] }
[09:29:51.212] Lazy evaluation: FALSE
[09:29:51.212] Asynchronous evaluation: TRUE
[09:29:51.212] Local evaluation: TRUE
[09:29:51.212] Environment: R_GlobalEnv
[09:29:51.212] Capture standard output: TRUE
[09:29:51.212] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:51.212] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:51.212] Packages: 1 packages (‘future.apply’)
[09:29:51.212] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:51.212] Resolved: TRUE
[09:29:51.212] Value: <not collected>
[09:29:51.212] Conditions captured: <none>
[09:29:51.212] Early signaling: FALSE
[09:29:51.212] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:51.212] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.215] Chunk #1 of 2 ... DONE
[09:29:51.215] Chunk #2 of 2 ...
[09:29:51.215]  - Finding globals in 'X' for chunk #2 ...
[09:29:51.215] getGlobalsAndPackages() ...
[09:29:51.215] Searching for globals...
[09:29:51.215] 
[09:29:51.215] Searching for globals ... DONE
[09:29:51.216] - globals: [0] <none>
[09:29:51.216] getGlobalsAndPackages() ... DONE
[09:29:51.216]    + additional globals found: [n=0] 
[09:29:51.216]    + additional namespaces needed: [n=0] 
[09:29:51.216]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:51.216]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:51.216]  - seeds: <none>
[09:29:51.216]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.216] getGlobalsAndPackages() ...
[09:29:51.216] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.216] Resolving globals: FALSE
[09:29:51.217] Tweak future expression to call with '...' arguments ...
[09:29:51.217] {
[09:29:51.217]     do.call(function(...) {
[09:29:51.217]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.217]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.217]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.217]             on.exit(options(oopts), add = TRUE)
[09:29:51.217]         }
[09:29:51.217]         {
[09:29:51.217]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.217]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.217]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.217]             })
[09:29:51.217]         }
[09:29:51.217]     }, args = future.call.arguments)
[09:29:51.217] }
[09:29:51.217] Tweak future expression to call with '...' arguments ... DONE
[09:29:51.217] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.218] - packages: [1] ‘future.apply’
[09:29:51.218] getGlobalsAndPackages() ... DONE
[09:29:51.218] run() for ‘Future’ ...
[09:29:51.218] - state: ‘created’
[09:29:51.218] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:51.232] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:51.233]   - Field: ‘node’
[09:29:51.233]   - Field: ‘label’
[09:29:51.233]   - Field: ‘local’
[09:29:51.233]   - Field: ‘owner’
[09:29:51.233]   - Field: ‘envir’
[09:29:51.233]   - Field: ‘workers’
[09:29:51.233]   - Field: ‘packages’
[09:29:51.233]   - Field: ‘gc’
[09:29:51.233]   - Field: ‘conditions’
[09:29:51.234]   - Field: ‘persistent’
[09:29:51.234]   - Field: ‘expr’
[09:29:51.234]   - Field: ‘uuid’
[09:29:51.234]   - Field: ‘seed’
[09:29:51.234]   - Field: ‘version’
[09:29:51.234]   - Field: ‘result’
[09:29:51.234]   - Field: ‘asynchronous’
[09:29:51.234]   - Field: ‘calls’
[09:29:51.234]   - Field: ‘globals’
[09:29:51.234]   - Field: ‘stdout’
[09:29:51.234]   - Field: ‘earlySignal’
[09:29:51.234]   - Field: ‘lazy’
[09:29:51.235]   - Field: ‘state’
[09:29:51.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:51.235] - Launch lazy future ...
[09:29:51.235] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:51.235] Packages needed by future strategies (n = 0): <none>
[09:29:51.236] {
[09:29:51.236]     {
[09:29:51.236]         {
[09:29:51.236]             ...future.startTime <- base::Sys.time()
[09:29:51.236]             {
[09:29:51.236]                 {
[09:29:51.236]                   {
[09:29:51.236]                     {
[09:29:51.236]                       {
[09:29:51.236]                         base::local({
[09:29:51.236]                           has_future <- base::requireNamespace("future", 
[09:29:51.236]                             quietly = TRUE)
[09:29:51.236]                           if (has_future) {
[09:29:51.236]                             ns <- base::getNamespace("future")
[09:29:51.236]                             version <- ns[[".package"]][["version"]]
[09:29:51.236]                             if (is.null(version)) 
[09:29:51.236]                               version <- utils::packageVersion("future")
[09:29:51.236]                           }
[09:29:51.236]                           else {
[09:29:51.236]                             version <- NULL
[09:29:51.236]                           }
[09:29:51.236]                           if (!has_future || version < "1.8.0") {
[09:29:51.236]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:51.236]                               "", base::R.version$version.string), 
[09:29:51.236]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:51.236]                                 base::R.version$platform, 8 * 
[09:29:51.236]                                   base::.Machine$sizeof.pointer), 
[09:29:51.236]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:51.236]                                 "release", "version")], collapse = " "), 
[09:29:51.236]                               hostname = base::Sys.info()[["nodename"]])
[09:29:51.236]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:51.236]                               info)
[09:29:51.236]                             info <- base::paste(info, collapse = "; ")
[09:29:51.236]                             if (!has_future) {
[09:29:51.236]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:51.236]                                 info)
[09:29:51.236]                             }
[09:29:51.236]                             else {
[09:29:51.236]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:51.236]                                 info, version)
[09:29:51.236]                             }
[09:29:51.236]                             base::stop(msg)
[09:29:51.236]                           }
[09:29:51.236]                         })
[09:29:51.236]                       }
[09:29:51.236]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:51.236]                       base::options(mc.cores = 1L)
[09:29:51.236]                     }
[09:29:51.236]                     base::local({
[09:29:51.236]                       for (pkg in "future.apply") {
[09:29:51.236]                         base::loadNamespace(pkg)
[09:29:51.236]                         base::library(pkg, character.only = TRUE)
[09:29:51.236]                       }
[09:29:51.236]                     })
[09:29:51.236]                   }
[09:29:51.236]                   ...future.strategy.old <- future::plan("list")
[09:29:51.236]                   options(future.plan = NULL)
[09:29:51.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:51.236]                 }
[09:29:51.236]                 ...future.workdir <- getwd()
[09:29:51.236]             }
[09:29:51.236]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:51.236]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:51.236]         }
[09:29:51.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:51.236]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:51.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:51.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:51.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:51.236]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:51.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:51.236]             base::names(...future.oldOptions))
[09:29:51.236]     }
[09:29:51.236]     if (FALSE) {
[09:29:51.236]     }
[09:29:51.236]     else {
[09:29:51.236]         if (TRUE) {
[09:29:51.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:51.236]                 open = "w")
[09:29:51.236]         }
[09:29:51.236]         else {
[09:29:51.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:51.236]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:51.236]         }
[09:29:51.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:51.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:51.236]             base::sink(type = "output", split = FALSE)
[09:29:51.236]             base::close(...future.stdout)
[09:29:51.236]         }, add = TRUE)
[09:29:51.236]     }
[09:29:51.236]     ...future.frame <- base::sys.nframe()
[09:29:51.236]     ...future.conditions <- base::list()
[09:29:51.236]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:51.236]     if (FALSE) {
[09:29:51.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:51.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:51.236]     }
[09:29:51.236]     ...future.result <- base::tryCatch({
[09:29:51.236]         base::withCallingHandlers({
[09:29:51.236]             ...future.value <- base::withVisible(base::local({
[09:29:51.236]                 ...future.makeSendCondition <- base::local({
[09:29:51.236]                   sendCondition <- NULL
[09:29:51.236]                   function(frame = 1L) {
[09:29:51.236]                     if (is.function(sendCondition)) 
[09:29:51.236]                       return(sendCondition)
[09:29:51.236]                     ns <- getNamespace("parallel")
[09:29:51.236]                     if (exists("sendData", mode = "function", 
[09:29:51.236]                       envir = ns)) {
[09:29:51.236]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:51.236]                         envir = ns)
[09:29:51.236]                       envir <- sys.frame(frame)
[09:29:51.236]                       master <- NULL
[09:29:51.236]                       while (!identical(envir, .GlobalEnv) && 
[09:29:51.236]                         !identical(envir, emptyenv())) {
[09:29:51.236]                         if (exists("master", mode = "list", envir = envir, 
[09:29:51.236]                           inherits = FALSE)) {
[09:29:51.236]                           master <- get("master", mode = "list", 
[09:29:51.236]                             envir = envir, inherits = FALSE)
[09:29:51.236]                           if (inherits(master, c("SOCKnode", 
[09:29:51.236]                             "SOCK0node"))) {
[09:29:51.236]                             sendCondition <<- function(cond) {
[09:29:51.236]                               data <- list(type = "VALUE", value = cond, 
[09:29:51.236]                                 success = TRUE)
[09:29:51.236]                               parallel_sendData(master, data)
[09:29:51.236]                             }
[09:29:51.236]                             return(sendCondition)
[09:29:51.236]                           }
[09:29:51.236]                         }
[09:29:51.236]                         frame <- frame + 1L
[09:29:51.236]                         envir <- sys.frame(frame)
[09:29:51.236]                       }
[09:29:51.236]                     }
[09:29:51.236]                     sendCondition <<- function(cond) NULL
[09:29:51.236]                   }
[09:29:51.236]                 })
[09:29:51.236]                 withCallingHandlers({
[09:29:51.236]                   {
[09:29:51.236]                     do.call(function(...) {
[09:29:51.236]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.236]                       if (!identical(...future.globals.maxSize.org, 
[09:29:51.236]                         ...future.globals.maxSize)) {
[09:29:51.236]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.236]                         on.exit(options(oopts), add = TRUE)
[09:29:51.236]                       }
[09:29:51.236]                       {
[09:29:51.236]                         lapply(seq_along(...future.elements_ii), 
[09:29:51.236]                           FUN = function(jj) {
[09:29:51.236]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.236]                             ...future.FUN(...future.X_jj, ...)
[09:29:51.236]                           })
[09:29:51.236]                       }
[09:29:51.236]                     }, args = future.call.arguments)
[09:29:51.236]                   }
[09:29:51.236]                 }, immediateCondition = function(cond) {
[09:29:51.236]                   sendCondition <- ...future.makeSendCondition()
[09:29:51.236]                   sendCondition(cond)
[09:29:51.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.236]                   {
[09:29:51.236]                     inherits <- base::inherits
[09:29:51.236]                     invokeRestart <- base::invokeRestart
[09:29:51.236]                     is.null <- base::is.null
[09:29:51.236]                     muffled <- FALSE
[09:29:51.236]                     if (inherits(cond, "message")) {
[09:29:51.236]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:51.236]                       if (muffled) 
[09:29:51.236]                         invokeRestart("muffleMessage")
[09:29:51.236]                     }
[09:29:51.236]                     else if (inherits(cond, "warning")) {
[09:29:51.236]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:51.236]                       if (muffled) 
[09:29:51.236]                         invokeRestart("muffleWarning")
[09:29:51.236]                     }
[09:29:51.236]                     else if (inherits(cond, "condition")) {
[09:29:51.236]                       if (!is.null(pattern)) {
[09:29:51.236]                         computeRestarts <- base::computeRestarts
[09:29:51.236]                         grepl <- base::grepl
[09:29:51.236]                         restarts <- computeRestarts(cond)
[09:29:51.236]                         for (restart in restarts) {
[09:29:51.236]                           name <- restart$name
[09:29:51.236]                           if (is.null(name)) 
[09:29:51.236]                             next
[09:29:51.236]                           if (!grepl(pattern, name)) 
[09:29:51.236]                             next
[09:29:51.236]                           invokeRestart(restart)
[09:29:51.236]                           muffled <- TRUE
[09:29:51.236]                           break
[09:29:51.236]                         }
[09:29:51.236]                       }
[09:29:51.236]                     }
[09:29:51.236]                     invisible(muffled)
[09:29:51.236]                   }
[09:29:51.236]                   muffleCondition(cond)
[09:29:51.236]                 })
[09:29:51.236]             }))
[09:29:51.236]             future::FutureResult(value = ...future.value$value, 
[09:29:51.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.236]                   ...future.rng), globalenv = if (FALSE) 
[09:29:51.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:51.236]                     ...future.globalenv.names))
[09:29:51.236]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:51.236]         }, condition = base::local({
[09:29:51.236]             c <- base::c
[09:29:51.236]             inherits <- base::inherits
[09:29:51.236]             invokeRestart <- base::invokeRestart
[09:29:51.236]             length <- base::length
[09:29:51.236]             list <- base::list
[09:29:51.236]             seq.int <- base::seq.int
[09:29:51.236]             signalCondition <- base::signalCondition
[09:29:51.236]             sys.calls <- base::sys.calls
[09:29:51.236]             `[[` <- base::`[[`
[09:29:51.236]             `+` <- base::`+`
[09:29:51.236]             `<<-` <- base::`<<-`
[09:29:51.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:51.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:51.236]                   3L)]
[09:29:51.236]             }
[09:29:51.236]             function(cond) {
[09:29:51.236]                 is_error <- inherits(cond, "error")
[09:29:51.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:51.236]                   NULL)
[09:29:51.236]                 if (is_error) {
[09:29:51.236]                   sessionInformation <- function() {
[09:29:51.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:51.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:51.236]                       search = base::search(), system = base::Sys.info())
[09:29:51.236]                   }
[09:29:51.236]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:51.236]                     cond$call), session = sessionInformation(), 
[09:29:51.236]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:51.236]                   signalCondition(cond)
[09:29:51.236]                 }
[09:29:51.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:51.236]                 "immediateCondition"))) {
[09:29:51.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:51.236]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:51.236]                   if (TRUE && !signal) {
[09:29:51.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.236]                     {
[09:29:51.236]                       inherits <- base::inherits
[09:29:51.236]                       invokeRestart <- base::invokeRestart
[09:29:51.236]                       is.null <- base::is.null
[09:29:51.236]                       muffled <- FALSE
[09:29:51.236]                       if (inherits(cond, "message")) {
[09:29:51.236]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.236]                         if (muffled) 
[09:29:51.236]                           invokeRestart("muffleMessage")
[09:29:51.236]                       }
[09:29:51.236]                       else if (inherits(cond, "warning")) {
[09:29:51.236]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.236]                         if (muffled) 
[09:29:51.236]                           invokeRestart("muffleWarning")
[09:29:51.236]                       }
[09:29:51.236]                       else if (inherits(cond, "condition")) {
[09:29:51.236]                         if (!is.null(pattern)) {
[09:29:51.236]                           computeRestarts <- base::computeRestarts
[09:29:51.236]                           grepl <- base::grepl
[09:29:51.236]                           restarts <- computeRestarts(cond)
[09:29:51.236]                           for (restart in restarts) {
[09:29:51.236]                             name <- restart$name
[09:29:51.236]                             if (is.null(name)) 
[09:29:51.236]                               next
[09:29:51.236]                             if (!grepl(pattern, name)) 
[09:29:51.236]                               next
[09:29:51.236]                             invokeRestart(restart)
[09:29:51.236]                             muffled <- TRUE
[09:29:51.236]                             break
[09:29:51.236]                           }
[09:29:51.236]                         }
[09:29:51.236]                       }
[09:29:51.236]                       invisible(muffled)
[09:29:51.236]                     }
[09:29:51.236]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.236]                   }
[09:29:51.236]                 }
[09:29:51.236]                 else {
[09:29:51.236]                   if (TRUE) {
[09:29:51.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.236]                     {
[09:29:51.236]                       inherits <- base::inherits
[09:29:51.236]                       invokeRestart <- base::invokeRestart
[09:29:51.236]                       is.null <- base::is.null
[09:29:51.236]                       muffled <- FALSE
[09:29:51.236]                       if (inherits(cond, "message")) {
[09:29:51.236]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.236]                         if (muffled) 
[09:29:51.236]                           invokeRestart("muffleMessage")
[09:29:51.236]                       }
[09:29:51.236]                       else if (inherits(cond, "warning")) {
[09:29:51.236]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.236]                         if (muffled) 
[09:29:51.236]                           invokeRestart("muffleWarning")
[09:29:51.236]                       }
[09:29:51.236]                       else if (inherits(cond, "condition")) {
[09:29:51.236]                         if (!is.null(pattern)) {
[09:29:51.236]                           computeRestarts <- base::computeRestarts
[09:29:51.236]                           grepl <- base::grepl
[09:29:51.236]                           restarts <- computeRestarts(cond)
[09:29:51.236]                           for (restart in restarts) {
[09:29:51.236]                             name <- restart$name
[09:29:51.236]                             if (is.null(name)) 
[09:29:51.236]                               next
[09:29:51.236]                             if (!grepl(pattern, name)) 
[09:29:51.236]                               next
[09:29:51.236]                             invokeRestart(restart)
[09:29:51.236]                             muffled <- TRUE
[09:29:51.236]                             break
[09:29:51.236]                           }
[09:29:51.236]                         }
[09:29:51.236]                       }
[09:29:51.236]                       invisible(muffled)
[09:29:51.236]                     }
[09:29:51.236]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.236]                   }
[09:29:51.236]                 }
[09:29:51.236]             }
[09:29:51.236]         }))
[09:29:51.236]     }, error = function(ex) {
[09:29:51.236]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:51.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.236]                 ...future.rng), started = ...future.startTime, 
[09:29:51.236]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:51.236]             version = "1.8"), class = "FutureResult")
[09:29:51.236]     }, finally = {
[09:29:51.236]         if (!identical(...future.workdir, getwd())) 
[09:29:51.236]             setwd(...future.workdir)
[09:29:51.236]         {
[09:29:51.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:51.236]                 ...future.oldOptions$nwarnings <- NULL
[09:29:51.236]             }
[09:29:51.236]             base::options(...future.oldOptions)
[09:29:51.236]             if (.Platform$OS.type == "windows") {
[09:29:51.236]                 old_names <- names(...future.oldEnvVars)
[09:29:51.236]                 envs <- base::Sys.getenv()
[09:29:51.236]                 names <- names(envs)
[09:29:51.236]                 common <- intersect(names, old_names)
[09:29:51.236]                 added <- setdiff(names, old_names)
[09:29:51.236]                 removed <- setdiff(old_names, names)
[09:29:51.236]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:51.236]                   envs[common]]
[09:29:51.236]                 NAMES <- toupper(changed)
[09:29:51.236]                 args <- list()
[09:29:51.236]                 for (kk in seq_along(NAMES)) {
[09:29:51.236]                   name <- changed[[kk]]
[09:29:51.236]                   NAME <- NAMES[[kk]]
[09:29:51.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.236]                     next
[09:29:51.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.236]                 }
[09:29:51.236]                 NAMES <- toupper(added)
[09:29:51.236]                 for (kk in seq_along(NAMES)) {
[09:29:51.236]                   name <- added[[kk]]
[09:29:51.236]                   NAME <- NAMES[[kk]]
[09:29:51.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.236]                     next
[09:29:51.236]                   args[[name]] <- ""
[09:29:51.236]                 }
[09:29:51.236]                 NAMES <- toupper(removed)
[09:29:51.236]                 for (kk in seq_along(NAMES)) {
[09:29:51.236]                   name <- removed[[kk]]
[09:29:51.236]                   NAME <- NAMES[[kk]]
[09:29:51.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.236]                     next
[09:29:51.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.236]                 }
[09:29:51.236]                 if (length(args) > 0) 
[09:29:51.236]                   base::do.call(base::Sys.setenv, args = args)
[09:29:51.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:51.236]             }
[09:29:51.236]             else {
[09:29:51.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:51.236]             }
[09:29:51.236]             {
[09:29:51.236]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:51.236]                   0L) {
[09:29:51.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:51.236]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:51.236]                   base::options(opts)
[09:29:51.236]                 }
[09:29:51.236]                 {
[09:29:51.236]                   {
[09:29:51.236]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:51.236]                     NULL
[09:29:51.236]                   }
[09:29:51.236]                   options(future.plan = NULL)
[09:29:51.236]                   if (is.na(NA_character_)) 
[09:29:51.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:51.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:51.236]                     .init = FALSE)
[09:29:51.236]                 }
[09:29:51.236]             }
[09:29:51.236]         }
[09:29:51.236]     })
[09:29:51.236]     if (TRUE) {
[09:29:51.236]         base::sink(type = "output", split = FALSE)
[09:29:51.236]         if (TRUE) {
[09:29:51.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:51.236]         }
[09:29:51.236]         else {
[09:29:51.236]             ...future.result["stdout"] <- base::list(NULL)
[09:29:51.236]         }
[09:29:51.236]         base::close(...future.stdout)
[09:29:51.236]         ...future.stdout <- NULL
[09:29:51.236]     }
[09:29:51.236]     ...future.result$conditions <- ...future.conditions
[09:29:51.236]     ...future.result$finished <- base::Sys.time()
[09:29:51.236]     ...future.result
[09:29:51.236] }
[09:29:51.238] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[09:29:51.238] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:51.280] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:51.280] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[09:29:51.281] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[09:29:51.281] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:51.281] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:51.281] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:51.324] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:51.324] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:51.368] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:51.368] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[09:29:51.369] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[09:29:51.369] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[09:29:51.369] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[09:29:51.369] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:51.370] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.370] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:51.370] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:51.370] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:51.371] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.371] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:51.371] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.371] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[09:29:51.372] MultisessionFuture started
[09:29:51.372] - Launch lazy future ... done
[09:29:51.372] run() for ‘MultisessionFuture’ ... done
[09:29:51.372] Created future:
[09:29:51.374] receiveMessageFromWorker() for ClusterFuture ...
[09:29:51.374] - Validating connection of MultisessionFuture
[09:29:51.374] - received message: FutureResult
[09:29:51.374] - Received FutureResult
[09:29:51.374] - Erased future from FutureRegistry
[09:29:51.374] result() for ClusterFuture ...
[09:29:51.374] - result already collected: FutureResult
[09:29:51.374] result() for ClusterFuture ... done
[09:29:51.374] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:51.372] MultisessionFuture:
[09:29:51.372] Label: ‘future_vapply-2’
[09:29:51.372] Expression:
[09:29:51.372] {
[09:29:51.372]     do.call(function(...) {
[09:29:51.372]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.372]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.372]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.372]             on.exit(options(oopts), add = TRUE)
[09:29:51.372]         }
[09:29:51.372]         {
[09:29:51.372]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.372]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.372]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.372]             })
[09:29:51.372]         }
[09:29:51.372]     }, args = future.call.arguments)
[09:29:51.372] }
[09:29:51.372] Lazy evaluation: FALSE
[09:29:51.372] Asynchronous evaluation: TRUE
[09:29:51.372] Local evaluation: TRUE
[09:29:51.372] Environment: R_GlobalEnv
[09:29:51.372] Capture standard output: TRUE
[09:29:51.372] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:51.372] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:51.372] Packages: 1 packages (‘future.apply’)
[09:29:51.372] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:51.372] Resolved: TRUE
[09:29:51.372] Value: <not collected>
[09:29:51.372] Conditions captured: <none>
[09:29:51.372] Early signaling: FALSE
[09:29:51.372] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:51.372] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.375] Chunk #2 of 2 ... DONE
[09:29:51.375] Launching 2 futures (chunks) ... DONE
[09:29:51.375] Resolving 2 futures (chunks) ...
[09:29:51.375] resolve() on list ...
[09:29:51.375]  recursive: 0
[09:29:51.375]  length: 2
[09:29:51.375] 
[09:29:51.375] Future #1
[09:29:51.375] result() for ClusterFuture ...
[09:29:51.376] - result already collected: FutureResult
[09:29:51.376] result() for ClusterFuture ... done
[09:29:51.376] result() for ClusterFuture ...
[09:29:51.376] - result already collected: FutureResult
[09:29:51.376] result() for ClusterFuture ... done
[09:29:51.376] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:51.376] - nx: 2
[09:29:51.376] - relay: TRUE
[09:29:51.376] - stdout: TRUE
[09:29:51.376] - signal: TRUE
[09:29:51.376] - resignal: FALSE
[09:29:51.377] - force: TRUE
[09:29:51.377] - relayed: [n=2] FALSE, FALSE
[09:29:51.377] - queued futures: [n=2] FALSE, FALSE
[09:29:51.377]  - until=1
[09:29:51.377]  - relaying element #1
[09:29:51.377] result() for ClusterFuture ...
[09:29:51.377] - result already collected: FutureResult
[09:29:51.377] result() for ClusterFuture ... done
[09:29:51.377] result() for ClusterFuture ...
[09:29:51.377] - result already collected: FutureResult
[09:29:51.377] result() for ClusterFuture ... done
[09:29:51.377] result() for ClusterFuture ...
[09:29:51.378] - result already collected: FutureResult
[09:29:51.378] result() for ClusterFuture ... done
[09:29:51.378] result() for ClusterFuture ...
[09:29:51.378] - result already collected: FutureResult
[09:29:51.378] result() for ClusterFuture ... done
[09:29:51.378] - relayed: [n=2] TRUE, FALSE
[09:29:51.378] - queued futures: [n=2] TRUE, FALSE
[09:29:51.378] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:51.378]  length: 1 (resolved future 1)
[09:29:51.378] Future #2
[09:29:51.378] result() for ClusterFuture ...
[09:29:51.379] - result already collected: FutureResult
[09:29:51.379] result() for ClusterFuture ... done
[09:29:51.379] result() for ClusterFuture ...
[09:29:51.379] - result already collected: FutureResult
[09:29:51.379] result() for ClusterFuture ... done
[09:29:51.379] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:51.379] - nx: 2
[09:29:51.379] - relay: TRUE
[09:29:51.379] - stdout: TRUE
[09:29:51.379] - signal: TRUE
[09:29:51.379] - resignal: FALSE
[09:29:51.379] - force: TRUE
[09:29:51.379] - relayed: [n=2] TRUE, FALSE
[09:29:51.380] - queued futures: [n=2] TRUE, FALSE
[09:29:51.380]  - until=2
[09:29:51.380]  - relaying element #2
[09:29:51.382] result() for ClusterFuture ...
[09:29:51.382] - result already collected: FutureResult
[09:29:51.382] result() for ClusterFuture ... done
[09:29:51.382] result() for ClusterFuture ...
[09:29:51.382] - result already collected: FutureResult
[09:29:51.382] result() for ClusterFuture ... done
[09:29:51.382] result() for ClusterFuture ...
[09:29:51.382] - result already collected: FutureResult
[09:29:51.383] result() for ClusterFuture ... done
[09:29:51.383] result() for ClusterFuture ...
[09:29:51.383] - result already collected: FutureResult
[09:29:51.383] result() for ClusterFuture ... done
[09:29:51.383] - relayed: [n=2] TRUE, TRUE
[09:29:51.383] - queued futures: [n=2] TRUE, TRUE
[09:29:51.383] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:51.383]  length: 0 (resolved future 2)
[09:29:51.383] Relaying remaining futures
[09:29:51.383] signalConditionsASAP(NULL, pos=0) ...
[09:29:51.383] - nx: 2
[09:29:51.383] - relay: TRUE
[09:29:51.384] - stdout: TRUE
[09:29:51.384] - signal: TRUE
[09:29:51.384] - resignal: FALSE
[09:29:51.384] - force: TRUE
[09:29:51.384] - relayed: [n=2] TRUE, TRUE
[09:29:51.384] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:51.384] - relayed: [n=2] TRUE, TRUE
[09:29:51.384] - queued futures: [n=2] TRUE, TRUE
[09:29:51.384] signalConditionsASAP(NULL, pos=0) ... done
[09:29:51.384] resolve() on list ... DONE
[09:29:51.384] result() for ClusterFuture ...
[09:29:51.385] - result already collected: FutureResult
[09:29:51.385] result() for ClusterFuture ... done
[09:29:51.385] result() for ClusterFuture ...
[09:29:51.385] - result already collected: FutureResult
[09:29:51.385] result() for ClusterFuture ... done
[09:29:51.385] result() for ClusterFuture ...
[09:29:51.385] - result already collected: FutureResult
[09:29:51.385] result() for ClusterFuture ... done
[09:29:51.385] result() for ClusterFuture ...
[09:29:51.385] - result already collected: FutureResult
[09:29:51.385] result() for ClusterFuture ... done
[09:29:51.385]  - Number of value chunks collected: 2
[09:29:51.386] Resolving 2 futures (chunks) ... DONE
[09:29:51.386] Reducing values from 2 chunks ...
[09:29:51.386]  - Number of values collected after concatenation: 10
[09:29:51.386]  - Number of values expected: 10
[09:29:51.386] Reducing values from 2 chunks ... DONE
[09:29:51.386] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[09:29:51.387] future_lapply() ...
[09:29:51.392] Number of chunks: 2
[09:29:51.392] getGlobalsAndPackagesXApply() ...
[09:29:51.392]  - future.globals: TRUE
[09:29:51.392] getGlobalsAndPackages() ...
[09:29:51.392] Searching for globals...
[09:29:51.396] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[09:29:51.396] Searching for globals ... DONE
[09:29:51.396] Resolving globals: FALSE
[09:29:51.397] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[09:29:51.397] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:51.397] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:51.397] - packages: [1] ‘future.apply’
[09:29:51.397] getGlobalsAndPackages() ... DONE
[09:29:51.397]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:51.398]  - needed namespaces: [n=1] ‘future.apply’
[09:29:51.398] Finding globals ... DONE
[09:29:51.398]  - use_args: TRUE
[09:29:51.398]  - Getting '...' globals ...
[09:29:51.398] resolve() on list ...
[09:29:51.398]  recursive: 0
[09:29:51.398]  length: 1
[09:29:51.398]  elements: ‘...’
[09:29:51.399]  length: 0 (resolved future 1)
[09:29:51.399] resolve() on list ... DONE
[09:29:51.399]    - '...' content: [n=0] 
[09:29:51.399] List of 1
[09:29:51.399]  $ ...: list()
[09:29:51.399]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:51.399]  - attr(*, "where")=List of 1
[09:29:51.399]   ..$ ...:<environment: 0x561d36924668> 
[09:29:51.399]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:51.399]  - attr(*, "resolved")= logi TRUE
[09:29:51.399]  - attr(*, "total_size")= num NA
[09:29:51.401]  - Getting '...' globals ... DONE
[09:29:51.402] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:51.402] List of 8
[09:29:51.402]  $ ...future.FUN:function (x, ...)  
[09:29:51.402]  $ x_FUN        :function (x)  
[09:29:51.402]  $ times        : int 4
[09:29:51.402]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:51.402]  $ stop_if_not  :function (...)  
[09:29:51.402]  $ dim          : int [1:2] 2 2
[09:29:51.402]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:51.402]  $ ...          : list()
[09:29:51.402]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:51.402]  - attr(*, "where")=List of 8
[09:29:51.402]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:51.402]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:51.402]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:51.402]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:51.402]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:51.402]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:51.402]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:51.402]   ..$ ...          :<environment: 0x561d36924668> 
[09:29:51.402]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:51.402]  - attr(*, "resolved")= logi FALSE
[09:29:51.402]  - attr(*, "total_size")= num 97304
[09:29:51.407] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:51.407] getGlobalsAndPackagesXApply() ... DONE
[09:29:51.407] Number of futures (= number of chunks): 2
[09:29:51.407] Launching 2 futures (chunks) ...
[09:29:51.407] Chunk #1 of 2 ...
[09:29:51.408]  - Finding globals in 'X' for chunk #1 ...
[09:29:51.408] getGlobalsAndPackages() ...
[09:29:51.408] Searching for globals...
[09:29:51.408] 
[09:29:51.408] Searching for globals ... DONE
[09:29:51.408] - globals: [0] <none>
[09:29:51.408] getGlobalsAndPackages() ... DONE
[09:29:51.408]    + additional globals found: [n=0] 
[09:29:51.408]    + additional namespaces needed: [n=0] 
[09:29:51.409]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:51.409]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:51.409]  - seeds: <none>
[09:29:51.409]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.409] getGlobalsAndPackages() ...
[09:29:51.409] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.409] Resolving globals: FALSE
[09:29:51.409] Tweak future expression to call with '...' arguments ...
[09:29:51.409] {
[09:29:51.409]     do.call(function(...) {
[09:29:51.409]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.409]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.409]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.409]             on.exit(options(oopts), add = TRUE)
[09:29:51.409]         }
[09:29:51.409]         {
[09:29:51.409]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.409]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.409]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.409]             })
[09:29:51.409]         }
[09:29:51.409]     }, args = future.call.arguments)
[09:29:51.409] }
[09:29:51.410] Tweak future expression to call with '...' arguments ... DONE
[09:29:51.410] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.410] - packages: [1] ‘future.apply’
[09:29:51.410] getGlobalsAndPackages() ... DONE
[09:29:51.411] run() for ‘Future’ ...
[09:29:51.411] - state: ‘created’
[09:29:51.411] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:51.424] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.425] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:51.425]   - Field: ‘node’
[09:29:51.425]   - Field: ‘label’
[09:29:51.425]   - Field: ‘local’
[09:29:51.425]   - Field: ‘owner’
[09:29:51.425]   - Field: ‘envir’
[09:29:51.425]   - Field: ‘workers’
[09:29:51.425]   - Field: ‘packages’
[09:29:51.425]   - Field: ‘gc’
[09:29:51.425]   - Field: ‘conditions’
[09:29:51.426]   - Field: ‘persistent’
[09:29:51.426]   - Field: ‘expr’
[09:29:51.426]   - Field: ‘uuid’
[09:29:51.426]   - Field: ‘seed’
[09:29:51.426]   - Field: ‘version’
[09:29:51.426]   - Field: ‘result’
[09:29:51.426]   - Field: ‘asynchronous’
[09:29:51.426]   - Field: ‘calls’
[09:29:51.426]   - Field: ‘globals’
[09:29:51.426]   - Field: ‘stdout’
[09:29:51.426]   - Field: ‘earlySignal’
[09:29:51.426]   - Field: ‘lazy’
[09:29:51.427]   - Field: ‘state’
[09:29:51.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:51.427] - Launch lazy future ...
[09:29:51.427] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:51.427] Packages needed by future strategies (n = 0): <none>
[09:29:51.428] {
[09:29:51.428]     {
[09:29:51.428]         {
[09:29:51.428]             ...future.startTime <- base::Sys.time()
[09:29:51.428]             {
[09:29:51.428]                 {
[09:29:51.428]                   {
[09:29:51.428]                     {
[09:29:51.428]                       {
[09:29:51.428]                         base::local({
[09:29:51.428]                           has_future <- base::requireNamespace("future", 
[09:29:51.428]                             quietly = TRUE)
[09:29:51.428]                           if (has_future) {
[09:29:51.428]                             ns <- base::getNamespace("future")
[09:29:51.428]                             version <- ns[[".package"]][["version"]]
[09:29:51.428]                             if (is.null(version)) 
[09:29:51.428]                               version <- utils::packageVersion("future")
[09:29:51.428]                           }
[09:29:51.428]                           else {
[09:29:51.428]                             version <- NULL
[09:29:51.428]                           }
[09:29:51.428]                           if (!has_future || version < "1.8.0") {
[09:29:51.428]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:51.428]                               "", base::R.version$version.string), 
[09:29:51.428]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:51.428]                                 base::R.version$platform, 8 * 
[09:29:51.428]                                   base::.Machine$sizeof.pointer), 
[09:29:51.428]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:51.428]                                 "release", "version")], collapse = " "), 
[09:29:51.428]                               hostname = base::Sys.info()[["nodename"]])
[09:29:51.428]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:51.428]                               info)
[09:29:51.428]                             info <- base::paste(info, collapse = "; ")
[09:29:51.428]                             if (!has_future) {
[09:29:51.428]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:51.428]                                 info)
[09:29:51.428]                             }
[09:29:51.428]                             else {
[09:29:51.428]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:51.428]                                 info, version)
[09:29:51.428]                             }
[09:29:51.428]                             base::stop(msg)
[09:29:51.428]                           }
[09:29:51.428]                         })
[09:29:51.428]                       }
[09:29:51.428]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:51.428]                       base::options(mc.cores = 1L)
[09:29:51.428]                     }
[09:29:51.428]                     base::local({
[09:29:51.428]                       for (pkg in "future.apply") {
[09:29:51.428]                         base::loadNamespace(pkg)
[09:29:51.428]                         base::library(pkg, character.only = TRUE)
[09:29:51.428]                       }
[09:29:51.428]                     })
[09:29:51.428]                   }
[09:29:51.428]                   ...future.strategy.old <- future::plan("list")
[09:29:51.428]                   options(future.plan = NULL)
[09:29:51.428]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.428]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:51.428]                 }
[09:29:51.428]                 ...future.workdir <- getwd()
[09:29:51.428]             }
[09:29:51.428]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:51.428]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:51.428]         }
[09:29:51.428]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:51.428]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:51.428]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:51.428]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:51.428]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:51.428]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:51.428]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:51.428]             base::names(...future.oldOptions))
[09:29:51.428]     }
[09:29:51.428]     if (FALSE) {
[09:29:51.428]     }
[09:29:51.428]     else {
[09:29:51.428]         if (TRUE) {
[09:29:51.428]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:51.428]                 open = "w")
[09:29:51.428]         }
[09:29:51.428]         else {
[09:29:51.428]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:51.428]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:51.428]         }
[09:29:51.428]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:51.428]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:51.428]             base::sink(type = "output", split = FALSE)
[09:29:51.428]             base::close(...future.stdout)
[09:29:51.428]         }, add = TRUE)
[09:29:51.428]     }
[09:29:51.428]     ...future.frame <- base::sys.nframe()
[09:29:51.428]     ...future.conditions <- base::list()
[09:29:51.428]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:51.428]     if (FALSE) {
[09:29:51.428]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:51.428]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:51.428]     }
[09:29:51.428]     ...future.result <- base::tryCatch({
[09:29:51.428]         base::withCallingHandlers({
[09:29:51.428]             ...future.value <- base::withVisible(base::local({
[09:29:51.428]                 ...future.makeSendCondition <- base::local({
[09:29:51.428]                   sendCondition <- NULL
[09:29:51.428]                   function(frame = 1L) {
[09:29:51.428]                     if (is.function(sendCondition)) 
[09:29:51.428]                       return(sendCondition)
[09:29:51.428]                     ns <- getNamespace("parallel")
[09:29:51.428]                     if (exists("sendData", mode = "function", 
[09:29:51.428]                       envir = ns)) {
[09:29:51.428]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:51.428]                         envir = ns)
[09:29:51.428]                       envir <- sys.frame(frame)
[09:29:51.428]                       master <- NULL
[09:29:51.428]                       while (!identical(envir, .GlobalEnv) && 
[09:29:51.428]                         !identical(envir, emptyenv())) {
[09:29:51.428]                         if (exists("master", mode = "list", envir = envir, 
[09:29:51.428]                           inherits = FALSE)) {
[09:29:51.428]                           master <- get("master", mode = "list", 
[09:29:51.428]                             envir = envir, inherits = FALSE)
[09:29:51.428]                           if (inherits(master, c("SOCKnode", 
[09:29:51.428]                             "SOCK0node"))) {
[09:29:51.428]                             sendCondition <<- function(cond) {
[09:29:51.428]                               data <- list(type = "VALUE", value = cond, 
[09:29:51.428]                                 success = TRUE)
[09:29:51.428]                               parallel_sendData(master, data)
[09:29:51.428]                             }
[09:29:51.428]                             return(sendCondition)
[09:29:51.428]                           }
[09:29:51.428]                         }
[09:29:51.428]                         frame <- frame + 1L
[09:29:51.428]                         envir <- sys.frame(frame)
[09:29:51.428]                       }
[09:29:51.428]                     }
[09:29:51.428]                     sendCondition <<- function(cond) NULL
[09:29:51.428]                   }
[09:29:51.428]                 })
[09:29:51.428]                 withCallingHandlers({
[09:29:51.428]                   {
[09:29:51.428]                     do.call(function(...) {
[09:29:51.428]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.428]                       if (!identical(...future.globals.maxSize.org, 
[09:29:51.428]                         ...future.globals.maxSize)) {
[09:29:51.428]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.428]                         on.exit(options(oopts), add = TRUE)
[09:29:51.428]                       }
[09:29:51.428]                       {
[09:29:51.428]                         lapply(seq_along(...future.elements_ii), 
[09:29:51.428]                           FUN = function(jj) {
[09:29:51.428]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.428]                             ...future.FUN(...future.X_jj, ...)
[09:29:51.428]                           })
[09:29:51.428]                       }
[09:29:51.428]                     }, args = future.call.arguments)
[09:29:51.428]                   }
[09:29:51.428]                 }, immediateCondition = function(cond) {
[09:29:51.428]                   sendCondition <- ...future.makeSendCondition()
[09:29:51.428]                   sendCondition(cond)
[09:29:51.428]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.428]                   {
[09:29:51.428]                     inherits <- base::inherits
[09:29:51.428]                     invokeRestart <- base::invokeRestart
[09:29:51.428]                     is.null <- base::is.null
[09:29:51.428]                     muffled <- FALSE
[09:29:51.428]                     if (inherits(cond, "message")) {
[09:29:51.428]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:51.428]                       if (muffled) 
[09:29:51.428]                         invokeRestart("muffleMessage")
[09:29:51.428]                     }
[09:29:51.428]                     else if (inherits(cond, "warning")) {
[09:29:51.428]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:51.428]                       if (muffled) 
[09:29:51.428]                         invokeRestart("muffleWarning")
[09:29:51.428]                     }
[09:29:51.428]                     else if (inherits(cond, "condition")) {
[09:29:51.428]                       if (!is.null(pattern)) {
[09:29:51.428]                         computeRestarts <- base::computeRestarts
[09:29:51.428]                         grepl <- base::grepl
[09:29:51.428]                         restarts <- computeRestarts(cond)
[09:29:51.428]                         for (restart in restarts) {
[09:29:51.428]                           name <- restart$name
[09:29:51.428]                           if (is.null(name)) 
[09:29:51.428]                             next
[09:29:51.428]                           if (!grepl(pattern, name)) 
[09:29:51.428]                             next
[09:29:51.428]                           invokeRestart(restart)
[09:29:51.428]                           muffled <- TRUE
[09:29:51.428]                           break
[09:29:51.428]                         }
[09:29:51.428]                       }
[09:29:51.428]                     }
[09:29:51.428]                     invisible(muffled)
[09:29:51.428]                   }
[09:29:51.428]                   muffleCondition(cond)
[09:29:51.428]                 })
[09:29:51.428]             }))
[09:29:51.428]             future::FutureResult(value = ...future.value$value, 
[09:29:51.428]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.428]                   ...future.rng), globalenv = if (FALSE) 
[09:29:51.428]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:51.428]                     ...future.globalenv.names))
[09:29:51.428]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:51.428]         }, condition = base::local({
[09:29:51.428]             c <- base::c
[09:29:51.428]             inherits <- base::inherits
[09:29:51.428]             invokeRestart <- base::invokeRestart
[09:29:51.428]             length <- base::length
[09:29:51.428]             list <- base::list
[09:29:51.428]             seq.int <- base::seq.int
[09:29:51.428]             signalCondition <- base::signalCondition
[09:29:51.428]             sys.calls <- base::sys.calls
[09:29:51.428]             `[[` <- base::`[[`
[09:29:51.428]             `+` <- base::`+`
[09:29:51.428]             `<<-` <- base::`<<-`
[09:29:51.428]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:51.428]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:51.428]                   3L)]
[09:29:51.428]             }
[09:29:51.428]             function(cond) {
[09:29:51.428]                 is_error <- inherits(cond, "error")
[09:29:51.428]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:51.428]                   NULL)
[09:29:51.428]                 if (is_error) {
[09:29:51.428]                   sessionInformation <- function() {
[09:29:51.428]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:51.428]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:51.428]                       search = base::search(), system = base::Sys.info())
[09:29:51.428]                   }
[09:29:51.428]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.428]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:51.428]                     cond$call), session = sessionInformation(), 
[09:29:51.428]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:51.428]                   signalCondition(cond)
[09:29:51.428]                 }
[09:29:51.428]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:51.428]                 "immediateCondition"))) {
[09:29:51.428]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:51.428]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.428]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:51.428]                   if (TRUE && !signal) {
[09:29:51.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.428]                     {
[09:29:51.428]                       inherits <- base::inherits
[09:29:51.428]                       invokeRestart <- base::invokeRestart
[09:29:51.428]                       is.null <- base::is.null
[09:29:51.428]                       muffled <- FALSE
[09:29:51.428]                       if (inherits(cond, "message")) {
[09:29:51.428]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.428]                         if (muffled) 
[09:29:51.428]                           invokeRestart("muffleMessage")
[09:29:51.428]                       }
[09:29:51.428]                       else if (inherits(cond, "warning")) {
[09:29:51.428]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.428]                         if (muffled) 
[09:29:51.428]                           invokeRestart("muffleWarning")
[09:29:51.428]                       }
[09:29:51.428]                       else if (inherits(cond, "condition")) {
[09:29:51.428]                         if (!is.null(pattern)) {
[09:29:51.428]                           computeRestarts <- base::computeRestarts
[09:29:51.428]                           grepl <- base::grepl
[09:29:51.428]                           restarts <- computeRestarts(cond)
[09:29:51.428]                           for (restart in restarts) {
[09:29:51.428]                             name <- restart$name
[09:29:51.428]                             if (is.null(name)) 
[09:29:51.428]                               next
[09:29:51.428]                             if (!grepl(pattern, name)) 
[09:29:51.428]                               next
[09:29:51.428]                             invokeRestart(restart)
[09:29:51.428]                             muffled <- TRUE
[09:29:51.428]                             break
[09:29:51.428]                           }
[09:29:51.428]                         }
[09:29:51.428]                       }
[09:29:51.428]                       invisible(muffled)
[09:29:51.428]                     }
[09:29:51.428]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.428]                   }
[09:29:51.428]                 }
[09:29:51.428]                 else {
[09:29:51.428]                   if (TRUE) {
[09:29:51.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.428]                     {
[09:29:51.428]                       inherits <- base::inherits
[09:29:51.428]                       invokeRestart <- base::invokeRestart
[09:29:51.428]                       is.null <- base::is.null
[09:29:51.428]                       muffled <- FALSE
[09:29:51.428]                       if (inherits(cond, "message")) {
[09:29:51.428]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.428]                         if (muffled) 
[09:29:51.428]                           invokeRestart("muffleMessage")
[09:29:51.428]                       }
[09:29:51.428]                       else if (inherits(cond, "warning")) {
[09:29:51.428]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.428]                         if (muffled) 
[09:29:51.428]                           invokeRestart("muffleWarning")
[09:29:51.428]                       }
[09:29:51.428]                       else if (inherits(cond, "condition")) {
[09:29:51.428]                         if (!is.null(pattern)) {
[09:29:51.428]                           computeRestarts <- base::computeRestarts
[09:29:51.428]                           grepl <- base::grepl
[09:29:51.428]                           restarts <- computeRestarts(cond)
[09:29:51.428]                           for (restart in restarts) {
[09:29:51.428]                             name <- restart$name
[09:29:51.428]                             if (is.null(name)) 
[09:29:51.428]                               next
[09:29:51.428]                             if (!grepl(pattern, name)) 
[09:29:51.428]                               next
[09:29:51.428]                             invokeRestart(restart)
[09:29:51.428]                             muffled <- TRUE
[09:29:51.428]                             break
[09:29:51.428]                           }
[09:29:51.428]                         }
[09:29:51.428]                       }
[09:29:51.428]                       invisible(muffled)
[09:29:51.428]                     }
[09:29:51.428]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.428]                   }
[09:29:51.428]                 }
[09:29:51.428]             }
[09:29:51.428]         }))
[09:29:51.428]     }, error = function(ex) {
[09:29:51.428]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:51.428]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.428]                 ...future.rng), started = ...future.startTime, 
[09:29:51.428]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:51.428]             version = "1.8"), class = "FutureResult")
[09:29:51.428]     }, finally = {
[09:29:51.428]         if (!identical(...future.workdir, getwd())) 
[09:29:51.428]             setwd(...future.workdir)
[09:29:51.428]         {
[09:29:51.428]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:51.428]                 ...future.oldOptions$nwarnings <- NULL
[09:29:51.428]             }
[09:29:51.428]             base::options(...future.oldOptions)
[09:29:51.428]             if (.Platform$OS.type == "windows") {
[09:29:51.428]                 old_names <- names(...future.oldEnvVars)
[09:29:51.428]                 envs <- base::Sys.getenv()
[09:29:51.428]                 names <- names(envs)
[09:29:51.428]                 common <- intersect(names, old_names)
[09:29:51.428]                 added <- setdiff(names, old_names)
[09:29:51.428]                 removed <- setdiff(old_names, names)
[09:29:51.428]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:51.428]                   envs[common]]
[09:29:51.428]                 NAMES <- toupper(changed)
[09:29:51.428]                 args <- list()
[09:29:51.428]                 for (kk in seq_along(NAMES)) {
[09:29:51.428]                   name <- changed[[kk]]
[09:29:51.428]                   NAME <- NAMES[[kk]]
[09:29:51.428]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.428]                     next
[09:29:51.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.428]                 }
[09:29:51.428]                 NAMES <- toupper(added)
[09:29:51.428]                 for (kk in seq_along(NAMES)) {
[09:29:51.428]                   name <- added[[kk]]
[09:29:51.428]                   NAME <- NAMES[[kk]]
[09:29:51.428]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.428]                     next
[09:29:51.428]                   args[[name]] <- ""
[09:29:51.428]                 }
[09:29:51.428]                 NAMES <- toupper(removed)
[09:29:51.428]                 for (kk in seq_along(NAMES)) {
[09:29:51.428]                   name <- removed[[kk]]
[09:29:51.428]                   NAME <- NAMES[[kk]]
[09:29:51.428]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.428]                     next
[09:29:51.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.428]                 }
[09:29:51.428]                 if (length(args) > 0) 
[09:29:51.428]                   base::do.call(base::Sys.setenv, args = args)
[09:29:51.428]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:51.428]             }
[09:29:51.428]             else {
[09:29:51.428]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:51.428]             }
[09:29:51.428]             {
[09:29:51.428]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:51.428]                   0L) {
[09:29:51.428]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:51.428]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:51.428]                   base::options(opts)
[09:29:51.428]                 }
[09:29:51.428]                 {
[09:29:51.428]                   {
[09:29:51.428]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:51.428]                     NULL
[09:29:51.428]                   }
[09:29:51.428]                   options(future.plan = NULL)
[09:29:51.428]                   if (is.na(NA_character_)) 
[09:29:51.428]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.428]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:51.428]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:51.428]                     .init = FALSE)
[09:29:51.428]                 }
[09:29:51.428]             }
[09:29:51.428]         }
[09:29:51.428]     })
[09:29:51.428]     if (TRUE) {
[09:29:51.428]         base::sink(type = "output", split = FALSE)
[09:29:51.428]         if (TRUE) {
[09:29:51.428]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:51.428]         }
[09:29:51.428]         else {
[09:29:51.428]             ...future.result["stdout"] <- base::list(NULL)
[09:29:51.428]         }
[09:29:51.428]         base::close(...future.stdout)
[09:29:51.428]         ...future.stdout <- NULL
[09:29:51.428]     }
[09:29:51.428]     ...future.result$conditions <- ...future.conditions
[09:29:51.428]     ...future.result$finished <- base::Sys.time()
[09:29:51.428]     ...future.result
[09:29:51.428] }
[09:29:51.430] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[09:29:51.430] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:51.472] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:51.472] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[09:29:51.473] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[09:29:51.473] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:51.473] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:51.473] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:51.516] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:51.516] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:51.560] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:51.560] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[09:29:51.561] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[09:29:51.561] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:51.561] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:51.562] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:51.562] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.562] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:51.562] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:51.563] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:51.563] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.563] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:51.563] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.564] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[09:29:51.564] MultisessionFuture started
[09:29:51.564] - Launch lazy future ... done
[09:29:51.564] run() for ‘MultisessionFuture’ ... done
[09:29:51.564] Created future:
[09:29:51.566] receiveMessageFromWorker() for ClusterFuture ...
[09:29:51.566] - Validating connection of MultisessionFuture
[09:29:51.566] - received message: FutureResult
[09:29:51.566] - Received FutureResult
[09:29:51.566] - Erased future from FutureRegistry
[09:29:51.567] result() for ClusterFuture ...
[09:29:51.567] - result already collected: FutureResult
[09:29:51.567] result() for ClusterFuture ... done
[09:29:51.567] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:51.565] MultisessionFuture:
[09:29:51.565] Label: ‘future_vapply-1’
[09:29:51.565] Expression:
[09:29:51.565] {
[09:29:51.565]     do.call(function(...) {
[09:29:51.565]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.565]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.565]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.565]             on.exit(options(oopts), add = TRUE)
[09:29:51.565]         }
[09:29:51.565]         {
[09:29:51.565]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.565]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.565]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.565]             })
[09:29:51.565]         }
[09:29:51.565]     }, args = future.call.arguments)
[09:29:51.565] }
[09:29:51.565] Lazy evaluation: FALSE
[09:29:51.565] Asynchronous evaluation: TRUE
[09:29:51.565] Local evaluation: TRUE
[09:29:51.565] Environment: R_GlobalEnv
[09:29:51.565] Capture standard output: TRUE
[09:29:51.565] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:51.565] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:51.565] Packages: 1 packages (‘future.apply’)
[09:29:51.565] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:51.565] Resolved: TRUE
[09:29:51.565] Value: <not collected>
[09:29:51.565] Conditions captured: <none>
[09:29:51.565] Early signaling: FALSE
[09:29:51.565] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:51.565] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.567] Chunk #1 of 2 ... DONE
[09:29:51.567] Chunk #2 of 2 ...
[09:29:51.567]  - Finding globals in 'X' for chunk #2 ...
[09:29:51.567] getGlobalsAndPackages() ...
[09:29:51.568] Searching for globals...
[09:29:51.568] 
[09:29:51.568] Searching for globals ... DONE
[09:29:51.568] - globals: [0] <none>
[09:29:51.568] getGlobalsAndPackages() ... DONE
[09:29:51.568]    + additional globals found: [n=0] 
[09:29:51.568]    + additional namespaces needed: [n=0] 
[09:29:51.568]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:51.568]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:51.569]  - seeds: <none>
[09:29:51.569]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.569] getGlobalsAndPackages() ...
[09:29:51.569] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.569] Resolving globals: FALSE
[09:29:51.569] Tweak future expression to call with '...' arguments ...
[09:29:51.569] {
[09:29:51.569]     do.call(function(...) {
[09:29:51.569]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.569]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.569]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.569]             on.exit(options(oopts), add = TRUE)
[09:29:51.569]         }
[09:29:51.569]         {
[09:29:51.569]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.569]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.569]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.569]             })
[09:29:51.569]         }
[09:29:51.569]     }, args = future.call.arguments)
[09:29:51.569] }
[09:29:51.569] Tweak future expression to call with '...' arguments ... DONE
[09:29:51.570] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.570] - packages: [1] ‘future.apply’
[09:29:51.570] getGlobalsAndPackages() ... DONE
[09:29:51.570] run() for ‘Future’ ...
[09:29:51.570] - state: ‘created’
[09:29:51.571] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:51.585] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.585] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:51.585]   - Field: ‘node’
[09:29:51.585]   - Field: ‘label’
[09:29:51.586]   - Field: ‘local’
[09:29:51.586]   - Field: ‘owner’
[09:29:51.586]   - Field: ‘envir’
[09:29:51.586]   - Field: ‘workers’
[09:29:51.586]   - Field: ‘packages’
[09:29:51.586]   - Field: ‘gc’
[09:29:51.586]   - Field: ‘conditions’
[09:29:51.586]   - Field: ‘persistent’
[09:29:51.586]   - Field: ‘expr’
[09:29:51.586]   - Field: ‘uuid’
[09:29:51.586]   - Field: ‘seed’
[09:29:51.587]   - Field: ‘version’
[09:29:51.587]   - Field: ‘result’
[09:29:51.587]   - Field: ‘asynchronous’
[09:29:51.587]   - Field: ‘calls’
[09:29:51.587]   - Field: ‘globals’
[09:29:51.587]   - Field: ‘stdout’
[09:29:51.587]   - Field: ‘earlySignal’
[09:29:51.587]   - Field: ‘lazy’
[09:29:51.587]   - Field: ‘state’
[09:29:51.587] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:51.587] - Launch lazy future ...
[09:29:51.588] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:51.588] Packages needed by future strategies (n = 0): <none>
[09:29:51.588] {
[09:29:51.588]     {
[09:29:51.588]         {
[09:29:51.588]             ...future.startTime <- base::Sys.time()
[09:29:51.588]             {
[09:29:51.588]                 {
[09:29:51.588]                   {
[09:29:51.588]                     {
[09:29:51.588]                       {
[09:29:51.588]                         base::local({
[09:29:51.588]                           has_future <- base::requireNamespace("future", 
[09:29:51.588]                             quietly = TRUE)
[09:29:51.588]                           if (has_future) {
[09:29:51.588]                             ns <- base::getNamespace("future")
[09:29:51.588]                             version <- ns[[".package"]][["version"]]
[09:29:51.588]                             if (is.null(version)) 
[09:29:51.588]                               version <- utils::packageVersion("future")
[09:29:51.588]                           }
[09:29:51.588]                           else {
[09:29:51.588]                             version <- NULL
[09:29:51.588]                           }
[09:29:51.588]                           if (!has_future || version < "1.8.0") {
[09:29:51.588]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:51.588]                               "", base::R.version$version.string), 
[09:29:51.588]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:51.588]                                 base::R.version$platform, 8 * 
[09:29:51.588]                                   base::.Machine$sizeof.pointer), 
[09:29:51.588]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:51.588]                                 "release", "version")], collapse = " "), 
[09:29:51.588]                               hostname = base::Sys.info()[["nodename"]])
[09:29:51.588]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:51.588]                               info)
[09:29:51.588]                             info <- base::paste(info, collapse = "; ")
[09:29:51.588]                             if (!has_future) {
[09:29:51.588]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:51.588]                                 info)
[09:29:51.588]                             }
[09:29:51.588]                             else {
[09:29:51.588]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:51.588]                                 info, version)
[09:29:51.588]                             }
[09:29:51.588]                             base::stop(msg)
[09:29:51.588]                           }
[09:29:51.588]                         })
[09:29:51.588]                       }
[09:29:51.588]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:51.588]                       base::options(mc.cores = 1L)
[09:29:51.588]                     }
[09:29:51.588]                     base::local({
[09:29:51.588]                       for (pkg in "future.apply") {
[09:29:51.588]                         base::loadNamespace(pkg)
[09:29:51.588]                         base::library(pkg, character.only = TRUE)
[09:29:51.588]                       }
[09:29:51.588]                     })
[09:29:51.588]                   }
[09:29:51.588]                   ...future.strategy.old <- future::plan("list")
[09:29:51.588]                   options(future.plan = NULL)
[09:29:51.588]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.588]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:51.588]                 }
[09:29:51.588]                 ...future.workdir <- getwd()
[09:29:51.588]             }
[09:29:51.588]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:51.588]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:51.588]         }
[09:29:51.588]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:51.588]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:51.588]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:51.588]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:51.588]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:51.588]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:51.588]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:51.588]             base::names(...future.oldOptions))
[09:29:51.588]     }
[09:29:51.588]     if (FALSE) {
[09:29:51.588]     }
[09:29:51.588]     else {
[09:29:51.588]         if (TRUE) {
[09:29:51.588]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:51.588]                 open = "w")
[09:29:51.588]         }
[09:29:51.588]         else {
[09:29:51.588]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:51.588]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:51.588]         }
[09:29:51.588]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:51.588]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:51.588]             base::sink(type = "output", split = FALSE)
[09:29:51.588]             base::close(...future.stdout)
[09:29:51.588]         }, add = TRUE)
[09:29:51.588]     }
[09:29:51.588]     ...future.frame <- base::sys.nframe()
[09:29:51.588]     ...future.conditions <- base::list()
[09:29:51.588]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:51.588]     if (FALSE) {
[09:29:51.588]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:51.588]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:51.588]     }
[09:29:51.588]     ...future.result <- base::tryCatch({
[09:29:51.588]         base::withCallingHandlers({
[09:29:51.588]             ...future.value <- base::withVisible(base::local({
[09:29:51.588]                 ...future.makeSendCondition <- base::local({
[09:29:51.588]                   sendCondition <- NULL
[09:29:51.588]                   function(frame = 1L) {
[09:29:51.588]                     if (is.function(sendCondition)) 
[09:29:51.588]                       return(sendCondition)
[09:29:51.588]                     ns <- getNamespace("parallel")
[09:29:51.588]                     if (exists("sendData", mode = "function", 
[09:29:51.588]                       envir = ns)) {
[09:29:51.588]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:51.588]                         envir = ns)
[09:29:51.588]                       envir <- sys.frame(frame)
[09:29:51.588]                       master <- NULL
[09:29:51.588]                       while (!identical(envir, .GlobalEnv) && 
[09:29:51.588]                         !identical(envir, emptyenv())) {
[09:29:51.588]                         if (exists("master", mode = "list", envir = envir, 
[09:29:51.588]                           inherits = FALSE)) {
[09:29:51.588]                           master <- get("master", mode = "list", 
[09:29:51.588]                             envir = envir, inherits = FALSE)
[09:29:51.588]                           if (inherits(master, c("SOCKnode", 
[09:29:51.588]                             "SOCK0node"))) {
[09:29:51.588]                             sendCondition <<- function(cond) {
[09:29:51.588]                               data <- list(type = "VALUE", value = cond, 
[09:29:51.588]                                 success = TRUE)
[09:29:51.588]                               parallel_sendData(master, data)
[09:29:51.588]                             }
[09:29:51.588]                             return(sendCondition)
[09:29:51.588]                           }
[09:29:51.588]                         }
[09:29:51.588]                         frame <- frame + 1L
[09:29:51.588]                         envir <- sys.frame(frame)
[09:29:51.588]                       }
[09:29:51.588]                     }
[09:29:51.588]                     sendCondition <<- function(cond) NULL
[09:29:51.588]                   }
[09:29:51.588]                 })
[09:29:51.588]                 withCallingHandlers({
[09:29:51.588]                   {
[09:29:51.588]                     do.call(function(...) {
[09:29:51.588]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.588]                       if (!identical(...future.globals.maxSize.org, 
[09:29:51.588]                         ...future.globals.maxSize)) {
[09:29:51.588]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.588]                         on.exit(options(oopts), add = TRUE)
[09:29:51.588]                       }
[09:29:51.588]                       {
[09:29:51.588]                         lapply(seq_along(...future.elements_ii), 
[09:29:51.588]                           FUN = function(jj) {
[09:29:51.588]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.588]                             ...future.FUN(...future.X_jj, ...)
[09:29:51.588]                           })
[09:29:51.588]                       }
[09:29:51.588]                     }, args = future.call.arguments)
[09:29:51.588]                   }
[09:29:51.588]                 }, immediateCondition = function(cond) {
[09:29:51.588]                   sendCondition <- ...future.makeSendCondition()
[09:29:51.588]                   sendCondition(cond)
[09:29:51.588]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.588]                   {
[09:29:51.588]                     inherits <- base::inherits
[09:29:51.588]                     invokeRestart <- base::invokeRestart
[09:29:51.588]                     is.null <- base::is.null
[09:29:51.588]                     muffled <- FALSE
[09:29:51.588]                     if (inherits(cond, "message")) {
[09:29:51.588]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:51.588]                       if (muffled) 
[09:29:51.588]                         invokeRestart("muffleMessage")
[09:29:51.588]                     }
[09:29:51.588]                     else if (inherits(cond, "warning")) {
[09:29:51.588]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:51.588]                       if (muffled) 
[09:29:51.588]                         invokeRestart("muffleWarning")
[09:29:51.588]                     }
[09:29:51.588]                     else if (inherits(cond, "condition")) {
[09:29:51.588]                       if (!is.null(pattern)) {
[09:29:51.588]                         computeRestarts <- base::computeRestarts
[09:29:51.588]                         grepl <- base::grepl
[09:29:51.588]                         restarts <- computeRestarts(cond)
[09:29:51.588]                         for (restart in restarts) {
[09:29:51.588]                           name <- restart$name
[09:29:51.588]                           if (is.null(name)) 
[09:29:51.588]                             next
[09:29:51.588]                           if (!grepl(pattern, name)) 
[09:29:51.588]                             next
[09:29:51.588]                           invokeRestart(restart)
[09:29:51.588]                           muffled <- TRUE
[09:29:51.588]                           break
[09:29:51.588]                         }
[09:29:51.588]                       }
[09:29:51.588]                     }
[09:29:51.588]                     invisible(muffled)
[09:29:51.588]                   }
[09:29:51.588]                   muffleCondition(cond)
[09:29:51.588]                 })
[09:29:51.588]             }))
[09:29:51.588]             future::FutureResult(value = ...future.value$value, 
[09:29:51.588]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.588]                   ...future.rng), globalenv = if (FALSE) 
[09:29:51.588]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:51.588]                     ...future.globalenv.names))
[09:29:51.588]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:51.588]         }, condition = base::local({
[09:29:51.588]             c <- base::c
[09:29:51.588]             inherits <- base::inherits
[09:29:51.588]             invokeRestart <- base::invokeRestart
[09:29:51.588]             length <- base::length
[09:29:51.588]             list <- base::list
[09:29:51.588]             seq.int <- base::seq.int
[09:29:51.588]             signalCondition <- base::signalCondition
[09:29:51.588]             sys.calls <- base::sys.calls
[09:29:51.588]             `[[` <- base::`[[`
[09:29:51.588]             `+` <- base::`+`
[09:29:51.588]             `<<-` <- base::`<<-`
[09:29:51.588]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:51.588]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:51.588]                   3L)]
[09:29:51.588]             }
[09:29:51.588]             function(cond) {
[09:29:51.588]                 is_error <- inherits(cond, "error")
[09:29:51.588]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:51.588]                   NULL)
[09:29:51.588]                 if (is_error) {
[09:29:51.588]                   sessionInformation <- function() {
[09:29:51.588]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:51.588]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:51.588]                       search = base::search(), system = base::Sys.info())
[09:29:51.588]                   }
[09:29:51.588]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.588]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:51.588]                     cond$call), session = sessionInformation(), 
[09:29:51.588]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:51.588]                   signalCondition(cond)
[09:29:51.588]                 }
[09:29:51.588]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:51.588]                 "immediateCondition"))) {
[09:29:51.588]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:51.588]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.588]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:51.588]                   if (TRUE && !signal) {
[09:29:51.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.588]                     {
[09:29:51.588]                       inherits <- base::inherits
[09:29:51.588]                       invokeRestart <- base::invokeRestart
[09:29:51.588]                       is.null <- base::is.null
[09:29:51.588]                       muffled <- FALSE
[09:29:51.588]                       if (inherits(cond, "message")) {
[09:29:51.588]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.588]                         if (muffled) 
[09:29:51.588]                           invokeRestart("muffleMessage")
[09:29:51.588]                       }
[09:29:51.588]                       else if (inherits(cond, "warning")) {
[09:29:51.588]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.588]                         if (muffled) 
[09:29:51.588]                           invokeRestart("muffleWarning")
[09:29:51.588]                       }
[09:29:51.588]                       else if (inherits(cond, "condition")) {
[09:29:51.588]                         if (!is.null(pattern)) {
[09:29:51.588]                           computeRestarts <- base::computeRestarts
[09:29:51.588]                           grepl <- base::grepl
[09:29:51.588]                           restarts <- computeRestarts(cond)
[09:29:51.588]                           for (restart in restarts) {
[09:29:51.588]                             name <- restart$name
[09:29:51.588]                             if (is.null(name)) 
[09:29:51.588]                               next
[09:29:51.588]                             if (!grepl(pattern, name)) 
[09:29:51.588]                               next
[09:29:51.588]                             invokeRestart(restart)
[09:29:51.588]                             muffled <- TRUE
[09:29:51.588]                             break
[09:29:51.588]                           }
[09:29:51.588]                         }
[09:29:51.588]                       }
[09:29:51.588]                       invisible(muffled)
[09:29:51.588]                     }
[09:29:51.588]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.588]                   }
[09:29:51.588]                 }
[09:29:51.588]                 else {
[09:29:51.588]                   if (TRUE) {
[09:29:51.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.588]                     {
[09:29:51.588]                       inherits <- base::inherits
[09:29:51.588]                       invokeRestart <- base::invokeRestart
[09:29:51.588]                       is.null <- base::is.null
[09:29:51.588]                       muffled <- FALSE
[09:29:51.588]                       if (inherits(cond, "message")) {
[09:29:51.588]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.588]                         if (muffled) 
[09:29:51.588]                           invokeRestart("muffleMessage")
[09:29:51.588]                       }
[09:29:51.588]                       else if (inherits(cond, "warning")) {
[09:29:51.588]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.588]                         if (muffled) 
[09:29:51.588]                           invokeRestart("muffleWarning")
[09:29:51.588]                       }
[09:29:51.588]                       else if (inherits(cond, "condition")) {
[09:29:51.588]                         if (!is.null(pattern)) {
[09:29:51.588]                           computeRestarts <- base::computeRestarts
[09:29:51.588]                           grepl <- base::grepl
[09:29:51.588]                           restarts <- computeRestarts(cond)
[09:29:51.588]                           for (restart in restarts) {
[09:29:51.588]                             name <- restart$name
[09:29:51.588]                             if (is.null(name)) 
[09:29:51.588]                               next
[09:29:51.588]                             if (!grepl(pattern, name)) 
[09:29:51.588]                               next
[09:29:51.588]                             invokeRestart(restart)
[09:29:51.588]                             muffled <- TRUE
[09:29:51.588]                             break
[09:29:51.588]                           }
[09:29:51.588]                         }
[09:29:51.588]                       }
[09:29:51.588]                       invisible(muffled)
[09:29:51.588]                     }
[09:29:51.588]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.588]                   }
[09:29:51.588]                 }
[09:29:51.588]             }
[09:29:51.588]         }))
[09:29:51.588]     }, error = function(ex) {
[09:29:51.588]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:51.588]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.588]                 ...future.rng), started = ...future.startTime, 
[09:29:51.588]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:51.588]             version = "1.8"), class = "FutureResult")
[09:29:51.588]     }, finally = {
[09:29:51.588]         if (!identical(...future.workdir, getwd())) 
[09:29:51.588]             setwd(...future.workdir)
[09:29:51.588]         {
[09:29:51.588]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:51.588]                 ...future.oldOptions$nwarnings <- NULL
[09:29:51.588]             }
[09:29:51.588]             base::options(...future.oldOptions)
[09:29:51.588]             if (.Platform$OS.type == "windows") {
[09:29:51.588]                 old_names <- names(...future.oldEnvVars)
[09:29:51.588]                 envs <- base::Sys.getenv()
[09:29:51.588]                 names <- names(envs)
[09:29:51.588]                 common <- intersect(names, old_names)
[09:29:51.588]                 added <- setdiff(names, old_names)
[09:29:51.588]                 removed <- setdiff(old_names, names)
[09:29:51.588]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:51.588]                   envs[common]]
[09:29:51.588]                 NAMES <- toupper(changed)
[09:29:51.588]                 args <- list()
[09:29:51.588]                 for (kk in seq_along(NAMES)) {
[09:29:51.588]                   name <- changed[[kk]]
[09:29:51.588]                   NAME <- NAMES[[kk]]
[09:29:51.588]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.588]                     next
[09:29:51.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.588]                 }
[09:29:51.588]                 NAMES <- toupper(added)
[09:29:51.588]                 for (kk in seq_along(NAMES)) {
[09:29:51.588]                   name <- added[[kk]]
[09:29:51.588]                   NAME <- NAMES[[kk]]
[09:29:51.588]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.588]                     next
[09:29:51.588]                   args[[name]] <- ""
[09:29:51.588]                 }
[09:29:51.588]                 NAMES <- toupper(removed)
[09:29:51.588]                 for (kk in seq_along(NAMES)) {
[09:29:51.588]                   name <- removed[[kk]]
[09:29:51.588]                   NAME <- NAMES[[kk]]
[09:29:51.588]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.588]                     next
[09:29:51.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.588]                 }
[09:29:51.588]                 if (length(args) > 0) 
[09:29:51.588]                   base::do.call(base::Sys.setenv, args = args)
[09:29:51.588]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:51.588]             }
[09:29:51.588]             else {
[09:29:51.588]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:51.588]             }
[09:29:51.588]             {
[09:29:51.588]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:51.588]                   0L) {
[09:29:51.588]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:51.588]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:51.588]                   base::options(opts)
[09:29:51.588]                 }
[09:29:51.588]                 {
[09:29:51.588]                   {
[09:29:51.588]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:51.588]                     NULL
[09:29:51.588]                   }
[09:29:51.588]                   options(future.plan = NULL)
[09:29:51.588]                   if (is.na(NA_character_)) 
[09:29:51.588]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.588]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:51.588]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:51.588]                     .init = FALSE)
[09:29:51.588]                 }
[09:29:51.588]             }
[09:29:51.588]         }
[09:29:51.588]     })
[09:29:51.588]     if (TRUE) {
[09:29:51.588]         base::sink(type = "output", split = FALSE)
[09:29:51.588]         if (TRUE) {
[09:29:51.588]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:51.588]         }
[09:29:51.588]         else {
[09:29:51.588]             ...future.result["stdout"] <- base::list(NULL)
[09:29:51.588]         }
[09:29:51.588]         base::close(...future.stdout)
[09:29:51.588]         ...future.stdout <- NULL
[09:29:51.588]     }
[09:29:51.588]     ...future.result$conditions <- ...future.conditions
[09:29:51.588]     ...future.result$finished <- base::Sys.time()
[09:29:51.588]     ...future.result
[09:29:51.588] }
[09:29:51.591] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[09:29:51.591] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:51.632] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:51.632] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[09:29:51.633] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[09:29:51.633] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:51.633] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:51.633] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:51.676] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:51.676] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:51.720] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:51.720] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[09:29:51.721] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[09:29:51.721] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:51.721] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:51.721] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:51.722] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.722] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:51.722] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:51.722] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:51.723] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.723] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:51.723] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.723] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[09:29:51.724] MultisessionFuture started
[09:29:51.724] - Launch lazy future ... done
[09:29:51.724] run() for ‘MultisessionFuture’ ... done
[09:29:51.724] Created future:
[09:29:51.725] receiveMessageFromWorker() for ClusterFuture ...
[09:29:51.726] - Validating connection of MultisessionFuture
[09:29:51.726] - received message: FutureResult
[09:29:51.726] - Received FutureResult
[09:29:51.726] - Erased future from FutureRegistry
[09:29:51.726] result() for ClusterFuture ...
[09:29:51.726] - result already collected: FutureResult
[09:29:51.726] result() for ClusterFuture ... done
[09:29:51.726] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:51.724] MultisessionFuture:
[09:29:51.724] Label: ‘future_vapply-2’
[09:29:51.724] Expression:
[09:29:51.724] {
[09:29:51.724]     do.call(function(...) {
[09:29:51.724]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.724]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.724]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.724]             on.exit(options(oopts), add = TRUE)
[09:29:51.724]         }
[09:29:51.724]         {
[09:29:51.724]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.724]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.724]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.724]             })
[09:29:51.724]         }
[09:29:51.724]     }, args = future.call.arguments)
[09:29:51.724] }
[09:29:51.724] Lazy evaluation: FALSE
[09:29:51.724] Asynchronous evaluation: TRUE
[09:29:51.724] Local evaluation: TRUE
[09:29:51.724] Environment: R_GlobalEnv
[09:29:51.724] Capture standard output: TRUE
[09:29:51.724] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:51.724] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:51.724] Packages: 1 packages (‘future.apply’)
[09:29:51.724] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:51.724] Resolved: TRUE
[09:29:51.724] Value: <not collected>
[09:29:51.724] Conditions captured: <none>
[09:29:51.724] Early signaling: FALSE
[09:29:51.724] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:51.724] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.727] Chunk #2 of 2 ... DONE
[09:29:51.727] Launching 2 futures (chunks) ... DONE
[09:29:51.727] Resolving 2 futures (chunks) ...
[09:29:51.727] resolve() on list ...
[09:29:51.727]  recursive: 0
[09:29:51.727]  length: 2
[09:29:51.727] 
[09:29:51.727] Future #1
[09:29:51.727] result() for ClusterFuture ...
[09:29:51.727] - result already collected: FutureResult
[09:29:51.727] result() for ClusterFuture ... done
[09:29:51.728] result() for ClusterFuture ...
[09:29:51.728] - result already collected: FutureResult
[09:29:51.728] result() for ClusterFuture ... done
[09:29:51.728] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:51.728] - nx: 2
[09:29:51.728] - relay: TRUE
[09:29:51.728] - stdout: TRUE
[09:29:51.728] - signal: TRUE
[09:29:51.728] - resignal: FALSE
[09:29:51.728] - force: TRUE
[09:29:51.728] - relayed: [n=2] FALSE, FALSE
[09:29:51.729] - queued futures: [n=2] FALSE, FALSE
[09:29:51.729]  - until=1
[09:29:51.729]  - relaying element #1
[09:29:51.729] result() for ClusterFuture ...
[09:29:51.729] - result already collected: FutureResult
[09:29:51.729] result() for ClusterFuture ... done
[09:29:51.729] result() for ClusterFuture ...
[09:29:51.729] - result already collected: FutureResult
[09:29:51.729] result() for ClusterFuture ... done
[09:29:51.729] result() for ClusterFuture ...
[09:29:51.729] - result already collected: FutureResult
[09:29:51.729] result() for ClusterFuture ... done
[09:29:51.730] result() for ClusterFuture ...
[09:29:51.730] - result already collected: FutureResult
[09:29:51.730] result() for ClusterFuture ... done
[09:29:51.730] - relayed: [n=2] TRUE, FALSE
[09:29:51.730] - queued futures: [n=2] TRUE, FALSE
[09:29:51.730] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:51.730]  length: 1 (resolved future 1)
[09:29:51.730] Future #2
[09:29:51.730] result() for ClusterFuture ...
[09:29:51.730] - result already collected: FutureResult
[09:29:51.730] result() for ClusterFuture ... done
[09:29:51.731] result() for ClusterFuture ...
[09:29:51.731] - result already collected: FutureResult
[09:29:51.731] result() for ClusterFuture ... done
[09:29:51.731] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:51.731] - nx: 2
[09:29:51.731] - relay: TRUE
[09:29:51.731] - stdout: TRUE
[09:29:51.731] - signal: TRUE
[09:29:51.731] - resignal: FALSE
[09:29:51.731] - force: TRUE
[09:29:51.731] - relayed: [n=2] TRUE, FALSE
[09:29:51.731] - queued futures: [n=2] TRUE, FALSE
[09:29:51.732]  - until=2
[09:29:51.732]  - relaying element #2
[09:29:51.732] result() for ClusterFuture ...
[09:29:51.732] - result already collected: FutureResult
[09:29:51.732] result() for ClusterFuture ... done
[09:29:51.732] result() for ClusterFuture ...
[09:29:51.732] - result already collected: FutureResult
[09:29:51.732] result() for ClusterFuture ... done
[09:29:51.732] result() for ClusterFuture ...
[09:29:51.732] - result already collected: FutureResult
[09:29:51.732] result() for ClusterFuture ... done
[09:29:51.732] result() for ClusterFuture ...
[09:29:51.733] - result already collected: FutureResult
[09:29:51.733] result() for ClusterFuture ... done
[09:29:51.733] - relayed: [n=2] TRUE, TRUE
[09:29:51.733] - queued futures: [n=2] TRUE, TRUE
[09:29:51.733] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:51.733]  length: 0 (resolved future 2)
[09:29:51.733] Relaying remaining futures
[09:29:51.733] signalConditionsASAP(NULL, pos=0) ...
[09:29:51.733] - nx: 2
[09:29:51.733] - relay: TRUE
[09:29:51.733] - stdout: TRUE
[09:29:51.733] - signal: TRUE
[09:29:51.734] - resignal: FALSE
[09:29:51.734] - force: TRUE
[09:29:51.734] - relayed: [n=2] TRUE, TRUE
[09:29:51.734] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:51.734] - relayed: [n=2] TRUE, TRUE
[09:29:51.734] - queued futures: [n=2] TRUE, TRUE
[09:29:51.734] signalConditionsASAP(NULL, pos=0) ... done
[09:29:51.734] resolve() on list ... DONE
[09:29:51.734] result() for ClusterFuture ...
[09:29:51.734] - result already collected: FutureResult
[09:29:51.734] result() for ClusterFuture ... done
[09:29:51.735] result() for ClusterFuture ...
[09:29:51.735] - result already collected: FutureResult
[09:29:51.735] result() for ClusterFuture ... done
[09:29:51.735] result() for ClusterFuture ...
[09:29:51.735] - result already collected: FutureResult
[09:29:51.735] result() for ClusterFuture ... done
[09:29:51.735] result() for ClusterFuture ...
[09:29:51.735] - result already collected: FutureResult
[09:29:51.735] result() for ClusterFuture ... done
[09:29:51.735]  - Number of value chunks collected: 2
[09:29:51.735] Resolving 2 futures (chunks) ... DONE
[09:29:51.735] Reducing values from 2 chunks ...
[09:29:51.736]  - Number of values collected after concatenation: 10
[09:29:51.736]  - Number of values expected: 10
[09:29:51.736] Reducing values from 2 chunks ... DONE
[09:29:51.736] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[09:29:51.738] future_lapply() ...
[09:29:51.743] Number of chunks: 2
[09:29:51.743] getGlobalsAndPackagesXApply() ...
[09:29:51.743]  - future.globals: TRUE
[09:29:51.743] getGlobalsAndPackages() ...
[09:29:51.743] Searching for globals...
[09:29:51.747] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[09:29:51.747] Searching for globals ... DONE
[09:29:51.747] Resolving globals: FALSE
[09:29:51.748] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[09:29:51.748] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:51.748] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:51.749] - packages: [1] ‘future.apply’
[09:29:51.749] getGlobalsAndPackages() ... DONE
[09:29:51.749]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:51.749]  - needed namespaces: [n=1] ‘future.apply’
[09:29:51.749] Finding globals ... DONE
[09:29:51.749]  - use_args: TRUE
[09:29:51.749]  - Getting '...' globals ...
[09:29:51.749] resolve() on list ...
[09:29:51.749]  recursive: 0
[09:29:51.750]  length: 1
[09:29:51.750]  elements: ‘...’
[09:29:51.750]  length: 0 (resolved future 1)
[09:29:51.750] resolve() on list ... DONE
[09:29:51.750]    - '...' content: [n=0] 
[09:29:51.752] List of 1
[09:29:51.752]  $ ...: list()
[09:29:51.752]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:51.752]  - attr(*, "where")=List of 1
[09:29:51.752]   ..$ ...:<environment: 0x561d38f45348> 
[09:29:51.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:51.752]  - attr(*, "resolved")= logi TRUE
[09:29:51.752]  - attr(*, "total_size")= num NA
[09:29:51.754]  - Getting '...' globals ... DONE
[09:29:51.755] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:51.755] List of 8
[09:29:51.755]  $ ...future.FUN:function (x, ...)  
[09:29:51.755]  $ x_FUN        :function (x)  
[09:29:51.755]  $ times        : int 4
[09:29:51.755]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:51.755]  $ stop_if_not  :function (...)  
[09:29:51.755]  $ dim          : int [1:2] 2 2
[09:29:51.755]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:51.755]  $ ...          : list()
[09:29:51.755]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:51.755]  - attr(*, "where")=List of 8
[09:29:51.755]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:51.755]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:51.755]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:51.755]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:51.755]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:51.755]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:51.755]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:51.755]   ..$ ...          :<environment: 0x561d38f45348> 
[09:29:51.755]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:51.755]  - attr(*, "resolved")= logi FALSE
[09:29:51.755]  - attr(*, "total_size")= num 105552
[09:29:51.760] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:51.760] getGlobalsAndPackagesXApply() ... DONE
[09:29:51.760] Number of futures (= number of chunks): 2
[09:29:51.760] Launching 2 futures (chunks) ...
[09:29:51.760] Chunk #1 of 2 ...
[09:29:51.760]  - Finding globals in 'X' for chunk #1 ...
[09:29:51.760] getGlobalsAndPackages() ...
[09:29:51.761] Searching for globals...
[09:29:51.761] 
[09:29:51.761] Searching for globals ... DONE
[09:29:51.761] - globals: [0] <none>
[09:29:51.761] getGlobalsAndPackages() ... DONE
[09:29:51.761]    + additional globals found: [n=0] 
[09:29:51.761]    + additional namespaces needed: [n=0] 
[09:29:51.761]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:51.761]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:51.761]  - seeds: <none>
[09:29:51.762]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.762] getGlobalsAndPackages() ...
[09:29:51.762] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.762] Resolving globals: FALSE
[09:29:51.762] Tweak future expression to call with '...' arguments ...
[09:29:51.762] {
[09:29:51.762]     do.call(function(...) {
[09:29:51.762]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.762]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.762]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.762]             on.exit(options(oopts), add = TRUE)
[09:29:51.762]         }
[09:29:51.762]         {
[09:29:51.762]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.762]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.762]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.762]             })
[09:29:51.762]         }
[09:29:51.762]     }, args = future.call.arguments)
[09:29:51.762] }
[09:29:51.762] Tweak future expression to call with '...' arguments ... DONE
[09:29:51.763] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.763] - packages: [1] ‘future.apply’
[09:29:51.763] getGlobalsAndPackages() ... DONE
[09:29:51.763] run() for ‘Future’ ...
[09:29:51.763] - state: ‘created’
[09:29:51.764] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:51.779] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:51.779]   - Field: ‘node’
[09:29:51.779]   - Field: ‘label’
[09:29:51.779]   - Field: ‘local’
[09:29:51.780]   - Field: ‘owner’
[09:29:51.780]   - Field: ‘envir’
[09:29:51.780]   - Field: ‘workers’
[09:29:51.780]   - Field: ‘packages’
[09:29:51.780]   - Field: ‘gc’
[09:29:51.780]   - Field: ‘conditions’
[09:29:51.780]   - Field: ‘persistent’
[09:29:51.780]   - Field: ‘expr’
[09:29:51.780]   - Field: ‘uuid’
[09:29:51.780]   - Field: ‘seed’
[09:29:51.780]   - Field: ‘version’
[09:29:51.781]   - Field: ‘result’
[09:29:51.781]   - Field: ‘asynchronous’
[09:29:51.781]   - Field: ‘calls’
[09:29:51.781]   - Field: ‘globals’
[09:29:51.781]   - Field: ‘stdout’
[09:29:51.781]   - Field: ‘earlySignal’
[09:29:51.781]   - Field: ‘lazy’
[09:29:51.781]   - Field: ‘state’
[09:29:51.781] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:51.781] - Launch lazy future ...
[09:29:51.782] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:51.782] Packages needed by future strategies (n = 0): <none>
[09:29:51.782] {
[09:29:51.782]     {
[09:29:51.782]         {
[09:29:51.782]             ...future.startTime <- base::Sys.time()
[09:29:51.782]             {
[09:29:51.782]                 {
[09:29:51.782]                   {
[09:29:51.782]                     {
[09:29:51.782]                       {
[09:29:51.782]                         base::local({
[09:29:51.782]                           has_future <- base::requireNamespace("future", 
[09:29:51.782]                             quietly = TRUE)
[09:29:51.782]                           if (has_future) {
[09:29:51.782]                             ns <- base::getNamespace("future")
[09:29:51.782]                             version <- ns[[".package"]][["version"]]
[09:29:51.782]                             if (is.null(version)) 
[09:29:51.782]                               version <- utils::packageVersion("future")
[09:29:51.782]                           }
[09:29:51.782]                           else {
[09:29:51.782]                             version <- NULL
[09:29:51.782]                           }
[09:29:51.782]                           if (!has_future || version < "1.8.0") {
[09:29:51.782]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:51.782]                               "", base::R.version$version.string), 
[09:29:51.782]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:51.782]                                 base::R.version$platform, 8 * 
[09:29:51.782]                                   base::.Machine$sizeof.pointer), 
[09:29:51.782]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:51.782]                                 "release", "version")], collapse = " "), 
[09:29:51.782]                               hostname = base::Sys.info()[["nodename"]])
[09:29:51.782]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:51.782]                               info)
[09:29:51.782]                             info <- base::paste(info, collapse = "; ")
[09:29:51.782]                             if (!has_future) {
[09:29:51.782]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:51.782]                                 info)
[09:29:51.782]                             }
[09:29:51.782]                             else {
[09:29:51.782]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:51.782]                                 info, version)
[09:29:51.782]                             }
[09:29:51.782]                             base::stop(msg)
[09:29:51.782]                           }
[09:29:51.782]                         })
[09:29:51.782]                       }
[09:29:51.782]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:51.782]                       base::options(mc.cores = 1L)
[09:29:51.782]                     }
[09:29:51.782]                     base::local({
[09:29:51.782]                       for (pkg in "future.apply") {
[09:29:51.782]                         base::loadNamespace(pkg)
[09:29:51.782]                         base::library(pkg, character.only = TRUE)
[09:29:51.782]                       }
[09:29:51.782]                     })
[09:29:51.782]                   }
[09:29:51.782]                   ...future.strategy.old <- future::plan("list")
[09:29:51.782]                   options(future.plan = NULL)
[09:29:51.782]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.782]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:51.782]                 }
[09:29:51.782]                 ...future.workdir <- getwd()
[09:29:51.782]             }
[09:29:51.782]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:51.782]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:51.782]         }
[09:29:51.782]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:51.782]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:51.782]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:51.782]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:51.782]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:51.782]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:51.782]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:51.782]             base::names(...future.oldOptions))
[09:29:51.782]     }
[09:29:51.782]     if (FALSE) {
[09:29:51.782]     }
[09:29:51.782]     else {
[09:29:51.782]         if (TRUE) {
[09:29:51.782]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:51.782]                 open = "w")
[09:29:51.782]         }
[09:29:51.782]         else {
[09:29:51.782]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:51.782]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:51.782]         }
[09:29:51.782]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:51.782]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:51.782]             base::sink(type = "output", split = FALSE)
[09:29:51.782]             base::close(...future.stdout)
[09:29:51.782]         }, add = TRUE)
[09:29:51.782]     }
[09:29:51.782]     ...future.frame <- base::sys.nframe()
[09:29:51.782]     ...future.conditions <- base::list()
[09:29:51.782]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:51.782]     if (FALSE) {
[09:29:51.782]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:51.782]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:51.782]     }
[09:29:51.782]     ...future.result <- base::tryCatch({
[09:29:51.782]         base::withCallingHandlers({
[09:29:51.782]             ...future.value <- base::withVisible(base::local({
[09:29:51.782]                 ...future.makeSendCondition <- base::local({
[09:29:51.782]                   sendCondition <- NULL
[09:29:51.782]                   function(frame = 1L) {
[09:29:51.782]                     if (is.function(sendCondition)) 
[09:29:51.782]                       return(sendCondition)
[09:29:51.782]                     ns <- getNamespace("parallel")
[09:29:51.782]                     if (exists("sendData", mode = "function", 
[09:29:51.782]                       envir = ns)) {
[09:29:51.782]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:51.782]                         envir = ns)
[09:29:51.782]                       envir <- sys.frame(frame)
[09:29:51.782]                       master <- NULL
[09:29:51.782]                       while (!identical(envir, .GlobalEnv) && 
[09:29:51.782]                         !identical(envir, emptyenv())) {
[09:29:51.782]                         if (exists("master", mode = "list", envir = envir, 
[09:29:51.782]                           inherits = FALSE)) {
[09:29:51.782]                           master <- get("master", mode = "list", 
[09:29:51.782]                             envir = envir, inherits = FALSE)
[09:29:51.782]                           if (inherits(master, c("SOCKnode", 
[09:29:51.782]                             "SOCK0node"))) {
[09:29:51.782]                             sendCondition <<- function(cond) {
[09:29:51.782]                               data <- list(type = "VALUE", value = cond, 
[09:29:51.782]                                 success = TRUE)
[09:29:51.782]                               parallel_sendData(master, data)
[09:29:51.782]                             }
[09:29:51.782]                             return(sendCondition)
[09:29:51.782]                           }
[09:29:51.782]                         }
[09:29:51.782]                         frame <- frame + 1L
[09:29:51.782]                         envir <- sys.frame(frame)
[09:29:51.782]                       }
[09:29:51.782]                     }
[09:29:51.782]                     sendCondition <<- function(cond) NULL
[09:29:51.782]                   }
[09:29:51.782]                 })
[09:29:51.782]                 withCallingHandlers({
[09:29:51.782]                   {
[09:29:51.782]                     do.call(function(...) {
[09:29:51.782]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.782]                       if (!identical(...future.globals.maxSize.org, 
[09:29:51.782]                         ...future.globals.maxSize)) {
[09:29:51.782]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.782]                         on.exit(options(oopts), add = TRUE)
[09:29:51.782]                       }
[09:29:51.782]                       {
[09:29:51.782]                         lapply(seq_along(...future.elements_ii), 
[09:29:51.782]                           FUN = function(jj) {
[09:29:51.782]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.782]                             ...future.FUN(...future.X_jj, ...)
[09:29:51.782]                           })
[09:29:51.782]                       }
[09:29:51.782]                     }, args = future.call.arguments)
[09:29:51.782]                   }
[09:29:51.782]                 }, immediateCondition = function(cond) {
[09:29:51.782]                   sendCondition <- ...future.makeSendCondition()
[09:29:51.782]                   sendCondition(cond)
[09:29:51.782]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.782]                   {
[09:29:51.782]                     inherits <- base::inherits
[09:29:51.782]                     invokeRestart <- base::invokeRestart
[09:29:51.782]                     is.null <- base::is.null
[09:29:51.782]                     muffled <- FALSE
[09:29:51.782]                     if (inherits(cond, "message")) {
[09:29:51.782]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:51.782]                       if (muffled) 
[09:29:51.782]                         invokeRestart("muffleMessage")
[09:29:51.782]                     }
[09:29:51.782]                     else if (inherits(cond, "warning")) {
[09:29:51.782]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:51.782]                       if (muffled) 
[09:29:51.782]                         invokeRestart("muffleWarning")
[09:29:51.782]                     }
[09:29:51.782]                     else if (inherits(cond, "condition")) {
[09:29:51.782]                       if (!is.null(pattern)) {
[09:29:51.782]                         computeRestarts <- base::computeRestarts
[09:29:51.782]                         grepl <- base::grepl
[09:29:51.782]                         restarts <- computeRestarts(cond)
[09:29:51.782]                         for (restart in restarts) {
[09:29:51.782]                           name <- restart$name
[09:29:51.782]                           if (is.null(name)) 
[09:29:51.782]                             next
[09:29:51.782]                           if (!grepl(pattern, name)) 
[09:29:51.782]                             next
[09:29:51.782]                           invokeRestart(restart)
[09:29:51.782]                           muffled <- TRUE
[09:29:51.782]                           break
[09:29:51.782]                         }
[09:29:51.782]                       }
[09:29:51.782]                     }
[09:29:51.782]                     invisible(muffled)
[09:29:51.782]                   }
[09:29:51.782]                   muffleCondition(cond)
[09:29:51.782]                 })
[09:29:51.782]             }))
[09:29:51.782]             future::FutureResult(value = ...future.value$value, 
[09:29:51.782]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.782]                   ...future.rng), globalenv = if (FALSE) 
[09:29:51.782]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:51.782]                     ...future.globalenv.names))
[09:29:51.782]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:51.782]         }, condition = base::local({
[09:29:51.782]             c <- base::c
[09:29:51.782]             inherits <- base::inherits
[09:29:51.782]             invokeRestart <- base::invokeRestart
[09:29:51.782]             length <- base::length
[09:29:51.782]             list <- base::list
[09:29:51.782]             seq.int <- base::seq.int
[09:29:51.782]             signalCondition <- base::signalCondition
[09:29:51.782]             sys.calls <- base::sys.calls
[09:29:51.782]             `[[` <- base::`[[`
[09:29:51.782]             `+` <- base::`+`
[09:29:51.782]             `<<-` <- base::`<<-`
[09:29:51.782]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:51.782]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:51.782]                   3L)]
[09:29:51.782]             }
[09:29:51.782]             function(cond) {
[09:29:51.782]                 is_error <- inherits(cond, "error")
[09:29:51.782]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:51.782]                   NULL)
[09:29:51.782]                 if (is_error) {
[09:29:51.782]                   sessionInformation <- function() {
[09:29:51.782]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:51.782]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:51.782]                       search = base::search(), system = base::Sys.info())
[09:29:51.782]                   }
[09:29:51.782]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.782]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:51.782]                     cond$call), session = sessionInformation(), 
[09:29:51.782]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:51.782]                   signalCondition(cond)
[09:29:51.782]                 }
[09:29:51.782]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:51.782]                 "immediateCondition"))) {
[09:29:51.782]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:51.782]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.782]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:51.782]                   if (TRUE && !signal) {
[09:29:51.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.782]                     {
[09:29:51.782]                       inherits <- base::inherits
[09:29:51.782]                       invokeRestart <- base::invokeRestart
[09:29:51.782]                       is.null <- base::is.null
[09:29:51.782]                       muffled <- FALSE
[09:29:51.782]                       if (inherits(cond, "message")) {
[09:29:51.782]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.782]                         if (muffled) 
[09:29:51.782]                           invokeRestart("muffleMessage")
[09:29:51.782]                       }
[09:29:51.782]                       else if (inherits(cond, "warning")) {
[09:29:51.782]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.782]                         if (muffled) 
[09:29:51.782]                           invokeRestart("muffleWarning")
[09:29:51.782]                       }
[09:29:51.782]                       else if (inherits(cond, "condition")) {
[09:29:51.782]                         if (!is.null(pattern)) {
[09:29:51.782]                           computeRestarts <- base::computeRestarts
[09:29:51.782]                           grepl <- base::grepl
[09:29:51.782]                           restarts <- computeRestarts(cond)
[09:29:51.782]                           for (restart in restarts) {
[09:29:51.782]                             name <- restart$name
[09:29:51.782]                             if (is.null(name)) 
[09:29:51.782]                               next
[09:29:51.782]                             if (!grepl(pattern, name)) 
[09:29:51.782]                               next
[09:29:51.782]                             invokeRestart(restart)
[09:29:51.782]                             muffled <- TRUE
[09:29:51.782]                             break
[09:29:51.782]                           }
[09:29:51.782]                         }
[09:29:51.782]                       }
[09:29:51.782]                       invisible(muffled)
[09:29:51.782]                     }
[09:29:51.782]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.782]                   }
[09:29:51.782]                 }
[09:29:51.782]                 else {
[09:29:51.782]                   if (TRUE) {
[09:29:51.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.782]                     {
[09:29:51.782]                       inherits <- base::inherits
[09:29:51.782]                       invokeRestart <- base::invokeRestart
[09:29:51.782]                       is.null <- base::is.null
[09:29:51.782]                       muffled <- FALSE
[09:29:51.782]                       if (inherits(cond, "message")) {
[09:29:51.782]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.782]                         if (muffled) 
[09:29:51.782]                           invokeRestart("muffleMessage")
[09:29:51.782]                       }
[09:29:51.782]                       else if (inherits(cond, "warning")) {
[09:29:51.782]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.782]                         if (muffled) 
[09:29:51.782]                           invokeRestart("muffleWarning")
[09:29:51.782]                       }
[09:29:51.782]                       else if (inherits(cond, "condition")) {
[09:29:51.782]                         if (!is.null(pattern)) {
[09:29:51.782]                           computeRestarts <- base::computeRestarts
[09:29:51.782]                           grepl <- base::grepl
[09:29:51.782]                           restarts <- computeRestarts(cond)
[09:29:51.782]                           for (restart in restarts) {
[09:29:51.782]                             name <- restart$name
[09:29:51.782]                             if (is.null(name)) 
[09:29:51.782]                               next
[09:29:51.782]                             if (!grepl(pattern, name)) 
[09:29:51.782]                               next
[09:29:51.782]                             invokeRestart(restart)
[09:29:51.782]                             muffled <- TRUE
[09:29:51.782]                             break
[09:29:51.782]                           }
[09:29:51.782]                         }
[09:29:51.782]                       }
[09:29:51.782]                       invisible(muffled)
[09:29:51.782]                     }
[09:29:51.782]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.782]                   }
[09:29:51.782]                 }
[09:29:51.782]             }
[09:29:51.782]         }))
[09:29:51.782]     }, error = function(ex) {
[09:29:51.782]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:51.782]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.782]                 ...future.rng), started = ...future.startTime, 
[09:29:51.782]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:51.782]             version = "1.8"), class = "FutureResult")
[09:29:51.782]     }, finally = {
[09:29:51.782]         if (!identical(...future.workdir, getwd())) 
[09:29:51.782]             setwd(...future.workdir)
[09:29:51.782]         {
[09:29:51.782]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:51.782]                 ...future.oldOptions$nwarnings <- NULL
[09:29:51.782]             }
[09:29:51.782]             base::options(...future.oldOptions)
[09:29:51.782]             if (.Platform$OS.type == "windows") {
[09:29:51.782]                 old_names <- names(...future.oldEnvVars)
[09:29:51.782]                 envs <- base::Sys.getenv()
[09:29:51.782]                 names <- names(envs)
[09:29:51.782]                 common <- intersect(names, old_names)
[09:29:51.782]                 added <- setdiff(names, old_names)
[09:29:51.782]                 removed <- setdiff(old_names, names)
[09:29:51.782]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:51.782]                   envs[common]]
[09:29:51.782]                 NAMES <- toupper(changed)
[09:29:51.782]                 args <- list()
[09:29:51.782]                 for (kk in seq_along(NAMES)) {
[09:29:51.782]                   name <- changed[[kk]]
[09:29:51.782]                   NAME <- NAMES[[kk]]
[09:29:51.782]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.782]                     next
[09:29:51.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.782]                 }
[09:29:51.782]                 NAMES <- toupper(added)
[09:29:51.782]                 for (kk in seq_along(NAMES)) {
[09:29:51.782]                   name <- added[[kk]]
[09:29:51.782]                   NAME <- NAMES[[kk]]
[09:29:51.782]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.782]                     next
[09:29:51.782]                   args[[name]] <- ""
[09:29:51.782]                 }
[09:29:51.782]                 NAMES <- toupper(removed)
[09:29:51.782]                 for (kk in seq_along(NAMES)) {
[09:29:51.782]                   name <- removed[[kk]]
[09:29:51.782]                   NAME <- NAMES[[kk]]
[09:29:51.782]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.782]                     next
[09:29:51.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.782]                 }
[09:29:51.782]                 if (length(args) > 0) 
[09:29:51.782]                   base::do.call(base::Sys.setenv, args = args)
[09:29:51.782]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:51.782]             }
[09:29:51.782]             else {
[09:29:51.782]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:51.782]             }
[09:29:51.782]             {
[09:29:51.782]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:51.782]                   0L) {
[09:29:51.782]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:51.782]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:51.782]                   base::options(opts)
[09:29:51.782]                 }
[09:29:51.782]                 {
[09:29:51.782]                   {
[09:29:51.782]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:51.782]                     NULL
[09:29:51.782]                   }
[09:29:51.782]                   options(future.plan = NULL)
[09:29:51.782]                   if (is.na(NA_character_)) 
[09:29:51.782]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.782]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:51.782]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:51.782]                     .init = FALSE)
[09:29:51.782]                 }
[09:29:51.782]             }
[09:29:51.782]         }
[09:29:51.782]     })
[09:29:51.782]     if (TRUE) {
[09:29:51.782]         base::sink(type = "output", split = FALSE)
[09:29:51.782]         if (TRUE) {
[09:29:51.782]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:51.782]         }
[09:29:51.782]         else {
[09:29:51.782]             ...future.result["stdout"] <- base::list(NULL)
[09:29:51.782]         }
[09:29:51.782]         base::close(...future.stdout)
[09:29:51.782]         ...future.stdout <- NULL
[09:29:51.782]     }
[09:29:51.782]     ...future.result$conditions <- ...future.conditions
[09:29:51.782]     ...future.result$finished <- base::Sys.time()
[09:29:51.782]     ...future.result
[09:29:51.782] }
[09:29:51.785] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[09:29:51.785] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:51.828] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:51.828] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[09:29:51.829] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[09:29:51.829] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:51.829] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:51.829] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:51.872] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:51.872] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:51.916] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:51.916] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[09:29:51.917] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[09:29:51.917] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:51.917] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:51.917] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:51.918] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.918] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:51.918] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:51.918] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:51.919] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.919] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:51.919] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:51.919] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[09:29:51.920] MultisessionFuture started
[09:29:51.920] - Launch lazy future ... done
[09:29:51.920] run() for ‘MultisessionFuture’ ... done
[09:29:51.920] Created future:
[09:29:51.922] receiveMessageFromWorker() for ClusterFuture ...
[09:29:51.922] - Validating connection of MultisessionFuture
[09:29:51.922] - received message: FutureResult
[09:29:51.922] - Received FutureResult
[09:29:51.922] - Erased future from FutureRegistry
[09:29:51.922] result() for ClusterFuture ...
[09:29:51.922] - result already collected: FutureResult
[09:29:51.922] result() for ClusterFuture ... done
[09:29:51.923] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:51.920] MultisessionFuture:
[09:29:51.920] Label: ‘future_vapply-1’
[09:29:51.920] Expression:
[09:29:51.920] {
[09:29:51.920]     do.call(function(...) {
[09:29:51.920]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.920]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.920]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.920]             on.exit(options(oopts), add = TRUE)
[09:29:51.920]         }
[09:29:51.920]         {
[09:29:51.920]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.920]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.920]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.920]             })
[09:29:51.920]         }
[09:29:51.920]     }, args = future.call.arguments)
[09:29:51.920] }
[09:29:51.920] Lazy evaluation: FALSE
[09:29:51.920] Asynchronous evaluation: TRUE
[09:29:51.920] Local evaluation: TRUE
[09:29:51.920] Environment: R_GlobalEnv
[09:29:51.920] Capture standard output: TRUE
[09:29:51.920] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:51.920] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:51.920] Packages: 1 packages (‘future.apply’)
[09:29:51.920] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:51.920] Resolved: TRUE
[09:29:51.920] Value: <not collected>
[09:29:51.920] Conditions captured: <none>
[09:29:51.920] Early signaling: FALSE
[09:29:51.920] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:51.920] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.923] Chunk #1 of 2 ... DONE
[09:29:51.923] Chunk #2 of 2 ...
[09:29:51.923]  - Finding globals in 'X' for chunk #2 ...
[09:29:51.923] getGlobalsAndPackages() ...
[09:29:51.923] Searching for globals...
[09:29:51.923] 
[09:29:51.924] Searching for globals ... DONE
[09:29:51.924] - globals: [0] <none>
[09:29:51.924] getGlobalsAndPackages() ... DONE
[09:29:51.924]    + additional globals found: [n=0] 
[09:29:51.924]    + additional namespaces needed: [n=0] 
[09:29:51.924]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:51.924]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:51.924]  - seeds: <none>
[09:29:51.924]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.924] getGlobalsAndPackages() ...
[09:29:51.924] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.925] Resolving globals: FALSE
[09:29:51.925] Tweak future expression to call with '...' arguments ...
[09:29:51.925] {
[09:29:51.925]     do.call(function(...) {
[09:29:51.925]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.925]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:51.925]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.925]             on.exit(options(oopts), add = TRUE)
[09:29:51.925]         }
[09:29:51.925]         {
[09:29:51.925]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:51.925]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.925]                 ...future.FUN(...future.X_jj, ...)
[09:29:51.925]             })
[09:29:51.925]         }
[09:29:51.925]     }, args = future.call.arguments)
[09:29:51.925] }
[09:29:51.925] Tweak future expression to call with '...' arguments ... DONE
[09:29:51.926] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:51.926] - packages: [1] ‘future.apply’
[09:29:51.926] getGlobalsAndPackages() ... DONE
[09:29:51.926] run() for ‘Future’ ...
[09:29:51.926] - state: ‘created’
[09:29:51.926] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:51.940] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:51.941] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:51.941]   - Field: ‘node’
[09:29:51.941]   - Field: ‘label’
[09:29:51.941]   - Field: ‘local’
[09:29:51.941]   - Field: ‘owner’
[09:29:51.941]   - Field: ‘envir’
[09:29:51.941]   - Field: ‘workers’
[09:29:51.941]   - Field: ‘packages’
[09:29:51.941]   - Field: ‘gc’
[09:29:51.941]   - Field: ‘conditions’
[09:29:51.942]   - Field: ‘persistent’
[09:29:51.942]   - Field: ‘expr’
[09:29:51.942]   - Field: ‘uuid’
[09:29:51.942]   - Field: ‘seed’
[09:29:51.942]   - Field: ‘version’
[09:29:51.942]   - Field: ‘result’
[09:29:51.942]   - Field: ‘asynchronous’
[09:29:51.942]   - Field: ‘calls’
[09:29:51.942]   - Field: ‘globals’
[09:29:51.942]   - Field: ‘stdout’
[09:29:51.942]   - Field: ‘earlySignal’
[09:29:51.943]   - Field: ‘lazy’
[09:29:51.943]   - Field: ‘state’
[09:29:51.943] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:51.943] - Launch lazy future ...
[09:29:51.943] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:51.943] Packages needed by future strategies (n = 0): <none>
[09:29:51.944] {
[09:29:51.944]     {
[09:29:51.944]         {
[09:29:51.944]             ...future.startTime <- base::Sys.time()
[09:29:51.944]             {
[09:29:51.944]                 {
[09:29:51.944]                   {
[09:29:51.944]                     {
[09:29:51.944]                       {
[09:29:51.944]                         base::local({
[09:29:51.944]                           has_future <- base::requireNamespace("future", 
[09:29:51.944]                             quietly = TRUE)
[09:29:51.944]                           if (has_future) {
[09:29:51.944]                             ns <- base::getNamespace("future")
[09:29:51.944]                             version <- ns[[".package"]][["version"]]
[09:29:51.944]                             if (is.null(version)) 
[09:29:51.944]                               version <- utils::packageVersion("future")
[09:29:51.944]                           }
[09:29:51.944]                           else {
[09:29:51.944]                             version <- NULL
[09:29:51.944]                           }
[09:29:51.944]                           if (!has_future || version < "1.8.0") {
[09:29:51.944]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:51.944]                               "", base::R.version$version.string), 
[09:29:51.944]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:51.944]                                 base::R.version$platform, 8 * 
[09:29:51.944]                                   base::.Machine$sizeof.pointer), 
[09:29:51.944]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:51.944]                                 "release", "version")], collapse = " "), 
[09:29:51.944]                               hostname = base::Sys.info()[["nodename"]])
[09:29:51.944]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:51.944]                               info)
[09:29:51.944]                             info <- base::paste(info, collapse = "; ")
[09:29:51.944]                             if (!has_future) {
[09:29:51.944]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:51.944]                                 info)
[09:29:51.944]                             }
[09:29:51.944]                             else {
[09:29:51.944]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:51.944]                                 info, version)
[09:29:51.944]                             }
[09:29:51.944]                             base::stop(msg)
[09:29:51.944]                           }
[09:29:51.944]                         })
[09:29:51.944]                       }
[09:29:51.944]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:51.944]                       base::options(mc.cores = 1L)
[09:29:51.944]                     }
[09:29:51.944]                     base::local({
[09:29:51.944]                       for (pkg in "future.apply") {
[09:29:51.944]                         base::loadNamespace(pkg)
[09:29:51.944]                         base::library(pkg, character.only = TRUE)
[09:29:51.944]                       }
[09:29:51.944]                     })
[09:29:51.944]                   }
[09:29:51.944]                   ...future.strategy.old <- future::plan("list")
[09:29:51.944]                   options(future.plan = NULL)
[09:29:51.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:51.944]                 }
[09:29:51.944]                 ...future.workdir <- getwd()
[09:29:51.944]             }
[09:29:51.944]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:51.944]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:51.944]         }
[09:29:51.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:51.944]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:51.944]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:51.944]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:51.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:51.944]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:51.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:51.944]             base::names(...future.oldOptions))
[09:29:51.944]     }
[09:29:51.944]     if (FALSE) {
[09:29:51.944]     }
[09:29:51.944]     else {
[09:29:51.944]         if (TRUE) {
[09:29:51.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:51.944]                 open = "w")
[09:29:51.944]         }
[09:29:51.944]         else {
[09:29:51.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:51.944]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:51.944]         }
[09:29:51.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:51.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:51.944]             base::sink(type = "output", split = FALSE)
[09:29:51.944]             base::close(...future.stdout)
[09:29:51.944]         }, add = TRUE)
[09:29:51.944]     }
[09:29:51.944]     ...future.frame <- base::sys.nframe()
[09:29:51.944]     ...future.conditions <- base::list()
[09:29:51.944]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:51.944]     if (FALSE) {
[09:29:51.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:51.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:51.944]     }
[09:29:51.944]     ...future.result <- base::tryCatch({
[09:29:51.944]         base::withCallingHandlers({
[09:29:51.944]             ...future.value <- base::withVisible(base::local({
[09:29:51.944]                 ...future.makeSendCondition <- base::local({
[09:29:51.944]                   sendCondition <- NULL
[09:29:51.944]                   function(frame = 1L) {
[09:29:51.944]                     if (is.function(sendCondition)) 
[09:29:51.944]                       return(sendCondition)
[09:29:51.944]                     ns <- getNamespace("parallel")
[09:29:51.944]                     if (exists("sendData", mode = "function", 
[09:29:51.944]                       envir = ns)) {
[09:29:51.944]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:51.944]                         envir = ns)
[09:29:51.944]                       envir <- sys.frame(frame)
[09:29:51.944]                       master <- NULL
[09:29:51.944]                       while (!identical(envir, .GlobalEnv) && 
[09:29:51.944]                         !identical(envir, emptyenv())) {
[09:29:51.944]                         if (exists("master", mode = "list", envir = envir, 
[09:29:51.944]                           inherits = FALSE)) {
[09:29:51.944]                           master <- get("master", mode = "list", 
[09:29:51.944]                             envir = envir, inherits = FALSE)
[09:29:51.944]                           if (inherits(master, c("SOCKnode", 
[09:29:51.944]                             "SOCK0node"))) {
[09:29:51.944]                             sendCondition <<- function(cond) {
[09:29:51.944]                               data <- list(type = "VALUE", value = cond, 
[09:29:51.944]                                 success = TRUE)
[09:29:51.944]                               parallel_sendData(master, data)
[09:29:51.944]                             }
[09:29:51.944]                             return(sendCondition)
[09:29:51.944]                           }
[09:29:51.944]                         }
[09:29:51.944]                         frame <- frame + 1L
[09:29:51.944]                         envir <- sys.frame(frame)
[09:29:51.944]                       }
[09:29:51.944]                     }
[09:29:51.944]                     sendCondition <<- function(cond) NULL
[09:29:51.944]                   }
[09:29:51.944]                 })
[09:29:51.944]                 withCallingHandlers({
[09:29:51.944]                   {
[09:29:51.944]                     do.call(function(...) {
[09:29:51.944]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:51.944]                       if (!identical(...future.globals.maxSize.org, 
[09:29:51.944]                         ...future.globals.maxSize)) {
[09:29:51.944]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:51.944]                         on.exit(options(oopts), add = TRUE)
[09:29:51.944]                       }
[09:29:51.944]                       {
[09:29:51.944]                         lapply(seq_along(...future.elements_ii), 
[09:29:51.944]                           FUN = function(jj) {
[09:29:51.944]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:51.944]                             ...future.FUN(...future.X_jj, ...)
[09:29:51.944]                           })
[09:29:51.944]                       }
[09:29:51.944]                     }, args = future.call.arguments)
[09:29:51.944]                   }
[09:29:51.944]                 }, immediateCondition = function(cond) {
[09:29:51.944]                   sendCondition <- ...future.makeSendCondition()
[09:29:51.944]                   sendCondition(cond)
[09:29:51.944]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.944]                   {
[09:29:51.944]                     inherits <- base::inherits
[09:29:51.944]                     invokeRestart <- base::invokeRestart
[09:29:51.944]                     is.null <- base::is.null
[09:29:51.944]                     muffled <- FALSE
[09:29:51.944]                     if (inherits(cond, "message")) {
[09:29:51.944]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:51.944]                       if (muffled) 
[09:29:51.944]                         invokeRestart("muffleMessage")
[09:29:51.944]                     }
[09:29:51.944]                     else if (inherits(cond, "warning")) {
[09:29:51.944]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:51.944]                       if (muffled) 
[09:29:51.944]                         invokeRestart("muffleWarning")
[09:29:51.944]                     }
[09:29:51.944]                     else if (inherits(cond, "condition")) {
[09:29:51.944]                       if (!is.null(pattern)) {
[09:29:51.944]                         computeRestarts <- base::computeRestarts
[09:29:51.944]                         grepl <- base::grepl
[09:29:51.944]                         restarts <- computeRestarts(cond)
[09:29:51.944]                         for (restart in restarts) {
[09:29:51.944]                           name <- restart$name
[09:29:51.944]                           if (is.null(name)) 
[09:29:51.944]                             next
[09:29:51.944]                           if (!grepl(pattern, name)) 
[09:29:51.944]                             next
[09:29:51.944]                           invokeRestart(restart)
[09:29:51.944]                           muffled <- TRUE
[09:29:51.944]                           break
[09:29:51.944]                         }
[09:29:51.944]                       }
[09:29:51.944]                     }
[09:29:51.944]                     invisible(muffled)
[09:29:51.944]                   }
[09:29:51.944]                   muffleCondition(cond)
[09:29:51.944]                 })
[09:29:51.944]             }))
[09:29:51.944]             future::FutureResult(value = ...future.value$value, 
[09:29:51.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.944]                   ...future.rng), globalenv = if (FALSE) 
[09:29:51.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:51.944]                     ...future.globalenv.names))
[09:29:51.944]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:51.944]         }, condition = base::local({
[09:29:51.944]             c <- base::c
[09:29:51.944]             inherits <- base::inherits
[09:29:51.944]             invokeRestart <- base::invokeRestart
[09:29:51.944]             length <- base::length
[09:29:51.944]             list <- base::list
[09:29:51.944]             seq.int <- base::seq.int
[09:29:51.944]             signalCondition <- base::signalCondition
[09:29:51.944]             sys.calls <- base::sys.calls
[09:29:51.944]             `[[` <- base::`[[`
[09:29:51.944]             `+` <- base::`+`
[09:29:51.944]             `<<-` <- base::`<<-`
[09:29:51.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:51.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:51.944]                   3L)]
[09:29:51.944]             }
[09:29:51.944]             function(cond) {
[09:29:51.944]                 is_error <- inherits(cond, "error")
[09:29:51.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:51.944]                   NULL)
[09:29:51.944]                 if (is_error) {
[09:29:51.944]                   sessionInformation <- function() {
[09:29:51.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:51.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:51.944]                       search = base::search(), system = base::Sys.info())
[09:29:51.944]                   }
[09:29:51.944]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:51.944]                     cond$call), session = sessionInformation(), 
[09:29:51.944]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:51.944]                   signalCondition(cond)
[09:29:51.944]                 }
[09:29:51.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:51.944]                 "immediateCondition"))) {
[09:29:51.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:51.944]                   ...future.conditions[[length(...future.conditions) + 
[09:29:51.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:51.944]                   if (TRUE && !signal) {
[09:29:51.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.944]                     {
[09:29:51.944]                       inherits <- base::inherits
[09:29:51.944]                       invokeRestart <- base::invokeRestart
[09:29:51.944]                       is.null <- base::is.null
[09:29:51.944]                       muffled <- FALSE
[09:29:51.944]                       if (inherits(cond, "message")) {
[09:29:51.944]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.944]                         if (muffled) 
[09:29:51.944]                           invokeRestart("muffleMessage")
[09:29:51.944]                       }
[09:29:51.944]                       else if (inherits(cond, "warning")) {
[09:29:51.944]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.944]                         if (muffled) 
[09:29:51.944]                           invokeRestart("muffleWarning")
[09:29:51.944]                       }
[09:29:51.944]                       else if (inherits(cond, "condition")) {
[09:29:51.944]                         if (!is.null(pattern)) {
[09:29:51.944]                           computeRestarts <- base::computeRestarts
[09:29:51.944]                           grepl <- base::grepl
[09:29:51.944]                           restarts <- computeRestarts(cond)
[09:29:51.944]                           for (restart in restarts) {
[09:29:51.944]                             name <- restart$name
[09:29:51.944]                             if (is.null(name)) 
[09:29:51.944]                               next
[09:29:51.944]                             if (!grepl(pattern, name)) 
[09:29:51.944]                               next
[09:29:51.944]                             invokeRestart(restart)
[09:29:51.944]                             muffled <- TRUE
[09:29:51.944]                             break
[09:29:51.944]                           }
[09:29:51.944]                         }
[09:29:51.944]                       }
[09:29:51.944]                       invisible(muffled)
[09:29:51.944]                     }
[09:29:51.944]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.944]                   }
[09:29:51.944]                 }
[09:29:51.944]                 else {
[09:29:51.944]                   if (TRUE) {
[09:29:51.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:51.944]                     {
[09:29:51.944]                       inherits <- base::inherits
[09:29:51.944]                       invokeRestart <- base::invokeRestart
[09:29:51.944]                       is.null <- base::is.null
[09:29:51.944]                       muffled <- FALSE
[09:29:51.944]                       if (inherits(cond, "message")) {
[09:29:51.944]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:51.944]                         if (muffled) 
[09:29:51.944]                           invokeRestart("muffleMessage")
[09:29:51.944]                       }
[09:29:51.944]                       else if (inherits(cond, "warning")) {
[09:29:51.944]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:51.944]                         if (muffled) 
[09:29:51.944]                           invokeRestart("muffleWarning")
[09:29:51.944]                       }
[09:29:51.944]                       else if (inherits(cond, "condition")) {
[09:29:51.944]                         if (!is.null(pattern)) {
[09:29:51.944]                           computeRestarts <- base::computeRestarts
[09:29:51.944]                           grepl <- base::grepl
[09:29:51.944]                           restarts <- computeRestarts(cond)
[09:29:51.944]                           for (restart in restarts) {
[09:29:51.944]                             name <- restart$name
[09:29:51.944]                             if (is.null(name)) 
[09:29:51.944]                               next
[09:29:51.944]                             if (!grepl(pattern, name)) 
[09:29:51.944]                               next
[09:29:51.944]                             invokeRestart(restart)
[09:29:51.944]                             muffled <- TRUE
[09:29:51.944]                             break
[09:29:51.944]                           }
[09:29:51.944]                         }
[09:29:51.944]                       }
[09:29:51.944]                       invisible(muffled)
[09:29:51.944]                     }
[09:29:51.944]                     muffleCondition(cond, pattern = "^muffle")
[09:29:51.944]                   }
[09:29:51.944]                 }
[09:29:51.944]             }
[09:29:51.944]         }))
[09:29:51.944]     }, error = function(ex) {
[09:29:51.944]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:51.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:51.944]                 ...future.rng), started = ...future.startTime, 
[09:29:51.944]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:51.944]             version = "1.8"), class = "FutureResult")
[09:29:51.944]     }, finally = {
[09:29:51.944]         if (!identical(...future.workdir, getwd())) 
[09:29:51.944]             setwd(...future.workdir)
[09:29:51.944]         {
[09:29:51.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:51.944]                 ...future.oldOptions$nwarnings <- NULL
[09:29:51.944]             }
[09:29:51.944]             base::options(...future.oldOptions)
[09:29:51.944]             if (.Platform$OS.type == "windows") {
[09:29:51.944]                 old_names <- names(...future.oldEnvVars)
[09:29:51.944]                 envs <- base::Sys.getenv()
[09:29:51.944]                 names <- names(envs)
[09:29:51.944]                 common <- intersect(names, old_names)
[09:29:51.944]                 added <- setdiff(names, old_names)
[09:29:51.944]                 removed <- setdiff(old_names, names)
[09:29:51.944]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:51.944]                   envs[common]]
[09:29:51.944]                 NAMES <- toupper(changed)
[09:29:51.944]                 args <- list()
[09:29:51.944]                 for (kk in seq_along(NAMES)) {
[09:29:51.944]                   name <- changed[[kk]]
[09:29:51.944]                   NAME <- NAMES[[kk]]
[09:29:51.944]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.944]                     next
[09:29:51.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.944]                 }
[09:29:51.944]                 NAMES <- toupper(added)
[09:29:51.944]                 for (kk in seq_along(NAMES)) {
[09:29:51.944]                   name <- added[[kk]]
[09:29:51.944]                   NAME <- NAMES[[kk]]
[09:29:51.944]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.944]                     next
[09:29:51.944]                   args[[name]] <- ""
[09:29:51.944]                 }
[09:29:51.944]                 NAMES <- toupper(removed)
[09:29:51.944]                 for (kk in seq_along(NAMES)) {
[09:29:51.944]                   name <- removed[[kk]]
[09:29:51.944]                   NAME <- NAMES[[kk]]
[09:29:51.944]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:51.944]                     next
[09:29:51.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:51.944]                 }
[09:29:51.944]                 if (length(args) > 0) 
[09:29:51.944]                   base::do.call(base::Sys.setenv, args = args)
[09:29:51.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:51.944]             }
[09:29:51.944]             else {
[09:29:51.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:51.944]             }
[09:29:51.944]             {
[09:29:51.944]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:51.944]                   0L) {
[09:29:51.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:51.944]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:51.944]                   base::options(opts)
[09:29:51.944]                 }
[09:29:51.944]                 {
[09:29:51.944]                   {
[09:29:51.944]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:51.944]                     NULL
[09:29:51.944]                   }
[09:29:51.944]                   options(future.plan = NULL)
[09:29:51.944]                   if (is.na(NA_character_)) 
[09:29:51.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:51.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:51.944]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:51.944]                     .init = FALSE)
[09:29:51.944]                 }
[09:29:51.944]             }
[09:29:51.944]         }
[09:29:51.944]     })
[09:29:51.944]     if (TRUE) {
[09:29:51.944]         base::sink(type = "output", split = FALSE)
[09:29:51.944]         if (TRUE) {
[09:29:51.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:51.944]         }
[09:29:51.944]         else {
[09:29:51.944]             ...future.result["stdout"] <- base::list(NULL)
[09:29:51.944]         }
[09:29:51.944]         base::close(...future.stdout)
[09:29:51.944]         ...future.stdout <- NULL
[09:29:51.944]     }
[09:29:51.944]     ...future.result$conditions <- ...future.conditions
[09:29:51.944]     ...future.result$finished <- base::Sys.time()
[09:29:51.944]     ...future.result
[09:29:51.944] }
[09:29:51.946] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[09:29:51.946] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:51.988] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:51.988] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[09:29:51.989] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[09:29:51.989] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:51.989] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:51.989] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:52.032] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:52.032] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:52.076] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:52.076] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[09:29:52.077] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[09:29:52.077] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:52.077] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:52.077] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:52.078] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.078] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[09:29:52.078] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[09:29:52.078] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:52.079] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.079] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:52.079] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.079] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[09:29:52.080] MultisessionFuture started
[09:29:52.080] - Launch lazy future ... done
[09:29:52.080] run() for ‘MultisessionFuture’ ... done
[09:29:52.080] Created future:
[09:29:52.081] receiveMessageFromWorker() for ClusterFuture ...
[09:29:52.081] - Validating connection of MultisessionFuture
[09:29:52.082] - received message: FutureResult
[09:29:52.082] - Received FutureResult
[09:29:52.082] - Erased future from FutureRegistry
[09:29:52.082] result() for ClusterFuture ...
[09:29:52.082] - result already collected: FutureResult
[09:29:52.082] result() for ClusterFuture ... done
[09:29:52.082] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:52.080] MultisessionFuture:
[09:29:52.080] Label: ‘future_vapply-2’
[09:29:52.080] Expression:
[09:29:52.080] {
[09:29:52.080]     do.call(function(...) {
[09:29:52.080]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.080]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.080]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.080]             on.exit(options(oopts), add = TRUE)
[09:29:52.080]         }
[09:29:52.080]         {
[09:29:52.080]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.080]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.080]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.080]             })
[09:29:52.080]         }
[09:29:52.080]     }, args = future.call.arguments)
[09:29:52.080] }
[09:29:52.080] Lazy evaluation: FALSE
[09:29:52.080] Asynchronous evaluation: TRUE
[09:29:52.080] Local evaluation: TRUE
[09:29:52.080] Environment: R_GlobalEnv
[09:29:52.080] Capture standard output: TRUE
[09:29:52.080] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:52.080] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:52.080] Packages: 1 packages (‘future.apply’)
[09:29:52.080] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:52.080] Resolved: TRUE
[09:29:52.080] Value: <not collected>
[09:29:52.080] Conditions captured: <none>
[09:29:52.080] Early signaling: FALSE
[09:29:52.080] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:52.080] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.082] Chunk #2 of 2 ... DONE
[09:29:52.083] Launching 2 futures (chunks) ... DONE
[09:29:52.083] Resolving 2 futures (chunks) ...
[09:29:52.083] resolve() on list ...
[09:29:52.083]  recursive: 0
[09:29:52.083]  length: 2
[09:29:52.083] 
[09:29:52.083] Future #1
[09:29:52.083] result() for ClusterFuture ...
[09:29:52.083] - result already collected: FutureResult
[09:29:52.083] result() for ClusterFuture ... done
[09:29:52.083] result() for ClusterFuture ...
[09:29:52.084] - result already collected: FutureResult
[09:29:52.084] result() for ClusterFuture ... done
[09:29:52.084] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:52.084] - nx: 2
[09:29:52.084] - relay: TRUE
[09:29:52.084] - stdout: TRUE
[09:29:52.084] - signal: TRUE
[09:29:52.084] - resignal: FALSE
[09:29:52.084] - force: TRUE
[09:29:52.084] - relayed: [n=2] FALSE, FALSE
[09:29:52.084] - queued futures: [n=2] FALSE, FALSE
[09:29:52.085]  - until=1
[09:29:52.085]  - relaying element #1
[09:29:52.085] result() for ClusterFuture ...
[09:29:52.085] - result already collected: FutureResult
[09:29:52.085] result() for ClusterFuture ... done
[09:29:52.085] result() for ClusterFuture ...
[09:29:52.085] - result already collected: FutureResult
[09:29:52.085] result() for ClusterFuture ... done
[09:29:52.085] result() for ClusterFuture ...
[09:29:52.085] - result already collected: FutureResult
[09:29:52.085] result() for ClusterFuture ... done
[09:29:52.085] result() for ClusterFuture ...
[09:29:52.086] - result already collected: FutureResult
[09:29:52.086] result() for ClusterFuture ... done
[09:29:52.086] - relayed: [n=2] TRUE, FALSE
[09:29:52.086] - queued futures: [n=2] TRUE, FALSE
[09:29:52.086] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:52.086]  length: 1 (resolved future 1)
[09:29:52.086] Future #2
[09:29:52.086] result() for ClusterFuture ...
[09:29:52.086] - result already collected: FutureResult
[09:29:52.087] result() for ClusterFuture ... done
[09:29:52.087] result() for ClusterFuture ...
[09:29:52.087] - result already collected: FutureResult
[09:29:52.087] result() for ClusterFuture ... done
[09:29:52.087] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:52.087] - nx: 2
[09:29:52.087] - relay: TRUE
[09:29:52.087] - stdout: TRUE
[09:29:52.087] - signal: TRUE
[09:29:52.087] - resignal: FALSE
[09:29:52.087] - force: TRUE
[09:29:52.087] - relayed: [n=2] TRUE, FALSE
[09:29:52.088] - queued futures: [n=2] TRUE, FALSE
[09:29:52.088]  - until=2
[09:29:52.088]  - relaying element #2
[09:29:52.088] result() for ClusterFuture ...
[09:29:52.088] - result already collected: FutureResult
[09:29:52.088] result() for ClusterFuture ... done
[09:29:52.088] result() for ClusterFuture ...
[09:29:52.088] - result already collected: FutureResult
[09:29:52.088] result() for ClusterFuture ... done
[09:29:52.088] result() for ClusterFuture ...
[09:29:52.088] - result already collected: FutureResult
[09:29:52.088] result() for ClusterFuture ... done
[09:29:52.089] result() for ClusterFuture ...
[09:29:52.089] - result already collected: FutureResult
[09:29:52.089] result() for ClusterFuture ... done
[09:29:52.089] - relayed: [n=2] TRUE, TRUE
[09:29:52.089] - queued futures: [n=2] TRUE, TRUE
[09:29:52.089] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:52.089]  length: 0 (resolved future 2)
[09:29:52.089] Relaying remaining futures
[09:29:52.089] signalConditionsASAP(NULL, pos=0) ...
[09:29:52.089] - nx: 2
[09:29:52.089] - relay: TRUE
[09:29:52.089] - stdout: TRUE
[09:29:52.090] - signal: TRUE
[09:29:52.090] - resignal: FALSE
[09:29:52.090] - force: TRUE
[09:29:52.090] - relayed: [n=2] TRUE, TRUE
[09:29:52.090] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:52.090] - relayed: [n=2] TRUE, TRUE
[09:29:52.090] - queued futures: [n=2] TRUE, TRUE
[09:29:52.090] signalConditionsASAP(NULL, pos=0) ... done
[09:29:52.090] resolve() on list ... DONE
[09:29:52.090] result() for ClusterFuture ...
[09:29:52.090] - result already collected: FutureResult
[09:29:52.091] result() for ClusterFuture ... done
[09:29:52.091] result() for ClusterFuture ...
[09:29:52.091] - result already collected: FutureResult
[09:29:52.091] result() for ClusterFuture ... done
[09:29:52.091] result() for ClusterFuture ...
[09:29:52.091] - result already collected: FutureResult
[09:29:52.091] result() for ClusterFuture ... done
[09:29:52.091] result() for ClusterFuture ...
[09:29:52.091] - result already collected: FutureResult
[09:29:52.091] result() for ClusterFuture ... done
[09:29:52.091]  - Number of value chunks collected: 2
[09:29:52.092] Resolving 2 futures (chunks) ... DONE
[09:29:52.092] Reducing values from 2 chunks ...
[09:29:52.092]  - Number of values collected after concatenation: 10
[09:29:52.092]  - Number of values expected: 10
[09:29:52.092] Reducing values from 2 chunks ... DONE
[09:29:52.092] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[09:29:52.094] future_lapply() ...
[09:29:52.099] Number of chunks: 2
[09:29:52.099] getGlobalsAndPackagesXApply() ...
[09:29:52.099]  - future.globals: TRUE
[09:29:52.100] getGlobalsAndPackages() ...
[09:29:52.100] Searching for globals...
[09:29:52.103] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[09:29:52.103] Searching for globals ... DONE
[09:29:52.103] Resolving globals: FALSE
[09:29:52.104] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[09:29:52.104] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:52.104] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:52.105] - packages: [2] ‘stats’, ‘future.apply’
[09:29:52.105] getGlobalsAndPackages() ... DONE
[09:29:52.105]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:52.105]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[09:29:52.105] Finding globals ... DONE
[09:29:52.105]  - use_args: TRUE
[09:29:52.105]  - Getting '...' globals ...
[09:29:52.105] resolve() on list ...
[09:29:52.106]  recursive: 0
[09:29:52.106]  length: 1
[09:29:52.106]  elements: ‘...’
[09:29:52.106]  length: 0 (resolved future 1)
[09:29:52.106] resolve() on list ... DONE
[09:29:52.106]    - '...' content: [n=0] 
[09:29:52.106] List of 1
[09:29:52.106]  $ ...: list()
[09:29:52.106]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:52.106]  - attr(*, "where")=List of 1
[09:29:52.106]   ..$ ...:<environment: 0x561d38694930> 
[09:29:52.106]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:52.106]  - attr(*, "resolved")= logi TRUE
[09:29:52.106]  - attr(*, "total_size")= num NA
[09:29:52.108]  - Getting '...' globals ... DONE
[09:29:52.109] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:52.109] List of 8
[09:29:52.109]  $ ...future.FUN:function (x, ...)  
[09:29:52.109]  $ x_FUN        :function (x, ...)  
[09:29:52.109]  $ times        : int 5
[09:29:52.109]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:52.109]  $ stop_if_not  :function (...)  
[09:29:52.109]  $ dim          : NULL
[09:29:52.109]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:52.109]  $ ...          : list()
[09:29:52.109]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:52.109]  - attr(*, "where")=List of 8
[09:29:52.109]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:52.109]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:52.109]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:52.109]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:52.109]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:52.109]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:52.109]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:52.109]   ..$ ...          :<environment: 0x561d38694930> 
[09:29:52.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:52.109]  - attr(*, "resolved")= logi FALSE
[09:29:52.109]  - attr(*, "total_size")= num 95528
[09:29:52.114] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[09:29:52.114] getGlobalsAndPackagesXApply() ... DONE
[09:29:52.114] Number of futures (= number of chunks): 2
[09:29:52.114] Launching 2 futures (chunks) ...
[09:29:52.114] Chunk #1 of 2 ...
[09:29:52.115]  - Finding globals in 'X' for chunk #1 ...
[09:29:52.115] getGlobalsAndPackages() ...
[09:29:52.115] Searching for globals...
[09:29:52.115] 
[09:29:52.115] Searching for globals ... DONE
[09:29:52.115] - globals: [0] <none>
[09:29:52.115] getGlobalsAndPackages() ... DONE
[09:29:52.115]    + additional globals found: [n=0] 
[09:29:52.115]    + additional namespaces needed: [n=0] 
[09:29:52.115]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:52.116]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:52.116]  - seeds: <none>
[09:29:52.116]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.116] getGlobalsAndPackages() ...
[09:29:52.116] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.116] Resolving globals: FALSE
[09:29:52.116] Tweak future expression to call with '...' arguments ...
[09:29:52.116] {
[09:29:52.116]     do.call(function(...) {
[09:29:52.116]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.116]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.116]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.116]             on.exit(options(oopts), add = TRUE)
[09:29:52.116]         }
[09:29:52.116]         {
[09:29:52.116]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.116]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.116]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.116]             })
[09:29:52.116]         }
[09:29:52.116]     }, args = future.call.arguments)
[09:29:52.116] }
[09:29:52.117] Tweak future expression to call with '...' arguments ... DONE
[09:29:52.117] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.117] - packages: [2] ‘stats’, ‘future.apply’
[09:29:52.117] getGlobalsAndPackages() ... DONE
[09:29:52.117] run() for ‘Future’ ...
[09:29:52.118] - state: ‘created’
[09:29:52.118] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:52.131] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:52.132]   - Field: ‘node’
[09:29:52.132]   - Field: ‘label’
[09:29:52.132]   - Field: ‘local’
[09:29:52.132]   - Field: ‘owner’
[09:29:52.132]   - Field: ‘envir’
[09:29:52.132]   - Field: ‘workers’
[09:29:52.132]   - Field: ‘packages’
[09:29:52.134]   - Field: ‘gc’
[09:29:52.134]   - Field: ‘conditions’
[09:29:52.134]   - Field: ‘persistent’
[09:29:52.135]   - Field: ‘expr’
[09:29:52.135]   - Field: ‘uuid’
[09:29:52.135]   - Field: ‘seed’
[09:29:52.135]   - Field: ‘version’
[09:29:52.135]   - Field: ‘result’
[09:29:52.135]   - Field: ‘asynchronous’
[09:29:52.135]   - Field: ‘calls’
[09:29:52.135]   - Field: ‘globals’
[09:29:52.135]   - Field: ‘stdout’
[09:29:52.135]   - Field: ‘earlySignal’
[09:29:52.135]   - Field: ‘lazy’
[09:29:52.135]   - Field: ‘state’
[09:29:52.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:52.136] - Launch lazy future ...
[09:29:52.136] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[09:29:52.136] Packages needed by future strategies (n = 0): <none>
[09:29:52.137] {
[09:29:52.137]     {
[09:29:52.137]         {
[09:29:52.137]             ...future.startTime <- base::Sys.time()
[09:29:52.137]             {
[09:29:52.137]                 {
[09:29:52.137]                   {
[09:29:52.137]                     {
[09:29:52.137]                       {
[09:29:52.137]                         base::local({
[09:29:52.137]                           has_future <- base::requireNamespace("future", 
[09:29:52.137]                             quietly = TRUE)
[09:29:52.137]                           if (has_future) {
[09:29:52.137]                             ns <- base::getNamespace("future")
[09:29:52.137]                             version <- ns[[".package"]][["version"]]
[09:29:52.137]                             if (is.null(version)) 
[09:29:52.137]                               version <- utils::packageVersion("future")
[09:29:52.137]                           }
[09:29:52.137]                           else {
[09:29:52.137]                             version <- NULL
[09:29:52.137]                           }
[09:29:52.137]                           if (!has_future || version < "1.8.0") {
[09:29:52.137]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:52.137]                               "", base::R.version$version.string), 
[09:29:52.137]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:52.137]                                 base::R.version$platform, 8 * 
[09:29:52.137]                                   base::.Machine$sizeof.pointer), 
[09:29:52.137]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:52.137]                                 "release", "version")], collapse = " "), 
[09:29:52.137]                               hostname = base::Sys.info()[["nodename"]])
[09:29:52.137]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:52.137]                               info)
[09:29:52.137]                             info <- base::paste(info, collapse = "; ")
[09:29:52.137]                             if (!has_future) {
[09:29:52.137]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:52.137]                                 info)
[09:29:52.137]                             }
[09:29:52.137]                             else {
[09:29:52.137]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:52.137]                                 info, version)
[09:29:52.137]                             }
[09:29:52.137]                             base::stop(msg)
[09:29:52.137]                           }
[09:29:52.137]                         })
[09:29:52.137]                       }
[09:29:52.137]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:52.137]                       base::options(mc.cores = 1L)
[09:29:52.137]                     }
[09:29:52.137]                     base::local({
[09:29:52.137]                       for (pkg in c("stats", "future.apply")) {
[09:29:52.137]                         base::loadNamespace(pkg)
[09:29:52.137]                         base::library(pkg, character.only = TRUE)
[09:29:52.137]                       }
[09:29:52.137]                     })
[09:29:52.137]                   }
[09:29:52.137]                   ...future.strategy.old <- future::plan("list")
[09:29:52.137]                   options(future.plan = NULL)
[09:29:52.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:52.137]                 }
[09:29:52.137]                 ...future.workdir <- getwd()
[09:29:52.137]             }
[09:29:52.137]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:52.137]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:52.137]         }
[09:29:52.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:52.137]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:52.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:52.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:52.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:52.137]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:52.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:52.137]             base::names(...future.oldOptions))
[09:29:52.137]     }
[09:29:52.137]     if (FALSE) {
[09:29:52.137]     }
[09:29:52.137]     else {
[09:29:52.137]         if (TRUE) {
[09:29:52.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:52.137]                 open = "w")
[09:29:52.137]         }
[09:29:52.137]         else {
[09:29:52.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:52.137]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:52.137]         }
[09:29:52.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:52.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:52.137]             base::sink(type = "output", split = FALSE)
[09:29:52.137]             base::close(...future.stdout)
[09:29:52.137]         }, add = TRUE)
[09:29:52.137]     }
[09:29:52.137]     ...future.frame <- base::sys.nframe()
[09:29:52.137]     ...future.conditions <- base::list()
[09:29:52.137]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:52.137]     if (FALSE) {
[09:29:52.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:52.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:52.137]     }
[09:29:52.137]     ...future.result <- base::tryCatch({
[09:29:52.137]         base::withCallingHandlers({
[09:29:52.137]             ...future.value <- base::withVisible(base::local({
[09:29:52.137]                 ...future.makeSendCondition <- base::local({
[09:29:52.137]                   sendCondition <- NULL
[09:29:52.137]                   function(frame = 1L) {
[09:29:52.137]                     if (is.function(sendCondition)) 
[09:29:52.137]                       return(sendCondition)
[09:29:52.137]                     ns <- getNamespace("parallel")
[09:29:52.137]                     if (exists("sendData", mode = "function", 
[09:29:52.137]                       envir = ns)) {
[09:29:52.137]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:52.137]                         envir = ns)
[09:29:52.137]                       envir <- sys.frame(frame)
[09:29:52.137]                       master <- NULL
[09:29:52.137]                       while (!identical(envir, .GlobalEnv) && 
[09:29:52.137]                         !identical(envir, emptyenv())) {
[09:29:52.137]                         if (exists("master", mode = "list", envir = envir, 
[09:29:52.137]                           inherits = FALSE)) {
[09:29:52.137]                           master <- get("master", mode = "list", 
[09:29:52.137]                             envir = envir, inherits = FALSE)
[09:29:52.137]                           if (inherits(master, c("SOCKnode", 
[09:29:52.137]                             "SOCK0node"))) {
[09:29:52.137]                             sendCondition <<- function(cond) {
[09:29:52.137]                               data <- list(type = "VALUE", value = cond, 
[09:29:52.137]                                 success = TRUE)
[09:29:52.137]                               parallel_sendData(master, data)
[09:29:52.137]                             }
[09:29:52.137]                             return(sendCondition)
[09:29:52.137]                           }
[09:29:52.137]                         }
[09:29:52.137]                         frame <- frame + 1L
[09:29:52.137]                         envir <- sys.frame(frame)
[09:29:52.137]                       }
[09:29:52.137]                     }
[09:29:52.137]                     sendCondition <<- function(cond) NULL
[09:29:52.137]                   }
[09:29:52.137]                 })
[09:29:52.137]                 withCallingHandlers({
[09:29:52.137]                   {
[09:29:52.137]                     do.call(function(...) {
[09:29:52.137]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.137]                       if (!identical(...future.globals.maxSize.org, 
[09:29:52.137]                         ...future.globals.maxSize)) {
[09:29:52.137]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.137]                         on.exit(options(oopts), add = TRUE)
[09:29:52.137]                       }
[09:29:52.137]                       {
[09:29:52.137]                         lapply(seq_along(...future.elements_ii), 
[09:29:52.137]                           FUN = function(jj) {
[09:29:52.137]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.137]                             ...future.FUN(...future.X_jj, ...)
[09:29:52.137]                           })
[09:29:52.137]                       }
[09:29:52.137]                     }, args = future.call.arguments)
[09:29:52.137]                   }
[09:29:52.137]                 }, immediateCondition = function(cond) {
[09:29:52.137]                   sendCondition <- ...future.makeSendCondition()
[09:29:52.137]                   sendCondition(cond)
[09:29:52.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.137]                   {
[09:29:52.137]                     inherits <- base::inherits
[09:29:52.137]                     invokeRestart <- base::invokeRestart
[09:29:52.137]                     is.null <- base::is.null
[09:29:52.137]                     muffled <- FALSE
[09:29:52.137]                     if (inherits(cond, "message")) {
[09:29:52.137]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:52.137]                       if (muffled) 
[09:29:52.137]                         invokeRestart("muffleMessage")
[09:29:52.137]                     }
[09:29:52.137]                     else if (inherits(cond, "warning")) {
[09:29:52.137]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:52.137]                       if (muffled) 
[09:29:52.137]                         invokeRestart("muffleWarning")
[09:29:52.137]                     }
[09:29:52.137]                     else if (inherits(cond, "condition")) {
[09:29:52.137]                       if (!is.null(pattern)) {
[09:29:52.137]                         computeRestarts <- base::computeRestarts
[09:29:52.137]                         grepl <- base::grepl
[09:29:52.137]                         restarts <- computeRestarts(cond)
[09:29:52.137]                         for (restart in restarts) {
[09:29:52.137]                           name <- restart$name
[09:29:52.137]                           if (is.null(name)) 
[09:29:52.137]                             next
[09:29:52.137]                           if (!grepl(pattern, name)) 
[09:29:52.137]                             next
[09:29:52.137]                           invokeRestart(restart)
[09:29:52.137]                           muffled <- TRUE
[09:29:52.137]                           break
[09:29:52.137]                         }
[09:29:52.137]                       }
[09:29:52.137]                     }
[09:29:52.137]                     invisible(muffled)
[09:29:52.137]                   }
[09:29:52.137]                   muffleCondition(cond)
[09:29:52.137]                 })
[09:29:52.137]             }))
[09:29:52.137]             future::FutureResult(value = ...future.value$value, 
[09:29:52.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.137]                   ...future.rng), globalenv = if (FALSE) 
[09:29:52.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:52.137]                     ...future.globalenv.names))
[09:29:52.137]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:52.137]         }, condition = base::local({
[09:29:52.137]             c <- base::c
[09:29:52.137]             inherits <- base::inherits
[09:29:52.137]             invokeRestart <- base::invokeRestart
[09:29:52.137]             length <- base::length
[09:29:52.137]             list <- base::list
[09:29:52.137]             seq.int <- base::seq.int
[09:29:52.137]             signalCondition <- base::signalCondition
[09:29:52.137]             sys.calls <- base::sys.calls
[09:29:52.137]             `[[` <- base::`[[`
[09:29:52.137]             `+` <- base::`+`
[09:29:52.137]             `<<-` <- base::`<<-`
[09:29:52.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:52.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:52.137]                   3L)]
[09:29:52.137]             }
[09:29:52.137]             function(cond) {
[09:29:52.137]                 is_error <- inherits(cond, "error")
[09:29:52.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:52.137]                   NULL)
[09:29:52.137]                 if (is_error) {
[09:29:52.137]                   sessionInformation <- function() {
[09:29:52.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:52.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:52.137]                       search = base::search(), system = base::Sys.info())
[09:29:52.137]                   }
[09:29:52.137]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:52.137]                     cond$call), session = sessionInformation(), 
[09:29:52.137]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:52.137]                   signalCondition(cond)
[09:29:52.137]                 }
[09:29:52.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:52.137]                 "immediateCondition"))) {
[09:29:52.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:52.137]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:52.137]                   if (TRUE && !signal) {
[09:29:52.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.137]                     {
[09:29:52.137]                       inherits <- base::inherits
[09:29:52.137]                       invokeRestart <- base::invokeRestart
[09:29:52.137]                       is.null <- base::is.null
[09:29:52.137]                       muffled <- FALSE
[09:29:52.137]                       if (inherits(cond, "message")) {
[09:29:52.137]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.137]                         if (muffled) 
[09:29:52.137]                           invokeRestart("muffleMessage")
[09:29:52.137]                       }
[09:29:52.137]                       else if (inherits(cond, "warning")) {
[09:29:52.137]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.137]                         if (muffled) 
[09:29:52.137]                           invokeRestart("muffleWarning")
[09:29:52.137]                       }
[09:29:52.137]                       else if (inherits(cond, "condition")) {
[09:29:52.137]                         if (!is.null(pattern)) {
[09:29:52.137]                           computeRestarts <- base::computeRestarts
[09:29:52.137]                           grepl <- base::grepl
[09:29:52.137]                           restarts <- computeRestarts(cond)
[09:29:52.137]                           for (restart in restarts) {
[09:29:52.137]                             name <- restart$name
[09:29:52.137]                             if (is.null(name)) 
[09:29:52.137]                               next
[09:29:52.137]                             if (!grepl(pattern, name)) 
[09:29:52.137]                               next
[09:29:52.137]                             invokeRestart(restart)
[09:29:52.137]                             muffled <- TRUE
[09:29:52.137]                             break
[09:29:52.137]                           }
[09:29:52.137]                         }
[09:29:52.137]                       }
[09:29:52.137]                       invisible(muffled)
[09:29:52.137]                     }
[09:29:52.137]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.137]                   }
[09:29:52.137]                 }
[09:29:52.137]                 else {
[09:29:52.137]                   if (TRUE) {
[09:29:52.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.137]                     {
[09:29:52.137]                       inherits <- base::inherits
[09:29:52.137]                       invokeRestart <- base::invokeRestart
[09:29:52.137]                       is.null <- base::is.null
[09:29:52.137]                       muffled <- FALSE
[09:29:52.137]                       if (inherits(cond, "message")) {
[09:29:52.137]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.137]                         if (muffled) 
[09:29:52.137]                           invokeRestart("muffleMessage")
[09:29:52.137]                       }
[09:29:52.137]                       else if (inherits(cond, "warning")) {
[09:29:52.137]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.137]                         if (muffled) 
[09:29:52.137]                           invokeRestart("muffleWarning")
[09:29:52.137]                       }
[09:29:52.137]                       else if (inherits(cond, "condition")) {
[09:29:52.137]                         if (!is.null(pattern)) {
[09:29:52.137]                           computeRestarts <- base::computeRestarts
[09:29:52.137]                           grepl <- base::grepl
[09:29:52.137]                           restarts <- computeRestarts(cond)
[09:29:52.137]                           for (restart in restarts) {
[09:29:52.137]                             name <- restart$name
[09:29:52.137]                             if (is.null(name)) 
[09:29:52.137]                               next
[09:29:52.137]                             if (!grepl(pattern, name)) 
[09:29:52.137]                               next
[09:29:52.137]                             invokeRestart(restart)
[09:29:52.137]                             muffled <- TRUE
[09:29:52.137]                             break
[09:29:52.137]                           }
[09:29:52.137]                         }
[09:29:52.137]                       }
[09:29:52.137]                       invisible(muffled)
[09:29:52.137]                     }
[09:29:52.137]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.137]                   }
[09:29:52.137]                 }
[09:29:52.137]             }
[09:29:52.137]         }))
[09:29:52.137]     }, error = function(ex) {
[09:29:52.137]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:52.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.137]                 ...future.rng), started = ...future.startTime, 
[09:29:52.137]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:52.137]             version = "1.8"), class = "FutureResult")
[09:29:52.137]     }, finally = {
[09:29:52.137]         if (!identical(...future.workdir, getwd())) 
[09:29:52.137]             setwd(...future.workdir)
[09:29:52.137]         {
[09:29:52.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:52.137]                 ...future.oldOptions$nwarnings <- NULL
[09:29:52.137]             }
[09:29:52.137]             base::options(...future.oldOptions)
[09:29:52.137]             if (.Platform$OS.type == "windows") {
[09:29:52.137]                 old_names <- names(...future.oldEnvVars)
[09:29:52.137]                 envs <- base::Sys.getenv()
[09:29:52.137]                 names <- names(envs)
[09:29:52.137]                 common <- intersect(names, old_names)
[09:29:52.137]                 added <- setdiff(names, old_names)
[09:29:52.137]                 removed <- setdiff(old_names, names)
[09:29:52.137]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:52.137]                   envs[common]]
[09:29:52.137]                 NAMES <- toupper(changed)
[09:29:52.137]                 args <- list()
[09:29:52.137]                 for (kk in seq_along(NAMES)) {
[09:29:52.137]                   name <- changed[[kk]]
[09:29:52.137]                   NAME <- NAMES[[kk]]
[09:29:52.137]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.137]                     next
[09:29:52.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.137]                 }
[09:29:52.137]                 NAMES <- toupper(added)
[09:29:52.137]                 for (kk in seq_along(NAMES)) {
[09:29:52.137]                   name <- added[[kk]]
[09:29:52.137]                   NAME <- NAMES[[kk]]
[09:29:52.137]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.137]                     next
[09:29:52.137]                   args[[name]] <- ""
[09:29:52.137]                 }
[09:29:52.137]                 NAMES <- toupper(removed)
[09:29:52.137]                 for (kk in seq_along(NAMES)) {
[09:29:52.137]                   name <- removed[[kk]]
[09:29:52.137]                   NAME <- NAMES[[kk]]
[09:29:52.137]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.137]                     next
[09:29:52.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.137]                 }
[09:29:52.137]                 if (length(args) > 0) 
[09:29:52.137]                   base::do.call(base::Sys.setenv, args = args)
[09:29:52.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:52.137]             }
[09:29:52.137]             else {
[09:29:52.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:52.137]             }
[09:29:52.137]             {
[09:29:52.137]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:52.137]                   0L) {
[09:29:52.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:52.137]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:52.137]                   base::options(opts)
[09:29:52.137]                 }
[09:29:52.137]                 {
[09:29:52.137]                   {
[09:29:52.137]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:52.137]                     NULL
[09:29:52.137]                   }
[09:29:52.137]                   options(future.plan = NULL)
[09:29:52.137]                   if (is.na(NA_character_)) 
[09:29:52.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:52.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:52.137]                     .init = FALSE)
[09:29:52.137]                 }
[09:29:52.137]             }
[09:29:52.137]         }
[09:29:52.137]     })
[09:29:52.137]     if (TRUE) {
[09:29:52.137]         base::sink(type = "output", split = FALSE)
[09:29:52.137]         if (TRUE) {
[09:29:52.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:52.137]         }
[09:29:52.137]         else {
[09:29:52.137]             ...future.result["stdout"] <- base::list(NULL)
[09:29:52.137]         }
[09:29:52.137]         base::close(...future.stdout)
[09:29:52.137]         ...future.stdout <- NULL
[09:29:52.137]     }
[09:29:52.137]     ...future.result$conditions <- ...future.conditions
[09:29:52.137]     ...future.result$finished <- base::Sys.time()
[09:29:52.137]     ...future.result
[09:29:52.137] }
[09:29:52.139] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[09:29:52.139] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:52.180] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:52.180] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[09:29:52.181] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[09:29:52.181] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:52.181] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:52.181] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:52.224] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:52.224] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:52.268] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:52.268] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:52.269] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.269] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:52.269] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:52.269] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:52.270] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.270] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[09:29:52.270] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[09:29:52.270] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:52.271] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.271] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:52.271] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.271] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[09:29:52.272] MultisessionFuture started
[09:29:52.272] - Launch lazy future ... done
[09:29:52.272] run() for ‘MultisessionFuture’ ... done
[09:29:52.272] Created future:
[09:29:52.275] receiveMessageFromWorker() for ClusterFuture ...
[09:29:52.275] - Validating connection of MultisessionFuture
[09:29:52.275] - received message: FutureResult
[09:29:52.276] - Received FutureResult
[09:29:52.276] - Erased future from FutureRegistry
[09:29:52.276] result() for ClusterFuture ...
[09:29:52.276] - result already collected: FutureResult
[09:29:52.276] result() for ClusterFuture ... done
[09:29:52.276] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:52.272] MultisessionFuture:
[09:29:52.272] Label: ‘future_vapply-1’
[09:29:52.272] Expression:
[09:29:52.272] {
[09:29:52.272]     do.call(function(...) {
[09:29:52.272]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.272]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.272]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.272]             on.exit(options(oopts), add = TRUE)
[09:29:52.272]         }
[09:29:52.272]         {
[09:29:52.272]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.272]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.272]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.272]             })
[09:29:52.272]         }
[09:29:52.272]     }, args = future.call.arguments)
[09:29:52.272] }
[09:29:52.272] Lazy evaluation: FALSE
[09:29:52.272] Asynchronous evaluation: TRUE
[09:29:52.272] Local evaluation: TRUE
[09:29:52.272] Environment: R_GlobalEnv
[09:29:52.272] Capture standard output: TRUE
[09:29:52.272] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:52.272] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:52.272] Packages: 2 packages (‘stats’, ‘future.apply’)
[09:29:52.272] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:52.272] Resolved: TRUE
[09:29:52.272] Value: <not collected>
[09:29:52.272] Conditions captured: <none>
[09:29:52.272] Early signaling: FALSE
[09:29:52.272] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:52.272] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.276] Chunk #1 of 2 ... DONE
[09:29:52.276] Chunk #2 of 2 ...
[09:29:52.277]  - Finding globals in 'X' for chunk #2 ...
[09:29:52.277] getGlobalsAndPackages() ...
[09:29:52.277] Searching for globals...
[09:29:52.277] 
[09:29:52.277] Searching for globals ... DONE
[09:29:52.277] - globals: [0] <none>
[09:29:52.277] getGlobalsAndPackages() ... DONE
[09:29:52.277]    + additional globals found: [n=0] 
[09:29:52.277]    + additional namespaces needed: [n=0] 
[09:29:52.277]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:52.278]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:52.278]  - seeds: <none>
[09:29:52.278]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.278] getGlobalsAndPackages() ...
[09:29:52.278] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.278] Resolving globals: FALSE
[09:29:52.278] Tweak future expression to call with '...' arguments ...
[09:29:52.278] {
[09:29:52.278]     do.call(function(...) {
[09:29:52.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.278]             on.exit(options(oopts), add = TRUE)
[09:29:52.278]         }
[09:29:52.278]         {
[09:29:52.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.278]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.278]             })
[09:29:52.278]         }
[09:29:52.278]     }, args = future.call.arguments)
[09:29:52.278] }
[09:29:52.278] Tweak future expression to call with '...' arguments ... DONE
[09:29:52.279] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.279] - packages: [2] ‘stats’, ‘future.apply’
[09:29:52.279] getGlobalsAndPackages() ... DONE
[09:29:52.279] run() for ‘Future’ ...
[09:29:52.280] - state: ‘created’
[09:29:52.280] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:52.294] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:52.295]   - Field: ‘node’
[09:29:52.295]   - Field: ‘label’
[09:29:52.295]   - Field: ‘local’
[09:29:52.295]   - Field: ‘owner’
[09:29:52.295]   - Field: ‘envir’
[09:29:52.295]   - Field: ‘workers’
[09:29:52.295]   - Field: ‘packages’
[09:29:52.295]   - Field: ‘gc’
[09:29:52.295]   - Field: ‘conditions’
[09:29:52.296]   - Field: ‘persistent’
[09:29:52.296]   - Field: ‘expr’
[09:29:52.296]   - Field: ‘uuid’
[09:29:52.296]   - Field: ‘seed’
[09:29:52.296]   - Field: ‘version’
[09:29:52.296]   - Field: ‘result’
[09:29:52.296]   - Field: ‘asynchronous’
[09:29:52.296]   - Field: ‘calls’
[09:29:52.296]   - Field: ‘globals’
[09:29:52.296]   - Field: ‘stdout’
[09:29:52.296]   - Field: ‘earlySignal’
[09:29:52.297]   - Field: ‘lazy’
[09:29:52.297]   - Field: ‘state’
[09:29:52.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:52.297] - Launch lazy future ...
[09:29:52.297] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[09:29:52.297] Packages needed by future strategies (n = 0): <none>
[09:29:52.298] {
[09:29:52.298]     {
[09:29:52.298]         {
[09:29:52.298]             ...future.startTime <- base::Sys.time()
[09:29:52.298]             {
[09:29:52.298]                 {
[09:29:52.298]                   {
[09:29:52.298]                     {
[09:29:52.298]                       {
[09:29:52.298]                         base::local({
[09:29:52.298]                           has_future <- base::requireNamespace("future", 
[09:29:52.298]                             quietly = TRUE)
[09:29:52.298]                           if (has_future) {
[09:29:52.298]                             ns <- base::getNamespace("future")
[09:29:52.298]                             version <- ns[[".package"]][["version"]]
[09:29:52.298]                             if (is.null(version)) 
[09:29:52.298]                               version <- utils::packageVersion("future")
[09:29:52.298]                           }
[09:29:52.298]                           else {
[09:29:52.298]                             version <- NULL
[09:29:52.298]                           }
[09:29:52.298]                           if (!has_future || version < "1.8.0") {
[09:29:52.298]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:52.298]                               "", base::R.version$version.string), 
[09:29:52.298]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:52.298]                                 base::R.version$platform, 8 * 
[09:29:52.298]                                   base::.Machine$sizeof.pointer), 
[09:29:52.298]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:52.298]                                 "release", "version")], collapse = " "), 
[09:29:52.298]                               hostname = base::Sys.info()[["nodename"]])
[09:29:52.298]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:52.298]                               info)
[09:29:52.298]                             info <- base::paste(info, collapse = "; ")
[09:29:52.298]                             if (!has_future) {
[09:29:52.298]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:52.298]                                 info)
[09:29:52.298]                             }
[09:29:52.298]                             else {
[09:29:52.298]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:52.298]                                 info, version)
[09:29:52.298]                             }
[09:29:52.298]                             base::stop(msg)
[09:29:52.298]                           }
[09:29:52.298]                         })
[09:29:52.298]                       }
[09:29:52.298]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:52.298]                       base::options(mc.cores = 1L)
[09:29:52.298]                     }
[09:29:52.298]                     base::local({
[09:29:52.298]                       for (pkg in c("stats", "future.apply")) {
[09:29:52.298]                         base::loadNamespace(pkg)
[09:29:52.298]                         base::library(pkg, character.only = TRUE)
[09:29:52.298]                       }
[09:29:52.298]                     })
[09:29:52.298]                   }
[09:29:52.298]                   ...future.strategy.old <- future::plan("list")
[09:29:52.298]                   options(future.plan = NULL)
[09:29:52.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:52.298]                 }
[09:29:52.298]                 ...future.workdir <- getwd()
[09:29:52.298]             }
[09:29:52.298]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:52.298]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:52.298]         }
[09:29:52.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:52.298]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:52.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:52.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:52.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:52.298]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:52.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:52.298]             base::names(...future.oldOptions))
[09:29:52.298]     }
[09:29:52.298]     if (FALSE) {
[09:29:52.298]     }
[09:29:52.298]     else {
[09:29:52.298]         if (TRUE) {
[09:29:52.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:52.298]                 open = "w")
[09:29:52.298]         }
[09:29:52.298]         else {
[09:29:52.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:52.298]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:52.298]         }
[09:29:52.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:52.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:52.298]             base::sink(type = "output", split = FALSE)
[09:29:52.298]             base::close(...future.stdout)
[09:29:52.298]         }, add = TRUE)
[09:29:52.298]     }
[09:29:52.298]     ...future.frame <- base::sys.nframe()
[09:29:52.298]     ...future.conditions <- base::list()
[09:29:52.298]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:52.298]     if (FALSE) {
[09:29:52.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:52.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:52.298]     }
[09:29:52.298]     ...future.result <- base::tryCatch({
[09:29:52.298]         base::withCallingHandlers({
[09:29:52.298]             ...future.value <- base::withVisible(base::local({
[09:29:52.298]                 ...future.makeSendCondition <- base::local({
[09:29:52.298]                   sendCondition <- NULL
[09:29:52.298]                   function(frame = 1L) {
[09:29:52.298]                     if (is.function(sendCondition)) 
[09:29:52.298]                       return(sendCondition)
[09:29:52.298]                     ns <- getNamespace("parallel")
[09:29:52.298]                     if (exists("sendData", mode = "function", 
[09:29:52.298]                       envir = ns)) {
[09:29:52.298]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:52.298]                         envir = ns)
[09:29:52.298]                       envir <- sys.frame(frame)
[09:29:52.298]                       master <- NULL
[09:29:52.298]                       while (!identical(envir, .GlobalEnv) && 
[09:29:52.298]                         !identical(envir, emptyenv())) {
[09:29:52.298]                         if (exists("master", mode = "list", envir = envir, 
[09:29:52.298]                           inherits = FALSE)) {
[09:29:52.298]                           master <- get("master", mode = "list", 
[09:29:52.298]                             envir = envir, inherits = FALSE)
[09:29:52.298]                           if (inherits(master, c("SOCKnode", 
[09:29:52.298]                             "SOCK0node"))) {
[09:29:52.298]                             sendCondition <<- function(cond) {
[09:29:52.298]                               data <- list(type = "VALUE", value = cond, 
[09:29:52.298]                                 success = TRUE)
[09:29:52.298]                               parallel_sendData(master, data)
[09:29:52.298]                             }
[09:29:52.298]                             return(sendCondition)
[09:29:52.298]                           }
[09:29:52.298]                         }
[09:29:52.298]                         frame <- frame + 1L
[09:29:52.298]                         envir <- sys.frame(frame)
[09:29:52.298]                       }
[09:29:52.298]                     }
[09:29:52.298]                     sendCondition <<- function(cond) NULL
[09:29:52.298]                   }
[09:29:52.298]                 })
[09:29:52.298]                 withCallingHandlers({
[09:29:52.298]                   {
[09:29:52.298]                     do.call(function(...) {
[09:29:52.298]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.298]                       if (!identical(...future.globals.maxSize.org, 
[09:29:52.298]                         ...future.globals.maxSize)) {
[09:29:52.298]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.298]                         on.exit(options(oopts), add = TRUE)
[09:29:52.298]                       }
[09:29:52.298]                       {
[09:29:52.298]                         lapply(seq_along(...future.elements_ii), 
[09:29:52.298]                           FUN = function(jj) {
[09:29:52.298]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.298]                             ...future.FUN(...future.X_jj, ...)
[09:29:52.298]                           })
[09:29:52.298]                       }
[09:29:52.298]                     }, args = future.call.arguments)
[09:29:52.298]                   }
[09:29:52.298]                 }, immediateCondition = function(cond) {
[09:29:52.298]                   sendCondition <- ...future.makeSendCondition()
[09:29:52.298]                   sendCondition(cond)
[09:29:52.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.298]                   {
[09:29:52.298]                     inherits <- base::inherits
[09:29:52.298]                     invokeRestart <- base::invokeRestart
[09:29:52.298]                     is.null <- base::is.null
[09:29:52.298]                     muffled <- FALSE
[09:29:52.298]                     if (inherits(cond, "message")) {
[09:29:52.298]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:52.298]                       if (muffled) 
[09:29:52.298]                         invokeRestart("muffleMessage")
[09:29:52.298]                     }
[09:29:52.298]                     else if (inherits(cond, "warning")) {
[09:29:52.298]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:52.298]                       if (muffled) 
[09:29:52.298]                         invokeRestart("muffleWarning")
[09:29:52.298]                     }
[09:29:52.298]                     else if (inherits(cond, "condition")) {
[09:29:52.298]                       if (!is.null(pattern)) {
[09:29:52.298]                         computeRestarts <- base::computeRestarts
[09:29:52.298]                         grepl <- base::grepl
[09:29:52.298]                         restarts <- computeRestarts(cond)
[09:29:52.298]                         for (restart in restarts) {
[09:29:52.298]                           name <- restart$name
[09:29:52.298]                           if (is.null(name)) 
[09:29:52.298]                             next
[09:29:52.298]                           if (!grepl(pattern, name)) 
[09:29:52.298]                             next
[09:29:52.298]                           invokeRestart(restart)
[09:29:52.298]                           muffled <- TRUE
[09:29:52.298]                           break
[09:29:52.298]                         }
[09:29:52.298]                       }
[09:29:52.298]                     }
[09:29:52.298]                     invisible(muffled)
[09:29:52.298]                   }
[09:29:52.298]                   muffleCondition(cond)
[09:29:52.298]                 })
[09:29:52.298]             }))
[09:29:52.298]             future::FutureResult(value = ...future.value$value, 
[09:29:52.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.298]                   ...future.rng), globalenv = if (FALSE) 
[09:29:52.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:52.298]                     ...future.globalenv.names))
[09:29:52.298]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:52.298]         }, condition = base::local({
[09:29:52.298]             c <- base::c
[09:29:52.298]             inherits <- base::inherits
[09:29:52.298]             invokeRestart <- base::invokeRestart
[09:29:52.298]             length <- base::length
[09:29:52.298]             list <- base::list
[09:29:52.298]             seq.int <- base::seq.int
[09:29:52.298]             signalCondition <- base::signalCondition
[09:29:52.298]             sys.calls <- base::sys.calls
[09:29:52.298]             `[[` <- base::`[[`
[09:29:52.298]             `+` <- base::`+`
[09:29:52.298]             `<<-` <- base::`<<-`
[09:29:52.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:52.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:52.298]                   3L)]
[09:29:52.298]             }
[09:29:52.298]             function(cond) {
[09:29:52.298]                 is_error <- inherits(cond, "error")
[09:29:52.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:52.298]                   NULL)
[09:29:52.298]                 if (is_error) {
[09:29:52.298]                   sessionInformation <- function() {
[09:29:52.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:52.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:52.298]                       search = base::search(), system = base::Sys.info())
[09:29:52.298]                   }
[09:29:52.298]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:52.298]                     cond$call), session = sessionInformation(), 
[09:29:52.298]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:52.298]                   signalCondition(cond)
[09:29:52.298]                 }
[09:29:52.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:52.298]                 "immediateCondition"))) {
[09:29:52.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:52.298]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:52.298]                   if (TRUE && !signal) {
[09:29:52.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.298]                     {
[09:29:52.298]                       inherits <- base::inherits
[09:29:52.298]                       invokeRestart <- base::invokeRestart
[09:29:52.298]                       is.null <- base::is.null
[09:29:52.298]                       muffled <- FALSE
[09:29:52.298]                       if (inherits(cond, "message")) {
[09:29:52.298]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.298]                         if (muffled) 
[09:29:52.298]                           invokeRestart("muffleMessage")
[09:29:52.298]                       }
[09:29:52.298]                       else if (inherits(cond, "warning")) {
[09:29:52.298]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.298]                         if (muffled) 
[09:29:52.298]                           invokeRestart("muffleWarning")
[09:29:52.298]                       }
[09:29:52.298]                       else if (inherits(cond, "condition")) {
[09:29:52.298]                         if (!is.null(pattern)) {
[09:29:52.298]                           computeRestarts <- base::computeRestarts
[09:29:52.298]                           grepl <- base::grepl
[09:29:52.298]                           restarts <- computeRestarts(cond)
[09:29:52.298]                           for (restart in restarts) {
[09:29:52.298]                             name <- restart$name
[09:29:52.298]                             if (is.null(name)) 
[09:29:52.298]                               next
[09:29:52.298]                             if (!grepl(pattern, name)) 
[09:29:52.298]                               next
[09:29:52.298]                             invokeRestart(restart)
[09:29:52.298]                             muffled <- TRUE
[09:29:52.298]                             break
[09:29:52.298]                           }
[09:29:52.298]                         }
[09:29:52.298]                       }
[09:29:52.298]                       invisible(muffled)
[09:29:52.298]                     }
[09:29:52.298]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.298]                   }
[09:29:52.298]                 }
[09:29:52.298]                 else {
[09:29:52.298]                   if (TRUE) {
[09:29:52.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.298]                     {
[09:29:52.298]                       inherits <- base::inherits
[09:29:52.298]                       invokeRestart <- base::invokeRestart
[09:29:52.298]                       is.null <- base::is.null
[09:29:52.298]                       muffled <- FALSE
[09:29:52.298]                       if (inherits(cond, "message")) {
[09:29:52.298]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.298]                         if (muffled) 
[09:29:52.298]                           invokeRestart("muffleMessage")
[09:29:52.298]                       }
[09:29:52.298]                       else if (inherits(cond, "warning")) {
[09:29:52.298]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.298]                         if (muffled) 
[09:29:52.298]                           invokeRestart("muffleWarning")
[09:29:52.298]                       }
[09:29:52.298]                       else if (inherits(cond, "condition")) {
[09:29:52.298]                         if (!is.null(pattern)) {
[09:29:52.298]                           computeRestarts <- base::computeRestarts
[09:29:52.298]                           grepl <- base::grepl
[09:29:52.298]                           restarts <- computeRestarts(cond)
[09:29:52.298]                           for (restart in restarts) {
[09:29:52.298]                             name <- restart$name
[09:29:52.298]                             if (is.null(name)) 
[09:29:52.298]                               next
[09:29:52.298]                             if (!grepl(pattern, name)) 
[09:29:52.298]                               next
[09:29:52.298]                             invokeRestart(restart)
[09:29:52.298]                             muffled <- TRUE
[09:29:52.298]                             break
[09:29:52.298]                           }
[09:29:52.298]                         }
[09:29:52.298]                       }
[09:29:52.298]                       invisible(muffled)
[09:29:52.298]                     }
[09:29:52.298]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.298]                   }
[09:29:52.298]                 }
[09:29:52.298]             }
[09:29:52.298]         }))
[09:29:52.298]     }, error = function(ex) {
[09:29:52.298]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:52.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.298]                 ...future.rng), started = ...future.startTime, 
[09:29:52.298]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:52.298]             version = "1.8"), class = "FutureResult")
[09:29:52.298]     }, finally = {
[09:29:52.298]         if (!identical(...future.workdir, getwd())) 
[09:29:52.298]             setwd(...future.workdir)
[09:29:52.298]         {
[09:29:52.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:52.298]                 ...future.oldOptions$nwarnings <- NULL
[09:29:52.298]             }
[09:29:52.298]             base::options(...future.oldOptions)
[09:29:52.298]             if (.Platform$OS.type == "windows") {
[09:29:52.298]                 old_names <- names(...future.oldEnvVars)
[09:29:52.298]                 envs <- base::Sys.getenv()
[09:29:52.298]                 names <- names(envs)
[09:29:52.298]                 common <- intersect(names, old_names)
[09:29:52.298]                 added <- setdiff(names, old_names)
[09:29:52.298]                 removed <- setdiff(old_names, names)
[09:29:52.298]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:52.298]                   envs[common]]
[09:29:52.298]                 NAMES <- toupper(changed)
[09:29:52.298]                 args <- list()
[09:29:52.298]                 for (kk in seq_along(NAMES)) {
[09:29:52.298]                   name <- changed[[kk]]
[09:29:52.298]                   NAME <- NAMES[[kk]]
[09:29:52.298]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.298]                     next
[09:29:52.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.298]                 }
[09:29:52.298]                 NAMES <- toupper(added)
[09:29:52.298]                 for (kk in seq_along(NAMES)) {
[09:29:52.298]                   name <- added[[kk]]
[09:29:52.298]                   NAME <- NAMES[[kk]]
[09:29:52.298]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.298]                     next
[09:29:52.298]                   args[[name]] <- ""
[09:29:52.298]                 }
[09:29:52.298]                 NAMES <- toupper(removed)
[09:29:52.298]                 for (kk in seq_along(NAMES)) {
[09:29:52.298]                   name <- removed[[kk]]
[09:29:52.298]                   NAME <- NAMES[[kk]]
[09:29:52.298]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.298]                     next
[09:29:52.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.298]                 }
[09:29:52.298]                 if (length(args) > 0) 
[09:29:52.298]                   base::do.call(base::Sys.setenv, args = args)
[09:29:52.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:52.298]             }
[09:29:52.298]             else {
[09:29:52.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:52.298]             }
[09:29:52.298]             {
[09:29:52.298]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:52.298]                   0L) {
[09:29:52.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:52.298]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:52.298]                   base::options(opts)
[09:29:52.298]                 }
[09:29:52.298]                 {
[09:29:52.298]                   {
[09:29:52.298]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:52.298]                     NULL
[09:29:52.298]                   }
[09:29:52.298]                   options(future.plan = NULL)
[09:29:52.298]                   if (is.na(NA_character_)) 
[09:29:52.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:52.298]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:52.298]                     .init = FALSE)
[09:29:52.298]                 }
[09:29:52.298]             }
[09:29:52.298]         }
[09:29:52.298]     })
[09:29:52.298]     if (TRUE) {
[09:29:52.298]         base::sink(type = "output", split = FALSE)
[09:29:52.298]         if (TRUE) {
[09:29:52.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:52.298]         }
[09:29:52.298]         else {
[09:29:52.298]             ...future.result["stdout"] <- base::list(NULL)
[09:29:52.298]         }
[09:29:52.298]         base::close(...future.stdout)
[09:29:52.298]         ...future.stdout <- NULL
[09:29:52.298]     }
[09:29:52.298]     ...future.result$conditions <- ...future.conditions
[09:29:52.298]     ...future.result$finished <- base::Sys.time()
[09:29:52.298]     ...future.result
[09:29:52.298] }
[09:29:52.300] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[09:29:52.301] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:52.344] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:52.344] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[09:29:52.345] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[09:29:52.345] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:52.345] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:52.345] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:52.388] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:52.388] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:52.432] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:52.432] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:52.433] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.433] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:52.433] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:52.433] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:52.434] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.434] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #1 ...
[09:29:52.434] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #1 ... DONE
[09:29:52.434] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:52.435] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.435] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:52.435] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.435] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[09:29:52.436] MultisessionFuture started
[09:29:52.436] - Launch lazy future ... done
[09:29:52.436] run() for ‘MultisessionFuture’ ... done
[09:29:52.436] Created future:
[09:29:52.440] receiveMessageFromWorker() for ClusterFuture ...
[09:29:52.440] - Validating connection of MultisessionFuture
[09:29:52.440] - received message: FutureResult
[09:29:52.440] - Received FutureResult
[09:29:52.440] - Erased future from FutureRegistry
[09:29:52.441] result() for ClusterFuture ...
[09:29:52.441] - result already collected: FutureResult
[09:29:52.441] result() for ClusterFuture ... done
[09:29:52.441] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:52.436] MultisessionFuture:
[09:29:52.436] Label: ‘future_vapply-2’
[09:29:52.436] Expression:
[09:29:52.436] {
[09:29:52.436]     do.call(function(...) {
[09:29:52.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.436]             on.exit(options(oopts), add = TRUE)
[09:29:52.436]         }
[09:29:52.436]         {
[09:29:52.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.436]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.436]             })
[09:29:52.436]         }
[09:29:52.436]     }, args = future.call.arguments)
[09:29:52.436] }
[09:29:52.436] Lazy evaluation: FALSE
[09:29:52.436] Asynchronous evaluation: TRUE
[09:29:52.436] Local evaluation: TRUE
[09:29:52.436] Environment: R_GlobalEnv
[09:29:52.436] Capture standard output: TRUE
[09:29:52.436] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:52.436] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:52.436] Packages: 2 packages (‘stats’, ‘future.apply’)
[09:29:52.436] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:52.436] Resolved: TRUE
[09:29:52.436] Value: <not collected>
[09:29:52.436] Conditions captured: <none>
[09:29:52.436] Early signaling: FALSE
[09:29:52.436] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:52.436] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.441] Chunk #2 of 2 ... DONE
[09:29:52.441] Launching 2 futures (chunks) ... DONE
[09:29:52.441] Resolving 2 futures (chunks) ...
[09:29:52.441] resolve() on list ...
[09:29:52.441]  recursive: 0
[09:29:52.442]  length: 2
[09:29:52.442] 
[09:29:52.442] Future #1
[09:29:52.442] result() for ClusterFuture ...
[09:29:52.442] - result already collected: FutureResult
[09:29:52.442] result() for ClusterFuture ... done
[09:29:52.442] result() for ClusterFuture ...
[09:29:52.442] - result already collected: FutureResult
[09:29:52.442] result() for ClusterFuture ... done
[09:29:52.442] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:52.442] - nx: 2
[09:29:52.443] - relay: TRUE
[09:29:52.443] - stdout: TRUE
[09:29:52.443] - signal: TRUE
[09:29:52.443] - resignal: FALSE
[09:29:52.443] - force: TRUE
[09:29:52.443] - relayed: [n=2] FALSE, FALSE
[09:29:52.443] - queued futures: [n=2] FALSE, FALSE
[09:29:52.443]  - until=1
[09:29:52.443]  - relaying element #1
[09:29:52.443] result() for ClusterFuture ...
[09:29:52.443] - result already collected: FutureResult
[09:29:52.443] result() for ClusterFuture ... done
[09:29:52.444] result() for ClusterFuture ...
[09:29:52.444] - result already collected: FutureResult
[09:29:52.444] result() for ClusterFuture ... done
[09:29:52.444] result() for ClusterFuture ...
[09:29:52.444] - result already collected: FutureResult
[09:29:52.444] result() for ClusterFuture ... done
[09:29:52.444] result() for ClusterFuture ...
[09:29:52.444] - result already collected: FutureResult
[09:29:52.444] result() for ClusterFuture ... done
[09:29:52.444] - relayed: [n=2] TRUE, FALSE
[09:29:52.444] - queued futures: [n=2] TRUE, FALSE
[09:29:52.445] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:52.445]  length: 1 (resolved future 1)
[09:29:52.445] Future #2
[09:29:52.445] result() for ClusterFuture ...
[09:29:52.445] - result already collected: FutureResult
[09:29:52.445] result() for ClusterFuture ... done
[09:29:52.445] result() for ClusterFuture ...
[09:29:52.445] - result already collected: FutureResult
[09:29:52.445] result() for ClusterFuture ... done
[09:29:52.445] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:52.445] - nx: 2
[09:29:52.446] - relay: TRUE
[09:29:52.446] - stdout: TRUE
[09:29:52.446] - signal: TRUE
[09:29:52.446] - resignal: FALSE
[09:29:52.446] - force: TRUE
[09:29:52.446] - relayed: [n=2] TRUE, FALSE
[09:29:52.446] - queued futures: [n=2] TRUE, FALSE
[09:29:52.446]  - until=2
[09:29:52.446]  - relaying element #2
[09:29:52.446] result() for ClusterFuture ...
[09:29:52.446] - result already collected: FutureResult
[09:29:52.446] result() for ClusterFuture ... done
[09:29:52.447] result() for ClusterFuture ...
[09:29:52.447] - result already collected: FutureResult
[09:29:52.447] result() for ClusterFuture ... done
[09:29:52.447] result() for ClusterFuture ...
[09:29:52.447] - result already collected: FutureResult
[09:29:52.447] result() for ClusterFuture ... done
[09:29:52.447] result() for ClusterFuture ...
[09:29:52.447] - result already collected: FutureResult
[09:29:52.447] result() for ClusterFuture ... done
[09:29:52.447] - relayed: [n=2] TRUE, TRUE
[09:29:52.447] - queued futures: [n=2] TRUE, TRUE
[09:29:52.447] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:52.448]  length: 0 (resolved future 2)
[09:29:52.448] Relaying remaining futures
[09:29:52.448] signalConditionsASAP(NULL, pos=0) ...
[09:29:52.448] - nx: 2
[09:29:52.448] - relay: TRUE
[09:29:52.448] - stdout: TRUE
[09:29:52.448] - signal: TRUE
[09:29:52.448] - resignal: FALSE
[09:29:52.448] - force: TRUE
[09:29:52.448] - relayed: [n=2] TRUE, TRUE
[09:29:52.448] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:52.449] - relayed: [n=2] TRUE, TRUE
[09:29:52.449] - queued futures: [n=2] TRUE, TRUE
[09:29:52.449] signalConditionsASAP(NULL, pos=0) ... done
[09:29:52.449] resolve() on list ... DONE
[09:29:52.449] result() for ClusterFuture ...
[09:29:52.449] - result already collected: FutureResult
[09:29:52.449] result() for ClusterFuture ... done
[09:29:52.449] result() for ClusterFuture ...
[09:29:52.449] - result already collected: FutureResult
[09:29:52.449] result() for ClusterFuture ... done
[09:29:52.449] result() for ClusterFuture ...
[09:29:52.449] - result already collected: FutureResult
[09:29:52.450] result() for ClusterFuture ... done
[09:29:52.450] result() for ClusterFuture ...
[09:29:52.450] - result already collected: FutureResult
[09:29:52.450] result() for ClusterFuture ... done
[09:29:52.450]  - Number of value chunks collected: 2
[09:29:52.450] Resolving 2 futures (chunks) ... DONE
[09:29:52.450] Reducing values from 2 chunks ...
[09:29:52.450]  - Number of values collected after concatenation: 3
[09:29:52.450]  - Number of values expected: 3
[09:29:52.450] Reducing values from 2 chunks ... DONE
[09:29:52.450] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[09:29:52.452] future_lapply() ...
[09:29:52.459] Number of chunks: 2
[09:29:52.459] getGlobalsAndPackagesXApply() ...
[09:29:52.459]  - future.globals: TRUE
[09:29:52.459] getGlobalsAndPackages() ...
[09:29:52.459] Searching for globals...
[09:29:52.464] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[09:29:52.464] Searching for globals ... DONE
[09:29:52.464] Resolving globals: FALSE
[09:29:52.465] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[09:29:52.465] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[09:29:52.465] - globals: [1] ‘FUN’
[09:29:52.465] - packages: [1] ‘stats’
[09:29:52.466] getGlobalsAndPackages() ... DONE
[09:29:52.466]  - globals found/used: [n=1] ‘FUN’
[09:29:52.466]  - needed namespaces: [n=1] ‘stats’
[09:29:52.466] Finding globals ... DONE
[09:29:52.466]  - use_args: TRUE
[09:29:52.466]  - Getting '...' globals ...
[09:29:52.466] resolve() on list ...
[09:29:52.466]  recursive: 0
[09:29:52.466]  length: 1
[09:29:52.467]  elements: ‘...’
[09:29:52.467]  length: 0 (resolved future 1)
[09:29:52.467] resolve() on list ... DONE
[09:29:52.467]    - '...' content: [n=0] 
[09:29:52.467] List of 1
[09:29:52.467]  $ ...: list()
[09:29:52.467]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:52.467]  - attr(*, "where")=List of 1
[09:29:52.467]   ..$ ...:<environment: 0x561d37f572b8> 
[09:29:52.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:52.467]  - attr(*, "resolved")= logi TRUE
[09:29:52.467]  - attr(*, "total_size")= num NA
[09:29:52.469]  - Getting '...' globals ... DONE
[09:29:52.469] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:29:52.470] List of 2
[09:29:52.470]  $ ...future.FUN:function (x, na.rm = TRUE)  
[09:29:52.470]  $ ...          : list()
[09:29:52.470]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:52.470]  - attr(*, "where")=List of 2
[09:29:52.470]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:52.470]   ..$ ...          :<environment: 0x561d37f572b8> 
[09:29:52.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:52.470]  - attr(*, "resolved")= logi FALSE
[09:29:52.470]  - attr(*, "total_size")= num 46960
[09:29:52.472] Packages to be attached in all futures: [n=1] ‘stats’
[09:29:52.472] getGlobalsAndPackagesXApply() ... DONE
[09:29:52.472] Number of futures (= number of chunks): 2
[09:29:52.473] Launching 2 futures (chunks) ...
[09:29:52.473] Chunk #1 of 2 ...
[09:29:52.473]  - Finding globals in 'X' for chunk #1 ...
[09:29:52.473] getGlobalsAndPackages() ...
[09:29:52.473] Searching for globals...
[09:29:52.473] 
[09:29:52.473] Searching for globals ... DONE
[09:29:52.473] - globals: [0] <none>
[09:29:52.473] getGlobalsAndPackages() ... DONE
[09:29:52.474]    + additional globals found: [n=0] 
[09:29:52.474]    + additional namespaces needed: [n=0] 
[09:29:52.474]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:52.474]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:52.474]  - seeds: <none>
[09:29:52.474]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.474] getGlobalsAndPackages() ...
[09:29:52.474] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.474] Resolving globals: FALSE
[09:29:52.474] Tweak future expression to call with '...' arguments ...
[09:29:52.474] {
[09:29:52.474]     do.call(function(...) {
[09:29:52.474]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.474]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.474]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.474]             on.exit(options(oopts), add = TRUE)
[09:29:52.474]         }
[09:29:52.474]         {
[09:29:52.474]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.474]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.474]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.474]             })
[09:29:52.474]         }
[09:29:52.474]     }, args = future.call.arguments)
[09:29:52.474] }
[09:29:52.475] Tweak future expression to call with '...' arguments ... DONE
[09:29:52.475] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.475] - packages: [1] ‘stats’
[09:29:52.475] getGlobalsAndPackages() ... DONE
[09:29:52.476] run() for ‘Future’ ...
[09:29:52.476] - state: ‘created’
[09:29:52.476] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:52.489] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:52.490]   - Field: ‘node’
[09:29:52.490]   - Field: ‘label’
[09:29:52.490]   - Field: ‘local’
[09:29:52.490]   - Field: ‘owner’
[09:29:52.490]   - Field: ‘envir’
[09:29:52.490]   - Field: ‘workers’
[09:29:52.490]   - Field: ‘packages’
[09:29:52.490]   - Field: ‘gc’
[09:29:52.490]   - Field: ‘conditions’
[09:29:52.491]   - Field: ‘persistent’
[09:29:52.491]   - Field: ‘expr’
[09:29:52.491]   - Field: ‘uuid’
[09:29:52.491]   - Field: ‘seed’
[09:29:52.491]   - Field: ‘version’
[09:29:52.491]   - Field: ‘result’
[09:29:52.491]   - Field: ‘asynchronous’
[09:29:52.491]   - Field: ‘calls’
[09:29:52.491]   - Field: ‘globals’
[09:29:52.491]   - Field: ‘stdout’
[09:29:52.491]   - Field: ‘earlySignal’
[09:29:52.492]   - Field: ‘lazy’
[09:29:52.492]   - Field: ‘state’
[09:29:52.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:52.492] - Launch lazy future ...
[09:29:52.492] Packages needed by the future expression (n = 1): ‘stats’
[09:29:52.492] Packages needed by future strategies (n = 0): <none>
[09:29:52.493] {
[09:29:52.493]     {
[09:29:52.493]         {
[09:29:52.493]             ...future.startTime <- base::Sys.time()
[09:29:52.493]             {
[09:29:52.493]                 {
[09:29:52.493]                   {
[09:29:52.493]                     {
[09:29:52.493]                       {
[09:29:52.493]                         base::local({
[09:29:52.493]                           has_future <- base::requireNamespace("future", 
[09:29:52.493]                             quietly = TRUE)
[09:29:52.493]                           if (has_future) {
[09:29:52.493]                             ns <- base::getNamespace("future")
[09:29:52.493]                             version <- ns[[".package"]][["version"]]
[09:29:52.493]                             if (is.null(version)) 
[09:29:52.493]                               version <- utils::packageVersion("future")
[09:29:52.493]                           }
[09:29:52.493]                           else {
[09:29:52.493]                             version <- NULL
[09:29:52.493]                           }
[09:29:52.493]                           if (!has_future || version < "1.8.0") {
[09:29:52.493]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:52.493]                               "", base::R.version$version.string), 
[09:29:52.493]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:52.493]                                 base::R.version$platform, 8 * 
[09:29:52.493]                                   base::.Machine$sizeof.pointer), 
[09:29:52.493]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:52.493]                                 "release", "version")], collapse = " "), 
[09:29:52.493]                               hostname = base::Sys.info()[["nodename"]])
[09:29:52.493]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:52.493]                               info)
[09:29:52.493]                             info <- base::paste(info, collapse = "; ")
[09:29:52.493]                             if (!has_future) {
[09:29:52.493]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:52.493]                                 info)
[09:29:52.493]                             }
[09:29:52.493]                             else {
[09:29:52.493]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:52.493]                                 info, version)
[09:29:52.493]                             }
[09:29:52.493]                             base::stop(msg)
[09:29:52.493]                           }
[09:29:52.493]                         })
[09:29:52.493]                       }
[09:29:52.493]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:52.493]                       base::options(mc.cores = 1L)
[09:29:52.493]                     }
[09:29:52.493]                     base::local({
[09:29:52.493]                       for (pkg in "stats") {
[09:29:52.493]                         base::loadNamespace(pkg)
[09:29:52.493]                         base::library(pkg, character.only = TRUE)
[09:29:52.493]                       }
[09:29:52.493]                     })
[09:29:52.493]                   }
[09:29:52.493]                   ...future.strategy.old <- future::plan("list")
[09:29:52.493]                   options(future.plan = NULL)
[09:29:52.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:52.493]                 }
[09:29:52.493]                 ...future.workdir <- getwd()
[09:29:52.493]             }
[09:29:52.493]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:52.493]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:52.493]         }
[09:29:52.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:52.493]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:52.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:52.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:52.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:52.493]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:52.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:52.493]             base::names(...future.oldOptions))
[09:29:52.493]     }
[09:29:52.493]     if (FALSE) {
[09:29:52.493]     }
[09:29:52.493]     else {
[09:29:52.493]         if (TRUE) {
[09:29:52.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:52.493]                 open = "w")
[09:29:52.493]         }
[09:29:52.493]         else {
[09:29:52.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:52.493]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:52.493]         }
[09:29:52.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:52.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:52.493]             base::sink(type = "output", split = FALSE)
[09:29:52.493]             base::close(...future.stdout)
[09:29:52.493]         }, add = TRUE)
[09:29:52.493]     }
[09:29:52.493]     ...future.frame <- base::sys.nframe()
[09:29:52.493]     ...future.conditions <- base::list()
[09:29:52.493]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:52.493]     if (FALSE) {
[09:29:52.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:52.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:52.493]     }
[09:29:52.493]     ...future.result <- base::tryCatch({
[09:29:52.493]         base::withCallingHandlers({
[09:29:52.493]             ...future.value <- base::withVisible(base::local({
[09:29:52.493]                 ...future.makeSendCondition <- base::local({
[09:29:52.493]                   sendCondition <- NULL
[09:29:52.493]                   function(frame = 1L) {
[09:29:52.493]                     if (is.function(sendCondition)) 
[09:29:52.493]                       return(sendCondition)
[09:29:52.493]                     ns <- getNamespace("parallel")
[09:29:52.493]                     if (exists("sendData", mode = "function", 
[09:29:52.493]                       envir = ns)) {
[09:29:52.493]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:52.493]                         envir = ns)
[09:29:52.493]                       envir <- sys.frame(frame)
[09:29:52.493]                       master <- NULL
[09:29:52.493]                       while (!identical(envir, .GlobalEnv) && 
[09:29:52.493]                         !identical(envir, emptyenv())) {
[09:29:52.493]                         if (exists("master", mode = "list", envir = envir, 
[09:29:52.493]                           inherits = FALSE)) {
[09:29:52.493]                           master <- get("master", mode = "list", 
[09:29:52.493]                             envir = envir, inherits = FALSE)
[09:29:52.493]                           if (inherits(master, c("SOCKnode", 
[09:29:52.493]                             "SOCK0node"))) {
[09:29:52.493]                             sendCondition <<- function(cond) {
[09:29:52.493]                               data <- list(type = "VALUE", value = cond, 
[09:29:52.493]                                 success = TRUE)
[09:29:52.493]                               parallel_sendData(master, data)
[09:29:52.493]                             }
[09:29:52.493]                             return(sendCondition)
[09:29:52.493]                           }
[09:29:52.493]                         }
[09:29:52.493]                         frame <- frame + 1L
[09:29:52.493]                         envir <- sys.frame(frame)
[09:29:52.493]                       }
[09:29:52.493]                     }
[09:29:52.493]                     sendCondition <<- function(cond) NULL
[09:29:52.493]                   }
[09:29:52.493]                 })
[09:29:52.493]                 withCallingHandlers({
[09:29:52.493]                   {
[09:29:52.493]                     do.call(function(...) {
[09:29:52.493]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.493]                       if (!identical(...future.globals.maxSize.org, 
[09:29:52.493]                         ...future.globals.maxSize)) {
[09:29:52.493]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.493]                         on.exit(options(oopts), add = TRUE)
[09:29:52.493]                       }
[09:29:52.493]                       {
[09:29:52.493]                         lapply(seq_along(...future.elements_ii), 
[09:29:52.493]                           FUN = function(jj) {
[09:29:52.493]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.493]                             ...future.FUN(...future.X_jj, ...)
[09:29:52.493]                           })
[09:29:52.493]                       }
[09:29:52.493]                     }, args = future.call.arguments)
[09:29:52.493]                   }
[09:29:52.493]                 }, immediateCondition = function(cond) {
[09:29:52.493]                   sendCondition <- ...future.makeSendCondition()
[09:29:52.493]                   sendCondition(cond)
[09:29:52.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.493]                   {
[09:29:52.493]                     inherits <- base::inherits
[09:29:52.493]                     invokeRestart <- base::invokeRestart
[09:29:52.493]                     is.null <- base::is.null
[09:29:52.493]                     muffled <- FALSE
[09:29:52.493]                     if (inherits(cond, "message")) {
[09:29:52.493]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:52.493]                       if (muffled) 
[09:29:52.493]                         invokeRestart("muffleMessage")
[09:29:52.493]                     }
[09:29:52.493]                     else if (inherits(cond, "warning")) {
[09:29:52.493]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:52.493]                       if (muffled) 
[09:29:52.493]                         invokeRestart("muffleWarning")
[09:29:52.493]                     }
[09:29:52.493]                     else if (inherits(cond, "condition")) {
[09:29:52.493]                       if (!is.null(pattern)) {
[09:29:52.493]                         computeRestarts <- base::computeRestarts
[09:29:52.493]                         grepl <- base::grepl
[09:29:52.493]                         restarts <- computeRestarts(cond)
[09:29:52.493]                         for (restart in restarts) {
[09:29:52.493]                           name <- restart$name
[09:29:52.493]                           if (is.null(name)) 
[09:29:52.493]                             next
[09:29:52.493]                           if (!grepl(pattern, name)) 
[09:29:52.493]                             next
[09:29:52.493]                           invokeRestart(restart)
[09:29:52.493]                           muffled <- TRUE
[09:29:52.493]                           break
[09:29:52.493]                         }
[09:29:52.493]                       }
[09:29:52.493]                     }
[09:29:52.493]                     invisible(muffled)
[09:29:52.493]                   }
[09:29:52.493]                   muffleCondition(cond)
[09:29:52.493]                 })
[09:29:52.493]             }))
[09:29:52.493]             future::FutureResult(value = ...future.value$value, 
[09:29:52.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.493]                   ...future.rng), globalenv = if (FALSE) 
[09:29:52.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:52.493]                     ...future.globalenv.names))
[09:29:52.493]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:52.493]         }, condition = base::local({
[09:29:52.493]             c <- base::c
[09:29:52.493]             inherits <- base::inherits
[09:29:52.493]             invokeRestart <- base::invokeRestart
[09:29:52.493]             length <- base::length
[09:29:52.493]             list <- base::list
[09:29:52.493]             seq.int <- base::seq.int
[09:29:52.493]             signalCondition <- base::signalCondition
[09:29:52.493]             sys.calls <- base::sys.calls
[09:29:52.493]             `[[` <- base::`[[`
[09:29:52.493]             `+` <- base::`+`
[09:29:52.493]             `<<-` <- base::`<<-`
[09:29:52.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:52.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:52.493]                   3L)]
[09:29:52.493]             }
[09:29:52.493]             function(cond) {
[09:29:52.493]                 is_error <- inherits(cond, "error")
[09:29:52.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:52.493]                   NULL)
[09:29:52.493]                 if (is_error) {
[09:29:52.493]                   sessionInformation <- function() {
[09:29:52.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:52.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:52.493]                       search = base::search(), system = base::Sys.info())
[09:29:52.493]                   }
[09:29:52.493]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:52.493]                     cond$call), session = sessionInformation(), 
[09:29:52.493]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:52.493]                   signalCondition(cond)
[09:29:52.493]                 }
[09:29:52.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:52.493]                 "immediateCondition"))) {
[09:29:52.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:52.493]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:52.493]                   if (TRUE && !signal) {
[09:29:52.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.493]                     {
[09:29:52.493]                       inherits <- base::inherits
[09:29:52.493]                       invokeRestart <- base::invokeRestart
[09:29:52.493]                       is.null <- base::is.null
[09:29:52.493]                       muffled <- FALSE
[09:29:52.493]                       if (inherits(cond, "message")) {
[09:29:52.493]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.493]                         if (muffled) 
[09:29:52.493]                           invokeRestart("muffleMessage")
[09:29:52.493]                       }
[09:29:52.493]                       else if (inherits(cond, "warning")) {
[09:29:52.493]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.493]                         if (muffled) 
[09:29:52.493]                           invokeRestart("muffleWarning")
[09:29:52.493]                       }
[09:29:52.493]                       else if (inherits(cond, "condition")) {
[09:29:52.493]                         if (!is.null(pattern)) {
[09:29:52.493]                           computeRestarts <- base::computeRestarts
[09:29:52.493]                           grepl <- base::grepl
[09:29:52.493]                           restarts <- computeRestarts(cond)
[09:29:52.493]                           for (restart in restarts) {
[09:29:52.493]                             name <- restart$name
[09:29:52.493]                             if (is.null(name)) 
[09:29:52.493]                               next
[09:29:52.493]                             if (!grepl(pattern, name)) 
[09:29:52.493]                               next
[09:29:52.493]                             invokeRestart(restart)
[09:29:52.493]                             muffled <- TRUE
[09:29:52.493]                             break
[09:29:52.493]                           }
[09:29:52.493]                         }
[09:29:52.493]                       }
[09:29:52.493]                       invisible(muffled)
[09:29:52.493]                     }
[09:29:52.493]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.493]                   }
[09:29:52.493]                 }
[09:29:52.493]                 else {
[09:29:52.493]                   if (TRUE) {
[09:29:52.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.493]                     {
[09:29:52.493]                       inherits <- base::inherits
[09:29:52.493]                       invokeRestart <- base::invokeRestart
[09:29:52.493]                       is.null <- base::is.null
[09:29:52.493]                       muffled <- FALSE
[09:29:52.493]                       if (inherits(cond, "message")) {
[09:29:52.493]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.493]                         if (muffled) 
[09:29:52.493]                           invokeRestart("muffleMessage")
[09:29:52.493]                       }
[09:29:52.493]                       else if (inherits(cond, "warning")) {
[09:29:52.493]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.493]                         if (muffled) 
[09:29:52.493]                           invokeRestart("muffleWarning")
[09:29:52.493]                       }
[09:29:52.493]                       else if (inherits(cond, "condition")) {
[09:29:52.493]                         if (!is.null(pattern)) {
[09:29:52.493]                           computeRestarts <- base::computeRestarts
[09:29:52.493]                           grepl <- base::grepl
[09:29:52.493]                           restarts <- computeRestarts(cond)
[09:29:52.493]                           for (restart in restarts) {
[09:29:52.493]                             name <- restart$name
[09:29:52.493]                             if (is.null(name)) 
[09:29:52.493]                               next
[09:29:52.493]                             if (!grepl(pattern, name)) 
[09:29:52.493]                               next
[09:29:52.493]                             invokeRestart(restart)
[09:29:52.493]                             muffled <- TRUE
[09:29:52.493]                             break
[09:29:52.493]                           }
[09:29:52.493]                         }
[09:29:52.493]                       }
[09:29:52.493]                       invisible(muffled)
[09:29:52.493]                     }
[09:29:52.493]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.493]                   }
[09:29:52.493]                 }
[09:29:52.493]             }
[09:29:52.493]         }))
[09:29:52.493]     }, error = function(ex) {
[09:29:52.493]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:52.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.493]                 ...future.rng), started = ...future.startTime, 
[09:29:52.493]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:52.493]             version = "1.8"), class = "FutureResult")
[09:29:52.493]     }, finally = {
[09:29:52.493]         if (!identical(...future.workdir, getwd())) 
[09:29:52.493]             setwd(...future.workdir)
[09:29:52.493]         {
[09:29:52.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:52.493]                 ...future.oldOptions$nwarnings <- NULL
[09:29:52.493]             }
[09:29:52.493]             base::options(...future.oldOptions)
[09:29:52.493]             if (.Platform$OS.type == "windows") {
[09:29:52.493]                 old_names <- names(...future.oldEnvVars)
[09:29:52.493]                 envs <- base::Sys.getenv()
[09:29:52.493]                 names <- names(envs)
[09:29:52.493]                 common <- intersect(names, old_names)
[09:29:52.493]                 added <- setdiff(names, old_names)
[09:29:52.493]                 removed <- setdiff(old_names, names)
[09:29:52.493]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:52.493]                   envs[common]]
[09:29:52.493]                 NAMES <- toupper(changed)
[09:29:52.493]                 args <- list()
[09:29:52.493]                 for (kk in seq_along(NAMES)) {
[09:29:52.493]                   name <- changed[[kk]]
[09:29:52.493]                   NAME <- NAMES[[kk]]
[09:29:52.493]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.493]                     next
[09:29:52.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.493]                 }
[09:29:52.493]                 NAMES <- toupper(added)
[09:29:52.493]                 for (kk in seq_along(NAMES)) {
[09:29:52.493]                   name <- added[[kk]]
[09:29:52.493]                   NAME <- NAMES[[kk]]
[09:29:52.493]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.493]                     next
[09:29:52.493]                   args[[name]] <- ""
[09:29:52.493]                 }
[09:29:52.493]                 NAMES <- toupper(removed)
[09:29:52.493]                 for (kk in seq_along(NAMES)) {
[09:29:52.493]                   name <- removed[[kk]]
[09:29:52.493]                   NAME <- NAMES[[kk]]
[09:29:52.493]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.493]                     next
[09:29:52.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.493]                 }
[09:29:52.493]                 if (length(args) > 0) 
[09:29:52.493]                   base::do.call(base::Sys.setenv, args = args)
[09:29:52.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:52.493]             }
[09:29:52.493]             else {
[09:29:52.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:52.493]             }
[09:29:52.493]             {
[09:29:52.493]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:52.493]                   0L) {
[09:29:52.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:52.493]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:52.493]                   base::options(opts)
[09:29:52.493]                 }
[09:29:52.493]                 {
[09:29:52.493]                   {
[09:29:52.493]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:52.493]                     NULL
[09:29:52.493]                   }
[09:29:52.493]                   options(future.plan = NULL)
[09:29:52.493]                   if (is.na(NA_character_)) 
[09:29:52.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:52.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:52.493]                     .init = FALSE)
[09:29:52.493]                 }
[09:29:52.493]             }
[09:29:52.493]         }
[09:29:52.493]     })
[09:29:52.493]     if (TRUE) {
[09:29:52.493]         base::sink(type = "output", split = FALSE)
[09:29:52.493]         if (TRUE) {
[09:29:52.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:52.493]         }
[09:29:52.493]         else {
[09:29:52.493]             ...future.result["stdout"] <- base::list(NULL)
[09:29:52.493]         }
[09:29:52.493]         base::close(...future.stdout)
[09:29:52.493]         ...future.stdout <- NULL
[09:29:52.493]     }
[09:29:52.493]     ...future.result$conditions <- ...future.conditions
[09:29:52.493]     ...future.result$finished <- base::Sys.time()
[09:29:52.493]     ...future.result
[09:29:52.493] }
[09:29:52.495] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[09:29:52.495] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[09:29:52.536] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[09:29:52.536] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:52.537] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.537] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[09:29:52.537] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[09:29:52.538] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:52.538] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.538] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:52.538] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.539] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[09:29:52.539] MultisessionFuture started
[09:29:52.539] - Launch lazy future ... done
[09:29:52.539] run() for ‘MultisessionFuture’ ... done
[09:29:52.539] Created future:
[09:29:52.541] receiveMessageFromWorker() for ClusterFuture ...
[09:29:52.541] - Validating connection of MultisessionFuture
[09:29:52.541] - received message: FutureResult
[09:29:52.541] - Received FutureResult
[09:29:52.541] - Erased future from FutureRegistry
[09:29:52.541] result() for ClusterFuture ...
[09:29:52.542] - result already collected: FutureResult
[09:29:52.542] result() for ClusterFuture ... done
[09:29:52.542] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:52.539] MultisessionFuture:
[09:29:52.539] Label: ‘future_sapply-1’
[09:29:52.539] Expression:
[09:29:52.539] {
[09:29:52.539]     do.call(function(...) {
[09:29:52.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.539]             on.exit(options(oopts), add = TRUE)
[09:29:52.539]         }
[09:29:52.539]         {
[09:29:52.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.539]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.539]             })
[09:29:52.539]         }
[09:29:52.539]     }, args = future.call.arguments)
[09:29:52.539] }
[09:29:52.539] Lazy evaluation: FALSE
[09:29:52.539] Asynchronous evaluation: TRUE
[09:29:52.539] Local evaluation: TRUE
[09:29:52.539] Environment: R_GlobalEnv
[09:29:52.539] Capture standard output: TRUE
[09:29:52.539] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:52.539] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:52.539] Packages: 1 packages (‘stats’)
[09:29:52.539] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:52.539] Resolved: TRUE
[09:29:52.539] Value: <not collected>
[09:29:52.539] Conditions captured: <none>
[09:29:52.539] Early signaling: FALSE
[09:29:52.539] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:52.539] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.542] Chunk #1 of 2 ... DONE
[09:29:52.542] Chunk #2 of 2 ...
[09:29:52.542]  - Finding globals in 'X' for chunk #2 ...
[09:29:52.542] getGlobalsAndPackages() ...
[09:29:52.542] Searching for globals...
[09:29:52.543] 
[09:29:52.543] Searching for globals ... DONE
[09:29:52.543] - globals: [0] <none>
[09:29:52.543] getGlobalsAndPackages() ... DONE
[09:29:52.543]    + additional globals found: [n=0] 
[09:29:52.543]    + additional namespaces needed: [n=0] 
[09:29:52.543]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:52.543]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:52.543]  - seeds: <none>
[09:29:52.543]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.543] getGlobalsAndPackages() ...
[09:29:52.544] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.544] Resolving globals: FALSE
[09:29:52.544] Tweak future expression to call with '...' arguments ...
[09:29:52.544] {
[09:29:52.544]     do.call(function(...) {
[09:29:52.544]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.544]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.544]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.544]             on.exit(options(oopts), add = TRUE)
[09:29:52.544]         }
[09:29:52.544]         {
[09:29:52.544]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.544]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.544]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.544]             })
[09:29:52.544]         }
[09:29:52.544]     }, args = future.call.arguments)
[09:29:52.544] }
[09:29:52.544] Tweak future expression to call with '...' arguments ... DONE
[09:29:52.545] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.545] - packages: [1] ‘stats’
[09:29:52.545] getGlobalsAndPackages() ... DONE
[09:29:52.545] run() for ‘Future’ ...
[09:29:52.545] - state: ‘created’
[09:29:52.545] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:52.559] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:52.559]   - Field: ‘node’
[09:29:52.559]   - Field: ‘label’
[09:29:52.559]   - Field: ‘local’
[09:29:52.559]   - Field: ‘owner’
[09:29:52.559]   - Field: ‘envir’
[09:29:52.559]   - Field: ‘workers’
[09:29:52.560]   - Field: ‘packages’
[09:29:52.560]   - Field: ‘gc’
[09:29:52.560]   - Field: ‘conditions’
[09:29:52.560]   - Field: ‘persistent’
[09:29:52.560]   - Field: ‘expr’
[09:29:52.560]   - Field: ‘uuid’
[09:29:52.560]   - Field: ‘seed’
[09:29:52.560]   - Field: ‘version’
[09:29:52.560]   - Field: ‘result’
[09:29:52.560]   - Field: ‘asynchronous’
[09:29:52.560]   - Field: ‘calls’
[09:29:52.561]   - Field: ‘globals’
[09:29:52.561]   - Field: ‘stdout’
[09:29:52.563]   - Field: ‘earlySignal’
[09:29:52.563]   - Field: ‘lazy’
[09:29:52.563]   - Field: ‘state’
[09:29:52.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:52.563] - Launch lazy future ...
[09:29:52.563] Packages needed by the future expression (n = 1): ‘stats’
[09:29:52.564] Packages needed by future strategies (n = 0): <none>
[09:29:52.564] {
[09:29:52.564]     {
[09:29:52.564]         {
[09:29:52.564]             ...future.startTime <- base::Sys.time()
[09:29:52.564]             {
[09:29:52.564]                 {
[09:29:52.564]                   {
[09:29:52.564]                     {
[09:29:52.564]                       {
[09:29:52.564]                         base::local({
[09:29:52.564]                           has_future <- base::requireNamespace("future", 
[09:29:52.564]                             quietly = TRUE)
[09:29:52.564]                           if (has_future) {
[09:29:52.564]                             ns <- base::getNamespace("future")
[09:29:52.564]                             version <- ns[[".package"]][["version"]]
[09:29:52.564]                             if (is.null(version)) 
[09:29:52.564]                               version <- utils::packageVersion("future")
[09:29:52.564]                           }
[09:29:52.564]                           else {
[09:29:52.564]                             version <- NULL
[09:29:52.564]                           }
[09:29:52.564]                           if (!has_future || version < "1.8.0") {
[09:29:52.564]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:52.564]                               "", base::R.version$version.string), 
[09:29:52.564]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:52.564]                                 base::R.version$platform, 8 * 
[09:29:52.564]                                   base::.Machine$sizeof.pointer), 
[09:29:52.564]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:52.564]                                 "release", "version")], collapse = " "), 
[09:29:52.564]                               hostname = base::Sys.info()[["nodename"]])
[09:29:52.564]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:52.564]                               info)
[09:29:52.564]                             info <- base::paste(info, collapse = "; ")
[09:29:52.564]                             if (!has_future) {
[09:29:52.564]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:52.564]                                 info)
[09:29:52.564]                             }
[09:29:52.564]                             else {
[09:29:52.564]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:52.564]                                 info, version)
[09:29:52.564]                             }
[09:29:52.564]                             base::stop(msg)
[09:29:52.564]                           }
[09:29:52.564]                         })
[09:29:52.564]                       }
[09:29:52.564]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:52.564]                       base::options(mc.cores = 1L)
[09:29:52.564]                     }
[09:29:52.564]                     base::local({
[09:29:52.564]                       for (pkg in "stats") {
[09:29:52.564]                         base::loadNamespace(pkg)
[09:29:52.564]                         base::library(pkg, character.only = TRUE)
[09:29:52.564]                       }
[09:29:52.564]                     })
[09:29:52.564]                   }
[09:29:52.564]                   ...future.strategy.old <- future::plan("list")
[09:29:52.564]                   options(future.plan = NULL)
[09:29:52.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:52.564]                 }
[09:29:52.564]                 ...future.workdir <- getwd()
[09:29:52.564]             }
[09:29:52.564]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:52.564]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:52.564]         }
[09:29:52.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:52.564]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:52.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:52.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:52.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:52.564]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:52.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:52.564]             base::names(...future.oldOptions))
[09:29:52.564]     }
[09:29:52.564]     if (FALSE) {
[09:29:52.564]     }
[09:29:52.564]     else {
[09:29:52.564]         if (TRUE) {
[09:29:52.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:52.564]                 open = "w")
[09:29:52.564]         }
[09:29:52.564]         else {
[09:29:52.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:52.564]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:52.564]         }
[09:29:52.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:52.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:52.564]             base::sink(type = "output", split = FALSE)
[09:29:52.564]             base::close(...future.stdout)
[09:29:52.564]         }, add = TRUE)
[09:29:52.564]     }
[09:29:52.564]     ...future.frame <- base::sys.nframe()
[09:29:52.564]     ...future.conditions <- base::list()
[09:29:52.564]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:52.564]     if (FALSE) {
[09:29:52.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:52.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:52.564]     }
[09:29:52.564]     ...future.result <- base::tryCatch({
[09:29:52.564]         base::withCallingHandlers({
[09:29:52.564]             ...future.value <- base::withVisible(base::local({
[09:29:52.564]                 ...future.makeSendCondition <- base::local({
[09:29:52.564]                   sendCondition <- NULL
[09:29:52.564]                   function(frame = 1L) {
[09:29:52.564]                     if (is.function(sendCondition)) 
[09:29:52.564]                       return(sendCondition)
[09:29:52.564]                     ns <- getNamespace("parallel")
[09:29:52.564]                     if (exists("sendData", mode = "function", 
[09:29:52.564]                       envir = ns)) {
[09:29:52.564]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:52.564]                         envir = ns)
[09:29:52.564]                       envir <- sys.frame(frame)
[09:29:52.564]                       master <- NULL
[09:29:52.564]                       while (!identical(envir, .GlobalEnv) && 
[09:29:52.564]                         !identical(envir, emptyenv())) {
[09:29:52.564]                         if (exists("master", mode = "list", envir = envir, 
[09:29:52.564]                           inherits = FALSE)) {
[09:29:52.564]                           master <- get("master", mode = "list", 
[09:29:52.564]                             envir = envir, inherits = FALSE)
[09:29:52.564]                           if (inherits(master, c("SOCKnode", 
[09:29:52.564]                             "SOCK0node"))) {
[09:29:52.564]                             sendCondition <<- function(cond) {
[09:29:52.564]                               data <- list(type = "VALUE", value = cond, 
[09:29:52.564]                                 success = TRUE)
[09:29:52.564]                               parallel_sendData(master, data)
[09:29:52.564]                             }
[09:29:52.564]                             return(sendCondition)
[09:29:52.564]                           }
[09:29:52.564]                         }
[09:29:52.564]                         frame <- frame + 1L
[09:29:52.564]                         envir <- sys.frame(frame)
[09:29:52.564]                       }
[09:29:52.564]                     }
[09:29:52.564]                     sendCondition <<- function(cond) NULL
[09:29:52.564]                   }
[09:29:52.564]                 })
[09:29:52.564]                 withCallingHandlers({
[09:29:52.564]                   {
[09:29:52.564]                     do.call(function(...) {
[09:29:52.564]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.564]                       if (!identical(...future.globals.maxSize.org, 
[09:29:52.564]                         ...future.globals.maxSize)) {
[09:29:52.564]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.564]                         on.exit(options(oopts), add = TRUE)
[09:29:52.564]                       }
[09:29:52.564]                       {
[09:29:52.564]                         lapply(seq_along(...future.elements_ii), 
[09:29:52.564]                           FUN = function(jj) {
[09:29:52.564]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.564]                             ...future.FUN(...future.X_jj, ...)
[09:29:52.564]                           })
[09:29:52.564]                       }
[09:29:52.564]                     }, args = future.call.arguments)
[09:29:52.564]                   }
[09:29:52.564]                 }, immediateCondition = function(cond) {
[09:29:52.564]                   sendCondition <- ...future.makeSendCondition()
[09:29:52.564]                   sendCondition(cond)
[09:29:52.564]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.564]                   {
[09:29:52.564]                     inherits <- base::inherits
[09:29:52.564]                     invokeRestart <- base::invokeRestart
[09:29:52.564]                     is.null <- base::is.null
[09:29:52.564]                     muffled <- FALSE
[09:29:52.564]                     if (inherits(cond, "message")) {
[09:29:52.564]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:52.564]                       if (muffled) 
[09:29:52.564]                         invokeRestart("muffleMessage")
[09:29:52.564]                     }
[09:29:52.564]                     else if (inherits(cond, "warning")) {
[09:29:52.564]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:52.564]                       if (muffled) 
[09:29:52.564]                         invokeRestart("muffleWarning")
[09:29:52.564]                     }
[09:29:52.564]                     else if (inherits(cond, "condition")) {
[09:29:52.564]                       if (!is.null(pattern)) {
[09:29:52.564]                         computeRestarts <- base::computeRestarts
[09:29:52.564]                         grepl <- base::grepl
[09:29:52.564]                         restarts <- computeRestarts(cond)
[09:29:52.564]                         for (restart in restarts) {
[09:29:52.564]                           name <- restart$name
[09:29:52.564]                           if (is.null(name)) 
[09:29:52.564]                             next
[09:29:52.564]                           if (!grepl(pattern, name)) 
[09:29:52.564]                             next
[09:29:52.564]                           invokeRestart(restart)
[09:29:52.564]                           muffled <- TRUE
[09:29:52.564]                           break
[09:29:52.564]                         }
[09:29:52.564]                       }
[09:29:52.564]                     }
[09:29:52.564]                     invisible(muffled)
[09:29:52.564]                   }
[09:29:52.564]                   muffleCondition(cond)
[09:29:52.564]                 })
[09:29:52.564]             }))
[09:29:52.564]             future::FutureResult(value = ...future.value$value, 
[09:29:52.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.564]                   ...future.rng), globalenv = if (FALSE) 
[09:29:52.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:52.564]                     ...future.globalenv.names))
[09:29:52.564]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:52.564]         }, condition = base::local({
[09:29:52.564]             c <- base::c
[09:29:52.564]             inherits <- base::inherits
[09:29:52.564]             invokeRestart <- base::invokeRestart
[09:29:52.564]             length <- base::length
[09:29:52.564]             list <- base::list
[09:29:52.564]             seq.int <- base::seq.int
[09:29:52.564]             signalCondition <- base::signalCondition
[09:29:52.564]             sys.calls <- base::sys.calls
[09:29:52.564]             `[[` <- base::`[[`
[09:29:52.564]             `+` <- base::`+`
[09:29:52.564]             `<<-` <- base::`<<-`
[09:29:52.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:52.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:52.564]                   3L)]
[09:29:52.564]             }
[09:29:52.564]             function(cond) {
[09:29:52.564]                 is_error <- inherits(cond, "error")
[09:29:52.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:52.564]                   NULL)
[09:29:52.564]                 if (is_error) {
[09:29:52.564]                   sessionInformation <- function() {
[09:29:52.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:52.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:52.564]                       search = base::search(), system = base::Sys.info())
[09:29:52.564]                   }
[09:29:52.564]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:52.564]                     cond$call), session = sessionInformation(), 
[09:29:52.564]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:52.564]                   signalCondition(cond)
[09:29:52.564]                 }
[09:29:52.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:52.564]                 "immediateCondition"))) {
[09:29:52.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:52.564]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:52.564]                   if (TRUE && !signal) {
[09:29:52.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.564]                     {
[09:29:52.564]                       inherits <- base::inherits
[09:29:52.564]                       invokeRestart <- base::invokeRestart
[09:29:52.564]                       is.null <- base::is.null
[09:29:52.564]                       muffled <- FALSE
[09:29:52.564]                       if (inherits(cond, "message")) {
[09:29:52.564]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.564]                         if (muffled) 
[09:29:52.564]                           invokeRestart("muffleMessage")
[09:29:52.564]                       }
[09:29:52.564]                       else if (inherits(cond, "warning")) {
[09:29:52.564]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.564]                         if (muffled) 
[09:29:52.564]                           invokeRestart("muffleWarning")
[09:29:52.564]                       }
[09:29:52.564]                       else if (inherits(cond, "condition")) {
[09:29:52.564]                         if (!is.null(pattern)) {
[09:29:52.564]                           computeRestarts <- base::computeRestarts
[09:29:52.564]                           grepl <- base::grepl
[09:29:52.564]                           restarts <- computeRestarts(cond)
[09:29:52.564]                           for (restart in restarts) {
[09:29:52.564]                             name <- restart$name
[09:29:52.564]                             if (is.null(name)) 
[09:29:52.564]                               next
[09:29:52.564]                             if (!grepl(pattern, name)) 
[09:29:52.564]                               next
[09:29:52.564]                             invokeRestart(restart)
[09:29:52.564]                             muffled <- TRUE
[09:29:52.564]                             break
[09:29:52.564]                           }
[09:29:52.564]                         }
[09:29:52.564]                       }
[09:29:52.564]                       invisible(muffled)
[09:29:52.564]                     }
[09:29:52.564]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.564]                   }
[09:29:52.564]                 }
[09:29:52.564]                 else {
[09:29:52.564]                   if (TRUE) {
[09:29:52.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.564]                     {
[09:29:52.564]                       inherits <- base::inherits
[09:29:52.564]                       invokeRestart <- base::invokeRestart
[09:29:52.564]                       is.null <- base::is.null
[09:29:52.564]                       muffled <- FALSE
[09:29:52.564]                       if (inherits(cond, "message")) {
[09:29:52.564]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.564]                         if (muffled) 
[09:29:52.564]                           invokeRestart("muffleMessage")
[09:29:52.564]                       }
[09:29:52.564]                       else if (inherits(cond, "warning")) {
[09:29:52.564]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.564]                         if (muffled) 
[09:29:52.564]                           invokeRestart("muffleWarning")
[09:29:52.564]                       }
[09:29:52.564]                       else if (inherits(cond, "condition")) {
[09:29:52.564]                         if (!is.null(pattern)) {
[09:29:52.564]                           computeRestarts <- base::computeRestarts
[09:29:52.564]                           grepl <- base::grepl
[09:29:52.564]                           restarts <- computeRestarts(cond)
[09:29:52.564]                           for (restart in restarts) {
[09:29:52.564]                             name <- restart$name
[09:29:52.564]                             if (is.null(name)) 
[09:29:52.564]                               next
[09:29:52.564]                             if (!grepl(pattern, name)) 
[09:29:52.564]                               next
[09:29:52.564]                             invokeRestart(restart)
[09:29:52.564]                             muffled <- TRUE
[09:29:52.564]                             break
[09:29:52.564]                           }
[09:29:52.564]                         }
[09:29:52.564]                       }
[09:29:52.564]                       invisible(muffled)
[09:29:52.564]                     }
[09:29:52.564]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.564]                   }
[09:29:52.564]                 }
[09:29:52.564]             }
[09:29:52.564]         }))
[09:29:52.564]     }, error = function(ex) {
[09:29:52.564]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:52.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.564]                 ...future.rng), started = ...future.startTime, 
[09:29:52.564]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:52.564]             version = "1.8"), class = "FutureResult")
[09:29:52.564]     }, finally = {
[09:29:52.564]         if (!identical(...future.workdir, getwd())) 
[09:29:52.564]             setwd(...future.workdir)
[09:29:52.564]         {
[09:29:52.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:52.564]                 ...future.oldOptions$nwarnings <- NULL
[09:29:52.564]             }
[09:29:52.564]             base::options(...future.oldOptions)
[09:29:52.564]             if (.Platform$OS.type == "windows") {
[09:29:52.564]                 old_names <- names(...future.oldEnvVars)
[09:29:52.564]                 envs <- base::Sys.getenv()
[09:29:52.564]                 names <- names(envs)
[09:29:52.564]                 common <- intersect(names, old_names)
[09:29:52.564]                 added <- setdiff(names, old_names)
[09:29:52.564]                 removed <- setdiff(old_names, names)
[09:29:52.564]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:52.564]                   envs[common]]
[09:29:52.564]                 NAMES <- toupper(changed)
[09:29:52.564]                 args <- list()
[09:29:52.564]                 for (kk in seq_along(NAMES)) {
[09:29:52.564]                   name <- changed[[kk]]
[09:29:52.564]                   NAME <- NAMES[[kk]]
[09:29:52.564]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.564]                     next
[09:29:52.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.564]                 }
[09:29:52.564]                 NAMES <- toupper(added)
[09:29:52.564]                 for (kk in seq_along(NAMES)) {
[09:29:52.564]                   name <- added[[kk]]
[09:29:52.564]                   NAME <- NAMES[[kk]]
[09:29:52.564]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.564]                     next
[09:29:52.564]                   args[[name]] <- ""
[09:29:52.564]                 }
[09:29:52.564]                 NAMES <- toupper(removed)
[09:29:52.564]                 for (kk in seq_along(NAMES)) {
[09:29:52.564]                   name <- removed[[kk]]
[09:29:52.564]                   NAME <- NAMES[[kk]]
[09:29:52.564]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.564]                     next
[09:29:52.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.564]                 }
[09:29:52.564]                 if (length(args) > 0) 
[09:29:52.564]                   base::do.call(base::Sys.setenv, args = args)
[09:29:52.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:52.564]             }
[09:29:52.564]             else {
[09:29:52.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:52.564]             }
[09:29:52.564]             {
[09:29:52.564]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:52.564]                   0L) {
[09:29:52.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:52.564]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:52.564]                   base::options(opts)
[09:29:52.564]                 }
[09:29:52.564]                 {
[09:29:52.564]                   {
[09:29:52.564]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:52.564]                     NULL
[09:29:52.564]                   }
[09:29:52.564]                   options(future.plan = NULL)
[09:29:52.564]                   if (is.na(NA_character_)) 
[09:29:52.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:52.564]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:52.564]                     .init = FALSE)
[09:29:52.564]                 }
[09:29:52.564]             }
[09:29:52.564]         }
[09:29:52.564]     })
[09:29:52.564]     if (TRUE) {
[09:29:52.564]         base::sink(type = "output", split = FALSE)
[09:29:52.564]         if (TRUE) {
[09:29:52.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:52.564]         }
[09:29:52.564]         else {
[09:29:52.564]             ...future.result["stdout"] <- base::list(NULL)
[09:29:52.564]         }
[09:29:52.564]         base::close(...future.stdout)
[09:29:52.564]         ...future.stdout <- NULL
[09:29:52.564]     }
[09:29:52.564]     ...future.result$conditions <- ...future.conditions
[09:29:52.564]     ...future.result$finished <- base::Sys.time()
[09:29:52.564]     ...future.result
[09:29:52.564] }
[09:29:52.567] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[09:29:52.567] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[09:29:52.608] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[09:29:52.608] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:52.609] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.609] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #1 ...
[09:29:52.609] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #1 ... DONE
[09:29:52.609] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:52.610] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.610] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:52.610] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.610] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[09:29:52.611] MultisessionFuture started
[09:29:52.611] - Launch lazy future ... done
[09:29:52.611] run() for ‘MultisessionFuture’ ... done
[09:29:52.611] Created future:
[09:29:52.612] receiveMessageFromWorker() for ClusterFuture ...
[09:29:52.613] - Validating connection of MultisessionFuture
[09:29:52.613] - received message: FutureResult
[09:29:52.613] - Received FutureResult
[09:29:52.613] - Erased future from FutureRegistry
[09:29:52.613] result() for ClusterFuture ...
[09:29:52.613] - result already collected: FutureResult
[09:29:52.613] result() for ClusterFuture ... done
[09:29:52.613] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:52.611] MultisessionFuture:
[09:29:52.611] Label: ‘future_sapply-2’
[09:29:52.611] Expression:
[09:29:52.611] {
[09:29:52.611]     do.call(function(...) {
[09:29:52.611]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.611]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.611]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.611]             on.exit(options(oopts), add = TRUE)
[09:29:52.611]         }
[09:29:52.611]         {
[09:29:52.611]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.611]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.611]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.611]             })
[09:29:52.611]         }
[09:29:52.611]     }, args = future.call.arguments)
[09:29:52.611] }
[09:29:52.611] Lazy evaluation: FALSE
[09:29:52.611] Asynchronous evaluation: TRUE
[09:29:52.611] Local evaluation: TRUE
[09:29:52.611] Environment: R_GlobalEnv
[09:29:52.611] Capture standard output: TRUE
[09:29:52.611] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:52.611] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:52.611] Packages: 1 packages (‘stats’)
[09:29:52.611] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:52.611] Resolved: TRUE
[09:29:52.611] Value: <not collected>
[09:29:52.611] Conditions captured: <none>
[09:29:52.611] Early signaling: FALSE
[09:29:52.611] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:52.611] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.613] Chunk #2 of 2 ... DONE
[09:29:52.614] Launching 2 futures (chunks) ... DONE
[09:29:52.614] Resolving 2 futures (chunks) ...
[09:29:52.614] resolve() on list ...
[09:29:52.614]  recursive: 0
[09:29:52.614]  length: 2
[09:29:52.614] 
[09:29:52.614] Future #1
[09:29:52.614] result() for ClusterFuture ...
[09:29:52.614] - result already collected: FutureResult
[09:29:52.614] result() for ClusterFuture ... done
[09:29:52.614] result() for ClusterFuture ...
[09:29:52.615] - result already collected: FutureResult
[09:29:52.615] result() for ClusterFuture ... done
[09:29:52.615] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:52.615] - nx: 2
[09:29:52.615] - relay: TRUE
[09:29:52.615] - stdout: TRUE
[09:29:52.615] - signal: TRUE
[09:29:52.615] - resignal: FALSE
[09:29:52.615] - force: TRUE
[09:29:52.615] - relayed: [n=2] FALSE, FALSE
[09:29:52.615] - queued futures: [n=2] FALSE, FALSE
[09:29:52.615]  - until=1
[09:29:52.616]  - relaying element #1
[09:29:52.616] result() for ClusterFuture ...
[09:29:52.616] - result already collected: FutureResult
[09:29:52.616] result() for ClusterFuture ... done
[09:29:52.616] result() for ClusterFuture ...
[09:29:52.616] - result already collected: FutureResult
[09:29:52.616] result() for ClusterFuture ... done
[09:29:52.616] result() for ClusterFuture ...
[09:29:52.616] - result already collected: FutureResult
[09:29:52.616] result() for ClusterFuture ... done
[09:29:52.616] result() for ClusterFuture ...
[09:29:52.617] - result already collected: FutureResult
[09:29:52.617] result() for ClusterFuture ... done
[09:29:52.617] - relayed: [n=2] TRUE, FALSE
[09:29:52.617] - queued futures: [n=2] TRUE, FALSE
[09:29:52.617] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:52.617]  length: 1 (resolved future 1)
[09:29:52.617] Future #2
[09:29:52.617] result() for ClusterFuture ...
[09:29:52.617] - result already collected: FutureResult
[09:29:52.617] result() for ClusterFuture ... done
[09:29:52.617] result() for ClusterFuture ...
[09:29:52.617] - result already collected: FutureResult
[09:29:52.618] result() for ClusterFuture ... done
[09:29:52.618] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:52.618] - nx: 2
[09:29:52.618] - relay: TRUE
[09:29:52.618] - stdout: TRUE
[09:29:52.618] - signal: TRUE
[09:29:52.618] - resignal: FALSE
[09:29:52.618] - force: TRUE
[09:29:52.618] - relayed: [n=2] TRUE, FALSE
[09:29:52.618] - queued futures: [n=2] TRUE, FALSE
[09:29:52.618]  - until=2
[09:29:52.618]  - relaying element #2
[09:29:52.619] result() for ClusterFuture ...
[09:29:52.619] - result already collected: FutureResult
[09:29:52.619] result() for ClusterFuture ... done
[09:29:52.619] result() for ClusterFuture ...
[09:29:52.619] - result already collected: FutureResult
[09:29:52.619] result() for ClusterFuture ... done
[09:29:52.619] result() for ClusterFuture ...
[09:29:52.619] - result already collected: FutureResult
[09:29:52.619] result() for ClusterFuture ... done
[09:29:52.619] result() for ClusterFuture ...
[09:29:52.619] - result already collected: FutureResult
[09:29:52.619] result() for ClusterFuture ... done
[09:29:52.620] - relayed: [n=2] TRUE, TRUE
[09:29:52.620] - queued futures: [n=2] TRUE, TRUE
[09:29:52.620] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:52.620]  length: 0 (resolved future 2)
[09:29:52.620] Relaying remaining futures
[09:29:52.620] signalConditionsASAP(NULL, pos=0) ...
[09:29:52.620] - nx: 2
[09:29:52.620] - relay: TRUE
[09:29:52.620] - stdout: TRUE
[09:29:52.620] - signal: TRUE
[09:29:52.620] - resignal: FALSE
[09:29:52.621] - force: TRUE
[09:29:52.621] - relayed: [n=2] TRUE, TRUE
[09:29:52.621] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:52.621] - relayed: [n=2] TRUE, TRUE
[09:29:52.621] - queued futures: [n=2] TRUE, TRUE
[09:29:52.621] signalConditionsASAP(NULL, pos=0) ... done
[09:29:52.621] resolve() on list ... DONE
[09:29:52.621] result() for ClusterFuture ...
[09:29:52.621] - result already collected: FutureResult
[09:29:52.621] result() for ClusterFuture ... done
[09:29:52.621] result() for ClusterFuture ...
[09:29:52.622] - result already collected: FutureResult
[09:29:52.622] result() for ClusterFuture ... done
[09:29:52.622] result() for ClusterFuture ...
[09:29:52.622] - result already collected: FutureResult
[09:29:52.622] result() for ClusterFuture ... done
[09:29:52.622] result() for ClusterFuture ...
[09:29:52.622] - result already collected: FutureResult
[09:29:52.622] result() for ClusterFuture ... done
[09:29:52.622]  - Number of value chunks collected: 2
[09:29:52.622] Resolving 2 futures (chunks) ... DONE
[09:29:52.622] Reducing values from 2 chunks ...
[09:29:52.623]  - Number of values collected after concatenation: 7
[09:29:52.623]  - Number of values expected: 7
[09:29:52.623] Reducing values from 2 chunks ... DONE
[09:29:52.623] future_lapply() ... DONE
[09:29:52.623] future_lapply() ...
[09:29:52.628] Number of chunks: 2
[09:29:52.628] getGlobalsAndPackagesXApply() ...
[09:29:52.629]  - future.globals: TRUE
[09:29:52.629] getGlobalsAndPackages() ...
[09:29:52.629] Searching for globals...
[09:29:52.636] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[09:29:52.636] Searching for globals ... DONE
[09:29:52.636] Resolving globals: FALSE
[09:29:52.637] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[09:29:52.638] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[09:29:52.638] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:52.638] - packages: [2] ‘stats’, ‘future.apply’
[09:29:52.638] getGlobalsAndPackages() ... DONE
[09:29:52.638]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:52.638]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[09:29:52.638] Finding globals ... DONE
[09:29:52.638]  - use_args: TRUE
[09:29:52.638]  - Getting '...' globals ...
[09:29:52.639] resolve() on list ...
[09:29:52.639]  recursive: 0
[09:29:52.639]  length: 1
[09:29:52.639]  elements: ‘...’
[09:29:52.639]  length: 0 (resolved future 1)
[09:29:52.639] resolve() on list ... DONE
[09:29:52.639]    - '...' content: [n=0] 
[09:29:52.639] List of 1
[09:29:52.639]  $ ...: list()
[09:29:52.639]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:52.639]  - attr(*, "where")=List of 1
[09:29:52.639]   ..$ ...:<environment: 0x561d35da16f8> 
[09:29:52.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:52.639]  - attr(*, "resolved")= logi TRUE
[09:29:52.639]  - attr(*, "total_size")= num NA
[09:29:52.642]  - Getting '...' globals ... DONE
[09:29:52.642] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:52.642] List of 8
[09:29:52.642]  $ ...future.FUN:function (x, ...)  
[09:29:52.642]  $ x_FUN        :function (x, na.rm = TRUE)  
[09:29:52.642]  $ times        : int 5
[09:29:52.642]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:52.642]  $ stop_if_not  :function (...)  
[09:29:52.642]  $ dim          : NULL
[09:29:52.642]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:52.642]  $ ...          : list()
[09:29:52.642]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:52.642]  - attr(*, "where")=List of 8
[09:29:52.642]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:52.642]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:52.642]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:52.642]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:52.642]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:52.642]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:52.642]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:52.642]   ..$ ...          :<environment: 0x561d35da16f8> 
[09:29:52.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:52.642]  - attr(*, "resolved")= logi FALSE
[09:29:52.642]  - attr(*, "total_size")= num 141240
[09:29:52.647] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[09:29:52.647] getGlobalsAndPackagesXApply() ... DONE
[09:29:52.648] Number of futures (= number of chunks): 2
[09:29:52.648] Launching 2 futures (chunks) ...
[09:29:52.648] Chunk #1 of 2 ...
[09:29:52.648]  - Finding globals in 'X' for chunk #1 ...
[09:29:52.648] getGlobalsAndPackages() ...
[09:29:52.648] Searching for globals...
[09:29:52.648] 
[09:29:52.648] Searching for globals ... DONE
[09:29:52.648] - globals: [0] <none>
[09:29:52.649] getGlobalsAndPackages() ... DONE
[09:29:52.649]    + additional globals found: [n=0] 
[09:29:52.649]    + additional namespaces needed: [n=0] 
[09:29:52.649]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:52.649]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:52.649]  - seeds: <none>
[09:29:52.649]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.649] getGlobalsAndPackages() ...
[09:29:52.649] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.649] Resolving globals: FALSE
[09:29:52.650] Tweak future expression to call with '...' arguments ...
[09:29:52.650] {
[09:29:52.650]     do.call(function(...) {
[09:29:52.650]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.650]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.650]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.650]             on.exit(options(oopts), add = TRUE)
[09:29:52.650]         }
[09:29:52.650]         {
[09:29:52.650]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.650]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.650]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.650]             })
[09:29:52.650]         }
[09:29:52.650]     }, args = future.call.arguments)
[09:29:52.650] }
[09:29:52.650] Tweak future expression to call with '...' arguments ... DONE
[09:29:52.650] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.650] - packages: [2] ‘stats’, ‘future.apply’
[09:29:52.651] getGlobalsAndPackages() ... DONE
[09:29:52.651] run() for ‘Future’ ...
[09:29:52.651] - state: ‘created’
[09:29:52.651] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:52.664] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.665] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:52.665]   - Field: ‘node’
[09:29:52.665]   - Field: ‘label’
[09:29:52.665]   - Field: ‘local’
[09:29:52.665]   - Field: ‘owner’
[09:29:52.665]   - Field: ‘envir’
[09:29:52.665]   - Field: ‘workers’
[09:29:52.665]   - Field: ‘packages’
[09:29:52.665]   - Field: ‘gc’
[09:29:52.665]   - Field: ‘conditions’
[09:29:52.666]   - Field: ‘persistent’
[09:29:52.666]   - Field: ‘expr’
[09:29:52.666]   - Field: ‘uuid’
[09:29:52.666]   - Field: ‘seed’
[09:29:52.666]   - Field: ‘version’
[09:29:52.666]   - Field: ‘result’
[09:29:52.666]   - Field: ‘asynchronous’
[09:29:52.666]   - Field: ‘calls’
[09:29:52.666]   - Field: ‘globals’
[09:29:52.666]   - Field: ‘stdout’
[09:29:52.666]   - Field: ‘earlySignal’
[09:29:52.667]   - Field: ‘lazy’
[09:29:52.667]   - Field: ‘state’
[09:29:52.667] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:52.667] - Launch lazy future ...
[09:29:52.667] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[09:29:52.667] Packages needed by future strategies (n = 0): <none>
[09:29:52.668] {
[09:29:52.668]     {
[09:29:52.668]         {
[09:29:52.668]             ...future.startTime <- base::Sys.time()
[09:29:52.668]             {
[09:29:52.668]                 {
[09:29:52.668]                   {
[09:29:52.668]                     {
[09:29:52.668]                       {
[09:29:52.668]                         base::local({
[09:29:52.668]                           has_future <- base::requireNamespace("future", 
[09:29:52.668]                             quietly = TRUE)
[09:29:52.668]                           if (has_future) {
[09:29:52.668]                             ns <- base::getNamespace("future")
[09:29:52.668]                             version <- ns[[".package"]][["version"]]
[09:29:52.668]                             if (is.null(version)) 
[09:29:52.668]                               version <- utils::packageVersion("future")
[09:29:52.668]                           }
[09:29:52.668]                           else {
[09:29:52.668]                             version <- NULL
[09:29:52.668]                           }
[09:29:52.668]                           if (!has_future || version < "1.8.0") {
[09:29:52.668]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:52.668]                               "", base::R.version$version.string), 
[09:29:52.668]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:52.668]                                 base::R.version$platform, 8 * 
[09:29:52.668]                                   base::.Machine$sizeof.pointer), 
[09:29:52.668]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:52.668]                                 "release", "version")], collapse = " "), 
[09:29:52.668]                               hostname = base::Sys.info()[["nodename"]])
[09:29:52.668]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:52.668]                               info)
[09:29:52.668]                             info <- base::paste(info, collapse = "; ")
[09:29:52.668]                             if (!has_future) {
[09:29:52.668]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:52.668]                                 info)
[09:29:52.668]                             }
[09:29:52.668]                             else {
[09:29:52.668]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:52.668]                                 info, version)
[09:29:52.668]                             }
[09:29:52.668]                             base::stop(msg)
[09:29:52.668]                           }
[09:29:52.668]                         })
[09:29:52.668]                       }
[09:29:52.668]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:52.668]                       base::options(mc.cores = 1L)
[09:29:52.668]                     }
[09:29:52.668]                     base::local({
[09:29:52.668]                       for (pkg in c("stats", "future.apply")) {
[09:29:52.668]                         base::loadNamespace(pkg)
[09:29:52.668]                         base::library(pkg, character.only = TRUE)
[09:29:52.668]                       }
[09:29:52.668]                     })
[09:29:52.668]                   }
[09:29:52.668]                   ...future.strategy.old <- future::plan("list")
[09:29:52.668]                   options(future.plan = NULL)
[09:29:52.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:52.668]                 }
[09:29:52.668]                 ...future.workdir <- getwd()
[09:29:52.668]             }
[09:29:52.668]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:52.668]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:52.668]         }
[09:29:52.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:52.668]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:52.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:52.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:52.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:52.668]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:52.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:52.668]             base::names(...future.oldOptions))
[09:29:52.668]     }
[09:29:52.668]     if (FALSE) {
[09:29:52.668]     }
[09:29:52.668]     else {
[09:29:52.668]         if (TRUE) {
[09:29:52.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:52.668]                 open = "w")
[09:29:52.668]         }
[09:29:52.668]         else {
[09:29:52.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:52.668]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:52.668]         }
[09:29:52.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:52.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:52.668]             base::sink(type = "output", split = FALSE)
[09:29:52.668]             base::close(...future.stdout)
[09:29:52.668]         }, add = TRUE)
[09:29:52.668]     }
[09:29:52.668]     ...future.frame <- base::sys.nframe()
[09:29:52.668]     ...future.conditions <- base::list()
[09:29:52.668]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:52.668]     if (FALSE) {
[09:29:52.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:52.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:52.668]     }
[09:29:52.668]     ...future.result <- base::tryCatch({
[09:29:52.668]         base::withCallingHandlers({
[09:29:52.668]             ...future.value <- base::withVisible(base::local({
[09:29:52.668]                 ...future.makeSendCondition <- base::local({
[09:29:52.668]                   sendCondition <- NULL
[09:29:52.668]                   function(frame = 1L) {
[09:29:52.668]                     if (is.function(sendCondition)) 
[09:29:52.668]                       return(sendCondition)
[09:29:52.668]                     ns <- getNamespace("parallel")
[09:29:52.668]                     if (exists("sendData", mode = "function", 
[09:29:52.668]                       envir = ns)) {
[09:29:52.668]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:52.668]                         envir = ns)
[09:29:52.668]                       envir <- sys.frame(frame)
[09:29:52.668]                       master <- NULL
[09:29:52.668]                       while (!identical(envir, .GlobalEnv) && 
[09:29:52.668]                         !identical(envir, emptyenv())) {
[09:29:52.668]                         if (exists("master", mode = "list", envir = envir, 
[09:29:52.668]                           inherits = FALSE)) {
[09:29:52.668]                           master <- get("master", mode = "list", 
[09:29:52.668]                             envir = envir, inherits = FALSE)
[09:29:52.668]                           if (inherits(master, c("SOCKnode", 
[09:29:52.668]                             "SOCK0node"))) {
[09:29:52.668]                             sendCondition <<- function(cond) {
[09:29:52.668]                               data <- list(type = "VALUE", value = cond, 
[09:29:52.668]                                 success = TRUE)
[09:29:52.668]                               parallel_sendData(master, data)
[09:29:52.668]                             }
[09:29:52.668]                             return(sendCondition)
[09:29:52.668]                           }
[09:29:52.668]                         }
[09:29:52.668]                         frame <- frame + 1L
[09:29:52.668]                         envir <- sys.frame(frame)
[09:29:52.668]                       }
[09:29:52.668]                     }
[09:29:52.668]                     sendCondition <<- function(cond) NULL
[09:29:52.668]                   }
[09:29:52.668]                 })
[09:29:52.668]                 withCallingHandlers({
[09:29:52.668]                   {
[09:29:52.668]                     do.call(function(...) {
[09:29:52.668]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.668]                       if (!identical(...future.globals.maxSize.org, 
[09:29:52.668]                         ...future.globals.maxSize)) {
[09:29:52.668]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.668]                         on.exit(options(oopts), add = TRUE)
[09:29:52.668]                       }
[09:29:52.668]                       {
[09:29:52.668]                         lapply(seq_along(...future.elements_ii), 
[09:29:52.668]                           FUN = function(jj) {
[09:29:52.668]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.668]                             ...future.FUN(...future.X_jj, ...)
[09:29:52.668]                           })
[09:29:52.668]                       }
[09:29:52.668]                     }, args = future.call.arguments)
[09:29:52.668]                   }
[09:29:52.668]                 }, immediateCondition = function(cond) {
[09:29:52.668]                   sendCondition <- ...future.makeSendCondition()
[09:29:52.668]                   sendCondition(cond)
[09:29:52.668]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.668]                   {
[09:29:52.668]                     inherits <- base::inherits
[09:29:52.668]                     invokeRestart <- base::invokeRestart
[09:29:52.668]                     is.null <- base::is.null
[09:29:52.668]                     muffled <- FALSE
[09:29:52.668]                     if (inherits(cond, "message")) {
[09:29:52.668]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:52.668]                       if (muffled) 
[09:29:52.668]                         invokeRestart("muffleMessage")
[09:29:52.668]                     }
[09:29:52.668]                     else if (inherits(cond, "warning")) {
[09:29:52.668]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:52.668]                       if (muffled) 
[09:29:52.668]                         invokeRestart("muffleWarning")
[09:29:52.668]                     }
[09:29:52.668]                     else if (inherits(cond, "condition")) {
[09:29:52.668]                       if (!is.null(pattern)) {
[09:29:52.668]                         computeRestarts <- base::computeRestarts
[09:29:52.668]                         grepl <- base::grepl
[09:29:52.668]                         restarts <- computeRestarts(cond)
[09:29:52.668]                         for (restart in restarts) {
[09:29:52.668]                           name <- restart$name
[09:29:52.668]                           if (is.null(name)) 
[09:29:52.668]                             next
[09:29:52.668]                           if (!grepl(pattern, name)) 
[09:29:52.668]                             next
[09:29:52.668]                           invokeRestart(restart)
[09:29:52.668]                           muffled <- TRUE
[09:29:52.668]                           break
[09:29:52.668]                         }
[09:29:52.668]                       }
[09:29:52.668]                     }
[09:29:52.668]                     invisible(muffled)
[09:29:52.668]                   }
[09:29:52.668]                   muffleCondition(cond)
[09:29:52.668]                 })
[09:29:52.668]             }))
[09:29:52.668]             future::FutureResult(value = ...future.value$value, 
[09:29:52.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.668]                   ...future.rng), globalenv = if (FALSE) 
[09:29:52.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:52.668]                     ...future.globalenv.names))
[09:29:52.668]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:52.668]         }, condition = base::local({
[09:29:52.668]             c <- base::c
[09:29:52.668]             inherits <- base::inherits
[09:29:52.668]             invokeRestart <- base::invokeRestart
[09:29:52.668]             length <- base::length
[09:29:52.668]             list <- base::list
[09:29:52.668]             seq.int <- base::seq.int
[09:29:52.668]             signalCondition <- base::signalCondition
[09:29:52.668]             sys.calls <- base::sys.calls
[09:29:52.668]             `[[` <- base::`[[`
[09:29:52.668]             `+` <- base::`+`
[09:29:52.668]             `<<-` <- base::`<<-`
[09:29:52.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:52.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:52.668]                   3L)]
[09:29:52.668]             }
[09:29:52.668]             function(cond) {
[09:29:52.668]                 is_error <- inherits(cond, "error")
[09:29:52.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:52.668]                   NULL)
[09:29:52.668]                 if (is_error) {
[09:29:52.668]                   sessionInformation <- function() {
[09:29:52.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:52.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:52.668]                       search = base::search(), system = base::Sys.info())
[09:29:52.668]                   }
[09:29:52.668]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:52.668]                     cond$call), session = sessionInformation(), 
[09:29:52.668]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:52.668]                   signalCondition(cond)
[09:29:52.668]                 }
[09:29:52.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:52.668]                 "immediateCondition"))) {
[09:29:52.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:52.668]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:52.668]                   if (TRUE && !signal) {
[09:29:52.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.668]                     {
[09:29:52.668]                       inherits <- base::inherits
[09:29:52.668]                       invokeRestart <- base::invokeRestart
[09:29:52.668]                       is.null <- base::is.null
[09:29:52.668]                       muffled <- FALSE
[09:29:52.668]                       if (inherits(cond, "message")) {
[09:29:52.668]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.668]                         if (muffled) 
[09:29:52.668]                           invokeRestart("muffleMessage")
[09:29:52.668]                       }
[09:29:52.668]                       else if (inherits(cond, "warning")) {
[09:29:52.668]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.668]                         if (muffled) 
[09:29:52.668]                           invokeRestart("muffleWarning")
[09:29:52.668]                       }
[09:29:52.668]                       else if (inherits(cond, "condition")) {
[09:29:52.668]                         if (!is.null(pattern)) {
[09:29:52.668]                           computeRestarts <- base::computeRestarts
[09:29:52.668]                           grepl <- base::grepl
[09:29:52.668]                           restarts <- computeRestarts(cond)
[09:29:52.668]                           for (restart in restarts) {
[09:29:52.668]                             name <- restart$name
[09:29:52.668]                             if (is.null(name)) 
[09:29:52.668]                               next
[09:29:52.668]                             if (!grepl(pattern, name)) 
[09:29:52.668]                               next
[09:29:52.668]                             invokeRestart(restart)
[09:29:52.668]                             muffled <- TRUE
[09:29:52.668]                             break
[09:29:52.668]                           }
[09:29:52.668]                         }
[09:29:52.668]                       }
[09:29:52.668]                       invisible(muffled)
[09:29:52.668]                     }
[09:29:52.668]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.668]                   }
[09:29:52.668]                 }
[09:29:52.668]                 else {
[09:29:52.668]                   if (TRUE) {
[09:29:52.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.668]                     {
[09:29:52.668]                       inherits <- base::inherits
[09:29:52.668]                       invokeRestart <- base::invokeRestart
[09:29:52.668]                       is.null <- base::is.null
[09:29:52.668]                       muffled <- FALSE
[09:29:52.668]                       if (inherits(cond, "message")) {
[09:29:52.668]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.668]                         if (muffled) 
[09:29:52.668]                           invokeRestart("muffleMessage")
[09:29:52.668]                       }
[09:29:52.668]                       else if (inherits(cond, "warning")) {
[09:29:52.668]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.668]                         if (muffled) 
[09:29:52.668]                           invokeRestart("muffleWarning")
[09:29:52.668]                       }
[09:29:52.668]                       else if (inherits(cond, "condition")) {
[09:29:52.668]                         if (!is.null(pattern)) {
[09:29:52.668]                           computeRestarts <- base::computeRestarts
[09:29:52.668]                           grepl <- base::grepl
[09:29:52.668]                           restarts <- computeRestarts(cond)
[09:29:52.668]                           for (restart in restarts) {
[09:29:52.668]                             name <- restart$name
[09:29:52.668]                             if (is.null(name)) 
[09:29:52.668]                               next
[09:29:52.668]                             if (!grepl(pattern, name)) 
[09:29:52.668]                               next
[09:29:52.668]                             invokeRestart(restart)
[09:29:52.668]                             muffled <- TRUE
[09:29:52.668]                             break
[09:29:52.668]                           }
[09:29:52.668]                         }
[09:29:52.668]                       }
[09:29:52.668]                       invisible(muffled)
[09:29:52.668]                     }
[09:29:52.668]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.668]                   }
[09:29:52.668]                 }
[09:29:52.668]             }
[09:29:52.668]         }))
[09:29:52.668]     }, error = function(ex) {
[09:29:52.668]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:52.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.668]                 ...future.rng), started = ...future.startTime, 
[09:29:52.668]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:52.668]             version = "1.8"), class = "FutureResult")
[09:29:52.668]     }, finally = {
[09:29:52.668]         if (!identical(...future.workdir, getwd())) 
[09:29:52.668]             setwd(...future.workdir)
[09:29:52.668]         {
[09:29:52.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:52.668]                 ...future.oldOptions$nwarnings <- NULL
[09:29:52.668]             }
[09:29:52.668]             base::options(...future.oldOptions)
[09:29:52.668]             if (.Platform$OS.type == "windows") {
[09:29:52.668]                 old_names <- names(...future.oldEnvVars)
[09:29:52.668]                 envs <- base::Sys.getenv()
[09:29:52.668]                 names <- names(envs)
[09:29:52.668]                 common <- intersect(names, old_names)
[09:29:52.668]                 added <- setdiff(names, old_names)
[09:29:52.668]                 removed <- setdiff(old_names, names)
[09:29:52.668]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:52.668]                   envs[common]]
[09:29:52.668]                 NAMES <- toupper(changed)
[09:29:52.668]                 args <- list()
[09:29:52.668]                 for (kk in seq_along(NAMES)) {
[09:29:52.668]                   name <- changed[[kk]]
[09:29:52.668]                   NAME <- NAMES[[kk]]
[09:29:52.668]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.668]                     next
[09:29:52.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.668]                 }
[09:29:52.668]                 NAMES <- toupper(added)
[09:29:52.668]                 for (kk in seq_along(NAMES)) {
[09:29:52.668]                   name <- added[[kk]]
[09:29:52.668]                   NAME <- NAMES[[kk]]
[09:29:52.668]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.668]                     next
[09:29:52.668]                   args[[name]] <- ""
[09:29:52.668]                 }
[09:29:52.668]                 NAMES <- toupper(removed)
[09:29:52.668]                 for (kk in seq_along(NAMES)) {
[09:29:52.668]                   name <- removed[[kk]]
[09:29:52.668]                   NAME <- NAMES[[kk]]
[09:29:52.668]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.668]                     next
[09:29:52.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.668]                 }
[09:29:52.668]                 if (length(args) > 0) 
[09:29:52.668]                   base::do.call(base::Sys.setenv, args = args)
[09:29:52.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:52.668]             }
[09:29:52.668]             else {
[09:29:52.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:52.668]             }
[09:29:52.668]             {
[09:29:52.668]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:52.668]                   0L) {
[09:29:52.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:52.668]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:52.668]                   base::options(opts)
[09:29:52.668]                 }
[09:29:52.668]                 {
[09:29:52.668]                   {
[09:29:52.668]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:52.668]                     NULL
[09:29:52.668]                   }
[09:29:52.668]                   options(future.plan = NULL)
[09:29:52.668]                   if (is.na(NA_character_)) 
[09:29:52.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:52.668]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:52.668]                     .init = FALSE)
[09:29:52.668]                 }
[09:29:52.668]             }
[09:29:52.668]         }
[09:29:52.668]     })
[09:29:52.668]     if (TRUE) {
[09:29:52.668]         base::sink(type = "output", split = FALSE)
[09:29:52.668]         if (TRUE) {
[09:29:52.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:52.668]         }
[09:29:52.668]         else {
[09:29:52.668]             ...future.result["stdout"] <- base::list(NULL)
[09:29:52.668]         }
[09:29:52.668]         base::close(...future.stdout)
[09:29:52.668]         ...future.stdout <- NULL
[09:29:52.668]     }
[09:29:52.668]     ...future.result$conditions <- ...future.conditions
[09:29:52.668]     ...future.result$finished <- base::Sys.time()
[09:29:52.668]     ...future.result
[09:29:52.668] }
[09:29:52.670] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[09:29:52.670] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:52.712] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:52.712] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[09:29:52.756] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[09:29:52.756] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:52.757] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:52.757] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:52.800] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:52.800] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:52.844] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:52.844] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:52.845] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.845] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:52.845] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:52.845] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:52.846] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.846] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[09:29:52.846] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[09:29:52.846] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:52.847] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.847] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:52.847] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:52.847] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[09:29:52.848] MultisessionFuture started
[09:29:52.848] - Launch lazy future ... done
[09:29:52.848] run() for ‘MultisessionFuture’ ... done
[09:29:52.848] Created future:
[09:29:52.850] receiveMessageFromWorker() for ClusterFuture ...
[09:29:52.850] - Validating connection of MultisessionFuture
[09:29:52.850] - received message: FutureResult
[09:29:52.850] - Received FutureResult
[09:29:52.850] - Erased future from FutureRegistry
[09:29:52.850] result() for ClusterFuture ...
[09:29:52.850] - result already collected: FutureResult
[09:29:52.850] result() for ClusterFuture ... done
[09:29:52.850] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:52.848] MultisessionFuture:
[09:29:52.848] Label: ‘future_vapply-1’
[09:29:52.848] Expression:
[09:29:52.848] {
[09:29:52.848]     do.call(function(...) {
[09:29:52.848]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.848]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.848]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.848]             on.exit(options(oopts), add = TRUE)
[09:29:52.848]         }
[09:29:52.848]         {
[09:29:52.848]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.848]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.848]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.848]             })
[09:29:52.848]         }
[09:29:52.848]     }, args = future.call.arguments)
[09:29:52.848] }
[09:29:52.848] Lazy evaluation: FALSE
[09:29:52.848] Asynchronous evaluation: TRUE
[09:29:52.848] Local evaluation: TRUE
[09:29:52.848] Environment: R_GlobalEnv
[09:29:52.848] Capture standard output: TRUE
[09:29:52.848] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:52.848] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:52.848] Packages: 2 packages (‘stats’, ‘future.apply’)
[09:29:52.848] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:52.848] Resolved: TRUE
[09:29:52.848] Value: <not collected>
[09:29:52.848] Conditions captured: <none>
[09:29:52.848] Early signaling: FALSE
[09:29:52.848] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:52.848] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.851] Chunk #1 of 2 ... DONE
[09:29:52.851] Chunk #2 of 2 ...
[09:29:52.851]  - Finding globals in 'X' for chunk #2 ...
[09:29:52.851] getGlobalsAndPackages() ...
[09:29:52.851] Searching for globals...
[09:29:52.851] 
[09:29:52.851] Searching for globals ... DONE
[09:29:52.852] - globals: [0] <none>
[09:29:52.852] getGlobalsAndPackages() ... DONE
[09:29:52.852]    + additional globals found: [n=0] 
[09:29:52.852]    + additional namespaces needed: [n=0] 
[09:29:52.852]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:52.852]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:52.852]  - seeds: <none>
[09:29:52.852]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.852] getGlobalsAndPackages() ...
[09:29:52.852] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.853] Resolving globals: FALSE
[09:29:52.853] Tweak future expression to call with '...' arguments ...
[09:29:52.853] {
[09:29:52.853]     do.call(function(...) {
[09:29:52.853]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.853]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:52.853]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.853]             on.exit(options(oopts), add = TRUE)
[09:29:52.853]         }
[09:29:52.853]         {
[09:29:52.853]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:52.853]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.853]                 ...future.FUN(...future.X_jj, ...)
[09:29:52.853]             })
[09:29:52.853]         }
[09:29:52.853]     }, args = future.call.arguments)
[09:29:52.853] }
[09:29:52.853] Tweak future expression to call with '...' arguments ... DONE
[09:29:52.853] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:52.854] - packages: [2] ‘stats’, ‘future.apply’
[09:29:52.854] getGlobalsAndPackages() ... DONE
[09:29:52.854] run() for ‘Future’ ...
[09:29:52.854] - state: ‘created’
[09:29:52.854] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:52.868] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:52.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:52.868]   - Field: ‘node’
[09:29:52.868]   - Field: ‘label’
[09:29:52.868]   - Field: ‘local’
[09:29:52.868]   - Field: ‘owner’
[09:29:52.868]   - Field: ‘envir’
[09:29:52.869]   - Field: ‘workers’
[09:29:52.869]   - Field: ‘packages’
[09:29:52.869]   - Field: ‘gc’
[09:29:52.869]   - Field: ‘conditions’
[09:29:52.869]   - Field: ‘persistent’
[09:29:52.869]   - Field: ‘expr’
[09:29:52.869]   - Field: ‘uuid’
[09:29:52.869]   - Field: ‘seed’
[09:29:52.869]   - Field: ‘version’
[09:29:52.869]   - Field: ‘result’
[09:29:52.869]   - Field: ‘asynchronous’
[09:29:52.870]   - Field: ‘calls’
[09:29:52.870]   - Field: ‘globals’
[09:29:52.870]   - Field: ‘stdout’
[09:29:52.870]   - Field: ‘earlySignal’
[09:29:52.870]   - Field: ‘lazy’
[09:29:52.870]   - Field: ‘state’
[09:29:52.870] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:52.870] - Launch lazy future ...
[09:29:52.870] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[09:29:52.870] Packages needed by future strategies (n = 0): <none>
[09:29:52.871] {
[09:29:52.871]     {
[09:29:52.871]         {
[09:29:52.871]             ...future.startTime <- base::Sys.time()
[09:29:52.871]             {
[09:29:52.871]                 {
[09:29:52.871]                   {
[09:29:52.871]                     {
[09:29:52.871]                       {
[09:29:52.871]                         base::local({
[09:29:52.871]                           has_future <- base::requireNamespace("future", 
[09:29:52.871]                             quietly = TRUE)
[09:29:52.871]                           if (has_future) {
[09:29:52.871]                             ns <- base::getNamespace("future")
[09:29:52.871]                             version <- ns[[".package"]][["version"]]
[09:29:52.871]                             if (is.null(version)) 
[09:29:52.871]                               version <- utils::packageVersion("future")
[09:29:52.871]                           }
[09:29:52.871]                           else {
[09:29:52.871]                             version <- NULL
[09:29:52.871]                           }
[09:29:52.871]                           if (!has_future || version < "1.8.0") {
[09:29:52.871]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:52.871]                               "", base::R.version$version.string), 
[09:29:52.871]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:52.871]                                 base::R.version$platform, 8 * 
[09:29:52.871]                                   base::.Machine$sizeof.pointer), 
[09:29:52.871]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:52.871]                                 "release", "version")], collapse = " "), 
[09:29:52.871]                               hostname = base::Sys.info()[["nodename"]])
[09:29:52.871]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:52.871]                               info)
[09:29:52.871]                             info <- base::paste(info, collapse = "; ")
[09:29:52.871]                             if (!has_future) {
[09:29:52.871]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:52.871]                                 info)
[09:29:52.871]                             }
[09:29:52.871]                             else {
[09:29:52.871]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:52.871]                                 info, version)
[09:29:52.871]                             }
[09:29:52.871]                             base::stop(msg)
[09:29:52.871]                           }
[09:29:52.871]                         })
[09:29:52.871]                       }
[09:29:52.871]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:52.871]                       base::options(mc.cores = 1L)
[09:29:52.871]                     }
[09:29:52.871]                     base::local({
[09:29:52.871]                       for (pkg in c("stats", "future.apply")) {
[09:29:52.871]                         base::loadNamespace(pkg)
[09:29:52.871]                         base::library(pkg, character.only = TRUE)
[09:29:52.871]                       }
[09:29:52.871]                     })
[09:29:52.871]                   }
[09:29:52.871]                   ...future.strategy.old <- future::plan("list")
[09:29:52.871]                   options(future.plan = NULL)
[09:29:52.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:52.871]                 }
[09:29:52.871]                 ...future.workdir <- getwd()
[09:29:52.871]             }
[09:29:52.871]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:52.871]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:52.871]         }
[09:29:52.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:52.871]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:52.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:52.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:52.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:52.871]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:52.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:52.871]             base::names(...future.oldOptions))
[09:29:52.871]     }
[09:29:52.871]     if (FALSE) {
[09:29:52.871]     }
[09:29:52.871]     else {
[09:29:52.871]         if (TRUE) {
[09:29:52.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:52.871]                 open = "w")
[09:29:52.871]         }
[09:29:52.871]         else {
[09:29:52.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:52.871]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:52.871]         }
[09:29:52.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:52.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:52.871]             base::sink(type = "output", split = FALSE)
[09:29:52.871]             base::close(...future.stdout)
[09:29:52.871]         }, add = TRUE)
[09:29:52.871]     }
[09:29:52.871]     ...future.frame <- base::sys.nframe()
[09:29:52.871]     ...future.conditions <- base::list()
[09:29:52.871]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:52.871]     if (FALSE) {
[09:29:52.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:52.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:52.871]     }
[09:29:52.871]     ...future.result <- base::tryCatch({
[09:29:52.871]         base::withCallingHandlers({
[09:29:52.871]             ...future.value <- base::withVisible(base::local({
[09:29:52.871]                 ...future.makeSendCondition <- base::local({
[09:29:52.871]                   sendCondition <- NULL
[09:29:52.871]                   function(frame = 1L) {
[09:29:52.871]                     if (is.function(sendCondition)) 
[09:29:52.871]                       return(sendCondition)
[09:29:52.871]                     ns <- getNamespace("parallel")
[09:29:52.871]                     if (exists("sendData", mode = "function", 
[09:29:52.871]                       envir = ns)) {
[09:29:52.871]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:52.871]                         envir = ns)
[09:29:52.871]                       envir <- sys.frame(frame)
[09:29:52.871]                       master <- NULL
[09:29:52.871]                       while (!identical(envir, .GlobalEnv) && 
[09:29:52.871]                         !identical(envir, emptyenv())) {
[09:29:52.871]                         if (exists("master", mode = "list", envir = envir, 
[09:29:52.871]                           inherits = FALSE)) {
[09:29:52.871]                           master <- get("master", mode = "list", 
[09:29:52.871]                             envir = envir, inherits = FALSE)
[09:29:52.871]                           if (inherits(master, c("SOCKnode", 
[09:29:52.871]                             "SOCK0node"))) {
[09:29:52.871]                             sendCondition <<- function(cond) {
[09:29:52.871]                               data <- list(type = "VALUE", value = cond, 
[09:29:52.871]                                 success = TRUE)
[09:29:52.871]                               parallel_sendData(master, data)
[09:29:52.871]                             }
[09:29:52.871]                             return(sendCondition)
[09:29:52.871]                           }
[09:29:52.871]                         }
[09:29:52.871]                         frame <- frame + 1L
[09:29:52.871]                         envir <- sys.frame(frame)
[09:29:52.871]                       }
[09:29:52.871]                     }
[09:29:52.871]                     sendCondition <<- function(cond) NULL
[09:29:52.871]                   }
[09:29:52.871]                 })
[09:29:52.871]                 withCallingHandlers({
[09:29:52.871]                   {
[09:29:52.871]                     do.call(function(...) {
[09:29:52.871]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:52.871]                       if (!identical(...future.globals.maxSize.org, 
[09:29:52.871]                         ...future.globals.maxSize)) {
[09:29:52.871]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:52.871]                         on.exit(options(oopts), add = TRUE)
[09:29:52.871]                       }
[09:29:52.871]                       {
[09:29:52.871]                         lapply(seq_along(...future.elements_ii), 
[09:29:52.871]                           FUN = function(jj) {
[09:29:52.871]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:52.871]                             ...future.FUN(...future.X_jj, ...)
[09:29:52.871]                           })
[09:29:52.871]                       }
[09:29:52.871]                     }, args = future.call.arguments)
[09:29:52.871]                   }
[09:29:52.871]                 }, immediateCondition = function(cond) {
[09:29:52.871]                   sendCondition <- ...future.makeSendCondition()
[09:29:52.871]                   sendCondition(cond)
[09:29:52.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.871]                   {
[09:29:52.871]                     inherits <- base::inherits
[09:29:52.871]                     invokeRestart <- base::invokeRestart
[09:29:52.871]                     is.null <- base::is.null
[09:29:52.871]                     muffled <- FALSE
[09:29:52.871]                     if (inherits(cond, "message")) {
[09:29:52.871]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:52.871]                       if (muffled) 
[09:29:52.871]                         invokeRestart("muffleMessage")
[09:29:52.871]                     }
[09:29:52.871]                     else if (inherits(cond, "warning")) {
[09:29:52.871]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:52.871]                       if (muffled) 
[09:29:52.871]                         invokeRestart("muffleWarning")
[09:29:52.871]                     }
[09:29:52.871]                     else if (inherits(cond, "condition")) {
[09:29:52.871]                       if (!is.null(pattern)) {
[09:29:52.871]                         computeRestarts <- base::computeRestarts
[09:29:52.871]                         grepl <- base::grepl
[09:29:52.871]                         restarts <- computeRestarts(cond)
[09:29:52.871]                         for (restart in restarts) {
[09:29:52.871]                           name <- restart$name
[09:29:52.871]                           if (is.null(name)) 
[09:29:52.871]                             next
[09:29:52.871]                           if (!grepl(pattern, name)) 
[09:29:52.871]                             next
[09:29:52.871]                           invokeRestart(restart)
[09:29:52.871]                           muffled <- TRUE
[09:29:52.871]                           break
[09:29:52.871]                         }
[09:29:52.871]                       }
[09:29:52.871]                     }
[09:29:52.871]                     invisible(muffled)
[09:29:52.871]                   }
[09:29:52.871]                   muffleCondition(cond)
[09:29:52.871]                 })
[09:29:52.871]             }))
[09:29:52.871]             future::FutureResult(value = ...future.value$value, 
[09:29:52.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.871]                   ...future.rng), globalenv = if (FALSE) 
[09:29:52.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:52.871]                     ...future.globalenv.names))
[09:29:52.871]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:52.871]         }, condition = base::local({
[09:29:52.871]             c <- base::c
[09:29:52.871]             inherits <- base::inherits
[09:29:52.871]             invokeRestart <- base::invokeRestart
[09:29:52.871]             length <- base::length
[09:29:52.871]             list <- base::list
[09:29:52.871]             seq.int <- base::seq.int
[09:29:52.871]             signalCondition <- base::signalCondition
[09:29:52.871]             sys.calls <- base::sys.calls
[09:29:52.871]             `[[` <- base::`[[`
[09:29:52.871]             `+` <- base::`+`
[09:29:52.871]             `<<-` <- base::`<<-`
[09:29:52.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:52.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:52.871]                   3L)]
[09:29:52.871]             }
[09:29:52.871]             function(cond) {
[09:29:52.871]                 is_error <- inherits(cond, "error")
[09:29:52.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:52.871]                   NULL)
[09:29:52.871]                 if (is_error) {
[09:29:52.871]                   sessionInformation <- function() {
[09:29:52.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:52.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:52.871]                       search = base::search(), system = base::Sys.info())
[09:29:52.871]                   }
[09:29:52.871]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:52.871]                     cond$call), session = sessionInformation(), 
[09:29:52.871]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:52.871]                   signalCondition(cond)
[09:29:52.871]                 }
[09:29:52.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:52.871]                 "immediateCondition"))) {
[09:29:52.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:52.871]                   ...future.conditions[[length(...future.conditions) + 
[09:29:52.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:52.871]                   if (TRUE && !signal) {
[09:29:52.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.871]                     {
[09:29:52.871]                       inherits <- base::inherits
[09:29:52.871]                       invokeRestart <- base::invokeRestart
[09:29:52.871]                       is.null <- base::is.null
[09:29:52.871]                       muffled <- FALSE
[09:29:52.871]                       if (inherits(cond, "message")) {
[09:29:52.871]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.871]                         if (muffled) 
[09:29:52.871]                           invokeRestart("muffleMessage")
[09:29:52.871]                       }
[09:29:52.871]                       else if (inherits(cond, "warning")) {
[09:29:52.871]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.871]                         if (muffled) 
[09:29:52.871]                           invokeRestart("muffleWarning")
[09:29:52.871]                       }
[09:29:52.871]                       else if (inherits(cond, "condition")) {
[09:29:52.871]                         if (!is.null(pattern)) {
[09:29:52.871]                           computeRestarts <- base::computeRestarts
[09:29:52.871]                           grepl <- base::grepl
[09:29:52.871]                           restarts <- computeRestarts(cond)
[09:29:52.871]                           for (restart in restarts) {
[09:29:52.871]                             name <- restart$name
[09:29:52.871]                             if (is.null(name)) 
[09:29:52.871]                               next
[09:29:52.871]                             if (!grepl(pattern, name)) 
[09:29:52.871]                               next
[09:29:52.871]                             invokeRestart(restart)
[09:29:52.871]                             muffled <- TRUE
[09:29:52.871]                             break
[09:29:52.871]                           }
[09:29:52.871]                         }
[09:29:52.871]                       }
[09:29:52.871]                       invisible(muffled)
[09:29:52.871]                     }
[09:29:52.871]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.871]                   }
[09:29:52.871]                 }
[09:29:52.871]                 else {
[09:29:52.871]                   if (TRUE) {
[09:29:52.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:52.871]                     {
[09:29:52.871]                       inherits <- base::inherits
[09:29:52.871]                       invokeRestart <- base::invokeRestart
[09:29:52.871]                       is.null <- base::is.null
[09:29:52.871]                       muffled <- FALSE
[09:29:52.871]                       if (inherits(cond, "message")) {
[09:29:52.871]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:52.871]                         if (muffled) 
[09:29:52.871]                           invokeRestart("muffleMessage")
[09:29:52.871]                       }
[09:29:52.871]                       else if (inherits(cond, "warning")) {
[09:29:52.871]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:52.871]                         if (muffled) 
[09:29:52.871]                           invokeRestart("muffleWarning")
[09:29:52.871]                       }
[09:29:52.871]                       else if (inherits(cond, "condition")) {
[09:29:52.871]                         if (!is.null(pattern)) {
[09:29:52.871]                           computeRestarts <- base::computeRestarts
[09:29:52.871]                           grepl <- base::grepl
[09:29:52.871]                           restarts <- computeRestarts(cond)
[09:29:52.871]                           for (restart in restarts) {
[09:29:52.871]                             name <- restart$name
[09:29:52.871]                             if (is.null(name)) 
[09:29:52.871]                               next
[09:29:52.871]                             if (!grepl(pattern, name)) 
[09:29:52.871]                               next
[09:29:52.871]                             invokeRestart(restart)
[09:29:52.871]                             muffled <- TRUE
[09:29:52.871]                             break
[09:29:52.871]                           }
[09:29:52.871]                         }
[09:29:52.871]                       }
[09:29:52.871]                       invisible(muffled)
[09:29:52.871]                     }
[09:29:52.871]                     muffleCondition(cond, pattern = "^muffle")
[09:29:52.871]                   }
[09:29:52.871]                 }
[09:29:52.871]             }
[09:29:52.871]         }))
[09:29:52.871]     }, error = function(ex) {
[09:29:52.871]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:52.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:52.871]                 ...future.rng), started = ...future.startTime, 
[09:29:52.871]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:52.871]             version = "1.8"), class = "FutureResult")
[09:29:52.871]     }, finally = {
[09:29:52.871]         if (!identical(...future.workdir, getwd())) 
[09:29:52.871]             setwd(...future.workdir)
[09:29:52.871]         {
[09:29:52.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:52.871]                 ...future.oldOptions$nwarnings <- NULL
[09:29:52.871]             }
[09:29:52.871]             base::options(...future.oldOptions)
[09:29:52.871]             if (.Platform$OS.type == "windows") {
[09:29:52.871]                 old_names <- names(...future.oldEnvVars)
[09:29:52.871]                 envs <- base::Sys.getenv()
[09:29:52.871]                 names <- names(envs)
[09:29:52.871]                 common <- intersect(names, old_names)
[09:29:52.871]                 added <- setdiff(names, old_names)
[09:29:52.871]                 removed <- setdiff(old_names, names)
[09:29:52.871]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:52.871]                   envs[common]]
[09:29:52.871]                 NAMES <- toupper(changed)
[09:29:52.871]                 args <- list()
[09:29:52.871]                 for (kk in seq_along(NAMES)) {
[09:29:52.871]                   name <- changed[[kk]]
[09:29:52.871]                   NAME <- NAMES[[kk]]
[09:29:52.871]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.871]                     next
[09:29:52.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.871]                 }
[09:29:52.871]                 NAMES <- toupper(added)
[09:29:52.871]                 for (kk in seq_along(NAMES)) {
[09:29:52.871]                   name <- added[[kk]]
[09:29:52.871]                   NAME <- NAMES[[kk]]
[09:29:52.871]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.871]                     next
[09:29:52.871]                   args[[name]] <- ""
[09:29:52.871]                 }
[09:29:52.871]                 NAMES <- toupper(removed)
[09:29:52.871]                 for (kk in seq_along(NAMES)) {
[09:29:52.871]                   name <- removed[[kk]]
[09:29:52.871]                   NAME <- NAMES[[kk]]
[09:29:52.871]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:52.871]                     next
[09:29:52.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:52.871]                 }
[09:29:52.871]                 if (length(args) > 0) 
[09:29:52.871]                   base::do.call(base::Sys.setenv, args = args)
[09:29:52.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:52.871]             }
[09:29:52.871]             else {
[09:29:52.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:52.871]             }
[09:29:52.871]             {
[09:29:52.871]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:52.871]                   0L) {
[09:29:52.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:52.871]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:52.871]                   base::options(opts)
[09:29:52.871]                 }
[09:29:52.871]                 {
[09:29:52.871]                   {
[09:29:52.871]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:52.871]                     NULL
[09:29:52.871]                   }
[09:29:52.871]                   options(future.plan = NULL)
[09:29:52.871]                   if (is.na(NA_character_)) 
[09:29:52.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:52.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:52.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:52.871]                     .init = FALSE)
[09:29:52.871]                 }
[09:29:52.871]             }
[09:29:52.871]         }
[09:29:52.871]     })
[09:29:52.871]     if (TRUE) {
[09:29:52.871]         base::sink(type = "output", split = FALSE)
[09:29:52.871]         if (TRUE) {
[09:29:52.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:52.871]         }
[09:29:52.871]         else {
[09:29:52.871]             ...future.result["stdout"] <- base::list(NULL)
[09:29:52.871]         }
[09:29:52.871]         base::close(...future.stdout)
[09:29:52.871]         ...future.stdout <- NULL
[09:29:52.871]     }
[09:29:52.871]     ...future.result$conditions <- ...future.conditions
[09:29:52.871]     ...future.result$finished <- base::Sys.time()
[09:29:52.871]     ...future.result
[09:29:52.871] }
[09:29:52.874] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[09:29:52.874] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:52.916] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:52.916] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[09:29:52.960] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[09:29:52.960] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:52.961] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:52.961] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:53.004] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:53.004] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:53.048] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:53.048] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:53.049] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.049] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:53.049] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:53.050] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:53.050] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.050] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #1 ...
[09:29:53.051] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #1 ... DONE
[09:29:53.051] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:53.051] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.051] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:53.051] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.052] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[09:29:53.052] MultisessionFuture started
[09:29:53.052] - Launch lazy future ... done
[09:29:53.052] run() for ‘MultisessionFuture’ ... done
[09:29:53.053] Created future:
[09:29:53.053] MultisessionFuture:
[09:29:53.053] Label: ‘future_vapply-2’
[09:29:53.053] Expression:
[09:29:53.053] {
[09:29:53.053]     do.call(function(...) {
[09:29:53.053]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.053]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.053]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.053]             on.exit(options(oopts), add = TRUE)
[09:29:53.053]         }
[09:29:53.053]         {
[09:29:53.053]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.053]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.053]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.053]             })
[09:29:53.053]         }
[09:29:53.053]     }, args = future.call.arguments)
[09:29:53.053] }
[09:29:53.053] Lazy evaluation: FALSE
[09:29:53.053] Asynchronous evaluation: TRUE
[09:29:53.053] Local evaluation: TRUE
[09:29:53.053] Environment: R_GlobalEnv
[09:29:53.053] Capture standard output: TRUE
[09:29:53.053] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:53.053] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:53.053] Packages: 2 packages (‘stats’, ‘future.apply’)
[09:29:53.053] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:53.053] Resolved: FALSE
[09:29:53.053] Value: <not collected>
[09:29:53.053] Conditions captured: <none>
[09:29:53.053] Early signaling: FALSE
[09:29:53.053] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:53.053] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.064] Chunk #2 of 2 ... DONE
[09:29:53.064] Launching 2 futures (chunks) ... DONE
[09:29:53.064] Resolving 2 futures (chunks) ...
[09:29:53.065] resolve() on list ...
[09:29:53.065]  recursive: 0
[09:29:53.065]  length: 2
[09:29:53.065] 
[09:29:53.065] Future #1
[09:29:53.065] result() for ClusterFuture ...
[09:29:53.065] - result already collected: FutureResult
[09:29:53.065] result() for ClusterFuture ... done
[09:29:53.065] result() for ClusterFuture ...
[09:29:53.066] - result already collected: FutureResult
[09:29:53.066] result() for ClusterFuture ... done
[09:29:53.066] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:53.066] - nx: 2
[09:29:53.066] - relay: TRUE
[09:29:53.066] - stdout: TRUE
[09:29:53.066] - signal: TRUE
[09:29:53.066] - resignal: FALSE
[09:29:53.066] - force: TRUE
[09:29:53.066] - relayed: [n=2] FALSE, FALSE
[09:29:53.066] - queued futures: [n=2] FALSE, FALSE
[09:29:53.066]  - until=1
[09:29:53.067]  - relaying element #1
[09:29:53.067] result() for ClusterFuture ...
[09:29:53.067] - result already collected: FutureResult
[09:29:53.067] result() for ClusterFuture ... done
[09:29:53.067] result() for ClusterFuture ...
[09:29:53.067] - result already collected: FutureResult
[09:29:53.067] result() for ClusterFuture ... done
[09:29:53.067] result() for ClusterFuture ...
[09:29:53.067] - result already collected: FutureResult
[09:29:53.067] result() for ClusterFuture ... done
[09:29:53.067] result() for ClusterFuture ...
[09:29:53.068] - result already collected: FutureResult
[09:29:53.068] result() for ClusterFuture ... done
[09:29:53.068] - relayed: [n=2] TRUE, FALSE
[09:29:53.068] - queued futures: [n=2] TRUE, FALSE
[09:29:53.068] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:53.068]  length: 1 (resolved future 1)
[09:29:53.097] receiveMessageFromWorker() for ClusterFuture ...
[09:29:53.098] - Validating connection of MultisessionFuture
[09:29:53.098] - received message: FutureResult
[09:29:53.098] - Received FutureResult
[09:29:53.098] - Erased future from FutureRegistry
[09:29:53.098] result() for ClusterFuture ...
[09:29:53.098] - result already collected: FutureResult
[09:29:53.098] result() for ClusterFuture ... done
[09:29:53.098] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:53.099] Future #2
[09:29:53.099] result() for ClusterFuture ...
[09:29:53.099] - result already collected: FutureResult
[09:29:53.099] result() for ClusterFuture ... done
[09:29:53.099] result() for ClusterFuture ...
[09:29:53.099] - result already collected: FutureResult
[09:29:53.099] result() for ClusterFuture ... done
[09:29:53.099] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:53.099] - nx: 2
[09:29:53.099] - relay: TRUE
[09:29:53.099] - stdout: TRUE
[09:29:53.099] - signal: TRUE
[09:29:53.099] - resignal: FALSE
[09:29:53.108] - force: TRUE
[09:29:53.108] - relayed: [n=2] TRUE, FALSE
[09:29:53.108] - queued futures: [n=2] TRUE, FALSE
[09:29:53.108]  - until=2
[09:29:53.108]  - relaying element #2
[09:29:53.108] result() for ClusterFuture ...
[09:29:53.108] - result already collected: FutureResult
[09:29:53.108] result() for ClusterFuture ... done
[09:29:53.109] result() for ClusterFuture ...
[09:29:53.109] - result already collected: FutureResult
[09:29:53.109] result() for ClusterFuture ... done
[09:29:53.109] result() for ClusterFuture ...
[09:29:53.109] - result already collected: FutureResult
[09:29:53.109] result() for ClusterFuture ... done
[09:29:53.109] result() for ClusterFuture ...
[09:29:53.109] - result already collected: FutureResult
[09:29:53.109] result() for ClusterFuture ... done
[09:29:53.109] - relayed: [n=2] TRUE, TRUE
[09:29:53.109] - queued futures: [n=2] TRUE, TRUE
[09:29:53.109] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:53.110]  length: 0 (resolved future 2)
[09:29:53.110] Relaying remaining futures
[09:29:53.110] signalConditionsASAP(NULL, pos=0) ...
[09:29:53.110] - nx: 2
[09:29:53.110] - relay: TRUE
[09:29:53.110] - stdout: TRUE
[09:29:53.110] - signal: TRUE
[09:29:53.110] - resignal: FALSE
[09:29:53.110] - force: TRUE
[09:29:53.110] - relayed: [n=2] TRUE, TRUE
[09:29:53.110] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:53.110] - relayed: [n=2] TRUE, TRUE
[09:29:53.111] - queued futures: [n=2] TRUE, TRUE
[09:29:53.111] signalConditionsASAP(NULL, pos=0) ... done
[09:29:53.111] resolve() on list ... DONE
[09:29:53.111] result() for ClusterFuture ...
[09:29:53.111] - result already collected: FutureResult
[09:29:53.111] result() for ClusterFuture ... done
[09:29:53.111] result() for ClusterFuture ...
[09:29:53.111] - result already collected: FutureResult
[09:29:53.111] result() for ClusterFuture ... done
[09:29:53.111] result() for ClusterFuture ...
[09:29:53.111] - result already collected: FutureResult
[09:29:53.111] result() for ClusterFuture ... done
[09:29:53.112] result() for ClusterFuture ...
[09:29:53.112] - result already collected: FutureResult
[09:29:53.112] result() for ClusterFuture ... done
[09:29:53.112]  - Number of value chunks collected: 2
[09:29:53.112] Resolving 2 futures (chunks) ... DONE
[09:29:53.112] Reducing values from 2 chunks ...
[09:29:53.112]  - Number of values collected after concatenation: 7
[09:29:53.112]  - Number of values expected: 7
[09:29:53.112] Reducing values from 2 chunks ... DONE
[09:29:53.112] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[09:29:53.114] future_lapply() ...
[09:29:53.118] Number of chunks: 2
[09:29:53.119] getGlobalsAndPackagesXApply() ...
[09:29:53.119]  - future.globals: TRUE
[09:29:53.119] getGlobalsAndPackages() ...
[09:29:53.119] Searching for globals...
[09:29:53.120] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[09:29:53.120] Searching for globals ... DONE
[09:29:53.120] Resolving globals: FALSE
[09:29:53.121] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[09:29:53.121] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[09:29:53.121] - globals: [1] ‘FUN’
[09:29:53.121] 
[09:29:53.121] getGlobalsAndPackages() ... DONE
[09:29:53.121]  - globals found/used: [n=1] ‘FUN’
[09:29:53.121]  - needed namespaces: [n=0] 
[09:29:53.122] Finding globals ... DONE
[09:29:53.122]  - use_args: TRUE
[09:29:53.122]  - Getting '...' globals ...
[09:29:53.122] resolve() on list ...
[09:29:53.122]  recursive: 0
[09:29:53.122]  length: 1
[09:29:53.122]  elements: ‘...’
[09:29:53.123]  length: 0 (resolved future 1)
[09:29:53.123] resolve() on list ... DONE
[09:29:53.123]    - '...' content: [n=1] ‘y’
[09:29:53.123] List of 1
[09:29:53.123]  $ ...:List of 1
[09:29:53.123]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:53.123]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:53.123]  - attr(*, "where")=List of 1
[09:29:53.123]   ..$ ...:<environment: 0x561d3686b298> 
[09:29:53.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:53.123]  - attr(*, "resolved")= logi TRUE
[09:29:53.123]  - attr(*, "total_size")= num NA
[09:29:53.126]  - Getting '...' globals ... DONE
[09:29:53.126] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[09:29:53.126] List of 2
[09:29:53.126]  $ ...future.FUN:function (x, y)  
[09:29:53.126]  $ ...          :List of 1
[09:29:53.126]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:53.126]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:53.126]  - attr(*, "where")=List of 2
[09:29:53.126]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:53.126]   ..$ ...          :<environment: 0x561d3686b298> 
[09:29:53.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:53.126]  - attr(*, "resolved")= logi FALSE
[09:29:53.126]  - attr(*, "total_size")= num 4264
[09:29:53.129] Packages to be attached in all futures: [n=0] 
[09:29:53.129] getGlobalsAndPackagesXApply() ... DONE
[09:29:53.129] Number of futures (= number of chunks): 2
[09:29:53.130] Launching 2 futures (chunks) ...
[09:29:53.130] Chunk #1 of 2 ...
[09:29:53.130]  - Finding globals in 'X' for chunk #1 ...
[09:29:53.130] getGlobalsAndPackages() ...
[09:29:53.130] Searching for globals...
[09:29:53.130] 
[09:29:53.130] Searching for globals ... DONE
[09:29:53.130] - globals: [0] <none>
[09:29:53.131] getGlobalsAndPackages() ... DONE
[09:29:53.131]    + additional globals found: [n=0] 
[09:29:53.131]    + additional namespaces needed: [n=0] 
[09:29:53.131]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:53.131]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:53.131]  - seeds: <none>
[09:29:53.131]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.131] getGlobalsAndPackages() ...
[09:29:53.131] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.131] Resolving globals: FALSE
[09:29:53.131] Tweak future expression to call with '...' arguments ...
[09:29:53.132] {
[09:29:53.132]     do.call(function(...) {
[09:29:53.132]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.132]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.132]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.132]             on.exit(options(oopts), add = TRUE)
[09:29:53.132]         }
[09:29:53.132]         {
[09:29:53.132]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.132]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.132]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.132]             })
[09:29:53.132]         }
[09:29:53.132]     }, args = future.call.arguments)
[09:29:53.132] }
[09:29:53.132] Tweak future expression to call with '...' arguments ... DONE
[09:29:53.132] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.132] 
[09:29:53.132] getGlobalsAndPackages() ... DONE
[09:29:53.133] run() for ‘Future’ ...
[09:29:53.133] - state: ‘created’
[09:29:53.133] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:53.147] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:53.147]   - Field: ‘node’
[09:29:53.147]   - Field: ‘label’
[09:29:53.147]   - Field: ‘local’
[09:29:53.148]   - Field: ‘owner’
[09:29:53.148]   - Field: ‘envir’
[09:29:53.148]   - Field: ‘workers’
[09:29:53.148]   - Field: ‘packages’
[09:29:53.148]   - Field: ‘gc’
[09:29:53.148]   - Field: ‘conditions’
[09:29:53.148]   - Field: ‘persistent’
[09:29:53.148]   - Field: ‘expr’
[09:29:53.148]   - Field: ‘uuid’
[09:29:53.148]   - Field: ‘seed’
[09:29:53.148]   - Field: ‘version’
[09:29:53.149]   - Field: ‘result’
[09:29:53.149]   - Field: ‘asynchronous’
[09:29:53.149]   - Field: ‘calls’
[09:29:53.149]   - Field: ‘globals’
[09:29:53.149]   - Field: ‘stdout’
[09:29:53.149]   - Field: ‘earlySignal’
[09:29:53.149]   - Field: ‘lazy’
[09:29:53.149]   - Field: ‘state’
[09:29:53.149] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:53.149] - Launch lazy future ...
[09:29:53.150] Packages needed by the future expression (n = 0): <none>
[09:29:53.150] Packages needed by future strategies (n = 0): <none>
[09:29:53.150] {
[09:29:53.150]     {
[09:29:53.150]         {
[09:29:53.150]             ...future.startTime <- base::Sys.time()
[09:29:53.150]             {
[09:29:53.150]                 {
[09:29:53.150]                   {
[09:29:53.150]                     {
[09:29:53.150]                       base::local({
[09:29:53.150]                         has_future <- base::requireNamespace("future", 
[09:29:53.150]                           quietly = TRUE)
[09:29:53.150]                         if (has_future) {
[09:29:53.150]                           ns <- base::getNamespace("future")
[09:29:53.150]                           version <- ns[[".package"]][["version"]]
[09:29:53.150]                           if (is.null(version)) 
[09:29:53.150]                             version <- utils::packageVersion("future")
[09:29:53.150]                         }
[09:29:53.150]                         else {
[09:29:53.150]                           version <- NULL
[09:29:53.150]                         }
[09:29:53.150]                         if (!has_future || version < "1.8.0") {
[09:29:53.150]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:53.150]                             "", base::R.version$version.string), 
[09:29:53.150]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:53.150]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:53.150]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:53.150]                               "release", "version")], collapse = " "), 
[09:29:53.150]                             hostname = base::Sys.info()[["nodename"]])
[09:29:53.150]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:53.150]                             info)
[09:29:53.150]                           info <- base::paste(info, collapse = "; ")
[09:29:53.150]                           if (!has_future) {
[09:29:53.150]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:53.150]                               info)
[09:29:53.150]                           }
[09:29:53.150]                           else {
[09:29:53.150]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:53.150]                               info, version)
[09:29:53.150]                           }
[09:29:53.150]                           base::stop(msg)
[09:29:53.150]                         }
[09:29:53.150]                       })
[09:29:53.150]                     }
[09:29:53.150]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:53.150]                     base::options(mc.cores = 1L)
[09:29:53.150]                   }
[09:29:53.150]                   ...future.strategy.old <- future::plan("list")
[09:29:53.150]                   options(future.plan = NULL)
[09:29:53.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:53.150]                 }
[09:29:53.150]                 ...future.workdir <- getwd()
[09:29:53.150]             }
[09:29:53.150]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:53.150]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:53.150]         }
[09:29:53.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:53.150]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:53.150]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:53.150]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:53.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:53.150]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:53.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:53.150]             base::names(...future.oldOptions))
[09:29:53.150]     }
[09:29:53.150]     if (FALSE) {
[09:29:53.150]     }
[09:29:53.150]     else {
[09:29:53.150]         if (TRUE) {
[09:29:53.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:53.150]                 open = "w")
[09:29:53.150]         }
[09:29:53.150]         else {
[09:29:53.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:53.150]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:53.150]         }
[09:29:53.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:53.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:53.150]             base::sink(type = "output", split = FALSE)
[09:29:53.150]             base::close(...future.stdout)
[09:29:53.150]         }, add = TRUE)
[09:29:53.150]     }
[09:29:53.150]     ...future.frame <- base::sys.nframe()
[09:29:53.150]     ...future.conditions <- base::list()
[09:29:53.150]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:53.150]     if (FALSE) {
[09:29:53.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:53.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:53.150]     }
[09:29:53.150]     ...future.result <- base::tryCatch({
[09:29:53.150]         base::withCallingHandlers({
[09:29:53.150]             ...future.value <- base::withVisible(base::local({
[09:29:53.150]                 ...future.makeSendCondition <- base::local({
[09:29:53.150]                   sendCondition <- NULL
[09:29:53.150]                   function(frame = 1L) {
[09:29:53.150]                     if (is.function(sendCondition)) 
[09:29:53.150]                       return(sendCondition)
[09:29:53.150]                     ns <- getNamespace("parallel")
[09:29:53.150]                     if (exists("sendData", mode = "function", 
[09:29:53.150]                       envir = ns)) {
[09:29:53.150]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:53.150]                         envir = ns)
[09:29:53.150]                       envir <- sys.frame(frame)
[09:29:53.150]                       master <- NULL
[09:29:53.150]                       while (!identical(envir, .GlobalEnv) && 
[09:29:53.150]                         !identical(envir, emptyenv())) {
[09:29:53.150]                         if (exists("master", mode = "list", envir = envir, 
[09:29:53.150]                           inherits = FALSE)) {
[09:29:53.150]                           master <- get("master", mode = "list", 
[09:29:53.150]                             envir = envir, inherits = FALSE)
[09:29:53.150]                           if (inherits(master, c("SOCKnode", 
[09:29:53.150]                             "SOCK0node"))) {
[09:29:53.150]                             sendCondition <<- function(cond) {
[09:29:53.150]                               data <- list(type = "VALUE", value = cond, 
[09:29:53.150]                                 success = TRUE)
[09:29:53.150]                               parallel_sendData(master, data)
[09:29:53.150]                             }
[09:29:53.150]                             return(sendCondition)
[09:29:53.150]                           }
[09:29:53.150]                         }
[09:29:53.150]                         frame <- frame + 1L
[09:29:53.150]                         envir <- sys.frame(frame)
[09:29:53.150]                       }
[09:29:53.150]                     }
[09:29:53.150]                     sendCondition <<- function(cond) NULL
[09:29:53.150]                   }
[09:29:53.150]                 })
[09:29:53.150]                 withCallingHandlers({
[09:29:53.150]                   {
[09:29:53.150]                     do.call(function(...) {
[09:29:53.150]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.150]                       if (!identical(...future.globals.maxSize.org, 
[09:29:53.150]                         ...future.globals.maxSize)) {
[09:29:53.150]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.150]                         on.exit(options(oopts), add = TRUE)
[09:29:53.150]                       }
[09:29:53.150]                       {
[09:29:53.150]                         lapply(seq_along(...future.elements_ii), 
[09:29:53.150]                           FUN = function(jj) {
[09:29:53.150]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.150]                             ...future.FUN(...future.X_jj, ...)
[09:29:53.150]                           })
[09:29:53.150]                       }
[09:29:53.150]                     }, args = future.call.arguments)
[09:29:53.150]                   }
[09:29:53.150]                 }, immediateCondition = function(cond) {
[09:29:53.150]                   sendCondition <- ...future.makeSendCondition()
[09:29:53.150]                   sendCondition(cond)
[09:29:53.150]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.150]                   {
[09:29:53.150]                     inherits <- base::inherits
[09:29:53.150]                     invokeRestart <- base::invokeRestart
[09:29:53.150]                     is.null <- base::is.null
[09:29:53.150]                     muffled <- FALSE
[09:29:53.150]                     if (inherits(cond, "message")) {
[09:29:53.150]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:53.150]                       if (muffled) 
[09:29:53.150]                         invokeRestart("muffleMessage")
[09:29:53.150]                     }
[09:29:53.150]                     else if (inherits(cond, "warning")) {
[09:29:53.150]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:53.150]                       if (muffled) 
[09:29:53.150]                         invokeRestart("muffleWarning")
[09:29:53.150]                     }
[09:29:53.150]                     else if (inherits(cond, "condition")) {
[09:29:53.150]                       if (!is.null(pattern)) {
[09:29:53.150]                         computeRestarts <- base::computeRestarts
[09:29:53.150]                         grepl <- base::grepl
[09:29:53.150]                         restarts <- computeRestarts(cond)
[09:29:53.150]                         for (restart in restarts) {
[09:29:53.150]                           name <- restart$name
[09:29:53.150]                           if (is.null(name)) 
[09:29:53.150]                             next
[09:29:53.150]                           if (!grepl(pattern, name)) 
[09:29:53.150]                             next
[09:29:53.150]                           invokeRestart(restart)
[09:29:53.150]                           muffled <- TRUE
[09:29:53.150]                           break
[09:29:53.150]                         }
[09:29:53.150]                       }
[09:29:53.150]                     }
[09:29:53.150]                     invisible(muffled)
[09:29:53.150]                   }
[09:29:53.150]                   muffleCondition(cond)
[09:29:53.150]                 })
[09:29:53.150]             }))
[09:29:53.150]             future::FutureResult(value = ...future.value$value, 
[09:29:53.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.150]                   ...future.rng), globalenv = if (FALSE) 
[09:29:53.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:53.150]                     ...future.globalenv.names))
[09:29:53.150]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:53.150]         }, condition = base::local({
[09:29:53.150]             c <- base::c
[09:29:53.150]             inherits <- base::inherits
[09:29:53.150]             invokeRestart <- base::invokeRestart
[09:29:53.150]             length <- base::length
[09:29:53.150]             list <- base::list
[09:29:53.150]             seq.int <- base::seq.int
[09:29:53.150]             signalCondition <- base::signalCondition
[09:29:53.150]             sys.calls <- base::sys.calls
[09:29:53.150]             `[[` <- base::`[[`
[09:29:53.150]             `+` <- base::`+`
[09:29:53.150]             `<<-` <- base::`<<-`
[09:29:53.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:53.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:53.150]                   3L)]
[09:29:53.150]             }
[09:29:53.150]             function(cond) {
[09:29:53.150]                 is_error <- inherits(cond, "error")
[09:29:53.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:53.150]                   NULL)
[09:29:53.150]                 if (is_error) {
[09:29:53.150]                   sessionInformation <- function() {
[09:29:53.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:53.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:53.150]                       search = base::search(), system = base::Sys.info())
[09:29:53.150]                   }
[09:29:53.150]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:53.150]                     cond$call), session = sessionInformation(), 
[09:29:53.150]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:53.150]                   signalCondition(cond)
[09:29:53.150]                 }
[09:29:53.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:53.150]                 "immediateCondition"))) {
[09:29:53.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:53.150]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:53.150]                   if (TRUE && !signal) {
[09:29:53.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.150]                     {
[09:29:53.150]                       inherits <- base::inherits
[09:29:53.150]                       invokeRestart <- base::invokeRestart
[09:29:53.150]                       is.null <- base::is.null
[09:29:53.150]                       muffled <- FALSE
[09:29:53.150]                       if (inherits(cond, "message")) {
[09:29:53.150]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.150]                         if (muffled) 
[09:29:53.150]                           invokeRestart("muffleMessage")
[09:29:53.150]                       }
[09:29:53.150]                       else if (inherits(cond, "warning")) {
[09:29:53.150]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.150]                         if (muffled) 
[09:29:53.150]                           invokeRestart("muffleWarning")
[09:29:53.150]                       }
[09:29:53.150]                       else if (inherits(cond, "condition")) {
[09:29:53.150]                         if (!is.null(pattern)) {
[09:29:53.150]                           computeRestarts <- base::computeRestarts
[09:29:53.150]                           grepl <- base::grepl
[09:29:53.150]                           restarts <- computeRestarts(cond)
[09:29:53.150]                           for (restart in restarts) {
[09:29:53.150]                             name <- restart$name
[09:29:53.150]                             if (is.null(name)) 
[09:29:53.150]                               next
[09:29:53.150]                             if (!grepl(pattern, name)) 
[09:29:53.150]                               next
[09:29:53.150]                             invokeRestart(restart)
[09:29:53.150]                             muffled <- TRUE
[09:29:53.150]                             break
[09:29:53.150]                           }
[09:29:53.150]                         }
[09:29:53.150]                       }
[09:29:53.150]                       invisible(muffled)
[09:29:53.150]                     }
[09:29:53.150]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.150]                   }
[09:29:53.150]                 }
[09:29:53.150]                 else {
[09:29:53.150]                   if (TRUE) {
[09:29:53.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.150]                     {
[09:29:53.150]                       inherits <- base::inherits
[09:29:53.150]                       invokeRestart <- base::invokeRestart
[09:29:53.150]                       is.null <- base::is.null
[09:29:53.150]                       muffled <- FALSE
[09:29:53.150]                       if (inherits(cond, "message")) {
[09:29:53.150]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.150]                         if (muffled) 
[09:29:53.150]                           invokeRestart("muffleMessage")
[09:29:53.150]                       }
[09:29:53.150]                       else if (inherits(cond, "warning")) {
[09:29:53.150]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.150]                         if (muffled) 
[09:29:53.150]                           invokeRestart("muffleWarning")
[09:29:53.150]                       }
[09:29:53.150]                       else if (inherits(cond, "condition")) {
[09:29:53.150]                         if (!is.null(pattern)) {
[09:29:53.150]                           computeRestarts <- base::computeRestarts
[09:29:53.150]                           grepl <- base::grepl
[09:29:53.150]                           restarts <- computeRestarts(cond)
[09:29:53.150]                           for (restart in restarts) {
[09:29:53.150]                             name <- restart$name
[09:29:53.150]                             if (is.null(name)) 
[09:29:53.150]                               next
[09:29:53.150]                             if (!grepl(pattern, name)) 
[09:29:53.150]                               next
[09:29:53.150]                             invokeRestart(restart)
[09:29:53.150]                             muffled <- TRUE
[09:29:53.150]                             break
[09:29:53.150]                           }
[09:29:53.150]                         }
[09:29:53.150]                       }
[09:29:53.150]                       invisible(muffled)
[09:29:53.150]                     }
[09:29:53.150]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.150]                   }
[09:29:53.150]                 }
[09:29:53.150]             }
[09:29:53.150]         }))
[09:29:53.150]     }, error = function(ex) {
[09:29:53.150]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:53.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.150]                 ...future.rng), started = ...future.startTime, 
[09:29:53.150]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:53.150]             version = "1.8"), class = "FutureResult")
[09:29:53.150]     }, finally = {
[09:29:53.150]         if (!identical(...future.workdir, getwd())) 
[09:29:53.150]             setwd(...future.workdir)
[09:29:53.150]         {
[09:29:53.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:53.150]                 ...future.oldOptions$nwarnings <- NULL
[09:29:53.150]             }
[09:29:53.150]             base::options(...future.oldOptions)
[09:29:53.150]             if (.Platform$OS.type == "windows") {
[09:29:53.150]                 old_names <- names(...future.oldEnvVars)
[09:29:53.150]                 envs <- base::Sys.getenv()
[09:29:53.150]                 names <- names(envs)
[09:29:53.150]                 common <- intersect(names, old_names)
[09:29:53.150]                 added <- setdiff(names, old_names)
[09:29:53.150]                 removed <- setdiff(old_names, names)
[09:29:53.150]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:53.150]                   envs[common]]
[09:29:53.150]                 NAMES <- toupper(changed)
[09:29:53.150]                 args <- list()
[09:29:53.150]                 for (kk in seq_along(NAMES)) {
[09:29:53.150]                   name <- changed[[kk]]
[09:29:53.150]                   NAME <- NAMES[[kk]]
[09:29:53.150]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.150]                     next
[09:29:53.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.150]                 }
[09:29:53.150]                 NAMES <- toupper(added)
[09:29:53.150]                 for (kk in seq_along(NAMES)) {
[09:29:53.150]                   name <- added[[kk]]
[09:29:53.150]                   NAME <- NAMES[[kk]]
[09:29:53.150]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.150]                     next
[09:29:53.150]                   args[[name]] <- ""
[09:29:53.150]                 }
[09:29:53.150]                 NAMES <- toupper(removed)
[09:29:53.150]                 for (kk in seq_along(NAMES)) {
[09:29:53.150]                   name <- removed[[kk]]
[09:29:53.150]                   NAME <- NAMES[[kk]]
[09:29:53.150]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.150]                     next
[09:29:53.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.150]                 }
[09:29:53.150]                 if (length(args) > 0) 
[09:29:53.150]                   base::do.call(base::Sys.setenv, args = args)
[09:29:53.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:53.150]             }
[09:29:53.150]             else {
[09:29:53.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:53.150]             }
[09:29:53.150]             {
[09:29:53.150]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:53.150]                   0L) {
[09:29:53.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:53.150]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:53.150]                   base::options(opts)
[09:29:53.150]                 }
[09:29:53.150]                 {
[09:29:53.150]                   {
[09:29:53.150]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:53.150]                     NULL
[09:29:53.150]                   }
[09:29:53.150]                   options(future.plan = NULL)
[09:29:53.150]                   if (is.na(NA_character_)) 
[09:29:53.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:53.150]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:53.150]                     .init = FALSE)
[09:29:53.150]                 }
[09:29:53.150]             }
[09:29:53.150]         }
[09:29:53.150]     })
[09:29:53.150]     if (TRUE) {
[09:29:53.150]         base::sink(type = "output", split = FALSE)
[09:29:53.150]         if (TRUE) {
[09:29:53.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:53.150]         }
[09:29:53.150]         else {
[09:29:53.150]             ...future.result["stdout"] <- base::list(NULL)
[09:29:53.150]         }
[09:29:53.150]         base::close(...future.stdout)
[09:29:53.150]         ...future.stdout <- NULL
[09:29:53.150]     }
[09:29:53.150]     ...future.result$conditions <- ...future.conditions
[09:29:53.150]     ...future.result$finished <- base::Sys.time()
[09:29:53.150]     ...future.result
[09:29:53.150] }
[09:29:53.153] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[09:29:53.153] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[09:29:53.154] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[09:29:53.154] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[09:29:53.154] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[09:29:53.154] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:29:53.155] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:29:53.155] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:53.155] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.155] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:53.156] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.156] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[09:29:53.156] MultisessionFuture started
[09:29:53.156] - Launch lazy future ... done
[09:29:53.157] run() for ‘MultisessionFuture’ ... done
[09:29:53.157] Created future:
[09:29:53.157] MultisessionFuture:
[09:29:53.157] Label: ‘future_sapply-1’
[09:29:53.157] Expression:
[09:29:53.157] {
[09:29:53.157]     do.call(function(...) {
[09:29:53.157]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.157]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.157]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.157]             on.exit(options(oopts), add = TRUE)
[09:29:53.157]         }
[09:29:53.157]         {
[09:29:53.157]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.157]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.157]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.157]             })
[09:29:53.157]         }
[09:29:53.157]     }, args = future.call.arguments)
[09:29:53.157] }
[09:29:53.157] Lazy evaluation: FALSE
[09:29:53.157] Asynchronous evaluation: TRUE
[09:29:53.157] Local evaluation: TRUE
[09:29:53.157] Environment: R_GlobalEnv
[09:29:53.157] Capture standard output: TRUE
[09:29:53.157] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:53.157] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:53.157] Packages: <none>
[09:29:53.157] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:53.157] Resolved: FALSE
[09:29:53.157] Value: <not collected>
[09:29:53.157] Conditions captured: <none>
[09:29:53.157] Early signaling: FALSE
[09:29:53.157] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:53.157] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.168] Chunk #1 of 2 ... DONE
[09:29:53.169] Chunk #2 of 2 ...
[09:29:53.169]  - Finding globals in 'X' for chunk #2 ...
[09:29:53.169] getGlobalsAndPackages() ...
[09:29:53.169] Searching for globals...
[09:29:53.169] 
[09:29:53.169] Searching for globals ... DONE
[09:29:53.169] - globals: [0] <none>
[09:29:53.169] getGlobalsAndPackages() ... DONE
[09:29:53.169]    + additional globals found: [n=0] 
[09:29:53.170]    + additional namespaces needed: [n=0] 
[09:29:53.170]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:53.170]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:53.170]  - seeds: <none>
[09:29:53.170]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.170] getGlobalsAndPackages() ...
[09:29:53.170] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.170] Resolving globals: FALSE
[09:29:53.170] Tweak future expression to call with '...' arguments ...
[09:29:53.170] {
[09:29:53.170]     do.call(function(...) {
[09:29:53.170]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.170]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.170]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.170]             on.exit(options(oopts), add = TRUE)
[09:29:53.170]         }
[09:29:53.170]         {
[09:29:53.170]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.170]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.170]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.170]             })
[09:29:53.170]         }
[09:29:53.170]     }, args = future.call.arguments)
[09:29:53.170] }
[09:29:53.171] Tweak future expression to call with '...' arguments ... DONE
[09:29:53.171] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.171] 
[09:29:53.171] getGlobalsAndPackages() ... DONE
[09:29:53.172] run() for ‘Future’ ...
[09:29:53.172] - state: ‘created’
[09:29:53.172] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:53.186] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:53.186]   - Field: ‘node’
[09:29:53.187]   - Field: ‘label’
[09:29:53.187]   - Field: ‘local’
[09:29:53.187]   - Field: ‘owner’
[09:29:53.187]   - Field: ‘envir’
[09:29:53.187]   - Field: ‘workers’
[09:29:53.187]   - Field: ‘packages’
[09:29:53.187]   - Field: ‘gc’
[09:29:53.187]   - Field: ‘conditions’
[09:29:53.187]   - Field: ‘persistent’
[09:29:53.187]   - Field: ‘expr’
[09:29:53.187]   - Field: ‘uuid’
[09:29:53.188]   - Field: ‘seed’
[09:29:53.188]   - Field: ‘version’
[09:29:53.188]   - Field: ‘result’
[09:29:53.188]   - Field: ‘asynchronous’
[09:29:53.188]   - Field: ‘calls’
[09:29:53.188]   - Field: ‘globals’
[09:29:53.188]   - Field: ‘stdout’
[09:29:53.188]   - Field: ‘earlySignal’
[09:29:53.188]   - Field: ‘lazy’
[09:29:53.188]   - Field: ‘state’
[09:29:53.188] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:53.189] - Launch lazy future ...
[09:29:53.189] Packages needed by the future expression (n = 0): <none>
[09:29:53.189] Packages needed by future strategies (n = 0): <none>
[09:29:53.189] {
[09:29:53.189]     {
[09:29:53.189]         {
[09:29:53.189]             ...future.startTime <- base::Sys.time()
[09:29:53.189]             {
[09:29:53.189]                 {
[09:29:53.189]                   {
[09:29:53.189]                     {
[09:29:53.189]                       base::local({
[09:29:53.189]                         has_future <- base::requireNamespace("future", 
[09:29:53.189]                           quietly = TRUE)
[09:29:53.189]                         if (has_future) {
[09:29:53.189]                           ns <- base::getNamespace("future")
[09:29:53.189]                           version <- ns[[".package"]][["version"]]
[09:29:53.189]                           if (is.null(version)) 
[09:29:53.189]                             version <- utils::packageVersion("future")
[09:29:53.189]                         }
[09:29:53.189]                         else {
[09:29:53.189]                           version <- NULL
[09:29:53.189]                         }
[09:29:53.189]                         if (!has_future || version < "1.8.0") {
[09:29:53.189]                           info <- base::c(r_version = base::gsub("R version ", 
[09:29:53.189]                             "", base::R.version$version.string), 
[09:29:53.189]                             platform = base::sprintf("%s (%s-bit)", 
[09:29:53.189]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:29:53.189]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:53.189]                               "release", "version")], collapse = " "), 
[09:29:53.189]                             hostname = base::Sys.info()[["nodename"]])
[09:29:53.189]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:29:53.189]                             info)
[09:29:53.189]                           info <- base::paste(info, collapse = "; ")
[09:29:53.189]                           if (!has_future) {
[09:29:53.189]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:53.189]                               info)
[09:29:53.189]                           }
[09:29:53.189]                           else {
[09:29:53.189]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:53.189]                               info, version)
[09:29:53.189]                           }
[09:29:53.189]                           base::stop(msg)
[09:29:53.189]                         }
[09:29:53.189]                       })
[09:29:53.189]                     }
[09:29:53.189]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:53.189]                     base::options(mc.cores = 1L)
[09:29:53.189]                   }
[09:29:53.189]                   ...future.strategy.old <- future::plan("list")
[09:29:53.189]                   options(future.plan = NULL)
[09:29:53.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:53.189]                 }
[09:29:53.189]                 ...future.workdir <- getwd()
[09:29:53.189]             }
[09:29:53.189]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:53.189]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:53.189]         }
[09:29:53.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:53.189]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:53.189]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:53.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:53.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:53.189]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:53.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:53.189]             base::names(...future.oldOptions))
[09:29:53.189]     }
[09:29:53.189]     if (FALSE) {
[09:29:53.189]     }
[09:29:53.189]     else {
[09:29:53.189]         if (TRUE) {
[09:29:53.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:53.189]                 open = "w")
[09:29:53.189]         }
[09:29:53.189]         else {
[09:29:53.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:53.189]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:53.189]         }
[09:29:53.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:53.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:53.189]             base::sink(type = "output", split = FALSE)
[09:29:53.189]             base::close(...future.stdout)
[09:29:53.189]         }, add = TRUE)
[09:29:53.189]     }
[09:29:53.189]     ...future.frame <- base::sys.nframe()
[09:29:53.189]     ...future.conditions <- base::list()
[09:29:53.189]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:53.189]     if (FALSE) {
[09:29:53.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:53.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:53.189]     }
[09:29:53.189]     ...future.result <- base::tryCatch({
[09:29:53.189]         base::withCallingHandlers({
[09:29:53.189]             ...future.value <- base::withVisible(base::local({
[09:29:53.189]                 ...future.makeSendCondition <- base::local({
[09:29:53.189]                   sendCondition <- NULL
[09:29:53.189]                   function(frame = 1L) {
[09:29:53.189]                     if (is.function(sendCondition)) 
[09:29:53.189]                       return(sendCondition)
[09:29:53.189]                     ns <- getNamespace("parallel")
[09:29:53.189]                     if (exists("sendData", mode = "function", 
[09:29:53.189]                       envir = ns)) {
[09:29:53.189]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:53.189]                         envir = ns)
[09:29:53.189]                       envir <- sys.frame(frame)
[09:29:53.189]                       master <- NULL
[09:29:53.189]                       while (!identical(envir, .GlobalEnv) && 
[09:29:53.189]                         !identical(envir, emptyenv())) {
[09:29:53.189]                         if (exists("master", mode = "list", envir = envir, 
[09:29:53.189]                           inherits = FALSE)) {
[09:29:53.189]                           master <- get("master", mode = "list", 
[09:29:53.189]                             envir = envir, inherits = FALSE)
[09:29:53.189]                           if (inherits(master, c("SOCKnode", 
[09:29:53.189]                             "SOCK0node"))) {
[09:29:53.189]                             sendCondition <<- function(cond) {
[09:29:53.189]                               data <- list(type = "VALUE", value = cond, 
[09:29:53.189]                                 success = TRUE)
[09:29:53.189]                               parallel_sendData(master, data)
[09:29:53.189]                             }
[09:29:53.189]                             return(sendCondition)
[09:29:53.189]                           }
[09:29:53.189]                         }
[09:29:53.189]                         frame <- frame + 1L
[09:29:53.189]                         envir <- sys.frame(frame)
[09:29:53.189]                       }
[09:29:53.189]                     }
[09:29:53.189]                     sendCondition <<- function(cond) NULL
[09:29:53.189]                   }
[09:29:53.189]                 })
[09:29:53.189]                 withCallingHandlers({
[09:29:53.189]                   {
[09:29:53.189]                     do.call(function(...) {
[09:29:53.189]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.189]                       if (!identical(...future.globals.maxSize.org, 
[09:29:53.189]                         ...future.globals.maxSize)) {
[09:29:53.189]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.189]                         on.exit(options(oopts), add = TRUE)
[09:29:53.189]                       }
[09:29:53.189]                       {
[09:29:53.189]                         lapply(seq_along(...future.elements_ii), 
[09:29:53.189]                           FUN = function(jj) {
[09:29:53.189]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.189]                             ...future.FUN(...future.X_jj, ...)
[09:29:53.189]                           })
[09:29:53.189]                       }
[09:29:53.189]                     }, args = future.call.arguments)
[09:29:53.189]                   }
[09:29:53.189]                 }, immediateCondition = function(cond) {
[09:29:53.189]                   sendCondition <- ...future.makeSendCondition()
[09:29:53.189]                   sendCondition(cond)
[09:29:53.189]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.189]                   {
[09:29:53.189]                     inherits <- base::inherits
[09:29:53.189]                     invokeRestart <- base::invokeRestart
[09:29:53.189]                     is.null <- base::is.null
[09:29:53.189]                     muffled <- FALSE
[09:29:53.189]                     if (inherits(cond, "message")) {
[09:29:53.189]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:53.189]                       if (muffled) 
[09:29:53.189]                         invokeRestart("muffleMessage")
[09:29:53.189]                     }
[09:29:53.189]                     else if (inherits(cond, "warning")) {
[09:29:53.189]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:53.189]                       if (muffled) 
[09:29:53.189]                         invokeRestart("muffleWarning")
[09:29:53.189]                     }
[09:29:53.189]                     else if (inherits(cond, "condition")) {
[09:29:53.189]                       if (!is.null(pattern)) {
[09:29:53.189]                         computeRestarts <- base::computeRestarts
[09:29:53.189]                         grepl <- base::grepl
[09:29:53.189]                         restarts <- computeRestarts(cond)
[09:29:53.189]                         for (restart in restarts) {
[09:29:53.189]                           name <- restart$name
[09:29:53.189]                           if (is.null(name)) 
[09:29:53.189]                             next
[09:29:53.189]                           if (!grepl(pattern, name)) 
[09:29:53.189]                             next
[09:29:53.189]                           invokeRestart(restart)
[09:29:53.189]                           muffled <- TRUE
[09:29:53.189]                           break
[09:29:53.189]                         }
[09:29:53.189]                       }
[09:29:53.189]                     }
[09:29:53.189]                     invisible(muffled)
[09:29:53.189]                   }
[09:29:53.189]                   muffleCondition(cond)
[09:29:53.189]                 })
[09:29:53.189]             }))
[09:29:53.189]             future::FutureResult(value = ...future.value$value, 
[09:29:53.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.189]                   ...future.rng), globalenv = if (FALSE) 
[09:29:53.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:53.189]                     ...future.globalenv.names))
[09:29:53.189]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:53.189]         }, condition = base::local({
[09:29:53.189]             c <- base::c
[09:29:53.189]             inherits <- base::inherits
[09:29:53.189]             invokeRestart <- base::invokeRestart
[09:29:53.189]             length <- base::length
[09:29:53.189]             list <- base::list
[09:29:53.189]             seq.int <- base::seq.int
[09:29:53.189]             signalCondition <- base::signalCondition
[09:29:53.189]             sys.calls <- base::sys.calls
[09:29:53.189]             `[[` <- base::`[[`
[09:29:53.189]             `+` <- base::`+`
[09:29:53.189]             `<<-` <- base::`<<-`
[09:29:53.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:53.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:53.189]                   3L)]
[09:29:53.189]             }
[09:29:53.189]             function(cond) {
[09:29:53.189]                 is_error <- inherits(cond, "error")
[09:29:53.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:53.189]                   NULL)
[09:29:53.189]                 if (is_error) {
[09:29:53.189]                   sessionInformation <- function() {
[09:29:53.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:53.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:53.189]                       search = base::search(), system = base::Sys.info())
[09:29:53.189]                   }
[09:29:53.189]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:53.189]                     cond$call), session = sessionInformation(), 
[09:29:53.189]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:53.189]                   signalCondition(cond)
[09:29:53.189]                 }
[09:29:53.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:53.189]                 "immediateCondition"))) {
[09:29:53.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:53.189]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:53.189]                   if (TRUE && !signal) {
[09:29:53.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.189]                     {
[09:29:53.189]                       inherits <- base::inherits
[09:29:53.189]                       invokeRestart <- base::invokeRestart
[09:29:53.189]                       is.null <- base::is.null
[09:29:53.189]                       muffled <- FALSE
[09:29:53.189]                       if (inherits(cond, "message")) {
[09:29:53.189]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.189]                         if (muffled) 
[09:29:53.189]                           invokeRestart("muffleMessage")
[09:29:53.189]                       }
[09:29:53.189]                       else if (inherits(cond, "warning")) {
[09:29:53.189]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.189]                         if (muffled) 
[09:29:53.189]                           invokeRestart("muffleWarning")
[09:29:53.189]                       }
[09:29:53.189]                       else if (inherits(cond, "condition")) {
[09:29:53.189]                         if (!is.null(pattern)) {
[09:29:53.189]                           computeRestarts <- base::computeRestarts
[09:29:53.189]                           grepl <- base::grepl
[09:29:53.189]                           restarts <- computeRestarts(cond)
[09:29:53.189]                           for (restart in restarts) {
[09:29:53.189]                             name <- restart$name
[09:29:53.189]                             if (is.null(name)) 
[09:29:53.189]                               next
[09:29:53.189]                             if (!grepl(pattern, name)) 
[09:29:53.189]                               next
[09:29:53.189]                             invokeRestart(restart)
[09:29:53.189]                             muffled <- TRUE
[09:29:53.189]                             break
[09:29:53.189]                           }
[09:29:53.189]                         }
[09:29:53.189]                       }
[09:29:53.189]                       invisible(muffled)
[09:29:53.189]                     }
[09:29:53.189]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.189]                   }
[09:29:53.189]                 }
[09:29:53.189]                 else {
[09:29:53.189]                   if (TRUE) {
[09:29:53.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.189]                     {
[09:29:53.189]                       inherits <- base::inherits
[09:29:53.189]                       invokeRestart <- base::invokeRestart
[09:29:53.189]                       is.null <- base::is.null
[09:29:53.189]                       muffled <- FALSE
[09:29:53.189]                       if (inherits(cond, "message")) {
[09:29:53.189]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.189]                         if (muffled) 
[09:29:53.189]                           invokeRestart("muffleMessage")
[09:29:53.189]                       }
[09:29:53.189]                       else if (inherits(cond, "warning")) {
[09:29:53.189]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.189]                         if (muffled) 
[09:29:53.189]                           invokeRestart("muffleWarning")
[09:29:53.189]                       }
[09:29:53.189]                       else if (inherits(cond, "condition")) {
[09:29:53.189]                         if (!is.null(pattern)) {
[09:29:53.189]                           computeRestarts <- base::computeRestarts
[09:29:53.189]                           grepl <- base::grepl
[09:29:53.189]                           restarts <- computeRestarts(cond)
[09:29:53.189]                           for (restart in restarts) {
[09:29:53.189]                             name <- restart$name
[09:29:53.189]                             if (is.null(name)) 
[09:29:53.189]                               next
[09:29:53.189]                             if (!grepl(pattern, name)) 
[09:29:53.189]                               next
[09:29:53.189]                             invokeRestart(restart)
[09:29:53.189]                             muffled <- TRUE
[09:29:53.189]                             break
[09:29:53.189]                           }
[09:29:53.189]                         }
[09:29:53.189]                       }
[09:29:53.189]                       invisible(muffled)
[09:29:53.189]                     }
[09:29:53.189]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.189]                   }
[09:29:53.189]                 }
[09:29:53.189]             }
[09:29:53.189]         }))
[09:29:53.189]     }, error = function(ex) {
[09:29:53.189]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:53.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.189]                 ...future.rng), started = ...future.startTime, 
[09:29:53.189]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:53.189]             version = "1.8"), class = "FutureResult")
[09:29:53.189]     }, finally = {
[09:29:53.189]         if (!identical(...future.workdir, getwd())) 
[09:29:53.189]             setwd(...future.workdir)
[09:29:53.189]         {
[09:29:53.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:53.189]                 ...future.oldOptions$nwarnings <- NULL
[09:29:53.189]             }
[09:29:53.189]             base::options(...future.oldOptions)
[09:29:53.189]             if (.Platform$OS.type == "windows") {
[09:29:53.189]                 old_names <- names(...future.oldEnvVars)
[09:29:53.189]                 envs <- base::Sys.getenv()
[09:29:53.189]                 names <- names(envs)
[09:29:53.189]                 common <- intersect(names, old_names)
[09:29:53.189]                 added <- setdiff(names, old_names)
[09:29:53.189]                 removed <- setdiff(old_names, names)
[09:29:53.189]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:53.189]                   envs[common]]
[09:29:53.189]                 NAMES <- toupper(changed)
[09:29:53.189]                 args <- list()
[09:29:53.189]                 for (kk in seq_along(NAMES)) {
[09:29:53.189]                   name <- changed[[kk]]
[09:29:53.189]                   NAME <- NAMES[[kk]]
[09:29:53.189]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.189]                     next
[09:29:53.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.189]                 }
[09:29:53.189]                 NAMES <- toupper(added)
[09:29:53.189]                 for (kk in seq_along(NAMES)) {
[09:29:53.189]                   name <- added[[kk]]
[09:29:53.189]                   NAME <- NAMES[[kk]]
[09:29:53.189]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.189]                     next
[09:29:53.189]                   args[[name]] <- ""
[09:29:53.189]                 }
[09:29:53.189]                 NAMES <- toupper(removed)
[09:29:53.189]                 for (kk in seq_along(NAMES)) {
[09:29:53.189]                   name <- removed[[kk]]
[09:29:53.189]                   NAME <- NAMES[[kk]]
[09:29:53.189]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.189]                     next
[09:29:53.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.189]                 }
[09:29:53.189]                 if (length(args) > 0) 
[09:29:53.189]                   base::do.call(base::Sys.setenv, args = args)
[09:29:53.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:53.189]             }
[09:29:53.189]             else {
[09:29:53.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:53.189]             }
[09:29:53.189]             {
[09:29:53.189]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:53.189]                   0L) {
[09:29:53.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:53.189]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:53.189]                   base::options(opts)
[09:29:53.189]                 }
[09:29:53.189]                 {
[09:29:53.189]                   {
[09:29:53.189]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:53.189]                     NULL
[09:29:53.189]                   }
[09:29:53.189]                   options(future.plan = NULL)
[09:29:53.189]                   if (is.na(NA_character_)) 
[09:29:53.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:53.189]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:53.189]                     .init = FALSE)
[09:29:53.189]                 }
[09:29:53.189]             }
[09:29:53.189]         }
[09:29:53.189]     })
[09:29:53.189]     if (TRUE) {
[09:29:53.189]         base::sink(type = "output", split = FALSE)
[09:29:53.189]         if (TRUE) {
[09:29:53.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:53.189]         }
[09:29:53.189]         else {
[09:29:53.189]             ...future.result["stdout"] <- base::list(NULL)
[09:29:53.189]         }
[09:29:53.189]         base::close(...future.stdout)
[09:29:53.189]         ...future.stdout <- NULL
[09:29:53.189]     }
[09:29:53.189]     ...future.result$conditions <- ...future.conditions
[09:29:53.189]     ...future.result$finished <- base::Sys.time()
[09:29:53.189]     ...future.result
[09:29:53.189] }
[09:29:53.192] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[09:29:53.192] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[09:29:53.193] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[09:29:53.193] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[09:29:53.193] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[09:29:53.194] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[09:29:53.194] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[09:29:53.194] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:53.194] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:53.194] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:53.195] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:53.195] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[09:29:53.195] MultisessionFuture started
[09:29:53.196] - Launch lazy future ... done
[09:29:53.196] run() for ‘MultisessionFuture’ ... done
[09:29:53.196] Created future:
[09:29:53.196] MultisessionFuture:
[09:29:53.196] Label: ‘future_sapply-2’
[09:29:53.196] Expression:
[09:29:53.196] {
[09:29:53.196]     do.call(function(...) {
[09:29:53.196]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.196]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.196]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.196]             on.exit(options(oopts), add = TRUE)
[09:29:53.196]         }
[09:29:53.196]         {
[09:29:53.196]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.196]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.196]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.196]             })
[09:29:53.196]         }
[09:29:53.196]     }, args = future.call.arguments)
[09:29:53.196] }
[09:29:53.196] Lazy evaluation: FALSE
[09:29:53.196] Asynchronous evaluation: TRUE
[09:29:53.196] Local evaluation: TRUE
[09:29:53.196] Environment: R_GlobalEnv
[09:29:53.196] Capture standard output: TRUE
[09:29:53.196] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:53.196] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[09:29:53.196] Packages: <none>
[09:29:53.196] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:53.196] Resolved: FALSE
[09:29:53.196] Value: <not collected>
[09:29:53.196] Conditions captured: <none>
[09:29:53.196] Early signaling: FALSE
[09:29:53.196] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:53.196] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.208] Chunk #2 of 2 ... DONE
[09:29:53.208] Launching 2 futures (chunks) ... DONE
[09:29:53.208] Resolving 2 futures (chunks) ...
[09:29:53.208] resolve() on list ...
[09:29:53.208]  recursive: 0
[09:29:53.208]  length: 2
[09:29:53.208] 
[09:29:53.209] receiveMessageFromWorker() for ClusterFuture ...
[09:29:53.209] - Validating connection of MultisessionFuture
[09:29:53.209] - received message: FutureResult
[09:29:53.209] - Received FutureResult
[09:29:53.209] - Erased future from FutureRegistry
[09:29:53.209] result() for ClusterFuture ...
[09:29:53.210] - result already collected: FutureResult
[09:29:53.210] result() for ClusterFuture ... done
[09:29:53.210] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:53.210] Future #1
[09:29:53.210] result() for ClusterFuture ...
[09:29:53.210] - result already collected: FutureResult
[09:29:53.210] result() for ClusterFuture ... done
[09:29:53.210] result() for ClusterFuture ...
[09:29:53.210] - result already collected: FutureResult
[09:29:53.210] result() for ClusterFuture ... done
[09:29:53.210] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:53.210] - nx: 2
[09:29:53.211] - relay: TRUE
[09:29:53.211] - stdout: TRUE
[09:29:53.211] - signal: TRUE
[09:29:53.211] - resignal: FALSE
[09:29:53.211] - force: TRUE
[09:29:53.211] - relayed: [n=2] FALSE, FALSE
[09:29:53.211] - queued futures: [n=2] FALSE, FALSE
[09:29:53.211]  - until=1
[09:29:53.211]  - relaying element #1
[09:29:53.211] result() for ClusterFuture ...
[09:29:53.211] - result already collected: FutureResult
[09:29:53.211] result() for ClusterFuture ... done
[09:29:53.212] result() for ClusterFuture ...
[09:29:53.212] - result already collected: FutureResult
[09:29:53.212] result() for ClusterFuture ... done
[09:29:53.212] result() for ClusterFuture ...
[09:29:53.212] - result already collected: FutureResult
[09:29:53.212] result() for ClusterFuture ... done
[09:29:53.212] result() for ClusterFuture ...
[09:29:53.212] - result already collected: FutureResult
[09:29:53.212] result() for ClusterFuture ... done
[09:29:53.212] - relayed: [n=2] TRUE, FALSE
[09:29:53.212] - queued futures: [n=2] TRUE, FALSE
[09:29:53.213] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:53.213]  length: 1 (resolved future 1)
[09:29:53.237] receiveMessageFromWorker() for ClusterFuture ...
[09:29:53.238] - Validating connection of MultisessionFuture
[09:29:53.238] - received message: FutureResult
[09:29:53.238] - Received FutureResult
[09:29:53.238] - Erased future from FutureRegistry
[09:29:53.238] result() for ClusterFuture ...
[09:29:53.238] - result already collected: FutureResult
[09:29:53.238] result() for ClusterFuture ... done
[09:29:53.238] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:53.238] Future #2
[09:29:53.238] result() for ClusterFuture ...
[09:29:53.239] - result already collected: FutureResult
[09:29:53.239] result() for ClusterFuture ... done
[09:29:53.239] result() for ClusterFuture ...
[09:29:53.239] - result already collected: FutureResult
[09:29:53.239] result() for ClusterFuture ... done
[09:29:53.239] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:53.239] - nx: 2
[09:29:53.239] - relay: TRUE
[09:29:53.239] - stdout: TRUE
[09:29:53.239] - signal: TRUE
[09:29:53.239] - resignal: FALSE
[09:29:53.239] - force: TRUE
[09:29:53.240] - relayed: [n=2] TRUE, FALSE
[09:29:53.240] - queued futures: [n=2] TRUE, FALSE
[09:29:53.240]  - until=2
[09:29:53.240]  - relaying element #2
[09:29:53.240] result() for ClusterFuture ...
[09:29:53.240] - result already collected: FutureResult
[09:29:53.240] result() for ClusterFuture ... done
[09:29:53.240] result() for ClusterFuture ...
[09:29:53.240] - result already collected: FutureResult
[09:29:53.240] result() for ClusterFuture ... done
[09:29:53.240] result() for ClusterFuture ...
[09:29:53.241] - result already collected: FutureResult
[09:29:53.241] result() for ClusterFuture ... done
[09:29:53.241] result() for ClusterFuture ...
[09:29:53.241] - result already collected: FutureResult
[09:29:53.241] result() for ClusterFuture ... done
[09:29:53.241] - relayed: [n=2] TRUE, TRUE
[09:29:53.241] - queued futures: [n=2] TRUE, TRUE
[09:29:53.241] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:53.241]  length: 0 (resolved future 2)
[09:29:53.241] Relaying remaining futures
[09:29:53.241] signalConditionsASAP(NULL, pos=0) ...
[09:29:53.242] - nx: 2
[09:29:53.242] - relay: TRUE
[09:29:53.242] - stdout: TRUE
[09:29:53.242] - signal: TRUE
[09:29:53.242] - resignal: FALSE
[09:29:53.242] - force: TRUE
[09:29:53.242] - relayed: [n=2] TRUE, TRUE
[09:29:53.242] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:53.242] - relayed: [n=2] TRUE, TRUE
[09:29:53.242] - queued futures: [n=2] TRUE, TRUE
[09:29:53.242] signalConditionsASAP(NULL, pos=0) ... done
[09:29:53.242] resolve() on list ... DONE
[09:29:53.243] result() for ClusterFuture ...
[09:29:53.243] - result already collected: FutureResult
[09:29:53.243] result() for ClusterFuture ... done
[09:29:53.243] result() for ClusterFuture ...
[09:29:53.243] - result already collected: FutureResult
[09:29:53.243] result() for ClusterFuture ... done
[09:29:53.243] result() for ClusterFuture ...
[09:29:53.243] - result already collected: FutureResult
[09:29:53.243] result() for ClusterFuture ... done
[09:29:53.243] result() for ClusterFuture ...
[09:29:53.243] - result already collected: FutureResult
[09:29:53.243] result() for ClusterFuture ... done
[09:29:53.244]  - Number of value chunks collected: 2
[09:29:53.244] Resolving 2 futures (chunks) ... DONE
[09:29:53.244] Reducing values from 2 chunks ...
[09:29:53.244]  - Number of values collected after concatenation: 4
[09:29:53.244]  - Number of values expected: 4
[09:29:53.244] Reducing values from 2 chunks ... DONE
[09:29:53.244] future_lapply() ... DONE
[09:29:53.245] future_lapply() ...
[09:29:53.250] Number of chunks: 2
[09:29:53.250] getGlobalsAndPackagesXApply() ...
[09:29:53.250]  - future.globals: TRUE
[09:29:53.250] getGlobalsAndPackages() ...
[09:29:53.250] Searching for globals...
[09:29:53.254] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[09:29:53.254] Searching for globals ... DONE
[09:29:53.254] Resolving globals: FALSE
[09:29:53.255] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[09:29:53.255] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:53.255] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:53.255] - packages: [1] ‘future.apply’
[09:29:53.255] getGlobalsAndPackages() ... DONE
[09:29:53.256]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:53.256]  - needed namespaces: [n=1] ‘future.apply’
[09:29:53.256] Finding globals ... DONE
[09:29:53.256]  - use_args: TRUE
[09:29:53.256]  - Getting '...' globals ...
[09:29:53.256] resolve() on list ...
[09:29:53.256]  recursive: 0
[09:29:53.257]  length: 1
[09:29:53.257]  elements: ‘...’
[09:29:53.257]  length: 0 (resolved future 1)
[09:29:53.257] resolve() on list ... DONE
[09:29:53.257]    - '...' content: [n=1] ‘y’
[09:29:53.257] List of 1
[09:29:53.257]  $ ...:List of 1
[09:29:53.257]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:53.257]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:53.257]  - attr(*, "where")=List of 1
[09:29:53.257]   ..$ ...:<environment: 0x561d38d99b70> 
[09:29:53.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:53.257]  - attr(*, "resolved")= logi TRUE
[09:29:53.257]  - attr(*, "total_size")= num NA
[09:29:53.260]  - Getting '...' globals ... DONE
[09:29:53.260] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:53.260] List of 8
[09:29:53.260]  $ ...future.FUN:function (x, ...)  
[09:29:53.260]  $ x_FUN        :function (x, y)  
[09:29:53.260]  $ times        : int 15
[09:29:53.260]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:53.260]  $ stop_if_not  :function (...)  
[09:29:53.260]  $ dim          : int [1:2] 3 5
[09:29:53.260]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:53.260]  $ ...          :List of 1
[09:29:53.260]   ..$ y: num [1:5] 2 4 6 8 10
[09:29:53.260]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:53.260]  - attr(*, "where")=List of 8
[09:29:53.260]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:53.260]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:53.260]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:53.260]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:53.260]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:53.260]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:53.260]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:53.260]   ..$ ...          :<environment: 0x561d38d99b70> 
[09:29:53.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:53.260]  - attr(*, "resolved")= logi FALSE
[09:29:53.260]  - attr(*, "total_size")= num 98600
[09:29:53.266] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:53.266] getGlobalsAndPackagesXApply() ... DONE
[09:29:53.266] Number of futures (= number of chunks): 2
[09:29:53.266] Launching 2 futures (chunks) ...
[09:29:53.266] Chunk #1 of 2 ...
[09:29:53.267]  - Finding globals in 'X' for chunk #1 ...
[09:29:53.267] getGlobalsAndPackages() ...
[09:29:53.267] Searching for globals...
[09:29:53.267] 
[09:29:53.267] Searching for globals ... DONE
[09:29:53.267] - globals: [0] <none>
[09:29:53.267] getGlobalsAndPackages() ... DONE
[09:29:53.267]    + additional globals found: [n=0] 
[09:29:53.267]    + additional namespaces needed: [n=0] 
[09:29:53.267]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:53.270]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:53.270]  - seeds: <none>
[09:29:53.270]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.270] getGlobalsAndPackages() ...
[09:29:53.270] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.270] Resolving globals: FALSE
[09:29:53.270] Tweak future expression to call with '...' arguments ...
[09:29:53.271] {
[09:29:53.271]     do.call(function(...) {
[09:29:53.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.271]             on.exit(options(oopts), add = TRUE)
[09:29:53.271]         }
[09:29:53.271]         {
[09:29:53.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.271]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.271]             })
[09:29:53.271]         }
[09:29:53.271]     }, args = future.call.arguments)
[09:29:53.271] }
[09:29:53.271] Tweak future expression to call with '...' arguments ... DONE
[09:29:53.271] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.271] - packages: [1] ‘future.apply’
[09:29:53.272] getGlobalsAndPackages() ... DONE
[09:29:53.272] run() for ‘Future’ ...
[09:29:53.272] - state: ‘created’
[09:29:53.272] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:53.286] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:53.287]   - Field: ‘node’
[09:29:53.287]   - Field: ‘label’
[09:29:53.287]   - Field: ‘local’
[09:29:53.287]   - Field: ‘owner’
[09:29:53.287]   - Field: ‘envir’
[09:29:53.287]   - Field: ‘workers’
[09:29:53.287]   - Field: ‘packages’
[09:29:53.287]   - Field: ‘gc’
[09:29:53.287]   - Field: ‘conditions’
[09:29:53.287]   - Field: ‘persistent’
[09:29:53.287]   - Field: ‘expr’
[09:29:53.288]   - Field: ‘uuid’
[09:29:53.288]   - Field: ‘seed’
[09:29:53.288]   - Field: ‘version’
[09:29:53.288]   - Field: ‘result’
[09:29:53.288]   - Field: ‘asynchronous’
[09:29:53.288]   - Field: ‘calls’
[09:29:53.288]   - Field: ‘globals’
[09:29:53.288]   - Field: ‘stdout’
[09:29:53.288]   - Field: ‘earlySignal’
[09:29:53.288]   - Field: ‘lazy’
[09:29:53.288]   - Field: ‘state’
[09:29:53.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:53.289] - Launch lazy future ...
[09:29:53.289] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:53.289] Packages needed by future strategies (n = 0): <none>
[09:29:53.289] {
[09:29:53.289]     {
[09:29:53.289]         {
[09:29:53.289]             ...future.startTime <- base::Sys.time()
[09:29:53.289]             {
[09:29:53.289]                 {
[09:29:53.289]                   {
[09:29:53.289]                     {
[09:29:53.289]                       {
[09:29:53.289]                         base::local({
[09:29:53.289]                           has_future <- base::requireNamespace("future", 
[09:29:53.289]                             quietly = TRUE)
[09:29:53.289]                           if (has_future) {
[09:29:53.289]                             ns <- base::getNamespace("future")
[09:29:53.289]                             version <- ns[[".package"]][["version"]]
[09:29:53.289]                             if (is.null(version)) 
[09:29:53.289]                               version <- utils::packageVersion("future")
[09:29:53.289]                           }
[09:29:53.289]                           else {
[09:29:53.289]                             version <- NULL
[09:29:53.289]                           }
[09:29:53.289]                           if (!has_future || version < "1.8.0") {
[09:29:53.289]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:53.289]                               "", base::R.version$version.string), 
[09:29:53.289]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:53.289]                                 base::R.version$platform, 8 * 
[09:29:53.289]                                   base::.Machine$sizeof.pointer), 
[09:29:53.289]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:53.289]                                 "release", "version")], collapse = " "), 
[09:29:53.289]                               hostname = base::Sys.info()[["nodename"]])
[09:29:53.289]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:53.289]                               info)
[09:29:53.289]                             info <- base::paste(info, collapse = "; ")
[09:29:53.289]                             if (!has_future) {
[09:29:53.289]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:53.289]                                 info)
[09:29:53.289]                             }
[09:29:53.289]                             else {
[09:29:53.289]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:53.289]                                 info, version)
[09:29:53.289]                             }
[09:29:53.289]                             base::stop(msg)
[09:29:53.289]                           }
[09:29:53.289]                         })
[09:29:53.289]                       }
[09:29:53.289]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:53.289]                       base::options(mc.cores = 1L)
[09:29:53.289]                     }
[09:29:53.289]                     base::local({
[09:29:53.289]                       for (pkg in "future.apply") {
[09:29:53.289]                         base::loadNamespace(pkg)
[09:29:53.289]                         base::library(pkg, character.only = TRUE)
[09:29:53.289]                       }
[09:29:53.289]                     })
[09:29:53.289]                   }
[09:29:53.289]                   ...future.strategy.old <- future::plan("list")
[09:29:53.289]                   options(future.plan = NULL)
[09:29:53.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:53.289]                 }
[09:29:53.289]                 ...future.workdir <- getwd()
[09:29:53.289]             }
[09:29:53.289]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:53.289]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:53.289]         }
[09:29:53.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:53.289]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:53.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:53.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:53.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:53.289]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:53.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:53.289]             base::names(...future.oldOptions))
[09:29:53.289]     }
[09:29:53.289]     if (FALSE) {
[09:29:53.289]     }
[09:29:53.289]     else {
[09:29:53.289]         if (TRUE) {
[09:29:53.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:53.289]                 open = "w")
[09:29:53.289]         }
[09:29:53.289]         else {
[09:29:53.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:53.289]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:53.289]         }
[09:29:53.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:53.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:53.289]             base::sink(type = "output", split = FALSE)
[09:29:53.289]             base::close(...future.stdout)
[09:29:53.289]         }, add = TRUE)
[09:29:53.289]     }
[09:29:53.289]     ...future.frame <- base::sys.nframe()
[09:29:53.289]     ...future.conditions <- base::list()
[09:29:53.289]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:53.289]     if (FALSE) {
[09:29:53.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:53.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:53.289]     }
[09:29:53.289]     ...future.result <- base::tryCatch({
[09:29:53.289]         base::withCallingHandlers({
[09:29:53.289]             ...future.value <- base::withVisible(base::local({
[09:29:53.289]                 ...future.makeSendCondition <- base::local({
[09:29:53.289]                   sendCondition <- NULL
[09:29:53.289]                   function(frame = 1L) {
[09:29:53.289]                     if (is.function(sendCondition)) 
[09:29:53.289]                       return(sendCondition)
[09:29:53.289]                     ns <- getNamespace("parallel")
[09:29:53.289]                     if (exists("sendData", mode = "function", 
[09:29:53.289]                       envir = ns)) {
[09:29:53.289]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:53.289]                         envir = ns)
[09:29:53.289]                       envir <- sys.frame(frame)
[09:29:53.289]                       master <- NULL
[09:29:53.289]                       while (!identical(envir, .GlobalEnv) && 
[09:29:53.289]                         !identical(envir, emptyenv())) {
[09:29:53.289]                         if (exists("master", mode = "list", envir = envir, 
[09:29:53.289]                           inherits = FALSE)) {
[09:29:53.289]                           master <- get("master", mode = "list", 
[09:29:53.289]                             envir = envir, inherits = FALSE)
[09:29:53.289]                           if (inherits(master, c("SOCKnode", 
[09:29:53.289]                             "SOCK0node"))) {
[09:29:53.289]                             sendCondition <<- function(cond) {
[09:29:53.289]                               data <- list(type = "VALUE", value = cond, 
[09:29:53.289]                                 success = TRUE)
[09:29:53.289]                               parallel_sendData(master, data)
[09:29:53.289]                             }
[09:29:53.289]                             return(sendCondition)
[09:29:53.289]                           }
[09:29:53.289]                         }
[09:29:53.289]                         frame <- frame + 1L
[09:29:53.289]                         envir <- sys.frame(frame)
[09:29:53.289]                       }
[09:29:53.289]                     }
[09:29:53.289]                     sendCondition <<- function(cond) NULL
[09:29:53.289]                   }
[09:29:53.289]                 })
[09:29:53.289]                 withCallingHandlers({
[09:29:53.289]                   {
[09:29:53.289]                     do.call(function(...) {
[09:29:53.289]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.289]                       if (!identical(...future.globals.maxSize.org, 
[09:29:53.289]                         ...future.globals.maxSize)) {
[09:29:53.289]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.289]                         on.exit(options(oopts), add = TRUE)
[09:29:53.289]                       }
[09:29:53.289]                       {
[09:29:53.289]                         lapply(seq_along(...future.elements_ii), 
[09:29:53.289]                           FUN = function(jj) {
[09:29:53.289]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.289]                             ...future.FUN(...future.X_jj, ...)
[09:29:53.289]                           })
[09:29:53.289]                       }
[09:29:53.289]                     }, args = future.call.arguments)
[09:29:53.289]                   }
[09:29:53.289]                 }, immediateCondition = function(cond) {
[09:29:53.289]                   sendCondition <- ...future.makeSendCondition()
[09:29:53.289]                   sendCondition(cond)
[09:29:53.289]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.289]                   {
[09:29:53.289]                     inherits <- base::inherits
[09:29:53.289]                     invokeRestart <- base::invokeRestart
[09:29:53.289]                     is.null <- base::is.null
[09:29:53.289]                     muffled <- FALSE
[09:29:53.289]                     if (inherits(cond, "message")) {
[09:29:53.289]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:53.289]                       if (muffled) 
[09:29:53.289]                         invokeRestart("muffleMessage")
[09:29:53.289]                     }
[09:29:53.289]                     else if (inherits(cond, "warning")) {
[09:29:53.289]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:53.289]                       if (muffled) 
[09:29:53.289]                         invokeRestart("muffleWarning")
[09:29:53.289]                     }
[09:29:53.289]                     else if (inherits(cond, "condition")) {
[09:29:53.289]                       if (!is.null(pattern)) {
[09:29:53.289]                         computeRestarts <- base::computeRestarts
[09:29:53.289]                         grepl <- base::grepl
[09:29:53.289]                         restarts <- computeRestarts(cond)
[09:29:53.289]                         for (restart in restarts) {
[09:29:53.289]                           name <- restart$name
[09:29:53.289]                           if (is.null(name)) 
[09:29:53.289]                             next
[09:29:53.289]                           if (!grepl(pattern, name)) 
[09:29:53.289]                             next
[09:29:53.289]                           invokeRestart(restart)
[09:29:53.289]                           muffled <- TRUE
[09:29:53.289]                           break
[09:29:53.289]                         }
[09:29:53.289]                       }
[09:29:53.289]                     }
[09:29:53.289]                     invisible(muffled)
[09:29:53.289]                   }
[09:29:53.289]                   muffleCondition(cond)
[09:29:53.289]                 })
[09:29:53.289]             }))
[09:29:53.289]             future::FutureResult(value = ...future.value$value, 
[09:29:53.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.289]                   ...future.rng), globalenv = if (FALSE) 
[09:29:53.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:53.289]                     ...future.globalenv.names))
[09:29:53.289]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:53.289]         }, condition = base::local({
[09:29:53.289]             c <- base::c
[09:29:53.289]             inherits <- base::inherits
[09:29:53.289]             invokeRestart <- base::invokeRestart
[09:29:53.289]             length <- base::length
[09:29:53.289]             list <- base::list
[09:29:53.289]             seq.int <- base::seq.int
[09:29:53.289]             signalCondition <- base::signalCondition
[09:29:53.289]             sys.calls <- base::sys.calls
[09:29:53.289]             `[[` <- base::`[[`
[09:29:53.289]             `+` <- base::`+`
[09:29:53.289]             `<<-` <- base::`<<-`
[09:29:53.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:53.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:53.289]                   3L)]
[09:29:53.289]             }
[09:29:53.289]             function(cond) {
[09:29:53.289]                 is_error <- inherits(cond, "error")
[09:29:53.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:53.289]                   NULL)
[09:29:53.289]                 if (is_error) {
[09:29:53.289]                   sessionInformation <- function() {
[09:29:53.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:53.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:53.289]                       search = base::search(), system = base::Sys.info())
[09:29:53.289]                   }
[09:29:53.289]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:53.289]                     cond$call), session = sessionInformation(), 
[09:29:53.289]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:53.289]                   signalCondition(cond)
[09:29:53.289]                 }
[09:29:53.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:53.289]                 "immediateCondition"))) {
[09:29:53.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:53.289]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:53.289]                   if (TRUE && !signal) {
[09:29:53.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.289]                     {
[09:29:53.289]                       inherits <- base::inherits
[09:29:53.289]                       invokeRestart <- base::invokeRestart
[09:29:53.289]                       is.null <- base::is.null
[09:29:53.289]                       muffled <- FALSE
[09:29:53.289]                       if (inherits(cond, "message")) {
[09:29:53.289]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.289]                         if (muffled) 
[09:29:53.289]                           invokeRestart("muffleMessage")
[09:29:53.289]                       }
[09:29:53.289]                       else if (inherits(cond, "warning")) {
[09:29:53.289]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.289]                         if (muffled) 
[09:29:53.289]                           invokeRestart("muffleWarning")
[09:29:53.289]                       }
[09:29:53.289]                       else if (inherits(cond, "condition")) {
[09:29:53.289]                         if (!is.null(pattern)) {
[09:29:53.289]                           computeRestarts <- base::computeRestarts
[09:29:53.289]                           grepl <- base::grepl
[09:29:53.289]                           restarts <- computeRestarts(cond)
[09:29:53.289]                           for (restart in restarts) {
[09:29:53.289]                             name <- restart$name
[09:29:53.289]                             if (is.null(name)) 
[09:29:53.289]                               next
[09:29:53.289]                             if (!grepl(pattern, name)) 
[09:29:53.289]                               next
[09:29:53.289]                             invokeRestart(restart)
[09:29:53.289]                             muffled <- TRUE
[09:29:53.289]                             break
[09:29:53.289]                           }
[09:29:53.289]                         }
[09:29:53.289]                       }
[09:29:53.289]                       invisible(muffled)
[09:29:53.289]                     }
[09:29:53.289]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.289]                   }
[09:29:53.289]                 }
[09:29:53.289]                 else {
[09:29:53.289]                   if (TRUE) {
[09:29:53.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.289]                     {
[09:29:53.289]                       inherits <- base::inherits
[09:29:53.289]                       invokeRestart <- base::invokeRestart
[09:29:53.289]                       is.null <- base::is.null
[09:29:53.289]                       muffled <- FALSE
[09:29:53.289]                       if (inherits(cond, "message")) {
[09:29:53.289]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.289]                         if (muffled) 
[09:29:53.289]                           invokeRestart("muffleMessage")
[09:29:53.289]                       }
[09:29:53.289]                       else if (inherits(cond, "warning")) {
[09:29:53.289]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.289]                         if (muffled) 
[09:29:53.289]                           invokeRestart("muffleWarning")
[09:29:53.289]                       }
[09:29:53.289]                       else if (inherits(cond, "condition")) {
[09:29:53.289]                         if (!is.null(pattern)) {
[09:29:53.289]                           computeRestarts <- base::computeRestarts
[09:29:53.289]                           grepl <- base::grepl
[09:29:53.289]                           restarts <- computeRestarts(cond)
[09:29:53.289]                           for (restart in restarts) {
[09:29:53.289]                             name <- restart$name
[09:29:53.289]                             if (is.null(name)) 
[09:29:53.289]                               next
[09:29:53.289]                             if (!grepl(pattern, name)) 
[09:29:53.289]                               next
[09:29:53.289]                             invokeRestart(restart)
[09:29:53.289]                             muffled <- TRUE
[09:29:53.289]                             break
[09:29:53.289]                           }
[09:29:53.289]                         }
[09:29:53.289]                       }
[09:29:53.289]                       invisible(muffled)
[09:29:53.289]                     }
[09:29:53.289]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.289]                   }
[09:29:53.289]                 }
[09:29:53.289]             }
[09:29:53.289]         }))
[09:29:53.289]     }, error = function(ex) {
[09:29:53.289]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:53.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.289]                 ...future.rng), started = ...future.startTime, 
[09:29:53.289]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:53.289]             version = "1.8"), class = "FutureResult")
[09:29:53.289]     }, finally = {
[09:29:53.289]         if (!identical(...future.workdir, getwd())) 
[09:29:53.289]             setwd(...future.workdir)
[09:29:53.289]         {
[09:29:53.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:53.289]                 ...future.oldOptions$nwarnings <- NULL
[09:29:53.289]             }
[09:29:53.289]             base::options(...future.oldOptions)
[09:29:53.289]             if (.Platform$OS.type == "windows") {
[09:29:53.289]                 old_names <- names(...future.oldEnvVars)
[09:29:53.289]                 envs <- base::Sys.getenv()
[09:29:53.289]                 names <- names(envs)
[09:29:53.289]                 common <- intersect(names, old_names)
[09:29:53.289]                 added <- setdiff(names, old_names)
[09:29:53.289]                 removed <- setdiff(old_names, names)
[09:29:53.289]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:53.289]                   envs[common]]
[09:29:53.289]                 NAMES <- toupper(changed)
[09:29:53.289]                 args <- list()
[09:29:53.289]                 for (kk in seq_along(NAMES)) {
[09:29:53.289]                   name <- changed[[kk]]
[09:29:53.289]                   NAME <- NAMES[[kk]]
[09:29:53.289]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.289]                     next
[09:29:53.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.289]                 }
[09:29:53.289]                 NAMES <- toupper(added)
[09:29:53.289]                 for (kk in seq_along(NAMES)) {
[09:29:53.289]                   name <- added[[kk]]
[09:29:53.289]                   NAME <- NAMES[[kk]]
[09:29:53.289]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.289]                     next
[09:29:53.289]                   args[[name]] <- ""
[09:29:53.289]                 }
[09:29:53.289]                 NAMES <- toupper(removed)
[09:29:53.289]                 for (kk in seq_along(NAMES)) {
[09:29:53.289]                   name <- removed[[kk]]
[09:29:53.289]                   NAME <- NAMES[[kk]]
[09:29:53.289]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.289]                     next
[09:29:53.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.289]                 }
[09:29:53.289]                 if (length(args) > 0) 
[09:29:53.289]                   base::do.call(base::Sys.setenv, args = args)
[09:29:53.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:53.289]             }
[09:29:53.289]             else {
[09:29:53.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:53.289]             }
[09:29:53.289]             {
[09:29:53.289]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:53.289]                   0L) {
[09:29:53.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:53.289]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:53.289]                   base::options(opts)
[09:29:53.289]                 }
[09:29:53.289]                 {
[09:29:53.289]                   {
[09:29:53.289]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:53.289]                     NULL
[09:29:53.289]                   }
[09:29:53.289]                   options(future.plan = NULL)
[09:29:53.289]                   if (is.na(NA_character_)) 
[09:29:53.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:53.289]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:53.289]                     .init = FALSE)
[09:29:53.289]                 }
[09:29:53.289]             }
[09:29:53.289]         }
[09:29:53.289]     })
[09:29:53.289]     if (TRUE) {
[09:29:53.289]         base::sink(type = "output", split = FALSE)
[09:29:53.289]         if (TRUE) {
[09:29:53.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:53.289]         }
[09:29:53.289]         else {
[09:29:53.289]             ...future.result["stdout"] <- base::list(NULL)
[09:29:53.289]         }
[09:29:53.289]         base::close(...future.stdout)
[09:29:53.289]         ...future.stdout <- NULL
[09:29:53.289]     }
[09:29:53.289]     ...future.result$conditions <- ...future.conditions
[09:29:53.289]     ...future.result$finished <- base::Sys.time()
[09:29:53.289]     ...future.result
[09:29:53.289] }
[09:29:53.292] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[09:29:53.292] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:53.336] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:53.336] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[09:29:53.337] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[09:29:53.337] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:53.337] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:53.337] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:53.380] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:53.380] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:53.424] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:53.424] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[09:29:53.424] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[09:29:53.425] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:53.425] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:53.425] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[09:29:53.426] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[09:29:53.426] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:29:53.426] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:29:53.426] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:53.427] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.427] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:53.427] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.427] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[09:29:53.428] MultisessionFuture started
[09:29:53.428] - Launch lazy future ... done
[09:29:53.428] run() for ‘MultisessionFuture’ ... done
[09:29:53.428] Created future:
[09:29:53.429] receiveMessageFromWorker() for ClusterFuture ...
[09:29:53.430] - Validating connection of MultisessionFuture
[09:29:53.430] - received message: FutureResult
[09:29:53.430] - Received FutureResult
[09:29:53.430] - Erased future from FutureRegistry
[09:29:53.430] result() for ClusterFuture ...
[09:29:53.430] - result already collected: FutureResult
[09:29:53.430] result() for ClusterFuture ... done
[09:29:53.430] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:53.428] MultisessionFuture:
[09:29:53.428] Label: ‘future_vapply-1’
[09:29:53.428] Expression:
[09:29:53.428] {
[09:29:53.428]     do.call(function(...) {
[09:29:53.428]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.428]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.428]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.428]             on.exit(options(oopts), add = TRUE)
[09:29:53.428]         }
[09:29:53.428]         {
[09:29:53.428]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.428]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.428]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.428]             })
[09:29:53.428]         }
[09:29:53.428]     }, args = future.call.arguments)
[09:29:53.428] }
[09:29:53.428] Lazy evaluation: FALSE
[09:29:53.428] Asynchronous evaluation: TRUE
[09:29:53.428] Local evaluation: TRUE
[09:29:53.428] Environment: R_GlobalEnv
[09:29:53.428] Capture standard output: TRUE
[09:29:53.428] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:53.428] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:53.428] Packages: 1 packages (‘future.apply’)
[09:29:53.428] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:53.428] Resolved: TRUE
[09:29:53.428] Value: <not collected>
[09:29:53.428] Conditions captured: <none>
[09:29:53.428] Early signaling: FALSE
[09:29:53.428] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:53.428] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.431] Chunk #1 of 2 ... DONE
[09:29:53.431] Chunk #2 of 2 ...
[09:29:53.431]  - Finding globals in 'X' for chunk #2 ...
[09:29:53.431] getGlobalsAndPackages() ...
[09:29:53.431] Searching for globals...
[09:29:53.431] 
[09:29:53.431] Searching for globals ... DONE
[09:29:53.431] - globals: [0] <none>
[09:29:53.431] getGlobalsAndPackages() ... DONE
[09:29:53.432]    + additional globals found: [n=0] 
[09:29:53.432]    + additional namespaces needed: [n=0] 
[09:29:53.432]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:53.432]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:53.432]  - seeds: <none>
[09:29:53.432]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.432] getGlobalsAndPackages() ...
[09:29:53.432] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.432] Resolving globals: FALSE
[09:29:53.432] Tweak future expression to call with '...' arguments ...
[09:29:53.433] {
[09:29:53.433]     do.call(function(...) {
[09:29:53.433]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.433]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.433]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.433]             on.exit(options(oopts), add = TRUE)
[09:29:53.433]         }
[09:29:53.433]         {
[09:29:53.433]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.433]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.433]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.433]             })
[09:29:53.433]         }
[09:29:53.433]     }, args = future.call.arguments)
[09:29:53.433] }
[09:29:53.433] Tweak future expression to call with '...' arguments ... DONE
[09:29:53.433] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.433] - packages: [1] ‘future.apply’
[09:29:53.434] getGlobalsAndPackages() ... DONE
[09:29:53.434] run() for ‘Future’ ...
[09:29:53.434] - state: ‘created’
[09:29:53.434] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:53.451] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.451] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:53.451]   - Field: ‘node’
[09:29:53.451]   - Field: ‘label’
[09:29:53.451]   - Field: ‘local’
[09:29:53.451]   - Field: ‘owner’
[09:29:53.451]   - Field: ‘envir’
[09:29:53.451]   - Field: ‘workers’
[09:29:53.452]   - Field: ‘packages’
[09:29:53.452]   - Field: ‘gc’
[09:29:53.452]   - Field: ‘conditions’
[09:29:53.452]   - Field: ‘persistent’
[09:29:53.452]   - Field: ‘expr’
[09:29:53.452]   - Field: ‘uuid’
[09:29:53.452]   - Field: ‘seed’
[09:29:53.452]   - Field: ‘version’
[09:29:53.452]   - Field: ‘result’
[09:29:53.452]   - Field: ‘asynchronous’
[09:29:53.452]   - Field: ‘calls’
[09:29:53.453]   - Field: ‘globals’
[09:29:53.453]   - Field: ‘stdout’
[09:29:53.453]   - Field: ‘earlySignal’
[09:29:53.453]   - Field: ‘lazy’
[09:29:53.453]   - Field: ‘state’
[09:29:53.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:53.453] - Launch lazy future ...
[09:29:53.453] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:53.453] Packages needed by future strategies (n = 0): <none>
[09:29:53.454] {
[09:29:53.454]     {
[09:29:53.454]         {
[09:29:53.454]             ...future.startTime <- base::Sys.time()
[09:29:53.454]             {
[09:29:53.454]                 {
[09:29:53.454]                   {
[09:29:53.454]                     {
[09:29:53.454]                       {
[09:29:53.454]                         base::local({
[09:29:53.454]                           has_future <- base::requireNamespace("future", 
[09:29:53.454]                             quietly = TRUE)
[09:29:53.454]                           if (has_future) {
[09:29:53.454]                             ns <- base::getNamespace("future")
[09:29:53.454]                             version <- ns[[".package"]][["version"]]
[09:29:53.454]                             if (is.null(version)) 
[09:29:53.454]                               version <- utils::packageVersion("future")
[09:29:53.454]                           }
[09:29:53.454]                           else {
[09:29:53.454]                             version <- NULL
[09:29:53.454]                           }
[09:29:53.454]                           if (!has_future || version < "1.8.0") {
[09:29:53.454]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:53.454]                               "", base::R.version$version.string), 
[09:29:53.454]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:53.454]                                 base::R.version$platform, 8 * 
[09:29:53.454]                                   base::.Machine$sizeof.pointer), 
[09:29:53.454]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:53.454]                                 "release", "version")], collapse = " "), 
[09:29:53.454]                               hostname = base::Sys.info()[["nodename"]])
[09:29:53.454]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:53.454]                               info)
[09:29:53.454]                             info <- base::paste(info, collapse = "; ")
[09:29:53.454]                             if (!has_future) {
[09:29:53.454]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:53.454]                                 info)
[09:29:53.454]                             }
[09:29:53.454]                             else {
[09:29:53.454]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:53.454]                                 info, version)
[09:29:53.454]                             }
[09:29:53.454]                             base::stop(msg)
[09:29:53.454]                           }
[09:29:53.454]                         })
[09:29:53.454]                       }
[09:29:53.454]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:53.454]                       base::options(mc.cores = 1L)
[09:29:53.454]                     }
[09:29:53.454]                     base::local({
[09:29:53.454]                       for (pkg in "future.apply") {
[09:29:53.454]                         base::loadNamespace(pkg)
[09:29:53.454]                         base::library(pkg, character.only = TRUE)
[09:29:53.454]                       }
[09:29:53.454]                     })
[09:29:53.454]                   }
[09:29:53.454]                   ...future.strategy.old <- future::plan("list")
[09:29:53.454]                   options(future.plan = NULL)
[09:29:53.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:53.454]                 }
[09:29:53.454]                 ...future.workdir <- getwd()
[09:29:53.454]             }
[09:29:53.454]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:53.454]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:53.454]         }
[09:29:53.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:53.454]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:53.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:53.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:53.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:53.454]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:53.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:53.454]             base::names(...future.oldOptions))
[09:29:53.454]     }
[09:29:53.454]     if (FALSE) {
[09:29:53.454]     }
[09:29:53.454]     else {
[09:29:53.454]         if (TRUE) {
[09:29:53.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:53.454]                 open = "w")
[09:29:53.454]         }
[09:29:53.454]         else {
[09:29:53.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:53.454]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:53.454]         }
[09:29:53.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:53.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:53.454]             base::sink(type = "output", split = FALSE)
[09:29:53.454]             base::close(...future.stdout)
[09:29:53.454]         }, add = TRUE)
[09:29:53.454]     }
[09:29:53.454]     ...future.frame <- base::sys.nframe()
[09:29:53.454]     ...future.conditions <- base::list()
[09:29:53.454]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:53.454]     if (FALSE) {
[09:29:53.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:53.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:53.454]     }
[09:29:53.454]     ...future.result <- base::tryCatch({
[09:29:53.454]         base::withCallingHandlers({
[09:29:53.454]             ...future.value <- base::withVisible(base::local({
[09:29:53.454]                 ...future.makeSendCondition <- base::local({
[09:29:53.454]                   sendCondition <- NULL
[09:29:53.454]                   function(frame = 1L) {
[09:29:53.454]                     if (is.function(sendCondition)) 
[09:29:53.454]                       return(sendCondition)
[09:29:53.454]                     ns <- getNamespace("parallel")
[09:29:53.454]                     if (exists("sendData", mode = "function", 
[09:29:53.454]                       envir = ns)) {
[09:29:53.454]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:53.454]                         envir = ns)
[09:29:53.454]                       envir <- sys.frame(frame)
[09:29:53.454]                       master <- NULL
[09:29:53.454]                       while (!identical(envir, .GlobalEnv) && 
[09:29:53.454]                         !identical(envir, emptyenv())) {
[09:29:53.454]                         if (exists("master", mode = "list", envir = envir, 
[09:29:53.454]                           inherits = FALSE)) {
[09:29:53.454]                           master <- get("master", mode = "list", 
[09:29:53.454]                             envir = envir, inherits = FALSE)
[09:29:53.454]                           if (inherits(master, c("SOCKnode", 
[09:29:53.454]                             "SOCK0node"))) {
[09:29:53.454]                             sendCondition <<- function(cond) {
[09:29:53.454]                               data <- list(type = "VALUE", value = cond, 
[09:29:53.454]                                 success = TRUE)
[09:29:53.454]                               parallel_sendData(master, data)
[09:29:53.454]                             }
[09:29:53.454]                             return(sendCondition)
[09:29:53.454]                           }
[09:29:53.454]                         }
[09:29:53.454]                         frame <- frame + 1L
[09:29:53.454]                         envir <- sys.frame(frame)
[09:29:53.454]                       }
[09:29:53.454]                     }
[09:29:53.454]                     sendCondition <<- function(cond) NULL
[09:29:53.454]                   }
[09:29:53.454]                 })
[09:29:53.454]                 withCallingHandlers({
[09:29:53.454]                   {
[09:29:53.454]                     do.call(function(...) {
[09:29:53.454]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.454]                       if (!identical(...future.globals.maxSize.org, 
[09:29:53.454]                         ...future.globals.maxSize)) {
[09:29:53.454]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.454]                         on.exit(options(oopts), add = TRUE)
[09:29:53.454]                       }
[09:29:53.454]                       {
[09:29:53.454]                         lapply(seq_along(...future.elements_ii), 
[09:29:53.454]                           FUN = function(jj) {
[09:29:53.454]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.454]                             ...future.FUN(...future.X_jj, ...)
[09:29:53.454]                           })
[09:29:53.454]                       }
[09:29:53.454]                     }, args = future.call.arguments)
[09:29:53.454]                   }
[09:29:53.454]                 }, immediateCondition = function(cond) {
[09:29:53.454]                   sendCondition <- ...future.makeSendCondition()
[09:29:53.454]                   sendCondition(cond)
[09:29:53.454]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.454]                   {
[09:29:53.454]                     inherits <- base::inherits
[09:29:53.454]                     invokeRestart <- base::invokeRestart
[09:29:53.454]                     is.null <- base::is.null
[09:29:53.454]                     muffled <- FALSE
[09:29:53.454]                     if (inherits(cond, "message")) {
[09:29:53.454]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:53.454]                       if (muffled) 
[09:29:53.454]                         invokeRestart("muffleMessage")
[09:29:53.454]                     }
[09:29:53.454]                     else if (inherits(cond, "warning")) {
[09:29:53.454]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:53.454]                       if (muffled) 
[09:29:53.454]                         invokeRestart("muffleWarning")
[09:29:53.454]                     }
[09:29:53.454]                     else if (inherits(cond, "condition")) {
[09:29:53.454]                       if (!is.null(pattern)) {
[09:29:53.454]                         computeRestarts <- base::computeRestarts
[09:29:53.454]                         grepl <- base::grepl
[09:29:53.454]                         restarts <- computeRestarts(cond)
[09:29:53.454]                         for (restart in restarts) {
[09:29:53.454]                           name <- restart$name
[09:29:53.454]                           if (is.null(name)) 
[09:29:53.454]                             next
[09:29:53.454]                           if (!grepl(pattern, name)) 
[09:29:53.454]                             next
[09:29:53.454]                           invokeRestart(restart)
[09:29:53.454]                           muffled <- TRUE
[09:29:53.454]                           break
[09:29:53.454]                         }
[09:29:53.454]                       }
[09:29:53.454]                     }
[09:29:53.454]                     invisible(muffled)
[09:29:53.454]                   }
[09:29:53.454]                   muffleCondition(cond)
[09:29:53.454]                 })
[09:29:53.454]             }))
[09:29:53.454]             future::FutureResult(value = ...future.value$value, 
[09:29:53.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.454]                   ...future.rng), globalenv = if (FALSE) 
[09:29:53.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:53.454]                     ...future.globalenv.names))
[09:29:53.454]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:53.454]         }, condition = base::local({
[09:29:53.454]             c <- base::c
[09:29:53.454]             inherits <- base::inherits
[09:29:53.454]             invokeRestart <- base::invokeRestart
[09:29:53.454]             length <- base::length
[09:29:53.454]             list <- base::list
[09:29:53.454]             seq.int <- base::seq.int
[09:29:53.454]             signalCondition <- base::signalCondition
[09:29:53.454]             sys.calls <- base::sys.calls
[09:29:53.454]             `[[` <- base::`[[`
[09:29:53.454]             `+` <- base::`+`
[09:29:53.454]             `<<-` <- base::`<<-`
[09:29:53.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:53.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:53.454]                   3L)]
[09:29:53.454]             }
[09:29:53.454]             function(cond) {
[09:29:53.454]                 is_error <- inherits(cond, "error")
[09:29:53.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:53.454]                   NULL)
[09:29:53.454]                 if (is_error) {
[09:29:53.454]                   sessionInformation <- function() {
[09:29:53.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:53.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:53.454]                       search = base::search(), system = base::Sys.info())
[09:29:53.454]                   }
[09:29:53.454]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:53.454]                     cond$call), session = sessionInformation(), 
[09:29:53.454]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:53.454]                   signalCondition(cond)
[09:29:53.454]                 }
[09:29:53.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:53.454]                 "immediateCondition"))) {
[09:29:53.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:53.454]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:53.454]                   if (TRUE && !signal) {
[09:29:53.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.454]                     {
[09:29:53.454]                       inherits <- base::inherits
[09:29:53.454]                       invokeRestart <- base::invokeRestart
[09:29:53.454]                       is.null <- base::is.null
[09:29:53.454]                       muffled <- FALSE
[09:29:53.454]                       if (inherits(cond, "message")) {
[09:29:53.454]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.454]                         if (muffled) 
[09:29:53.454]                           invokeRestart("muffleMessage")
[09:29:53.454]                       }
[09:29:53.454]                       else if (inherits(cond, "warning")) {
[09:29:53.454]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.454]                         if (muffled) 
[09:29:53.454]                           invokeRestart("muffleWarning")
[09:29:53.454]                       }
[09:29:53.454]                       else if (inherits(cond, "condition")) {
[09:29:53.454]                         if (!is.null(pattern)) {
[09:29:53.454]                           computeRestarts <- base::computeRestarts
[09:29:53.454]                           grepl <- base::grepl
[09:29:53.454]                           restarts <- computeRestarts(cond)
[09:29:53.454]                           for (restart in restarts) {
[09:29:53.454]                             name <- restart$name
[09:29:53.454]                             if (is.null(name)) 
[09:29:53.454]                               next
[09:29:53.454]                             if (!grepl(pattern, name)) 
[09:29:53.454]                               next
[09:29:53.454]                             invokeRestart(restart)
[09:29:53.454]                             muffled <- TRUE
[09:29:53.454]                             break
[09:29:53.454]                           }
[09:29:53.454]                         }
[09:29:53.454]                       }
[09:29:53.454]                       invisible(muffled)
[09:29:53.454]                     }
[09:29:53.454]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.454]                   }
[09:29:53.454]                 }
[09:29:53.454]                 else {
[09:29:53.454]                   if (TRUE) {
[09:29:53.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.454]                     {
[09:29:53.454]                       inherits <- base::inherits
[09:29:53.454]                       invokeRestart <- base::invokeRestart
[09:29:53.454]                       is.null <- base::is.null
[09:29:53.454]                       muffled <- FALSE
[09:29:53.454]                       if (inherits(cond, "message")) {
[09:29:53.454]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.454]                         if (muffled) 
[09:29:53.454]                           invokeRestart("muffleMessage")
[09:29:53.454]                       }
[09:29:53.454]                       else if (inherits(cond, "warning")) {
[09:29:53.454]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.454]                         if (muffled) 
[09:29:53.454]                           invokeRestart("muffleWarning")
[09:29:53.454]                       }
[09:29:53.454]                       else if (inherits(cond, "condition")) {
[09:29:53.454]                         if (!is.null(pattern)) {
[09:29:53.454]                           computeRestarts <- base::computeRestarts
[09:29:53.454]                           grepl <- base::grepl
[09:29:53.454]                           restarts <- computeRestarts(cond)
[09:29:53.454]                           for (restart in restarts) {
[09:29:53.454]                             name <- restart$name
[09:29:53.454]                             if (is.null(name)) 
[09:29:53.454]                               next
[09:29:53.454]                             if (!grepl(pattern, name)) 
[09:29:53.454]                               next
[09:29:53.454]                             invokeRestart(restart)
[09:29:53.454]                             muffled <- TRUE
[09:29:53.454]                             break
[09:29:53.454]                           }
[09:29:53.454]                         }
[09:29:53.454]                       }
[09:29:53.454]                       invisible(muffled)
[09:29:53.454]                     }
[09:29:53.454]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.454]                   }
[09:29:53.454]                 }
[09:29:53.454]             }
[09:29:53.454]         }))
[09:29:53.454]     }, error = function(ex) {
[09:29:53.454]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:53.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.454]                 ...future.rng), started = ...future.startTime, 
[09:29:53.454]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:53.454]             version = "1.8"), class = "FutureResult")
[09:29:53.454]     }, finally = {
[09:29:53.454]         if (!identical(...future.workdir, getwd())) 
[09:29:53.454]             setwd(...future.workdir)
[09:29:53.454]         {
[09:29:53.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:53.454]                 ...future.oldOptions$nwarnings <- NULL
[09:29:53.454]             }
[09:29:53.454]             base::options(...future.oldOptions)
[09:29:53.454]             if (.Platform$OS.type == "windows") {
[09:29:53.454]                 old_names <- names(...future.oldEnvVars)
[09:29:53.454]                 envs <- base::Sys.getenv()
[09:29:53.454]                 names <- names(envs)
[09:29:53.454]                 common <- intersect(names, old_names)
[09:29:53.454]                 added <- setdiff(names, old_names)
[09:29:53.454]                 removed <- setdiff(old_names, names)
[09:29:53.454]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:53.454]                   envs[common]]
[09:29:53.454]                 NAMES <- toupper(changed)
[09:29:53.454]                 args <- list()
[09:29:53.454]                 for (kk in seq_along(NAMES)) {
[09:29:53.454]                   name <- changed[[kk]]
[09:29:53.454]                   NAME <- NAMES[[kk]]
[09:29:53.454]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.454]                     next
[09:29:53.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.454]                 }
[09:29:53.454]                 NAMES <- toupper(added)
[09:29:53.454]                 for (kk in seq_along(NAMES)) {
[09:29:53.454]                   name <- added[[kk]]
[09:29:53.454]                   NAME <- NAMES[[kk]]
[09:29:53.454]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.454]                     next
[09:29:53.454]                   args[[name]] <- ""
[09:29:53.454]                 }
[09:29:53.454]                 NAMES <- toupper(removed)
[09:29:53.454]                 for (kk in seq_along(NAMES)) {
[09:29:53.454]                   name <- removed[[kk]]
[09:29:53.454]                   NAME <- NAMES[[kk]]
[09:29:53.454]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.454]                     next
[09:29:53.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.454]                 }
[09:29:53.454]                 if (length(args) > 0) 
[09:29:53.454]                   base::do.call(base::Sys.setenv, args = args)
[09:29:53.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:53.454]             }
[09:29:53.454]             else {
[09:29:53.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:53.454]             }
[09:29:53.454]             {
[09:29:53.454]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:53.454]                   0L) {
[09:29:53.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:53.454]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:53.454]                   base::options(opts)
[09:29:53.454]                 }
[09:29:53.454]                 {
[09:29:53.454]                   {
[09:29:53.454]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:53.454]                     NULL
[09:29:53.454]                   }
[09:29:53.454]                   options(future.plan = NULL)
[09:29:53.454]                   if (is.na(NA_character_)) 
[09:29:53.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:53.454]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:53.454]                     .init = FALSE)
[09:29:53.454]                 }
[09:29:53.454]             }
[09:29:53.454]         }
[09:29:53.454]     })
[09:29:53.454]     if (TRUE) {
[09:29:53.454]         base::sink(type = "output", split = FALSE)
[09:29:53.454]         if (TRUE) {
[09:29:53.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:53.454]         }
[09:29:53.454]         else {
[09:29:53.454]             ...future.result["stdout"] <- base::list(NULL)
[09:29:53.454]         }
[09:29:53.454]         base::close(...future.stdout)
[09:29:53.454]         ...future.stdout <- NULL
[09:29:53.454]     }
[09:29:53.454]     ...future.result$conditions <- ...future.conditions
[09:29:53.454]     ...future.result$finished <- base::Sys.time()
[09:29:53.454]     ...future.result
[09:29:53.454] }
[09:29:53.457] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[09:29:53.457] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:53.500] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:53.500] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[09:29:53.501] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[09:29:53.501] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:53.501] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:53.501] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:53.544] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:53.544] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:53.588] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:53.588] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[09:29:53.589] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[09:29:53.589] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:53.589] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:53.589] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[09:29:53.590] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[09:29:53.590] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:29:53.590] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:29:53.590] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:53.591] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.591] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:53.591] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.591] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[09:29:53.592] MultisessionFuture started
[09:29:53.592] - Launch lazy future ... done
[09:29:53.592] run() for ‘MultisessionFuture’ ... done
[09:29:53.592] Created future:
[09:29:53.594] receiveMessageFromWorker() for ClusterFuture ...
[09:29:53.594] - Validating connection of MultisessionFuture
[09:29:53.594] - received message: FutureResult
[09:29:53.594] - Received FutureResult
[09:29:53.594] - Erased future from FutureRegistry
[09:29:53.594] result() for ClusterFuture ...
[09:29:53.594] - result already collected: FutureResult
[09:29:53.594] result() for ClusterFuture ... done
[09:29:53.594] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:53.592] MultisessionFuture:
[09:29:53.592] Label: ‘future_vapply-2’
[09:29:53.592] Expression:
[09:29:53.592] {
[09:29:53.592]     do.call(function(...) {
[09:29:53.592]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.592]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.592]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.592]             on.exit(options(oopts), add = TRUE)
[09:29:53.592]         }
[09:29:53.592]         {
[09:29:53.592]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.592]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.592]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.592]             })
[09:29:53.592]         }
[09:29:53.592]     }, args = future.call.arguments)
[09:29:53.592] }
[09:29:53.592] Lazy evaluation: FALSE
[09:29:53.592] Asynchronous evaluation: TRUE
[09:29:53.592] Local evaluation: TRUE
[09:29:53.592] Environment: R_GlobalEnv
[09:29:53.592] Capture standard output: TRUE
[09:29:53.592] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:53.592] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:53.592] Packages: 1 packages (‘future.apply’)
[09:29:53.592] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:53.592] Resolved: TRUE
[09:29:53.592] Value: <not collected>
[09:29:53.592] Conditions captured: <none>
[09:29:53.592] Early signaling: FALSE
[09:29:53.592] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:53.592] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.595] Chunk #2 of 2 ... DONE
[09:29:53.595] Launching 2 futures (chunks) ... DONE
[09:29:53.595] Resolving 2 futures (chunks) ...
[09:29:53.595] resolve() on list ...
[09:29:53.595]  recursive: 0
[09:29:53.595]  length: 2
[09:29:53.595] 
[09:29:53.595] Future #1
[09:29:53.595] result() for ClusterFuture ...
[09:29:53.596] - result already collected: FutureResult
[09:29:53.596] result() for ClusterFuture ... done
[09:29:53.596] result() for ClusterFuture ...
[09:29:53.596] - result already collected: FutureResult
[09:29:53.596] result() for ClusterFuture ... done
[09:29:53.596] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:53.596] - nx: 2
[09:29:53.596] - relay: TRUE
[09:29:53.596] - stdout: TRUE
[09:29:53.596] - signal: TRUE
[09:29:53.596] - resignal: FALSE
[09:29:53.596] - force: TRUE
[09:29:53.597] - relayed: [n=2] FALSE, FALSE
[09:29:53.597] - queued futures: [n=2] FALSE, FALSE
[09:29:53.597]  - until=1
[09:29:53.597]  - relaying element #1
[09:29:53.597] result() for ClusterFuture ...
[09:29:53.597] - result already collected: FutureResult
[09:29:53.597] result() for ClusterFuture ... done
[09:29:53.597] result() for ClusterFuture ...
[09:29:53.597] - result already collected: FutureResult
[09:29:53.597] result() for ClusterFuture ... done
[09:29:53.597] result() for ClusterFuture ...
[09:29:53.598] - result already collected: FutureResult
[09:29:53.598] result() for ClusterFuture ... done
[09:29:53.598] result() for ClusterFuture ...
[09:29:53.598] - result already collected: FutureResult
[09:29:53.598] result() for ClusterFuture ... done
[09:29:53.598] - relayed: [n=2] TRUE, FALSE
[09:29:53.598] - queued futures: [n=2] TRUE, FALSE
[09:29:53.598] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:53.598]  length: 1 (resolved future 1)
[09:29:53.598] Future #2
[09:29:53.598] result() for ClusterFuture ...
[09:29:53.599] - result already collected: FutureResult
[09:29:53.599] result() for ClusterFuture ... done
[09:29:53.599] result() for ClusterFuture ...
[09:29:53.599] - result already collected: FutureResult
[09:29:53.599] result() for ClusterFuture ... done
[09:29:53.599] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:53.599] - nx: 2
[09:29:53.599] - relay: TRUE
[09:29:53.599] - stdout: TRUE
[09:29:53.599] - signal: TRUE
[09:29:53.599] - resignal: FALSE
[09:29:53.599] - force: TRUE
[09:29:53.599] - relayed: [n=2] TRUE, FALSE
[09:29:53.600] - queued futures: [n=2] TRUE, FALSE
[09:29:53.600]  - until=2
[09:29:53.600]  - relaying element #2
[09:29:53.600] result() for ClusterFuture ...
[09:29:53.600] - result already collected: FutureResult
[09:29:53.600] result() for ClusterFuture ... done
[09:29:53.600] result() for ClusterFuture ...
[09:29:53.600] - result already collected: FutureResult
[09:29:53.600] result() for ClusterFuture ... done
[09:29:53.600] result() for ClusterFuture ...
[09:29:53.600] - result already collected: FutureResult
[09:29:53.601] result() for ClusterFuture ... done
[09:29:53.601] result() for ClusterFuture ...
[09:29:53.601] - result already collected: FutureResult
[09:29:53.601] result() for ClusterFuture ... done
[09:29:53.601] - relayed: [n=2] TRUE, TRUE
[09:29:53.601] - queued futures: [n=2] TRUE, TRUE
[09:29:53.601] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:53.601]  length: 0 (resolved future 2)
[09:29:53.601] Relaying remaining futures
[09:29:53.601] signalConditionsASAP(NULL, pos=0) ...
[09:29:53.601] - nx: 2
[09:29:53.601] - relay: TRUE
[09:29:53.602] - stdout: TRUE
[09:29:53.602] - signal: TRUE
[09:29:53.602] - resignal: FALSE
[09:29:53.602] - force: TRUE
[09:29:53.602] - relayed: [n=2] TRUE, TRUE
[09:29:53.602] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:53.602] - relayed: [n=2] TRUE, TRUE
[09:29:53.602] - queued futures: [n=2] TRUE, TRUE
[09:29:53.602] signalConditionsASAP(NULL, pos=0) ... done
[09:29:53.602] resolve() on list ... DONE
[09:29:53.602] result() for ClusterFuture ...
[09:29:53.602] - result already collected: FutureResult
[09:29:53.603] result() for ClusterFuture ... done
[09:29:53.603] result() for ClusterFuture ...
[09:29:53.603] - result already collected: FutureResult
[09:29:53.603] result() for ClusterFuture ... done
[09:29:53.603] result() for ClusterFuture ...
[09:29:53.603] - result already collected: FutureResult
[09:29:53.603] result() for ClusterFuture ... done
[09:29:53.603] result() for ClusterFuture ...
[09:29:53.603] - result already collected: FutureResult
[09:29:53.603] result() for ClusterFuture ... done
[09:29:53.603]  - Number of value chunks collected: 2
[09:29:53.604] Resolving 2 futures (chunks) ... DONE
[09:29:53.604] Reducing values from 2 chunks ...
[09:29:53.604]  - Number of values collected after concatenation: 4
[09:29:53.604]  - Number of values expected: 4
[09:29:53.604] Reducing values from 2 chunks ... DONE
[09:29:53.604] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[09:29:53.606] future_lapply() ...
[09:29:53.611] Number of chunks: 2
[09:29:53.611] getGlobalsAndPackagesXApply() ...
[09:29:53.611]  - future.globals: TRUE
[09:29:53.611] getGlobalsAndPackages() ...
[09:29:53.611] Searching for globals...
[09:29:53.614] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:53.614] Searching for globals ... DONE
[09:29:53.614] Resolving globals: FALSE
[09:29:53.615] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[09:29:53.615] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:53.615] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:53.615] - packages: [1] ‘future.apply’
[09:29:53.616] getGlobalsAndPackages() ... DONE
[09:29:53.616]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:53.616]  - needed namespaces: [n=1] ‘future.apply’
[09:29:53.616] Finding globals ... DONE
[09:29:53.616]  - use_args: TRUE
[09:29:53.616]  - Getting '...' globals ...
[09:29:53.616] resolve() on list ...
[09:29:53.616]  recursive: 0
[09:29:53.617]  length: 1
[09:29:53.617]  elements: ‘...’
[09:29:53.617]  length: 0 (resolved future 1)
[09:29:53.617] resolve() on list ... DONE
[09:29:53.617]    - '...' content: [n=0] 
[09:29:53.617] List of 1
[09:29:53.617]  $ ...: list()
[09:29:53.617]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:53.617]  - attr(*, "where")=List of 1
[09:29:53.617]   ..$ ...:<environment: 0x561d37a0d300> 
[09:29:53.617]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:53.617]  - attr(*, "resolved")= logi TRUE
[09:29:53.617]  - attr(*, "total_size")= num NA
[09:29:53.619]  - Getting '...' globals ... DONE
[09:29:53.620] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:53.620] List of 8
[09:29:53.620]  $ ...future.FUN:function (x, ...)  
[09:29:53.620]  $ x_FUN        :function (x)  
[09:29:53.620]  $ times        : int 1
[09:29:53.620]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:53.620]  $ stop_if_not  :function (...)  
[09:29:53.620]  $ dim          : NULL
[09:29:53.620]  $ valid_types  : chr "logical"
[09:29:53.620]  $ ...          : list()
[09:29:53.620]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:53.620]  - attr(*, "where")=List of 8
[09:29:53.620]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:53.620]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:53.620]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:53.620]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:53.620]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:53.620]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:53.620]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:53.620]   ..$ ...          :<environment: 0x561d37a0d300> 
[09:29:53.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:53.620]  - attr(*, "resolved")= logi FALSE
[09:29:53.620]  - attr(*, "total_size")= num 94200
[09:29:53.625] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:53.625] getGlobalsAndPackagesXApply() ... DONE
[09:29:53.625] Number of futures (= number of chunks): 2
[09:29:53.625] Launching 2 futures (chunks) ...
[09:29:53.625] Chunk #1 of 2 ...
[09:29:53.625]  - Finding globals in 'X' for chunk #1 ...
[09:29:53.626] getGlobalsAndPackages() ...
[09:29:53.626] Searching for globals...
[09:29:53.626] 
[09:29:53.626] Searching for globals ... DONE
[09:29:53.626] - globals: [0] <none>
[09:29:53.626] getGlobalsAndPackages() ... DONE
[09:29:53.626]    + additional globals found: [n=0] 
[09:29:53.626]    + additional namespaces needed: [n=0] 
[09:29:53.626]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:53.626]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:53.627]  - seeds: <none>
[09:29:53.627]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.627] getGlobalsAndPackages() ...
[09:29:53.627] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.627] Resolving globals: FALSE
[09:29:53.627] Tweak future expression to call with '...' arguments ...
[09:29:53.627] {
[09:29:53.627]     do.call(function(...) {
[09:29:53.627]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.627]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.627]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.627]             on.exit(options(oopts), add = TRUE)
[09:29:53.627]         }
[09:29:53.627]         {
[09:29:53.627]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.627]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.627]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.627]             })
[09:29:53.627]         }
[09:29:53.627]     }, args = future.call.arguments)
[09:29:53.627] }
[09:29:53.627] Tweak future expression to call with '...' arguments ... DONE
[09:29:53.628] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.628] - packages: [1] ‘future.apply’
[09:29:53.628] getGlobalsAndPackages() ... DONE
[09:29:53.628] run() for ‘Future’ ...
[09:29:53.629] - state: ‘created’
[09:29:53.629] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:53.642] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.642] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:53.642]   - Field: ‘node’
[09:29:53.642]   - Field: ‘label’
[09:29:53.643]   - Field: ‘local’
[09:29:53.643]   - Field: ‘owner’
[09:29:53.643]   - Field: ‘envir’
[09:29:53.643]   - Field: ‘workers’
[09:29:53.643]   - Field: ‘packages’
[09:29:53.643]   - Field: ‘gc’
[09:29:53.643]   - Field: ‘conditions’
[09:29:53.643]   - Field: ‘persistent’
[09:29:53.643]   - Field: ‘expr’
[09:29:53.643]   - Field: ‘uuid’
[09:29:53.643]   - Field: ‘seed’
[09:29:53.643]   - Field: ‘version’
[09:29:53.644]   - Field: ‘result’
[09:29:53.644]   - Field: ‘asynchronous’
[09:29:53.644]   - Field: ‘calls’
[09:29:53.644]   - Field: ‘globals’
[09:29:53.644]   - Field: ‘stdout’
[09:29:53.644]   - Field: ‘earlySignal’
[09:29:53.644]   - Field: ‘lazy’
[09:29:53.644]   - Field: ‘state’
[09:29:53.644] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:53.644] - Launch lazy future ...
[09:29:53.645] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:53.645] Packages needed by future strategies (n = 0): <none>
[09:29:53.645] {
[09:29:53.645]     {
[09:29:53.645]         {
[09:29:53.645]             ...future.startTime <- base::Sys.time()
[09:29:53.645]             {
[09:29:53.645]                 {
[09:29:53.645]                   {
[09:29:53.645]                     {
[09:29:53.645]                       {
[09:29:53.645]                         base::local({
[09:29:53.645]                           has_future <- base::requireNamespace("future", 
[09:29:53.645]                             quietly = TRUE)
[09:29:53.645]                           if (has_future) {
[09:29:53.645]                             ns <- base::getNamespace("future")
[09:29:53.645]                             version <- ns[[".package"]][["version"]]
[09:29:53.645]                             if (is.null(version)) 
[09:29:53.645]                               version <- utils::packageVersion("future")
[09:29:53.645]                           }
[09:29:53.645]                           else {
[09:29:53.645]                             version <- NULL
[09:29:53.645]                           }
[09:29:53.645]                           if (!has_future || version < "1.8.0") {
[09:29:53.645]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:53.645]                               "", base::R.version$version.string), 
[09:29:53.645]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:53.645]                                 base::R.version$platform, 8 * 
[09:29:53.645]                                   base::.Machine$sizeof.pointer), 
[09:29:53.645]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:53.645]                                 "release", "version")], collapse = " "), 
[09:29:53.645]                               hostname = base::Sys.info()[["nodename"]])
[09:29:53.645]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:53.645]                               info)
[09:29:53.645]                             info <- base::paste(info, collapse = "; ")
[09:29:53.645]                             if (!has_future) {
[09:29:53.645]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:53.645]                                 info)
[09:29:53.645]                             }
[09:29:53.645]                             else {
[09:29:53.645]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:53.645]                                 info, version)
[09:29:53.645]                             }
[09:29:53.645]                             base::stop(msg)
[09:29:53.645]                           }
[09:29:53.645]                         })
[09:29:53.645]                       }
[09:29:53.645]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:53.645]                       base::options(mc.cores = 1L)
[09:29:53.645]                     }
[09:29:53.645]                     base::local({
[09:29:53.645]                       for (pkg in "future.apply") {
[09:29:53.645]                         base::loadNamespace(pkg)
[09:29:53.645]                         base::library(pkg, character.only = TRUE)
[09:29:53.645]                       }
[09:29:53.645]                     })
[09:29:53.645]                   }
[09:29:53.645]                   ...future.strategy.old <- future::plan("list")
[09:29:53.645]                   options(future.plan = NULL)
[09:29:53.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:53.645]                 }
[09:29:53.645]                 ...future.workdir <- getwd()
[09:29:53.645]             }
[09:29:53.645]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:53.645]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:53.645]         }
[09:29:53.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:53.645]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:53.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:53.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:53.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:53.645]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:53.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:53.645]             base::names(...future.oldOptions))
[09:29:53.645]     }
[09:29:53.645]     if (FALSE) {
[09:29:53.645]     }
[09:29:53.645]     else {
[09:29:53.645]         if (TRUE) {
[09:29:53.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:53.645]                 open = "w")
[09:29:53.645]         }
[09:29:53.645]         else {
[09:29:53.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:53.645]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:53.645]         }
[09:29:53.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:53.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:53.645]             base::sink(type = "output", split = FALSE)
[09:29:53.645]             base::close(...future.stdout)
[09:29:53.645]         }, add = TRUE)
[09:29:53.645]     }
[09:29:53.645]     ...future.frame <- base::sys.nframe()
[09:29:53.645]     ...future.conditions <- base::list()
[09:29:53.645]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:53.645]     if (FALSE) {
[09:29:53.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:53.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:53.645]     }
[09:29:53.645]     ...future.result <- base::tryCatch({
[09:29:53.645]         base::withCallingHandlers({
[09:29:53.645]             ...future.value <- base::withVisible(base::local({
[09:29:53.645]                 ...future.makeSendCondition <- base::local({
[09:29:53.645]                   sendCondition <- NULL
[09:29:53.645]                   function(frame = 1L) {
[09:29:53.645]                     if (is.function(sendCondition)) 
[09:29:53.645]                       return(sendCondition)
[09:29:53.645]                     ns <- getNamespace("parallel")
[09:29:53.645]                     if (exists("sendData", mode = "function", 
[09:29:53.645]                       envir = ns)) {
[09:29:53.645]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:53.645]                         envir = ns)
[09:29:53.645]                       envir <- sys.frame(frame)
[09:29:53.645]                       master <- NULL
[09:29:53.645]                       while (!identical(envir, .GlobalEnv) && 
[09:29:53.645]                         !identical(envir, emptyenv())) {
[09:29:53.645]                         if (exists("master", mode = "list", envir = envir, 
[09:29:53.645]                           inherits = FALSE)) {
[09:29:53.645]                           master <- get("master", mode = "list", 
[09:29:53.645]                             envir = envir, inherits = FALSE)
[09:29:53.645]                           if (inherits(master, c("SOCKnode", 
[09:29:53.645]                             "SOCK0node"))) {
[09:29:53.645]                             sendCondition <<- function(cond) {
[09:29:53.645]                               data <- list(type = "VALUE", value = cond, 
[09:29:53.645]                                 success = TRUE)
[09:29:53.645]                               parallel_sendData(master, data)
[09:29:53.645]                             }
[09:29:53.645]                             return(sendCondition)
[09:29:53.645]                           }
[09:29:53.645]                         }
[09:29:53.645]                         frame <- frame + 1L
[09:29:53.645]                         envir <- sys.frame(frame)
[09:29:53.645]                       }
[09:29:53.645]                     }
[09:29:53.645]                     sendCondition <<- function(cond) NULL
[09:29:53.645]                   }
[09:29:53.645]                 })
[09:29:53.645]                 withCallingHandlers({
[09:29:53.645]                   {
[09:29:53.645]                     do.call(function(...) {
[09:29:53.645]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.645]                       if (!identical(...future.globals.maxSize.org, 
[09:29:53.645]                         ...future.globals.maxSize)) {
[09:29:53.645]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.645]                         on.exit(options(oopts), add = TRUE)
[09:29:53.645]                       }
[09:29:53.645]                       {
[09:29:53.645]                         lapply(seq_along(...future.elements_ii), 
[09:29:53.645]                           FUN = function(jj) {
[09:29:53.645]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.645]                             ...future.FUN(...future.X_jj, ...)
[09:29:53.645]                           })
[09:29:53.645]                       }
[09:29:53.645]                     }, args = future.call.arguments)
[09:29:53.645]                   }
[09:29:53.645]                 }, immediateCondition = function(cond) {
[09:29:53.645]                   sendCondition <- ...future.makeSendCondition()
[09:29:53.645]                   sendCondition(cond)
[09:29:53.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.645]                   {
[09:29:53.645]                     inherits <- base::inherits
[09:29:53.645]                     invokeRestart <- base::invokeRestart
[09:29:53.645]                     is.null <- base::is.null
[09:29:53.645]                     muffled <- FALSE
[09:29:53.645]                     if (inherits(cond, "message")) {
[09:29:53.645]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:53.645]                       if (muffled) 
[09:29:53.645]                         invokeRestart("muffleMessage")
[09:29:53.645]                     }
[09:29:53.645]                     else if (inherits(cond, "warning")) {
[09:29:53.645]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:53.645]                       if (muffled) 
[09:29:53.645]                         invokeRestart("muffleWarning")
[09:29:53.645]                     }
[09:29:53.645]                     else if (inherits(cond, "condition")) {
[09:29:53.645]                       if (!is.null(pattern)) {
[09:29:53.645]                         computeRestarts <- base::computeRestarts
[09:29:53.645]                         grepl <- base::grepl
[09:29:53.645]                         restarts <- computeRestarts(cond)
[09:29:53.645]                         for (restart in restarts) {
[09:29:53.645]                           name <- restart$name
[09:29:53.645]                           if (is.null(name)) 
[09:29:53.645]                             next
[09:29:53.645]                           if (!grepl(pattern, name)) 
[09:29:53.645]                             next
[09:29:53.645]                           invokeRestart(restart)
[09:29:53.645]                           muffled <- TRUE
[09:29:53.645]                           break
[09:29:53.645]                         }
[09:29:53.645]                       }
[09:29:53.645]                     }
[09:29:53.645]                     invisible(muffled)
[09:29:53.645]                   }
[09:29:53.645]                   muffleCondition(cond)
[09:29:53.645]                 })
[09:29:53.645]             }))
[09:29:53.645]             future::FutureResult(value = ...future.value$value, 
[09:29:53.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.645]                   ...future.rng), globalenv = if (FALSE) 
[09:29:53.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:53.645]                     ...future.globalenv.names))
[09:29:53.645]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:53.645]         }, condition = base::local({
[09:29:53.645]             c <- base::c
[09:29:53.645]             inherits <- base::inherits
[09:29:53.645]             invokeRestart <- base::invokeRestart
[09:29:53.645]             length <- base::length
[09:29:53.645]             list <- base::list
[09:29:53.645]             seq.int <- base::seq.int
[09:29:53.645]             signalCondition <- base::signalCondition
[09:29:53.645]             sys.calls <- base::sys.calls
[09:29:53.645]             `[[` <- base::`[[`
[09:29:53.645]             `+` <- base::`+`
[09:29:53.645]             `<<-` <- base::`<<-`
[09:29:53.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:53.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:53.645]                   3L)]
[09:29:53.645]             }
[09:29:53.645]             function(cond) {
[09:29:53.645]                 is_error <- inherits(cond, "error")
[09:29:53.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:53.645]                   NULL)
[09:29:53.645]                 if (is_error) {
[09:29:53.645]                   sessionInformation <- function() {
[09:29:53.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:53.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:53.645]                       search = base::search(), system = base::Sys.info())
[09:29:53.645]                   }
[09:29:53.645]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:53.645]                     cond$call), session = sessionInformation(), 
[09:29:53.645]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:53.645]                   signalCondition(cond)
[09:29:53.645]                 }
[09:29:53.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:53.645]                 "immediateCondition"))) {
[09:29:53.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:53.645]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:53.645]                   if (TRUE && !signal) {
[09:29:53.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.645]                     {
[09:29:53.645]                       inherits <- base::inherits
[09:29:53.645]                       invokeRestart <- base::invokeRestart
[09:29:53.645]                       is.null <- base::is.null
[09:29:53.645]                       muffled <- FALSE
[09:29:53.645]                       if (inherits(cond, "message")) {
[09:29:53.645]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.645]                         if (muffled) 
[09:29:53.645]                           invokeRestart("muffleMessage")
[09:29:53.645]                       }
[09:29:53.645]                       else if (inherits(cond, "warning")) {
[09:29:53.645]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.645]                         if (muffled) 
[09:29:53.645]                           invokeRestart("muffleWarning")
[09:29:53.645]                       }
[09:29:53.645]                       else if (inherits(cond, "condition")) {
[09:29:53.645]                         if (!is.null(pattern)) {
[09:29:53.645]                           computeRestarts <- base::computeRestarts
[09:29:53.645]                           grepl <- base::grepl
[09:29:53.645]                           restarts <- computeRestarts(cond)
[09:29:53.645]                           for (restart in restarts) {
[09:29:53.645]                             name <- restart$name
[09:29:53.645]                             if (is.null(name)) 
[09:29:53.645]                               next
[09:29:53.645]                             if (!grepl(pattern, name)) 
[09:29:53.645]                               next
[09:29:53.645]                             invokeRestart(restart)
[09:29:53.645]                             muffled <- TRUE
[09:29:53.645]                             break
[09:29:53.645]                           }
[09:29:53.645]                         }
[09:29:53.645]                       }
[09:29:53.645]                       invisible(muffled)
[09:29:53.645]                     }
[09:29:53.645]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.645]                   }
[09:29:53.645]                 }
[09:29:53.645]                 else {
[09:29:53.645]                   if (TRUE) {
[09:29:53.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.645]                     {
[09:29:53.645]                       inherits <- base::inherits
[09:29:53.645]                       invokeRestart <- base::invokeRestart
[09:29:53.645]                       is.null <- base::is.null
[09:29:53.645]                       muffled <- FALSE
[09:29:53.645]                       if (inherits(cond, "message")) {
[09:29:53.645]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.645]                         if (muffled) 
[09:29:53.645]                           invokeRestart("muffleMessage")
[09:29:53.645]                       }
[09:29:53.645]                       else if (inherits(cond, "warning")) {
[09:29:53.645]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.645]                         if (muffled) 
[09:29:53.645]                           invokeRestart("muffleWarning")
[09:29:53.645]                       }
[09:29:53.645]                       else if (inherits(cond, "condition")) {
[09:29:53.645]                         if (!is.null(pattern)) {
[09:29:53.645]                           computeRestarts <- base::computeRestarts
[09:29:53.645]                           grepl <- base::grepl
[09:29:53.645]                           restarts <- computeRestarts(cond)
[09:29:53.645]                           for (restart in restarts) {
[09:29:53.645]                             name <- restart$name
[09:29:53.645]                             if (is.null(name)) 
[09:29:53.645]                               next
[09:29:53.645]                             if (!grepl(pattern, name)) 
[09:29:53.645]                               next
[09:29:53.645]                             invokeRestart(restart)
[09:29:53.645]                             muffled <- TRUE
[09:29:53.645]                             break
[09:29:53.645]                           }
[09:29:53.645]                         }
[09:29:53.645]                       }
[09:29:53.645]                       invisible(muffled)
[09:29:53.645]                     }
[09:29:53.645]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.645]                   }
[09:29:53.645]                 }
[09:29:53.645]             }
[09:29:53.645]         }))
[09:29:53.645]     }, error = function(ex) {
[09:29:53.645]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:53.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.645]                 ...future.rng), started = ...future.startTime, 
[09:29:53.645]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:53.645]             version = "1.8"), class = "FutureResult")
[09:29:53.645]     }, finally = {
[09:29:53.645]         if (!identical(...future.workdir, getwd())) 
[09:29:53.645]             setwd(...future.workdir)
[09:29:53.645]         {
[09:29:53.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:53.645]                 ...future.oldOptions$nwarnings <- NULL
[09:29:53.645]             }
[09:29:53.645]             base::options(...future.oldOptions)
[09:29:53.645]             if (.Platform$OS.type == "windows") {
[09:29:53.645]                 old_names <- names(...future.oldEnvVars)
[09:29:53.645]                 envs <- base::Sys.getenv()
[09:29:53.645]                 names <- names(envs)
[09:29:53.645]                 common <- intersect(names, old_names)
[09:29:53.645]                 added <- setdiff(names, old_names)
[09:29:53.645]                 removed <- setdiff(old_names, names)
[09:29:53.645]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:53.645]                   envs[common]]
[09:29:53.645]                 NAMES <- toupper(changed)
[09:29:53.645]                 args <- list()
[09:29:53.645]                 for (kk in seq_along(NAMES)) {
[09:29:53.645]                   name <- changed[[kk]]
[09:29:53.645]                   NAME <- NAMES[[kk]]
[09:29:53.645]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.645]                     next
[09:29:53.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.645]                 }
[09:29:53.645]                 NAMES <- toupper(added)
[09:29:53.645]                 for (kk in seq_along(NAMES)) {
[09:29:53.645]                   name <- added[[kk]]
[09:29:53.645]                   NAME <- NAMES[[kk]]
[09:29:53.645]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.645]                     next
[09:29:53.645]                   args[[name]] <- ""
[09:29:53.645]                 }
[09:29:53.645]                 NAMES <- toupper(removed)
[09:29:53.645]                 for (kk in seq_along(NAMES)) {
[09:29:53.645]                   name <- removed[[kk]]
[09:29:53.645]                   NAME <- NAMES[[kk]]
[09:29:53.645]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.645]                     next
[09:29:53.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.645]                 }
[09:29:53.645]                 if (length(args) > 0) 
[09:29:53.645]                   base::do.call(base::Sys.setenv, args = args)
[09:29:53.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:53.645]             }
[09:29:53.645]             else {
[09:29:53.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:53.645]             }
[09:29:53.645]             {
[09:29:53.645]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:53.645]                   0L) {
[09:29:53.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:53.645]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:53.645]                   base::options(opts)
[09:29:53.645]                 }
[09:29:53.645]                 {
[09:29:53.645]                   {
[09:29:53.645]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:53.645]                     NULL
[09:29:53.645]                   }
[09:29:53.645]                   options(future.plan = NULL)
[09:29:53.645]                   if (is.na(NA_character_)) 
[09:29:53.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:53.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:53.645]                     .init = FALSE)
[09:29:53.645]                 }
[09:29:53.645]             }
[09:29:53.645]         }
[09:29:53.645]     })
[09:29:53.645]     if (TRUE) {
[09:29:53.645]         base::sink(type = "output", split = FALSE)
[09:29:53.645]         if (TRUE) {
[09:29:53.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:53.645]         }
[09:29:53.645]         else {
[09:29:53.645]             ...future.result["stdout"] <- base::list(NULL)
[09:29:53.645]         }
[09:29:53.645]         base::close(...future.stdout)
[09:29:53.645]         ...future.stdout <- NULL
[09:29:53.645]     }
[09:29:53.645]     ...future.result$conditions <- ...future.conditions
[09:29:53.645]     ...future.result$finished <- base::Sys.time()
[09:29:53.645]     ...future.result
[09:29:53.645] }
[09:29:53.648] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[09:29:53.648] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:53.692] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:53.692] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[09:29:53.693] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[09:29:53.693] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:53.693] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:53.693] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:53.736] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:53.736] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:53.780] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:53.780] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:53.781] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.781] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[09:29:53.781] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[09:29:53.782] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:53.782] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.782] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[09:29:53.783] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[09:29:53.783] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:53.783] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.784] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:53.784] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:53.784] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[09:29:53.785] MultisessionFuture started
[09:29:53.785] - Launch lazy future ... done
[09:29:53.785] run() for ‘MultisessionFuture’ ... done
[09:29:53.786] Created future:
[09:29:53.786] MultisessionFuture:
[09:29:53.786] Label: ‘future_vapply-1’
[09:29:53.786] Expression:
[09:29:53.786] {
[09:29:53.786]     do.call(function(...) {
[09:29:53.786]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.786]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.786]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.786]             on.exit(options(oopts), add = TRUE)
[09:29:53.786]         }
[09:29:53.786]         {
[09:29:53.786]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.786]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.786]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.786]             })
[09:29:53.786]         }
[09:29:53.786]     }, args = future.call.arguments)
[09:29:53.786] }
[09:29:53.786] Lazy evaluation: FALSE
[09:29:53.786] Asynchronous evaluation: TRUE
[09:29:53.786] Local evaluation: TRUE
[09:29:53.786] Environment: R_GlobalEnv
[09:29:53.786] Capture standard output: TRUE
[09:29:53.786] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:53.786] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:53.786] Packages: 1 packages (‘future.apply’)
[09:29:53.786] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:53.786] Resolved: FALSE
[09:29:53.786] Value: <not collected>
[09:29:53.786] Conditions captured: <none>
[09:29:53.786] Early signaling: FALSE
[09:29:53.786] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:53.786] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.799] Chunk #1 of 2 ... DONE
[09:29:53.799] Chunk #2 of 2 ...
[09:29:53.799]  - Finding globals in 'X' for chunk #2 ...
[09:29:53.799] getGlobalsAndPackages() ...
[09:29:53.799] Searching for globals...
[09:29:53.800] 
[09:29:53.800] Searching for globals ... DONE
[09:29:53.800] - globals: [0] <none>
[09:29:53.800] getGlobalsAndPackages() ... DONE
[09:29:53.801]    + additional globals found: [n=0] 
[09:29:53.801]    + additional namespaces needed: [n=0] 
[09:29:53.801]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:53.801]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:53.801]  - seeds: <none>
[09:29:53.801]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.802] getGlobalsAndPackages() ...
[09:29:53.802] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.802] Resolving globals: FALSE
[09:29:53.802] Tweak future expression to call with '...' arguments ...
[09:29:53.802] {
[09:29:53.802]     do.call(function(...) {
[09:29:53.802]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.802]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.802]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.802]             on.exit(options(oopts), add = TRUE)
[09:29:53.802]         }
[09:29:53.802]         {
[09:29:53.802]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.802]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.802]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.802]             })
[09:29:53.802]         }
[09:29:53.802]     }, args = future.call.arguments)
[09:29:53.802] }
[09:29:53.803] Tweak future expression to call with '...' arguments ... DONE
[09:29:53.804] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:53.804] - packages: [1] ‘future.apply’
[09:29:53.804] getGlobalsAndPackages() ... DONE
[09:29:53.805] run() for ‘Future’ ...
[09:29:53.805] - state: ‘created’
[09:29:53.805] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:53.825] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:53.825]   - Field: ‘node’
[09:29:53.825]   - Field: ‘label’
[09:29:53.825]   - Field: ‘local’
[09:29:53.825]   - Field: ‘owner’
[09:29:53.825]   - Field: ‘envir’
[09:29:53.825]   - Field: ‘workers’
[09:29:53.825]   - Field: ‘packages’
[09:29:53.825]   - Field: ‘gc’
[09:29:53.826]   - Field: ‘conditions’
[09:29:53.826]   - Field: ‘persistent’
[09:29:53.826]   - Field: ‘expr’
[09:29:53.826]   - Field: ‘uuid’
[09:29:53.826]   - Field: ‘seed’
[09:29:53.826]   - Field: ‘version’
[09:29:53.826]   - Field: ‘result’
[09:29:53.826]   - Field: ‘asynchronous’
[09:29:53.826]   - Field: ‘calls’
[09:29:53.826]   - Field: ‘globals’
[09:29:53.826]   - Field: ‘stdout’
[09:29:53.826]   - Field: ‘earlySignal’
[09:29:53.827]   - Field: ‘lazy’
[09:29:53.827]   - Field: ‘state’
[09:29:53.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:53.827] - Launch lazy future ...
[09:29:53.827] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:53.827] Packages needed by future strategies (n = 0): <none>
[09:29:53.828] {
[09:29:53.828]     {
[09:29:53.828]         {
[09:29:53.828]             ...future.startTime <- base::Sys.time()
[09:29:53.828]             {
[09:29:53.828]                 {
[09:29:53.828]                   {
[09:29:53.828]                     {
[09:29:53.828]                       {
[09:29:53.828]                         base::local({
[09:29:53.828]                           has_future <- base::requireNamespace("future", 
[09:29:53.828]                             quietly = TRUE)
[09:29:53.828]                           if (has_future) {
[09:29:53.828]                             ns <- base::getNamespace("future")
[09:29:53.828]                             version <- ns[[".package"]][["version"]]
[09:29:53.828]                             if (is.null(version)) 
[09:29:53.828]                               version <- utils::packageVersion("future")
[09:29:53.828]                           }
[09:29:53.828]                           else {
[09:29:53.828]                             version <- NULL
[09:29:53.828]                           }
[09:29:53.828]                           if (!has_future || version < "1.8.0") {
[09:29:53.828]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:53.828]                               "", base::R.version$version.string), 
[09:29:53.828]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:53.828]                                 base::R.version$platform, 8 * 
[09:29:53.828]                                   base::.Machine$sizeof.pointer), 
[09:29:53.828]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:53.828]                                 "release", "version")], collapse = " "), 
[09:29:53.828]                               hostname = base::Sys.info()[["nodename"]])
[09:29:53.828]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:53.828]                               info)
[09:29:53.828]                             info <- base::paste(info, collapse = "; ")
[09:29:53.828]                             if (!has_future) {
[09:29:53.828]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:53.828]                                 info)
[09:29:53.828]                             }
[09:29:53.828]                             else {
[09:29:53.828]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:53.828]                                 info, version)
[09:29:53.828]                             }
[09:29:53.828]                             base::stop(msg)
[09:29:53.828]                           }
[09:29:53.828]                         })
[09:29:53.828]                       }
[09:29:53.828]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:53.828]                       base::options(mc.cores = 1L)
[09:29:53.828]                     }
[09:29:53.828]                     base::local({
[09:29:53.828]                       for (pkg in "future.apply") {
[09:29:53.828]                         base::loadNamespace(pkg)
[09:29:53.828]                         base::library(pkg, character.only = TRUE)
[09:29:53.828]                       }
[09:29:53.828]                     })
[09:29:53.828]                   }
[09:29:53.828]                   ...future.strategy.old <- future::plan("list")
[09:29:53.828]                   options(future.plan = NULL)
[09:29:53.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:53.828]                 }
[09:29:53.828]                 ...future.workdir <- getwd()
[09:29:53.828]             }
[09:29:53.828]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:53.828]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:53.828]         }
[09:29:53.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:53.828]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:53.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:53.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:53.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:53.828]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:53.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:53.828]             base::names(...future.oldOptions))
[09:29:53.828]     }
[09:29:53.828]     if (FALSE) {
[09:29:53.828]     }
[09:29:53.828]     else {
[09:29:53.828]         if (TRUE) {
[09:29:53.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:53.828]                 open = "w")
[09:29:53.828]         }
[09:29:53.828]         else {
[09:29:53.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:53.828]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:53.828]         }
[09:29:53.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:53.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:53.828]             base::sink(type = "output", split = FALSE)
[09:29:53.828]             base::close(...future.stdout)
[09:29:53.828]         }, add = TRUE)
[09:29:53.828]     }
[09:29:53.828]     ...future.frame <- base::sys.nframe()
[09:29:53.828]     ...future.conditions <- base::list()
[09:29:53.828]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:53.828]     if (FALSE) {
[09:29:53.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:53.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:53.828]     }
[09:29:53.828]     ...future.result <- base::tryCatch({
[09:29:53.828]         base::withCallingHandlers({
[09:29:53.828]             ...future.value <- base::withVisible(base::local({
[09:29:53.828]                 ...future.makeSendCondition <- base::local({
[09:29:53.828]                   sendCondition <- NULL
[09:29:53.828]                   function(frame = 1L) {
[09:29:53.828]                     if (is.function(sendCondition)) 
[09:29:53.828]                       return(sendCondition)
[09:29:53.828]                     ns <- getNamespace("parallel")
[09:29:53.828]                     if (exists("sendData", mode = "function", 
[09:29:53.828]                       envir = ns)) {
[09:29:53.828]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:53.828]                         envir = ns)
[09:29:53.828]                       envir <- sys.frame(frame)
[09:29:53.828]                       master <- NULL
[09:29:53.828]                       while (!identical(envir, .GlobalEnv) && 
[09:29:53.828]                         !identical(envir, emptyenv())) {
[09:29:53.828]                         if (exists("master", mode = "list", envir = envir, 
[09:29:53.828]                           inherits = FALSE)) {
[09:29:53.828]                           master <- get("master", mode = "list", 
[09:29:53.828]                             envir = envir, inherits = FALSE)
[09:29:53.828]                           if (inherits(master, c("SOCKnode", 
[09:29:53.828]                             "SOCK0node"))) {
[09:29:53.828]                             sendCondition <<- function(cond) {
[09:29:53.828]                               data <- list(type = "VALUE", value = cond, 
[09:29:53.828]                                 success = TRUE)
[09:29:53.828]                               parallel_sendData(master, data)
[09:29:53.828]                             }
[09:29:53.828]                             return(sendCondition)
[09:29:53.828]                           }
[09:29:53.828]                         }
[09:29:53.828]                         frame <- frame + 1L
[09:29:53.828]                         envir <- sys.frame(frame)
[09:29:53.828]                       }
[09:29:53.828]                     }
[09:29:53.828]                     sendCondition <<- function(cond) NULL
[09:29:53.828]                   }
[09:29:53.828]                 })
[09:29:53.828]                 withCallingHandlers({
[09:29:53.828]                   {
[09:29:53.828]                     do.call(function(...) {
[09:29:53.828]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.828]                       if (!identical(...future.globals.maxSize.org, 
[09:29:53.828]                         ...future.globals.maxSize)) {
[09:29:53.828]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.828]                         on.exit(options(oopts), add = TRUE)
[09:29:53.828]                       }
[09:29:53.828]                       {
[09:29:53.828]                         lapply(seq_along(...future.elements_ii), 
[09:29:53.828]                           FUN = function(jj) {
[09:29:53.828]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.828]                             ...future.FUN(...future.X_jj, ...)
[09:29:53.828]                           })
[09:29:53.828]                       }
[09:29:53.828]                     }, args = future.call.arguments)
[09:29:53.828]                   }
[09:29:53.828]                 }, immediateCondition = function(cond) {
[09:29:53.828]                   sendCondition <- ...future.makeSendCondition()
[09:29:53.828]                   sendCondition(cond)
[09:29:53.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.828]                   {
[09:29:53.828]                     inherits <- base::inherits
[09:29:53.828]                     invokeRestart <- base::invokeRestart
[09:29:53.828]                     is.null <- base::is.null
[09:29:53.828]                     muffled <- FALSE
[09:29:53.828]                     if (inherits(cond, "message")) {
[09:29:53.828]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:53.828]                       if (muffled) 
[09:29:53.828]                         invokeRestart("muffleMessage")
[09:29:53.828]                     }
[09:29:53.828]                     else if (inherits(cond, "warning")) {
[09:29:53.828]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:53.828]                       if (muffled) 
[09:29:53.828]                         invokeRestart("muffleWarning")
[09:29:53.828]                     }
[09:29:53.828]                     else if (inherits(cond, "condition")) {
[09:29:53.828]                       if (!is.null(pattern)) {
[09:29:53.828]                         computeRestarts <- base::computeRestarts
[09:29:53.828]                         grepl <- base::grepl
[09:29:53.828]                         restarts <- computeRestarts(cond)
[09:29:53.828]                         for (restart in restarts) {
[09:29:53.828]                           name <- restart$name
[09:29:53.828]                           if (is.null(name)) 
[09:29:53.828]                             next
[09:29:53.828]                           if (!grepl(pattern, name)) 
[09:29:53.828]                             next
[09:29:53.828]                           invokeRestart(restart)
[09:29:53.828]                           muffled <- TRUE
[09:29:53.828]                           break
[09:29:53.828]                         }
[09:29:53.828]                       }
[09:29:53.828]                     }
[09:29:53.828]                     invisible(muffled)
[09:29:53.828]                   }
[09:29:53.828]                   muffleCondition(cond)
[09:29:53.828]                 })
[09:29:53.828]             }))
[09:29:53.828]             future::FutureResult(value = ...future.value$value, 
[09:29:53.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.828]                   ...future.rng), globalenv = if (FALSE) 
[09:29:53.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:53.828]                     ...future.globalenv.names))
[09:29:53.828]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:53.828]         }, condition = base::local({
[09:29:53.828]             c <- base::c
[09:29:53.828]             inherits <- base::inherits
[09:29:53.828]             invokeRestart <- base::invokeRestart
[09:29:53.828]             length <- base::length
[09:29:53.828]             list <- base::list
[09:29:53.828]             seq.int <- base::seq.int
[09:29:53.828]             signalCondition <- base::signalCondition
[09:29:53.828]             sys.calls <- base::sys.calls
[09:29:53.828]             `[[` <- base::`[[`
[09:29:53.828]             `+` <- base::`+`
[09:29:53.828]             `<<-` <- base::`<<-`
[09:29:53.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:53.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:53.828]                   3L)]
[09:29:53.828]             }
[09:29:53.828]             function(cond) {
[09:29:53.828]                 is_error <- inherits(cond, "error")
[09:29:53.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:53.828]                   NULL)
[09:29:53.828]                 if (is_error) {
[09:29:53.828]                   sessionInformation <- function() {
[09:29:53.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:53.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:53.828]                       search = base::search(), system = base::Sys.info())
[09:29:53.828]                   }
[09:29:53.828]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:53.828]                     cond$call), session = sessionInformation(), 
[09:29:53.828]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:53.828]                   signalCondition(cond)
[09:29:53.828]                 }
[09:29:53.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:53.828]                 "immediateCondition"))) {
[09:29:53.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:53.828]                   ...future.conditions[[length(...future.conditions) + 
[09:29:53.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:53.828]                   if (TRUE && !signal) {
[09:29:53.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.828]                     {
[09:29:53.828]                       inherits <- base::inherits
[09:29:53.828]                       invokeRestart <- base::invokeRestart
[09:29:53.828]                       is.null <- base::is.null
[09:29:53.828]                       muffled <- FALSE
[09:29:53.828]                       if (inherits(cond, "message")) {
[09:29:53.828]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.828]                         if (muffled) 
[09:29:53.828]                           invokeRestart("muffleMessage")
[09:29:53.828]                       }
[09:29:53.828]                       else if (inherits(cond, "warning")) {
[09:29:53.828]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.828]                         if (muffled) 
[09:29:53.828]                           invokeRestart("muffleWarning")
[09:29:53.828]                       }
[09:29:53.828]                       else if (inherits(cond, "condition")) {
[09:29:53.828]                         if (!is.null(pattern)) {
[09:29:53.828]                           computeRestarts <- base::computeRestarts
[09:29:53.828]                           grepl <- base::grepl
[09:29:53.828]                           restarts <- computeRestarts(cond)
[09:29:53.828]                           for (restart in restarts) {
[09:29:53.828]                             name <- restart$name
[09:29:53.828]                             if (is.null(name)) 
[09:29:53.828]                               next
[09:29:53.828]                             if (!grepl(pattern, name)) 
[09:29:53.828]                               next
[09:29:53.828]                             invokeRestart(restart)
[09:29:53.828]                             muffled <- TRUE
[09:29:53.828]                             break
[09:29:53.828]                           }
[09:29:53.828]                         }
[09:29:53.828]                       }
[09:29:53.828]                       invisible(muffled)
[09:29:53.828]                     }
[09:29:53.828]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.828]                   }
[09:29:53.828]                 }
[09:29:53.828]                 else {
[09:29:53.828]                   if (TRUE) {
[09:29:53.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:53.828]                     {
[09:29:53.828]                       inherits <- base::inherits
[09:29:53.828]                       invokeRestart <- base::invokeRestart
[09:29:53.828]                       is.null <- base::is.null
[09:29:53.828]                       muffled <- FALSE
[09:29:53.828]                       if (inherits(cond, "message")) {
[09:29:53.828]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:53.828]                         if (muffled) 
[09:29:53.828]                           invokeRestart("muffleMessage")
[09:29:53.828]                       }
[09:29:53.828]                       else if (inherits(cond, "warning")) {
[09:29:53.828]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:53.828]                         if (muffled) 
[09:29:53.828]                           invokeRestart("muffleWarning")
[09:29:53.828]                       }
[09:29:53.828]                       else if (inherits(cond, "condition")) {
[09:29:53.828]                         if (!is.null(pattern)) {
[09:29:53.828]                           computeRestarts <- base::computeRestarts
[09:29:53.828]                           grepl <- base::grepl
[09:29:53.828]                           restarts <- computeRestarts(cond)
[09:29:53.828]                           for (restart in restarts) {
[09:29:53.828]                             name <- restart$name
[09:29:53.828]                             if (is.null(name)) 
[09:29:53.828]                               next
[09:29:53.828]                             if (!grepl(pattern, name)) 
[09:29:53.828]                               next
[09:29:53.828]                             invokeRestart(restart)
[09:29:53.828]                             muffled <- TRUE
[09:29:53.828]                             break
[09:29:53.828]                           }
[09:29:53.828]                         }
[09:29:53.828]                       }
[09:29:53.828]                       invisible(muffled)
[09:29:53.828]                     }
[09:29:53.828]                     muffleCondition(cond, pattern = "^muffle")
[09:29:53.828]                   }
[09:29:53.828]                 }
[09:29:53.828]             }
[09:29:53.828]         }))
[09:29:53.828]     }, error = function(ex) {
[09:29:53.828]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:53.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:53.828]                 ...future.rng), started = ...future.startTime, 
[09:29:53.828]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:53.828]             version = "1.8"), class = "FutureResult")
[09:29:53.828]     }, finally = {
[09:29:53.828]         if (!identical(...future.workdir, getwd())) 
[09:29:53.828]             setwd(...future.workdir)
[09:29:53.828]         {
[09:29:53.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:53.828]                 ...future.oldOptions$nwarnings <- NULL
[09:29:53.828]             }
[09:29:53.828]             base::options(...future.oldOptions)
[09:29:53.828]             if (.Platform$OS.type == "windows") {
[09:29:53.828]                 old_names <- names(...future.oldEnvVars)
[09:29:53.828]                 envs <- base::Sys.getenv()
[09:29:53.828]                 names <- names(envs)
[09:29:53.828]                 common <- intersect(names, old_names)
[09:29:53.828]                 added <- setdiff(names, old_names)
[09:29:53.828]                 removed <- setdiff(old_names, names)
[09:29:53.828]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:53.828]                   envs[common]]
[09:29:53.828]                 NAMES <- toupper(changed)
[09:29:53.828]                 args <- list()
[09:29:53.828]                 for (kk in seq_along(NAMES)) {
[09:29:53.828]                   name <- changed[[kk]]
[09:29:53.828]                   NAME <- NAMES[[kk]]
[09:29:53.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.828]                     next
[09:29:53.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.828]                 }
[09:29:53.828]                 NAMES <- toupper(added)
[09:29:53.828]                 for (kk in seq_along(NAMES)) {
[09:29:53.828]                   name <- added[[kk]]
[09:29:53.828]                   NAME <- NAMES[[kk]]
[09:29:53.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.828]                     next
[09:29:53.828]                   args[[name]] <- ""
[09:29:53.828]                 }
[09:29:53.828]                 NAMES <- toupper(removed)
[09:29:53.828]                 for (kk in seq_along(NAMES)) {
[09:29:53.828]                   name <- removed[[kk]]
[09:29:53.828]                   NAME <- NAMES[[kk]]
[09:29:53.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:53.828]                     next
[09:29:53.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:53.828]                 }
[09:29:53.828]                 if (length(args) > 0) 
[09:29:53.828]                   base::do.call(base::Sys.setenv, args = args)
[09:29:53.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:53.828]             }
[09:29:53.828]             else {
[09:29:53.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:53.828]             }
[09:29:53.828]             {
[09:29:53.828]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:53.828]                   0L) {
[09:29:53.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:53.828]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:53.828]                   base::options(opts)
[09:29:53.828]                 }
[09:29:53.828]                 {
[09:29:53.828]                   {
[09:29:53.828]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:53.828]                     NULL
[09:29:53.828]                   }
[09:29:53.828]                   options(future.plan = NULL)
[09:29:53.828]                   if (is.na(NA_character_)) 
[09:29:53.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:53.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:53.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:53.828]                     .init = FALSE)
[09:29:53.828]                 }
[09:29:53.828]             }
[09:29:53.828]         }
[09:29:53.828]     })
[09:29:53.828]     if (TRUE) {
[09:29:53.828]         base::sink(type = "output", split = FALSE)
[09:29:53.828]         if (TRUE) {
[09:29:53.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:53.828]         }
[09:29:53.828]         else {
[09:29:53.828]             ...future.result["stdout"] <- base::list(NULL)
[09:29:53.828]         }
[09:29:53.828]         base::close(...future.stdout)
[09:29:53.828]         ...future.stdout <- NULL
[09:29:53.828]     }
[09:29:53.828]     ...future.result$conditions <- ...future.conditions
[09:29:53.828]     ...future.result$finished <- base::Sys.time()
[09:29:53.828]     ...future.result
[09:29:53.828] }
[09:29:53.830] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[09:29:53.831] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[09:29:53.872] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[09:29:53.872] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[09:29:53.873] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[09:29:53.873] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[09:29:53.873] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[09:29:53.873] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[09:29:53.916] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[09:29:53.916] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[09:29:53.960] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[09:29:53.960] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[09:29:53.961] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[09:29:53.961] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[09:29:53.961] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[09:29:53.961] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:29:53.962] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:29:53.962] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[09:29:53.962] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[09:29:53.962] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:53.963] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:53.963] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:53.963] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:53.963] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[09:29:53.964] MultisessionFuture started
[09:29:53.964] - Launch lazy future ... done
[09:29:53.964] run() for ‘MultisessionFuture’ ... done
[09:29:53.964] Created future:
[09:29:53.964] MultisessionFuture:
[09:29:53.964] Label: ‘future_vapply-2’
[09:29:53.964] Expression:
[09:29:53.964] {
[09:29:53.964]     do.call(function(...) {
[09:29:53.964]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:53.964]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:53.964]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:53.964]             on.exit(options(oopts), add = TRUE)
[09:29:53.964]         }
[09:29:53.964]         {
[09:29:53.964]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:53.964]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:53.964]                 ...future.FUN(...future.X_jj, ...)
[09:29:53.964]             })
[09:29:53.964]         }
[09:29:53.964]     }, args = future.call.arguments)
[09:29:53.964] }
[09:29:53.964] Lazy evaluation: FALSE
[09:29:53.964] Asynchronous evaluation: TRUE
[09:29:53.964] Local evaluation: TRUE
[09:29:53.964] Environment: R_GlobalEnv
[09:29:53.964] Capture standard output: TRUE
[09:29:53.964] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:53.964] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:53.964] Packages: 1 packages (‘future.apply’)
[09:29:53.964] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:53.964] Resolved: FALSE
[09:29:53.964] Value: <not collected>
[09:29:53.964] Conditions captured: <none>
[09:29:53.964] Early signaling: FALSE
[09:29:53.964] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:53.964] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:53.976] Chunk #2 of 2 ... DONE
[09:29:53.976] Launching 2 futures (chunks) ... DONE
[09:29:53.976] Resolving 2 futures (chunks) ...
[09:29:53.976] resolve() on list ...
[09:29:53.976]  recursive: 0
[09:29:53.976]  length: 2
[09:29:53.977] 
[09:29:53.977] receiveMessageFromWorker() for ClusterFuture ...
[09:29:53.977] - Validating connection of MultisessionFuture
[09:29:53.977] - received message: FutureResult
[09:29:53.977] - Received FutureResult
[09:29:53.977] - Erased future from FutureRegistry
[09:29:53.978] result() for ClusterFuture ...
[09:29:53.978] - result already collected: FutureResult
[09:29:53.978] result() for ClusterFuture ... done
[09:29:53.978] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:53.978] Future #1
[09:29:53.978] result() for ClusterFuture ...
[09:29:53.978] - result already collected: FutureResult
[09:29:53.978] result() for ClusterFuture ... done
[09:29:53.978] result() for ClusterFuture ...
[09:29:53.978] - result already collected: FutureResult
[09:29:53.978] result() for ClusterFuture ... done
[09:29:53.978] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:53.979] - nx: 2
[09:29:53.979] - relay: TRUE
[09:29:53.979] - stdout: TRUE
[09:29:53.979] - signal: TRUE
[09:29:53.979] - resignal: FALSE
[09:29:53.979] - force: TRUE
[09:29:53.979] - relayed: [n=2] FALSE, FALSE
[09:29:53.979] - queued futures: [n=2] FALSE, FALSE
[09:29:53.979]  - until=1
[09:29:53.979]  - relaying element #1
[09:29:53.979] result() for ClusterFuture ...
[09:29:53.979] - result already collected: FutureResult
[09:29:53.980] result() for ClusterFuture ... done
[09:29:53.980] result() for ClusterFuture ...
[09:29:53.980] - result already collected: FutureResult
[09:29:53.980] result() for ClusterFuture ... done
[09:29:53.980] result() for ClusterFuture ...
[09:29:53.980] - result already collected: FutureResult
[09:29:53.980] result() for ClusterFuture ... done
[09:29:53.980] result() for ClusterFuture ...
[09:29:53.980] - result already collected: FutureResult
[09:29:53.980] result() for ClusterFuture ... done
[09:29:53.980] - relayed: [n=2] TRUE, FALSE
[09:29:53.981] - queued futures: [n=2] TRUE, FALSE
[09:29:53.981] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:53.981]  length: 1 (resolved future 1)
[09:29:54.009] receiveMessageFromWorker() for ClusterFuture ...
[09:29:54.010] - Validating connection of MultisessionFuture
[09:29:54.010] - received message: FutureResult
[09:29:54.010] - Received FutureResult
[09:29:54.010] - Erased future from FutureRegistry
[09:29:54.010] result() for ClusterFuture ...
[09:29:54.010] - result already collected: FutureResult
[09:29:54.010] result() for ClusterFuture ... done
[09:29:54.010] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:54.011] Future #2
[09:29:54.011] result() for ClusterFuture ...
[09:29:54.011] - result already collected: FutureResult
[09:29:54.011] result() for ClusterFuture ... done
[09:29:54.011] result() for ClusterFuture ...
[09:29:54.011] - result already collected: FutureResult
[09:29:54.011] result() for ClusterFuture ... done
[09:29:54.011] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:54.011] - nx: 2
[09:29:54.011] - relay: TRUE
[09:29:54.011] - stdout: TRUE
[09:29:54.011] - signal: TRUE
[09:29:54.012] - resignal: FALSE
[09:29:54.012] - force: TRUE
[09:29:54.012] - relayed: [n=2] TRUE, FALSE
[09:29:54.012] - queued futures: [n=2] TRUE, FALSE
[09:29:54.012]  - until=2
[09:29:54.012]  - relaying element #2
[09:29:54.012] result() for ClusterFuture ...
[09:29:54.012] - result already collected: FutureResult
[09:29:54.012] result() for ClusterFuture ... done
[09:29:54.012] result() for ClusterFuture ...
[09:29:54.012] - result already collected: FutureResult
[09:29:54.013] result() for ClusterFuture ... done
[09:29:54.013] result() for ClusterFuture ...
[09:29:54.013] - result already collected: FutureResult
[09:29:54.013] result() for ClusterFuture ... done
[09:29:54.013] result() for ClusterFuture ...
[09:29:54.013] - result already collected: FutureResult
[09:29:54.013] result() for ClusterFuture ... done
[09:29:54.013] - relayed: [n=2] TRUE, TRUE
[09:29:54.013] - queued futures: [n=2] TRUE, TRUE
[09:29:54.013] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:54.014]  length: 0 (resolved future 2)
[09:29:54.014] Relaying remaining futures
[09:29:54.014] signalConditionsASAP(NULL, pos=0) ...
[09:29:54.014] - nx: 2
[09:29:54.014] - relay: TRUE
[09:29:54.014] - stdout: TRUE
[09:29:54.014] - signal: TRUE
[09:29:54.014] - resignal: FALSE
[09:29:54.014] - force: TRUE
[09:29:54.014] - relayed: [n=2] TRUE, TRUE
[09:29:54.014] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:54.014] - relayed: [n=2] TRUE, TRUE
[09:29:54.015] - queued futures: [n=2] TRUE, TRUE
[09:29:54.015] signalConditionsASAP(NULL, pos=0) ... done
[09:29:54.015] resolve() on list ... DONE
[09:29:54.015] result() for ClusterFuture ...
[09:29:54.015] - result already collected: FutureResult
[09:29:54.015] result() for ClusterFuture ... done
[09:29:54.015] result() for ClusterFuture ...
[09:29:54.015] - result already collected: FutureResult
[09:29:54.015] result() for ClusterFuture ... done
[09:29:54.015] result() for ClusterFuture ...
[09:29:54.015] - result already collected: FutureResult
[09:29:54.015] result() for ClusterFuture ... done
[09:29:54.016] result() for ClusterFuture ...
[09:29:54.016] - result already collected: FutureResult
[09:29:54.016] result() for ClusterFuture ... done
[09:29:54.016]  - Number of value chunks collected: 2
[09:29:54.016] Resolving 2 futures (chunks) ... DONE
[09:29:54.016] Reducing values from 2 chunks ...
[09:29:54.016]  - Number of values collected after concatenation: 11
[09:29:54.016]  - Number of values expected: 11
[09:29:54.016] Reducing values from 2 chunks ... DONE
[09:29:54.016] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[09:29:54.017] future_lapply() ...
[09:29:54.023] Number of chunks: 2
[09:29:54.023] getGlobalsAndPackagesXApply() ...
[09:29:54.023]  - future.globals: TRUE
[09:29:54.023] getGlobalsAndPackages() ...
[09:29:54.023] Searching for globals...
[09:29:54.026] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:54.027] Searching for globals ... DONE
[09:29:54.027] Resolving globals: FALSE
[09:29:54.027] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[09:29:54.028] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:54.028] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:54.028] - packages: [1] ‘future.apply’
[09:29:54.028] getGlobalsAndPackages() ... DONE
[09:29:54.028]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:54.028]  - needed namespaces: [n=1] ‘future.apply’
[09:29:54.029] Finding globals ... DONE
[09:29:54.029]  - use_args: TRUE
[09:29:54.029]  - Getting '...' globals ...
[09:29:54.029] resolve() on list ...
[09:29:54.029]  recursive: 0
[09:29:54.029]  length: 1
[09:29:54.029]  elements: ‘...’
[09:29:54.029]  length: 0 (resolved future 1)
[09:29:54.029] resolve() on list ... DONE
[09:29:54.030]    - '...' content: [n=0] 
[09:29:54.030] List of 1
[09:29:54.030]  $ ...: list()
[09:29:54.030]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:54.030]  - attr(*, "where")=List of 1
[09:29:54.030]   ..$ ...:<environment: 0x561d3788a430> 
[09:29:54.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:54.030]  - attr(*, "resolved")= logi TRUE
[09:29:54.030]  - attr(*, "total_size")= num NA
[09:29:54.032]  - Getting '...' globals ... DONE
[09:29:54.032] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:54.032] List of 8
[09:29:54.032]  $ ...future.FUN:function (x, ...)  
[09:29:54.032]  $ x_FUN        :function (x)  
[09:29:54.032]  $ times        : int 1
[09:29:54.032]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:54.032]  $ stop_if_not  :function (...)  
[09:29:54.032]  $ dim          : NULL
[09:29:54.032]  $ valid_types  : chr [1:2] "logical" "integer"
[09:29:54.032]  $ ...          : list()
[09:29:54.032]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:54.032]  - attr(*, "where")=List of 8
[09:29:54.032]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:54.032]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:54.032]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:54.032]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:54.032]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:54.032]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:54.032]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:54.032]   ..$ ...          :<environment: 0x561d3788a430> 
[09:29:54.032]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:54.032]  - attr(*, "resolved")= logi FALSE
[09:29:54.032]  - attr(*, "total_size")= num 94264
[09:29:54.037] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:54.038] getGlobalsAndPackagesXApply() ... DONE
[09:29:54.038] Number of futures (= number of chunks): 2
[09:29:54.038] Launching 2 futures (chunks) ...
[09:29:54.038] Chunk #1 of 2 ...
[09:29:54.038]  - Finding globals in 'X' for chunk #1 ...
[09:29:54.038] getGlobalsAndPackages() ...
[09:29:54.038] Searching for globals...
[09:29:54.038] 
[09:29:54.039] Searching for globals ... DONE
[09:29:54.039] - globals: [0] <none>
[09:29:54.039] getGlobalsAndPackages() ... DONE
[09:29:54.039]    + additional globals found: [n=0] 
[09:29:54.039]    + additional namespaces needed: [n=0] 
[09:29:54.039]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:54.039]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:54.039]  - seeds: <none>
[09:29:54.039]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.039] getGlobalsAndPackages() ...
[09:29:54.039] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.040] Resolving globals: FALSE
[09:29:54.040] Tweak future expression to call with '...' arguments ...
[09:29:54.040] {
[09:29:54.040]     do.call(function(...) {
[09:29:54.040]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.040]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:54.040]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.040]             on.exit(options(oopts), add = TRUE)
[09:29:54.040]         }
[09:29:54.040]         {
[09:29:54.040]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:54.040]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.040]                 ...future.FUN(...future.X_jj, ...)
[09:29:54.040]             })
[09:29:54.040]         }
[09:29:54.040]     }, args = future.call.arguments)
[09:29:54.040] }
[09:29:54.040] Tweak future expression to call with '...' arguments ... DONE
[09:29:54.041] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.041] - packages: [1] ‘future.apply’
[09:29:54.041] getGlobalsAndPackages() ... DONE
[09:29:54.041] run() for ‘Future’ ...
[09:29:54.041] - state: ‘created’
[09:29:54.041] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:54.055] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:54.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:54.055]   - Field: ‘node’
[09:29:54.055]   - Field: ‘label’
[09:29:54.055]   - Field: ‘local’
[09:29:54.055]   - Field: ‘owner’
[09:29:54.056]   - Field: ‘envir’
[09:29:54.056]   - Field: ‘workers’
[09:29:54.056]   - Field: ‘packages’
[09:29:54.056]   - Field: ‘gc’
[09:29:54.056]   - Field: ‘conditions’
[09:29:54.056]   - Field: ‘persistent’
[09:29:54.056]   - Field: ‘expr’
[09:29:54.056]   - Field: ‘uuid’
[09:29:54.056]   - Field: ‘seed’
[09:29:54.056]   - Field: ‘version’
[09:29:54.056]   - Field: ‘result’
[09:29:54.057]   - Field: ‘asynchronous’
[09:29:54.057]   - Field: ‘calls’
[09:29:54.057]   - Field: ‘globals’
[09:29:54.057]   - Field: ‘stdout’
[09:29:54.057]   - Field: ‘earlySignal’
[09:29:54.057]   - Field: ‘lazy’
[09:29:54.057]   - Field: ‘state’
[09:29:54.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:54.057] - Launch lazy future ...
[09:29:54.057] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:54.058] Packages needed by future strategies (n = 0): <none>
[09:29:54.058] {
[09:29:54.058]     {
[09:29:54.058]         {
[09:29:54.058]             ...future.startTime <- base::Sys.time()
[09:29:54.058]             {
[09:29:54.058]                 {
[09:29:54.058]                   {
[09:29:54.058]                     {
[09:29:54.058]                       {
[09:29:54.058]                         base::local({
[09:29:54.058]                           has_future <- base::requireNamespace("future", 
[09:29:54.058]                             quietly = TRUE)
[09:29:54.058]                           if (has_future) {
[09:29:54.058]                             ns <- base::getNamespace("future")
[09:29:54.058]                             version <- ns[[".package"]][["version"]]
[09:29:54.058]                             if (is.null(version)) 
[09:29:54.058]                               version <- utils::packageVersion("future")
[09:29:54.058]                           }
[09:29:54.058]                           else {
[09:29:54.058]                             version <- NULL
[09:29:54.058]                           }
[09:29:54.058]                           if (!has_future || version < "1.8.0") {
[09:29:54.058]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:54.058]                               "", base::R.version$version.string), 
[09:29:54.058]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:54.058]                                 base::R.version$platform, 8 * 
[09:29:54.058]                                   base::.Machine$sizeof.pointer), 
[09:29:54.058]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:54.058]                                 "release", "version")], collapse = " "), 
[09:29:54.058]                               hostname = base::Sys.info()[["nodename"]])
[09:29:54.058]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:54.058]                               info)
[09:29:54.058]                             info <- base::paste(info, collapse = "; ")
[09:29:54.058]                             if (!has_future) {
[09:29:54.058]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:54.058]                                 info)
[09:29:54.058]                             }
[09:29:54.058]                             else {
[09:29:54.058]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:54.058]                                 info, version)
[09:29:54.058]                             }
[09:29:54.058]                             base::stop(msg)
[09:29:54.058]                           }
[09:29:54.058]                         })
[09:29:54.058]                       }
[09:29:54.058]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:54.058]                       base::options(mc.cores = 1L)
[09:29:54.058]                     }
[09:29:54.058]                     base::local({
[09:29:54.058]                       for (pkg in "future.apply") {
[09:29:54.058]                         base::loadNamespace(pkg)
[09:29:54.058]                         base::library(pkg, character.only = TRUE)
[09:29:54.058]                       }
[09:29:54.058]                     })
[09:29:54.058]                   }
[09:29:54.058]                   ...future.strategy.old <- future::plan("list")
[09:29:54.058]                   options(future.plan = NULL)
[09:29:54.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:54.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:54.058]                 }
[09:29:54.058]                 ...future.workdir <- getwd()
[09:29:54.058]             }
[09:29:54.058]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:54.058]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:54.058]         }
[09:29:54.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:54.058]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:54.058]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:54.058]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:54.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:54.058]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:54.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:54.058]             base::names(...future.oldOptions))
[09:29:54.058]     }
[09:29:54.058]     if (FALSE) {
[09:29:54.058]     }
[09:29:54.058]     else {
[09:29:54.058]         if (TRUE) {
[09:29:54.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:54.058]                 open = "w")
[09:29:54.058]         }
[09:29:54.058]         else {
[09:29:54.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:54.058]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:54.058]         }
[09:29:54.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:54.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:54.058]             base::sink(type = "output", split = FALSE)
[09:29:54.058]             base::close(...future.stdout)
[09:29:54.058]         }, add = TRUE)
[09:29:54.058]     }
[09:29:54.058]     ...future.frame <- base::sys.nframe()
[09:29:54.058]     ...future.conditions <- base::list()
[09:29:54.058]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:54.058]     if (FALSE) {
[09:29:54.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:54.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:54.058]     }
[09:29:54.058]     ...future.result <- base::tryCatch({
[09:29:54.058]         base::withCallingHandlers({
[09:29:54.058]             ...future.value <- base::withVisible(base::local({
[09:29:54.058]                 ...future.makeSendCondition <- base::local({
[09:29:54.058]                   sendCondition <- NULL
[09:29:54.058]                   function(frame = 1L) {
[09:29:54.058]                     if (is.function(sendCondition)) 
[09:29:54.058]                       return(sendCondition)
[09:29:54.058]                     ns <- getNamespace("parallel")
[09:29:54.058]                     if (exists("sendData", mode = "function", 
[09:29:54.058]                       envir = ns)) {
[09:29:54.058]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:54.058]                         envir = ns)
[09:29:54.058]                       envir <- sys.frame(frame)
[09:29:54.058]                       master <- NULL
[09:29:54.058]                       while (!identical(envir, .GlobalEnv) && 
[09:29:54.058]                         !identical(envir, emptyenv())) {
[09:29:54.058]                         if (exists("master", mode = "list", envir = envir, 
[09:29:54.058]                           inherits = FALSE)) {
[09:29:54.058]                           master <- get("master", mode = "list", 
[09:29:54.058]                             envir = envir, inherits = FALSE)
[09:29:54.058]                           if (inherits(master, c("SOCKnode", 
[09:29:54.058]                             "SOCK0node"))) {
[09:29:54.058]                             sendCondition <<- function(cond) {
[09:29:54.058]                               data <- list(type = "VALUE", value = cond, 
[09:29:54.058]                                 success = TRUE)
[09:29:54.058]                               parallel_sendData(master, data)
[09:29:54.058]                             }
[09:29:54.058]                             return(sendCondition)
[09:29:54.058]                           }
[09:29:54.058]                         }
[09:29:54.058]                         frame <- frame + 1L
[09:29:54.058]                         envir <- sys.frame(frame)
[09:29:54.058]                       }
[09:29:54.058]                     }
[09:29:54.058]                     sendCondition <<- function(cond) NULL
[09:29:54.058]                   }
[09:29:54.058]                 })
[09:29:54.058]                 withCallingHandlers({
[09:29:54.058]                   {
[09:29:54.058]                     do.call(function(...) {
[09:29:54.058]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.058]                       if (!identical(...future.globals.maxSize.org, 
[09:29:54.058]                         ...future.globals.maxSize)) {
[09:29:54.058]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.058]                         on.exit(options(oopts), add = TRUE)
[09:29:54.058]                       }
[09:29:54.058]                       {
[09:29:54.058]                         lapply(seq_along(...future.elements_ii), 
[09:29:54.058]                           FUN = function(jj) {
[09:29:54.058]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.058]                             ...future.FUN(...future.X_jj, ...)
[09:29:54.058]                           })
[09:29:54.058]                       }
[09:29:54.058]                     }, args = future.call.arguments)
[09:29:54.058]                   }
[09:29:54.058]                 }, immediateCondition = function(cond) {
[09:29:54.058]                   sendCondition <- ...future.makeSendCondition()
[09:29:54.058]                   sendCondition(cond)
[09:29:54.058]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.058]                   {
[09:29:54.058]                     inherits <- base::inherits
[09:29:54.058]                     invokeRestart <- base::invokeRestart
[09:29:54.058]                     is.null <- base::is.null
[09:29:54.058]                     muffled <- FALSE
[09:29:54.058]                     if (inherits(cond, "message")) {
[09:29:54.058]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:54.058]                       if (muffled) 
[09:29:54.058]                         invokeRestart("muffleMessage")
[09:29:54.058]                     }
[09:29:54.058]                     else if (inherits(cond, "warning")) {
[09:29:54.058]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:54.058]                       if (muffled) 
[09:29:54.058]                         invokeRestart("muffleWarning")
[09:29:54.058]                     }
[09:29:54.058]                     else if (inherits(cond, "condition")) {
[09:29:54.058]                       if (!is.null(pattern)) {
[09:29:54.058]                         computeRestarts <- base::computeRestarts
[09:29:54.058]                         grepl <- base::grepl
[09:29:54.058]                         restarts <- computeRestarts(cond)
[09:29:54.058]                         for (restart in restarts) {
[09:29:54.058]                           name <- restart$name
[09:29:54.058]                           if (is.null(name)) 
[09:29:54.058]                             next
[09:29:54.058]                           if (!grepl(pattern, name)) 
[09:29:54.058]                             next
[09:29:54.058]                           invokeRestart(restart)
[09:29:54.058]                           muffled <- TRUE
[09:29:54.058]                           break
[09:29:54.058]                         }
[09:29:54.058]                       }
[09:29:54.058]                     }
[09:29:54.058]                     invisible(muffled)
[09:29:54.058]                   }
[09:29:54.058]                   muffleCondition(cond)
[09:29:54.058]                 })
[09:29:54.058]             }))
[09:29:54.058]             future::FutureResult(value = ...future.value$value, 
[09:29:54.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:54.058]                   ...future.rng), globalenv = if (FALSE) 
[09:29:54.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:54.058]                     ...future.globalenv.names))
[09:29:54.058]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:54.058]         }, condition = base::local({
[09:29:54.058]             c <- base::c
[09:29:54.058]             inherits <- base::inherits
[09:29:54.058]             invokeRestart <- base::invokeRestart
[09:29:54.058]             length <- base::length
[09:29:54.058]             list <- base::list
[09:29:54.058]             seq.int <- base::seq.int
[09:29:54.058]             signalCondition <- base::signalCondition
[09:29:54.058]             sys.calls <- base::sys.calls
[09:29:54.058]             `[[` <- base::`[[`
[09:29:54.058]             `+` <- base::`+`
[09:29:54.058]             `<<-` <- base::`<<-`
[09:29:54.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:54.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:54.058]                   3L)]
[09:29:54.058]             }
[09:29:54.058]             function(cond) {
[09:29:54.058]                 is_error <- inherits(cond, "error")
[09:29:54.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:54.058]                   NULL)
[09:29:54.058]                 if (is_error) {
[09:29:54.058]                   sessionInformation <- function() {
[09:29:54.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:54.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:54.058]                       search = base::search(), system = base::Sys.info())
[09:29:54.058]                   }
[09:29:54.058]                   ...future.conditions[[length(...future.conditions) + 
[09:29:54.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:54.058]                     cond$call), session = sessionInformation(), 
[09:29:54.058]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:54.058]                   signalCondition(cond)
[09:29:54.058]                 }
[09:29:54.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:54.058]                 "immediateCondition"))) {
[09:29:54.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:54.058]                   ...future.conditions[[length(...future.conditions) + 
[09:29:54.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:54.058]                   if (TRUE && !signal) {
[09:29:54.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.058]                     {
[09:29:54.058]                       inherits <- base::inherits
[09:29:54.058]                       invokeRestart <- base::invokeRestart
[09:29:54.058]                       is.null <- base::is.null
[09:29:54.058]                       muffled <- FALSE
[09:29:54.058]                       if (inherits(cond, "message")) {
[09:29:54.058]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:54.058]                         if (muffled) 
[09:29:54.058]                           invokeRestart("muffleMessage")
[09:29:54.058]                       }
[09:29:54.058]                       else if (inherits(cond, "warning")) {
[09:29:54.058]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:54.058]                         if (muffled) 
[09:29:54.058]                           invokeRestart("muffleWarning")
[09:29:54.058]                       }
[09:29:54.058]                       else if (inherits(cond, "condition")) {
[09:29:54.058]                         if (!is.null(pattern)) {
[09:29:54.058]                           computeRestarts <- base::computeRestarts
[09:29:54.058]                           grepl <- base::grepl
[09:29:54.058]                           restarts <- computeRestarts(cond)
[09:29:54.058]                           for (restart in restarts) {
[09:29:54.058]                             name <- restart$name
[09:29:54.058]                             if (is.null(name)) 
[09:29:54.058]                               next
[09:29:54.058]                             if (!grepl(pattern, name)) 
[09:29:54.058]                               next
[09:29:54.058]                             invokeRestart(restart)
[09:29:54.058]                             muffled <- TRUE
[09:29:54.058]                             break
[09:29:54.058]                           }
[09:29:54.058]                         }
[09:29:54.058]                       }
[09:29:54.058]                       invisible(muffled)
[09:29:54.058]                     }
[09:29:54.058]                     muffleCondition(cond, pattern = "^muffle")
[09:29:54.058]                   }
[09:29:54.058]                 }
[09:29:54.058]                 else {
[09:29:54.058]                   if (TRUE) {
[09:29:54.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.058]                     {
[09:29:54.058]                       inherits <- base::inherits
[09:29:54.058]                       invokeRestart <- base::invokeRestart
[09:29:54.058]                       is.null <- base::is.null
[09:29:54.058]                       muffled <- FALSE
[09:29:54.058]                       if (inherits(cond, "message")) {
[09:29:54.058]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:54.058]                         if (muffled) 
[09:29:54.058]                           invokeRestart("muffleMessage")
[09:29:54.058]                       }
[09:29:54.058]                       else if (inherits(cond, "warning")) {
[09:29:54.058]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:54.058]                         if (muffled) 
[09:29:54.058]                           invokeRestart("muffleWarning")
[09:29:54.058]                       }
[09:29:54.058]                       else if (inherits(cond, "condition")) {
[09:29:54.058]                         if (!is.null(pattern)) {
[09:29:54.058]                           computeRestarts <- base::computeRestarts
[09:29:54.058]                           grepl <- base::grepl
[09:29:54.058]                           restarts <- computeRestarts(cond)
[09:29:54.058]                           for (restart in restarts) {
[09:29:54.058]                             name <- restart$name
[09:29:54.058]                             if (is.null(name)) 
[09:29:54.058]                               next
[09:29:54.058]                             if (!grepl(pattern, name)) 
[09:29:54.058]                               next
[09:29:54.058]                             invokeRestart(restart)
[09:29:54.058]                             muffled <- TRUE
[09:29:54.058]                             break
[09:29:54.058]                           }
[09:29:54.058]                         }
[09:29:54.058]                       }
[09:29:54.058]                       invisible(muffled)
[09:29:54.058]                     }
[09:29:54.058]                     muffleCondition(cond, pattern = "^muffle")
[09:29:54.058]                   }
[09:29:54.058]                 }
[09:29:54.058]             }
[09:29:54.058]         }))
[09:29:54.058]     }, error = function(ex) {
[09:29:54.058]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:54.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:54.058]                 ...future.rng), started = ...future.startTime, 
[09:29:54.058]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:54.058]             version = "1.8"), class = "FutureResult")
[09:29:54.058]     }, finally = {
[09:29:54.058]         if (!identical(...future.workdir, getwd())) 
[09:29:54.058]             setwd(...future.workdir)
[09:29:54.058]         {
[09:29:54.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:54.058]                 ...future.oldOptions$nwarnings <- NULL
[09:29:54.058]             }
[09:29:54.058]             base::options(...future.oldOptions)
[09:29:54.058]             if (.Platform$OS.type == "windows") {
[09:29:54.058]                 old_names <- names(...future.oldEnvVars)
[09:29:54.058]                 envs <- base::Sys.getenv()
[09:29:54.058]                 names <- names(envs)
[09:29:54.058]                 common <- intersect(names, old_names)
[09:29:54.058]                 added <- setdiff(names, old_names)
[09:29:54.058]                 removed <- setdiff(old_names, names)
[09:29:54.058]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:54.058]                   envs[common]]
[09:29:54.058]                 NAMES <- toupper(changed)
[09:29:54.058]                 args <- list()
[09:29:54.058]                 for (kk in seq_along(NAMES)) {
[09:29:54.058]                   name <- changed[[kk]]
[09:29:54.058]                   NAME <- NAMES[[kk]]
[09:29:54.058]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.058]                     next
[09:29:54.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:54.058]                 }
[09:29:54.058]                 NAMES <- toupper(added)
[09:29:54.058]                 for (kk in seq_along(NAMES)) {
[09:29:54.058]                   name <- added[[kk]]
[09:29:54.058]                   NAME <- NAMES[[kk]]
[09:29:54.058]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.058]                     next
[09:29:54.058]                   args[[name]] <- ""
[09:29:54.058]                 }
[09:29:54.058]                 NAMES <- toupper(removed)
[09:29:54.058]                 for (kk in seq_along(NAMES)) {
[09:29:54.058]                   name <- removed[[kk]]
[09:29:54.058]                   NAME <- NAMES[[kk]]
[09:29:54.058]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.058]                     next
[09:29:54.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:54.058]                 }
[09:29:54.058]                 if (length(args) > 0) 
[09:29:54.058]                   base::do.call(base::Sys.setenv, args = args)
[09:29:54.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:54.058]             }
[09:29:54.058]             else {
[09:29:54.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:54.058]             }
[09:29:54.058]             {
[09:29:54.058]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:54.058]                   0L) {
[09:29:54.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:54.058]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:54.058]                   base::options(opts)
[09:29:54.058]                 }
[09:29:54.058]                 {
[09:29:54.058]                   {
[09:29:54.058]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:54.058]                     NULL
[09:29:54.058]                   }
[09:29:54.058]                   options(future.plan = NULL)
[09:29:54.058]                   if (is.na(NA_character_)) 
[09:29:54.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:54.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:54.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:54.058]                     .init = FALSE)
[09:29:54.058]                 }
[09:29:54.058]             }
[09:29:54.058]         }
[09:29:54.058]     })
[09:29:54.058]     if (TRUE) {
[09:29:54.058]         base::sink(type = "output", split = FALSE)
[09:29:54.058]         if (TRUE) {
[09:29:54.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:54.058]         }
[09:29:54.058]         else {
[09:29:54.058]             ...future.result["stdout"] <- base::list(NULL)
[09:29:54.058]         }
[09:29:54.058]         base::close(...future.stdout)
[09:29:54.058]         ...future.stdout <- NULL
[09:29:54.058]     }
[09:29:54.058]     ...future.result$conditions <- ...future.conditions
[09:29:54.058]     ...future.result$finished <- base::Sys.time()
[09:29:54.058]     ...future.result
[09:29:54.058] }
[09:29:54.061] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[09:29:54.061] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:54.104] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:54.104] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[09:29:54.105] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[09:29:54.105] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:54.105] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:54.105] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:54.148] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:54.148] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:54.192] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:54.192] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:54.193] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.193] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[09:29:54.193] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[09:29:54.193] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:54.194] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.194] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:29:54.194] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:29:54.194] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:54.195] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.195] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:54.195] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.195] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[09:29:54.196] MultisessionFuture started
[09:29:54.196] - Launch lazy future ... done
[09:29:54.196] run() for ‘MultisessionFuture’ ... done
[09:29:54.196] Created future:
[09:29:54.196] MultisessionFuture:
[09:29:54.196] Label: ‘future_vapply-1’
[09:29:54.196] Expression:
[09:29:54.196] {
[09:29:54.196]     do.call(function(...) {
[09:29:54.196]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.196]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:54.196]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.196]             on.exit(options(oopts), add = TRUE)
[09:29:54.196]         }
[09:29:54.196]         {
[09:29:54.196]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:54.196]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.196]                 ...future.FUN(...future.X_jj, ...)
[09:29:54.196]             })
[09:29:54.196]         }
[09:29:54.196]     }, args = future.call.arguments)
[09:29:54.196] }
[09:29:54.196] Lazy evaluation: FALSE
[09:29:54.196] Asynchronous evaluation: TRUE
[09:29:54.196] Local evaluation: TRUE
[09:29:54.196] Environment: R_GlobalEnv
[09:29:54.196] Capture standard output: TRUE
[09:29:54.196] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:54.196] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:54.196] Packages: 1 packages (‘future.apply’)
[09:29:54.196] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:54.196] Resolved: FALSE
[09:29:54.196] Value: <not collected>
[09:29:54.196] Conditions captured: <none>
[09:29:54.196] Early signaling: FALSE
[09:29:54.196] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:54.196] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:54.208] Chunk #1 of 2 ... DONE
[09:29:54.208] Chunk #2 of 2 ...
[09:29:54.208]  - Finding globals in 'X' for chunk #2 ...
[09:29:54.208] getGlobalsAndPackages() ...
[09:29:54.208] Searching for globals...
[09:29:54.208] 
[09:29:54.209] Searching for globals ... DONE
[09:29:54.209] - globals: [0] <none>
[09:29:54.209] getGlobalsAndPackages() ... DONE
[09:29:54.209]    + additional globals found: [n=0] 
[09:29:54.209]    + additional namespaces needed: [n=0] 
[09:29:54.209]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:54.209]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:54.209]  - seeds: <none>
[09:29:54.209]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.209] getGlobalsAndPackages() ...
[09:29:54.209] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.210] Resolving globals: FALSE
[09:29:54.210] Tweak future expression to call with '...' arguments ...
[09:29:54.210] {
[09:29:54.210]     do.call(function(...) {
[09:29:54.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:54.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.210]             on.exit(options(oopts), add = TRUE)
[09:29:54.210]         }
[09:29:54.210]         {
[09:29:54.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:54.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.210]                 ...future.FUN(...future.X_jj, ...)
[09:29:54.210]             })
[09:29:54.210]         }
[09:29:54.210]     }, args = future.call.arguments)
[09:29:54.210] }
[09:29:54.210] Tweak future expression to call with '...' arguments ... DONE
[09:29:54.211] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.211] - packages: [1] ‘future.apply’
[09:29:54.211] getGlobalsAndPackages() ... DONE
[09:29:54.211] run() for ‘Future’ ...
[09:29:54.211] - state: ‘created’
[09:29:54.211] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:54.225] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:54.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:54.225]   - Field: ‘node’
[09:29:54.225]   - Field: ‘label’
[09:29:54.225]   - Field: ‘local’
[09:29:54.225]   - Field: ‘owner’
[09:29:54.226]   - Field: ‘envir’
[09:29:54.226]   - Field: ‘workers’
[09:29:54.226]   - Field: ‘packages’
[09:29:54.226]   - Field: ‘gc’
[09:29:54.226]   - Field: ‘conditions’
[09:29:54.226]   - Field: ‘persistent’
[09:29:54.226]   - Field: ‘expr’
[09:29:54.226]   - Field: ‘uuid’
[09:29:54.226]   - Field: ‘seed’
[09:29:54.226]   - Field: ‘version’
[09:29:54.226]   - Field: ‘result’
[09:29:54.227]   - Field: ‘asynchronous’
[09:29:54.227]   - Field: ‘calls’
[09:29:54.227]   - Field: ‘globals’
[09:29:54.227]   - Field: ‘stdout’
[09:29:54.227]   - Field: ‘earlySignal’
[09:29:54.227]   - Field: ‘lazy’
[09:29:54.227]   - Field: ‘state’
[09:29:54.227] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:54.227] - Launch lazy future ...
[09:29:54.227] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:54.228] Packages needed by future strategies (n = 0): <none>
[09:29:54.228] {
[09:29:54.228]     {
[09:29:54.228]         {
[09:29:54.228]             ...future.startTime <- base::Sys.time()
[09:29:54.228]             {
[09:29:54.228]                 {
[09:29:54.228]                   {
[09:29:54.228]                     {
[09:29:54.228]                       {
[09:29:54.228]                         base::local({
[09:29:54.228]                           has_future <- base::requireNamespace("future", 
[09:29:54.228]                             quietly = TRUE)
[09:29:54.228]                           if (has_future) {
[09:29:54.228]                             ns <- base::getNamespace("future")
[09:29:54.228]                             version <- ns[[".package"]][["version"]]
[09:29:54.228]                             if (is.null(version)) 
[09:29:54.228]                               version <- utils::packageVersion("future")
[09:29:54.228]                           }
[09:29:54.228]                           else {
[09:29:54.228]                             version <- NULL
[09:29:54.228]                           }
[09:29:54.228]                           if (!has_future || version < "1.8.0") {
[09:29:54.228]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:54.228]                               "", base::R.version$version.string), 
[09:29:54.228]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:54.228]                                 base::R.version$platform, 8 * 
[09:29:54.228]                                   base::.Machine$sizeof.pointer), 
[09:29:54.228]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:54.228]                                 "release", "version")], collapse = " "), 
[09:29:54.228]                               hostname = base::Sys.info()[["nodename"]])
[09:29:54.228]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:54.228]                               info)
[09:29:54.228]                             info <- base::paste(info, collapse = "; ")
[09:29:54.228]                             if (!has_future) {
[09:29:54.228]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:54.228]                                 info)
[09:29:54.228]                             }
[09:29:54.228]                             else {
[09:29:54.228]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:54.228]                                 info, version)
[09:29:54.228]                             }
[09:29:54.228]                             base::stop(msg)
[09:29:54.228]                           }
[09:29:54.228]                         })
[09:29:54.228]                       }
[09:29:54.228]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:54.228]                       base::options(mc.cores = 1L)
[09:29:54.228]                     }
[09:29:54.228]                     base::local({
[09:29:54.228]                       for (pkg in "future.apply") {
[09:29:54.228]                         base::loadNamespace(pkg)
[09:29:54.228]                         base::library(pkg, character.only = TRUE)
[09:29:54.228]                       }
[09:29:54.228]                     })
[09:29:54.228]                   }
[09:29:54.228]                   ...future.strategy.old <- future::plan("list")
[09:29:54.228]                   options(future.plan = NULL)
[09:29:54.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:54.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:54.228]                 }
[09:29:54.228]                 ...future.workdir <- getwd()
[09:29:54.228]             }
[09:29:54.228]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:54.228]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:54.228]         }
[09:29:54.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:54.228]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:54.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:54.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:54.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:54.228]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:54.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:54.228]             base::names(...future.oldOptions))
[09:29:54.228]     }
[09:29:54.228]     if (FALSE) {
[09:29:54.228]     }
[09:29:54.228]     else {
[09:29:54.228]         if (TRUE) {
[09:29:54.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:54.228]                 open = "w")
[09:29:54.228]         }
[09:29:54.228]         else {
[09:29:54.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:54.228]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:54.228]         }
[09:29:54.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:54.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:54.228]             base::sink(type = "output", split = FALSE)
[09:29:54.228]             base::close(...future.stdout)
[09:29:54.228]         }, add = TRUE)
[09:29:54.228]     }
[09:29:54.228]     ...future.frame <- base::sys.nframe()
[09:29:54.228]     ...future.conditions <- base::list()
[09:29:54.228]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:54.228]     if (FALSE) {
[09:29:54.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:54.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:54.228]     }
[09:29:54.228]     ...future.result <- base::tryCatch({
[09:29:54.228]         base::withCallingHandlers({
[09:29:54.228]             ...future.value <- base::withVisible(base::local({
[09:29:54.228]                 ...future.makeSendCondition <- base::local({
[09:29:54.228]                   sendCondition <- NULL
[09:29:54.228]                   function(frame = 1L) {
[09:29:54.228]                     if (is.function(sendCondition)) 
[09:29:54.228]                       return(sendCondition)
[09:29:54.228]                     ns <- getNamespace("parallel")
[09:29:54.228]                     if (exists("sendData", mode = "function", 
[09:29:54.228]                       envir = ns)) {
[09:29:54.228]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:54.228]                         envir = ns)
[09:29:54.228]                       envir <- sys.frame(frame)
[09:29:54.228]                       master <- NULL
[09:29:54.228]                       while (!identical(envir, .GlobalEnv) && 
[09:29:54.228]                         !identical(envir, emptyenv())) {
[09:29:54.228]                         if (exists("master", mode = "list", envir = envir, 
[09:29:54.228]                           inherits = FALSE)) {
[09:29:54.228]                           master <- get("master", mode = "list", 
[09:29:54.228]                             envir = envir, inherits = FALSE)
[09:29:54.228]                           if (inherits(master, c("SOCKnode", 
[09:29:54.228]                             "SOCK0node"))) {
[09:29:54.228]                             sendCondition <<- function(cond) {
[09:29:54.228]                               data <- list(type = "VALUE", value = cond, 
[09:29:54.228]                                 success = TRUE)
[09:29:54.228]                               parallel_sendData(master, data)
[09:29:54.228]                             }
[09:29:54.228]                             return(sendCondition)
[09:29:54.228]                           }
[09:29:54.228]                         }
[09:29:54.228]                         frame <- frame + 1L
[09:29:54.228]                         envir <- sys.frame(frame)
[09:29:54.228]                       }
[09:29:54.228]                     }
[09:29:54.228]                     sendCondition <<- function(cond) NULL
[09:29:54.228]                   }
[09:29:54.228]                 })
[09:29:54.228]                 withCallingHandlers({
[09:29:54.228]                   {
[09:29:54.228]                     do.call(function(...) {
[09:29:54.228]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.228]                       if (!identical(...future.globals.maxSize.org, 
[09:29:54.228]                         ...future.globals.maxSize)) {
[09:29:54.228]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.228]                         on.exit(options(oopts), add = TRUE)
[09:29:54.228]                       }
[09:29:54.228]                       {
[09:29:54.228]                         lapply(seq_along(...future.elements_ii), 
[09:29:54.228]                           FUN = function(jj) {
[09:29:54.228]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.228]                             ...future.FUN(...future.X_jj, ...)
[09:29:54.228]                           })
[09:29:54.228]                       }
[09:29:54.228]                     }, args = future.call.arguments)
[09:29:54.228]                   }
[09:29:54.228]                 }, immediateCondition = function(cond) {
[09:29:54.228]                   sendCondition <- ...future.makeSendCondition()
[09:29:54.228]                   sendCondition(cond)
[09:29:54.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.228]                   {
[09:29:54.228]                     inherits <- base::inherits
[09:29:54.228]                     invokeRestart <- base::invokeRestart
[09:29:54.228]                     is.null <- base::is.null
[09:29:54.228]                     muffled <- FALSE
[09:29:54.228]                     if (inherits(cond, "message")) {
[09:29:54.228]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:54.228]                       if (muffled) 
[09:29:54.228]                         invokeRestart("muffleMessage")
[09:29:54.228]                     }
[09:29:54.228]                     else if (inherits(cond, "warning")) {
[09:29:54.228]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:54.228]                       if (muffled) 
[09:29:54.228]                         invokeRestart("muffleWarning")
[09:29:54.228]                     }
[09:29:54.228]                     else if (inherits(cond, "condition")) {
[09:29:54.228]                       if (!is.null(pattern)) {
[09:29:54.228]                         computeRestarts <- base::computeRestarts
[09:29:54.228]                         grepl <- base::grepl
[09:29:54.228]                         restarts <- computeRestarts(cond)
[09:29:54.228]                         for (restart in restarts) {
[09:29:54.228]                           name <- restart$name
[09:29:54.228]                           if (is.null(name)) 
[09:29:54.228]                             next
[09:29:54.228]                           if (!grepl(pattern, name)) 
[09:29:54.228]                             next
[09:29:54.228]                           invokeRestart(restart)
[09:29:54.228]                           muffled <- TRUE
[09:29:54.228]                           break
[09:29:54.228]                         }
[09:29:54.228]                       }
[09:29:54.228]                     }
[09:29:54.228]                     invisible(muffled)
[09:29:54.228]                   }
[09:29:54.228]                   muffleCondition(cond)
[09:29:54.228]                 })
[09:29:54.228]             }))
[09:29:54.228]             future::FutureResult(value = ...future.value$value, 
[09:29:54.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:54.228]                   ...future.rng), globalenv = if (FALSE) 
[09:29:54.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:54.228]                     ...future.globalenv.names))
[09:29:54.228]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:54.228]         }, condition = base::local({
[09:29:54.228]             c <- base::c
[09:29:54.228]             inherits <- base::inherits
[09:29:54.228]             invokeRestart <- base::invokeRestart
[09:29:54.228]             length <- base::length
[09:29:54.228]             list <- base::list
[09:29:54.228]             seq.int <- base::seq.int
[09:29:54.228]             signalCondition <- base::signalCondition
[09:29:54.228]             sys.calls <- base::sys.calls
[09:29:54.228]             `[[` <- base::`[[`
[09:29:54.228]             `+` <- base::`+`
[09:29:54.228]             `<<-` <- base::`<<-`
[09:29:54.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:54.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:54.228]                   3L)]
[09:29:54.228]             }
[09:29:54.228]             function(cond) {
[09:29:54.228]                 is_error <- inherits(cond, "error")
[09:29:54.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:54.228]                   NULL)
[09:29:54.228]                 if (is_error) {
[09:29:54.228]                   sessionInformation <- function() {
[09:29:54.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:54.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:54.228]                       search = base::search(), system = base::Sys.info())
[09:29:54.228]                   }
[09:29:54.228]                   ...future.conditions[[length(...future.conditions) + 
[09:29:54.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:54.228]                     cond$call), session = sessionInformation(), 
[09:29:54.228]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:54.228]                   signalCondition(cond)
[09:29:54.228]                 }
[09:29:54.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:54.228]                 "immediateCondition"))) {
[09:29:54.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:54.228]                   ...future.conditions[[length(...future.conditions) + 
[09:29:54.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:54.228]                   if (TRUE && !signal) {
[09:29:54.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.228]                     {
[09:29:54.228]                       inherits <- base::inherits
[09:29:54.228]                       invokeRestart <- base::invokeRestart
[09:29:54.228]                       is.null <- base::is.null
[09:29:54.228]                       muffled <- FALSE
[09:29:54.228]                       if (inherits(cond, "message")) {
[09:29:54.228]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:54.228]                         if (muffled) 
[09:29:54.228]                           invokeRestart("muffleMessage")
[09:29:54.228]                       }
[09:29:54.228]                       else if (inherits(cond, "warning")) {
[09:29:54.228]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:54.228]                         if (muffled) 
[09:29:54.228]                           invokeRestart("muffleWarning")
[09:29:54.228]                       }
[09:29:54.228]                       else if (inherits(cond, "condition")) {
[09:29:54.228]                         if (!is.null(pattern)) {
[09:29:54.228]                           computeRestarts <- base::computeRestarts
[09:29:54.228]                           grepl <- base::grepl
[09:29:54.228]                           restarts <- computeRestarts(cond)
[09:29:54.228]                           for (restart in restarts) {
[09:29:54.228]                             name <- restart$name
[09:29:54.228]                             if (is.null(name)) 
[09:29:54.228]                               next
[09:29:54.228]                             if (!grepl(pattern, name)) 
[09:29:54.228]                               next
[09:29:54.228]                             invokeRestart(restart)
[09:29:54.228]                             muffled <- TRUE
[09:29:54.228]                             break
[09:29:54.228]                           }
[09:29:54.228]                         }
[09:29:54.228]                       }
[09:29:54.228]                       invisible(muffled)
[09:29:54.228]                     }
[09:29:54.228]                     muffleCondition(cond, pattern = "^muffle")
[09:29:54.228]                   }
[09:29:54.228]                 }
[09:29:54.228]                 else {
[09:29:54.228]                   if (TRUE) {
[09:29:54.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.228]                     {
[09:29:54.228]                       inherits <- base::inherits
[09:29:54.228]                       invokeRestart <- base::invokeRestart
[09:29:54.228]                       is.null <- base::is.null
[09:29:54.228]                       muffled <- FALSE
[09:29:54.228]                       if (inherits(cond, "message")) {
[09:29:54.228]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:54.228]                         if (muffled) 
[09:29:54.228]                           invokeRestart("muffleMessage")
[09:29:54.228]                       }
[09:29:54.228]                       else if (inherits(cond, "warning")) {
[09:29:54.228]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:54.228]                         if (muffled) 
[09:29:54.228]                           invokeRestart("muffleWarning")
[09:29:54.228]                       }
[09:29:54.228]                       else if (inherits(cond, "condition")) {
[09:29:54.228]                         if (!is.null(pattern)) {
[09:29:54.228]                           computeRestarts <- base::computeRestarts
[09:29:54.228]                           grepl <- base::grepl
[09:29:54.228]                           restarts <- computeRestarts(cond)
[09:29:54.228]                           for (restart in restarts) {
[09:29:54.228]                             name <- restart$name
[09:29:54.228]                             if (is.null(name)) 
[09:29:54.228]                               next
[09:29:54.228]                             if (!grepl(pattern, name)) 
[09:29:54.228]                               next
[09:29:54.228]                             invokeRestart(restart)
[09:29:54.228]                             muffled <- TRUE
[09:29:54.228]                             break
[09:29:54.228]                           }
[09:29:54.228]                         }
[09:29:54.228]                       }
[09:29:54.228]                       invisible(muffled)
[09:29:54.228]                     }
[09:29:54.228]                     muffleCondition(cond, pattern = "^muffle")
[09:29:54.228]                   }
[09:29:54.228]                 }
[09:29:54.228]             }
[09:29:54.228]         }))
[09:29:54.228]     }, error = function(ex) {
[09:29:54.228]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:54.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:54.228]                 ...future.rng), started = ...future.startTime, 
[09:29:54.228]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:54.228]             version = "1.8"), class = "FutureResult")
[09:29:54.228]     }, finally = {
[09:29:54.228]         if (!identical(...future.workdir, getwd())) 
[09:29:54.228]             setwd(...future.workdir)
[09:29:54.228]         {
[09:29:54.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:54.228]                 ...future.oldOptions$nwarnings <- NULL
[09:29:54.228]             }
[09:29:54.228]             base::options(...future.oldOptions)
[09:29:54.228]             if (.Platform$OS.type == "windows") {
[09:29:54.228]                 old_names <- names(...future.oldEnvVars)
[09:29:54.228]                 envs <- base::Sys.getenv()
[09:29:54.228]                 names <- names(envs)
[09:29:54.228]                 common <- intersect(names, old_names)
[09:29:54.228]                 added <- setdiff(names, old_names)
[09:29:54.228]                 removed <- setdiff(old_names, names)
[09:29:54.228]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:54.228]                   envs[common]]
[09:29:54.228]                 NAMES <- toupper(changed)
[09:29:54.228]                 args <- list()
[09:29:54.228]                 for (kk in seq_along(NAMES)) {
[09:29:54.228]                   name <- changed[[kk]]
[09:29:54.228]                   NAME <- NAMES[[kk]]
[09:29:54.228]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.228]                     next
[09:29:54.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:54.228]                 }
[09:29:54.228]                 NAMES <- toupper(added)
[09:29:54.228]                 for (kk in seq_along(NAMES)) {
[09:29:54.228]                   name <- added[[kk]]
[09:29:54.228]                   NAME <- NAMES[[kk]]
[09:29:54.228]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.228]                     next
[09:29:54.228]                   args[[name]] <- ""
[09:29:54.228]                 }
[09:29:54.228]                 NAMES <- toupper(removed)
[09:29:54.228]                 for (kk in seq_along(NAMES)) {
[09:29:54.228]                   name <- removed[[kk]]
[09:29:54.228]                   NAME <- NAMES[[kk]]
[09:29:54.228]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.228]                     next
[09:29:54.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:54.228]                 }
[09:29:54.228]                 if (length(args) > 0) 
[09:29:54.228]                   base::do.call(base::Sys.setenv, args = args)
[09:29:54.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:54.228]             }
[09:29:54.228]             else {
[09:29:54.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:54.228]             }
[09:29:54.228]             {
[09:29:54.228]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:54.228]                   0L) {
[09:29:54.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:54.228]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:54.228]                   base::options(opts)
[09:29:54.228]                 }
[09:29:54.228]                 {
[09:29:54.228]                   {
[09:29:54.228]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:54.228]                     NULL
[09:29:54.228]                   }
[09:29:54.228]                   options(future.plan = NULL)
[09:29:54.228]                   if (is.na(NA_character_)) 
[09:29:54.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:54.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:54.228]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:54.228]                     .init = FALSE)
[09:29:54.228]                 }
[09:29:54.228]             }
[09:29:54.228]         }
[09:29:54.228]     })
[09:29:54.228]     if (TRUE) {
[09:29:54.228]         base::sink(type = "output", split = FALSE)
[09:29:54.228]         if (TRUE) {
[09:29:54.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:54.228]         }
[09:29:54.228]         else {
[09:29:54.228]             ...future.result["stdout"] <- base::list(NULL)
[09:29:54.228]         }
[09:29:54.228]         base::close(...future.stdout)
[09:29:54.228]         ...future.stdout <- NULL
[09:29:54.228]     }
[09:29:54.228]     ...future.result$conditions <- ...future.conditions
[09:29:54.228]     ...future.result$finished <- base::Sys.time()
[09:29:54.228]     ...future.result
[09:29:54.228] }
[09:29:54.231] Exporting 11 global objects (92.05 KiB) to cluster node #2 ...
[09:29:54.231] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[09:29:54.272] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[09:29:54.272] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[09:29:54.273] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[09:29:54.273] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[09:29:54.273] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[09:29:54.273] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[09:29:54.316] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[09:29:54.316] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[09:29:54.360] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[09:29:54.360] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[09:29:54.361] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[09:29:54.361] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[09:29:54.361] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[09:29:54.361] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[09:29:54.362] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[09:29:54.362] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[09:29:54.362] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[09:29:54.362] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[09:29:54.363] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[09:29:54.363] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[09:29:54.363] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[09:29:54.363] Exporting 11 global objects (92.05 KiB) to cluster node #2 ... DONE
[09:29:54.364] MultisessionFuture started
[09:29:54.364] - Launch lazy future ... done
[09:29:54.364] run() for ‘MultisessionFuture’ ... done
[09:29:54.364] Created future:
[09:29:54.364] MultisessionFuture:
[09:29:54.364] Label: ‘future_vapply-2’
[09:29:54.364] Expression:
[09:29:54.364] {
[09:29:54.364]     do.call(function(...) {
[09:29:54.364]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.364]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:54.364]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.364]             on.exit(options(oopts), add = TRUE)
[09:29:54.364]         }
[09:29:54.364]         {
[09:29:54.364]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:54.364]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.364]                 ...future.FUN(...future.X_jj, ...)
[09:29:54.364]             })
[09:29:54.364]         }
[09:29:54.364]     }, args = future.call.arguments)
[09:29:54.364] }
[09:29:54.364] Lazy evaluation: FALSE
[09:29:54.364] Asynchronous evaluation: TRUE
[09:29:54.364] Local evaluation: TRUE
[09:29:54.364] Environment: R_GlobalEnv
[09:29:54.364] Capture standard output: TRUE
[09:29:54.364] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:54.364] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:54.364] Packages: 1 packages (‘future.apply’)
[09:29:54.364] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:54.364] Resolved: FALSE
[09:29:54.364] Value: <not collected>
[09:29:54.364] Conditions captured: <none>
[09:29:54.364] Early signaling: FALSE
[09:29:54.364] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:54.364] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:54.376] Chunk #2 of 2 ... DONE
[09:29:54.376] Launching 2 futures (chunks) ... DONE
[09:29:54.376] Resolving 2 futures (chunks) ...
[09:29:54.376] resolve() on list ...
[09:29:54.377]  recursive: 0
[09:29:54.377]  length: 2
[09:29:54.377] 
[09:29:54.377] receiveMessageFromWorker() for ClusterFuture ...
[09:29:54.377] - Validating connection of MultisessionFuture
[09:29:54.377] - received message: FutureResult
[09:29:54.378] - Received FutureResult
[09:29:54.378] - Erased future from FutureRegistry
[09:29:54.378] result() for ClusterFuture ...
[09:29:54.378] - result already collected: FutureResult
[09:29:54.378] result() for ClusterFuture ... done
[09:29:54.378] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:54.378] Future #1
[09:29:54.378] result() for ClusterFuture ...
[09:29:54.378] - result already collected: FutureResult
[09:29:54.378] result() for ClusterFuture ... done
[09:29:54.378] result() for ClusterFuture ...
[09:29:54.378] - result already collected: FutureResult
[09:29:54.379] result() for ClusterFuture ... done
[09:29:54.379] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:54.379] - nx: 2
[09:29:54.379] - relay: TRUE
[09:29:54.379] - stdout: TRUE
[09:29:54.379] - signal: TRUE
[09:29:54.379] - resignal: FALSE
[09:29:54.379] - force: TRUE
[09:29:54.379] - relayed: [n=2] FALSE, FALSE
[09:29:54.379] - queued futures: [n=2] FALSE, FALSE
[09:29:54.379]  - until=1
[09:29:54.379]  - relaying element #1
[09:29:54.380] result() for ClusterFuture ...
[09:29:54.380] - result already collected: FutureResult
[09:29:54.380] result() for ClusterFuture ... done
[09:29:54.380] result() for ClusterFuture ...
[09:29:54.380] - result already collected: FutureResult
[09:29:54.380] result() for ClusterFuture ... done
[09:29:54.380] result() for ClusterFuture ...
[09:29:54.380] - result already collected: FutureResult
[09:29:54.380] result() for ClusterFuture ... done
[09:29:54.380] result() for ClusterFuture ...
[09:29:54.380] - result already collected: FutureResult
[09:29:54.381] result() for ClusterFuture ... done
[09:29:54.381] - relayed: [n=2] TRUE, FALSE
[09:29:54.381] - queued futures: [n=2] TRUE, FALSE
[09:29:54.381] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:54.381]  length: 1 (resolved future 1)
[09:29:54.409] receiveMessageFromWorker() for ClusterFuture ...
[09:29:54.410] - Validating connection of MultisessionFuture
[09:29:54.410] - received message: FutureResult
[09:29:54.410] - Received FutureResult
[09:29:54.410] - Erased future from FutureRegistry
[09:29:54.410] result() for ClusterFuture ...
[09:29:54.410] - result already collected: FutureResult
[09:29:54.410] result() for ClusterFuture ... done
[09:29:54.410] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:54.411] Future #2
[09:29:54.411] result() for ClusterFuture ...
[09:29:54.411] - result already collected: FutureResult
[09:29:54.411] result() for ClusterFuture ... done
[09:29:54.411] result() for ClusterFuture ...
[09:29:54.411] - result already collected: FutureResult
[09:29:54.411] result() for ClusterFuture ... done
[09:29:54.411] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:29:54.411] - nx: 2
[09:29:54.411] - relay: TRUE
[09:29:54.411] - stdout: TRUE
[09:29:54.411] - signal: TRUE
[09:29:54.412] - resignal: FALSE
[09:29:54.412] - force: TRUE
[09:29:54.412] - relayed: [n=2] TRUE, FALSE
[09:29:54.412] - queued futures: [n=2] TRUE, FALSE
[09:29:54.412]  - until=2
[09:29:54.412]  - relaying element #2
[09:29:54.412] result() for ClusterFuture ...
[09:29:54.412] - result already collected: FutureResult
[09:29:54.412] result() for ClusterFuture ... done
[09:29:54.412] result() for ClusterFuture ...
[09:29:54.412] - result already collected: FutureResult
[09:29:54.412] result() for ClusterFuture ... done
[09:29:54.413] result() for ClusterFuture ...
[09:29:54.413] - result already collected: FutureResult
[09:29:54.413] result() for ClusterFuture ... done
[09:29:54.413] result() for ClusterFuture ...
[09:29:54.413] - result already collected: FutureResult
[09:29:54.413] result() for ClusterFuture ... done
[09:29:54.413] - relayed: [n=2] TRUE, TRUE
[09:29:54.413] - queued futures: [n=2] TRUE, TRUE
[09:29:54.413] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:29:54.413]  length: 0 (resolved future 2)
[09:29:54.413] Relaying remaining futures
[09:29:54.414] signalConditionsASAP(NULL, pos=0) ...
[09:29:54.414] - nx: 2
[09:29:54.414] - relay: TRUE
[09:29:54.414] - stdout: TRUE
[09:29:54.414] - signal: TRUE
[09:29:54.414] - resignal: FALSE
[09:29:54.414] - force: TRUE
[09:29:54.414] - relayed: [n=2] TRUE, TRUE
[09:29:54.414] - queued futures: [n=2] TRUE, TRUE
 - flush all
[09:29:54.414] - relayed: [n=2] TRUE, TRUE
[09:29:54.414] - queued futures: [n=2] TRUE, TRUE
[09:29:54.414] signalConditionsASAP(NULL, pos=0) ... done
[09:29:54.415] resolve() on list ... DONE
[09:29:54.415] result() for ClusterFuture ...
[09:29:54.415] - result already collected: FutureResult
[09:29:54.415] result() for ClusterFuture ... done
[09:29:54.415] result() for ClusterFuture ...
[09:29:54.415] - result already collected: FutureResult
[09:29:54.415] result() for ClusterFuture ... done
[09:29:54.415] result() for ClusterFuture ...
[09:29:54.415] - result already collected: FutureResult
[09:29:54.415] result() for ClusterFuture ... done
[09:29:54.415] result() for ClusterFuture ...
[09:29:54.415] - result already collected: FutureResult
[09:29:54.416] result() for ClusterFuture ... done
[09:29:54.416]  - Number of value chunks collected: 2
[09:29:54.416] Resolving 2 futures (chunks) ... DONE
[09:29:54.416] Reducing values from 2 chunks ...
[09:29:54.416]  - Number of values collected after concatenation: 3
[09:29:54.416]  - Number of values expected: 3
[09:29:54.416] Reducing values from 2 chunks ... DONE
[09:29:54.416] future_lapply() ... DONE
- exceptions ...
[09:29:54.416] future_lapply() ...
[09:29:54.421] Number of chunks: 2
[09:29:54.422] getGlobalsAndPackagesXApply() ...
[09:29:54.422]  - future.globals: TRUE
[09:29:54.422] getGlobalsAndPackages() ...
[09:29:54.422] Searching for globals...
[09:29:54.425] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[09:29:54.425] Searching for globals ... DONE
[09:29:54.425] Resolving globals: FALSE
[09:29:54.426] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[09:29:54.426] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[09:29:54.427] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:54.427] - packages: [1] ‘future.apply’
[09:29:54.427] getGlobalsAndPackages() ... DONE
[09:29:54.427]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[09:29:54.427]  - needed namespaces: [n=1] ‘future.apply’
[09:29:54.427] Finding globals ... DONE
[09:29:54.427]  - use_args: TRUE
[09:29:54.427]  - Getting '...' globals ...
[09:29:54.428] resolve() on list ...
[09:29:54.428]  recursive: 0
[09:29:54.428]  length: 1
[09:29:54.428]  elements: ‘...’
[09:29:54.428]  length: 0 (resolved future 1)
[09:29:54.428] resolve() on list ... DONE
[09:29:54.428]    - '...' content: [n=0] 
[09:29:54.428] List of 1
[09:29:54.428]  $ ...: list()
[09:29:54.428]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:54.428]  - attr(*, "where")=List of 1
[09:29:54.428]   ..$ ...:<environment: 0x561d367d4498> 
[09:29:54.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:54.428]  - attr(*, "resolved")= logi TRUE
[09:29:54.428]  - attr(*, "total_size")= num NA
[09:29:54.431]  - Getting '...' globals ... DONE
[09:29:54.431] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[09:29:54.431] List of 8
[09:29:54.431]  $ ...future.FUN:function (x, ...)  
[09:29:54.431]  $ x_FUN        :function (x)  
[09:29:54.431]  $ times        : int 2
[09:29:54.431]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[09:29:54.431]  $ stop_if_not  :function (...)  
[09:29:54.431]  $ dim          : NULL
[09:29:54.431]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[09:29:54.431]  $ ...          : list()
[09:29:54.431]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[09:29:54.431]  - attr(*, "where")=List of 8
[09:29:54.431]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[09:29:54.431]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[09:29:54.431]   ..$ times        :<environment: R_EmptyEnv> 
[09:29:54.431]   ..$ stopf        :<environment: R_EmptyEnv> 
[09:29:54.431]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[09:29:54.431]   ..$ dim          :<environment: R_EmptyEnv> 
[09:29:54.431]   ..$ valid_types  :<environment: R_EmptyEnv> 
[09:29:54.431]   ..$ ...          :<environment: 0x561d367d4498> 
[09:29:54.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:29:54.431]  - attr(*, "resolved")= logi FALSE
[09:29:54.431]  - attr(*, "total_size")= num 95128
[09:29:54.436] Packages to be attached in all futures: [n=1] ‘future.apply’
[09:29:54.436] getGlobalsAndPackagesXApply() ... DONE
[09:29:54.437] Number of futures (= number of chunks): 2
[09:29:54.437] Launching 2 futures (chunks) ...
[09:29:54.437] Chunk #1 of 2 ...
[09:29:54.437]  - Finding globals in 'X' for chunk #1 ...
[09:29:54.437] getGlobalsAndPackages() ...
[09:29:54.437] Searching for globals...
[09:29:54.437] 
[09:29:54.437] Searching for globals ... DONE
[09:29:54.438] - globals: [0] <none>
[09:29:54.438] getGlobalsAndPackages() ... DONE
[09:29:54.438]    + additional globals found: [n=0] 
[09:29:54.438]    + additional namespaces needed: [n=0] 
[09:29:54.438]  - Finding globals in 'X' for chunk #1 ... DONE
[09:29:54.438]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:54.438]  - seeds: <none>
[09:29:54.438]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.438] getGlobalsAndPackages() ...
[09:29:54.438] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.438] Resolving globals: FALSE
[09:29:54.439] Tweak future expression to call with '...' arguments ...
[09:29:54.439] {
[09:29:54.439]     do.call(function(...) {
[09:29:54.439]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.439]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:54.439]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.439]             on.exit(options(oopts), add = TRUE)
[09:29:54.439]         }
[09:29:54.439]         {
[09:29:54.439]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:54.439]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.439]                 ...future.FUN(...future.X_jj, ...)
[09:29:54.439]             })
[09:29:54.439]         }
[09:29:54.439]     }, args = future.call.arguments)
[09:29:54.439] }
[09:29:54.439] Tweak future expression to call with '...' arguments ... DONE
[09:29:54.439] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.439] - packages: [1] ‘future.apply’
[09:29:54.440] getGlobalsAndPackages() ... DONE
[09:29:54.440] run() for ‘Future’ ...
[09:29:54.440] - state: ‘created’
[09:29:54.440] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:54.454] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:54.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:54.454]   - Field: ‘node’
[09:29:54.454]   - Field: ‘label’
[09:29:54.454]   - Field: ‘local’
[09:29:54.454]   - Field: ‘owner’
[09:29:54.454]   - Field: ‘envir’
[09:29:54.454]   - Field: ‘workers’
[09:29:54.454]   - Field: ‘packages’
[09:29:54.454]   - Field: ‘gc’
[09:29:54.455]   - Field: ‘conditions’
[09:29:54.455]   - Field: ‘persistent’
[09:29:54.455]   - Field: ‘expr’
[09:29:54.455]   - Field: ‘uuid’
[09:29:54.455]   - Field: ‘seed’
[09:29:54.455]   - Field: ‘version’
[09:29:54.455]   - Field: ‘result’
[09:29:54.455]   - Field: ‘asynchronous’
[09:29:54.455]   - Field: ‘calls’
[09:29:54.455]   - Field: ‘globals’
[09:29:54.455]   - Field: ‘stdout’
[09:29:54.456]   - Field: ‘earlySignal’
[09:29:54.456]   - Field: ‘lazy’
[09:29:54.456]   - Field: ‘state’
[09:29:54.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:54.456] - Launch lazy future ...
[09:29:54.456] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:54.456] Packages needed by future strategies (n = 0): <none>
[09:29:54.457] {
[09:29:54.457]     {
[09:29:54.457]         {
[09:29:54.457]             ...future.startTime <- base::Sys.time()
[09:29:54.457]             {
[09:29:54.457]                 {
[09:29:54.457]                   {
[09:29:54.457]                     {
[09:29:54.457]                       {
[09:29:54.457]                         base::local({
[09:29:54.457]                           has_future <- base::requireNamespace("future", 
[09:29:54.457]                             quietly = TRUE)
[09:29:54.457]                           if (has_future) {
[09:29:54.457]                             ns <- base::getNamespace("future")
[09:29:54.457]                             version <- ns[[".package"]][["version"]]
[09:29:54.457]                             if (is.null(version)) 
[09:29:54.457]                               version <- utils::packageVersion("future")
[09:29:54.457]                           }
[09:29:54.457]                           else {
[09:29:54.457]                             version <- NULL
[09:29:54.457]                           }
[09:29:54.457]                           if (!has_future || version < "1.8.0") {
[09:29:54.457]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:54.457]                               "", base::R.version$version.string), 
[09:29:54.457]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:54.457]                                 base::R.version$platform, 8 * 
[09:29:54.457]                                   base::.Machine$sizeof.pointer), 
[09:29:54.457]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:54.457]                                 "release", "version")], collapse = " "), 
[09:29:54.457]                               hostname = base::Sys.info()[["nodename"]])
[09:29:54.457]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:54.457]                               info)
[09:29:54.457]                             info <- base::paste(info, collapse = "; ")
[09:29:54.457]                             if (!has_future) {
[09:29:54.457]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:54.457]                                 info)
[09:29:54.457]                             }
[09:29:54.457]                             else {
[09:29:54.457]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:54.457]                                 info, version)
[09:29:54.457]                             }
[09:29:54.457]                             base::stop(msg)
[09:29:54.457]                           }
[09:29:54.457]                         })
[09:29:54.457]                       }
[09:29:54.457]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:54.457]                       base::options(mc.cores = 1L)
[09:29:54.457]                     }
[09:29:54.457]                     base::local({
[09:29:54.457]                       for (pkg in "future.apply") {
[09:29:54.457]                         base::loadNamespace(pkg)
[09:29:54.457]                         base::library(pkg, character.only = TRUE)
[09:29:54.457]                       }
[09:29:54.457]                     })
[09:29:54.457]                   }
[09:29:54.457]                   ...future.strategy.old <- future::plan("list")
[09:29:54.457]                   options(future.plan = NULL)
[09:29:54.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:54.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:54.457]                 }
[09:29:54.457]                 ...future.workdir <- getwd()
[09:29:54.457]             }
[09:29:54.457]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:54.457]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:54.457]         }
[09:29:54.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:54.457]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:54.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:54.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:54.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:54.457]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:54.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:54.457]             base::names(...future.oldOptions))
[09:29:54.457]     }
[09:29:54.457]     if (FALSE) {
[09:29:54.457]     }
[09:29:54.457]     else {
[09:29:54.457]         if (TRUE) {
[09:29:54.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:54.457]                 open = "w")
[09:29:54.457]         }
[09:29:54.457]         else {
[09:29:54.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:54.457]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:54.457]         }
[09:29:54.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:54.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:54.457]             base::sink(type = "output", split = FALSE)
[09:29:54.457]             base::close(...future.stdout)
[09:29:54.457]         }, add = TRUE)
[09:29:54.457]     }
[09:29:54.457]     ...future.frame <- base::sys.nframe()
[09:29:54.457]     ...future.conditions <- base::list()
[09:29:54.457]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:54.457]     if (FALSE) {
[09:29:54.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:54.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:54.457]     }
[09:29:54.457]     ...future.result <- base::tryCatch({
[09:29:54.457]         base::withCallingHandlers({
[09:29:54.457]             ...future.value <- base::withVisible(base::local({
[09:29:54.457]                 ...future.makeSendCondition <- base::local({
[09:29:54.457]                   sendCondition <- NULL
[09:29:54.457]                   function(frame = 1L) {
[09:29:54.457]                     if (is.function(sendCondition)) 
[09:29:54.457]                       return(sendCondition)
[09:29:54.457]                     ns <- getNamespace("parallel")
[09:29:54.457]                     if (exists("sendData", mode = "function", 
[09:29:54.457]                       envir = ns)) {
[09:29:54.457]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:54.457]                         envir = ns)
[09:29:54.457]                       envir <- sys.frame(frame)
[09:29:54.457]                       master <- NULL
[09:29:54.457]                       while (!identical(envir, .GlobalEnv) && 
[09:29:54.457]                         !identical(envir, emptyenv())) {
[09:29:54.457]                         if (exists("master", mode = "list", envir = envir, 
[09:29:54.457]                           inherits = FALSE)) {
[09:29:54.457]                           master <- get("master", mode = "list", 
[09:29:54.457]                             envir = envir, inherits = FALSE)
[09:29:54.457]                           if (inherits(master, c("SOCKnode", 
[09:29:54.457]                             "SOCK0node"))) {
[09:29:54.457]                             sendCondition <<- function(cond) {
[09:29:54.457]                               data <- list(type = "VALUE", value = cond, 
[09:29:54.457]                                 success = TRUE)
[09:29:54.457]                               parallel_sendData(master, data)
[09:29:54.457]                             }
[09:29:54.457]                             return(sendCondition)
[09:29:54.457]                           }
[09:29:54.457]                         }
[09:29:54.457]                         frame <- frame + 1L
[09:29:54.457]                         envir <- sys.frame(frame)
[09:29:54.457]                       }
[09:29:54.457]                     }
[09:29:54.457]                     sendCondition <<- function(cond) NULL
[09:29:54.457]                   }
[09:29:54.457]                 })
[09:29:54.457]                 withCallingHandlers({
[09:29:54.457]                   {
[09:29:54.457]                     do.call(function(...) {
[09:29:54.457]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.457]                       if (!identical(...future.globals.maxSize.org, 
[09:29:54.457]                         ...future.globals.maxSize)) {
[09:29:54.457]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.457]                         on.exit(options(oopts), add = TRUE)
[09:29:54.457]                       }
[09:29:54.457]                       {
[09:29:54.457]                         lapply(seq_along(...future.elements_ii), 
[09:29:54.457]                           FUN = function(jj) {
[09:29:54.457]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.457]                             ...future.FUN(...future.X_jj, ...)
[09:29:54.457]                           })
[09:29:54.457]                       }
[09:29:54.457]                     }, args = future.call.arguments)
[09:29:54.457]                   }
[09:29:54.457]                 }, immediateCondition = function(cond) {
[09:29:54.457]                   sendCondition <- ...future.makeSendCondition()
[09:29:54.457]                   sendCondition(cond)
[09:29:54.457]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.457]                   {
[09:29:54.457]                     inherits <- base::inherits
[09:29:54.457]                     invokeRestart <- base::invokeRestart
[09:29:54.457]                     is.null <- base::is.null
[09:29:54.457]                     muffled <- FALSE
[09:29:54.457]                     if (inherits(cond, "message")) {
[09:29:54.457]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:54.457]                       if (muffled) 
[09:29:54.457]                         invokeRestart("muffleMessage")
[09:29:54.457]                     }
[09:29:54.457]                     else if (inherits(cond, "warning")) {
[09:29:54.457]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:54.457]                       if (muffled) 
[09:29:54.457]                         invokeRestart("muffleWarning")
[09:29:54.457]                     }
[09:29:54.457]                     else if (inherits(cond, "condition")) {
[09:29:54.457]                       if (!is.null(pattern)) {
[09:29:54.457]                         computeRestarts <- base::computeRestarts
[09:29:54.457]                         grepl <- base::grepl
[09:29:54.457]                         restarts <- computeRestarts(cond)
[09:29:54.457]                         for (restart in restarts) {
[09:29:54.457]                           name <- restart$name
[09:29:54.457]                           if (is.null(name)) 
[09:29:54.457]                             next
[09:29:54.457]                           if (!grepl(pattern, name)) 
[09:29:54.457]                             next
[09:29:54.457]                           invokeRestart(restart)
[09:29:54.457]                           muffled <- TRUE
[09:29:54.457]                           break
[09:29:54.457]                         }
[09:29:54.457]                       }
[09:29:54.457]                     }
[09:29:54.457]                     invisible(muffled)
[09:29:54.457]                   }
[09:29:54.457]                   muffleCondition(cond)
[09:29:54.457]                 })
[09:29:54.457]             }))
[09:29:54.457]             future::FutureResult(value = ...future.value$value, 
[09:29:54.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:54.457]                   ...future.rng), globalenv = if (FALSE) 
[09:29:54.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:54.457]                     ...future.globalenv.names))
[09:29:54.457]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:54.457]         }, condition = base::local({
[09:29:54.457]             c <- base::c
[09:29:54.457]             inherits <- base::inherits
[09:29:54.457]             invokeRestart <- base::invokeRestart
[09:29:54.457]             length <- base::length
[09:29:54.457]             list <- base::list
[09:29:54.457]             seq.int <- base::seq.int
[09:29:54.457]             signalCondition <- base::signalCondition
[09:29:54.457]             sys.calls <- base::sys.calls
[09:29:54.457]             `[[` <- base::`[[`
[09:29:54.457]             `+` <- base::`+`
[09:29:54.457]             `<<-` <- base::`<<-`
[09:29:54.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:54.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:54.457]                   3L)]
[09:29:54.457]             }
[09:29:54.457]             function(cond) {
[09:29:54.457]                 is_error <- inherits(cond, "error")
[09:29:54.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:54.457]                   NULL)
[09:29:54.457]                 if (is_error) {
[09:29:54.457]                   sessionInformation <- function() {
[09:29:54.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:54.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:54.457]                       search = base::search(), system = base::Sys.info())
[09:29:54.457]                   }
[09:29:54.457]                   ...future.conditions[[length(...future.conditions) + 
[09:29:54.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:54.457]                     cond$call), session = sessionInformation(), 
[09:29:54.457]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:54.457]                   signalCondition(cond)
[09:29:54.457]                 }
[09:29:54.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:54.457]                 "immediateCondition"))) {
[09:29:54.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:54.457]                   ...future.conditions[[length(...future.conditions) + 
[09:29:54.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:54.457]                   if (TRUE && !signal) {
[09:29:54.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.457]                     {
[09:29:54.457]                       inherits <- base::inherits
[09:29:54.457]                       invokeRestart <- base::invokeRestart
[09:29:54.457]                       is.null <- base::is.null
[09:29:54.457]                       muffled <- FALSE
[09:29:54.457]                       if (inherits(cond, "message")) {
[09:29:54.457]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:54.457]                         if (muffled) 
[09:29:54.457]                           invokeRestart("muffleMessage")
[09:29:54.457]                       }
[09:29:54.457]                       else if (inherits(cond, "warning")) {
[09:29:54.457]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:54.457]                         if (muffled) 
[09:29:54.457]                           invokeRestart("muffleWarning")
[09:29:54.457]                       }
[09:29:54.457]                       else if (inherits(cond, "condition")) {
[09:29:54.457]                         if (!is.null(pattern)) {
[09:29:54.457]                           computeRestarts <- base::computeRestarts
[09:29:54.457]                           grepl <- base::grepl
[09:29:54.457]                           restarts <- computeRestarts(cond)
[09:29:54.457]                           for (restart in restarts) {
[09:29:54.457]                             name <- restart$name
[09:29:54.457]                             if (is.null(name)) 
[09:29:54.457]                               next
[09:29:54.457]                             if (!grepl(pattern, name)) 
[09:29:54.457]                               next
[09:29:54.457]                             invokeRestart(restart)
[09:29:54.457]                             muffled <- TRUE
[09:29:54.457]                             break
[09:29:54.457]                           }
[09:29:54.457]                         }
[09:29:54.457]                       }
[09:29:54.457]                       invisible(muffled)
[09:29:54.457]                     }
[09:29:54.457]                     muffleCondition(cond, pattern = "^muffle")
[09:29:54.457]                   }
[09:29:54.457]                 }
[09:29:54.457]                 else {
[09:29:54.457]                   if (TRUE) {
[09:29:54.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.457]                     {
[09:29:54.457]                       inherits <- base::inherits
[09:29:54.457]                       invokeRestart <- base::invokeRestart
[09:29:54.457]                       is.null <- base::is.null
[09:29:54.457]                       muffled <- FALSE
[09:29:54.457]                       if (inherits(cond, "message")) {
[09:29:54.457]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:54.457]                         if (muffled) 
[09:29:54.457]                           invokeRestart("muffleMessage")
[09:29:54.457]                       }
[09:29:54.457]                       else if (inherits(cond, "warning")) {
[09:29:54.457]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:54.457]                         if (muffled) 
[09:29:54.457]                           invokeRestart("muffleWarning")
[09:29:54.457]                       }
[09:29:54.457]                       else if (inherits(cond, "condition")) {
[09:29:54.457]                         if (!is.null(pattern)) {
[09:29:54.457]                           computeRestarts <- base::computeRestarts
[09:29:54.457]                           grepl <- base::grepl
[09:29:54.457]                           restarts <- computeRestarts(cond)
[09:29:54.457]                           for (restart in restarts) {
[09:29:54.457]                             name <- restart$name
[09:29:54.457]                             if (is.null(name)) 
[09:29:54.457]                               next
[09:29:54.457]                             if (!grepl(pattern, name)) 
[09:29:54.457]                               next
[09:29:54.457]                             invokeRestart(restart)
[09:29:54.457]                             muffled <- TRUE
[09:29:54.457]                             break
[09:29:54.457]                           }
[09:29:54.457]                         }
[09:29:54.457]                       }
[09:29:54.457]                       invisible(muffled)
[09:29:54.457]                     }
[09:29:54.457]                     muffleCondition(cond, pattern = "^muffle")
[09:29:54.457]                   }
[09:29:54.457]                 }
[09:29:54.457]             }
[09:29:54.457]         }))
[09:29:54.457]     }, error = function(ex) {
[09:29:54.457]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:54.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:54.457]                 ...future.rng), started = ...future.startTime, 
[09:29:54.457]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:54.457]             version = "1.8"), class = "FutureResult")
[09:29:54.457]     }, finally = {
[09:29:54.457]         if (!identical(...future.workdir, getwd())) 
[09:29:54.457]             setwd(...future.workdir)
[09:29:54.457]         {
[09:29:54.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:54.457]                 ...future.oldOptions$nwarnings <- NULL
[09:29:54.457]             }
[09:29:54.457]             base::options(...future.oldOptions)
[09:29:54.457]             if (.Platform$OS.type == "windows") {
[09:29:54.457]                 old_names <- names(...future.oldEnvVars)
[09:29:54.457]                 envs <- base::Sys.getenv()
[09:29:54.457]                 names <- names(envs)
[09:29:54.457]                 common <- intersect(names, old_names)
[09:29:54.457]                 added <- setdiff(names, old_names)
[09:29:54.457]                 removed <- setdiff(old_names, names)
[09:29:54.457]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:54.457]                   envs[common]]
[09:29:54.457]                 NAMES <- toupper(changed)
[09:29:54.457]                 args <- list()
[09:29:54.457]                 for (kk in seq_along(NAMES)) {
[09:29:54.457]                   name <- changed[[kk]]
[09:29:54.457]                   NAME <- NAMES[[kk]]
[09:29:54.457]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.457]                     next
[09:29:54.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:54.457]                 }
[09:29:54.457]                 NAMES <- toupper(added)
[09:29:54.457]                 for (kk in seq_along(NAMES)) {
[09:29:54.457]                   name <- added[[kk]]
[09:29:54.457]                   NAME <- NAMES[[kk]]
[09:29:54.457]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.457]                     next
[09:29:54.457]                   args[[name]] <- ""
[09:29:54.457]                 }
[09:29:54.457]                 NAMES <- toupper(removed)
[09:29:54.457]                 for (kk in seq_along(NAMES)) {
[09:29:54.457]                   name <- removed[[kk]]
[09:29:54.457]                   NAME <- NAMES[[kk]]
[09:29:54.457]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.457]                     next
[09:29:54.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:54.457]                 }
[09:29:54.457]                 if (length(args) > 0) 
[09:29:54.457]                   base::do.call(base::Sys.setenv, args = args)
[09:29:54.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:54.457]             }
[09:29:54.457]             else {
[09:29:54.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:54.457]             }
[09:29:54.457]             {
[09:29:54.457]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:54.457]                   0L) {
[09:29:54.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:54.457]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:54.457]                   base::options(opts)
[09:29:54.457]                 }
[09:29:54.457]                 {
[09:29:54.457]                   {
[09:29:54.457]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:54.457]                     NULL
[09:29:54.457]                   }
[09:29:54.457]                   options(future.plan = NULL)
[09:29:54.457]                   if (is.na(NA_character_)) 
[09:29:54.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:54.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:54.457]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:54.457]                     .init = FALSE)
[09:29:54.457]                 }
[09:29:54.457]             }
[09:29:54.457]         }
[09:29:54.457]     })
[09:29:54.457]     if (TRUE) {
[09:29:54.457]         base::sink(type = "output", split = FALSE)
[09:29:54.457]         if (TRUE) {
[09:29:54.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:54.457]         }
[09:29:54.457]         else {
[09:29:54.457]             ...future.result["stdout"] <- base::list(NULL)
[09:29:54.457]         }
[09:29:54.457]         base::close(...future.stdout)
[09:29:54.457]         ...future.stdout <- NULL
[09:29:54.457]     }
[09:29:54.457]     ...future.result$conditions <- ...future.conditions
[09:29:54.457]     ...future.result$finished <- base::Sys.time()
[09:29:54.457]     ...future.result
[09:29:54.457] }
[09:29:54.459] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[09:29:54.460] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:54.504] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:54.504] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[09:29:54.505] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[09:29:54.505] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:54.505] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:54.505] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:54.548] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:54.548] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:54.592] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:54.592] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:54.593] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.593] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:54.593] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:54.594] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:54.594] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.594] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[09:29:54.594] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[09:29:54.594] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:54.595] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.595] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:54.595] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.595] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[09:29:54.596] MultisessionFuture started
[09:29:54.596] - Launch lazy future ... done
[09:29:54.596] run() for ‘MultisessionFuture’ ... done
[09:29:54.596] Created future:
[09:29:54.598] receiveMessageFromWorker() for ClusterFuture ...
[09:29:54.598] - Validating connection of MultisessionFuture
[09:29:54.599] - received message: FutureResult
[09:29:54.599] - Received FutureResult
[09:29:54.599] - Erased future from FutureRegistry
[09:29:54.599] result() for ClusterFuture ...
[09:29:54.599] - result already collected: FutureResult
[09:29:54.599] result() for ClusterFuture ... done
[09:29:54.599] signalConditions() ...
[09:29:54.599]  - include = ‘immediateCondition’
[09:29:54.599]  - exclude = 
[09:29:54.599]  - resignal = FALSE
[09:29:54.600]  - Number of conditions: 1
[09:29:54.600] signalConditions() ... done
[09:29:54.600] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:54.596] MultisessionFuture:
[09:29:54.596] Label: ‘future_vapply-1’
[09:29:54.596] Expression:
[09:29:54.596] {
[09:29:54.596]     do.call(function(...) {
[09:29:54.596]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.596]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:54.596]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.596]             on.exit(options(oopts), add = TRUE)
[09:29:54.596]         }
[09:29:54.596]         {
[09:29:54.596]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:54.596]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.596]                 ...future.FUN(...future.X_jj, ...)
[09:29:54.596]             })
[09:29:54.596]         }
[09:29:54.596]     }, args = future.call.arguments)
[09:29:54.596] }
[09:29:54.596] Lazy evaluation: FALSE
[09:29:54.596] Asynchronous evaluation: TRUE
[09:29:54.596] Local evaluation: TRUE
[09:29:54.596] Environment: R_GlobalEnv
[09:29:54.596] Capture standard output: TRUE
[09:29:54.596] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:54.596] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:54.596] Packages: 1 packages (‘future.apply’)
[09:29:54.596] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:54.596] Resolved: TRUE
[09:29:54.596] Value: <not collected>
[09:29:54.596] Conditions captured: <none>
[09:29:54.596] Early signaling: FALSE
[09:29:54.596] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:54.596] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:54.600] Chunk #1 of 2 ... DONE
[09:29:54.600] Chunk #2 of 2 ...
[09:29:54.600]  - Finding globals in 'X' for chunk #2 ...
[09:29:54.600] getGlobalsAndPackages() ...
[09:29:54.600] Searching for globals...
[09:29:54.601] 
[09:29:54.601] Searching for globals ... DONE
[09:29:54.601] - globals: [0] <none>
[09:29:54.601] getGlobalsAndPackages() ... DONE
[09:29:54.601]    + additional globals found: [n=0] 
[09:29:54.601]    + additional namespaces needed: [n=0] 
[09:29:54.601]  - Finding globals in 'X' for chunk #2 ... DONE
[09:29:54.601]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[09:29:54.601]  - seeds: <none>
[09:29:54.602]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.602] getGlobalsAndPackages() ...
[09:29:54.602] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.602] Resolving globals: FALSE
[09:29:54.602] Tweak future expression to call with '...' arguments ...
[09:29:54.602] {
[09:29:54.602]     do.call(function(...) {
[09:29:54.602]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.602]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:54.602]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.602]             on.exit(options(oopts), add = TRUE)
[09:29:54.602]         }
[09:29:54.602]         {
[09:29:54.602]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:54.602]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.602]                 ...future.FUN(...future.X_jj, ...)
[09:29:54.602]             })
[09:29:54.602]         }
[09:29:54.602]     }, args = future.call.arguments)
[09:29:54.602] }
[09:29:54.602] Tweak future expression to call with '...' arguments ... DONE
[09:29:54.603] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[09:29:54.603] - packages: [1] ‘future.apply’
[09:29:54.603] getGlobalsAndPackages() ... DONE
[09:29:54.603] run() for ‘Future’ ...
[09:29:54.603] - state: ‘created’
[09:29:54.604] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:29:54.618] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:54.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:29:54.618]   - Field: ‘node’
[09:29:54.618]   - Field: ‘label’
[09:29:54.618]   - Field: ‘local’
[09:29:54.618]   - Field: ‘owner’
[09:29:54.618]   - Field: ‘envir’
[09:29:54.619]   - Field: ‘workers’
[09:29:54.619]   - Field: ‘packages’
[09:29:54.619]   - Field: ‘gc’
[09:29:54.619]   - Field: ‘conditions’
[09:29:54.619]   - Field: ‘persistent’
[09:29:54.619]   - Field: ‘expr’
[09:29:54.619]   - Field: ‘uuid’
[09:29:54.619]   - Field: ‘seed’
[09:29:54.619]   - Field: ‘version’
[09:29:54.619]   - Field: ‘result’
[09:29:54.619]   - Field: ‘asynchronous’
[09:29:54.620]   - Field: ‘calls’
[09:29:54.620]   - Field: ‘globals’
[09:29:54.620]   - Field: ‘stdout’
[09:29:54.620]   - Field: ‘earlySignal’
[09:29:54.620]   - Field: ‘lazy’
[09:29:54.620]   - Field: ‘state’
[09:29:54.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:29:54.620] - Launch lazy future ...
[09:29:54.621] Packages needed by the future expression (n = 1): ‘future.apply’
[09:29:54.621] Packages needed by future strategies (n = 0): <none>
[09:29:54.621] {
[09:29:54.621]     {
[09:29:54.621]         {
[09:29:54.621]             ...future.startTime <- base::Sys.time()
[09:29:54.621]             {
[09:29:54.621]                 {
[09:29:54.621]                   {
[09:29:54.621]                     {
[09:29:54.621]                       {
[09:29:54.621]                         base::local({
[09:29:54.621]                           has_future <- base::requireNamespace("future", 
[09:29:54.621]                             quietly = TRUE)
[09:29:54.621]                           if (has_future) {
[09:29:54.621]                             ns <- base::getNamespace("future")
[09:29:54.621]                             version <- ns[[".package"]][["version"]]
[09:29:54.621]                             if (is.null(version)) 
[09:29:54.621]                               version <- utils::packageVersion("future")
[09:29:54.621]                           }
[09:29:54.621]                           else {
[09:29:54.621]                             version <- NULL
[09:29:54.621]                           }
[09:29:54.621]                           if (!has_future || version < "1.8.0") {
[09:29:54.621]                             info <- base::c(r_version = base::gsub("R version ", 
[09:29:54.621]                               "", base::R.version$version.string), 
[09:29:54.621]                               platform = base::sprintf("%s (%s-bit)", 
[09:29:54.621]                                 base::R.version$platform, 8 * 
[09:29:54.621]                                   base::.Machine$sizeof.pointer), 
[09:29:54.621]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:29:54.621]                                 "release", "version")], collapse = " "), 
[09:29:54.621]                               hostname = base::Sys.info()[["nodename"]])
[09:29:54.621]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:29:54.621]                               info)
[09:29:54.621]                             info <- base::paste(info, collapse = "; ")
[09:29:54.621]                             if (!has_future) {
[09:29:54.621]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:29:54.621]                                 info)
[09:29:54.621]                             }
[09:29:54.621]                             else {
[09:29:54.621]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:29:54.621]                                 info, version)
[09:29:54.621]                             }
[09:29:54.621]                             base::stop(msg)
[09:29:54.621]                           }
[09:29:54.621]                         })
[09:29:54.621]                       }
[09:29:54.621]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:29:54.621]                       base::options(mc.cores = 1L)
[09:29:54.621]                     }
[09:29:54.621]                     base::local({
[09:29:54.621]                       for (pkg in "future.apply") {
[09:29:54.621]                         base::loadNamespace(pkg)
[09:29:54.621]                         base::library(pkg, character.only = TRUE)
[09:29:54.621]                       }
[09:29:54.621]                     })
[09:29:54.621]                   }
[09:29:54.621]                   ...future.strategy.old <- future::plan("list")
[09:29:54.621]                   options(future.plan = NULL)
[09:29:54.621]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:29:54.621]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:29:54.621]                 }
[09:29:54.621]                 ...future.workdir <- getwd()
[09:29:54.621]             }
[09:29:54.621]             ...future.oldOptions <- base::as.list(base::.Options)
[09:29:54.621]             ...future.oldEnvVars <- base::Sys.getenv()
[09:29:54.621]         }
[09:29:54.621]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:29:54.621]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[09:29:54.621]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:29:54.621]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:29:54.621]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:29:54.621]             future.stdout.windows.reencode = NULL, width = 80L)
[09:29:54.621]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:29:54.621]             base::names(...future.oldOptions))
[09:29:54.621]     }
[09:29:54.621]     if (FALSE) {
[09:29:54.621]     }
[09:29:54.621]     else {
[09:29:54.621]         if (TRUE) {
[09:29:54.621]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:29:54.621]                 open = "w")
[09:29:54.621]         }
[09:29:54.621]         else {
[09:29:54.621]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:29:54.621]                 windows = "NUL", "/dev/null"), open = "w")
[09:29:54.621]         }
[09:29:54.621]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:29:54.621]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:29:54.621]             base::sink(type = "output", split = FALSE)
[09:29:54.621]             base::close(...future.stdout)
[09:29:54.621]         }, add = TRUE)
[09:29:54.621]     }
[09:29:54.621]     ...future.frame <- base::sys.nframe()
[09:29:54.621]     ...future.conditions <- base::list()
[09:29:54.621]     ...future.rng <- base::globalenv()$.Random.seed
[09:29:54.621]     if (FALSE) {
[09:29:54.621]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:29:54.621]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:29:54.621]     }
[09:29:54.621]     ...future.result <- base::tryCatch({
[09:29:54.621]         base::withCallingHandlers({
[09:29:54.621]             ...future.value <- base::withVisible(base::local({
[09:29:54.621]                 ...future.makeSendCondition <- base::local({
[09:29:54.621]                   sendCondition <- NULL
[09:29:54.621]                   function(frame = 1L) {
[09:29:54.621]                     if (is.function(sendCondition)) 
[09:29:54.621]                       return(sendCondition)
[09:29:54.621]                     ns <- getNamespace("parallel")
[09:29:54.621]                     if (exists("sendData", mode = "function", 
[09:29:54.621]                       envir = ns)) {
[09:29:54.621]                       parallel_sendData <- get("sendData", mode = "function", 
[09:29:54.621]                         envir = ns)
[09:29:54.621]                       envir <- sys.frame(frame)
[09:29:54.621]                       master <- NULL
[09:29:54.621]                       while (!identical(envir, .GlobalEnv) && 
[09:29:54.621]                         !identical(envir, emptyenv())) {
[09:29:54.621]                         if (exists("master", mode = "list", envir = envir, 
[09:29:54.621]                           inherits = FALSE)) {
[09:29:54.621]                           master <- get("master", mode = "list", 
[09:29:54.621]                             envir = envir, inherits = FALSE)
[09:29:54.621]                           if (inherits(master, c("SOCKnode", 
[09:29:54.621]                             "SOCK0node"))) {
[09:29:54.621]                             sendCondition <<- function(cond) {
[09:29:54.621]                               data <- list(type = "VALUE", value = cond, 
[09:29:54.621]                                 success = TRUE)
[09:29:54.621]                               parallel_sendData(master, data)
[09:29:54.621]                             }
[09:29:54.621]                             return(sendCondition)
[09:29:54.621]                           }
[09:29:54.621]                         }
[09:29:54.621]                         frame <- frame + 1L
[09:29:54.621]                         envir <- sys.frame(frame)
[09:29:54.621]                       }
[09:29:54.621]                     }
[09:29:54.621]                     sendCondition <<- function(cond) NULL
[09:29:54.621]                   }
[09:29:54.621]                 })
[09:29:54.621]                 withCallingHandlers({
[09:29:54.621]                   {
[09:29:54.621]                     do.call(function(...) {
[09:29:54.621]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.621]                       if (!identical(...future.globals.maxSize.org, 
[09:29:54.621]                         ...future.globals.maxSize)) {
[09:29:54.621]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.621]                         on.exit(options(oopts), add = TRUE)
[09:29:54.621]                       }
[09:29:54.621]                       {
[09:29:54.621]                         lapply(seq_along(...future.elements_ii), 
[09:29:54.621]                           FUN = function(jj) {
[09:29:54.621]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.621]                             ...future.FUN(...future.X_jj, ...)
[09:29:54.621]                           })
[09:29:54.621]                       }
[09:29:54.621]                     }, args = future.call.arguments)
[09:29:54.621]                   }
[09:29:54.621]                 }, immediateCondition = function(cond) {
[09:29:54.621]                   sendCondition <- ...future.makeSendCondition()
[09:29:54.621]                   sendCondition(cond)
[09:29:54.621]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.621]                   {
[09:29:54.621]                     inherits <- base::inherits
[09:29:54.621]                     invokeRestart <- base::invokeRestart
[09:29:54.621]                     is.null <- base::is.null
[09:29:54.621]                     muffled <- FALSE
[09:29:54.621]                     if (inherits(cond, "message")) {
[09:29:54.621]                       muffled <- grepl(pattern, "muffleMessage")
[09:29:54.621]                       if (muffled) 
[09:29:54.621]                         invokeRestart("muffleMessage")
[09:29:54.621]                     }
[09:29:54.621]                     else if (inherits(cond, "warning")) {
[09:29:54.621]                       muffled <- grepl(pattern, "muffleWarning")
[09:29:54.621]                       if (muffled) 
[09:29:54.621]                         invokeRestart("muffleWarning")
[09:29:54.621]                     }
[09:29:54.621]                     else if (inherits(cond, "condition")) {
[09:29:54.621]                       if (!is.null(pattern)) {
[09:29:54.621]                         computeRestarts <- base::computeRestarts
[09:29:54.621]                         grepl <- base::grepl
[09:29:54.621]                         restarts <- computeRestarts(cond)
[09:29:54.621]                         for (restart in restarts) {
[09:29:54.621]                           name <- restart$name
[09:29:54.621]                           if (is.null(name)) 
[09:29:54.621]                             next
[09:29:54.621]                           if (!grepl(pattern, name)) 
[09:29:54.621]                             next
[09:29:54.621]                           invokeRestart(restart)
[09:29:54.621]                           muffled <- TRUE
[09:29:54.621]                           break
[09:29:54.621]                         }
[09:29:54.621]                       }
[09:29:54.621]                     }
[09:29:54.621]                     invisible(muffled)
[09:29:54.621]                   }
[09:29:54.621]                   muffleCondition(cond)
[09:29:54.621]                 })
[09:29:54.621]             }))
[09:29:54.621]             future::FutureResult(value = ...future.value$value, 
[09:29:54.621]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:54.621]                   ...future.rng), globalenv = if (FALSE) 
[09:29:54.621]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:29:54.621]                     ...future.globalenv.names))
[09:29:54.621]                 else NULL, started = ...future.startTime, version = "1.8")
[09:29:54.621]         }, condition = base::local({
[09:29:54.621]             c <- base::c
[09:29:54.621]             inherits <- base::inherits
[09:29:54.621]             invokeRestart <- base::invokeRestart
[09:29:54.621]             length <- base::length
[09:29:54.621]             list <- base::list
[09:29:54.621]             seq.int <- base::seq.int
[09:29:54.621]             signalCondition <- base::signalCondition
[09:29:54.621]             sys.calls <- base::sys.calls
[09:29:54.621]             `[[` <- base::`[[`
[09:29:54.621]             `+` <- base::`+`
[09:29:54.621]             `<<-` <- base::`<<-`
[09:29:54.621]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:29:54.621]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:29:54.621]                   3L)]
[09:29:54.621]             }
[09:29:54.621]             function(cond) {
[09:29:54.621]                 is_error <- inherits(cond, "error")
[09:29:54.621]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:29:54.621]                   NULL)
[09:29:54.621]                 if (is_error) {
[09:29:54.621]                   sessionInformation <- function() {
[09:29:54.621]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:29:54.621]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:29:54.621]                       search = base::search(), system = base::Sys.info())
[09:29:54.621]                   }
[09:29:54.621]                   ...future.conditions[[length(...future.conditions) + 
[09:29:54.621]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:29:54.621]                     cond$call), session = sessionInformation(), 
[09:29:54.621]                     timestamp = base::Sys.time(), signaled = 0L)
[09:29:54.621]                   signalCondition(cond)
[09:29:54.621]                 }
[09:29:54.621]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:29:54.621]                 "immediateCondition"))) {
[09:29:54.621]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:29:54.621]                   ...future.conditions[[length(...future.conditions) + 
[09:29:54.621]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:29:54.621]                   if (TRUE && !signal) {
[09:29:54.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.621]                     {
[09:29:54.621]                       inherits <- base::inherits
[09:29:54.621]                       invokeRestart <- base::invokeRestart
[09:29:54.621]                       is.null <- base::is.null
[09:29:54.621]                       muffled <- FALSE
[09:29:54.621]                       if (inherits(cond, "message")) {
[09:29:54.621]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:54.621]                         if (muffled) 
[09:29:54.621]                           invokeRestart("muffleMessage")
[09:29:54.621]                       }
[09:29:54.621]                       else if (inherits(cond, "warning")) {
[09:29:54.621]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:54.621]                         if (muffled) 
[09:29:54.621]                           invokeRestart("muffleWarning")
[09:29:54.621]                       }
[09:29:54.621]                       else if (inherits(cond, "condition")) {
[09:29:54.621]                         if (!is.null(pattern)) {
[09:29:54.621]                           computeRestarts <- base::computeRestarts
[09:29:54.621]                           grepl <- base::grepl
[09:29:54.621]                           restarts <- computeRestarts(cond)
[09:29:54.621]                           for (restart in restarts) {
[09:29:54.621]                             name <- restart$name
[09:29:54.621]                             if (is.null(name)) 
[09:29:54.621]                               next
[09:29:54.621]                             if (!grepl(pattern, name)) 
[09:29:54.621]                               next
[09:29:54.621]                             invokeRestart(restart)
[09:29:54.621]                             muffled <- TRUE
[09:29:54.621]                             break
[09:29:54.621]                           }
[09:29:54.621]                         }
[09:29:54.621]                       }
[09:29:54.621]                       invisible(muffled)
[09:29:54.621]                     }
[09:29:54.621]                     muffleCondition(cond, pattern = "^muffle")
[09:29:54.621]                   }
[09:29:54.621]                 }
[09:29:54.621]                 else {
[09:29:54.621]                   if (TRUE) {
[09:29:54.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:29:54.621]                     {
[09:29:54.621]                       inherits <- base::inherits
[09:29:54.621]                       invokeRestart <- base::invokeRestart
[09:29:54.621]                       is.null <- base::is.null
[09:29:54.621]                       muffled <- FALSE
[09:29:54.621]                       if (inherits(cond, "message")) {
[09:29:54.621]                         muffled <- grepl(pattern, "muffleMessage")
[09:29:54.621]                         if (muffled) 
[09:29:54.621]                           invokeRestart("muffleMessage")
[09:29:54.621]                       }
[09:29:54.621]                       else if (inherits(cond, "warning")) {
[09:29:54.621]                         muffled <- grepl(pattern, "muffleWarning")
[09:29:54.621]                         if (muffled) 
[09:29:54.621]                           invokeRestart("muffleWarning")
[09:29:54.621]                       }
[09:29:54.621]                       else if (inherits(cond, "condition")) {
[09:29:54.621]                         if (!is.null(pattern)) {
[09:29:54.621]                           computeRestarts <- base::computeRestarts
[09:29:54.621]                           grepl <- base::grepl
[09:29:54.621]                           restarts <- computeRestarts(cond)
[09:29:54.621]                           for (restart in restarts) {
[09:29:54.621]                             name <- restart$name
[09:29:54.621]                             if (is.null(name)) 
[09:29:54.621]                               next
[09:29:54.621]                             if (!grepl(pattern, name)) 
[09:29:54.621]                               next
[09:29:54.621]                             invokeRestart(restart)
[09:29:54.621]                             muffled <- TRUE
[09:29:54.621]                             break
[09:29:54.621]                           }
[09:29:54.621]                         }
[09:29:54.621]                       }
[09:29:54.621]                       invisible(muffled)
[09:29:54.621]                     }
[09:29:54.621]                     muffleCondition(cond, pattern = "^muffle")
[09:29:54.621]                   }
[09:29:54.621]                 }
[09:29:54.621]             }
[09:29:54.621]         }))
[09:29:54.621]     }, error = function(ex) {
[09:29:54.621]         base::structure(base::list(value = NULL, visible = NULL, 
[09:29:54.621]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:29:54.621]                 ...future.rng), started = ...future.startTime, 
[09:29:54.621]             finished = Sys.time(), session_uuid = NA_character_, 
[09:29:54.621]             version = "1.8"), class = "FutureResult")
[09:29:54.621]     }, finally = {
[09:29:54.621]         if (!identical(...future.workdir, getwd())) 
[09:29:54.621]             setwd(...future.workdir)
[09:29:54.621]         {
[09:29:54.621]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:29:54.621]                 ...future.oldOptions$nwarnings <- NULL
[09:29:54.621]             }
[09:29:54.621]             base::options(...future.oldOptions)
[09:29:54.621]             if (.Platform$OS.type == "windows") {
[09:29:54.621]                 old_names <- names(...future.oldEnvVars)
[09:29:54.621]                 envs <- base::Sys.getenv()
[09:29:54.621]                 names <- names(envs)
[09:29:54.621]                 common <- intersect(names, old_names)
[09:29:54.621]                 added <- setdiff(names, old_names)
[09:29:54.621]                 removed <- setdiff(old_names, names)
[09:29:54.621]                 changed <- common[...future.oldEnvVars[common] != 
[09:29:54.621]                   envs[common]]
[09:29:54.621]                 NAMES <- toupper(changed)
[09:29:54.621]                 args <- list()
[09:29:54.621]                 for (kk in seq_along(NAMES)) {
[09:29:54.621]                   name <- changed[[kk]]
[09:29:54.621]                   NAME <- NAMES[[kk]]
[09:29:54.621]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.621]                     next
[09:29:54.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:54.621]                 }
[09:29:54.621]                 NAMES <- toupper(added)
[09:29:54.621]                 for (kk in seq_along(NAMES)) {
[09:29:54.621]                   name <- added[[kk]]
[09:29:54.621]                   NAME <- NAMES[[kk]]
[09:29:54.621]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.621]                     next
[09:29:54.621]                   args[[name]] <- ""
[09:29:54.621]                 }
[09:29:54.621]                 NAMES <- toupper(removed)
[09:29:54.621]                 for (kk in seq_along(NAMES)) {
[09:29:54.621]                   name <- removed[[kk]]
[09:29:54.621]                   NAME <- NAMES[[kk]]
[09:29:54.621]                   if (name != NAME && is.element(NAME, old_names)) 
[09:29:54.621]                     next
[09:29:54.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:29:54.621]                 }
[09:29:54.621]                 if (length(args) > 0) 
[09:29:54.621]                   base::do.call(base::Sys.setenv, args = args)
[09:29:54.621]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:29:54.621]             }
[09:29:54.621]             else {
[09:29:54.621]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:29:54.621]             }
[09:29:54.621]             {
[09:29:54.621]                 if (base::length(...future.futureOptionsAdded) > 
[09:29:54.621]                   0L) {
[09:29:54.621]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:29:54.621]                   base::names(opts) <- ...future.futureOptionsAdded
[09:29:54.621]                   base::options(opts)
[09:29:54.621]                 }
[09:29:54.621]                 {
[09:29:54.621]                   {
[09:29:54.621]                     base::options(mc.cores = ...future.mc.cores.old)
[09:29:54.621]                     NULL
[09:29:54.621]                   }
[09:29:54.621]                   options(future.plan = NULL)
[09:29:54.621]                   if (is.na(NA_character_)) 
[09:29:54.621]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:29:54.621]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:29:54.621]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:29:54.621]                     .init = FALSE)
[09:29:54.621]                 }
[09:29:54.621]             }
[09:29:54.621]         }
[09:29:54.621]     })
[09:29:54.621]     if (TRUE) {
[09:29:54.621]         base::sink(type = "output", split = FALSE)
[09:29:54.621]         if (TRUE) {
[09:29:54.621]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:29:54.621]         }
[09:29:54.621]         else {
[09:29:54.621]             ...future.result["stdout"] <- base::list(NULL)
[09:29:54.621]         }
[09:29:54.621]         base::close(...future.stdout)
[09:29:54.621]         ...future.stdout <- NULL
[09:29:54.621]     }
[09:29:54.621]     ...future.result$conditions <- ...future.conditions
[09:29:54.621]     ...future.result$finished <- base::Sys.time()
[09:29:54.621]     ...future.result
[09:29:54.621] }
[09:29:54.624] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[09:29:54.624] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[09:29:54.668] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[09:29:54.668] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[09:29:54.669] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[09:29:54.669] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[09:29:54.669] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[09:29:54.669] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[09:29:54.712] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[09:29:54.712] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[09:29:54.756] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[09:29:54.756] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[09:29:54.757] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.757] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[09:29:54.757] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[09:29:54.757] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[09:29:54.758] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.758] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[09:29:54.758] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[09:29:54.758] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[09:29:54.759] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.759] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[09:29:54.759] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[09:29:54.759] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[09:29:54.760] MultisessionFuture started
[09:29:54.760] - Launch lazy future ... done
[09:29:54.760] run() for ‘MultisessionFuture’ ... done
[09:29:54.760] Created future:
[09:29:54.762] receiveMessageFromWorker() for ClusterFuture ...
[09:29:54.762] - Validating connection of MultisessionFuture
[09:29:54.762] - received message: FutureResult
[09:29:54.762] - Received FutureResult
[09:29:54.762] - Erased future from FutureRegistry
[09:29:54.762] result() for ClusterFuture ...
[09:29:54.763] - result already collected: FutureResult
[09:29:54.763] result() for ClusterFuture ... done
[09:29:54.763] signalConditions() ...
[09:29:54.763]  - include = ‘immediateCondition’
[09:29:54.763]  - exclude = 
[09:29:54.763]  - resignal = FALSE
[09:29:54.763]  - Number of conditions: 1
[09:29:54.763] signalConditions() ... done
[09:29:54.763] receiveMessageFromWorker() for ClusterFuture ... done
[09:29:54.760] MultisessionFuture:
[09:29:54.760] Label: ‘future_vapply-2’
[09:29:54.760] Expression:
[09:29:54.760] {
[09:29:54.760]     do.call(function(...) {
[09:29:54.760]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[09:29:54.760]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[09:29:54.760]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[09:29:54.760]             on.exit(options(oopts), add = TRUE)
[09:29:54.760]         }
[09:29:54.760]         {
[09:29:54.760]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[09:29:54.760]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[09:29:54.760]                 ...future.FUN(...future.X_jj, ...)
[09:29:54.760]             })
[09:29:54.760]         }
[09:29:54.760]     }, args = future.call.arguments)
[09:29:54.760] }
[09:29:54.760] Lazy evaluation: FALSE
[09:29:54.760] Asynchronous evaluation: TRUE
[09:29:54.760] Local evaluation: TRUE
[09:29:54.760] Environment: R_GlobalEnv
[09:29:54.760] Capture standard output: TRUE
[09:29:54.760] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[09:29:54.760] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[09:29:54.760] Packages: 1 packages (‘future.apply’)
[09:29:54.760] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[09:29:54.760] Resolved: TRUE
[09:29:54.760] Value: <not collected>
[09:29:54.760] Conditions captured: <none>
[09:29:54.760] Early signaling: FALSE
[09:29:54.760] Owner process: 53b672ce-960e-6cad-8a78-3670d4e9d739
[09:29:54.760] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:29:54.763] Chunk #2 of 2 ... DONE
[09:29:54.764] Launching 2 futures (chunks) ... DONE
[09:29:54.764] Resolving 2 futures (chunks) ...
[09:29:54.764] resolve() on list ...
[09:29:54.764]  recursive: 0
[09:29:54.764]  length: 2
[09:29:54.764] 
[09:29:54.764] Future #1
[09:29:54.764] result() for ClusterFuture ...
[09:29:54.764] - result already collected: FutureResult
[09:29:54.764] result() for ClusterFuture ... done
[09:29:54.765] result() for ClusterFuture ...
[09:29:54.765] - result already collected: FutureResult
[09:29:54.765] result() for ClusterFuture ... done
[09:29:54.765] signalConditions() ...
[09:29:54.765]  - include = ‘immediateCondition’
[09:29:54.765]  - exclude = 
[09:29:54.765]  - resignal = FALSE
[09:29:54.765]  - Number of conditions: 1
[09:29:54.765] signalConditions() ... done
[09:29:54.765] signalConditionsASAP(MultisessionFuture, pos=1) ...
[09:29:54.765] - nx: 2
[09:29:54.765] - relay: TRUE
[09:29:54.766] - stdout: TRUE
[09:29:54.766] - signal: TRUE
[09:29:54.766] - resignal: FALSE
[09:29:54.766] - force: TRUE
[09:29:54.766] - relayed: [n=2] FALSE, FALSE
[09:29:54.766] - queued futures: [n=2] FALSE, FALSE
[09:29:54.766]  - until=1
[09:29:54.766]  - relaying element #1
[09:29:54.766] result() for ClusterFuture ...
[09:29:54.766] - result already collected: FutureResult
[09:29:54.766] result() for ClusterFuture ... done
[09:29:54.766] result() for ClusterFuture ...
[09:29:54.767] - result already collected: FutureResult
[09:29:54.767] result() for ClusterFuture ... done
[09:29:54.767] signalConditions() ...
[09:29:54.767]  - include = ‘immediateCondition’
[09:29:54.767]  - exclude = 
[09:29:54.767]  - resignal = FALSE
[09:29:54.767]  - Number of conditions: 1
[09:29:54.767] signalConditions() ... done
[09:29:54.767] result() for ClusterFuture ...
[09:29:54.767] - result already collected: FutureResult
[09:29:54.767] result() for ClusterFuture ... done
[09:29:54.768] signalConditions() ...
[09:29:54.768]  - include = ‘immediateCondition’
[09:29:54.768]  - exclude = 
[09:29:54.768]  - resignal = FALSE
[09:29:54.768]  - Number of conditions: 1
[09:29:54.768] signalConditions() ... done
[09:29:54.768] result() for ClusterFuture ...
[09:29:54.768] - result already collected: FutureResult
[09:29:54.768] result() for ClusterFuture ... done
[09:29:54.768] signalConditions() ...
[09:29:54.768]  - include = ‘condition’
[09:29:54.768]  - exclude = ‘immediateCondition’
[09:29:54.769]  - resignal = TRUE
[09:29:54.769]  - Number of conditions: 1
[09:29:54.769]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[09:29:54.769] signalConditions() ... done
[09:29:54.769] - relayed: [n=2] FALSE, FALSE
[09:29:54.769] - queued futures: [n=2] TRUE, FALSE
[09:29:54.769] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[09:29:54.769] plan(): Setting new future strategy stack:
[09:29:54.769] List of future strategies:
[09:29:54.769] 1. sequential:
[09:29:54.769]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:54.769]    - tweaked: FALSE
[09:29:54.769]    - call: plan(sequential)
[09:29:54.770] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[09:29:54.771] plan(): Setting new future strategy stack:
[09:29:54.771] List of future strategies:
[09:29:54.771] 1. FutureStrategy:
[09:29:54.771]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:29:54.771]    - tweaked: FALSE
[09:29:54.771]    - call: future::plan(oplan)
[09:29:54.772] plan(): nbrOfWorkers() = 1
> 
